# Python知识体系上下文提醒系统

## 目录

- [Python知识体系上下文提醒系统](#python知识体系上下文提醒系统)
  - [目录](#目录)
  - [概述](#概述)
    - [系统架构概览](#系统架构概览)
  - [上下文管理架构](#上下文管理架构)
    - [知识上下文模型](#知识上下文模型)
  - [知识图谱构建](#知识图谱构建)
    - [知识关系建模](#知识关系建模)
  - [智能提醒机制](#智能提醒机制)
    - [个性化推荐系统](#个性化推荐系统)
  - [相关主题](#相关主题)

---

## 概述

Python知识体系上下文提醒系统是一个智能化的知识管理和学习辅助系统，
通过构建完整的知识图谱、智能提醒机制和持续学习系统，
帮助开发者高效掌握Python生态系统。

### 系统架构概览

```python
# 上下文提醒系统架构
context_reminder_system = {
    "core_components": {
        "knowledge_graph": {
            "description": "知识图谱构建与管理",
            "features": ["概念关系", "依赖映射", "学习路径", "知识更新"],
            "components": ["节点管理", "关系建模", "图遍历", "路径优化"]
        },
        "reminder_engine": {
            "description": "智能提醒引擎",
            "features": ["上下文感知", "个性化推荐", "学习提醒", "进度跟踪"],
            "components": ["规则引擎", "推荐算法", "通知系统", "用户画像"]
        },
        "learning_system": {
            "description": "持续学习系统",
            "features": ["自适应学习", "知识更新", "技能评估", "学习路径"],
            "components": ["学习算法", "评估模型", "路径规划", "进度监控"]
        },
        "quality_assurance": {
            "description": "质量保证体系",
            "features": ["内容验证", "一致性检查", "更新监控", "质量评分"],
            "components": ["验证规则", "检查引擎", "评分系统", "报告生成"]
        }
    },
    "data_flow": {
        "input": "知识输入与更新",
        "processing": "知识处理与建模",
        "storage": "知识存储与管理",
        "output": "提醒与推荐输出"
    },
    "integration_points": {
        "external_sources": "外部知识源集成",
        "user_interaction": "用户交互接口",
        "system_monitoring": "系统监控与维护"
    }
}
```

---

## 上下文管理架构

### 知识上下文模型

```python
# 知识上下文模型
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any
from datetime import datetime, timedelta
from enum import Enum
import json

class KnowledgeLevel(Enum):
    """知识水平枚举"""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"

class LearningStatus(Enum):
    """学习状态枚举"""
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    REVIEW_NEEDED = "review_needed"

@dataclass
class KnowledgeNode:
    """知识节点"""
    id: str
    title: str
    description: str
    level: KnowledgeLevel
    category: str
    tags: Set[str] = field(default_factory=set)
    prerequisites: Set[str] = field(default_factory=set)
    dependencies: Set[str] = field(default_factory=set)
    related_concepts: Set[str] = field(default_factory=set)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    difficulty_score: float = 0.0
    importance_score: float = 0.0
    learning_time_estimate: int = 0  # 分钟

@dataclass
class LearningPath:
    """学习路径"""
    id: str
    name: str
    description: str
    target_level: KnowledgeLevel
    nodes: List[str]  # 知识节点ID列表
    estimated_duration: int  # 总学习时间（分钟）
    prerequisites: Set[str] = field(default_factory=set)
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class UserProfile:
    """用户画像"""
    user_id: str
    current_level: KnowledgeLevel
    learning_goals: Set[str] = field(default_factory=set)
    completed_nodes: Set[str] = field(default_factory=set)
    in_progress_nodes: Set[str] = field(default_factory=set)
    learning_preferences: Dict[str, Any] = field(default_factory=dict)
    last_activity: datetime = field(default_factory=datetime.now)
    learning_streak: int = 0
    total_learning_time: int = 0  # 总学习时间（分钟）

@dataclass
class ContextReminder:
    """上下文提醒"""
    id: str
    user_id: str
    node_id: str
    reminder_type: str
    message: str
    priority: int  # 1-10，10为最高优先级
    scheduled_time: datetime
    is_read: bool = False
    created_at: datetime = field(default_factory=datetime.now)

class ContextManager:
    """上下文管理器"""
    
    def __init__(self):
        self.knowledge_nodes: Dict[str, KnowledgeNode] = {}
        self.learning_paths: Dict[str, LearningPath] = {}
        self.user_profiles: Dict[str, UserProfile] = {}
        self.reminders: List[ContextReminder] = []
        self.knowledge_graph: Dict[str, Set[str]] = {}  # 邻接表表示
    
    def add_knowledge_node(self, node: KnowledgeNode):
        """添加知识节点"""
        self.knowledge_nodes[node.id] = node
        
        # 更新知识图谱
        self.knowledge_graph[node.id] = set()
        for related_id in node.related_concepts:
            if related_id in self.knowledge_nodes:
                self.knowledge_graph[node.id].add(related_id)
                self.knowledge_graph[related_id].add(node.id)
    
    def create_learning_path(self, path: LearningPath):
        """创建学习路径"""
        self.learning_paths[path.id] = path
        
        # 验证路径的可行性
        self._validate_learning_path(path)
    
    def _validate_learning_path(self, path: LearningPath):
        """验证学习路径的可行性"""
        for i, node_id in enumerate(path.nodes):
            if node_id not in self.knowledge_nodes:
                raise ValueError(f"知识节点 {node_id} 不存在")
            
            node = self.knowledge_nodes[node_id]
            
            # 检查前置条件
            for prereq in node.prerequisites:
                if prereq not in path.nodes[:i]:
                    raise ValueError(f"节点 {node_id} 的前置条件 {prereq} 未满足")
    
    def get_learning_path_for_user(self, user_id: str, target_level: KnowledgeLevel) -> Optional[LearningPath]:
        """为用户生成学习路径"""
        if user_id not in self.user_profiles:
            return None
        
        user = self.user_profiles[user_id]
        
        # 找到适合的学习路径
        suitable_paths = [
            path for path in self.learning_paths.values()
            if path.target_level == target_level and 
            all(prereq in user.completed_nodes for prereq in path.prerequisites)
        ]
        
        if not suitable_paths:
            return None
        
        # 选择最适合的路径（基于用户当前水平）
        best_path = min(suitable_paths, key=lambda p: abs(
            self._calculate_path_difficulty(p) - self._get_user_difficulty_level(user)
        ))
        
        return best_path
    
    def _calculate_path_difficulty(self, path: LearningPath) -> float:
        """计算学习路径难度"""
        if not path.nodes:
            return 0.0
        
        total_difficulty = sum(
            self.knowledge_nodes[node_id].difficulty_score
            for node_id in path.nodes
            if node_id in self.knowledge_nodes
        )
        
        return total_difficulty / len(path.nodes)
    
    def _get_user_difficulty_level(self, user: UserProfile) -> float:
        """获取用户难度水平"""
        if not user.completed_nodes:
            return 0.0
        
        total_difficulty = sum(
            self.knowledge_nodes[node_id].difficulty_score
            for node_id in user.completed_nodes
            if node_id in self.knowledge_nodes
        )
        
        return total_difficulty / len(user.completed_nodes)
    
    def generate_reminders(self, user_id: str) -> List[ContextReminder]:
        """生成上下文提醒"""
        if user_id not in self.user_profiles:
            return []
        
        user = self.user_profiles[user_id]
        reminders = []
        
        # 1. 学习进度提醒
        progress_reminders = self._generate_progress_reminders(user)
        reminders.extend(progress_reminders)
        
        # 2. 复习提醒
        review_reminders = self._generate_review_reminders(user)
        reminders.extend(review_reminders)
        
        # 3. 新知识推荐
        recommendation_reminders = self._generate_recommendation_reminders(user)
        reminders.extend(recommendation_reminders)
        
        # 4. 学习路径提醒
        path_reminders = self._generate_path_reminders(user)
        reminders.extend(path_reminders)
        
        return reminders
    
    def _generate_progress_reminders(self, user: UserProfile) -> List[ContextReminder]:
        """生成学习进度提醒"""
        reminders = []
        
        # 检查长时间未学习的节点
        for node_id in user.in_progress_nodes:
            node = self.knowledge_nodes.get(node_id)
            if not node:
                continue
            
            # 如果超过3天未学习，生成提醒
            if datetime.now() - user.last_activity > timedelta(days=3):
                reminder = ContextReminder(
                    id=f"progress_{node_id}_{user.user_id}",
                    user_id=user.user_id,
                    node_id=node_id,
                    reminder_type="progress",
                    message=f"继续学习 {node.title}",
                    priority=7,
                    scheduled_time=datetime.now()
                )
                reminders.append(reminder)
        
        return reminders
    
    def _generate_review_reminders(self, user: UserProfile) -> List[ContextReminder]:
        """生成复习提醒"""
        reminders = []
        
        # 基于遗忘曲线生成复习提醒
        for node_id in user.completed_nodes:
            node = self.knowledge_nodes.get(node_id)
            if not node:
                continue
            
            # 计算复习间隔（简化版遗忘曲线）
            review_intervals = [1, 3, 7, 14, 30]  # 天
            
            for interval in review_intervals:
                # 这里应该基于实际完成时间计算，简化处理
                if datetime.now() - user.last_activity > timedelta(days=interval):
                    reminder = ContextReminder(
                        id=f"review_{node_id}_{interval}_{user.user_id}",
                        user_id=user.user_id,
                        node_id=node_id,
                        reminder_type="review",
                        message=f"复习 {node.title}",
                        priority=5,
                        scheduled_time=datetime.now()
                    )
                    reminders.append(reminder)
                    break
        
        return reminders
    
    def _generate_recommendation_reminders(self, user: UserProfile) -> List[ContextReminder]:
        """生成新知识推荐提醒"""
        reminders = []
        
        # 基于用户兴趣和当前水平推荐新知识
        recommended_nodes = self._get_recommended_nodes(user)
        
        for node_id in recommended_nodes[:3]:  # 最多推荐3个
            node = self.knowledge_nodes[node_id]
            reminder = ContextReminder(
                id=f"recommendation_{node_id}_{user.user_id}",
                user_id=user.user_id,
                node_id=node_id,
                reminder_type="recommendation",
                message=f"推荐学习 {node.title}",
                priority=6,
                scheduled_time=datetime.now()
            )
            reminders.append(reminder)
        
        return reminders
    
    def _generate_path_reminders(self, user: UserProfile) -> List[ContextReminder]:
        """生成学习路径提醒"""
        reminders = []
        
        # 检查用户是否有未完成的学习路径
        for path in self.learning_paths.values():
            if all(prereq in user.completed_nodes for prereq in path.prerequisites):
                # 找到路径中下一个未完成的节点
                next_node = None
                for node_id in path.nodes:
                    if node_id not in user.completed_nodes and node_id not in user.in_progress_nodes:
                        next_node = node_id
                        break
                
                if next_node:
                    node = self.knowledge_nodes[next_node]
                    reminder = ContextReminder(
                        id=f"path_{path.id}_{next_node}_{user.user_id}",
                        user_id=user.user_id,
                        node_id=next_node,
                        reminder_type="path",
                        message=f"学习路径 {path.name} 的下一步：{node.title}",
                        priority=8,
                        scheduled_time=datetime.now()
                    )
                    reminders.append(reminder)
        
        return reminders
    
    def _get_recommended_nodes(self, user: UserProfile) -> List[str]:
        """获取推荐的知识节点"""
        # 基于用户当前水平和兴趣推荐
        suitable_nodes = []
        
        for node_id, node in self.knowledge_nodes.items():
            if node_id in user.completed_nodes or node_id in user.in_progress_nodes:
                continue
            
            # 检查前置条件
            if not all(prereq in user.completed_nodes for prereq in node.prerequisites):
                continue
            
            # 计算推荐分数
            score = self._calculate_recommendation_score(node, user)
            suitable_nodes.append((node_id, score))
        
        # 按分数排序
        suitable_nodes.sort(key=lambda x: x[1], reverse=True)
        return [node_id for node_id, _ in suitable_nodes]
    
    def _calculate_recommendation_score(self, node: KnowledgeNode, user: UserProfile) -> float:
        """计算推荐分数"""
        score = 0.0
        
        # 基于重要性
        score += node.importance_score * 0.3
        
        # 基于难度匹配
        user_level = self._get_user_difficulty_level(user)
        difficulty_match = 1.0 - abs(node.difficulty_score - user_level)
        score += difficulty_match * 0.4
        
        # 基于学习目标
        if any(goal in node.tags for goal in user.learning_goals):
            score += 0.3
        
        return score
```

---

## 知识图谱构建

### 知识关系建模

```python
# 知识关系建模
class KnowledgeGraphBuilder:
    """知识图谱构建器"""
    
    def __init__(self):
        self.graph = {}
        self.node_attributes = {}
        self.edge_attributes = {}
    
    def add_node(self, node_id: str, attributes: Dict[str, Any]):
        """添加节点"""
        self.graph[node_id] = set()
        self.node_attributes[node_id] = attributes
    
    def add_edge(self, from_node: str, to_node: str, relationship: str, weight: float = 1.0):
        """添加边"""
        if from_node not in self.graph:
            self.graph[from_node] = set()
        if to_node not in self.graph:
            self.graph[to_node] = set()
        
        self.graph[from_node].add(to_node)
        
        edge_key = (from_node, to_node)
        self.edge_attributes[edge_key] = {
            'relationship': relationship,
            'weight': weight
        }
    
    def find_shortest_path(self, start: str, end: str) -> List[str]:
        """查找最短路径"""
        if start not in self.graph or end not in self.graph:
            return []
        
        # 使用BFS查找最短路径
        queue = [(start, [start])]
        visited = {start}
        
        while queue:
            current, path = queue.pop(0)
            
            if current == end:
                return path
            
            for neighbor in self.graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return []
    
    def get_related_concepts(self, node_id: str, depth: int = 2) -> Set[str]:
        """获取相关概念"""
        if node_id not in self.graph:
            return set()
        
        related = set()
        current_level = {node_id}
        
        for _ in range(depth):
            next_level = set()
            for node in current_level:
                if node in self.graph:
                    next_level.update(self.graph[node])
            related.update(next_level)
            current_level = next_level
        
        related.discard(node_id)  # 移除自身
        return related
    
    def calculate_centrality(self, node_id: str) -> float:
        """计算节点中心性"""
        if node_id not in self.graph:
            return 0.0
        
        # 简化的度中心性计算
        degree = len(self.graph[node_id])
        total_nodes = len(self.graph)
        
        return degree / (total_nodes - 1) if total_nodes > 1 else 0.0
    
    def export_graph(self) -> Dict[str, Any]:
        """导出图谱"""
        return {
            'nodes': [
                {
                    'id': node_id,
                    'attributes': self.node_attributes.get(node_id, {})
                }
                for node_id in self.graph.keys()
            ],
            'edges': [
                {
                    'from': from_node,
                    'to': to_node,
                    'attributes': self.edge_attributes.get((from_node, to_node), {})
                }
                for from_node, neighbors in self.graph.items()
                for to_node in neighbors
            ]
        }

# Python知识图谱构建示例
class PythonKnowledgeGraph:
    """Python知识图谱"""
    
    def __init__(self):
        self.builder = KnowledgeGraphBuilder()
        self._build_python_knowledge_graph()
    
    def _build_python_knowledge_graph(self):
        """构建Python知识图谱"""
        
        # 基础概念节点
        basic_concepts = {
            'python_basics': {
                'title': 'Python基础',
                'level': 'beginner',
                'category': 'language',
                'difficulty': 1.0,
                'importance': 9.0
            },
            'variables': {
                'title': '变量与数据类型',
                'level': 'beginner',
                'category': 'language',
                'difficulty': 1.0,
                'importance': 8.0
            },
            'control_flow': {
                'title': '控制流程',
                'level': 'beginner',
                'category': 'language',
                'difficulty': 2.0,
                'importance': 8.0
            },
            'functions': {
                'title': '函数',
                'level': 'beginner',
                'category': 'language',
                'difficulty': 2.5,
                'importance': 9.0
            },
            'classes': {
                'title': '类与对象',
                'level': 'intermediate',
                'category': 'language',
                'difficulty': 4.0,
                'importance': 8.0
            },
            'async_programming': {
                'title': '异步编程',
                'level': 'advanced',
                'category': 'language',
                'difficulty': 6.0,
                'importance': 7.0
            }
        }
        
        # 添加节点
        for concept_id, attributes in basic_concepts.items():
            self.builder.add_node(concept_id, attributes)
        
        # 添加关系
        relationships = [
            ('python_basics', 'variables', 'prerequisite', 1.0),
            ('python_basics', 'control_flow', 'prerequisite', 1.0),
            ('variables', 'functions', 'prerequisite', 0.8),
            ('control_flow', 'functions', 'prerequisite', 0.8),
            ('functions', 'classes', 'prerequisite', 0.9),
            ('classes', 'async_programming', 'prerequisite', 0.7),
            ('functions', 'async_programming', 'related', 0.6)
        ]
        
        for from_node, to_node, relationship, weight in relationships:
            self.builder.add_edge(from_node, to_node, relationship, weight)
    
    def get_learning_path(self, start_level: str, target_level: str) -> List[str]:
        """获取学习路径"""
        # 根据水平映射到具体节点
        level_mapping = {
            'beginner': 'python_basics',
            'intermediate': 'classes',
            'advanced': 'async_programming'
        }
        
        start_node = level_mapping.get(start_level, 'python_basics')
        target_node = level_mapping.get(target_level, 'async_programming')
        
        return self.builder.find_shortest_path(start_node, target_node)
    
    def get_recommendations(self, current_concept: str, max_recommendations: int = 5) -> List[str]:
        """获取推荐概念"""
        related = self.builder.get_related_concepts(current_concept, depth=2)
        
        # 按重要性排序
        recommendations = []
        for concept in related:
            if concept in self.builder.node_attributes:
                importance = self.builder.node_attributes[concept].get('importance', 0)
                recommendations.append((concept, importance))
        
        recommendations.sort(key=lambda x: x[1], reverse=True)
        return [concept for concept, _ in recommendations[:max_recommendations]]
```

---

## 智能提醒机制

### 个性化推荐系统

```python
# 个性化推荐系统
class PersonalizedRecommendationSystem:
    """个性化推荐系统"""
    
    def __init__(self, context_manager: ContextManager):
        self.context_manager = context_manager
        self.user_behavior_history = {}
        self.recommendation_models = {}
    
    def track_user_behavior(self, user_id: str, action: str, node_id: str, timestamp: datetime):
        """跟踪用户行为"""
        if user_id not in self.user_behavior_history:
            self.user_behavior_history[user_id] = []
        
        self.user_behavior_history[user_id].append({
            'action': action,
            'node_id': node_id,
            'timestamp': timestamp
        })
    
    def generate_personalized_recommendations(self, user_id: str) -> List[Dict[str, Any]]:
        """生成个性化推荐"""
        if user_id not in self.user_profiles:
            return []
        
        user = self.context_manager.user_profiles[user_id]
        recommendations = []
        
        # 1. 基于学习历史的推荐
        history_recommendations = self._get_history_based_recommendations(user_id)
        recommendations.extend(history_recommendations)
        
        # 2. 基于协同过滤的推荐
        collaborative_recommendations = self._get_collaborative_recommendations(user_id)
        recommendations.extend(collaborative_recommendations)
        
        # 3. 基于内容的推荐
        content_recommendations = self._get_content_based_recommendations(user_id)
        recommendations.extend(content_recommendations)
        
        # 4. 基于学习目标的推荐
        goal_recommendations = self._get_goal_based_recommendations(user_id)
        recommendations.extend(goal_recommendations)
        
        # 去重并排序
        unique_recommendations = self._deduplicate_and_rank(recommendations)
        
        return unique_recommendations[:10]  # 返回前10个推荐
    
    def _get_history_based_recommendations(self, user_id: str) -> List[Dict[str, Any]]:
        """基于学习历史的推荐"""
        if user_id not in self.user_behavior_history:
            return []
        
        history = self.user_behavior_history[user_id]
        recent_actions = [action for action in history if 
                         datetime.now() - action['timestamp'] < timedelta(days=30)]
        
        # 分析用户兴趣
        interest_tags = set()
        for action in recent_actions:
            node_id = action['node_id']
            if node_id in self.context_manager.knowledge_nodes:
                node = self.context_manager.knowledge_nodes[node_id]
                interest_tags.update(node.tags)
        
        # 基于兴趣推荐
        recommendations = []
        for node_id, node in self.context_manager.knowledge_nodes.items():
            if node_id in self.context_manager.user_profiles[user_id].completed_nodes:
                continue
            
            # 计算兴趣匹配度
            match_score = len(interest_tags.intersection(node.tags)) / len(interest_tags) if interest_tags else 0
            
            if match_score > 0.3:
                recommendations.append({
                    'node_id': node_id,
                    'title': node.title,
                    'score': match_score,
                    'reason': '基于学习历史兴趣匹配'
                })
        
        return recommendations
    
    def _get_collaborative_recommendations(self, user_id: str) -> List[Dict[str, Any]]:
        """基于协同过滤的推荐"""
        # 简化版协同过滤
        user = self.context_manager.user_profiles[user_id]
        similar_users = self._find_similar_users(user_id)
        
        recommendations = []
        for similar_user_id in similar_users:
            similar_user = self.context_manager.user_profiles[similar_user_id]
            
            # 找到相似用户学习过但当前用户未学习的节点
            for node_id in similar_user.completed_nodes:
                if node_id not in user.completed_nodes and node_id not in user.in_progress_nodes:
                    node = self.context_manager.knowledge_nodes.get(node_id)
                    if node:
                        recommendations.append({
                            'node_id': node_id,
                            'title': node.title,
                            'score': 0.7,  # 简化评分
                            'reason': f'相似用户 {similar_user_id} 已学习'
                        })
        
        return recommendations
    
    def _get_content_based_recommendations(self, user_id: str) -> List[Dict[str, Any]]:
        """基于内容的推荐"""
        user = self.context_manager.user_profiles[user_id]
        recommendations = []
        
        # 基于用户当前水平推荐
        for node_id, node in self.context_manager.knowledge_nodes.items():
            if node_id in user.completed_nodes or node_id in user.in_progress_nodes:
                continue
            
            # 检查前置条件
            if not all(prereq in user.completed_nodes for prereq in node.prerequisites):
                continue
            
            # 计算内容匹配度
            content_score = self._calculate_content_score(node, user)
            
            if content_score > 0.5:
                recommendations.append({
                    'node_id': node_id,
                    'title': node.title,
                    'score': content_score,
                    'reason': '基于内容匹配度'
                })
        
        return recommendations
    
    def _get_goal_based_recommendations(self, user_id: str) -> List[Dict[str, Any]]:
        """基于学习目标的推荐"""
        user = self.context_manager.user_profiles[user_id]
        recommendations = []
        
        for node_id, node in self.context_manager.knowledge_nodes.items():
            if node_id in user.completed_nodes or node_id in user.in_progress_nodes:
                continue
            
            # 检查是否与学习目标相关
            goal_match = any(goal in node.tags for goal in user.learning_goals)
            
            if goal_match:
                recommendations.append({
                    'node_id': node_id,
                    'title': node.title,
                    'score': 0.8,
                    'reason': '与学习目标相关'
                })
        
        return recommendations
    
    def _find_similar_users(self, user_id: str) -> List[str]:
        """找到相似用户"""
        user = self.context_manager.user_profiles[user_id]
        similar_users = []
        
        for other_user_id, other_user in self.context_manager.user_profiles.items():
            if other_user_id == user_id:
                continue
            
            # 计算相似度（基于已完成节点）
            common_nodes = len(user.completed_nodes.intersection(other_user.completed_nodes))
            total_nodes = len(user.completed_nodes.union(other_user.completed_nodes))
            
            if total_nodes > 0:
                similarity = common_nodes / total_nodes
                if similarity > 0.3:
                    similar_users.append(other_user_id)
        
        return similar_users
    
    def _calculate_content_score(self, node: KnowledgeNode, user: UserProfile) -> float:
        """计算内容匹配度"""
        score = 0.0
        
        # 基于难度匹配
        user_level = self.context_manager._get_user_difficulty_level(user)
        difficulty_match = 1.0 - abs(node.difficulty_score - user_level)
        score += difficulty_match * 0.4
        
        # 基于重要性
        score += node.importance_score * 0.3
        
        # 基于学习目标
        if any(goal in node.tags for goal in user.learning_goals):
            score += 0.3
        
        return score
    
    def _deduplicate_and_rank(self, recommendations: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """去重并排序"""
        # 去重
        unique_recommendations = {}
        for rec in recommendations:
            node_id = rec['node_id']
            if node_id not in unique_recommendations or rec['score'] > unique_recommendations[node_id]['score']:
                unique_recommendations[node_id] = rec
        
        # 排序
        sorted_recommendations = sorted(
            unique_recommendations.values(),
            key=lambda x: x['score'],
            reverse=True
        )
        
        return sorted_recommendations
```

---

## 相关主题

- [Python语言新特性](./../../01-语言与生态/迁移/01-语言新特性.md)
- [Python技术栈2025](./../../01-语言与生态/迁移/02-技术栈2025.md)
- [质量检查](./../../02-测试与质量/迁移/质量检查.md)
- [项目管理](./../../03-工程与交付/迁移/项目管理.md)
- [现代Web框架](./../../05-Web开发/迁移/现代Web框架.md)
- [数据分析与机器学习](./../../06-数据科学/迁移/数据分析与机器学习.md)
- [异步编程模式](./../../04-并发与异步/迁移/异步编程模式.md)

---

**系统完成**: 所有核心模块已构建完成，形成完整的Python知识体系上下文提醒系统
