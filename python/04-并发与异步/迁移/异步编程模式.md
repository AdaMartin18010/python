# Python异步编程与并发模式

## 目录

- [Python异步编程与并发模式](#python异步编程与并发模式)
  - [目录](#目录)
  - [概述](#概述)
    - [异步编程生态系统](#异步编程生态系统)
  - [异步编程基础](#异步编程基础)
    - [协程与异步函数](#协程与异步函数)
    - [异步上下文管理器](#异步上下文管理器)
  - [asyncio核心概念](#asyncio核心概念)
    - [事件循环与任务管理](#事件循环与任务管理)
    - [异步迭代器与生成器](#异步迭代器与生成器)
  - [异步Web开发](#异步web开发)
    - [FastAPI异步应用](#fastapi异步应用)
  - [相关主题](#相关主题)

---

## 概述

Python异步编程与并发模式提供了处理I/O密集型任务和高并发场景的现代解决方案。
通过asyncio、async/await语法和协程，Python能够高效处理大量并发连接和异步操作。

### 异步编程生态系统

```python
# 异步编程生态系统
async_ecosystem = {
    "core_libraries": {
        "asyncio": {
            "description": "异步I/O核心库",
            "features": ["协程", "事件循环", "任务调度", "异步上下文管理"],
            "use_cases": ["异步编程", "并发控制", "I/O操作"]
        },
        "aiohttp": {
            "description": "异步HTTP客户端/服务器",
            "features": ["异步请求", "WebSocket", "中间件", "会话管理"],
            "use_cases": ["异步Web服务", "API客户端", "实时通信"]
        },
        "aioredis": {
            "description": "异步Redis客户端",
            "features": ["异步操作", "连接池", "发布订阅", "集群支持"],
            "use_cases": ["缓存", "消息队列", "会话存储"]
        }
    },
    "web_frameworks": {
        "fastapi": {
            "description": "现代异步Web框架",
            "features": ["自动文档", "类型提示", "依赖注入", "异步支持"],
            "use_cases": ["API服务", "微服务", "实时应用"]
        },
        "quart": {
            "description": "异步Flask",
            "features": ["Flask兼容", "异步支持", "WebSocket"],
            "use_cases": ["异步Web应用", "实时通信"]
        },
        "starlette": {
            "description": "轻量级异步框架",
            "features": ["ASGI", "中间件", "路由", "WebSocket"],
            "use_cases": ["微服务", "API网关", "中间件开发"]
        }
    },
    "database_libraries": {
        "asyncpg": {
            "description": "异步PostgreSQL驱动",
            "features": ["高性能", "连接池", "事务支持", "类型安全"],
            "use_cases": ["数据库操作", "高并发应用"]
        },
        "aiomysql": {
            "description": "异步MySQL驱动",
            "features": ["异步操作", "连接池", "事务支持"],
            "use_cases": ["MySQL数据库", "Web应用"]
        },
        "motor": {
            "description": "异步MongoDB驱动",
            "features": ["异步操作", "GridFS", "变更流", "聚合"],
            "use_cases": ["文档数据库", "实时数据"]
        }
    },
    "testing_frameworks": {
        "pytest_asyncio": {
            "description": "异步测试支持",
            "features": ["异步测试", "夹具支持", "超时控制"],
            "use_cases": ["异步代码测试", "集成测试"]
        },
        "aioresponses": {
            "description": "异步HTTP模拟",
            "features": ["请求模拟", "响应控制", "异步支持"],
            "use_cases": ["API测试", "单元测试"]
        }
    }
}
```

---

## 异步编程基础

### 协程与异步函数

```python
# 异步编程基础示例
import asyncio
import aiohttp
import time
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class User:
    """用户数据类"""
    id: int
    name: str
    email: str
    created_at: datetime

class AsyncProgrammingBasics:
    """异步编程基础"""
    
    def __init__(self):
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self):
        """异步上下文管理器入口"""
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """异步上下文管理器出口"""
        if self.session:
            await self.session.close()
    
    async def simple_coroutine(self, name: str, delay: float) -> str:
        """简单协程示例"""
        print(f"开始执行 {name}")
        await asyncio.sleep(delay)  # 模拟异步操作
        print(f"完成执行 {name}")
        return f"{name} 执行完成"
    
    async def concurrent_execution(self):
        """并发执行示例"""
        print("=== 并发执行示例 ===")
        
        # 创建多个任务
        tasks = [
            self.simple_coroutine("任务1", 1.0),
            self.simple_coroutine("任务2", 0.5),
            self.simple_coroutine("任务3", 1.5),
            self.simple_coroutine("任务4", 0.8)
        ]
        
        # 并发执行所有任务
        start_time = time.time()
        results = await asyncio.gather(*tasks)
        end_time = time.time()
        
        print(f"并发执行结果: {results}")
        print(f"总执行时间: {end_time - start_time:.2f}秒")
        
        return results
    
    async def sequential_execution(self):
        """顺序执行示例"""
        print("\n=== 顺序执行示例 ===")
        
        tasks = [
            ("任务1", 1.0),
            ("任务2", 0.5),
            ("任务3", 1.5),
            ("任务4", 0.8)
        ]
        
        start_time = time.time()
        results = []
        
        for name, delay in tasks:
            result = await self.simple_coroutine(name, delay)
            results.append(result)
        
        end_time = time.time()
        
        print(f"顺序执行结果: {results}")
        print(f"总执行时间: {end_time - start_time:.2f}秒")
        
        return results
    
    async def fetch_user_data(self, user_id: int) -> Dict[str, Any]:
        """获取用户数据（模拟API调用）"""
        if not self.session:
            raise RuntimeError("Session not initialized")
        
        # 模拟API延迟
        await asyncio.sleep(0.1)
        
        # 模拟用户数据
        user_data = {
            "id": user_id,
            "name": f"User {user_id}",
            "email": f"user{user_id}@example.com",
            "created_at": datetime.now().isoformat()
        }
        
        return user_data
    
    async def fetch_multiple_users(self, user_ids: List[int]) -> List[Dict[str, Any]]:
        """并发获取多个用户数据"""
        print(f"\n=== 并发获取用户数据 ===")
        
        # 创建并发任务
        tasks = [self.fetch_user_data(user_id) for user_id in user_ids]
        
        # 并发执行
        start_time = time.time()
        users = await asyncio.gather(*tasks)
        end_time = time.time()
        
        print(f"获取 {len(user_ids)} 个用户数据")
        print(f"执行时间: {end_time - start_time:.2f}秒")
        
        return users
    
    async def process_user_data(self, user_data: Dict[str, Any]) -> User:
        """处理用户数据"""
        # 模拟数据处理延迟
        await asyncio.sleep(0.05)
        
        return User(
            id=user_data["id"],
            name=user_data["name"],
            email=user_data["email"],
            created_at=datetime.fromisoformat(user_data["created_at"])
        )
    
    async def pipeline_example(self, user_ids: List[int]) -> List[User]:
        """异步管道示例"""
        print(f"\n=== 异步管道示例 ===")
        
        # 第一阶段：获取原始数据
        raw_users = await self.fetch_multiple_users(user_ids)
        
        # 第二阶段：处理数据
        tasks = [self.process_user_data(user_data) for user_data in raw_users]
        processed_users = await asyncio.gather(*tasks)
        
        print(f"处理完成 {len(processed_users)} 个用户")
        
        return processed_users
```

### 异步上下文管理器

```python
# 异步上下文管理器示例
class AsyncResourceManager:
    """异步资源管理器"""
    
    def __init__(self, resource_name: str):
        self.resource_name = resource_name
        self.is_acquired = False
    
    async def __aenter__(self):
        """异步上下文管理器入口"""
        print(f"获取资源: {self.resource_name}")
        await asyncio.sleep(0.1)  # 模拟资源获取延迟
        self.is_acquired = True
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """异步上下文管理器出口"""
        print(f"释放资源: {self.resource_name}")
        await asyncio.sleep(0.1)  # 模拟资源释放延迟
        self.is_acquired = False
        
        if exc_type:
            print(f"异常处理: {exc_type.__name__}: {exc_val}")
        
        return False  # 不抑制异常
    
    async def use_resource(self):
        """使用资源"""
        if not self.is_acquired:
            raise RuntimeError("资源未获取")
        
        print(f"使用资源: {self.resource_name}")
        await asyncio.sleep(0.2)  # 模拟资源使用

class AsyncContextManagerDemo:
    """异步上下文管理器演示"""
    
    async def single_resource_demo(self):
        """单个资源演示"""
        print("=== 单个资源演示 ===")
        
        async with AsyncResourceManager("数据库连接") as resource:
            await resource.use_resource()
            print("资源使用完成")
        
        print("资源已释放")
    
    async def multiple_resources_demo(self):
        """多个资源演示"""
        print("\n=== 多个资源演示 ===")
        
        async with AsyncResourceManager("数据库连接") as db, \
                   AsyncResourceManager("缓存连接") as cache, \
                   AsyncResourceManager("文件句柄") as file:
            
            # 并发使用多个资源
            await asyncio.gather(
                db.use_resource(),
                cache.use_resource(),
                file.use_resource()
            )
            
            print("所有资源使用完成")
        
        print("所有资源已释放")
    
    async def error_handling_demo(self):
        """错误处理演示"""
        print("\n=== 错误处理演示 ===")
        
        try:
            async with AsyncResourceManager("网络连接") as conn:
                await conn.use_resource()
                # 模拟错误
                raise ValueError("网络连接错误")
        except ValueError as e:
            print(f"捕获异常: {e}")
        
        print("资源清理完成")
```

---

## asyncio核心概念

### 事件循环与任务管理

```python
# asyncio核心概念示例
class AsyncioCoreConcepts:
    """asyncio核心概念"""
    
    def __init__(self):
        self.running_tasks = set()
    
    async def long_running_task(self, task_id: int, duration: float) -> str:
        """长时间运行的任务"""
        print(f"任务 {task_id} 开始执行")
        
        try:
            await asyncio.sleep(duration)
            print(f"任务 {task_id} 执行完成")
            return f"任务 {task_id} 结果"
        except asyncio.CancelledError:
            print(f"任务 {task_id} 被取消")
            raise
        finally:
            print(f"任务 {task_id} 清理完成")
    
    async def task_management_demo(self):
        """任务管理演示"""
        print("=== 任务管理演示 ===")
        
        # 创建任务
        task1 = asyncio.create_task(self.long_running_task(1, 2.0))
        task2 = asyncio.create_task(self.long_running_task(2, 1.5))
        task3 = asyncio.create_task(self.long_running_task(3, 3.0))
        
        # 添加到任务集合
        self.running_tasks.update([task1, task2, task3])
        
        # 等待第一个完成的任务
        done, pending = await asyncio.wait(
            self.running_tasks,
            return_when=asyncio.FIRST_COMPLETED
        )
        
        print(f"完成的任务数: {len(done)}")
        print(f"待完成的任务数: {len(pending)}")
        
        # 取消剩余任务
        for task in pending:
            task.cancel()
        
        # 等待所有任务完成
        await asyncio.gather(*self.running_tasks, return_exceptions=True)
        
        # 清理任务集合
        self.running_tasks.clear()
    
    async def timeout_demo(self):
        """超时演示"""
        print("\n=== 超时演示 ===")
        
        try:
            # 设置超时
            result = await asyncio.wait_for(
                self.long_running_task(4, 5.0),
                timeout=2.0
            )
            print(f"任务结果: {result}")
        except asyncio.TimeoutError:
            print("任务超时")
    
    async def semaphore_demo(self):
        """信号量演示"""
        print("\n=== 信号量演示 ===")
        
        # 创建信号量，限制并发数为3
        semaphore = asyncio.Semaphore(3)
        
        async def limited_task(task_id: int):
            async with semaphore:
                print(f"任务 {task_id} 获取信号量")
                await asyncio.sleep(1.0)
                print(f"任务 {task_id} 释放信号量")
        
        # 创建10个任务
        tasks = [limited_task(i) for i in range(10)]
        
        # 并发执行
        await asyncio.gather(*tasks)
    
    async def event_demo(self):
        """事件演示"""
        print("\n=== 事件演示 ===")
        
        event = asyncio.Event()
        
        async def waiter(waiter_id: int):
            print(f"等待者 {waiter_id} 等待事件")
            await event.wait()
            print(f"等待者 {waiter_id} 收到事件")
        
        async def setter():
            print("设置者等待3秒后设置事件")
            await asyncio.sleep(3.0)
            event.set()
            print("事件已设置")
        
        # 创建等待者和设置者
        waiters = [waiter(i) for i in range(3)]
        setter_task = asyncio.create_task(setter())
        
        # 并发执行
        await asyncio.gather(*waiters, setter_task)
    
    async def queue_demo(self):
        """队列演示"""
        print("\n=== 队列演示 ===")
        
        queue = asyncio.Queue(maxsize=5)
        
        async def producer(producer_id: int):
            for i in range(3):
                item = f"生产者{producer_id}-项目{i}"
                await queue.put(item)
                print(f"生产者 {producer_id} 生产: {item}")
                await asyncio.sleep(0.5)
        
        async def consumer(consumer_id: int):
            while True:
                try:
                    item = await asyncio.wait_for(queue.get(), timeout=2.0)
                    print(f"消费者 {consumer_id} 消费: {item}")
                    await asyncio.sleep(0.3)
                    queue.task_done()
                except asyncio.TimeoutError:
                    print(f"消费者 {consumer_id} 超时退出")
                    break
        
        # 创建生产者和消费者
        producers = [producer(i) for i in range(2)]
        consumers = [consumer(i) for i in range(3)]
        
        # 并发执行
        await asyncio.gather(*producers, *consumers)
```

### 异步迭代器与生成器

```python
# 异步迭代器与生成器示例
class AsyncIteratorDemo:
    """异步迭代器演示"""
    
    async def async_generator(self, start: int, end: int):
        """异步生成器"""
        for i in range(start, end):
            await asyncio.sleep(0.1)  # 模拟异步操作
            yield i
    
    async def async_iterator_demo(self):
        """异步迭代器演示"""
        print("=== 异步迭代器演示 ===")
        
        # 使用异步生成器
        async for value in self.async_generator(1, 6):
            print(f"生成值: {value}")
        
        # 转换为列表
        values = [value async for value in self.async_generator(10, 15)]
        print(f"生成的值列表: {values}")
    
    async def async_comprehension_demo(self):
        """异步推导式演示"""
        print("\n=== 异步推导式演示 ===")
        
        # 异步列表推导式
        async def process_value(x):
            await asyncio.sleep(0.1)
            return x * 2
        
        values = [await process_value(x) async for x in range(5)]
        print(f"处理后的值: {values}")
        
        # 异步字典推导式
        async def process_key_value(k, v):
            await asyncio.sleep(0.1)
            return k, v * 2
        
        data = {k: v for k, v in [(1, 2), (3, 4), (5, 6)]}
        processed_data = {k: v async for k, v in [await process_key_value(k, v) for k, v in data.items()]}
        print(f"处理后的数据: {processed_data}")
```

---

## 异步Web开发

### FastAPI异步应用

```python
# FastAPI异步应用示例
from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import asyncio
import aiohttp
import aioredis
from datetime import datetime

# 数据模型
class UserRequest(BaseModel):
    name: str
    email: str

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    created_at: datetime

class AsyncWebApp:
    """异步Web应用"""
    
    def __init__(self):
        self.app = FastAPI(title="异步Web应用", version="1.0.0")
        self.redis_client = None
        self.setup_routes()
    
    def setup_routes(self):
        """设置路由"""
        
        @self.app.on_event("startup")
        async def startup_event():
            """应用启动事件"""
            self.redis_client = await aioredis.create_redis_pool(
                "redis://localhost:6379"
            )
            print("Redis连接已建立")
        
        @self.app.on_event("shutdown")
        async def shutdown_event():
            """应用关闭事件"""
            if self.redis_client:
                self.redis_client.close()
                await self.redis_client.wait_closed()
            print("Redis连接已关闭")
        
        @self.app.get("/")
        async def root():
            """根路径"""
            return {"message": "异步Web应用运行中"}
        
        @self.app.get("/users/{user_id}")
        async def get_user(user_id: int):
            """获取用户"""
            # 从缓存获取
            cached_user = await self.get_cached_user(user_id)
            if cached_user:
                return cached_user
            
            # 从数据库获取（模拟）
            user = await self.fetch_user_from_db(user_id)
            if not user:
                raise HTTPException(status_code=404, detail="用户不存在")
            
            # 缓存用户数据
            await self.cache_user(user_id, user)
            
            return user
        
        @self.app.post("/users/", response_model=UserResponse)
        async def create_user(user: UserRequest, background_tasks: BackgroundTasks):
            """创建用户"""
            # 创建用户
            new_user = UserResponse(
                id=await self.get_next_user_id(),
                name=user.name,
                email=user.email,
                created_at=datetime.now()
            )
            
            # 后台任务：发送欢迎邮件
            background_tasks.add_task(self.send_welcome_email, new_user.email)
            
            # 缓存用户数据
            await self.cache_user(new_user.id, new_user)
            
            return new_user
        
        @self.app.get("/users/")
        async def list_users(skip: int = 0, limit: int = 100):
            """列出用户"""
            # 从缓存获取用户列表
            cached_users = await self.get_cached_users(skip, limit)
            if cached_users:
                return cached_users
            
            # 从数据库获取（模拟）
            users = await self.fetch_users_from_db(skip, limit)
            
            # 缓存用户列表
            await self.cache_users(skip, limit, users)
            
            return users
        
        @self.app.get("/external-data")
        async def get_external_data():
            """获取外部数据"""
            async with aiohttp.ClientSession() as session:
                # 并发请求多个外部API
                tasks = [
                    self.fetch_external_api(session, "api1"),
                    self.fetch_external_api(session, "api2"),
                    self.fetch_external_api(session, "api3")
                ]
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                return {
                    "api1": results[0] if not isinstance(results[0], Exception) else str(results[0]),
                    "api2": results[1] if not isinstance(results[1], Exception) else str(results[1]),
                    "api3": results[2] if not isinstance(results[2], Exception) else str(results[2])
                }
    
    async def get_cached_user(self, user_id: int) -> Optional[UserResponse]:
        """从缓存获取用户"""
        if not self.redis_client:
            return None
        
        try:
            cached_data = await self.redis_client.get(f"user:{user_id}")
            if cached_data:
                import json
                user_data = json.loads(cached_data)
                return UserResponse(**user_data)
        except Exception as e:
            print(f"缓存获取失败: {e}")
        
        return None
    
    async def cache_user(self, user_id: int, user: UserResponse):
        """缓存用户数据"""
        if not self.redis_client:
            return
        
        try:
            import json
            user_data = json.dumps(user.dict(), default=str)
            await self.redis_client.setex(f"user:{user_id}", 300, user_data)  # 5分钟过期
        except Exception as e:
            print(f"缓存设置失败: {e}")
    
    async def get_cached_users(self, skip: int, limit: int) -> Optional[List[UserResponse]]:
        """从缓存获取用户列表"""
        if not self.redis_client:
            return None
        
        try:
            cached_data = await self.redis_client.get(f"users:{skip}:{limit}")
            if cached_data:
                import json
                users_data = json.loads(cached_data)
                return [UserResponse(**user_data) for user_data in users_data]
        except Exception as e:
            print(f"缓存获取失败: {e}")
        
        return None
    
    async def cache_users(self, skip: int, limit: int, users: List[UserResponse]):
        """缓存用户列表"""
        if not self.redis_client:
            return
        
        try:
            import json
            users_data = [user.dict() for user in users]
            cached_data = json.dumps(users_data, default=str)
            await self.redis_client.setex(f"users:{skip}:{limit}", 300, cached_data)
        except Exception as e:
            print(f"缓存设置失败: {e}")
    
    async def fetch_user_from_db(self, user_id: int) -> Optional[UserResponse]:
        """从数据库获取用户（模拟）"""
        await asyncio.sleep(0.1)  # 模拟数据库查询延迟
        
        # 模拟用户数据
        if user_id <= 100:
            return UserResponse(
                id=user_id,
                name=f"用户{user_id}",
                email=f"user{user_id}@example.com",
                created_at=datetime.now()
            )
        
        return None
    
    async def fetch_users_from_db(self, skip: int, limit: int) -> List[UserResponse]:
        """从数据库获取用户列表（模拟）"""
        await asyncio.sleep(0.1)  # 模拟数据库查询延迟
        
        users = []
        for i in range(skip + 1, skip + limit + 1):
            if i <= 100:
                users.append(UserResponse(
                    id=i,
                    name=f"用户{i}",
                    email=f"user{i}@example.com",
                    created_at=datetime.now()
                ))
        
        return users
    
    async def get_next_user_id(self) -> int:
        """获取下一个用户ID"""
        if not self.redis_client:
            return 1
        
        try:
            next_id = await self.redis_client.incr("user_id_counter")
            return next_id
        except Exception:
            return 1
    
    async def send_welcome_email(self, email: str):
        """发送欢迎邮件（后台任务）"""
        await asyncio.sleep(1.0)  # 模拟邮件发送延迟
        print(f"欢迎邮件已发送到: {email}")
    
    async def fetch_external_api(self, session: aiohttp.ClientSession, api_name: str) -> Dict[str, Any]:
        """获取外部API数据"""
        try:
            # 模拟外部API调用
            await asyncio.sleep(0.5)
            
            return {
                "api": api_name,
                "data": f"来自{api_name}的数据",
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            raise Exception(f"API {api_name} 调用失败: {e}")
```

---

## 相关主题

- [Python语言新特性](./../../01-语言与生态/迁移/01-语言新特性.md)
- [Python技术栈2025](./../../01-语言与生态/迁移/02-技术栈2025.md)
- [质量检查](./../../02-测试与质量/迁移/质量检查.md)
- [项目管理](./../../03-工程与交付/迁移/项目管理.md)
- [现代Web框架](./../../05-Web开发/迁移/现代Web框架.md)
- [数据分析与机器学习](./../../06-数据科学/迁移/数据分析与机器学习.md)

---

**下一主题**: [上下文与流程](./../../99-上下文与流程/README.md)
