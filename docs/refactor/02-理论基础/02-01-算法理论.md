# 02-01 算法理论

## 📋 概述

算法理论是计算机科学的核心理论基础，研究算法的设计、分析和优化。本文档从形式化角度阐述算法的基本概念、复杂度理论和设计方法。

## 🎯 核心概念

### 1. 算法基础

#### 1.1 形式化定义

**定义 1.1** (算法)
算法是一个有限的计算过程，可以形式化为：
$$A = (I, O, S, \delta, \lambda)$$
其中：

- $I$ 是输入集合
- $O$ 是输出集合
- $S$ 是状态集合
- $\delta: S \times I \rightarrow S$ 是状态转移函数
- $\lambda: S \times I \rightarrow O$ 是输出函数

**定义 1.2** (算法的正确性)
算法 $A$ 对于问题 $P$ 是正确的，当且仅当：
$$\forall x \in I: A(x) = P(x)$$

**定义 1.3** (算法的终止性)
算法 $A$ 是终止的，当且仅当：
$$\forall x \in I: \exists n \in \mathbb{N}: A(x) \text{ 在 } n \text{ 步内终止}$$

#### 1.2 Python实现

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Any, Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import time
import math

T = TypeVar('T')
U = TypeVar('U')

class AlgorithmState(Enum):
    """算法状态"""
    INITIAL = "initial"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class AlgorithmStep:
    """算法步骤"""
    step_id: int
    state: Dict[str, Any]
    action: str
    timestamp: float

class Algorithm(ABC, Generic[T, U]):
    """算法抽象基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.state = AlgorithmState.INITIAL
        self.steps: List[AlgorithmStep] = []
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None
    
    @abstractmethod
    def execute(self, input_data: T) -> U:
        """执行算法"""
        pass
    
    def run(self, input_data: T) -> U:
        """运行算法并记录步骤"""
        self.state = AlgorithmState.RUNNING
        self.start_time = time.time()
        self.steps.clear()
        
        try:
            result = self.execute(input_data)
            self.state = AlgorithmState.COMPLETED
            self.end_time = time.time()
            return result
        except Exception as e:
            self.state = AlgorithmState.FAILED
            self.end_time = time.time()
            raise e
    
    def add_step(self, action: str, state: Dict[str, Any]) -> None:
        """添加执行步骤"""
        step = AlgorithmStep(
            step_id=len(self.steps) + 1,
            state=state.copy(),
            action=action,
            timestamp=time.time()
        )
        self.steps.append(step)
    
    def get_execution_time(self) -> Optional[float]:
        """获取执行时间"""
        if self.start_time and self.end_time:
            return self.end_time - self.start_time
        return None
    
    def get_step_count(self) -> int:
        """获取步骤数"""
        return len(self.steps)
    
    def print_execution_trace(self) -> None:
        """打印执行轨迹"""
        print(f"算法: {self.name}")
        print(f"状态: {self.state.value}")
        print(f"执行时间: {self.get_execution_time():.6f}秒")
        print(f"步骤数: {self.get_step_count()}")
        print("\n执行轨迹:")
        print("-" * 50)
        
        for step in self.steps:
            print(f"步骤 {step.step_id}: {step.action}")
            print(f"  状态: {step.state}")
            print(f"  时间: {step.timestamp:.6f}")

class SortingAlgorithm(Algorithm[List[int], List[int]]):
    """排序算法基类"""
    
    def __init__(self, name: str):
        super().__init__(name)
    
    def is_sorted(self, arr: List[int]) -> bool:
        """检查数组是否已排序"""
        return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))
    
    def verify_correctness(self, original: List[int], sorted_arr: List[int]) -> bool:
        """验证排序正确性"""
        # 检查排序后的数组是否有序
        if not self.is_sorted(sorted_arr):
            return False
        
        # 检查是否包含相同的元素
        return sorted(original) == sorted_arr

class BubbleSort(SortingAlgorithm):
    """冒泡排序算法"""
    
    def __init__(self):
        super().__init__("Bubble Sort")
    
    def execute(self, arr: List[int]) -> List[int]:
        """执行冒泡排序"""
        result = arr.copy()
        n = len(result)
        
        self.add_step("初始化", {"array": result.copy(), "n": n})
        
        for i in range(n):
            swapped = False
            self.add_step(f"外层循环 {i+1}", {"i": i, "array": result.copy()})
            
            for j in range(0, n-i-1):
                self.add_step(f"内层循环 {j+1}", {"i": i, "j": j, "array": result.copy()})
                
                if result[j] > result[j+1]:
                    # 交换元素
                    result[j], result[j+1] = result[j+1], result[j]
                    swapped = True
                    self.add_step("交换元素", {"i": i, "j": j, "array": result.copy()})
            
            if not swapped:
                self.add_step("提前终止", {"i": i, "array": result.copy()})
                break
        
        self.add_step("完成", {"array": result.copy()})
        return result

class QuickSort(SortingAlgorithm):
    """快速排序算法"""
    
    def __init__(self):
        super().__init__("Quick Sort")
    
    def execute(self, arr: List[int]) -> List[int]:
        """执行快速排序"""
        result = arr.copy()
        self.add_step("初始化", {"array": result.copy()})
        
        self._quick_sort(result, 0, len(result) - 1)
        
        self.add_step("完成", {"array": result.copy()})
        return result
    
    def _quick_sort(self, arr: List[int], low: int, high: int) -> None:
        """递归快速排序"""
        if low < high:
            self.add_step(f"分区排序 [{low}, {high}]", {"array": arr.copy(), "low": low, "high": high})
            
            # 分区
            pi = self._partition(arr, low, high)
            
            # 递归排序
            self._quick_sort(arr, low, pi - 1)
            self._quick_sort(arr, pi + 1, high)
    
    def _partition(self, arr: List[int], low: int, high: int) -> int:
        """分区函数"""
        pivot = arr[high]
        i = low - 1
        
        self.add_step("选择基准", {"pivot": pivot, "array": arr.copy()})
        
        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
                self.add_step("移动元素", {"i": i, "j": j, "array": arr.copy()})
        
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        self.add_step("放置基准", {"pivot_index": i + 1, "array": arr.copy()})
        
        return i + 1

# 示例使用
def demonstrate_sorting_algorithms():
    """演示排序算法"""
    # 测试数据
    test_data = [64, 34, 25, 12, 22, 11, 90]
    print(f"原始数组: {test_data}")
    
    # 冒泡排序
    bubble_sort = BubbleSort()
    bubble_result = bubble_sort.run(test_data)
    print(f"\n冒泡排序结果: {bubble_result}")
    print(f"正确性验证: {bubble_sort.verify_correctness(test_data, bubble_result)}")
    
    # 快速排序
    quick_sort = QuickSort()
    quick_result = quick_sort.run(test_data)
    print(f"\n快速排序结果: {quick_result}")
    print(f"正确性验证: {quick_sort.verify_correctness(test_data, quick_result)}")
    
    # 比较性能
    print(f"\n性能比较:")
    print(f"冒泡排序执行时间: {bubble_sort.get_execution_time():.6f}秒")
    print(f"快速排序执行时间: {quick_sort.get_execution_time():.6f}秒")

if __name__ == "__main__":
    demonstrate_sorting_algorithms()
```

### 2. 算法复杂度理论

#### 2.1 形式化定义

**定义 2.1** (时间复杂度)
算法 $A$ 的时间复杂度 $T_A(n)$ 定义为：
$$T_A(n) = \max\{t_A(x) \mid |x| = n\}$$
其中 $t_A(x)$ 是算法 $A$ 在输入 $x$ 上的执行时间。

**定义 2.2** (空间复杂度)
算法 $A$ 的空间复杂度 $S_A(n)$ 定义为：
$$S_A(n) = \max\{s_A(x) \mid |x| = n\}$$
其中 $s_A(x)$ 是算法 $A$ 在输入 $x$ 上的内存使用量。

**定义 2.3** (渐进复杂度)
对于函数 $f(n)$ 和 $g(n)$：

- $f(n) = O(g(n))$ 当且仅当 $\exists c > 0, n_0 > 0: \forall n \geq n_0: f(n) \leq c \cdot g(n)$
- $f(n) = \Omega(g(n))$ 当且仅当 $\exists c > 0, n_0 > 0: \forall n \geq n_0: f(n) \geq c \cdot g(n)$
- $f(n) = \Theta(g(n))$ 当且仅当 $f(n) = O(g(n))$ 且 $f(n) = \Omega(g(n))$

#### 2.2 Python实现

```python
from typing import Callable, List, Dict, Any, Tuple
from dataclasses import dataclass
import time
import random
import matplotlib.pyplot as plt
import numpy as np

@dataclass
class ComplexityAnalysis:
    """复杂度分析结果"""
    algorithm_name: str
    input_sizes: List[int]
    execution_times: List[float]
    space_usage: List[int]
    theoretical_complexity: str

class ComplexityAnalyzer:
    """复杂度分析器"""
    
    def __init__(self):
        self.analyses: Dict[str, ComplexityAnalysis] = {}
    
    def analyze_algorithm(self, 
                         algorithm: Algorithm, 
                         input_generator: Callable[[int], Any],
                         input_sizes: List[int],
                         theoretical_complexity: str) -> ComplexityAnalysis:
        """分析算法复杂度"""
        execution_times = []
        space_usage = []
        
        for size in input_sizes:
            # 生成测试数据
            test_input = input_generator(size)
            
            # 测量执行时间
            start_time = time.time()
            result = algorithm.run(test_input)
            end_time = time.time()
            
            execution_time = end_time - start_time
            execution_times.append(execution_time)
            
            # 估算空间使用（简化版本）
            space = self._estimate_space_usage(algorithm, test_input)
            space_usage.append(space)
        
        analysis = ComplexityAnalysis(
            algorithm_name=algorithm.name,
            input_sizes=input_sizes,
            execution_times=execution_times,
            space_usage=space_usage,
            theoretical_complexity=theoretical_complexity
        )
        
        self.analyses[algorithm.name] = analysis
        return analysis
    
    def _estimate_space_usage(self, algorithm: Algorithm, input_data: Any) -> int:
        """估算空间使用量"""
        # 简化版本，实际应用中需要更复杂的分析
        if isinstance(input_data, list):
            return len(input_data) * 8  # 假设每个元素8字节
        elif isinstance(input_data, dict):
            return len(input_data) * 16  # 假设每个键值对16字节
        else:
            return 100  # 默认值
    
    def plot_complexity_comparison(self) -> None:
        """绘制复杂度比较图"""
        plt.figure(figsize=(15, 10))
        
        # 时间复杂度比较
        plt.subplot(2, 2, 1)
        for name, analysis in self.analyses.items():
            plt.plot(analysis.input_sizes, analysis.execution_times, 
                    marker='o', label=f"{name} (实际)")
        
        # 添加理论复杂度曲线
        max_size = max(max(analysis.input_sizes) for analysis in self.analyses.values())
        x_theoretical = np.linspace(1, max_size, 100)
        
        # O(n²) 理论曲线
        y_n2 = x_theoretical ** 2 * 1e-6  # 缩放因子
        plt.plot(x_theoretical, y_n2, '--', label='O(n²) 理论', alpha=0.7)
        
        # O(n log n) 理论曲线
        y_nlogn = x_theoretical * np.log(x_theoretical) * 1e-5  # 缩放因子
        plt.plot(x_theoretical, y_nlogn, '--', label='O(n log n) 理论', alpha=0.7)
        
        plt.xlabel('输入大小')
        plt.ylabel('执行时间 (秒)')
        plt.title('时间复杂度比较')
        plt.legend()
        plt.grid(True)
        
        # 空间复杂度比较
        plt.subplot(2, 2, 2)
        for name, analysis in self.analyses.items():
            plt.plot(analysis.input_sizes, analysis.space_usage, 
                    marker='s', label=name)
        
        plt.xlabel('输入大小')
        plt.ylabel('空间使用 (字节)')
        plt.title('空间复杂度比较')
        plt.legend()
        plt.grid(True)
        
        # 对数尺度时间比较
        plt.subplot(2, 2, 3)
        for name, analysis in self.analyses.items():
            plt.loglog(analysis.input_sizes, analysis.execution_times, 
                      marker='o', label=name)
        
        plt.xlabel('输入大小 (对数尺度)')
        plt.ylabel('执行时间 (对数尺度)')
        plt.title('对数尺度时间复杂度')
        plt.legend()
        plt.grid(True)
        
        # 复杂度分析表格
        plt.subplot(2, 2, 4)
        plt.axis('off')
        
        table_data = []
        for name, analysis in self.analyses.items():
            table_data.append([
                name,
                analysis.theoretical_complexity,
                f"{analysis.execution_times[-1]:.6f}s",
                f"{analysis.space_usage[-1]} bytes"
            ])
        
        table = plt.table(cellText=table_data,
                         colLabels=['算法', '理论复杂度', '最大执行时间', '最大空间使用'],
                         cellLoc='center',
                         loc='center')
        table.auto_set_font_size(False)
        table.set_fontsize(9)
        table.scale(1, 2)
        
        plt.tight_layout()
        plt.show()
    
    def print_analysis_summary(self) -> None:
        """打印分析摘要"""
        print("算法复杂度分析摘要")
        print("=" * 60)
        
        for name, analysis in self.analyses.items():
            print(f"\n算法: {name}")
            print(f"理论复杂度: {analysis.theoretical_complexity}")
            print(f"最大执行时间: {analysis.execution_times[-1]:.6f}秒")
            print(f"最大空间使用: {analysis.space_usage[-1]}字节")
            
            # 计算增长率
            if len(analysis.execution_times) >= 2:
                growth_rate = analysis.execution_times[-1] / analysis.execution_times[-2]
                print(f"执行时间增长率: {growth_rate:.2f}x")

def generate_random_array(size: int) -> List[int]:
    """生成随机数组"""
    return [random.randint(1, 1000) for _ in range(size)]

# 示例：复杂度分析
def demonstrate_complexity_analysis():
    """演示复杂度分析"""
    analyzer = ComplexityAnalyzer()
    
    # 测试不同大小的输入
    input_sizes = [100, 200, 400, 800, 1600]
    
    # 分析冒泡排序
    bubble_sort = BubbleSort()
    bubble_analysis = analyzer.analyze_algorithm(
        bubble_sort, generate_random_array, input_sizes, "O(n²)"
    )
    
    # 分析快速排序
    quick_sort = QuickSort()
    quick_analysis = analyzer.analyze_algorithm(
        quick_sort, generate_random_array, input_sizes, "O(n log n)"
    )
    
    # 显示分析结果
    analyzer.print_analysis_summary()
    analyzer.plot_complexity_comparison()

if __name__ == "__main__":
    demonstrate_complexity_analysis()
```

### 3. 算法设计方法

#### 3.1 分治法

**定义 3.1** (分治算法)
分治算法将问题分解为子问题，递归求解，然后合并结果：
$$T(n) = aT(n/b) + f(n)$$
其中 $a$ 是子问题数，$b$ 是问题规模缩小因子，$f(n)$ 是合并成本。

**主定理** (Master Theorem)
对于递归式 $T(n) = aT(n/b) + f(n)$，其中 $a \geq 1, b > 1$：

- 如果 $f(n) = O(n^{\log_b a - \epsilon})$，则 $T(n) = \Theta(n^{\log_b a})$
- 如果 $f(n) = \Theta(n^{\log_b a} \log^k n)$，则 $T(n) = \Theta(n^{\log_b a} \log^{k+1} n)$
- 如果 $f(n) = \Omega(n^{\log_b a + \epsilon})$，则 $T(n) = \Theta(f(n))$

#### 3.2 Python实现

```python
from typing import List, Tuple, Any
import math

class DivideAndConquerAlgorithm(Algorithm):
    """分治算法基类"""
    
    def __init__(self, name: str):
        super().__init__(name)
    
    @abstractmethod
    def divide(self, problem: Any) -> List[Any]:
        """分解问题"""
        pass
    
    @abstractmethod
    def conquer(self, subproblems: List[Any]) -> Any:
        """合并子问题结果"""
        pass
    
    @abstractmethod
    def solve_base_case(self, problem: Any) -> Any:
        """解决基本情况"""
        pass
    
    def is_base_case(self, problem: Any) -> bool:
        """判断是否为基本情况"""
        pass
    
    def execute(self, problem: Any) -> Any:
        """执行分治算法"""
        self.add_step("开始分治", {"problem_size": self._get_problem_size(problem)})
        
        if self.is_base_case(problem):
            result = self.solve_base_case(problem)
            self.add_step("解决基本情况", {"result": result})
            return result
        
        # 分解
        subproblems = self.divide(problem)
        self.add_step("分解问题", {"subproblems_count": len(subproblems)})
        
        # 递归求解
        subresults = []
        for i, subproblem in enumerate(subproblems):
            self.add_step(f"递归求解子问题 {i+1}", {"subproblem": subproblem})
            subresult = self.execute(subproblem)
            subresults.append(subresult)
        
        # 合并
        result = self.conquer(subresults)
        self.add_step("合并结果", {"result": result})
        
        return result
    
    def _get_problem_size(self, problem: Any) -> int:
        """获取问题规模"""
        if isinstance(problem, list):
            return len(problem)
        elif isinstance(problem, str):
            return len(problem)
        else:
            return 1

class MergeSort(DivideAndConquerAlgorithm):
    """归并排序算法"""
    
    def __init__(self):
        super().__init__("Merge Sort")
    
    def is_base_case(self, arr: List[int]) -> bool:
        return len(arr) <= 1
    
    def solve_base_case(self, arr: List[int]) -> List[int]:
        return arr.copy()
    
    def divide(self, arr: List[int]) -> List[List[int]]:
        mid = len(arr) // 2
        return [arr[:mid], arr[mid:]]
    
    def conquer(self, subresults: List[List[int]]) -> List[int]:
        return self._merge(subresults[0], subresults[1])
    
    def _merge(self, left: List[int], right: List[int]) -> List[int]:
        """合并两个有序数组"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        # 添加剩余元素
        result.extend(left[i:])
        result.extend(right[j:])
        
        return result

class StrassenMatrixMultiplication(DivideAndConquerAlgorithm):
    """Strassen矩阵乘法算法"""
    
    def __init__(self):
        super().__init__("Strassen Matrix Multiplication")
    
    def is_base_case(self, matrices: Tuple[List[List[int]], List[List[int]]]) -> bool:
        A, B = matrices
        return len(A) <= 2
    
    def solve_base_case(self, matrices: Tuple[List[List[int]], List[List[int]]]) -> List[List[int]]:
        A, B = matrices
        if len(A) == 1:
            return [[A[0][0] * B[0][0]]]
        else:
            return self._standard_multiply(A, B)
    
    def divide(self, matrices: Tuple[List[List[int]], List[List[int]]]) -> List[Tuple[List[List[int]], List[List[int]]]]:
        A, B = matrices
        n = len(A)
        mid = n // 2
        
        # 分解矩阵A
        A11 = [row[:mid] for row in A[:mid]]
        A12 = [row[mid:] for row in A[:mid]]
        A21 = [row[:mid] for row in A[mid:]]
        A22 = [row[mid:] for row in A[mid:]]
        
        # 分解矩阵B
        B11 = [row[:mid] for row in B[:mid]]
        B12 = [row[mid:] for row in B[:mid]]
        B21 = [row[:mid] for row in B[mid:]]
        B22 = [row[mid:] for row in B[mid:]]
        
        # 创建子问题
        subproblems = [
            ((A11, B11), (A12, B21)),  # P1 = A11 * (B12 - B22)
            ((A11, B12), (A12, B22)),  # P2 = (A11 + A12) * B22
            ((A21, B11), (A22, B21)),  # P3 = (A21 + A22) * B11
            ((A21, B12), (A22, B22)),  # P4 = A22 * (B21 - B11)
            ((A11, B11), (A11, B22)),  # P5 = (A11 + A22) * (B11 + B22)
            ((A12, B21), (A12, B22)),  # P6 = (A12 - A22) * (B21 + B22)
            ((A11, B12), (A21, B12)),  # P7 = (A11 - A21) * (B11 + B12)
        ]
        
        return subproblems
    
    def conquer(self, subresults: List[List[List[int]]]) -> List[List[int]]:
        # Strassen公式
        P1, P2, P3, P4, P5, P6, P7 = subresults
        n = len(P1)
        
        # 计算C矩阵的四个子矩阵
        C11 = self._add_matrices(P5, P4)
        C11 = self._subtract_matrices(C11, P2)
        C11 = self._add_matrices(C11, P6)
        
        C12 = self._add_matrices(P1, P2)
        C21 = self._add_matrices(P3, P4)
        C22 = self._add_matrices(P5, P1)
        C22 = self._subtract_matrices(C22, P3)
        C22 = self._subtract_matrices(C22, P7)
        
        # 合并子矩阵
        result = []
        for i in range(n):
            result.append(C11[i] + C12[i])
        for i in range(n):
            result.append(C21[i] + C22[i])
        
        return result
    
    def _add_matrices(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        """矩阵加法"""
        return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]
    
    def _subtract_matrices(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        """矩阵减法"""
        return [[A[i][j] - B[i][j] for j in range(len(A[0]))] for i in range(len(A))]
    
    def _standard_multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        """标准矩阵乘法"""
        n = len(A)
        result = [[0 for _ in range(n)] for _ in range(n)]
        
        for i in range(n):
            for j in range(n):
                for k in range(n):
                    result[i][j] += A[i][k] * B[k][j]
        
        return result

# 示例使用
def demonstrate_divide_and_conquer():
    """演示分治算法"""
    # 归并排序
    merge_sort = MergeSort()
    test_array = [64, 34, 25, 12, 22, 11, 90]
    result = merge_sort.run(test_array)
    print(f"归并排序结果: {result}")
    
    # Strassen矩阵乘法
    strassen = StrassenMatrixMultiplication()
    A = [[1, 2], [3, 4]]
    B = [[5, 6], [7, 8]]
    result = strassen.run((A, B))
    print(f"Strassen矩阵乘法结果: {result}")

if __name__ == "__main__":
    demonstrate_divide_and_conquer()
```

## 📊 算法优化

### 1. 动态规划

#### 1.1 形式化定义

**定义 4.1** (最优子结构)
问题具有最优子结构，如果问题的最优解包含其子问题的最优解。

**定义 4.2** (重叠子问题)
问题具有重叠子问题，如果递归算法重复求解相同的子问题。

**定义 4.3** (动态规划)
动态规划是通过存储子问题的解来避免重复计算的优化技术。

#### 1.2 Python实现

```python
from typing import Dict, List, Any, Optional
from functools import lru_cache

class DynamicProgrammingAlgorithm(Algorithm):
    """动态规划算法基类"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.memo: Dict[str, Any] = {}
    
    def memoize(self, key: str, value: Any) -> None:
        """记忆化存储"""
        self.memo[key] = value
    
    def get_memoized(self, key: str) -> Optional[Any]:
        """获取记忆化的值"""
        return self.memo.get(key)
    
    def clear_memo(self) -> None:
        """清除记忆化缓存"""
        self.memo.clear()

class FibonacciDP(DynamicProgrammingAlgorithm):
    """动态规划斐波那契数列"""
    
    def __init__(self):
        super().__init__("Fibonacci DP")
    
    def execute(self, n: int) -> int:
        """计算第n个斐波那契数"""
        self.add_step("开始计算", {"n": n})
        
        if n <= 1:
            result = n
            self.add_step("基本情况", {"n": n, "result": result})
            return result
        
        # 检查是否已计算
        memo_key = f"fib_{n}"
        if self.get_memoized(memo_key) is not None:
            result = self.get_memoized(memo_key)
            self.add_step("使用缓存", {"n": n, "result": result})
            return result
        
        # 递归计算
        self.add_step("递归计算", {"n": n})
        result = self.execute(n-1) + self.execute(n-2)
        
        # 存储结果
        self.memoize(memo_key, result)
        self.add_step("存储结果", {"n": n, "result": result})
        
        return result

class LongestCommonSubsequence(DynamicProgrammingAlgorithm):
    """最长公共子序列"""
    
    def __init__(self):
        super().__init__("Longest Common Subsequence")
    
    def execute(self, input_data: Tuple[str, str]) -> str:
        """计算最长公共子序列"""
        str1, str2 = input_data
        self.add_step("开始计算", {"str1": str1, "str2": str2})
        
        # 构建DP表
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # 填充DP表
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        self.add_step("DP表构建完成", {"dp_table": dp})
        
        # 回溯构造LCS
        lcs = []
        i, j = m, n
        while i > 0 and j > 0:
            if str1[i-1] == str2[j-1]:
                lcs.append(str1[i-1])
                i -= 1
                j -= 1
            elif dp[i-1][j] > dp[i][j-1]:
                i -= 1
            else:
                j -= 1
        
        result = ''.join(reversed(lcs))
        self.add_step("构造LCS", {"lcs": result})
        
        return result

# 示例使用
def demonstrate_dynamic_programming():
    """演示动态规划"""
    # 斐波那契数列
    fib_dp = FibonacciDP()
    result = fib_dp.run(10)
    print(f"第10个斐波那契数: {result}")
    print(f"缓存大小: {len(fib_dp.memo)}")
    
    # 最长公共子序列
    lcs = LongestCommonSubsequence()
    result = lcs.run(("ABCDGH", "AEDFHR"))
    print(f"LCS结果: {result}")

if __name__ == "__main__":
    demonstrate_dynamic_programming()
```

## 📈 总结

算法理论为软件工程提供了：

1. **设计方法论**：分治、动态规划、贪心等设计模式
2. **性能分析工具**：时间复杂度和空间复杂度分析
3. **优化技术**：记忆化、剪枝、并行化等优化方法
4. **正确性验证**：算法正确性证明和验证技术
5. **实际应用**：排序、搜索、图算法等经典算法

通过系统性的算法理论，我们可以：

- 设计高效的算法
- 分析算法性能
- 优化现有算法
- 解决复杂问题
- 构建高性能软件系统

算法理论是计算机科学的核心，为现代软件工程提供了强大的理论基础和实践指导。
