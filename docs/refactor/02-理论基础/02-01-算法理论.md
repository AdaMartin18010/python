# 02-01 算法理论 (Algorithm Theory)

## 📋 目录

- [概述](#概述)
- [1. 算法基础](#1-算法基础)
- [2. 复杂度分析](#2-复杂度分析)
- [3. 算法设计范式](#3-算法设计范式)
- [4. 递归理论](#4-递归理论)
- [5. 分治策略](#5-分治策略)
- [6. 动态规划](#6-动态规划)
- [7. 贪心算法](#7-贪心算法)
- [8. 形式化表示](#8-形式化表示)
- [9. Python实现](#9-python实现)
- [10. 参考文献](#10-参考文献)

## 概述

算法理论是计算机科学的核心理论基础，研究算法的设计、分析和优化。本文档从形式化角度定义算法概念，分析算法复杂度，并介绍主要的算法设计范式。

## 1. 算法基础

### 1.1 算法的形式化定义

算法可以形式化定义为：

$$\mathcal{A} = \langle \mathcal{I}, \mathcal{O}, \mathcal{S}, \mathcal{T} \rangle$$

其中：
- $\mathcal{I}$ 是输入集合
- $\mathcal{O}$ 是输出集合
- $\mathcal{S}$ 是状态集合
- $\mathcal{T}$ 是转换函数集合

### 1.2 算法的性质

**正确性**: $\forall x \in \mathcal{I}: \mathcal{A}(x) = f(x)$

**终止性**: $\forall x \in \mathcal{I}: \mathcal{A}(x)$ 在有限步内终止

**确定性**: $\forall x \in \mathcal{I}: \mathcal{A}(x)$ 产生唯一输出

### 1.3 算法的表示

**伪代码**: 算法的高级描述
**流程图**: 算法的图形表示
**状态机**: 算法的状态转换表示

## 2. 复杂度分析

### 2.1 时间复杂度

**定义**: $T(n) = O(f(n)) \iff \exists c, n_0: \forall n \geq n_0: T(n) \leq c \cdot f(n)$

**常见复杂度类**:
- $O(1)$: 常数时间
- $O(\log n)$: 对数时间
- $O(n)$: 线性时间
- $O(n \log n)$: 线性对数时间
- $O(n^2)$: 二次时间
- $O(2^n)$: 指数时间

### 2.2 空间复杂度

**定义**: $S(n) = O(f(n)) \iff \exists c, n_0: \forall n \geq n_0: S(n) \leq c \cdot f(n)$

### 2.3 复杂度分析技术

**主定理**: 对于递归关系 $T(n) = aT(n/b) + f(n)$

$$T(n) = \begin{cases}
O(n^{\log_b a}) & \text{if } f(n) = O(n^{\log_b a - \epsilon}) \\
O(f(n) \log n) & \text{if } f(n) = O(n^{\log_b a}) \\
O(f(n)) & \text{if } f(n) = \Omega(n^{\log_b a + \epsilon})
\end{cases}$$

## 3. 算法设计范式

### 3.1 暴力搜索

**定义**: 穷举所有可能的解

**复杂度**: $O(n!)$ 或 $O(2^n)$

### 3.2 分治策略

**定义**: 将问题分解为子问题，递归解决，合并结果

**复杂度**: 通常 $O(n \log n)$

### 3.3 动态规划

**定义**: 通过存储子问题的解来避免重复计算

**复杂度**: 通常 $O(n^2)$ 或 $O(n^3)$

### 3.4 贪心算法

**定义**: 在每一步选择局部最优解

**复杂度**: 通常 $O(n \log n)$

## 4. 递归理论

### 4.1 递归定义

**递归函数**: $f(n) = g(f(n-1), n)$

**递归关系**: $T(n) = aT(n/b) + f(n)$

### 4.2 递归树分析

递归树的高度: $h = \log_b n$

每层的工作量: $a^i \cdot f(n/b^i)$

总工作量: $\sum_{i=0}^{h} a^i \cdot f(n/b^i)$

## 5. 分治策略

### 5.1 分治算法框架

```python
def divide_and_conquer(problem):
    if problem.is_small():
        return solve_directly(problem)
    
    subproblems = divide(problem)
    solutions = [divide_and_conquer(sub) for sub in subproblems]
    return combine(solutions)
```

### 5.2 经典分治算法

**归并排序**: $T(n) = 2T(n/2) + O(n) = O(n \log n)$

**快速排序**: $T(n) = T(k) + T(n-k-1) + O(n)$

**二分搜索**: $T(n) = T(n/2) + O(1) = O(\log n)$

## 6. 动态规划

### 6.1 动态规划原理

**最优子结构**: 问题的最优解包含子问题的最优解

**重叠子问题**: 子问题被重复计算

### 6.2 动态规划框架

```python
def dynamic_programming(problem):
    # 初始化DP表
    dp = initialize_dp_table()
    
    # 填充DP表
    for i in range(n):
        for j in range(m):
            dp[i][j] = optimal_choice(dp, i, j)
    
    return dp[n-1][m-1]
```

### 6.3 经典动态规划问题

**最长公共子序列**: $LCS(i,j) = \max(LCS(i-1,j), LCS(i,j-1), LCS(i-1,j-1) + 1)$

**背包问题**: $dp[i][w] = \max(dp[i-1][w], dp[i-1][w-w_i] + v_i)$

## 7. 贪心算法

### 7.1 贪心选择性质

**贪心选择**: 在每一步选择局部最优解

**最优子结构**: 贪心选择后，剩余问题仍具有最优子结构

### 7.2 贪心算法框架

```python
def greedy_algorithm(problem):
    solution = []
    while not problem.is_solved():
        choice = select_greedy_choice(problem)
        solution.append(choice)
        problem.update(choice)
    return solution
```

### 7.3 经典贪心算法

**活动选择**: 选择结束时间最早的活动

**霍夫曼编码**: 选择频率最低的两个节点合并

**Dijkstra算法**: 选择距离最小的未访问节点

## 8. 形式化表示

### 8.1 算法复杂度理论

**P类问题**: 可以在多项式时间内解决的问题

**NP类问题**: 可以在多项式时间内验证解的问题

**NP完全问题**: NP类中最难的问题

### 8.2 算法正确性证明

**循环不变式**: 在循环的每次迭代中都成立的断言

**数学归纳法**: 证明递归算法的正确性

## 9. Python实现

### 9.1 基础算法实现

```python
from typing import List, Tuple, Optional, Callable, Any
import time
import random
import math
from abc import ABC, abstractmethod

class AlgorithmAnalyzer:
    """算法分析器"""
    
    def __init__(self):
        self.complexity_cache = {}
    
    def measure_time(self, func: Callable, *args, **kwargs) -> float:
        """测量函数执行时间"""
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        return end_time - start_time
    
    def analyze_complexity(self, func: Callable, input_sizes: List[int], 
                          num_runs: int = 5) -> List[float]:
        """分析算法复杂度"""
        times = []
        
        for size in input_sizes:
            total_time = 0
            for _ in range(num_runs):
                # 生成测试数据
                test_data = self._generate_test_data(func, size)
                total_time += self.measure_time(func, test_data)
            
            avg_time = total_time / num_runs
            times.append(avg_time)
        
        return times
    
    def _generate_test_data(self, func: Callable, size: int) -> Any:
        """生成测试数据"""
        # 根据函数名生成相应的测试数据
        func_name = func.__name__.lower()
        
        if 'sort' in func_name:
            return [random.randint(1, 1000) for _ in range(size)]
        elif 'search' in func_name:
            arr = sorted([random.randint(1, 1000) for _ in range(size)])
            return arr, random.choice(arr)
        elif 'fibonacci' in func_name:
            return size
        else:
            return [random.randint(1, 100) for _ in range(size)]
    
    def estimate_complexity(self, input_sizes: List[int], times: List[float]) -> str:
        """估计算法复杂度"""
        if len(input_sizes) < 2:
            return "数据不足"
        
        # 计算复杂度比率
        ratios = []
        for i in range(1, len(input_sizes)):
            size_ratio = input_sizes[i] / input_sizes[i-1]
            time_ratio = times[i] / times[i-1]
            ratios.append(time_ratio / size_ratio)
        
        avg_ratio = sum(ratios) / len(ratios)
        
        # 根据比率判断复杂度
        if avg_ratio < 1.1:
            return "O(1)"
        elif avg_ratio < 1.5:
            return "O(log n)"
        elif avg_ratio < 2.5:
            return "O(n)"
        elif avg_ratio < 5:
            return "O(n log n)"
        elif avg_ratio < 10:
            return "O(n²)"
        else:
            return "O(2ⁿ) 或更高"

class SortingAlgorithms:
    """排序算法实现"""
    
    @staticmethod
    def bubble_sort(arr: List[int]) -> List[int]:
        """冒泡排序 - O(n²)"""
        arr = arr.copy()
        n = len(arr)
        
        for i in range(n):
            for j in range(0, n - i - 1):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
        
        return arr
    
    @staticmethod
    def merge_sort(arr: List[int]) -> List[int]:
        """归并排序 - O(n log n)"""
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = SortingAlgorithms.merge_sort(arr[:mid])
        right = SortingAlgorithms.merge_sort(arr[mid:])
        
        return SortingAlgorithms._merge(left, right)
    
    @staticmethod
    def _merge(left: List[int], right: List[int]) -> List[int]:
        """合并两个有序数组"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    @staticmethod
    def quick_sort(arr: List[int]) -> List[int]:
        """快速排序 - O(n log n) 平均情况"""
        if len(arr) <= 1:
            return arr
        
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        
        return (SortingAlgorithms.quick_sort(left) + 
                middle + 
                SortingAlgorithms.quick_sort(right))
    
    @staticmethod
    def heap_sort(arr: List[int]) -> List[int]:
        """堆排序 - O(n log n)"""
        def heapify(arr, n, i):
            largest = i
            left = 2 * i + 1
            right = 2 * i + 2
            
            if left < n and arr[left] > arr[largest]:
                largest = left
            
            if right < n and arr[right] > arr[largest]:
                largest = right
            
            if largest != i:
                arr[i], arr[largest] = arr[largest], arr[i]
                heapify(arr, n, largest)
        
        arr = arr.copy()
        n = len(arr)
        
        # 构建最大堆
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # 逐个提取元素
        for i in range(n - 1, 0, -1):
            arr[0], arr[i] = arr[i], arr[0]
            heapify(arr, i, 0)
        
        return arr

class SearchAlgorithms:
    """搜索算法实现"""
    
    @staticmethod
    def linear_search(arr: List[int], target: int) -> Optional[int]:
        """线性搜索 - O(n)"""
        for i, num in enumerate(arr):
            if num == target:
                return i
        return None
    
    @staticmethod
    def binary_search(arr: List[int], target: int) -> Optional[int]:
        """二分搜索 - O(log n)"""
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return None
    
    @staticmethod
    def depth_first_search(graph: dict, start: str, visited: set = None) -> List[str]:
        """深度优先搜索 - O(V + E)"""
        if visited is None:
            visited = set()
        
        visited.add(start)
        result = [start]
        
        for neighbor in graph.get(start, []):
            if neighbor not in visited:
                result.extend(SearchAlgorithms.depth_first_search(graph, neighbor, visited))
        
        return result
    
    @staticmethod
    def breadth_first_search(graph: dict, start: str) -> List[str]:
        """广度优先搜索 - O(V + E)"""
        visited = set()
        queue = [start]
        result = []
        
        while queue:
            vertex = queue.pop(0)
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                queue.extend(graph.get(vertex, []))
        
        return result

class DynamicProgramming:
    """动态规划算法实现"""
    
    @staticmethod
    def fibonacci_dp(n: int) -> int:
        """斐波那契数列 - 动态规划 - O(n)"""
        if n <= 1:
            return n
        
        dp = [0] * (n + 1)
        dp[1] = 1
        
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
    
    @staticmethod
    def longest_common_subsequence(str1: str, str2: str) -> int:
        """最长公共子序列 - O(mn)"""
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n]
    
    @staticmethod
    def knapsack_01(weights: List[int], values: List[int], capacity: int) -> int:
        """0-1背包问题 - O(nW)"""
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i - 1] <= w:
                    dp[i][w] = max(dp[i - 1][w], 
                                  dp[i - 1][w - weights[i - 1]] + values[i - 1])
                else:
                    dp[i][w] = dp[i - 1][w]
        
        return dp[n][capacity]
    
    @staticmethod
    def edit_distance(str1: str, str2: str) -> int:
        """编辑距离 - O(mn)"""
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # 初始化
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        # 填充DP表
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = 1 + min(dp[i - 1][j],      # 删除
                                      dp[i][j - 1],      # 插入
                                      dp[i - 1][j - 1])  # 替换
        
        return dp[m][n]

class GreedyAlgorithms:
    """贪心算法实现"""
    
    @staticmethod
    def activity_selection(start_times: List[int], end_times: List[int]) -> List[int]:
        """活动选择问题 - O(n log n)"""
        activities = list(zip(start_times, end_times, range(len(start_times))))
        activities.sort(key=lambda x: x[1])  # 按结束时间排序
        
        selected = [activities[0][2]]  # 选择第一个活动
        last_end = activities[0][1]
        
        for start, end, index in activities[1:]:
            if start >= last_end:
                selected.append(index)
                last_end = end
        
        return selected
    
    @staticmethod
    def huffman_encoding(frequencies: List[int]) -> dict:
        """霍夫曼编码 - O(n log n)"""
        import heapq
        
        # 创建优先队列
        heap = [(freq, i) for i, freq in enumerate(frequencies)]
        heapq.heapify(heap)
        
        # 构建霍夫曼树
        while len(heap) > 1:
            freq1, node1 = heapq.heappop(heap)
            freq2, node2 = heapq.heappop(heap)
            
            # 创建新节点
            new_freq = freq1 + freq2
            new_node = (new_freq, (node1, node2))
            heapq.heappush(heap, new_node)
        
        # 生成编码
        codes = {}
        def generate_codes(node, code=""):
            if isinstance(node, int):
                codes[node] = code
            else:
                generate_codes(node[0], code + "0")
                generate_codes(node[1], code + "1")
        
        if heap:
            generate_codes(heap[0][1])
        
        return codes
    
    @staticmethod
    def dijkstra_shortest_path(graph: dict, start: str) -> dict:
        """Dijkstra最短路径 - O(V²)"""
        distances = {node: float('infinity') for node in graph}
        distances[start] = 0
        unvisited = set(graph.keys())
        
        while unvisited:
            # 找到距离最小的未访问节点
            current = min(unvisited, key=lambda x: distances[x])
            unvisited.remove(current)
            
            # 更新邻居距离
            for neighbor, weight in graph[current].items():
                if neighbor in unvisited:
                    new_distance = distances[current] + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
        
        return distances

class AlgorithmComparison:
    """算法比较器"""
    
    def __init__(self):
        self.analyzer = AlgorithmAnalyzer()
    
    def compare_sorting_algorithms(self, input_sizes: List[int]):
        """比较排序算法"""
        algorithms = {
            'Bubble Sort': SortingAlgorithms.bubble_sort,
            'Merge Sort': SortingAlgorithms.merge_sort,
            'Quick Sort': SortingAlgorithms.quick_sort,
            'Heap Sort': SortingAlgorithms.heap_sort
        }
        
        results = {}
        
        for name, algorithm in algorithms.items():
            times = self.analyzer.analyze_complexity(algorithm, input_sizes)
            complexity = self.analyzer.estimate_complexity(input_sizes, times)
            results[name] = {
                'times': times,
                'complexity': complexity
            }
        
        return results
    
    def compare_search_algorithms(self, input_sizes: List[int]):
        """比较搜索算法"""
        algorithms = {
            'Linear Search': lambda arr: SearchAlgorithms.linear_search(arr, arr[-1]),
            'Binary Search': lambda arr: SearchAlgorithms.binary_search(sorted(arr), arr[-1])
        }
        
        results = {}
        
        for name, algorithm in algorithms.items():
            times = self.analyzer.analyze_complexity(algorithm, input_sizes)
            complexity = self.analyzer.estimate_complexity(input_sizes, times)
            results[name] = {
                'times': times,
                'complexity': complexity
            }
        
        return results

# 使用示例
def demonstrate_algorithm_theory():
    """演示算法理论"""
    
    print("=== 排序算法演示 ===\n")
    
    # 测试排序算法
    test_array = [64, 34, 25, 12, 22, 11, 90]
    print(f"原始数组: {test_array}")
    
    print(f"冒泡排序: {SortingAlgorithms.bubble_sort(test_array)}")
    print(f"归并排序: {SortingAlgorithms.merge_sort(test_array)}")
    print(f"快速排序: {SortingAlgorithms.quick_sort(test_array)}")
    print(f"堆排序: {SortingAlgorithms.heap_sort(test_array)}")
    
    print("\n=== 搜索算法演示 ===\n")
    
    # 测试搜索算法
    sorted_array = [1, 3, 5, 7, 9, 11, 13, 15]
    target = 7
    
    print(f"数组: {sorted_array}")
    print(f"目标: {target}")
    
    linear_result = SearchAlgorithms.linear_search(sorted_array, target)
    binary_result = SearchAlgorithms.binary_search(sorted_array, target)
    
    print(f"线性搜索结果: {linear_result}")
    print(f"二分搜索结果: {binary_result}")
    
    print("\n=== 动态规划演示 ===\n")
    
    # 测试动态规划算法
    n = 10
    print(f"斐波那契数列 F({n}) = {DynamicProgramming.fibonacci_dp(n)}")
    
    str1, str2 = "ABCDGH", "AEDFHR"
    lcs_length = DynamicProgramming.longest_common_subsequence(str1, str2)
    print(f"最长公共子序列长度: {lcs_length}")
    
    weights = [2, 1, 3, 2]
    values = [12, 10, 20, 15]
    capacity = 5
    max_value = DynamicProgramming.knapsack_01(weights, values, capacity)
    print(f"0-1背包最大价值: {max_value}")
    
    print("\n=== 贪心算法演示 ===\n")
    
    # 测试贪心算法
    start_times = [1, 3, 0, 5, 8, 5]
    end_times = [2, 4, 6, 7, 9, 9]
    selected_activities = GreedyAlgorithms.activity_selection(start_times, end_times)
    print(f"活动选择结果: {selected_activities}")
    
    frequencies = [5, 9, 12, 13, 16, 45]
    huffman_codes = GreedyAlgorithms.huffman_encoding(frequencies)
    print(f"霍夫曼编码: {huffman_codes}")
    
    print("\n=== 算法复杂度分析 ===\n")
    
    # 算法复杂度分析
    comparator = AlgorithmComparison()
    input_sizes = [100, 500, 1000, 2000]
    
    sorting_results = comparator.compare_sorting_algorithms(input_sizes)
    print("排序算法复杂度分析:")
    for name, result in sorting_results.items():
        print(f"  {name}: {result['complexity']}")
    
    search_results = comparator.compare_search_algorithms(input_sizes)
    print("\n搜索算法复杂度分析:")
    for name, result in search_results.items():
        print(f"  {name}: {result['complexity']}")

if __name__ == "__main__":
    demonstrate_algorithm_theory()
```

### 9.2 高级算法实现

```python
import numpy as np
from typing import List, Tuple, Set
import heapq
from collections import defaultdict, deque

class AdvancedAlgorithms:
    """高级算法实现"""
    
    @staticmethod
    def topological_sort(graph: dict) -> List[str]:
        """拓扑排序 - O(V + E)"""
        in_degree = defaultdict(int)
        for node in graph:
            for neighbor in graph[node]:
                in_degree[neighbor] += 1
        
        queue = deque([node for node in graph if in_degree[node] == 0])
        result = []
        
        while queue:
            node = queue.popleft()
            result.append(node)
            
            for neighbor in graph.get(node, []):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result if len(result) == len(graph) else []
    
    @staticmethod
    def strongly_connected_components(graph: dict) -> List[List[str]]:
        """强连通分量 - Kosaraju算法 - O(V + E)"""
        def dfs_first(node, visited, stack):
            visited.add(node)
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    dfs_first(neighbor, visited, stack)
            stack.append(node)
        
        def dfs_second(node, visited, component):
            visited.add(node)
            component.append(node)
            for neighbor in reversed_graph.get(node, []):
                if neighbor not in visited:
                    dfs_second(neighbor, visited, component)
        
        # 第一次DFS
        visited = set()
        stack = []
        for node in graph:
            if node not in visited:
                dfs_first(node, visited, stack)
        
        # 构建反向图
        reversed_graph = defaultdict(list)
        for node in graph:
            for neighbor in graph[node]:
                reversed_graph[neighbor].append(node)
        
        # 第二次DFS
        visited = set()
        components = []
        for node in reversed(stack):
            if node not in visited:
                component = []
                dfs_second(node, visited, component)
                components.append(component)
        
        return components
    
    @staticmethod
    def minimum_spanning_tree_kruskal(edges: List[Tuple], num_vertices: int) -> List[Tuple]:
        """Kruskal最小生成树算法 - O(E log E)"""
        def find(parent, x):
            if parent[x] != x:
                parent[x] = find(parent, parent[x])
            return parent[x]
        
        def union(parent, rank, x, y):
            root_x, root_y = find(parent, x), find(parent, y)
            if root_x == root_y:
                return False
            
            if rank[root_x] < rank[root_y]:
                parent[root_x] = root_y
            elif rank[root_x] > rank[root_y]:
                parent[root_y] = root_x
            else:
                parent[root_y] = root_x
                rank[root_x] += 1
            return True
        
        # 按权重排序边
        edges.sort(key=lambda x: x[2])
        
        parent = list(range(num_vertices))
        rank = [0] * num_vertices
        mst = []
        
        for u, v, weight in edges:
            if union(parent, rank, u, v):
                mst.append((u, v, weight))
                if len(mst) == num_vertices - 1:
                    break
        
        return mst
    
    @staticmethod
    def minimum_spanning_tree_prim(graph: dict, start: str) -> List[Tuple]:
        """Prim最小生成树算法 - O(E log V)"""
        visited = set()
        mst = []
        heap = [(0, start, None)]
        
        while heap and len(visited) < len(graph):
            weight, current, parent = heapq.heappop(heap)
            
            if current in visited:
                continue
            
            visited.add(current)
            if parent is not None:
                mst.append((parent, current, weight))
            
            for neighbor, edge_weight in graph[current].items():
                if neighbor not in visited:
                    heapq.heappush(heap, (edge_weight, neighbor, current))
        
        return mst
    
    @staticmethod
    def floyd_warshall(graph: List[List[float]]) -> List[List[float]]:
        """Floyd-Warshall全源最短路径 - O(V³)"""
        n = len(graph)
        dist = [row[:] for row in graph]
        
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
        
        return dist
    
    @staticmethod
    def bellman_ford(edges: List[Tuple], num_vertices: int, start: int) -> List[float]:
        """Bellman-Ford单源最短路径 - O(VE)"""
        distances = [float('infinity')] * num_vertices
        distances[start] = 0
        
        for _ in range(num_vertices - 1):
            for u, v, weight in edges:
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
        
        # 检查负权环
        for u, v, weight in edges:
            if distances[u] + weight < distances[v]:
                raise ValueError("图中存在负权环")
        
        return distances
    
    @staticmethod
    def max_flow_ford_fulkerson(graph: dict, source: str, sink: str) -> int:
        """Ford-Fulkerson最大流算法 - O(VE²)"""
        def bfs(graph, source, sink, parent):
            visited = set()
            queue = deque([source])
            visited.add(source)
            
            while queue:
                u = queue.popleft()
                for v, capacity in graph[u].items():
                    if v not in visited and capacity > 0:
                        queue.append(v)
                        visited.add(v)
                        parent[v] = u
                        if v == sink:
                            return True
            return False
        
        # 创建残差图
        residual_graph = defaultdict(dict)
        for u in graph:
            for v, capacity in graph[u].items():
                residual_graph[u][v] = capacity
                residual_graph[v][u] = 0
        
        parent = {}
        max_flow = 0
        
        while bfs(residual_graph, source, sink, parent):
            path_flow = float('infinity')
            v = sink
            
            # 找到路径上的最小容量
            while v != source:
                u = parent[v]
                path_flow = min(path_flow, residual_graph[u][v])
                v = u
            
            # 更新残差图
            v = sink
            while v != source:
                u = parent[v]
                residual_graph[u][v] -= path_flow
                residual_graph[v][u] += path_flow
                v = u
            
            max_flow += path_flow
        
        return max_flow
    
    @staticmethod
    def hungarian_algorithm(cost_matrix: List[List[int]]) -> Tuple[int, List[int]]:
        """匈牙利算法 - 二分图最大权匹配 - O(V³)"""
        n = len(cost_matrix)
        m = len(cost_matrix[0])
        
        # 初始化
        row_ind = [-1] * n
        col_ind = [-1] * m
        row_cover = [False] * n
        col_cover = [False] * m
        
        # 步骤1: 行约简
        for i in range(n):
            min_val = min(cost_matrix[i])
            for j in range(m):
                cost_matrix[i][j] -= min_val
        
        # 步骤2: 列约简
        for j in range(m):
            min_val = min(cost_matrix[i][j] for i in range(n))
            for i in range(n):
                cost_matrix[i][j] -= min_val
        
        # 步骤3: 用最少的线覆盖所有零
        while True:
            # 标记所有未覆盖的零
            marked = [[False] * m for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if cost_matrix[i][j] == 0 and not row_cover[i] and not col_cover[j]:
                        marked[i][j] = True
            
            # 找到独立零
            for i in range(n):
                for j in range(m):
                    if marked[i][j]:
                        row_ind[i] = j
                        col_ind[j] = i
                        row_cover[i] = True
                        col_cover[j] = True
            
            # 检查是否完成
            if sum(row_cover) == n:
                break
            
            # 用最少的线覆盖所有零
            uncovered_zeros = []
            for i in range(n):
                for j in range(m):
                    if cost_matrix[i][j] == 0 and not row_cover[i] and not col_cover[j]:
                        uncovered_zeros.append((i, j))
            
            if not uncovered_zeros:
                # 找到未覆盖元素的最小值
                min_val = float('infinity')
                for i in range(n):
                    for j in range(m):
                        if not row_cover[i] and not col_cover[j]:
                            min_val = min(min_val, cost_matrix[i][j])
                
                # 减去未覆盖行的最小值，加上覆盖列的最小值
                for i in range(n):
                    for j in range(m):
                        if not row_cover[i] and not col_cover[j]:
                            cost_matrix[i][j] -= min_val
                        elif row_cover[i] and col_cover[j]:
                            cost_matrix[i][j] += min_val
        
        # 计算总成本
        total_cost = 0
        for i in range(n):
            if row_ind[i] != -1:
                total_cost += cost_matrix[i][row_ind[i]]
        
        return total_cost, row_ind

# 使用示例
def demonstrate_advanced_algorithms():
    """演示高级算法"""
    
    print("=== 拓扑排序演示 ===\n")
    
    # 拓扑排序
    graph = {
        'A': ['B', 'C'],
        'B': ['D'],
        'C': ['D'],
        'D': ['E'],
        'E': []
    }
    
    topo_order = AdvancedAlgorithms.topological_sort(graph)
    print(f"拓扑排序结果: {topo_order}")
    
    print("\n=== 强连通分量演示 ===\n")
    
    # 强连通分量
    scc_graph = {
        'A': ['B'],
        'B': ['C'],
        'C': ['A'],
        'D': ['E'],
        'E': ['D']
    }
    
    scc_components = AdvancedAlgorithms.strongly_connected_components(scc_graph)
    print(f"强连通分量: {scc_components}")
    
    print("\n=== 最小生成树演示 ===\n")
    
    # Kruskal算法
    edges = [(0, 1, 4), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 4)]
    mst_kruskal = AdvancedAlgorithms.minimum_spanning_tree_kruskal(edges, 4)
    print(f"Kruskal最小生成树: {mst_kruskal}")
    
    # Prim算法
    prim_graph = {
        'A': {'B': 4, 'C': 3},
        'B': {'A': 4, 'C': 1, 'D': 2},
        'C': {'A': 3, 'B': 1, 'D': 4},
        'D': {'B': 2, 'C': 4}
    }
    
    mst_prim = AdvancedAlgorithms.minimum_spanning_tree_prim(prim_graph, 'A')
    print(f"Prim最小生成树: {mst_prim}")
    
    print("\n=== 最短路径演示 ===\n")
    
    # Floyd-Warshall算法
    floyd_graph = [
        [0, 3, 8, float('infinity'), -4],
        [float('infinity'), 0, float('infinity'), 1, 7],
        [float('infinity'), 4, 0, float('infinity'), float('infinity')],
        [2, float('infinity'), -5, 0, float('infinity')],
        [float('infinity'), float('infinity'), float('infinity'), 6, 0]
    ]
    
    floyd_result = AdvancedAlgorithms.floyd_warshall(floyd_graph)
    print("Floyd-Warshall全源最短路径:")
    for i, row in enumerate(floyd_result):
        print(f"  从节点{i}: {row}")
    
    # Bellman-Ford算法
    bellman_edges = [(0, 1, 3), (0, 2, 8), (1, 3, 1), (2, 1, 4), (3, 2, -5), (3, 4, 6)]
    bellman_result = AdvancedAlgorithms.bellman_ford(bellman_edges, 5, 0)
    print(f"Bellman-Ford单源最短路径: {bellman_result}")
    
    print("\n=== 最大流演示 ===\n")
    
    # Ford-Fulkerson算法
    flow_graph = {
        'S': {'A': 10, 'B': 10},
        'A': {'B': 2, 'T': 8},
        'B': {'T': 10},
        'T': {}
    }
    
    max_flow = AdvancedAlgorithms.max_flow_ford_fulkerson(flow_graph, 'S', 'T')
    print(f"最大流: {max_flow}")
    
    print("\n=== 匈牙利算法演示 ===\n")
    
    # 匈牙利算法
    cost_matrix = [
        [3, 1, 4],
        [2, 0, 5],
        [3, 2, 2]
    ]
    
    total_cost, assignment = AdvancedAlgorithms.hungarian_algorithm(cost_matrix)
    print(f"最小成本: {total_cost}")
    print(f"最优分配: {assignment}")

if __name__ == "__main__":
    demonstrate_advanced_algorithms()
```

## 10. 参考文献

1. Cormen, T. H., et al. (2009). "Introduction to Algorithms".
2. Knuth, D. E. (1997). "The Art of Computer Programming".
3. Sedgewick, R., & Wayne, K. (2011). "Algorithms".
4. Kleinberg, J., & Tardos, É. (2006). "Algorithm Design".

---

**相关文档**:
- [02-02-数据结构理论](./02-02-数据结构理论.md)
- [02-03-计算复杂性](./02-03-计算复杂性.md)
- [06-08-算法实现](./../06-组件算法/06-08-算法实现.md)

**最后更新**: 2024-01-XX  
**版本**: 1.0.0 