# 02-01 ç®—æ³•ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç®—æ³•ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒç†è®ºåŸºç¡€ï¼Œç ”ç©¶ç®—æ³•çš„è®¾è®¡ã€åˆ†æå’Œä¼˜åŒ–ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°ç®—æ³•çš„åŸºæœ¬æ¦‚å¿µã€å¤æ‚åº¦ç†è®ºå’Œè®¾è®¡æ–¹æ³•ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç®—æ³•åŸºç¡€

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (ç®—æ³•)
ç®—æ³•æ˜¯ä¸€ä¸ªæœ‰é™çš„è®¡ç®—è¿‡ç¨‹ï¼Œå¯ä»¥å½¢å¼åŒ–ä¸ºï¼š
$$A = (I, O, S, \delta, \lambda)$$
å…¶ä¸­ï¼š

- $I$ æ˜¯è¾“å…¥é›†åˆ
- $O$ æ˜¯è¾“å‡ºé›†åˆ
- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $\delta: S \times I \rightarrow S$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $\lambda: S \times I \rightarrow O$ æ˜¯è¾“å‡ºå‡½æ•°

**å®šä¹‰ 1.2** (ç®—æ³•çš„æ­£ç¡®æ€§)
ç®—æ³• $A$ å¯¹äºé—®é¢˜ $P$ æ˜¯æ­£ç¡®çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x \in I: A(x) = P(x)$$

**å®šä¹‰ 1.3** (ç®—æ³•çš„ç»ˆæ­¢æ€§)
ç®—æ³• $A$ æ˜¯ç»ˆæ­¢çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x \in I: \exists n \in \mathbb{N}: A(x) \text{ åœ¨ } n \text{ æ­¥å†…ç»ˆæ­¢}$$

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Any, Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import time
import math

T = TypeVar('T')
U = TypeVar('U')

class AlgorithmState(Enum):
    """ç®—æ³•çŠ¶æ€"""
    INITIAL = "initial"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class AlgorithmStep:
    """ç®—æ³•æ­¥éª¤"""
    step_id: int
    state: Dict[str, Any]
    action: str
    timestamp: float

class Algorithm(ABC, Generic[T, U]):
    """ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.state = AlgorithmState.INITIAL
        self.steps: List[AlgorithmStep] = []
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None
    
    @abstractmethod
    def execute(self, input_data: T) -> U:
        """æ‰§è¡Œç®—æ³•"""
        pass
    
    def run(self, input_data: T) -> U:
        """è¿è¡Œç®—æ³•å¹¶è®°å½•æ­¥éª¤"""
        self.state = AlgorithmState.RUNNING
        self.start_time = time.time()
        self.steps.clear()
        
        try:
            result = self.execute(input_data)
            self.state = AlgorithmState.COMPLETED
            self.end_time = time.time()
            return result
        except Exception as e:
            self.state = AlgorithmState.FAILED
            self.end_time = time.time()
            raise e
    
    def add_step(self, action: str, state: Dict[str, Any]) -> None:
        """æ·»åŠ æ‰§è¡Œæ­¥éª¤"""
        step = AlgorithmStep(
            step_id=len(self.steps) + 1,
            state=state.copy(),
            action=action,
            timestamp=time.time()
        )
        self.steps.append(step)
    
    def get_execution_time(self) -> Optional[float]:
        """è·å–æ‰§è¡Œæ—¶é—´"""
        if self.start_time and self.end_time:
            return self.end_time - self.start_time
        return None
    
    def get_step_count(self) -> int:
        """è·å–æ­¥éª¤æ•°"""
        return len(self.steps)
    
    def print_execution_trace(self) -> None:
        """æ‰“å°æ‰§è¡Œè½¨è¿¹"""
        print(f"ç®—æ³•: {self.name}")
        print(f"çŠ¶æ€: {self.state.value}")
        print(f"æ‰§è¡Œæ—¶é—´: {self.get_execution_time():.6f}ç§’")
        print(f"æ­¥éª¤æ•°: {self.get_step_count()}")
        print("\næ‰§è¡Œè½¨è¿¹:")
        print("-" * 50)
        
        for step in self.steps:
            print(f"æ­¥éª¤ {step.step_id}: {step.action}")
            print(f"  çŠ¶æ€: {step.state}")
            print(f"  æ—¶é—´: {step.timestamp:.6f}")

class SortingAlgorithm(Algorithm[List[int], List[int]]):
    """æ’åºç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str):
        super().__init__(name)
    
    def is_sorted(self, arr: List[int]) -> bool:
        """æ£€æŸ¥æ•°ç»„æ˜¯å¦å·²æ’åº"""
        return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))
    
    def verify_correctness(self, original: List[int], sorted_arr: List[int]) -> bool:
        """éªŒè¯æ’åºæ­£ç¡®æ€§"""
        # æ£€æŸ¥æ’åºåçš„æ•°ç»„æ˜¯å¦æœ‰åº
        if not self.is_sorted(sorted_arr):
            return False
        
        # æ£€æŸ¥æ˜¯å¦åŒ…å«ç›¸åŒçš„å…ƒç´ 
        return sorted(original) == sorted_arr

class BubbleSort(SortingAlgorithm):
    """å†’æ³¡æ’åºç®—æ³•"""
    
    def __init__(self):
        super().__init__("Bubble Sort")
    
    def execute(self, arr: List[int]) -> List[int]:
        """æ‰§è¡Œå†’æ³¡æ’åº"""
        result = arr.copy()
        n = len(result)
        
        self.add_step("åˆå§‹åŒ–", {"array": result.copy(), "n": n})
        
        for i in range(n):
            swapped = False
            self.add_step(f"å¤–å±‚å¾ªç¯ {i+1}", {"i": i, "array": result.copy()})
            
            for j in range(0, n-i-1):
                self.add_step(f"å†…å±‚å¾ªç¯ {j+1}", {"i": i, "j": j, "array": result.copy()})
                
                if result[j] > result[j+1]:
                    # äº¤æ¢å…ƒç´ 
                    result[j], result[j+1] = result[j+1], result[j]
                    swapped = True
                    self.add_step("äº¤æ¢å…ƒç´ ", {"i": i, "j": j, "array": result.copy()})
            
            if not swapped:
                self.add_step("æå‰ç»ˆæ­¢", {"i": i, "array": result.copy()})
                break
        
        self.add_step("å®Œæˆ", {"array": result.copy()})
        return result

class QuickSort(SortingAlgorithm):
    """å¿«é€Ÿæ’åºç®—æ³•"""
    
    def __init__(self):
        super().__init__("Quick Sort")
    
    def execute(self, arr: List[int]) -> List[int]:
        """æ‰§è¡Œå¿«é€Ÿæ’åº"""
        result = arr.copy()
        self.add_step("åˆå§‹åŒ–", {"array": result.copy()})
        
        self._quick_sort(result, 0, len(result) - 1)
        
        self.add_step("å®Œæˆ", {"array": result.copy()})
        return result
    
    def _quick_sort(self, arr: List[int], low: int, high: int) -> None:
        """é€’å½’å¿«é€Ÿæ’åº"""
        if low < high:
            self.add_step(f"åˆ†åŒºæ’åº [{low}, {high}]", {"array": arr.copy(), "low": low, "high": high})
            
            # åˆ†åŒº
            pi = self._partition(arr, low, high)
            
            # é€’å½’æ’åº
            self._quick_sort(arr, low, pi - 1)
            self._quick_sort(arr, pi + 1, high)
    
    def _partition(self, arr: List[int], low: int, high: int) -> int:
        """åˆ†åŒºå‡½æ•°"""
        pivot = arr[high]
        i = low - 1
        
        self.add_step("é€‰æ‹©åŸºå‡†", {"pivot": pivot, "array": arr.copy()})
        
        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
                self.add_step("ç§»åŠ¨å…ƒç´ ", {"i": i, "j": j, "array": arr.copy()})
        
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        self.add_step("æ”¾ç½®åŸºå‡†", {"pivot_index": i + 1, "array": arr.copy()})
        
        return i + 1

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_sorting_algorithms():
    """æ¼”ç¤ºæ’åºç®—æ³•"""
    # æµ‹è¯•æ•°æ®
    test_data = [64, 34, 25, 12, 22, 11, 90]
    print(f"åŸå§‹æ•°ç»„: {test_data}")
    
    # å†’æ³¡æ’åº
    bubble_sort = BubbleSort()
    bubble_result = bubble_sort.run(test_data)
    print(f"\nå†’æ³¡æ’åºç»“æœ: {bubble_result}")
    print(f"æ­£ç¡®æ€§éªŒè¯: {bubble_sort.verify_correctness(test_data, bubble_result)}")
    
    # å¿«é€Ÿæ’åº
    quick_sort = QuickSort()
    quick_result = quick_sort.run(test_data)
    print(f"\nå¿«é€Ÿæ’åºç»“æœ: {quick_result}")
    print(f"æ­£ç¡®æ€§éªŒè¯: {quick_sort.verify_correctness(test_data, quick_result)}")
    
    # æ¯”è¾ƒæ€§èƒ½
    print(f"\næ€§èƒ½æ¯”è¾ƒ:")
    print(f"å†’æ³¡æ’åºæ‰§è¡Œæ—¶é—´: {bubble_sort.get_execution_time():.6f}ç§’")
    print(f"å¿«é€Ÿæ’åºæ‰§è¡Œæ—¶é—´: {quick_sort.get_execution_time():.6f}ç§’")

if __name__ == "__main__":
    demonstrate_sorting_algorithms()
```

### 2. ç®—æ³•å¤æ‚åº¦ç†è®º

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1** (æ—¶é—´å¤æ‚åº¦)
ç®—æ³• $A$ çš„æ—¶é—´å¤æ‚åº¦ $T_A(n)$ å®šä¹‰ä¸ºï¼š
$$T_A(n) = \max\{t_A(x) \mid |x| = n\}$$
å…¶ä¸­ $t_A(x)$ æ˜¯ç®—æ³• $A$ åœ¨è¾“å…¥ $x$ ä¸Šçš„æ‰§è¡Œæ—¶é—´ã€‚

**å®šä¹‰ 2.2** (ç©ºé—´å¤æ‚åº¦)
ç®—æ³• $A$ çš„ç©ºé—´å¤æ‚åº¦ $S_A(n)$ å®šä¹‰ä¸ºï¼š
$$S_A(n) = \max\{s_A(x) \mid |x| = n\}$$
å…¶ä¸­ $s_A(x)$ æ˜¯ç®—æ³• $A$ åœ¨è¾“å…¥ $x$ ä¸Šçš„å†…å­˜ä½¿ç”¨é‡ã€‚

**å®šä¹‰ 2.3** (æ¸è¿›å¤æ‚åº¦)
å¯¹äºå‡½æ•° $f(n)$ å’Œ $g(n)$ï¼š

- $f(n) = O(g(n))$ å½“ä¸”ä»…å½“ $\exists c > 0, n_0 > 0: \forall n \geq n_0: f(n) \leq c \cdot g(n)$
- $f(n) = \Omega(g(n))$ å½“ä¸”ä»…å½“ $\exists c > 0, n_0 > 0: \forall n \geq n_0: f(n) \geq c \cdot g(n)$
- $f(n) = \Theta(g(n))$ å½“ä¸”ä»…å½“ $f(n) = O(g(n))$ ä¸” $f(n) = \Omega(g(n))$

#### 2.2 Pythonå®ç°

```python
from typing import Callable, List, Dict, Any, Tuple
from dataclasses import dataclass
import time
import random
import matplotlib.pyplot as plt
import numpy as np

@dataclass
class ComplexityAnalysis:
    """å¤æ‚åº¦åˆ†æç»“æœ"""
    algorithm_name: str
    input_sizes: List[int]
    execution_times: List[float]
    space_usage: List[int]
    theoretical_complexity: str

class ComplexityAnalyzer:
    """å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.analyses: Dict[str, ComplexityAnalysis] = {}
    
    def analyze_algorithm(self, 
                         algorithm: Algorithm, 
                         input_generator: Callable[[int], Any],
                         input_sizes: List[int],
                         theoretical_complexity: str) -> ComplexityAnalysis:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        execution_times = []
        space_usage = []
        
        for size in input_sizes:
            # ç”Ÿæˆæµ‹è¯•æ•°æ®
            test_input = input_generator(size)
            
            # æµ‹é‡æ‰§è¡Œæ—¶é—´
            start_time = time.time()
            result = algorithm.run(test_input)
            end_time = time.time()
            
            execution_time = end_time - start_time
            execution_times.append(execution_time)
            
            # ä¼°ç®—ç©ºé—´ä½¿ç”¨ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
            space = self._estimate_space_usage(algorithm, test_input)
            space_usage.append(space)
        
        analysis = ComplexityAnalysis(
            algorithm_name=algorithm.name,
            input_sizes=input_sizes,
            execution_times=execution_times,
            space_usage=space_usage,
            theoretical_complexity=theoretical_complexity
        )
        
        self.analyses[algorithm.name] = analysis
        return analysis
    
    def _estimate_space_usage(self, algorithm: Algorithm, input_data: Any) -> int:
        """ä¼°ç®—ç©ºé—´ä½¿ç”¨é‡"""
        # ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„åˆ†æ
        if isinstance(input_data, list):
            return len(input_data) * 8  # å‡è®¾æ¯ä¸ªå…ƒç´ 8å­—èŠ‚
        elif isinstance(input_data, dict):
            return len(input_data) * 16  # å‡è®¾æ¯ä¸ªé”®å€¼å¯¹16å­—èŠ‚
        else:
            return 100  # é»˜è®¤å€¼
    
    def plot_complexity_comparison(self) -> None:
        """ç»˜åˆ¶å¤æ‚åº¦æ¯”è¾ƒå›¾"""
        plt.figure(figsize=(15, 10))
        
        # æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒ
        plt.subplot(2, 2, 1)
        for name, analysis in self.analyses.items():
            plt.plot(analysis.input_sizes, analysis.execution_times, 
                    marker='o', label=f"{name} (å®é™…)")
        
        # æ·»åŠ ç†è®ºå¤æ‚åº¦æ›²çº¿
        max_size = max(max(analysis.input_sizes) for analysis in self.analyses.values())
        x_theoretical = np.linspace(1, max_size, 100)
        
        # O(nÂ²) ç†è®ºæ›²çº¿
        y_n2 = x_theoretical ** 2 * 1e-6  # ç¼©æ”¾å› å­
        plt.plot(x_theoretical, y_n2, '--', label='O(nÂ²) ç†è®º', alpha=0.7)
        
        # O(n log n) ç†è®ºæ›²çº¿
        y_nlogn = x_theoretical * np.log(x_theoretical) * 1e-5  # ç¼©æ”¾å› å­
        plt.plot(x_theoretical, y_nlogn, '--', label='O(n log n) ç†è®º', alpha=0.7)
        
        plt.xlabel('è¾“å…¥å¤§å°')
        plt.ylabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
        plt.title('æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒ')
        plt.legend()
        plt.grid(True)
        
        # ç©ºé—´å¤æ‚åº¦æ¯”è¾ƒ
        plt.subplot(2, 2, 2)
        for name, analysis in self.analyses.items():
            plt.plot(analysis.input_sizes, analysis.space_usage, 
                    marker='s', label=name)
        
        plt.xlabel('è¾“å…¥å¤§å°')
        plt.ylabel('ç©ºé—´ä½¿ç”¨ (å­—èŠ‚)')
        plt.title('ç©ºé—´å¤æ‚åº¦æ¯”è¾ƒ')
        plt.legend()
        plt.grid(True)
        
        # å¯¹æ•°å°ºåº¦æ—¶é—´æ¯”è¾ƒ
        plt.subplot(2, 2, 3)
        for name, analysis in self.analyses.items():
            plt.loglog(analysis.input_sizes, analysis.execution_times, 
                      marker='o', label=name)
        
        plt.xlabel('è¾“å…¥å¤§å° (å¯¹æ•°å°ºåº¦)')
        plt.ylabel('æ‰§è¡Œæ—¶é—´ (å¯¹æ•°å°ºåº¦)')
        plt.title('å¯¹æ•°å°ºåº¦æ—¶é—´å¤æ‚åº¦')
        plt.legend()
        plt.grid(True)
        
        # å¤æ‚åº¦åˆ†æè¡¨æ ¼
        plt.subplot(2, 2, 4)
        plt.axis('off')
        
        table_data = []
        for name, analysis in self.analyses.items():
            table_data.append([
                name,
                analysis.theoretical_complexity,
                f"{analysis.execution_times[-1]:.6f}s",
                f"{analysis.space_usage[-1]} bytes"
            ])
        
        table = plt.table(cellText=table_data,
                         colLabels=['ç®—æ³•', 'ç†è®ºå¤æ‚åº¦', 'æœ€å¤§æ‰§è¡Œæ—¶é—´', 'æœ€å¤§ç©ºé—´ä½¿ç”¨'],
                         cellLoc='center',
                         loc='center')
        table.auto_set_font_size(False)
        table.set_fontsize(9)
        table.scale(1, 2)
        
        plt.tight_layout()
        plt.show()
    
    def print_analysis_summary(self) -> None:
        """æ‰“å°åˆ†ææ‘˜è¦"""
        print("ç®—æ³•å¤æ‚åº¦åˆ†ææ‘˜è¦")
        print("=" * 60)
        
        for name, analysis in self.analyses.items():
            print(f"\nç®—æ³•: {name}")
            print(f"ç†è®ºå¤æ‚åº¦: {analysis.theoretical_complexity}")
            print(f"æœ€å¤§æ‰§è¡Œæ—¶é—´: {analysis.execution_times[-1]:.6f}ç§’")
            print(f"æœ€å¤§ç©ºé—´ä½¿ç”¨: {analysis.space_usage[-1]}å­—èŠ‚")
            
            # è®¡ç®—å¢é•¿ç‡
            if len(analysis.execution_times) >= 2:
                growth_rate = analysis.execution_times[-1] / analysis.execution_times[-2]
                print(f"æ‰§è¡Œæ—¶é—´å¢é•¿ç‡: {growth_rate:.2f}x")

def generate_random_array(size: int) -> List[int]:
    """ç”Ÿæˆéšæœºæ•°ç»„"""
    return [random.randint(1, 1000) for _ in range(size)]

# ç¤ºä¾‹ï¼šå¤æ‚åº¦åˆ†æ
def demonstrate_complexity_analysis():
    """æ¼”ç¤ºå¤æ‚åº¦åˆ†æ"""
    analyzer = ComplexityAnalyzer()
    
    # æµ‹è¯•ä¸åŒå¤§å°çš„è¾“å…¥
    input_sizes = [100, 200, 400, 800, 1600]
    
    # åˆ†æå†’æ³¡æ’åº
    bubble_sort = BubbleSort()
    bubble_analysis = analyzer.analyze_algorithm(
        bubble_sort, generate_random_array, input_sizes, "O(nÂ²)"
    )
    
    # åˆ†æå¿«é€Ÿæ’åº
    quick_sort = QuickSort()
    quick_analysis = analyzer.analyze_algorithm(
        quick_sort, generate_random_array, input_sizes, "O(n log n)"
    )
    
    # æ˜¾ç¤ºåˆ†æç»“æœ
    analyzer.print_analysis_summary()
    analyzer.plot_complexity_comparison()

if __name__ == "__main__":
    demonstrate_complexity_analysis()
```

### 3. ç®—æ³•è®¾è®¡æ–¹æ³•

#### 3.1 åˆ†æ²»æ³•

**å®šä¹‰ 3.1** (åˆ†æ²»ç®—æ³•)
åˆ†æ²»ç®—æ³•å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œé€’å½’æ±‚è§£ï¼Œç„¶ååˆå¹¶ç»“æœï¼š
$$T(n) = aT(n/b) + f(n)$$
å…¶ä¸­ $a$ æ˜¯å­é—®é¢˜æ•°ï¼Œ$b$ æ˜¯é—®é¢˜è§„æ¨¡ç¼©å°å› å­ï¼Œ$f(n)$ æ˜¯åˆå¹¶æˆæœ¬ã€‚

**ä¸»å®šç†** (Master Theorem)
å¯¹äºé€’å½’å¼ $T(n) = aT(n/b) + f(n)$ï¼Œå…¶ä¸­ $a \geq 1, b > 1$ï¼š

- å¦‚æœ $f(n) = O(n^{\log_b a - \epsilon})$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a})$
- å¦‚æœ $f(n) = \Theta(n^{\log_b a} \log^k n)$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a} \log^{k+1} n)$
- å¦‚æœ $f(n) = \Omega(n^{\log_b a + \epsilon})$ï¼Œåˆ™ $T(n) = \Theta(f(n))$

#### 3.2 Pythonå®ç°

```python
from typing import List, Tuple, Any
import math

class DivideAndConquerAlgorithm(Algorithm):
    """åˆ†æ²»ç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str):
        super().__init__(name)
    
    @abstractmethod
    def divide(self, problem: Any) -> List[Any]:
        """åˆ†è§£é—®é¢˜"""
        pass
    
    @abstractmethod
    def conquer(self, subproblems: List[Any]) -> Any:
        """åˆå¹¶å­é—®é¢˜ç»“æœ"""
        pass
    
    @abstractmethod
    def solve_base_case(self, problem: Any) -> Any:
        """è§£å†³åŸºæœ¬æƒ…å†µ"""
        pass
    
    def is_base_case(self, problem: Any) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºåŸºæœ¬æƒ…å†µ"""
        pass
    
    def execute(self, problem: Any) -> Any:
        """æ‰§è¡Œåˆ†æ²»ç®—æ³•"""
        self.add_step("å¼€å§‹åˆ†æ²»", {"problem_size": self._get_problem_size(problem)})
        
        if self.is_base_case(problem):
            result = self.solve_base_case(problem)
            self.add_step("è§£å†³åŸºæœ¬æƒ…å†µ", {"result": result})
            return result
        
        # åˆ†è§£
        subproblems = self.divide(problem)
        self.add_step("åˆ†è§£é—®é¢˜", {"subproblems_count": len(subproblems)})
        
        # é€’å½’æ±‚è§£
        subresults = []
        for i, subproblem in enumerate(subproblems):
            self.add_step(f"é€’å½’æ±‚è§£å­é—®é¢˜ {i+1}", {"subproblem": subproblem})
            subresult = self.execute(subproblem)
            subresults.append(subresult)
        
        # åˆå¹¶
        result = self.conquer(subresults)
        self.add_step("åˆå¹¶ç»“æœ", {"result": result})
        
        return result
    
    def _get_problem_size(self, problem: Any) -> int:
        """è·å–é—®é¢˜è§„æ¨¡"""
        if isinstance(problem, list):
            return len(problem)
        elif isinstance(problem, str):
            return len(problem)
        else:
            return 1

class MergeSort(DivideAndConquerAlgorithm):
    """å½’å¹¶æ’åºç®—æ³•"""
    
    def __init__(self):
        super().__init__("Merge Sort")
    
    def is_base_case(self, arr: List[int]) -> bool:
        return len(arr) <= 1
    
    def solve_base_case(self, arr: List[int]) -> List[int]:
        return arr.copy()
    
    def divide(self, arr: List[int]) -> List[List[int]]:
        mid = len(arr) // 2
        return [arr[:mid], arr[mid:]]
    
    def conquer(self, subresults: List[List[int]]) -> List[int]:
        return self._merge(subresults[0], subresults[1])
    
    def _merge(self, left: List[int], right: List[int]) -> List[int]:
        """åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        # æ·»åŠ å‰©ä½™å…ƒç´ 
        result.extend(left[i:])
        result.extend(right[j:])
        
        return result

class StrassenMatrixMultiplication(DivideAndConquerAlgorithm):
    """StrassençŸ©é˜µä¹˜æ³•ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Strassen Matrix Multiplication")
    
    def is_base_case(self, matrices: Tuple[List[List[int]], List[List[int]]]) -> bool:
        A, B = matrices
        return len(A) <= 2
    
    def solve_base_case(self, matrices: Tuple[List[List[int]], List[List[int]]]) -> List[List[int]]:
        A, B = matrices
        if len(A) == 1:
            return [[A[0][0] * B[0][0]]]
        else:
            return self._standard_multiply(A, B)
    
    def divide(self, matrices: Tuple[List[List[int]], List[List[int]]]) -> List[Tuple[List[List[int]], List[List[int]]]]:
        A, B = matrices
        n = len(A)
        mid = n // 2
        
        # åˆ†è§£çŸ©é˜µA
        A11 = [row[:mid] for row in A[:mid]]
        A12 = [row[mid:] for row in A[:mid]]
        A21 = [row[:mid] for row in A[mid:]]
        A22 = [row[mid:] for row in A[mid:]]
        
        # åˆ†è§£çŸ©é˜µB
        B11 = [row[:mid] for row in B[:mid]]
        B12 = [row[mid:] for row in B[:mid]]
        B21 = [row[:mid] for row in B[mid:]]
        B22 = [row[mid:] for row in B[mid:]]
        
        # åˆ›å»ºå­é—®é¢˜
        subproblems = [
            ((A11, B11), (A12, B21)),  # P1 = A11 * (B12 - B22)
            ((A11, B12), (A12, B22)),  # P2 = (A11 + A12) * B22
            ((A21, B11), (A22, B21)),  # P3 = (A21 + A22) * B11
            ((A21, B12), (A22, B22)),  # P4 = A22 * (B21 - B11)
            ((A11, B11), (A11, B22)),  # P5 = (A11 + A22) * (B11 + B22)
            ((A12, B21), (A12, B22)),  # P6 = (A12 - A22) * (B21 + B22)
            ((A11, B12), (A21, B12)),  # P7 = (A11 - A21) * (B11 + B12)
        ]
        
        return subproblems
    
    def conquer(self, subresults: List[List[List[int]]]) -> List[List[int]]:
        # Strassenå…¬å¼
        P1, P2, P3, P4, P5, P6, P7 = subresults
        n = len(P1)
        
        # è®¡ç®—CçŸ©é˜µçš„å››ä¸ªå­çŸ©é˜µ
        C11 = self._add_matrices(P5, P4)
        C11 = self._subtract_matrices(C11, P2)
        C11 = self._add_matrices(C11, P6)
        
        C12 = self._add_matrices(P1, P2)
        C21 = self._add_matrices(P3, P4)
        C22 = self._add_matrices(P5, P1)
        C22 = self._subtract_matrices(C22, P3)
        C22 = self._subtract_matrices(C22, P7)
        
        # åˆå¹¶å­çŸ©é˜µ
        result = []
        for i in range(n):
            result.append(C11[i] + C12[i])
        for i in range(n):
            result.append(C21[i] + C22[i])
        
        return result
    
    def _add_matrices(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        """çŸ©é˜µåŠ æ³•"""
        return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]
    
    def _subtract_matrices(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        """çŸ©é˜µå‡æ³•"""
        return [[A[i][j] - B[i][j] for j in range(len(A[0]))] for i in range(len(A))]
    
    def _standard_multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        """æ ‡å‡†çŸ©é˜µä¹˜æ³•"""
        n = len(A)
        result = [[0 for _ in range(n)] for _ in range(n)]
        
        for i in range(n):
            for j in range(n):
                for k in range(n):
                    result[i][j] += A[i][k] * B[k][j]
        
        return result

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_divide_and_conquer():
    """æ¼”ç¤ºåˆ†æ²»ç®—æ³•"""
    # å½’å¹¶æ’åº
    merge_sort = MergeSort()
    test_array = [64, 34, 25, 12, 22, 11, 90]
    result = merge_sort.run(test_array)
    print(f"å½’å¹¶æ’åºç»“æœ: {result}")
    
    # StrassençŸ©é˜µä¹˜æ³•
    strassen = StrassenMatrixMultiplication()
    A = [[1, 2], [3, 4]]
    B = [[5, 6], [7, 8]]
    result = strassen.run((A, B))
    print(f"StrassençŸ©é˜µä¹˜æ³•ç»“æœ: {result}")

if __name__ == "__main__":
    demonstrate_divide_and_conquer()
```

## ğŸ“Š ç®—æ³•ä¼˜åŒ–

### 1. åŠ¨æ€è§„åˆ’

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 4.1** (æœ€ä¼˜å­ç»“æ„)
é—®é¢˜å…·æœ‰æœ€ä¼˜å­ç»“æ„ï¼Œå¦‚æœé—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å…¶å­é—®é¢˜çš„æœ€ä¼˜è§£ã€‚

**å®šä¹‰ 4.2** (é‡å å­é—®é¢˜)
é—®é¢˜å…·æœ‰é‡å å­é—®é¢˜ï¼Œå¦‚æœé€’å½’ç®—æ³•é‡å¤æ±‚è§£ç›¸åŒçš„å­é—®é¢˜ã€‚

**å®šä¹‰ 4.3** (åŠ¨æ€è§„åˆ’)
åŠ¨æ€è§„åˆ’æ˜¯é€šè¿‡å­˜å‚¨å­é—®é¢˜çš„è§£æ¥é¿å…é‡å¤è®¡ç®—çš„ä¼˜åŒ–æŠ€æœ¯ã€‚

#### 1.2 Pythonå®ç°

```python
from typing import Dict, List, Any, Optional
from functools import lru_cache

class DynamicProgrammingAlgorithm(Algorithm):
    """åŠ¨æ€è§„åˆ’ç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.memo: Dict[str, Any] = {}
    
    def memoize(self, key: str, value: Any) -> None:
        """è®°å¿†åŒ–å­˜å‚¨"""
        self.memo[key] = value
    
    def get_memoized(self, key: str) -> Optional[Any]:
        """è·å–è®°å¿†åŒ–çš„å€¼"""
        return self.memo.get(key)
    
    def clear_memo(self) -> None:
        """æ¸…é™¤è®°å¿†åŒ–ç¼“å­˜"""
        self.memo.clear()

class FibonacciDP(DynamicProgrammingAlgorithm):
    """åŠ¨æ€è§„åˆ’æ–æ³¢é‚£å¥‘æ•°åˆ—"""
    
    def __init__(self):
        super().__init__("Fibonacci DP")
    
    def execute(self, n: int) -> int:
        """è®¡ç®—ç¬¬nä¸ªæ–æ³¢é‚£å¥‘æ•°"""
        self.add_step("å¼€å§‹è®¡ç®—", {"n": n})
        
        if n <= 1:
            result = n
            self.add_step("åŸºæœ¬æƒ…å†µ", {"n": n, "result": result})
            return result
        
        # æ£€æŸ¥æ˜¯å¦å·²è®¡ç®—
        memo_key = f"fib_{n}"
        if self.get_memoized(memo_key) is not None:
            result = self.get_memoized(memo_key)
            self.add_step("ä½¿ç”¨ç¼“å­˜", {"n": n, "result": result})
            return result
        
        # é€’å½’è®¡ç®—
        self.add_step("é€’å½’è®¡ç®—", {"n": n})
        result = self.execute(n-1) + self.execute(n-2)
        
        # å­˜å‚¨ç»“æœ
        self.memoize(memo_key, result)
        self.add_step("å­˜å‚¨ç»“æœ", {"n": n, "result": result})
        
        return result

class LongestCommonSubsequence(DynamicProgrammingAlgorithm):
    """æœ€é•¿å…¬å…±å­åºåˆ—"""
    
    def __init__(self):
        super().__init__("Longest Common Subsequence")
    
    def execute(self, input_data: Tuple[str, str]) -> str:
        """è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—"""
        str1, str2 = input_data
        self.add_step("å¼€å§‹è®¡ç®—", {"str1": str1, "str2": str2})
        
        # æ„å»ºDPè¡¨
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # å¡«å……DPè¡¨
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        self.add_step("DPè¡¨æ„å»ºå®Œæˆ", {"dp_table": dp})
        
        # å›æº¯æ„é€ LCS
        lcs = []
        i, j = m, n
        while i > 0 and j > 0:
            if str1[i-1] == str2[j-1]:
                lcs.append(str1[i-1])
                i -= 1
                j -= 1
            elif dp[i-1][j] > dp[i][j-1]:
                i -= 1
            else:
                j -= 1
        
        result = ''.join(reversed(lcs))
        self.add_step("æ„é€ LCS", {"lcs": result})
        
        return result

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_dynamic_programming():
    """æ¼”ç¤ºåŠ¨æ€è§„åˆ’"""
    # æ–æ³¢é‚£å¥‘æ•°åˆ—
    fib_dp = FibonacciDP()
    result = fib_dp.run(10)
    print(f"ç¬¬10ä¸ªæ–æ³¢é‚£å¥‘æ•°: {result}")
    print(f"ç¼“å­˜å¤§å°: {len(fib_dp.memo)}")
    
    # æœ€é•¿å…¬å…±å­åºåˆ—
    lcs = LongestCommonSubsequence()
    result = lcs.run(("ABCDGH", "AEDFHR"))
    print(f"LCSç»“æœ: {result}")

if __name__ == "__main__":
    demonstrate_dynamic_programming()
```

## ğŸ“ˆ æ€»ç»“

ç®—æ³•ç†è®ºä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†ï¼š

1. **è®¾è®¡æ–¹æ³•è®º**ï¼šåˆ†æ²»ã€åŠ¨æ€è§„åˆ’ã€è´ªå¿ƒç­‰è®¾è®¡æ¨¡å¼
2. **æ€§èƒ½åˆ†æå·¥å…·**ï¼šæ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦åˆ†æ
3. **ä¼˜åŒ–æŠ€æœ¯**ï¼šè®°å¿†åŒ–ã€å‰ªæã€å¹¶è¡ŒåŒ–ç­‰ä¼˜åŒ–æ–¹æ³•
4. **æ­£ç¡®æ€§éªŒè¯**ï¼šç®—æ³•æ­£ç¡®æ€§è¯æ˜å’ŒéªŒè¯æŠ€æœ¯
5. **å®é™…åº”ç”¨**ï¼šæ’åºã€æœç´¢ã€å›¾ç®—æ³•ç­‰ç»å…¸ç®—æ³•

é€šè¿‡ç³»ç»Ÿæ€§çš„ç®—æ³•ç†è®ºï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

- è®¾è®¡é«˜æ•ˆçš„ç®—æ³•
- åˆ†æç®—æ³•æ€§èƒ½
- ä¼˜åŒ–ç°æœ‰ç®—æ³•
- è§£å†³å¤æ‚é—®é¢˜
- æ„å»ºé«˜æ€§èƒ½è½¯ä»¶ç³»ç»Ÿ

ç®—æ³•ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒï¼Œä¸ºç°ä»£è½¯ä»¶å·¥ç¨‹æä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€å’Œå®è·µæŒ‡å¯¼ã€‚
