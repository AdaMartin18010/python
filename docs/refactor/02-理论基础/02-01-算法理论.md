# 02-01 ç®—æ³•ç†è®º (Algorithm Theory)

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. ç®—æ³•åŸºç¡€](#1-ç®—æ³•åŸºç¡€)
- [2. å¤æ‚åº¦åˆ†æ](#2-å¤æ‚åº¦åˆ†æ)
- [3. ç®—æ³•è®¾è®¡èŒƒå¼](#3-ç®—æ³•è®¾è®¡èŒƒå¼)
- [4. é€’å½’ç†è®º](#4-é€’å½’ç†è®º)
- [5. åˆ†æ²»ç­–ç•¥](#5-åˆ†æ²»ç­–ç•¥)
- [6. åŠ¨æ€è§„åˆ’](#6-åŠ¨æ€è§„åˆ’)
- [7. è´ªå¿ƒç®—æ³•](#7-è´ªå¿ƒç®—æ³•)
- [8. å½¢å¼åŒ–è¡¨ç¤º](#8-å½¢å¼åŒ–è¡¨ç¤º)
- [9. Pythonå®ç°](#9-pythonå®ç°)
- [10. å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## æ¦‚è¿°

ç®—æ³•ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒç†è®ºåŸºç¡€ï¼Œç ”ç©¶ç®—æ³•çš„è®¾è®¡ã€åˆ†æå’Œä¼˜åŒ–ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰ç®—æ³•æ¦‚å¿µï¼Œåˆ†æç®—æ³•å¤æ‚åº¦ï¼Œå¹¶ä»‹ç»ä¸»è¦çš„ç®—æ³•è®¾è®¡èŒƒå¼ã€‚

## 1. ç®—æ³•åŸºç¡€

### 1.1 ç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰

ç®—æ³•å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$\mathcal{A} = \langle \mathcal{I}, \mathcal{O}, \mathcal{S}, \mathcal{T} \rangle$$

å…¶ä¸­ï¼š
- $\mathcal{I}$ æ˜¯è¾“å…¥é›†åˆ
- $\mathcal{O}$ æ˜¯è¾“å‡ºé›†åˆ
- $\mathcal{S}$ æ˜¯çŠ¶æ€é›†åˆ
- $\mathcal{T}$ æ˜¯è½¬æ¢å‡½æ•°é›†åˆ

### 1.2 ç®—æ³•çš„æ€§è´¨

**æ­£ç¡®æ€§**: $\forall x \in \mathcal{I}: \mathcal{A}(x) = f(x)$

**ç»ˆæ­¢æ€§**: $\forall x \in \mathcal{I}: \mathcal{A}(x)$ åœ¨æœ‰é™æ­¥å†…ç»ˆæ­¢

**ç¡®å®šæ€§**: $\forall x \in \mathcal{I}: \mathcal{A}(x)$ äº§ç”Ÿå”¯ä¸€è¾“å‡º

### 1.3 ç®—æ³•çš„è¡¨ç¤º

**ä¼ªä»£ç **: ç®—æ³•çš„é«˜çº§æè¿°
**æµç¨‹å›¾**: ç®—æ³•çš„å›¾å½¢è¡¨ç¤º
**çŠ¶æ€æœº**: ç®—æ³•çš„çŠ¶æ€è½¬æ¢è¡¨ç¤º

## 2. å¤æ‚åº¦åˆ†æ

### 2.1 æ—¶é—´å¤æ‚åº¦

**å®šä¹‰**: $T(n) = O(f(n)) \iff \exists c, n_0: \forall n \geq n_0: T(n) \leq c \cdot f(n)$

**å¸¸è§å¤æ‚åº¦ç±»**:
- $O(1)$: å¸¸æ•°æ—¶é—´
- $O(\log n)$: å¯¹æ•°æ—¶é—´
- $O(n)$: çº¿æ€§æ—¶é—´
- $O(n \log n)$: çº¿æ€§å¯¹æ•°æ—¶é—´
- $O(n^2)$: äºŒæ¬¡æ—¶é—´
- $O(2^n)$: æŒ‡æ•°æ—¶é—´

### 2.2 ç©ºé—´å¤æ‚åº¦

**å®šä¹‰**: $S(n) = O(f(n)) \iff \exists c, n_0: \forall n \geq n_0: S(n) \leq c \cdot f(n)$

### 2.3 å¤æ‚åº¦åˆ†ææŠ€æœ¯

**ä¸»å®šç†**: å¯¹äºé€’å½’å…³ç³» $T(n) = aT(n/b) + f(n)$

$$T(n) = \begin{cases}
O(n^{\log_b a}) & \text{if } f(n) = O(n^{\log_b a - \epsilon}) \\
O(f(n) \log n) & \text{if } f(n) = O(n^{\log_b a}) \\
O(f(n)) & \text{if } f(n) = \Omega(n^{\log_b a + \epsilon})
\end{cases}$$

## 3. ç®—æ³•è®¾è®¡èŒƒå¼

### 3.1 æš´åŠ›æœç´¢

**å®šä¹‰**: ç©·ä¸¾æ‰€æœ‰å¯èƒ½çš„è§£

**å¤æ‚åº¦**: $O(n!)$ æˆ– $O(2^n)$

### 3.2 åˆ†æ²»ç­–ç•¥

**å®šä¹‰**: å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œé€’å½’è§£å†³ï¼Œåˆå¹¶ç»“æœ

**å¤æ‚åº¦**: é€šå¸¸ $O(n \log n)$

### 3.3 åŠ¨æ€è§„åˆ’

**å®šä¹‰**: é€šè¿‡å­˜å‚¨å­é—®é¢˜çš„è§£æ¥é¿å…é‡å¤è®¡ç®—

**å¤æ‚åº¦**: é€šå¸¸ $O(n^2)$ æˆ– $O(n^3)$

### 3.4 è´ªå¿ƒç®—æ³•

**å®šä¹‰**: åœ¨æ¯ä¸€æ­¥é€‰æ‹©å±€éƒ¨æœ€ä¼˜è§£

**å¤æ‚åº¦**: é€šå¸¸ $O(n \log n)$

## 4. é€’å½’ç†è®º

### 4.1 é€’å½’å®šä¹‰

**é€’å½’å‡½æ•°**: $f(n) = g(f(n-1), n)$

**é€’å½’å…³ç³»**: $T(n) = aT(n/b) + f(n)$

### 4.2 é€’å½’æ ‘åˆ†æ

é€’å½’æ ‘çš„é«˜åº¦: $h = \log_b n$

æ¯å±‚çš„å·¥ä½œé‡: $a^i \cdot f(n/b^i)$

æ€»å·¥ä½œé‡: $\sum_{i=0}^{h} a^i \cdot f(n/b^i)$

## 5. åˆ†æ²»ç­–ç•¥

### 5.1 åˆ†æ²»ç®—æ³•æ¡†æ¶

```python
def divide_and_conquer(problem):
    if problem.is_small():
        return solve_directly(problem)
    
    subproblems = divide(problem)
    solutions = [divide_and_conquer(sub) for sub in subproblems]
    return combine(solutions)
```

### 5.2 ç»å…¸åˆ†æ²»ç®—æ³•

**å½’å¹¶æ’åº**: $T(n) = 2T(n/2) + O(n) = O(n \log n)$

**å¿«é€Ÿæ’åº**: $T(n) = T(k) + T(n-k-1) + O(n)$

**äºŒåˆ†æœç´¢**: $T(n) = T(n/2) + O(1) = O(\log n)$

## 6. åŠ¨æ€è§„åˆ’

### 6.1 åŠ¨æ€è§„åˆ’åŸç†

**æœ€ä¼˜å­ç»“æ„**: é—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å­é—®é¢˜çš„æœ€ä¼˜è§£

**é‡å å­é—®é¢˜**: å­é—®é¢˜è¢«é‡å¤è®¡ç®—

### 6.2 åŠ¨æ€è§„åˆ’æ¡†æ¶

```python
def dynamic_programming(problem):
    # åˆå§‹åŒ–DPè¡¨
    dp = initialize_dp_table()
    
    # å¡«å……DPè¡¨
    for i in range(n):
        for j in range(m):
            dp[i][j] = optimal_choice(dp, i, j)
    
    return dp[n-1][m-1]
```

### 6.3 ç»å…¸åŠ¨æ€è§„åˆ’é—®é¢˜

**æœ€é•¿å…¬å…±å­åºåˆ—**: $LCS(i,j) = \max(LCS(i-1,j), LCS(i,j-1), LCS(i-1,j-1) + 1)$

**èƒŒåŒ…é—®é¢˜**: $dp[i][w] = \max(dp[i-1][w], dp[i-1][w-w_i] + v_i)$

## 7. è´ªå¿ƒç®—æ³•

### 7.1 è´ªå¿ƒé€‰æ‹©æ€§è´¨

**è´ªå¿ƒé€‰æ‹©**: åœ¨æ¯ä¸€æ­¥é€‰æ‹©å±€éƒ¨æœ€ä¼˜è§£

**æœ€ä¼˜å­ç»“æ„**: è´ªå¿ƒé€‰æ‹©åï¼Œå‰©ä½™é—®é¢˜ä»å…·æœ‰æœ€ä¼˜å­ç»“æ„

### 7.2 è´ªå¿ƒç®—æ³•æ¡†æ¶

```python
def greedy_algorithm(problem):
    solution = []
    while not problem.is_solved():
        choice = select_greedy_choice(problem)
        solution.append(choice)
        problem.update(choice)
    return solution
```

### 7.3 ç»å…¸è´ªå¿ƒç®—æ³•

**æ´»åŠ¨é€‰æ‹©**: é€‰æ‹©ç»“æŸæ—¶é—´æœ€æ—©çš„æ´»åŠ¨

**éœå¤«æ›¼ç¼–ç **: é€‰æ‹©é¢‘ç‡æœ€ä½çš„ä¸¤ä¸ªèŠ‚ç‚¹åˆå¹¶

**Dijkstraç®—æ³•**: é€‰æ‹©è·ç¦»æœ€å°çš„æœªè®¿é—®èŠ‚ç‚¹

## 8. å½¢å¼åŒ–è¡¨ç¤º

### 8.1 ç®—æ³•å¤æ‚åº¦ç†è®º

**Pç±»é—®é¢˜**: å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è§£å†³çš„é—®é¢˜

**NPç±»é—®é¢˜**: å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯è§£çš„é—®é¢˜

**NPå®Œå…¨é—®é¢˜**: NPç±»ä¸­æœ€éš¾çš„é—®é¢˜

### 8.2 ç®—æ³•æ­£ç¡®æ€§è¯æ˜

**å¾ªç¯ä¸å˜å¼**: åœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸­éƒ½æˆç«‹çš„æ–­è¨€

**æ•°å­¦å½’çº³æ³•**: è¯æ˜é€’å½’ç®—æ³•çš„æ­£ç¡®æ€§

## 9. Pythonå®ç°

### 9.1 åŸºç¡€ç®—æ³•å®ç°

```python
from typing import List, Tuple, Optional, Callable, Any
import time
import random
import math
from abc import ABC, abstractmethod

class AlgorithmAnalyzer:
    """ç®—æ³•åˆ†æå™¨"""
    
    def __init__(self):
        self.complexity_cache = {}
    
    def measure_time(self, func: Callable, *args, **kwargs) -> float:
        """æµ‹é‡å‡½æ•°æ‰§è¡Œæ—¶é—´"""
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        return end_time - start_time
    
    def analyze_complexity(self, func: Callable, input_sizes: List[int], 
                          num_runs: int = 5) -> List[float]:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        times = []
        
        for size in input_sizes:
            total_time = 0
            for _ in range(num_runs):
                # ç”Ÿæˆæµ‹è¯•æ•°æ®
                test_data = self._generate_test_data(func, size)
                total_time += self.measure_time(func, test_data)
            
            avg_time = total_time / num_runs
            times.append(avg_time)
        
        return times
    
    def _generate_test_data(self, func: Callable, size: int) -> Any:
        """ç”Ÿæˆæµ‹è¯•æ•°æ®"""
        # æ ¹æ®å‡½æ•°åç”Ÿæˆç›¸åº”çš„æµ‹è¯•æ•°æ®
        func_name = func.__name__.lower()
        
        if 'sort' in func_name:
            return [random.randint(1, 1000) for _ in range(size)]
        elif 'search' in func_name:
            arr = sorted([random.randint(1, 1000) for _ in range(size)])
            return arr, random.choice(arr)
        elif 'fibonacci' in func_name:
            return size
        else:
            return [random.randint(1, 100) for _ in range(size)]
    
    def estimate_complexity(self, input_sizes: List[int], times: List[float]) -> str:
        """ä¼°è®¡ç®—æ³•å¤æ‚åº¦"""
        if len(input_sizes) < 2:
            return "æ•°æ®ä¸è¶³"
        
        # è®¡ç®—å¤æ‚åº¦æ¯”ç‡
        ratios = []
        for i in range(1, len(input_sizes)):
            size_ratio = input_sizes[i] / input_sizes[i-1]
            time_ratio = times[i] / times[i-1]
            ratios.append(time_ratio / size_ratio)
        
        avg_ratio = sum(ratios) / len(ratios)
        
        # æ ¹æ®æ¯”ç‡åˆ¤æ–­å¤æ‚åº¦
        if avg_ratio < 1.1:
            return "O(1)"
        elif avg_ratio < 1.5:
            return "O(log n)"
        elif avg_ratio < 2.5:
            return "O(n)"
        elif avg_ratio < 5:
            return "O(n log n)"
        elif avg_ratio < 10:
            return "O(nÂ²)"
        else:
            return "O(2â¿) æˆ–æ›´é«˜"

class SortingAlgorithms:
    """æ’åºç®—æ³•å®ç°"""
    
    @staticmethod
    def bubble_sort(arr: List[int]) -> List[int]:
        """å†’æ³¡æ’åº - O(nÂ²)"""
        arr = arr.copy()
        n = len(arr)
        
        for i in range(n):
            for j in range(0, n - i - 1):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
        
        return arr
    
    @staticmethod
    def merge_sort(arr: List[int]) -> List[int]:
        """å½’å¹¶æ’åº - O(n log n)"""
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = SortingAlgorithms.merge_sort(arr[:mid])
        right = SortingAlgorithms.merge_sort(arr[mid:])
        
        return SortingAlgorithms._merge(left, right)
    
    @staticmethod
    def _merge(left: List[int], right: List[int]) -> List[int]:
        """åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    @staticmethod
    def quick_sort(arr: List[int]) -> List[int]:
        """å¿«é€Ÿæ’åº - O(n log n) å¹³å‡æƒ…å†µ"""
        if len(arr) <= 1:
            return arr
        
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        
        return (SortingAlgorithms.quick_sort(left) + 
                middle + 
                SortingAlgorithms.quick_sort(right))
    
    @staticmethod
    def heap_sort(arr: List[int]) -> List[int]:
        """å †æ’åº - O(n log n)"""
        def heapify(arr, n, i):
            largest = i
            left = 2 * i + 1
            right = 2 * i + 2
            
            if left < n and arr[left] > arr[largest]:
                largest = left
            
            if right < n and arr[right] > arr[largest]:
                largest = right
            
            if largest != i:
                arr[i], arr[largest] = arr[largest], arr[i]
                heapify(arr, n, largest)
        
        arr = arr.copy()
        n = len(arr)
        
        # æ„å»ºæœ€å¤§å †
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # é€ä¸ªæå–å…ƒç´ 
        for i in range(n - 1, 0, -1):
            arr[0], arr[i] = arr[i], arr[0]
            heapify(arr, i, 0)
        
        return arr

class SearchAlgorithms:
    """æœç´¢ç®—æ³•å®ç°"""
    
    @staticmethod
    def linear_search(arr: List[int], target: int) -> Optional[int]:
        """çº¿æ€§æœç´¢ - O(n)"""
        for i, num in enumerate(arr):
            if num == target:
                return i
        return None
    
    @staticmethod
    def binary_search(arr: List[int], target: int) -> Optional[int]:
        """äºŒåˆ†æœç´¢ - O(log n)"""
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return None
    
    @staticmethod
    def depth_first_search(graph: dict, start: str, visited: set = None) -> List[str]:
        """æ·±åº¦ä¼˜å…ˆæœç´¢ - O(V + E)"""
        if visited is None:
            visited = set()
        
        visited.add(start)
        result = [start]
        
        for neighbor in graph.get(start, []):
            if neighbor not in visited:
                result.extend(SearchAlgorithms.depth_first_search(graph, neighbor, visited))
        
        return result
    
    @staticmethod
    def breadth_first_search(graph: dict, start: str) -> List[str]:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢ - O(V + E)"""
        visited = set()
        queue = [start]
        result = []
        
        while queue:
            vertex = queue.pop(0)
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                queue.extend(graph.get(vertex, []))
        
        return result

class DynamicProgramming:
    """åŠ¨æ€è§„åˆ’ç®—æ³•å®ç°"""
    
    @staticmethod
    def fibonacci_dp(n: int) -> int:
        """æ–æ³¢é‚£å¥‘æ•°åˆ— - åŠ¨æ€è§„åˆ’ - O(n)"""
        if n <= 1:
            return n
        
        dp = [0] * (n + 1)
        dp[1] = 1
        
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
    
    @staticmethod
    def longest_common_subsequence(str1: str, str2: str) -> int:
        """æœ€é•¿å…¬å…±å­åºåˆ— - O(mn)"""
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n]
    
    @staticmethod
    def knapsack_01(weights: List[int], values: List[int], capacity: int) -> int:
        """0-1èƒŒåŒ…é—®é¢˜ - O(nW)"""
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i - 1] <= w:
                    dp[i][w] = max(dp[i - 1][w], 
                                  dp[i - 1][w - weights[i - 1]] + values[i - 1])
                else:
                    dp[i][w] = dp[i - 1][w]
        
        return dp[n][capacity]
    
    @staticmethod
    def edit_distance(str1: str, str2: str) -> int:
        """ç¼–è¾‘è·ç¦» - O(mn)"""
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # åˆå§‹åŒ–
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        # å¡«å……DPè¡¨
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = 1 + min(dp[i - 1][j],      # åˆ é™¤
                                      dp[i][j - 1],      # æ’å…¥
                                      dp[i - 1][j - 1])  # æ›¿æ¢
        
        return dp[m][n]

class GreedyAlgorithms:
    """è´ªå¿ƒç®—æ³•å®ç°"""
    
    @staticmethod
    def activity_selection(start_times: List[int], end_times: List[int]) -> List[int]:
        """æ´»åŠ¨é€‰æ‹©é—®é¢˜ - O(n log n)"""
        activities = list(zip(start_times, end_times, range(len(start_times))))
        activities.sort(key=lambda x: x[1])  # æŒ‰ç»“æŸæ—¶é—´æ’åº
        
        selected = [activities[0][2]]  # é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»åŠ¨
        last_end = activities[0][1]
        
        for start, end, index in activities[1:]:
            if start >= last_end:
                selected.append(index)
                last_end = end
        
        return selected
    
    @staticmethod
    def huffman_encoding(frequencies: List[int]) -> dict:
        """éœå¤«æ›¼ç¼–ç  - O(n log n)"""
        import heapq
        
        # åˆ›å»ºä¼˜å…ˆé˜Ÿåˆ—
        heap = [(freq, i) for i, freq in enumerate(frequencies)]
        heapq.heapify(heap)
        
        # æ„å»ºéœå¤«æ›¼æ ‘
        while len(heap) > 1:
            freq1, node1 = heapq.heappop(heap)
            freq2, node2 = heapq.heappop(heap)
            
            # åˆ›å»ºæ–°èŠ‚ç‚¹
            new_freq = freq1 + freq2
            new_node = (new_freq, (node1, node2))
            heapq.heappush(heap, new_node)
        
        # ç”Ÿæˆç¼–ç 
        codes = {}
        def generate_codes(node, code=""):
            if isinstance(node, int):
                codes[node] = code
            else:
                generate_codes(node[0], code + "0")
                generate_codes(node[1], code + "1")
        
        if heap:
            generate_codes(heap[0][1])
        
        return codes
    
    @staticmethod
    def dijkstra_shortest_path(graph: dict, start: str) -> dict:
        """Dijkstraæœ€çŸ­è·¯å¾„ - O(VÂ²)"""
        distances = {node: float('infinity') for node in graph}
        distances[start] = 0
        unvisited = set(graph.keys())
        
        while unvisited:
            # æ‰¾åˆ°è·ç¦»æœ€å°çš„æœªè®¿é—®èŠ‚ç‚¹
            current = min(unvisited, key=lambda x: distances[x])
            unvisited.remove(current)
            
            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor, weight in graph[current].items():
                if neighbor in unvisited:
                    new_distance = distances[current] + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
        
        return distances

class AlgorithmComparison:
    """ç®—æ³•æ¯”è¾ƒå™¨"""
    
    def __init__(self):
        self.analyzer = AlgorithmAnalyzer()
    
    def compare_sorting_algorithms(self, input_sizes: List[int]):
        """æ¯”è¾ƒæ’åºç®—æ³•"""
        algorithms = {
            'Bubble Sort': SortingAlgorithms.bubble_sort,
            'Merge Sort': SortingAlgorithms.merge_sort,
            'Quick Sort': SortingAlgorithms.quick_sort,
            'Heap Sort': SortingAlgorithms.heap_sort
        }
        
        results = {}
        
        for name, algorithm in algorithms.items():
            times = self.analyzer.analyze_complexity(algorithm, input_sizes)
            complexity = self.analyzer.estimate_complexity(input_sizes, times)
            results[name] = {
                'times': times,
                'complexity': complexity
            }
        
        return results
    
    def compare_search_algorithms(self, input_sizes: List[int]):
        """æ¯”è¾ƒæœç´¢ç®—æ³•"""
        algorithms = {
            'Linear Search': lambda arr: SearchAlgorithms.linear_search(arr, arr[-1]),
            'Binary Search': lambda arr: SearchAlgorithms.binary_search(sorted(arr), arr[-1])
        }
        
        results = {}
        
        for name, algorithm in algorithms.items():
            times = self.analyzer.analyze_complexity(algorithm, input_sizes)
            complexity = self.analyzer.estimate_complexity(input_sizes, times)
            results[name] = {
                'times': times,
                'complexity': complexity
            }
        
        return results

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_algorithm_theory():
    """æ¼”ç¤ºç®—æ³•ç†è®º"""
    
    print("=== æ’åºç®—æ³•æ¼”ç¤º ===\n")
    
    # æµ‹è¯•æ’åºç®—æ³•
    test_array = [64, 34, 25, 12, 22, 11, 90]
    print(f"åŸå§‹æ•°ç»„: {test_array}")
    
    print(f"å†’æ³¡æ’åº: {SortingAlgorithms.bubble_sort(test_array)}")
    print(f"å½’å¹¶æ’åº: {SortingAlgorithms.merge_sort(test_array)}")
    print(f"å¿«é€Ÿæ’åº: {SortingAlgorithms.quick_sort(test_array)}")
    print(f"å †æ’åº: {SortingAlgorithms.heap_sort(test_array)}")
    
    print("\n=== æœç´¢ç®—æ³•æ¼”ç¤º ===\n")
    
    # æµ‹è¯•æœç´¢ç®—æ³•
    sorted_array = [1, 3, 5, 7, 9, 11, 13, 15]
    target = 7
    
    print(f"æ•°ç»„: {sorted_array}")
    print(f"ç›®æ ‡: {target}")
    
    linear_result = SearchAlgorithms.linear_search(sorted_array, target)
    binary_result = SearchAlgorithms.binary_search(sorted_array, target)
    
    print(f"çº¿æ€§æœç´¢ç»“æœ: {linear_result}")
    print(f"äºŒåˆ†æœç´¢ç»“æœ: {binary_result}")
    
    print("\n=== åŠ¨æ€è§„åˆ’æ¼”ç¤º ===\n")
    
    # æµ‹è¯•åŠ¨æ€è§„åˆ’ç®—æ³•
    n = 10
    print(f"æ–æ³¢é‚£å¥‘æ•°åˆ— F({n}) = {DynamicProgramming.fibonacci_dp(n)}")
    
    str1, str2 = "ABCDGH", "AEDFHR"
    lcs_length = DynamicProgramming.longest_common_subsequence(str1, str2)
    print(f"æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦: {lcs_length}")
    
    weights = [2, 1, 3, 2]
    values = [12, 10, 20, 15]
    capacity = 5
    max_value = DynamicProgramming.knapsack_01(weights, values, capacity)
    print(f"0-1èƒŒåŒ…æœ€å¤§ä»·å€¼: {max_value}")
    
    print("\n=== è´ªå¿ƒç®—æ³•æ¼”ç¤º ===\n")
    
    # æµ‹è¯•è´ªå¿ƒç®—æ³•
    start_times = [1, 3, 0, 5, 8, 5]
    end_times = [2, 4, 6, 7, 9, 9]
    selected_activities = GreedyAlgorithms.activity_selection(start_times, end_times)
    print(f"æ´»åŠ¨é€‰æ‹©ç»“æœ: {selected_activities}")
    
    frequencies = [5, 9, 12, 13, 16, 45]
    huffman_codes = GreedyAlgorithms.huffman_encoding(frequencies)
    print(f"éœå¤«æ›¼ç¼–ç : {huffman_codes}")
    
    print("\n=== ç®—æ³•å¤æ‚åº¦åˆ†æ ===\n")
    
    # ç®—æ³•å¤æ‚åº¦åˆ†æ
    comparator = AlgorithmComparison()
    input_sizes = [100, 500, 1000, 2000]
    
    sorting_results = comparator.compare_sorting_algorithms(input_sizes)
    print("æ’åºç®—æ³•å¤æ‚åº¦åˆ†æ:")
    for name, result in sorting_results.items():
        print(f"  {name}: {result['complexity']}")
    
    search_results = comparator.compare_search_algorithms(input_sizes)
    print("\næœç´¢ç®—æ³•å¤æ‚åº¦åˆ†æ:")
    for name, result in search_results.items():
        print(f"  {name}: {result['complexity']}")

if __name__ == "__main__":
    demonstrate_algorithm_theory()
```

### 9.2 é«˜çº§ç®—æ³•å®ç°

```python
import numpy as np
from typing import List, Tuple, Set
import heapq
from collections import defaultdict, deque

class AdvancedAlgorithms:
    """é«˜çº§ç®—æ³•å®ç°"""
    
    @staticmethod
    def topological_sort(graph: dict) -> List[str]:
        """æ‹“æ‰‘æ’åº - O(V + E)"""
        in_degree = defaultdict(int)
        for node in graph:
            for neighbor in graph[node]:
                in_degree[neighbor] += 1
        
        queue = deque([node for node in graph if in_degree[node] == 0])
        result = []
        
        while queue:
            node = queue.popleft()
            result.append(node)
            
            for neighbor in graph.get(node, []):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result if len(result) == len(graph) else []
    
    @staticmethod
    def strongly_connected_components(graph: dict) -> List[List[str]]:
        """å¼ºè¿é€šåˆ†é‡ - Kosarajuç®—æ³• - O(V + E)"""
        def dfs_first(node, visited, stack):
            visited.add(node)
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    dfs_first(neighbor, visited, stack)
            stack.append(node)
        
        def dfs_second(node, visited, component):
            visited.add(node)
            component.append(node)
            for neighbor in reversed_graph.get(node, []):
                if neighbor not in visited:
                    dfs_second(neighbor, visited, component)
        
        # ç¬¬ä¸€æ¬¡DFS
        visited = set()
        stack = []
        for node in graph:
            if node not in visited:
                dfs_first(node, visited, stack)
        
        # æ„å»ºåå‘å›¾
        reversed_graph = defaultdict(list)
        for node in graph:
            for neighbor in graph[node]:
                reversed_graph[neighbor].append(node)
        
        # ç¬¬äºŒæ¬¡DFS
        visited = set()
        components = []
        for node in reversed(stack):
            if node not in visited:
                component = []
                dfs_second(node, visited, component)
                components.append(component)
        
        return components
    
    @staticmethod
    def minimum_spanning_tree_kruskal(edges: List[Tuple], num_vertices: int) -> List[Tuple]:
        """Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³• - O(E log E)"""
        def find(parent, x):
            if parent[x] != x:
                parent[x] = find(parent, parent[x])
            return parent[x]
        
        def union(parent, rank, x, y):
            root_x, root_y = find(parent, x), find(parent, y)
            if root_x == root_y:
                return False
            
            if rank[root_x] < rank[root_y]:
                parent[root_x] = root_y
            elif rank[root_x] > rank[root_y]:
                parent[root_y] = root_x
            else:
                parent[root_y] = root_x
                rank[root_x] += 1
            return True
        
        # æŒ‰æƒé‡æ’åºè¾¹
        edges.sort(key=lambda x: x[2])
        
        parent = list(range(num_vertices))
        rank = [0] * num_vertices
        mst = []
        
        for u, v, weight in edges:
            if union(parent, rank, u, v):
                mst.append((u, v, weight))
                if len(mst) == num_vertices - 1:
                    break
        
        return mst
    
    @staticmethod
    def minimum_spanning_tree_prim(graph: dict, start: str) -> List[Tuple]:
        """Primæœ€å°ç”Ÿæˆæ ‘ç®—æ³• - O(E log V)"""
        visited = set()
        mst = []
        heap = [(0, start, None)]
        
        while heap and len(visited) < len(graph):
            weight, current, parent = heapq.heappop(heap)
            
            if current in visited:
                continue
            
            visited.add(current)
            if parent is not None:
                mst.append((parent, current, weight))
            
            for neighbor, edge_weight in graph[current].items():
                if neighbor not in visited:
                    heapq.heappush(heap, (edge_weight, neighbor, current))
        
        return mst
    
    @staticmethod
    def floyd_warshall(graph: List[List[float]]) -> List[List[float]]:
        """Floyd-Warshallå…¨æºæœ€çŸ­è·¯å¾„ - O(VÂ³)"""
        n = len(graph)
        dist = [row[:] for row in graph]
        
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
        
        return dist
    
    @staticmethod
    def bellman_ford(edges: List[Tuple], num_vertices: int, start: int) -> List[float]:
        """Bellman-Fordå•æºæœ€çŸ­è·¯å¾„ - O(VE)"""
        distances = [float('infinity')] * num_vertices
        distances[start] = 0
        
        for _ in range(num_vertices - 1):
            for u, v, weight in edges:
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
        
        # æ£€æŸ¥è´Ÿæƒç¯
        for u, v, weight in edges:
            if distances[u] + weight < distances[v]:
                raise ValueError("å›¾ä¸­å­˜åœ¨è´Ÿæƒç¯")
        
        return distances
    
    @staticmethod
    def max_flow_ford_fulkerson(graph: dict, source: str, sink: str) -> int:
        """Ford-Fulkersonæœ€å¤§æµç®—æ³• - O(VEÂ²)"""
        def bfs(graph, source, sink, parent):
            visited = set()
            queue = deque([source])
            visited.add(source)
            
            while queue:
                u = queue.popleft()
                for v, capacity in graph[u].items():
                    if v not in visited and capacity > 0:
                        queue.append(v)
                        visited.add(v)
                        parent[v] = u
                        if v == sink:
                            return True
            return False
        
        # åˆ›å»ºæ®‹å·®å›¾
        residual_graph = defaultdict(dict)
        for u in graph:
            for v, capacity in graph[u].items():
                residual_graph[u][v] = capacity
                residual_graph[v][u] = 0
        
        parent = {}
        max_flow = 0
        
        while bfs(residual_graph, source, sink, parent):
            path_flow = float('infinity')
            v = sink
            
            # æ‰¾åˆ°è·¯å¾„ä¸Šçš„æœ€å°å®¹é‡
            while v != source:
                u = parent[v]
                path_flow = min(path_flow, residual_graph[u][v])
                v = u
            
            # æ›´æ–°æ®‹å·®å›¾
            v = sink
            while v != source:
                u = parent[v]
                residual_graph[u][v] -= path_flow
                residual_graph[v][u] += path_flow
                v = u
            
            max_flow += path_flow
        
        return max_flow
    
    @staticmethod
    def hungarian_algorithm(cost_matrix: List[List[int]]) -> Tuple[int, List[int]]:
        """åŒˆç‰™åˆ©ç®—æ³• - äºŒåˆ†å›¾æœ€å¤§æƒåŒ¹é… - O(VÂ³)"""
        n = len(cost_matrix)
        m = len(cost_matrix[0])
        
        # åˆå§‹åŒ–
        row_ind = [-1] * n
        col_ind = [-1] * m
        row_cover = [False] * n
        col_cover = [False] * m
        
        # æ­¥éª¤1: è¡Œçº¦ç®€
        for i in range(n):
            min_val = min(cost_matrix[i])
            for j in range(m):
                cost_matrix[i][j] -= min_val
        
        # æ­¥éª¤2: åˆ—çº¦ç®€
        for j in range(m):
            min_val = min(cost_matrix[i][j] for i in range(n))
            for i in range(n):
                cost_matrix[i][j] -= min_val
        
        # æ­¥éª¤3: ç”¨æœ€å°‘çš„çº¿è¦†ç›–æ‰€æœ‰é›¶
        while True:
            # æ ‡è®°æ‰€æœ‰æœªè¦†ç›–çš„é›¶
            marked = [[False] * m for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if cost_matrix[i][j] == 0 and not row_cover[i] and not col_cover[j]:
                        marked[i][j] = True
            
            # æ‰¾åˆ°ç‹¬ç«‹é›¶
            for i in range(n):
                for j in range(m):
                    if marked[i][j]:
                        row_ind[i] = j
                        col_ind[j] = i
                        row_cover[i] = True
                        col_cover[j] = True
            
            # æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if sum(row_cover) == n:
                break
            
            # ç”¨æœ€å°‘çš„çº¿è¦†ç›–æ‰€æœ‰é›¶
            uncovered_zeros = []
            for i in range(n):
                for j in range(m):
                    if cost_matrix[i][j] == 0 and not row_cover[i] and not col_cover[j]:
                        uncovered_zeros.append((i, j))
            
            if not uncovered_zeros:
                # æ‰¾åˆ°æœªè¦†ç›–å…ƒç´ çš„æœ€å°å€¼
                min_val = float('infinity')
                for i in range(n):
                    for j in range(m):
                        if not row_cover[i] and not col_cover[j]:
                            min_val = min(min_val, cost_matrix[i][j])
                
                # å‡å»æœªè¦†ç›–è¡Œçš„æœ€å°å€¼ï¼ŒåŠ ä¸Šè¦†ç›–åˆ—çš„æœ€å°å€¼
                for i in range(n):
                    for j in range(m):
                        if not row_cover[i] and not col_cover[j]:
                            cost_matrix[i][j] -= min_val
                        elif row_cover[i] and col_cover[j]:
                            cost_matrix[i][j] += min_val
        
        # è®¡ç®—æ€»æˆæœ¬
        total_cost = 0
        for i in range(n):
            if row_ind[i] != -1:
                total_cost += cost_matrix[i][row_ind[i]]
        
        return total_cost, row_ind

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_advanced_algorithms():
    """æ¼”ç¤ºé«˜çº§ç®—æ³•"""
    
    print("=== æ‹“æ‰‘æ’åºæ¼”ç¤º ===\n")
    
    # æ‹“æ‰‘æ’åº
    graph = {
        'A': ['B', 'C'],
        'B': ['D'],
        'C': ['D'],
        'D': ['E'],
        'E': []
    }
    
    topo_order = AdvancedAlgorithms.topological_sort(graph)
    print(f"æ‹“æ‰‘æ’åºç»“æœ: {topo_order}")
    
    print("\n=== å¼ºè¿é€šåˆ†é‡æ¼”ç¤º ===\n")
    
    # å¼ºè¿é€šåˆ†é‡
    scc_graph = {
        'A': ['B'],
        'B': ['C'],
        'C': ['A'],
        'D': ['E'],
        'E': ['D']
    }
    
    scc_components = AdvancedAlgorithms.strongly_connected_components(scc_graph)
    print(f"å¼ºè¿é€šåˆ†é‡: {scc_components}")
    
    print("\n=== æœ€å°ç”Ÿæˆæ ‘æ¼”ç¤º ===\n")
    
    # Kruskalç®—æ³•
    edges = [(0, 1, 4), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 4)]
    mst_kruskal = AdvancedAlgorithms.minimum_spanning_tree_kruskal(edges, 4)
    print(f"Kruskalæœ€å°ç”Ÿæˆæ ‘: {mst_kruskal}")
    
    # Primç®—æ³•
    prim_graph = {
        'A': {'B': 4, 'C': 3},
        'B': {'A': 4, 'C': 1, 'D': 2},
        'C': {'A': 3, 'B': 1, 'D': 4},
        'D': {'B': 2, 'C': 4}
    }
    
    mst_prim = AdvancedAlgorithms.minimum_spanning_tree_prim(prim_graph, 'A')
    print(f"Primæœ€å°ç”Ÿæˆæ ‘: {mst_prim}")
    
    print("\n=== æœ€çŸ­è·¯å¾„æ¼”ç¤º ===\n")
    
    # Floyd-Warshallç®—æ³•
    floyd_graph = [
        [0, 3, 8, float('infinity'), -4],
        [float('infinity'), 0, float('infinity'), 1, 7],
        [float('infinity'), 4, 0, float('infinity'), float('infinity')],
        [2, float('infinity'), -5, 0, float('infinity')],
        [float('infinity'), float('infinity'), float('infinity'), 6, 0]
    ]
    
    floyd_result = AdvancedAlgorithms.floyd_warshall(floyd_graph)
    print("Floyd-Warshallå…¨æºæœ€çŸ­è·¯å¾„:")
    for i, row in enumerate(floyd_result):
        print(f"  ä»èŠ‚ç‚¹{i}: {row}")
    
    # Bellman-Fordç®—æ³•
    bellman_edges = [(0, 1, 3), (0, 2, 8), (1, 3, 1), (2, 1, 4), (3, 2, -5), (3, 4, 6)]
    bellman_result = AdvancedAlgorithms.bellman_ford(bellman_edges, 5, 0)
    print(f"Bellman-Fordå•æºæœ€çŸ­è·¯å¾„: {bellman_result}")
    
    print("\n=== æœ€å¤§æµæ¼”ç¤º ===\n")
    
    # Ford-Fulkersonç®—æ³•
    flow_graph = {
        'S': {'A': 10, 'B': 10},
        'A': {'B': 2, 'T': 8},
        'B': {'T': 10},
        'T': {}
    }
    
    max_flow = AdvancedAlgorithms.max_flow_ford_fulkerson(flow_graph, 'S', 'T')
    print(f"æœ€å¤§æµ: {max_flow}")
    
    print("\n=== åŒˆç‰™åˆ©ç®—æ³•æ¼”ç¤º ===\n")
    
    # åŒˆç‰™åˆ©ç®—æ³•
    cost_matrix = [
        [3, 1, 4],
        [2, 0, 5],
        [3, 2, 2]
    ]
    
    total_cost, assignment = AdvancedAlgorithms.hungarian_algorithm(cost_matrix)
    print(f"æœ€å°æˆæœ¬: {total_cost}")
    print(f"æœ€ä¼˜åˆ†é…: {assignment}")

if __name__ == "__main__":
    demonstrate_advanced_algorithms()
```

## 10. å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., et al. (2009). "Introduction to Algorithms".
2. Knuth, D. E. (1997). "The Art of Computer Programming".
3. Sedgewick, R., & Wayne, K. (2011). "Algorithms".
4. Kleinberg, J., & Tardos, Ã‰. (2006). "Algorithm Design".

---

**ç›¸å…³æ–‡æ¡£**:
- [02-02-æ•°æ®ç»“æ„ç†è®º](./02-02-æ•°æ®ç»“æ„ç†è®º.md)
- [02-03-è®¡ç®—å¤æ‚æ€§](./02-03-è®¡ç®—å¤æ‚æ€§.md)
- [06-08-ç®—æ³•å®ç°](./../06-ç»„ä»¶ç®—æ³•/06-08-ç®—æ³•å®ç°.md)

**æœ€åæ›´æ–°**: 2024-01-XX  
**ç‰ˆæœ¬**: 1.0.0 