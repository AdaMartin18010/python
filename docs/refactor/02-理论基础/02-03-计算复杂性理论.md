# 02-03 è®¡ç®—å¤æ‚æ€§ç†è®º

## ğŸ“‹ æ¦‚è¿°

è®¡ç®—å¤æ‚æ€§ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒç†è®ºï¼Œç ”ç©¶è®¡ç®—é—®é¢˜çš„éš¾åº¦å’Œèµ„æºéœ€æ±‚ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°è®¡ç®—å¤æ‚æ€§çš„åŸºæœ¬æ¦‚å¿µã€å¤æ‚åº¦ç±»å’Œé‡è¦å®šç†ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¡ç®—æ¨¡å‹

#### 1.1 å›¾çµæœº

**å®šä¹‰ 1.1** (ç¡®å®šæ€§å›¾çµæœº)
ç¡®å®šæ€§å›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$$
å…¶ä¸­ï¼š

- $Q$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯ç£å¸¦å­—æ¯è¡¨
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $q_{accept} \in Q$ æ˜¯æ¥å—çŠ¶æ€
- $q_{reject} \in Q$ æ˜¯æ‹’ç»çŠ¶æ€

**å®šä¹‰ 1.2** (éç¡®å®šæ€§å›¾çµæœº)
éç¡®å®šæ€§å›¾çµæœºçš„è½¬ç§»å‡½æ•°ä¸ºï¼š
$$\delta: Q \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma \times \{L, R\})$$

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Tuple, Optional, Any
from dataclasses import dataclass
from enum import Enum
import copy

class Direction(Enum):
    """ç§»åŠ¨æ–¹å‘"""
    LEFT = "L"
    RIGHT = "R"
    STAY = "S"

class Tape:
    """å›¾çµæœºç£å¸¦"""
    
    def __init__(self, input_string: str, blank_symbol: str = "_"):
        self.tape = list(input_string)
        self.head_position = 0
        self.blank_symbol = blank_symbol
    
    def read(self) -> str:
        """è¯»å–å½“å‰ç¬¦å·"""
        if 0 <= self.head_position < len(self.tape):
            return self.tape[self.head_position]
        return self.blank_symbol
    
    def write(self, symbol: str) -> None:
        """å†™å…¥ç¬¦å·"""
        if 0 <= self.head_position < len(self.tape):
            self.tape[self.head_position] = symbol
        else:
            # æ‰©å±•ç£å¸¦
            if self.head_position < 0:
                self.tape.insert(0, symbol)
                self.head_position = 0
            else:
                self.tape.append(symbol)
    
    def move(self, direction: Direction) -> None:
        """ç§»åŠ¨ç£å¤´"""
        if direction == Direction.LEFT:
            self.head_position -= 1
        elif direction == Direction.RIGHT:
            self.head_position += 1
        # STAY ä¸ç§»åŠ¨
    
    def get_tape_string(self) -> str:
        """è·å–ç£å¸¦å†…å®¹"""
        return "".join(self.tape)
    
    def __str__(self) -> str:
        tape_str = self.get_tape_string()
        head_marker = " " * self.head_position + "^"
        return f"ç£å¸¦: {tape_str}\n      {head_marker}"

@dataclass
class Transition:
    """è½¬ç§»è§„åˆ™"""
    current_state: str
    current_symbol: str
    new_state: str
    new_symbol: str
    direction: Direction

class TuringMachine:
    """å›¾çµæœºå®ç°"""
    
    def __init__(self, 
                 states: Set[str],
                 input_alphabet: Set[str],
                 tape_alphabet: Set[str],
                 transitions: List[Transition],
                 initial_state: str,
                 accept_state: str,
                 reject_state: str):
        self.states = states
        self.input_alphabet = input_alphabet
        self.tape_alphabet = tape_alphabet
        self.transitions = transitions
        self.initial_state = initial_state
        self.accept_state = accept_state
        self.reject_state = reject_state
        
        # æ„å»ºè½¬ç§»è¡¨
        self.transition_table: Dict[Tuple[str, str], Transition] = {}
        for transition in transitions:
            key = (transition.current_state, transition.current_symbol)
            self.transition_table[key] = transition
    
    def run(self, input_string: str, max_steps: int = 1000) -> Tuple[bool, int, str]:
        """è¿è¡Œå›¾çµæœº"""
        tape = Tape(input_string)
        current_state = self.initial_state
        step_count = 0
        
        print(f"åˆå§‹é…ç½®: çŠ¶æ€={current_state}, {tape}")
        
        while step_count < max_steps:
            current_symbol = tape.read()
            key = (current_state, current_symbol)
            
            if key not in self.transition_table:
                print(f"æ— è½¬ç§»è§„åˆ™: çŠ¶æ€={current_state}, ç¬¦å·={current_symbol}")
                return False, step_count, tape.get_tape_string()
            
            transition = self.transition_table[key]
            current_state = transition.new_state
            tape.write(transition.new_symbol)
            tape.move(transition.direction)
            step_count += 1
            
            print(f"æ­¥éª¤ {step_count}: çŠ¶æ€={current_state}, {tape}")
            
            if current_state == self.accept_state:
                print("æ¥å—è¾“å…¥")
                return True, step_count, tape.get_tape_string()
            elif current_state == self.reject_state:
                print("æ‹’ç»è¾“å…¥")
                return False, step_count, tape.get_tape_string()
        
        print("è¶…è¿‡æœ€å¤§æ­¥æ•°")
        return False, step_count, tape.get_tape_string()

# ç¤ºä¾‹ï¼šè¯†åˆ«å›æ–‡ä¸²çš„å›¾çµæœº
def create_palindrome_turing_machine() -> TuringMachine:
    """åˆ›å»ºè¯†åˆ«å›æ–‡ä¸²çš„å›¾çµæœº"""
    states = {"q0", "q1", "q2", "q3", "q4", "qaccept", "qreject"}
    input_alphabet = {"0", "1"}
    tape_alphabet = {"0", "1", "_", "X", "Y"}
    
    transitions = [
        # åˆå§‹çŠ¶æ€ï¼šç§»åŠ¨åˆ°æœ€å³ç«¯
        Transition("q0", "0", "q0", "0", Direction.RIGHT),
        Transition("q0", "1", "q0", "1", Direction.RIGHT),
        Transition("q0", "_", "q1", "_", Direction.LEFT),
        
        # æ£€æŸ¥æœ€å³ç«¯ç¬¦å·
        Transition("q1", "0", "q2", "X", Direction.LEFT),
        Transition("q1", "1", "q3", "Y", Direction.LEFT),
        Transition("q1", "_", "qaccept", "_", Direction.STAY),
        
        # å¤„ç†0
        Transition("q2", "0", "q2", "0", Direction.LEFT),
        Transition("q2", "1", "q2", "1", Direction.LEFT),
        Transition("q2", "_", "q4", "_", Direction.RIGHT),
        Transition("q2", "X", "q4", "X", Direction.RIGHT),
        Transition("q2", "Y", "q4", "Y", Direction.RIGHT),
        
        # å¤„ç†1
        Transition("q3", "0", "q3", "0", Direction.LEFT),
        Transition("q3", "1", "q3", "1", Direction.LEFT),
        Transition("q3", "_", "q4", "_", Direction.RIGHT),
        Transition("q3", "X", "q4", "X", Direction.RIGHT),
        Transition("q3", "Y", "q4", "Y", Direction.RIGHT),
        
        # ç§»åŠ¨åˆ°æœ€å³ç«¯
        Transition("q4", "0", "q4", "0", Direction.RIGHT),
        Transition("q4", "1", "q4", "1", Direction.RIGHT),
        Transition("q4", "X", "q4", "X", Direction.RIGHT),
        Transition("q4", "Y", "q4", "Y", Direction.RIGHT),
        Transition("q4", "_", "q1", "_", Direction.LEFT),
    ]
    
    return TuringMachine(
        states=states,
        input_alphabet=input_alphabet,
        tape_alphabet=tape_alphabet,
        transitions=transitions,
        initial_state="q0",
        accept_state="qaccept",
        reject_state="qreject"
    )

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_turing_machine():
    """æ¼”ç¤ºå›¾çµæœº"""
    print("å›¾çµæœºæ¼”ç¤º")
    print("=" * 40)
    
    tm = create_palindrome_turing_machine()
    
    # æµ‹è¯•å›æ–‡ä¸²
    test_cases = ["101", "1001", "110", "111"]
    
    for test_input in test_cases:
        print(f"\næµ‹è¯•è¾“å…¥: {test_input}")
        accepted, steps, final_tape = tm.run(test_input)
        print(f"ç»“æœ: {'æ¥å—' if accepted else 'æ‹’ç»'}, æ­¥æ•°: {steps}")

if __name__ == "__main__":
    demonstrate_turing_machine()
```

### 2. å¤æ‚åº¦ç±»

#### 2.1 æ—¶é—´å¤æ‚æ€§ç±»

**å®šä¹‰ 2.1** (Pç±»)
Pç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è¢«ç¡®å®šæ€§å›¾çµæœºè§£å†³çš„é—®é¢˜çš„é›†åˆï¼š
$$P = \{L \mid \exists \text{DTM } M: L(M) = L \land \text{time}_M(n) = O(n^k)\}$$

**å®šä¹‰ 2.2** (NPç±»)
NPç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è¢«éç¡®å®šæ€§å›¾çµæœºè§£å†³çš„é—®é¢˜çš„é›†åˆï¼š
$$NP = \{L \mid \exists \text{NTM } M: L(M) = L \land \text{time}_M(n) = O(n^k)\}$$

**å®šä¹‰ 2.3** (NPå®Œå…¨é—®é¢˜)
è¯­è¨€ $L$ æ˜¯NPå®Œå…¨çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

1. $L \in NP$
2. $\forall L' \in NP: L' \leq_p L$

#### 2.2 Pythonå®ç°

```python
from typing import List, Set, Tuple, Optional, Callable, Any
from dataclasses import dataclass
import time
import random

@dataclass
class ProblemInstance:
    """é—®é¢˜å®ä¾‹"""
    name: str
    size: int
    data: Any

class ComplexityAnalyzer:
    """å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.results: Dict[str, List[Tuple[int, float]]] = {}
    
    def analyze_algorithm(self, 
                         algorithm: Callable,
                         problem_generator: Callable[[int], Any],
                         sizes: List[int],
                         runs_per_size: int = 3) -> Dict[str, List[Tuple[int, float]]]:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        results = []
        
        for size in sizes:
            times = []
            for _ in range(runs_per_size):
                problem = problem_generator(size)
                
                start_time = time.time()
                algorithm(problem)
                end_time = time.time()
                
                times.append(end_time - start_time)
            
            avg_time = sum(times) / len(times)
            results.append((size, avg_time))
        
        return results
    
    def classify_complexity(self, results: List[Tuple[int, float]]) -> str:
        """åˆ†ç±»å¤æ‚åº¦"""
        if len(results) < 2:
            return "æœªçŸ¥"
        
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(results)):
            size_ratio = results[i][0] / results[i-1][0]
            time_ratio = results[i][1] / results[i-1][1]
            growth_rates.append(time_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        if avg_growth < 1.5:
            return "O(1)"
        elif avg_growth < 2.5:
            return "O(log n)"
        elif avg_growth < 3.5:
            return "O(n)"
        elif avg_growth < 5:
            return "O(n log n)"
        elif avg_growth < 10:
            return "O(nÂ²)"
        else:
            return "O(n^k), k > 2"

class SATSolver:
    """SATé—®é¢˜æ±‚è§£å™¨"""
    
    def __init__(self):
        self.assignments: Dict[int, bool] = {}
    
    def solve_sat(self, clauses: List[List[int]]) -> Optional[Dict[int, bool]]:
        """æ±‚è§£SATé—®é¢˜"""
        variables = set()
        for clause in clauses:
            for literal in clause:
                variables.add(abs(literal))
        
        return self._backtrack_sat(list(variables), clauses)
    
    def _backtrack_sat(self, variables: List[int], clauses: List[List[int]]) -> Optional[Dict[int, bool]]:
        """å›æº¯æ±‚è§£SAT"""
        if not variables:
            return self.assignments.copy() if self._is_satisfiable(clauses) else None
        
        var = variables[0]
        remaining_vars = variables[1:]
        
        # å°è¯• var = True
        self.assignments[var] = True
        result = self._backtrack_sat(remaining_vars, clauses)
        if result is not None:
            return result
        
        # å°è¯• var = False
        self.assignments[var] = False
        result = self._backtrack_sat(remaining_vars, clauses)
        if result is not None:
            return result
        
        # å›æº¯
        del self.assignments[var]
        return None
    
    def _is_satisfiable(self, clauses: List[List[int]]) -> bool:
        """æ£€æŸ¥å½“å‰èµ‹å€¼æ˜¯å¦æ»¡è¶³æ‰€æœ‰å­å¥"""
        for clause in clauses:
            clause_satisfied = False
            for literal in clause:
                var = abs(literal)
                if var in self.assignments:
                    value = self.assignments[var]
                    if (literal > 0 and value) or (literal < 0 and not value):
                        clause_satisfied = True
                        break
            if not clause_satisfied:
                return False
        return True

class HamiltonianPathSolver:
    """å“ˆå¯†é¡¿è·¯å¾„æ±‚è§£å™¨"""
    
    def __init__(self):
        self.path: List[int] = []
        self.visited: Set[int] = set()
    
    def solve_hamiltonian_path(self, graph: Dict[int, List[int]]) -> Optional[List[int]]:
        """æ±‚è§£å“ˆå¯†é¡¿è·¯å¾„"""
        vertices = list(graph.keys())
        if not vertices:
            return []
        
        # å°è¯•æ¯ä¸ªé¡¶ç‚¹ä½œä¸ºèµ·ç‚¹
        for start_vertex in vertices:
            self.path = [start_vertex]
            self.visited = {start_vertex}
            
            if self._backtrack_hamiltonian(graph, start_vertex):
                return self.path.copy()
        
        return None
    
    def _backtrack_hamiltonian(self, graph: Dict[int, List[int]], current: int) -> bool:
        """å›æº¯æ±‚è§£å“ˆå¯†é¡¿è·¯å¾„"""
        if len(self.path) == len(graph):
            return True
        
        for neighbor in graph.get(current, []):
            if neighbor not in self.visited:
                self.visited.add(neighbor)
                self.path.append(neighbor)
                
                if self._backtrack_hamiltonian(graph, neighbor):
                    return True
                
                self.visited.remove(neighbor)
                self.path.pop()
        
        return False

def generate_sat_instance(size: int) -> List[List[int]]:
    """ç”ŸæˆSATé—®é¢˜å®ä¾‹"""
    clauses = []
    variables = size
    
    # ç”Ÿæˆéšæœºå­å¥
    for _ in range(size * 2):
        clause = []
        clause_size = random.randint(2, 4)
        for _ in range(clause_size):
            var = random.randint(1, variables)
            if random.random() < 0.5:
                var = -var
            clause.append(var)
        clauses.append(clause)
    
    return clauses

def generate_graph_instance(size: int) -> Dict[int, List[int]]:
    """ç”Ÿæˆå›¾å®ä¾‹"""
    graph = {}
    
    for i in range(size):
        graph[i] = []
        for j in range(size):
            if i != j and random.random() < 0.3:  # 30%æ¦‚ç‡æœ‰è¾¹
                graph[i].append(j)
    
    return graph

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_complexity_classes():
    """æ¼”ç¤ºå¤æ‚åº¦ç±»"""
    print("å¤æ‚åº¦ç±»æ¼”ç¤º")
    print("=" * 40)
    
    analyzer = ComplexityAnalyzer()
    
    # åˆ†æSATæ±‚è§£å™¨
    sat_solver = SATSolver()
    sat_results = analyzer.analyze_algorithm(
        lambda clauses: sat_solver.solve_sat(clauses),
        generate_sat_instance,
        [5, 10, 15, 20]
    )
    
    sat_complexity = analyzer.classify_complexity(sat_results)
    print(f"SATæ±‚è§£å™¨å¤æ‚åº¦: {sat_complexity}")
    
    # åˆ†æå“ˆå¯†é¡¿è·¯å¾„æ±‚è§£å™¨
    hamiltonian_solver = HamiltonianPathSolver()
    hamiltonian_results = analyzer.analyze_algorithm(
        lambda graph: hamiltonian_solver.solve_hamiltonian_path(graph),
        generate_graph_instance,
        [5, 8, 10, 12]
    )
    
    hamiltonian_complexity = analyzer.classify_complexity(hamiltonian_results)
    print(f"å“ˆå¯†é¡¿è·¯å¾„æ±‚è§£å™¨å¤æ‚åº¦: {hamiltonian_complexity}")

if __name__ == "__main__":
    demonstrate_complexity_classes()
```

### 3. é‡è¦å®šç†

#### 3.1 P vs NPé—®é¢˜

**å®šç† 3.1** (P âŠ† NP)
Pç±»åŒ…å«åœ¨NPç±»ä¸­ï¼š
$$P \subseteq NP$$

**è¯æ˜**:
å¯¹äºä»»æ„ $L \in P$ï¼Œå­˜åœ¨ç¡®å®šæ€§å›¾çµæœº $M$ åœ¨å¤šé¡¹å¼æ—¶é—´å†…åˆ¤å®š $L$ã€‚
ç”±äºç¡®å®šæ€§å›¾çµæœºæ˜¯éç¡®å®šæ€§å›¾çµæœºçš„ç‰¹ä¾‹ï¼Œ$M$ ä¹Ÿæ˜¯éç¡®å®šæ€§å›¾çµæœºã€‚
å› æ­¤ $L \in NP$ã€‚

**å®šç† 3.2** (NPå®Œå…¨é—®é¢˜çš„å­˜åœ¨æ€§)
å­˜åœ¨NPå®Œå…¨é—®é¢˜ã€‚

**è¯æ˜**:
æ„é€ é€šç”¨NPé—®é¢˜ï¼š
$$L_{NP} = \{\langle M, x, 1^t \rangle \mid M \text{ æ˜¯NTM}, x \text{ æ˜¯è¾“å…¥}, M \text{ åœ¨ } t \text{ æ­¥å†…æ¥å— } x\}$$

å¯ä»¥è¯æ˜ $L_{NP}$ æ˜¯NPå®Œå…¨çš„ã€‚

#### 3.2 Pythonå®ç°

```python
from typing import Dict, List, Set, Tuple, Optional, Any
import itertools

class NPCompleteProblems:
    """NPå®Œå…¨é—®é¢˜é›†åˆ"""
    
    @staticmethod
    def three_sat_to_clique(clauses: List[List[int]]) -> Tuple[Dict[int, List[int]], int]:
        """3-SATåˆ°å›¢é—®é¢˜çš„å½’çº¦"""
        graph = {}
        k = len(clauses)  # å›¢çš„å¤§å°
        
        # ä¸ºæ¯ä¸ªå­å¥åˆ›å»ºä¸‰ä¸ªé¡¶ç‚¹
        vertex_id = 0
        for i, clause in enumerate(clauses):
            for literal in clause:
                graph[vertex_id] = []
                vertex_id += 1
        
        # æ·»åŠ è¾¹ï¼šä¸åŒå­å¥ä¸­çš„é¡¶ç‚¹ä¹‹é—´éƒ½æœ‰è¾¹ï¼Œé™¤éå®ƒä»¬æ˜¯äº’è¡¥çš„
        for i, clause1 in enumerate(clauses):
            for j, clause2 in enumerate(clauses):
                if i != j:  # ä¸åŒå­å¥
                    for literal1 in clause1:
                        for literal2 in clause2:
                            v1 = i * 3 + clause1.index(literal1)
                            v2 = j * 3 + clause2.index(literal2)
                            
                            # å¦‚æœä¸æ˜¯äº’è¡¥çš„ï¼Œæ·»åŠ è¾¹
                            if literal1 != -literal2:
                                if v1 not in graph:
                                    graph[v1] = []
                                if v2 not in graph:
                                    graph[v2] = []
                                graph[v1].append(v2)
                                graph[v2].append(v1)
        
        return graph, k
    
    @staticmethod
    def clique_to_vertex_cover(graph: Dict[int, List[int]], k: int) -> Tuple[Dict[int, List[int]], int]:
        """å›¢é—®é¢˜åˆ°é¡¶ç‚¹è¦†ç›–é—®é¢˜çš„å½’çº¦"""
        # é¡¶ç‚¹è¦†ç›–çš„è¡¥é›†æ˜¯å›¢
        # å¦‚æœå›¾Gæœ‰å¤§å°ä¸ºkçš„å›¢ï¼Œåˆ™Gçš„è¡¥å›¾æœ‰å¤§å°ä¸º|V|-kçš„é¡¶ç‚¹è¦†ç›–
        
        vertices = set(graph.keys())
        n = len(vertices)
        
        # æ„é€ è¡¥å›¾
        complement_graph = {}
        for v in vertices:
            complement_graph[v] = []
            for u in vertices:
                if u != v and u not in graph.get(v, []):
                    complement_graph[v].append(u)
        
        return complement_graph, n - k
    
    @staticmethod
    def vertex_cover_to_hamiltonian_cycle(graph: Dict[int, List[int]], k: int) -> Dict[int, List[int]]:
        """é¡¶ç‚¹è¦†ç›–é—®é¢˜åˆ°å“ˆå¯†é¡¿ç¯é—®é¢˜çš„å½’çº¦"""
        # è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„å½’çº¦ï¼Œè¿™é‡Œæä¾›ç®€åŒ–ç‰ˆæœ¬
        # å®é™…å½’çº¦éœ€è¦æ„é€ ç‰¹æ®Šçš„å›¾ç»“æ„
        
        vertices = list(graph.keys())
        n = len(vertices)
        
        # æ„é€ å“ˆå¯†é¡¿ç¯å›¾
        hamiltonian_graph = {}
        
        # ä¸ºæ¯ä¸ªé¡¶ç‚¹åˆ›å»ºé€‰æ‹©å™¨
        for i, v in enumerate(vertices):
            hamiltonian_graph[v] = []
            next_vertex = vertices[(i + 1) % n]
            hamiltonian_graph[v].append(next_vertex)
        
        # æ·»åŠ é¢å¤–çš„è¾¹æ¥ç¼–ç é¡¶ç‚¹è¦†ç›–
        for v in vertices:
            for u in graph.get(v, []):
                if u > v:  # é¿å…é‡å¤è¾¹
                    hamiltonian_graph[v].append(u)
                    hamiltonian_graph[u].append(v)
        
        return hamiltonian_graph

class ReductionVerifier:
    """å½’çº¦éªŒè¯å™¨"""
    
    @staticmethod
    def verify_sat_to_clique(clauses: List[List[int]], graph: Dict[int, List[int]], k: int) -> bool:
        """éªŒè¯3-SATåˆ°å›¢é—®é¢˜çš„å½’çº¦"""
        # æ£€æŸ¥å›¢çš„å¤§å°
        if k != len(clauses):
            return False
        
        # æ£€æŸ¥å›¾çš„æ„é€ æ˜¯å¦æ­£ç¡®
        expected_vertices = len(clauses) * 3
        if len(graph) != expected_vertices:
            return False
        
        # æ£€æŸ¥è¾¹çš„æ„é€ 
        for i, clause1 in enumerate(clauses):
            for j, clause2 in enumerate(clauses):
                if i != j:
                    for literal1 in clause1:
                        for literal2 in clause2:
                            v1 = i * 3 + clause1.index(literal1)
                            v2 = j * 3 + clause2.index(literal2)
                            
                            # æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨
                            if literal1 != -literal2:
                                if v2 not in graph.get(v1, []):
                                    return False
        
        return True
    
    @staticmethod
    def verify_clique_to_vertex_cover(original_graph: Dict[int, List[int]], 
                                    k: int,
                                    complement_graph: Dict[int, List[int]], 
                                    cover_size: int) -> bool:
        """éªŒè¯å›¢é—®é¢˜åˆ°é¡¶ç‚¹è¦†ç›–é—®é¢˜çš„å½’çº¦"""
        vertices = set(original_graph.keys())
        n = len(vertices)
        
        # æ£€æŸ¥é¡¶ç‚¹è¦†ç›–å¤§å°
        if cover_size != n - k:
            return False
        
        # æ£€æŸ¥è¡¥å›¾æ„é€ 
        for v in vertices:
            for u in vertices:
                if u != v:
                    # åœ¨è¡¥å›¾ä¸­ï¼Œå¦‚æœåŸå›¾ä¸­æ²¡æœ‰è¾¹ï¼Œåˆ™åº”è¯¥æœ‰è¾¹
                    has_edge_original = u in original_graph.get(v, [])
                    has_edge_complement = u in complement_graph.get(v, [])
                    
                    if has_edge_original == has_edge_complement:
                        return False
        
        return True

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_reductions():
    """æ¼”ç¤ºé—®é¢˜å½’çº¦"""
    print("é—®é¢˜å½’çº¦æ¼”ç¤º")
    print("=" * 40)
    
    # 3-SATå®ä¾‹
    clauses = [[1, 2, 3], [-1, -2, 4], [1, -3, -4], [-2, 3, -4]]
    print(f"3-SATå®ä¾‹: {clauses}")
    
    # å½’çº¦åˆ°å›¢é—®é¢˜
    graph, k = NPCompleteProblems.three_sat_to_clique(clauses)
    print(f"å›¢é—®é¢˜: å›¾å¤§å°={len(graph)}, å›¢å¤§å°={k}")
    
    # éªŒè¯å½’çº¦
    is_valid = ReductionVerifier.verify_sat_to_clique(clauses, graph, k)
    print(f"å½’çº¦éªŒè¯: {'æ­£ç¡®' if is_valid else 'é”™è¯¯'}")
    
    # å½’çº¦åˆ°é¡¶ç‚¹è¦†ç›–
    complement_graph, cover_size = NPCompleteProblems.clique_to_vertex_cover(graph, k)
    print(f"é¡¶ç‚¹è¦†ç›–é—®é¢˜: å›¾å¤§å°={len(complement_graph)}, è¦†ç›–å¤§å°={cover_size}")
    
    # éªŒè¯å½’çº¦
    is_valid = ReductionVerifier.verify_clique_to_vertex_cover(graph, k, complement_graph, cover_size)
    print(f"å½’çº¦éªŒè¯: {'æ­£ç¡®' if is_valid else 'é”™è¯¯'}")

if __name__ == "__main__":
    demonstrate_reductions()
```

### 4. ç©ºé—´å¤æ‚æ€§

#### 4.1 ç©ºé—´å¤æ‚æ€§ç±»

**å®šä¹‰ 4.1** (PSPACE)
PSPACEç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼ç©ºé—´å†…è¢«ç¡®å®šæ€§å›¾çµæœºè§£å†³çš„é—®é¢˜çš„é›†åˆï¼š
$$PSPACE = \{L \mid \exists \text{DTM } M: L(M) = L \land \text{space}_M(n) = O(n^k)\}$$

**å®šä¹‰ 4.2** (NPSPACE)
NPSPACEç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼ç©ºé—´å†…è¢«éç¡®å®šæ€§å›¾çµæœºè§£å†³çš„é—®é¢˜çš„é›†åˆã€‚

**å®šç† 4.1** (è¨ç»´å¥‡å®šç†)
$$PSPACE = NPSPACE$$

#### 4.2 Pythonå®ç°

```python
from typing import Dict, List, Set, Tuple, Optional, Any
import sys

class SpaceComplexityAnalyzer:
    """ç©ºé—´å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.space_usage: List[Tuple[int, int]] = []
    
    def analyze_space_usage(self, 
                           algorithm: Callable,
                           problem_generator: Callable[[int], Any],
                           sizes: List[int]) -> List[Tuple[int, int]]:
        """åˆ†æç©ºé—´ä½¿ç”¨"""
        results = []
        
        for size in sizes:
            problem = problem_generator(size)
            
            # è®°å½•åˆå§‹å†…å­˜ä½¿ç”¨
            initial_memory = self._get_memory_usage()
            
            # è¿è¡Œç®—æ³•
            algorithm(problem)
            
            # è®°å½•æœ€ç»ˆå†…å­˜ä½¿ç”¨
            final_memory = self._get_memory_usage()
            space_used = final_memory - initial_memory
            
            results.append((size, space_used))
        
        return results
    
    def _get_memory_usage(self) -> int:
        """è·å–å½“å‰å†…å­˜ä½¿ç”¨é‡ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰"""
        # åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ›´ç²¾ç¡®çš„å†…å­˜ç›‘æ§
        return sys.getsizeof([])
    
    def classify_space_complexity(self, results: List[Tuple[int, int]]) -> str:
        """åˆ†ç±»ç©ºé—´å¤æ‚åº¦"""
        if len(results) < 2:
            return "æœªçŸ¥"
        
        # è®¡ç®—ç©ºé—´å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(results)):
            size_ratio = results[i][0] / results[i-1][0]
            space_ratio = results[i][1] / results[i-1][1]
            growth_rates.append(space_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        if avg_growth < 1.5:
            return "O(1)"
        elif avg_growth < 2.5:
            return "O(log n)"
        elif avg_growth < 3.5:
            return "O(n)"
        elif avg_growth < 5:
            return "O(n log n)"
        else:
            return "O(n^k), k > 1"

class RecursiveAlgorithm:
    """é€’å½’ç®—æ³•ç¤ºä¾‹"""
    
    def __init__(self):
        self.call_count = 0
        self.max_depth = 0
        self.current_depth = 0
    
    def factorial(self, n: int) -> int:
        """è®¡ç®—é˜¶ä¹˜ï¼ˆé€’å½’ç‰ˆæœ¬ï¼‰"""
        self.call_count += 1
        self.current_depth += 1
        self.max_depth = max(self.max_depth, self.current_depth)
        
        if n <= 1:
            result = 1
        else:
            result = n * self.factorial(n - 1)
        
        self.current_depth -= 1
        return result
    
    def fibonacci(self, n: int) -> int:
        """è®¡ç®—æ–æ³¢é‚£å¥‘æ•°ï¼ˆé€’å½’ç‰ˆæœ¬ï¼‰"""
        self.call_count += 1
        self.current_depth += 1
        self.max_depth = max(self.max_depth, self.current_depth)
        
        if n <= 1:
            result = n
        else:
            result = self.fibonacci(n - 1) + self.fibonacci(n - 2)
        
        self.current_depth -= 1
        return result
    
    def reset(self):
        """é‡ç½®è®¡æ•°å™¨"""
        self.call_count = 0
        self.max_depth = 0
        self.current_depth = 0

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_space_complexity():
    """æ¼”ç¤ºç©ºé—´å¤æ‚åº¦"""
    print("ç©ºé—´å¤æ‚åº¦æ¼”ç¤º")
    print("=" * 40)
    
    analyzer = SpaceComplexityAnalyzer()
    recursive_algo = RecursiveAlgorithm()
    
    # åˆ†æé˜¶ä¹˜ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦
    sizes = [5, 10, 15, 20]
    space_results = []
    
    for size in sizes:
        recursive_algo.reset()
        result = recursive_algo.factorial(size)
        space_results.append((size, recursive_algo.max_depth))
        print(f"é˜¶ä¹˜({size}) = {result}, é€’å½’æ·±åº¦: {recursive_algo.max_depth}")
    
    space_complexity = analyzer.classify_space_complexity(space_results)
    print(f"é˜¶ä¹˜ç®—æ³•ç©ºé—´å¤æ‚åº¦: {space_complexity}")

if __name__ == "__main__":
    demonstrate_space_complexity()
```

## ğŸ“Š å¤æ‚åº¦å±‚æ¬¡

### 1. å¤æ‚åº¦ç±»å…³ç³»

```text
P âŠ† NP âŠ† PSPACE âŠ† EXPTIME âŠ† EXPSPACE
```

### 2. é‡è¦é—®é¢˜åˆ†ç±»

| é—®é¢˜ç±»å‹ | å¤æ‚åº¦ç±» | ç¤ºä¾‹é—®é¢˜ |
|---------|---------|---------|
| æ˜“è§£é—®é¢˜ | P | æ’åºã€æœç´¢ã€æœ€çŸ­è·¯å¾„ |
| éš¾è§£é—®é¢˜ | NP | SATã€å›¢é—®é¢˜ã€æ—…è¡Œå•†é—®é¢˜ |
| ç©ºé—´é—®é¢˜ | PSPACE | åšå¼ˆã€é‡è¯å¸ƒå°”å…¬å¼ |
| æŒ‡æ•°æ—¶é—´ | EXPTIME | å›½é™…è±¡æ£‹ã€å›´æ£‹ |

### 3. æœªè§£å†³é—®é¢˜

1. **P vs NPé—®é¢˜**ï¼šP = NPï¼Ÿ
2. **NP vs PSPACEé—®é¢˜**ï¼šNP = PSPACEï¼Ÿ
3. **P vs PSPACEé—®é¢˜**ï¼šP = PSPACEï¼Ÿ

## ğŸ“ˆ æ€»ç»“

è®¡ç®—å¤æ‚æ€§ç†è®ºä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†ï¼š

1. **é—®é¢˜åˆ†ç±»**ï¼šå°†è®¡ç®—é—®é¢˜æŒ‰éš¾åº¦åˆ†ç±»
2. **ç®—æ³•è®¾è®¡æŒ‡å¯¼**ï¼šäº†è§£é—®é¢˜çš„å›ºæœ‰éš¾åº¦
3. **ä¼˜åŒ–è¾¹ç•Œ**ï¼šç¡®å®šç®—æ³•ä¼˜åŒ–çš„ç†è®ºæé™
4. **é—®é¢˜å½’çº¦**ï¼šé€šè¿‡å½’çº¦ç†è§£é—®é¢˜å…³ç³»
5. **å®é™…åº”ç”¨**ï¼šæŒ‡å¯¼ç®—æ³•é€‰æ‹©å’Œç³»ç»Ÿè®¾è®¡

é€šè¿‡ç³»ç»Ÿæ€§çš„å¤æ‚æ€§ç†è®ºï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

- ç†è§£é—®é¢˜çš„æœ¬è´¨éš¾åº¦
- é€‰æ‹©åˆé€‚çš„ç®—æ³•ç­–ç•¥
- é¿å…æ— æ•ˆçš„ä¼˜åŒ–å°è¯•
- è®¾è®¡é«˜æ•ˆçš„ç®—æ³•
- æ„å»ºå¯æ‰©å±•çš„ç³»ç»Ÿ

è®¡ç®—å¤æ‚æ€§ç†è®ºæ˜¯ç®—æ³•è®¾è®¡å’Œç³»ç»Ÿä¼˜åŒ–çš„ç†è®ºåŸºç¡€ï¼Œä¸ºç°ä»£è½¯ä»¶å·¥ç¨‹æä¾›äº†é‡è¦çš„ç†è®ºæŒ‡å¯¼ã€‚
