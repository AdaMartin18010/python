# 01. 设计模式理论

## 1.1 设计模式基础理论

### 1.1.1 模式的定义与本质

**定义 1.1.1 (设计模式)**
设计模式是在软件设计中反复出现的问题的典型解决方案，它描述了在特定上下文中解决特定问题的通用方法。

**形式化定义**：
设计模式 $P$ 是一个四元组：
$$P = (C, P, S, F)$$

其中：

- $C$ 是上下文 (Context)：模式适用的环境
- $P$ 是问题 (Problem)：需要解决的设计问题
- $S$ 是解决方案 (Solution)：抽象的设计结构
- $F$ 是效果 (Force)：使用模式的后果和权衡

**定理 1.1.1 (模式的存在性)**
对于任意设计问题 $D$，如果 $D$ 在多个系统中重复出现，则存在对应的设计模式 $P$ 解决 $D$。

*证明*：根据归纳原理，如果问题 $D$ 在 $n$ 个系统中出现，且每个系统都采用了相似的解决方案，那么这种解决方案就构成了一个模式。

### 1.1.2 模式的分类理论

**定义 1.1.2 (模式分类)**
设计模式可以按照以下维度分类：

1. **目的分类**：
   - 创建型模式：处理对象创建
   - 结构型模式：处理对象组合
   - 行为型模式：处理对象交互

2. **范围分类**：
   - 类模式：处理类之间的关系
   - 对象模式：处理对象之间的关系

3. **抽象层次分类**：
   - 架构模式：系统级设计
   - 设计模式：组件级设计
   - 惯用法：语言级设计

**数学表示**：
设模式集合为 $M$，分类函数为 $f: M \rightarrow C \times S \times A$，其中：

- $C$ 是目的集合
- $S$ 是范围集合  
- $A$ 是抽象层次集合

### 1.1.3 模式关系理论

**定义 1.1.3 (模式关系)**
模式间存在以下关系：

1. **组合关系**：$P_1 \circ P_2$ 表示模式 $P_1$ 和 $P_2$ 的组合
2. **继承关系**：$P_1 \prec P_2$ 表示 $P_1$ 是 $P_2$ 的特化
3. **依赖关系**：$P_1 \rightarrow P_2$ 表示 $P_1$ 依赖于 $P_2$

**定理 1.1.2 (模式组合的封闭性)**
如果 $P_1$ 和 $P_2$ 是有效的设计模式，那么它们的组合 $P_1 \circ P_2$ 也是有效的设计模式。

## 1.2 创建型模式理论

### 1.2.1 单例模式理论

**定义 1.2.1 (单例模式)**
单例模式确保一个类只有一个实例，并提供全局访问点。

**形式化定义**：
设类 $C$ 的单例实现为 $S(C)$，则：
$$\forall x, y \in S(C), x = y$$

**Python实现**：

```python
from typing import TypeVar, Type
from threading import Lock

T = TypeVar('T')

class Singleton:
    """单例模式基类"""
    _instances = {}
    _locks = {}
    
    def __new__(cls: Type[T]) -> T:
        if cls not in cls._instances:
            if cls not in cls._locks:
                cls._locks[cls] = Lock()
            
            with cls._locks[cls]:
                if cls not in cls._instances:
                    cls._instances[cls] = super().__new__(cls)
        return cls._instances[cls]

class Logger(Singleton):
    """单例日志器"""
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
            self._log_level = "INFO"
    
    def log(self, message: str, level: str = None):
        if level is None:
            level = self._log_level
        print(f"[{level}] {message}")
    
    def set_level(self, level: str):
        self._log_level = level

# 使用示例
logger1 = Logger()
logger2 = Logger()
assert logger1 is logger2  # 同一个实例
```

**定理 1.2.1 (单例唯一性)**
在单例模式中，类的所有实例都是同一个对象。

### 1.2.2 工厂模式理论

**定义 1.2.2 (工厂模式)**
工厂模式定义一个创建对象的接口，让子类决定实例化哪个类。

**形式化定义**：
设产品接口为 $I$，具体产品为 $C_1, C_2, ..., C_n$，工厂接口为 $F$，则：
$$F: \emptyset \rightarrow I$$

**Python实现**：

```python
from abc import ABC, abstractmethod
from typing import Dict, Type

class Product(ABC):
    """产品抽象基类"""
    @abstractmethod
    def operation(self) -> str:
        pass

class ConcreteProductA(Product):
    """具体产品A"""
    def operation(self) -> str:
        return "ConcreteProductA operation"

class ConcreteProductB(Product):
    """具体产品B"""
    def operation(self) -> str:
        return "ConcreteProductB operation"

class Creator(ABC):
    """创建者抽象基类"""
    @abstractmethod
    def factory_method(self) -> Product:
        pass
    
    def some_operation(self) -> str:
        product = self.factory_method()
        return f"Creator: {product.operation()}"

class ConcreteCreatorA(Creator):
    """具体创建者A"""
    def factory_method(self) -> Product:
        return ConcreteProductA()

class ConcreteCreatorB(Creator):
    """具体创建者B"""
    def factory_method(self) -> Product:
        return ConcreteProductB()

# 工厂注册表模式
class ProductRegistry:
    """产品注册表"""
    _products: Dict[str, Type[Product]] = {}
    
    @classmethod
    def register(cls, name: str, product_class: Type[Product]):
        cls._products[name] = product_class
    
    @classmethod
    def create(cls, name: str) -> Product:
        if name not in cls._products:
            raise ValueError(f"Product {name} not registered")
        return cls._products[name]()

# 注册产品
ProductRegistry.register("A", ConcreteProductA)
ProductRegistry.register("B", ConcreteProductB)
```

## 1.3 结构型模式理论

### 1.3.1 适配器模式理论

**定义 1.3.1 (适配器模式)**
适配器模式将一个类的接口转换成客户期望的另一个接口。

**形式化定义**：
设目标接口为 $T$，适配者接口为 $A$，适配器为 $Adapter$，则：
$$Adapter: A \rightarrow T$$

**Python实现**：

```python
from abc import ABC, abstractmethod
from typing import Protocol

class Target(Protocol):
    """目标接口"""
    def request(self) -> str:
        ...

class Adaptee:
    """适配者类"""
    def specific_request(self) -> str:
        return "Adaptee specific request"

class Adapter:
    """适配器类"""
    def __init__(self, adaptee: Adaptee):
        self._adaptee = adaptee
    
    def request(self) -> str:
        return f"Adapter: {self._adaptee.specific_request()}"

# 函数式适配器
def create_adapter(adaptee: Adaptee) -> Target:
    """创建适配器的函数"""
    def request() -> str:
        return f"Functional Adapter: {adaptee.specific_request()}"
    return request
```

## 1.4 行为型模式理论

### 1.4.1 观察者模式理论

**定义 1.4.1 (观察者模式)**
观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**形式化定义**：
设主题为 $S$，观察者集合为 $O = \{o_1, o_2, ..., o_n\}$，则：
$$S \rightarrow O \text{ (通知关系)}$$

**Python实现**：

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from collections import defaultdict
import asyncio

class Observer(ABC):
    """观察者抽象基类"""
    @abstractmethod
    def update(self, subject: 'Subject', **kwargs) -> None:
        pass

class Subject(ABC):
    """主题抽象基类"""
    def __init__(self):
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer) -> None:
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: Observer) -> None:
        self._observers.remove(observer)
    
    def notify(self, **kwargs) -> None:
        for observer in self._observers:
            observer.update(self, **kwargs)

class ConcreteSubject(Subject):
    """具体主题"""
    def __init__(self):
        super().__init__()
        self._state = None
    
    @property
    def state(self):
        return self._state
    
    @state.setter
    def state(self, value):
        self._state = value
        self.notify(state=value)

class ConcreteObserver(Observer):
    """具体观察者"""
    def __init__(self, name: str):
        self.name = name
    
    def update(self, subject: Subject, **kwargs) -> None:
        print(f"{self.name} received update: {kwargs}")

# 事件总线模式
class EventBus:
    """事件总线"""
    def __init__(self):
        self._handlers: Dict[str, List[callable]] = defaultdict(list)
    
    def subscribe(self, event_type: str, handler: callable) -> None:
        self._handlers[event_type].append(handler)
    
    def unsubscribe(self, event_type: str, handler: callable) -> None:
        if event_type in self._handlers:
            self._handlers[event_type].remove(handler)
    
    def publish(self, event_type: str, **kwargs) -> None:
        for handler in self._handlers[event_type]:
            handler(**kwargs)
```

## 1.5 模式组合理论

### 1.5.1 模式组合原则

**定义 1.5.1 (模式组合)**
模式组合是将多个设计模式结合使用以解决复杂设计问题的方法。

**组合原则**：

1. **单一职责原则**：每个模式只负责一个方面
2. **开闭原则**：对扩展开放，对修改封闭
3. **依赖倒置原则**：依赖抽象而非具体实现
4. **接口隔离原则**：使用多个专门的接口而非单一的总接口

### 1.5.2 常见模式组合

-**组合 1.5.1 (工厂+策略)**

```python
class PaymentStrategy(Protocol):
    def pay(self, amount: float) -> bool:
        ...

class CreditCardPayment:
    def pay(self, amount: float) -> bool:
        print(f"Paying {amount} with credit card")
        return True

class PayPalPayment:
    def pay(self, amount: float) -> bool:
        print(f"Paying {amount} with PayPal")
        return True

class PaymentFactory:
    @staticmethod
    def create_payment(method: str) -> PaymentStrategy:
        if method == "credit_card":
            return CreditCardPayment()
        elif method == "paypal":
            return PayPalPayment()
        else:
            raise ValueError(f"Unknown payment method: {method}")

# 使用组合
payment = PaymentFactory.create_payment("credit_card")
payment.pay(100.0)
```

## 1.6 模式评估理论

### 1.6.1 模式质量指标

**定义 1.6.1 (模式质量)**
模式质量可以从以下维度评估：

1. **可理解性**：模式是否容易理解
2. **可维护性**：模式是否容易维护
3. **可扩展性**：模式是否容易扩展
4. **性能影响**：模式对性能的影响
5. **内存开销**：模式的内存使用情况

**量化指标**：

- 代码复杂度：$C = \text{cyclomatic\_complexity}$
- 耦合度：$Co = \frac{\text{dependencies}}{\text{total\_components}}$
- 内聚度：$Ch = \frac{\text{related\_methods}}{\text{total\_methods}}$

### 1.6.2 模式选择决策

**决策模型**：
对于设计问题 $P$，选择模式 $M$ 的决策函数：
$$D(P, M) = w_1 \cdot Q_1(M) + w_2 \cdot Q_2(M) + ... + w_n \cdot Q_n(M)$$

其中 $Q_i$ 是质量指标，$w_i$ 是权重。

## 1.7 总结

设计模式理论为软件设计提供了系统化的解决方案框架。通过形式化的定义和数学化的分析，我们可以：

1. 精确描述模式的结构和行为
2. 分析模式之间的关系和组合
3. 评估模式的质量和适用性
4. 指导模式的选择和使用

这些理论基础将指导后续的具体实践，确保设计模式的有效应用。
