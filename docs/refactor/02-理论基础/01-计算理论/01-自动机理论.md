# 01-计算理论 - 自动机理论

## 概述

自动机理论是计算理论的基础，研究抽象的计算模型。它包括有限自动机、下推自动机、图灵机等，为理解计算能力和复杂度提供理论基础。

## 目录

- [01-计算理论 - 自动机理论](#01-计算理论---自动机理论)
  - [概述](#概述)
  - [目录](#目录)
  - [1. 有限自动机 (Finite Automata)](#1-有限自动机-finite-automata)
    - [1.1 定义](#11-定义)
    - [1.2 形式化表示](#12-形式化表示)
    - [1.3 非确定性有限自动机 (NFA)](#13-非确定性有限自动机-nfa)
  - [2. 下推自动机 (Pushdown Automata)](#2-下推自动机-pushdown-automata)
    - [2.1 定义](#21-定义)
    - [2.2 形式化表示](#22-形式化表示)
  - [3. 图灵机 (Turing Machine)](#3-图灵机-turing-machine)
    - [3.1 定义](#31-定义)
    - [3.2 形式化表示](#32-形式化表示)
  - [4. 自动机等价性](#4-自动机等价性)
    - [4.1 等价性定义](#41-等价性定义)
    - [4.2 等价性测试](#42-等价性测试)
  - [5. 正则表达式](#5-正则表达式)
    - [5.1 正则表达式定义](#51-正则表达式定义)
    - [5.2 正则表达式实现](#52-正则表达式实现)
  - [6. 上下文无关文法](#6-上下文无关文法)
    - [6.1 上下文无关文法定义](#61-上下文无关文法定义)
    - [6.2 上下文无关文法实现](#62-上下文无关文法实现)
  - [理论联系](#理论联系)
    - [与形式科学的联系](#与形式科学的联系)
    - [与理论基础的联系](#与理论基础的联系)
  - [持续发展](#持续发展)
  - [参考文献](#参考文献)

---

## 1. 有限自动机 (Finite Automata)

### 1.1 定义

**定义 1.1.1 (有限自动机)**  
有限自动机是一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：

- $Q$: 有限状态集
- $\Sigma$: 有限输入字母表
- $\delta: Q \times \Sigma \rightarrow Q$: 转移函数
- $q_0 \in Q$: 初始状态
- $F \subseteq Q$: 接受状态集

### 1.2 形式化表示

```python
from typing import Set, Dict, List, Any, Optional, Tuple, Union
from dataclasses import dataclass
from abc import ABC, abstractmethod
import re

@dataclass
class FiniteAutomaton:
    """有限自动机"""
    states: Set[str]                    # 状态集
    alphabet: Set[str]                  # 输入字母表
    transitions: Dict[Tuple[str, str], str]  # 转移函数
    initial_state: str                  # 初始状态
    accepting_states: Set[str]          # 接受状态集
    
    def __post_init__(self):
        # 验证初始状态在状态集中
        if self.initial_state not in self.states:
            raise ValueError(f"初始状态 {self.initial_state} 不在状态集中")
        
        # 验证接受状态是状态集的子集
        if not self.accepting_states.issubset(self.states):
            raise ValueError("接受状态集不是状态集的子集")
    
    def transition(self, state: str, symbol: str) -> Optional[str]:
        """执行转移"""
        return self.transitions.get((state, symbol))
    
    def accepts(self, input_string: str) -> bool:
        """判断是否接受输入字符串"""
        current_state = self.initial_state
        
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False  # 输入符号不在字母表中
            
            next_state = self.transition(current_state, symbol)
            if next_state is None:
                return False  # 没有定义转移
            
            current_state = next_state
        
        return current_state in self.accepting_states
    
    def get_reachable_states(self) -> Set[str]:
        """获取可达状态"""
        reachable = {self.initial_state}
        changed = True
        
        while changed:
            changed = False
            new_reachable = reachable.copy()
            
            for state in reachable:
                for symbol in self.alphabet:
                    next_state = self.transition(state, symbol)
                    if next_state and next_state not in reachable:
                        new_reachable.add(next_state)
                        changed = True
            
            reachable = new_reachable
        
        return reachable
    
    def is_deterministic(self) -> bool:
        """判断是否为确定性有限自动机"""
        for state in self.states:
            for symbol in self.alphabet:
                # 检查每个转移是否唯一
                transitions_for_state_symbol = [
                    next_state for (s, a), next_state in self.transitions.items()
                    if s == state and a == symbol
                ]
                if len(transitions_for_state_symbol) > 1:
                    return False
        return True
    
    def minimize(self) -> 'FiniteAutomaton':
        """最小化有限自动机"""
        # 移除不可达状态
        reachable_states = self.get_reachable_states()
        
        # 创建等价类
        equivalence_classes = self._find_equivalence_classes(reachable_states)
        
        # 构建最小化自动机
        return self._build_minimized_automaton(equivalence_classes)
    
    def _find_equivalence_classes(self, states: Set[str]) -> List[Set[str]]:
        """找到等价类"""
        # 初始划分：接受状态和非接受状态
        accepting = states & self.accepting_states
        non_accepting = states - self.accepting_states
        
        partition = []
        if accepting:
            partition.append(accepting)
        if non_accepting:
            partition.append(non_accepting)
        
        # 细化划分
        changed = True
        while changed:
            changed = False
            new_partition = []
            
            for group in partition:
                if len(group) <= 1:
                    new_partition.append(group)
                    continue
                
                # 尝试分割组
                subgroups = self._split_group(group, partition)
                if len(subgroups) > 1:
                    new_partition.extend(subgroups)
                    changed = True
                else:
                    new_partition.append(group)
            
            partition = new_partition
        
        return partition
    
    def _split_group(self, group: Set[str], partition: List[Set[str]]) -> List[Set[str]]:
        """分割等价类"""
        if len(group) <= 1:
            return [group]
        
        # 找到分割标准
        split_criteria = {}
        for state in group:
            criteria = []
            for symbol in self.alphabet:
                next_state = self.transition(state, symbol)
                if next_state:
                    # 找到next_state所在的等价类
                    for i, equiv_class in enumerate(partition):
                        if next_state in equiv_class:
                            criteria.append((symbol, i))
                            break
            split_criteria[state] = tuple(criteria)
        
        # 根据分割标准分组
        subgroups = {}
        for state in group:
            criteria = split_criteria[state]
            if criteria not in subgroups:
                subgroups[criteria] = set()
            subgroups[criteria].add(state)
        
        return list(subgroups.values())
    
    def _build_minimized_automaton(self, equivalence_classes: List[Set[str]]) -> 'FiniteAutomaton':
        """构建最小化自动机"""
        # 创建新的状态集
        new_states = set()
        new_transitions = {}
        new_accepting_states = set()
        
        # 为每个等价类创建一个新状态
        class_to_state = {}
        for i, equiv_class in enumerate(equivalence_classes):
            new_state = f"q{i}"
            new_states.add(new_state)
            class_to_state[tuple(equiv_class)] = new_state
            
            # 检查是否包含接受状态
            if equiv_class & self.accepting_states:
                new_accepting_states.add(new_state)
        
        # 构建转移函数
        for equiv_class in equivalence_classes:
            representative = next(iter(equiv_class))
            new_state = class_to_state[tuple(equiv_class)]
            
            for symbol in self.alphabet:
                next_state = self.transition(representative, symbol)
                if next_state:
                    # 找到next_state所在的等价类
                    for target_class in equivalence_classes:
                        if next_state in target_class:
                            target_new_state = class_to_state[tuple(target_class)]
                            new_transitions[(new_state, symbol)] = target_new_state
                            break
        
        # 确定初始状态
        for equiv_class in equivalence_classes:
            if self.initial_state in equiv_class:
                new_initial_state = class_to_state[tuple(equiv_class)]
                break
        
        return FiniteAutomaton(
            states=new_states,
            alphabet=self.alphabet,
            transitions=new_transitions,
            initial_state=new_initial_state,
            accepting_states=new_accepting_states
        )

# 使用示例
def demonstrate_finite_automaton():
    """演示有限自动机"""
    
    # 创建一个接受偶数个0的有限自动机
    states = {'q0', 'q1'}
    alphabet = {'0', '1'}
    transitions = {
        ('q0', '0'): 'q1',
        ('q0', '1'): 'q0',
        ('q1', '0'): 'q0',
        ('q1', '1'): 'q1'
    }
    initial_state = 'q0'
    accepting_states = {'q0'}
    
    fa = FiniteAutomaton(states, alphabet, transitions, initial_state, accepting_states)
    
    # 测试字符串
    test_strings = ['', '0', '00', '000', '01', '001', '100', '1010']
    
    print("有限自动机测试（接受偶数个0）:")
    for test_str in test_strings:
        result = fa.accepts(test_str)
        print(f"  '{test_str}' -> {result}")
    
    # 检查是否为确定性
    print(f"\n是否为确定性自动机: {fa.is_deterministic()}")
    
    # 获取可达状态
    reachable = fa.get_reachable_states()
    print(f"可达状态: {reachable}")
    
    # 最小化
    minimized = fa.minimize()
    print(f"最小化后的状态数: {len(minimized.states)}")

if __name__ == "__main__":
    demonstrate_finite_automaton()
```

### 1.3 非确定性有限自动机 (NFA)

```python
@dataclass
class NondeterministicFiniteAutomaton:
    """非确定性有限自动机"""
    states: Set[str]
    alphabet: Set[str]
    transitions: Dict[Tuple[str, str], Set[str]]  # 转移函数返回状态集
    initial_state: str
    accepting_states: Set[str]
    
    def transition(self, state: str, symbol: str) -> Set[str]:
        """执行转移"""
        return self.transitions.get((state, symbol), set())
    
    def epsilon_closure(self, states: Set[str]) -> Set[str]:
        """计算ε闭包"""
        closure = states.copy()
        changed = True
        
        while changed:
            changed = False
            new_closure = closure.copy()
            
            for state in closure:
                # 添加ε转移可达的状态
                epsilon_states = self.transitions.get((state, 'ε'), set())
                for epsilon_state in epsilon_states:
                    if epsilon_state not in closure:
                        new_closure.add(epsilon_state)
                        changed = True
            
            closure = new_closure
        
        return closure
    
    def accepts(self, input_string: str) -> bool:
        """判断是否接受输入字符串"""
        current_states = self.epsilon_closure({self.initial_state})
        
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            
            # 计算下一个状态集
            next_states = set()
            for state in current_states:
                transitions = self.transition(state, symbol)
                next_states.update(transitions)
            
            # 计算ε闭包
            current_states = self.epsilon_closure(next_states)
            
            if not current_states:
                return False
        
        # 检查是否有接受状态
        return bool(current_states & self.accepting_states)
    
    def to_dfa(self) -> FiniteAutomaton:
        """转换为确定性有限自动机"""
        # 子集构造法
        dfa_states = set()
        dfa_transitions = {}
        dfa_accepting_states = set()
        
        # 初始状态
        initial_dfa_state = tuple(sorted(self.epsilon_closure({self.initial_state})))
        dfa_states.add(initial_dfa_state)
        
        # 处理队列
        unprocessed = [initial_dfa_state]
        processed = set()
        
        while unprocessed:
            current_dfa_state = unprocessed.pop(0)
            if current_dfa_state in processed:
                continue
            
            processed.add(current_dfa_state)
            
            # 检查是否为接受状态
            if set(current_dfa_state) & self.accepting_states:
                dfa_accepting_states.add(current_dfa_state)
            
            # 为每个输入符号计算转移
            for symbol in self.alphabet:
                next_states = set()
                
                for nfa_state in current_dfa_state:
                    transitions = self.transition(nfa_state, symbol)
                    next_states.update(transitions)
                
                # 计算ε闭包
                next_states = self.epsilon_closure(next_states)
                next_dfa_state = tuple(sorted(next_states))
                
                if next_dfa_state:
                    dfa_states.add(next_dfa_state)
                    dfa_transitions[(current_dfa_state, symbol)] = next_dfa_state
                    
                    if next_dfa_state not in processed:
                        unprocessed.append(next_dfa_state)
        
        # 转换为字符串状态
        state_mapping = {state: f"q{i}" for i, state in enumerate(dfa_states)}
        
        new_transitions = {}
        for (state, symbol), next_state in dfa_transitions.items():
            new_transitions[(state_mapping[state], symbol)] = state_mapping[next_state]
        
        new_accepting_states = {state_mapping[state] for state in dfa_accepting_states}
        
        return FiniteAutomaton(
            states=set(state_mapping.values()),
            alphabet=self.alphabet,
            transitions=new_transitions,
            initial_state=state_mapping[initial_dfa_state],
            accepting_states=new_accepting_states
        )

# 使用示例
def demonstrate_nfa():
    """演示非确定性有限自动机"""
    
    # 创建一个NFA，接受包含"ab"的字符串
    states = {'q0', 'q1', 'q2'}
    alphabet = {'a', 'b'}
    transitions = {
        ('q0', 'a'): {'q0', 'q1'},
        ('q0', 'b'): {'q0'},
        ('q1', 'a'): {'q1'},
        ('q1', 'b'): {'q2'},
        ('q2', 'a'): {'q2'},
        ('q2', 'b'): {'q2'}
    }
    initial_state = 'q0'
    accepting_states = {'q2'}
    
    nfa = NondeterministicFiniteAutomaton(
        states, alphabet, transitions, initial_state, accepting_states
    )
    
    # 测试字符串
    test_strings = ['', 'a', 'b', 'ab', 'ba', 'aab', 'abb', 'abc']
    
    print("NFA测试（接受包含'ab'的字符串）:")
    for test_str in test_strings:
        result = nfa.accepts(test_str)
        print(f"  '{test_str}' -> {result}")
    
    # 转换为DFA
    dfa = nfa.to_dfa()
    print(f"\n转换为DFA后的状态数: {len(dfa.states)}")
    
    # 验证转换正确性
    print("\n验证转换正确性:")
    for test_str in test_strings:
        nfa_result = nfa.accepts(test_str)
        dfa_result = dfa.accepts(test_str)
        print(f"  '{test_str}': NFA={nfa_result}, DFA={dfa_result}")

if __name__ == "__main__":
    demonstrate_nfa()
```

---

## 2. 下推自动机 (Pushdown Automata)

### 2.1 定义

**定义 2.1.1 (下推自动机)**  
下推自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

- $Q$: 有限状态集
- $\Sigma$: 有限输入字母表
- $\Gamma$: 有限栈字母表
- $\delta: Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow 2^{Q \times \Gamma^*}$: 转移函数
- $q_0 \in Q$: 初始状态
- $Z_0 \in \Gamma$: 初始栈符号
- $F \subseteq Q$: 接受状态集

### 2.2 形式化表示

```python
@dataclass
class PushdownAutomaton:
    """下推自动机"""
    states: Set[str]
    input_alphabet: Set[str]
    stack_alphabet: Set[str]
    transitions: Dict[Tuple[str, str, str], List[Tuple[str, str]]]
    initial_state: str
    initial_stack_symbol: str
    accepting_states: Set[str]
    
    def __post_init__(self):
        if self.initial_state not in self.states:
            raise ValueError(f"初始状态 {self.initial_state} 不在状态集中")
        
        if self.initial_stack_symbol not in self.stack_alphabet:
            raise ValueError(f"初始栈符号 {self.initial_stack_symbol} 不在栈字母表中")
        
        if not self.accepting_states.issubset(self.states):
            raise ValueError("接受状态集不是状态集的子集")
    
    def transition(self, state: str, input_symbol: str, stack_top: str) -> List[Tuple[str, str]]:
        """执行转移"""
        return self.transitions.get((state, input_symbol, stack_top), [])
    
    def accepts(self, input_string: str) -> bool:
        """判断是否接受输入字符串"""
        # 使用配置进行模拟
        initial_config = (self.initial_state, input_string, [self.initial_stack_symbol])
        return self._accepts_config(initial_config)
    
    def _accepts_config(self, config: Tuple[str, str, List[str]]) -> bool:
        """判断配置是否被接受"""
        current_state, remaining_input, stack = config
        
        # 如果输入为空且状态为接受状态，则接受
        if not remaining_input and current_state in self.accepting_states:
            return True
        
        # 如果栈为空，则拒绝
        if not stack:
            return False
        
        stack_top = stack[-1]
        
        # 尝试所有可能的转移
        for input_symbol in [remaining_input[0] if remaining_input else 'ε']:
            transitions = self.transition(current_state, input_symbol, stack_top)
            
            for next_state, stack_push in transitions:
                # 创建新配置
                new_stack = stack[:-1] + list(stack_push)[::-1]  # 反转栈推入顺序
                new_remaining = remaining_input[1:] if input_symbol != 'ε' else remaining_input
                
                new_config = (next_state, new_remaining, new_stack)
                
                if self._accepts_config(new_config):
                    return True
        
        return False
    
    def to_cfg(self) -> 'ContextFreeGrammar':
        """转换为上下文无关文法"""
        # 这里是一个简化的转换
        # 实际转换需要更复杂的算法
        pass

# 使用示例
def demonstrate_pushdown_automaton():
    """演示下推自动机"""
    
    # 创建一个接受 {a^n b^n | n >= 0} 的PDA
    states = {'q0', 'q1', 'q2'}
    input_alphabet = {'a', 'b'}
    stack_alphabet = {'Z', 'A'}
    transitions = {
        ('q0', 'a', 'Z'): [('q0', 'AZ')],
        ('q0', 'a', 'A'): [('q0', 'AA')],
        ('q0', 'b', 'A'): [('q1', '')],
        ('q1', 'b', 'A'): [('q1', '')],
        ('q1', 'ε', 'Z'): [('q2', 'Z')]
    }
    initial_state = 'q0'
    initial_stack_symbol = 'Z'
    accepting_states = {'q2'}
    
    pda = PushdownAutomaton(
        states, input_alphabet, stack_alphabet, transitions,
        initial_state, initial_stack_symbol, accepting_states
    )
    
    # 测试字符串
    test_strings = ['', 'ab', 'aabb', 'aaabbb', 'abb', 'aab']
    
    print("下推自动机测试（接受 {a^n b^n | n >= 0}）:")
    for test_str in test_strings:
        result = pda.accepts(test_str)
        print(f"  '{test_str}' -> {result}")

if __name__ == "__main__":
    demonstrate_pushdown_automaton()
```

---

## 3. 图灵机 (Turing Machine)

### 3.1 定义

**定义 3.1.1 (图灵机)**  
图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$，其中：

- $Q$: 有限状态集
- $\Sigma$: 有限输入字母表
- $\Gamma$: 有限带字母表（$\Sigma \subseteq \Gamma$）
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$: 转移函数
- $q_0 \in Q$: 初始状态
- $B \in \Gamma$: 空白符号
- $F \subseteq Q$: 接受状态集

### 3.2 形式化表示

```python
from enum import Enum

class Direction(Enum):
    LEFT = 'L'
    RIGHT = 'R'

@dataclass
class TuringMachine:
    """图灵机"""
    states: Set[str]
    input_alphabet: Set[str]
    tape_alphabet: Set[str]
    transitions: Dict[Tuple[str, str], Tuple[str, str, Direction]]
    initial_state: str
    blank_symbol: str
    accepting_states: Set[str]
    
    def __post_init__(self):
        if self.initial_state not in self.states:
            raise ValueError(f"初始状态 {self.initial_state} 不在状态集中")
        
        if self.blank_symbol not in self.tape_alphabet:
            raise ValueError(f"空白符号 {self.blank_symbol} 不在带字母表中")
        
        if not self.input_alphabet.issubset(self.tape_alphabet):
            raise ValueError("输入字母表不是带字母表的子集")
        
        if not self.accepting_states.issubset(self.states):
            raise ValueError("接受状态集不是状态集的子集")
    
    def transition(self, state: str, symbol: str) -> Optional[Tuple[str, str, Direction]]:
        """执行转移"""
        return self.transitions.get((state, symbol))
    
    def run(self, input_string: str, max_steps: int = 1000) -> Tuple[bool, str, int]:
        """运行图灵机"""
        # 初始化带
        tape = list(input_string)
        if not tape:
            tape = [self.blank_symbol]
        
        # 添加无限空白
        tape.extend([self.blank_symbol] * 100)
        
        current_state = self.initial_state
        head_position = 0
        steps = 0
        
        while steps < max_steps:
            # 检查是否到达接受状态
            if current_state in self.accepting_states:
                return True, ''.join(tape).rstrip(self.blank_symbol), steps
            
            # 读取当前符号
            current_symbol = tape[head_position]
            
            # 执行转移
            transition = self.transition(current_state, current_symbol)
            if transition is None:
                return False, ''.join(tape).rstrip(self.blank_symbol), steps
            
            next_state, write_symbol, direction = transition
            
            # 写入符号
            tape[head_position] = write_symbol
            
            # 移动头
            if direction == Direction.LEFT:
                head_position = max(0, head_position - 1)
            else:  # Direction.RIGHT
                head_position += 1
                if head_position >= len(tape):
                    tape.append(self.blank_symbol)
            
            current_state = next_state
            steps += 1
        
        # 超时
        return False, ''.join(tape).rstrip(self.blank_symbol), steps
    
    def accepts(self, input_string: str) -> bool:
        """判断是否接受输入字符串"""
        accepted, _, _ = self.run(input_string)
        return accepted

# 使用示例
def demonstrate_turing_machine():
    """演示图灵机"""
    
    # 创建一个接受 {a^n b^n c^n | n >= 0} 的图灵机
    states = {'q0', 'q1', 'q2', 'q3', 'q4', 'q5', 'q6', 'qaccept', 'qreject'}
    input_alphabet = {'a', 'b', 'c'}
    tape_alphabet = {'a', 'b', 'c', 'X', 'Y', 'Z', 'B'}
    transitions = {
        # 初始状态：读取第一个a
        ('q0', 'a'): ('q1', 'X', Direction.RIGHT),
        ('q0', 'B'): ('qaccept', 'B', Direction.RIGHT),  # 空字符串
        ('q0', 'b'): ('qreject', 'b', Direction.RIGHT),
        ('q0', 'c'): ('qreject', 'c', Direction.RIGHT),
        
        # 跳过a，寻找第一个b
        ('q1', 'a'): ('q1', 'a', Direction.RIGHT),
        ('q1', 'b'): ('q2', 'Y', Direction.RIGHT),
        ('q1', 'X'): ('q1', 'X', Direction.RIGHT),
        ('q1', 'Y'): ('q1', 'Y', Direction.RIGHT),
        ('q1', 'Z'): ('q1', 'Z', Direction.RIGHT),
        
        # 跳过b，寻找第一个c
        ('q2', 'b'): ('q2', 'b', Direction.RIGHT),
        ('q2', 'c'): ('q3', 'Z', Direction.LEFT),
        ('q2', 'Y'): ('q2', 'Y', Direction.RIGHT),
        ('q2', 'Z'): ('q2', 'Z', Direction.RIGHT),
        
        # 向左移动，寻找X
        ('q3', 'a'): ('q3', 'a', Direction.LEFT),
        ('q3', 'b'): ('q3', 'b', Direction.LEFT),
        ('q3', 'c'): ('q3', 'c', Direction.LEFT),
        ('q3', 'X'): ('q4', 'X', Direction.RIGHT),
        ('q3', 'Y'): ('q3', 'Y', Direction.LEFT),
        ('q3', 'Z'): ('q3', 'Z', Direction.LEFT),
        
        # 检查是否还有a
        ('q4', 'a'): ('q1', 'X', Direction.RIGHT),
        ('q4', 'Y'): ('q5', 'Y', Direction.RIGHT),
        
        # 检查是否还有b
        ('q5', 'b'): ('q2', 'Y', Direction.RIGHT),
        ('q5', 'Z'): ('q6', 'Z', Direction.RIGHT),
        
        # 检查是否还有c
        ('q6', 'c'): ('q3', 'Z', Direction.LEFT),
        ('q6', 'B'): ('qaccept', 'B', Direction.RIGHT),
    }
    initial_state = 'q0'
    blank_symbol = 'B'
    accepting_states = {'qaccept'}
    
    tm = TuringMachine(
        states, input_alphabet, tape_alphabet, transitions,
        initial_state, blank_symbol, accepting_states
    )
    
    # 测试字符串
    test_strings = ['', 'abc', 'aabbcc', 'aaabbbccc', 'abbc', 'aabcc']
    
    print("图灵机测试（接受 {a^n b^n c^n | n >= 0}）:")
    for test_str in test_strings:
        accepted, final_tape, steps = tm.run(test_str)
        print(f"  '{test_str}' -> {accepted} (步骤: {steps})")

if __name__ == "__main__":
    demonstrate_turing_machine()
```

---

## 4. 自动机等价性

### 4.1 等价性定义

**定义 4.1.1 (自动机等价性)**  
两个自动机 $M_1$ 和 $M_2$ 等价，当且仅当它们接受相同的语言。

$$M_1 \equiv M_2 \Leftrightarrow L(M_1) = L(M_2)$$

### 4.2 等价性测试

```python
class AutomataEquivalence:
    """自动机等价性测试"""
    
    @staticmethod
    def are_equivalent(fa1: FiniteAutomaton, fa2: FiniteAutomaton) -> bool:
        """测试两个有限自动机是否等价"""
        # 使用乘积构造法
        product = AutomataEquivalence._build_product_automaton(fa1, fa2)
        
        # 检查是否存在可达的不等价状态
        return not AutomataEquivalence._has_inequivalent_states(product)
    
    @staticmethod
    def _build_product_automaton(fa1: FiniteAutomaton, fa2: FiniteAutomaton) -> FiniteAutomaton:
        """构建乘积自动机"""
        # 确保字母表相同
        if fa1.alphabet != fa2.alphabet:
            raise ValueError("自动机的字母表必须相同")
        
        # 创建乘积状态
        product_states = set()
        product_transitions = {}
        product_accepting_states = set()
        
        # 初始状态
        initial_state = (fa1.initial_state, fa2.initial_state)
        product_states.add(initial_state)
        
        # 处理队列
        unprocessed = [initial_state]
        processed = set()
        
        while unprocessed:
            current_state = unprocessed.pop(0)
            if current_state in processed:
                continue
            
            processed.add(current_state)
            state1, state2 = current_state
            
            # 检查是否为接受状态（异或）
            accepting1 = state1 in fa1.accepting_states
            accepting2 = state2 in fa2.accepting_states
            if accepting1 != accepting2:
                product_accepting_states.add(current_state)
            
            # 为每个输入符号计算转移
            for symbol in fa1.alphabet:
                next_state1 = fa1.transition(state1, symbol)
                next_state2 = fa2.transition(state2, symbol)
                
                if next_state1 and next_state2:
                    next_state = (next_state1, next_state2)
                    product_states.add(next_state)
                    product_transitions[(current_state, symbol)] = next_state
                    
                    if next_state not in processed:
                        unprocessed.append(next_state)
        
        return FiniteAutomaton(
            states=product_states,
            alphabet=fa1.alphabet,
            transitions=product_transitions,
            initial_state=initial_state,
            accepting_states=product_accepting_states
        )
    
    @staticmethod
    def _has_inequivalent_states(product: FiniteAutomaton) -> bool:
        """检查乘积自动机是否有不等价状态"""
        return len(product.accepting_states) > 0

# 使用示例
def demonstrate_equivalence():
    """演示自动机等价性测试"""
    
    # 创建两个等价的自动机
    # 自动机1：接受偶数个0
    fa1 = FiniteAutomaton(
        states={'q0', 'q1'},
        alphabet={'0', '1'},
        transitions={
            ('q0', '0'): 'q1',
            ('q0', '1'): 'q0',
            ('q1', '0'): 'q0',
            ('q1', '1'): 'q1'
        },
        initial_state='q0',
        accepting_states={'q0'}
    )
    
    # 自动机2：最小化后的等价自动机
    fa2 = FiniteAutomaton(
        states={'p0', 'p1'},
        alphabet={'0', '1'},
        transitions={
            ('p0', '0'): 'p1',
            ('p0', '1'): 'p0',
            ('p1', '0'): 'p0',
            ('p1', '1'): 'p1'
        },
        initial_state='p0',
        accepting_states={'p0'}
    )
    
    # 测试等价性
    equivalent = AutomataEquivalence.are_equivalent(fa1, fa2)
    print(f"两个自动机是否等价: {equivalent}")
    
    # 测试一些字符串
    test_strings = ['', '0', '00', '000', '01', '001', '100', '1010']
    
    print("\n字符串接受性比较:")
    for test_str in test_strings:
        result1 = fa1.accepts(test_str)
        result2 = fa2.accepts(test_str)
        print(f"  '{test_str}': FA1={result1}, FA2={result2}")

if __name__ == "__main__":
    demonstrate_equivalence()
```

---

## 5. 正则表达式

### 5.1 正则表达式定义

**定义 5.1.1 (正则表达式)**  
正则表达式是描述正则语言的表达式，递归定义如下：

1. $\emptyset$ 是正则表达式，表示空语言
2. $\varepsilon$ 是正则表达式，表示空字符串语言
3. 对于 $a \in \Sigma$，$a$ 是正则表达式
4. 如果 $r_1$ 和 $r_2$ 是正则表达式，则：
   - $r_1 + r_2$（并）
   - $r_1 \cdot r_2$（连接）
   - $r_1^*$（克林闭包）
   也是正则表达式

### 5.2 正则表达式实现

```python
class RegularExpression:
    """正则表达式"""
    
    def __init__(self, pattern: str):
        self.pattern = pattern
        self.nfa = self._parse_to_nfa(pattern)
        self.dfa = self.nfa.to_dfa()
    
    def match(self, string: str) -> bool:
        """匹配字符串"""
        return self.dfa.accepts(string)
    
    def _parse_to_nfa(self, pattern: str) -> NondeterministicFiniteAutomaton:
        """将正则表达式解析为NFA"""
        # 这里是一个简化的实现
        # 实际的正则表达式解析需要更复杂的算法
        
        if pattern == '':
            # 空字符串
            return self._create_empty_string_nfa()
        elif pattern == 'ε':
            # 空字符串
            return self._create_empty_string_nfa()
        elif len(pattern) == 1 and pattern.isalnum():
            # 单个字符
            return self._create_single_char_nfa(pattern)
        else:
            # 复杂表达式（简化处理）
            return self._create_complex_nfa(pattern)
    
    def _create_empty_string_nfa(self) -> NondeterministicFiniteAutomaton:
        """创建空字符串NFA"""
        return NondeterministicFiniteAutomaton(
            states={'q0'},
            alphabet=set(),
            transitions={},
            initial_state='q0',
            accepting_states={'q0'}
        )
    
    def _create_single_char_nfa(self, char: str) -> NondeterministicFiniteAutomaton:
        """创建单个字符NFA"""
        return NondeterministicFiniteAutomaton(
            states={'q0', 'q1'},
            alphabet={char},
            transitions={
                ('q0', char): {'q1'}
            },
            initial_state='q0',
            accepting_states={'q1'}
        )
    
    def _create_complex_nfa(self, pattern: str) -> NondeterministicFiniteAutomaton:
        """创建复杂表达式NFA（简化实现）"""
        # 这里只是一个占位符实现
        # 实际需要实现完整的正则表达式解析
        return self._create_single_char_nfa(pattern[0])

# 使用示例
def demonstrate_regular_expression():
    """演示正则表达式"""
    
    # 测试正则表达式
    patterns = ['a', 'ab', 'a*', 'a+b']
    
    for pattern in patterns:
        try:
            regex = RegularExpression(pattern)
            print(f"正则表达式: {pattern}")
            
            # 测试一些字符串
            test_strings = ['', 'a', 'b', 'ab', 'aa', 'bb']
            for test_str in test_strings:
                result = regex.match(test_str)
                print(f"  '{test_str}' -> {result}")
            print()
        except Exception as e:
            print(f"正则表达式 {pattern} 解析失败: {e}")

if __name__ == "__main__":
    demonstrate_regular_expression()
```

---

## 6. 上下文无关文法

### 6.1 上下文无关文法定义

**定义 6.1.1 (上下文无关文法)**  
上下文无关文法是一个四元组 $G = (V, \Sigma, P, S)$，其中：

- $V$: 有限变元集（非终结符）
- $\Sigma$: 有限终结符集
- $P$: 有限产生式集
- $S \in V$: 起始符号

### 6.2 上下文无关文法实现

```python
@dataclass
class ContextFreeGrammar:
    """上下文无关文法"""
    variables: Set[str]                    # 变元集
    terminals: Set[str]                    # 终结符集
    productions: Dict[str, List[str]]     # 产生式
    start_symbol: str                      # 起始符号
    
    def __post_init__(self):
        if self.start_symbol not in self.variables:
            raise ValueError(f"起始符号 {self.start_symbol} 不在变元集中")
    
    def derive(self, steps: int = 10) -> List[str]:
        """推导过程"""
        derivations = [self.start_symbol]
        current = self.start_symbol
        
        for _ in range(steps):
            # 找到一个可以应用的产生式
            applied = False
            for i, char in enumerate(current):
                if char in self.variables:
                    # 尝试应用产生式
                    for production in self.productions.get(char, []):
                        new_string = current[:i] + production + current[i+1:]
                        derivations.append(new_string)
                        current = new_string
                        applied = True
                        break
                    if applied:
                        break
            
            if not applied:
                break
        
        return derivations
    
    def is_in_language(self, string: str) -> bool:
        """判断字符串是否在语言中"""
        # 使用CYK算法（简化实现）
        return self._cyk_parse(string)
    
    def _cyk_parse(self, string: str) -> bool:
        """CYK算法解析"""
        n = len(string)
        if n == 0:
            return self._can_derive_empty()
        
        # 初始化表格
        table = [[set() for _ in range(n)] for _ in range(n)]
        
        # 填充对角线
        for i in range(n):
            symbol = string[i]
            for variable, productions in self.productions.items():
                if symbol in productions:
                    table[i][i].add(variable)
        
        # 填充其余部分
        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                for k in range(i, j):
                    # 检查所有可能的组合
                    for variable, productions in self.productions.items():
                        for production in productions:
                            if len(production) == 2:
                                left, right = production[0], production[1]
                                if (left in table[i][k] and 
                                    right in table[k+1][j]):
                                    table[i][j].add(variable)
        
        return self.start_symbol in table[0][n-1]
    
    def _can_derive_empty(self) -> bool:
        """检查是否可以推导出空字符串"""
        # 简化实现：检查起始符号是否有空产生式
        return '' in self.productions.get(self.start_symbol, [])

# 使用示例
def demonstrate_context_free_grammar():
    """演示上下文无关文法"""
    
    # 创建文法：S -> aSb | ε
    variables = {'S'}
    terminals = {'a', 'b'}
    productions = {
        'S': ['aSb', '']
    }
    start_symbol = 'S'
    
    cfg = ContextFreeGrammar(variables, terminals, productions, start_symbol)
    
    # 推导过程
    derivations = cfg.derive(5)
    print("推导过程:")
    for i, derivation in enumerate(derivations):
        print(f"  步骤 {i}: {derivation}")
    
    # 测试字符串
    test_strings = ['', 'ab', 'aabb', 'aaabbb', 'abb', 'aab']
    
    print("\n字符串测试:")
    for test_str in test_strings:
        result = cfg.is_in_language(test_str)
        print(f"  '{test_str}' -> {result}")

if __name__ == "__main__":
    demonstrate_context_free_grammar()
```

## 理论联系

### 与形式科学的联系

自动机理论基于数学基础：

- 集合论提供状态和字母表的基础
- 逻辑学提供形式化推理
- 图论提供状态转移图的分析

### 与理论基础的联系

自动机理论为计算理论提供基础：

- 有限自动机对应正则语言
- 下推自动机对应上下文无关语言
- 图灵机对应递归可枚举语言

## 持续发展

自动机理论将根据以下方向持续发展：

1. **量子自动机**: 研究量子计算模型
2. **概率自动机**: 研究随机性在计算中的作用
3. **无限自动机**: 研究无限状态系统
4. **应用扩展**: 扩展到新的应用领域

## 参考文献

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to automata theory, languages, and computation. Pearson.
2. Sipser, M. (2012). Introduction to the theory of computation. Cengage Learning.
3. Kozen, D. C. (2006). Automata and computability. Springer.
4. Lewis, H. R., & Papadimitriou, C. H. (1998). Elements of the theory of computation. Prentice Hall.
5. Arora, S., & Barak, B. (2009). Computational complexity: a modern approach. Cambridge University Press.
