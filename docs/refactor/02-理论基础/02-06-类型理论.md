# 02-06 ç±»å‹ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç±»å‹ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ç ”ç©¶ç±»å‹ç³»ç»Ÿã€ç±»å‹æ£€æŸ¥å’Œç±»å‹æ¨å¯¼çš„é‡è¦åˆ†æ”¯ï¼Œä¸ºç¼–ç¨‹è¯­è¨€è®¾è®¡ã€ç¨‹åºéªŒè¯å’Œå½¢å¼åŒ–æ–¹æ³•æä¾›äº†ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦ç³»ç»Ÿä»‹ç»ç±»å‹ç†è®ºçš„åŸºæœ¬æ¦‚å¿µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 ç±»å‹ç³»ç»ŸåŸºç¡€

**å®šä¹‰ 1.1** (ç±»å‹)
ç±»å‹æ˜¯ä¸€ä¸ªé›†åˆï¼Œè¡¨ç¤ºç¨‹åºå€¼çš„é›†åˆï¼š
$$Type = \{T_1, T_2, ..., T_n\}$$

**å®šä¹‰ 1.2** (ç±»å‹ç¯å¢ƒ)
ç±»å‹ç¯å¢ƒæ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$\Gamma: Var \rightarrow Type$$
å…¶ä¸­ $Var$ æ˜¯å˜é‡é›†åˆã€‚

**å®šä¹‰ 1.3** (ç±»å‹åˆ¤æ–­)
ç±»å‹åˆ¤æ–­çš„å½¢å¼ä¸ºï¼š
$$\Gamma \vdash e: T$$
è¡¨ç¤ºåœ¨ç¯å¢ƒ $\Gamma$ ä¸‹ï¼Œè¡¨è¾¾å¼ $e$ å…·æœ‰ç±»å‹ $T$ã€‚

### 1.2 ç±»å‹æ¨å¯¼è§„åˆ™

**è§„åˆ™ 1.1** (å˜é‡è§„åˆ™)
$$\frac{x: T \in \Gamma}{\Gamma \vdash x: T}$$

**è§„åˆ™ 1.2** (å‡½æ•°æŠ½è±¡è§„åˆ™)
$$\frac{\Gamma, x: T_1 \vdash e: T_2}{\Gamma \vdash \lambda x: T_1. e: T_1 \rightarrow T_2}$$

**è§„åˆ™ 1.3** (å‡½æ•°åº”ç”¨è§„åˆ™)
$$\frac{\Gamma \vdash e_1: T_1 \rightarrow T_2 \quad \Gamma \vdash e_2: T_1}{\Gamma \vdash e_1(e_2): T_2}$$

**è§„åˆ™ 1.4** (æ¡ä»¶è§„åˆ™)
$$\frac{\Gamma \vdash e_1: Bool \quad \Gamma \vdash e_2: T \quad \Gamma \vdash e_3: T}{\Gamma \vdash if\ e_1\ then\ e_2\ else\ e_3: T}$$

### 1.3 å¤šæ€ç±»å‹

**å®šä¹‰ 1.4** (ç±»å‹å˜é‡)
ç±»å‹å˜é‡æ˜¯ç±»å‹ç³»ç»Ÿä¸­çš„å˜é‡ï¼Œç”¨å¸Œè…Šå­—æ¯è¡¨ç¤ºï¼š
$$\alpha, \beta, \gamma, ...$$

**å®šä¹‰ 1.5** (å¤šæ€ç±»å‹)
å¤šæ€ç±»å‹çš„å½¢å¼ä¸ºï¼š
$$\forall \alpha. T$$
è¡¨ç¤ºå¯¹äºæ‰€æœ‰ç±»å‹ $\alpha$ï¼Œ$T$ éƒ½æˆç«‹ã€‚

**è§„åˆ™ 1.5** (ç±»å‹æŠ½è±¡è§„åˆ™)
$$\frac{\Gamma \vdash e: T}{\Gamma \vdash \Lambda \alpha. e: \forall \alpha. T}$$

**è§„åˆ™ 1.6** (ç±»å‹åº”ç”¨è§„åˆ™)
$$\frac{\Gamma \vdash e: \forall \alpha. T}{\Gamma \vdash e[T']: T[\alpha \mapsto T']}$$

## 2. Pythonå®ç°

### 2.1 ç±»å‹ç³»ç»ŸåŸºç¡€

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Optional, Union, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import re

class TypeKind(Enum):
    """ç±»å‹ç§ç±»"""
    BASIC = "basic"
    FUNCTION = "function"
    POLYMORPHIC = "polymorphic"
    UNION = "union"
    INTERSECTION = "intersection"

class Type(ABC):
    """ç±»å‹æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, kind: TypeKind):
        self.name = name
        self.kind = kind
    
    @abstractmethod
    def is_subtype_of(self, other: 'Type') -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå­ç±»å‹"""
        pass
    
    @abstractmethod
    def unify_with(self, other: 'Type') -> Optional['Type']:
        """ä¸å¦ä¸€ä¸ªç±»å‹ç»Ÿä¸€"""
        pass
    
    def __str__(self) -> str:
        return self.name
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.name})"

class BasicType(Type):
    """åŸºæœ¬ç±»å‹"""
    
    def __init__(self, name: str):
        super().__init__(name, TypeKind.BASIC)
    
    def is_subtype_of(self, other: Type) -> bool:
        """åŸºæœ¬ç±»å‹çš„å­ç±»å‹å…³ç³»"""
        if isinstance(other, BasicType):
            return self.name == other.name
        return False
    
    def unify_with(self, other: Type) -> Optional[Type]:
        """åŸºæœ¬ç±»å‹ç»Ÿä¸€"""
        if isinstance(other, BasicType):
            if self.name == other.name:
                return self
        return None

class FunctionType(Type):
    """å‡½æ•°ç±»å‹"""
    
    def __init__(self, domain: Type, codomain: Type):
        super().__init__(f"{domain} -> {codomain}", TypeKind.FUNCTION)
        self.domain = domain
        self.codomain = codomain
    
    def is_subtype_of(self, other: Type) -> bool:
        """å‡½æ•°ç±»å‹çš„å­ç±»å‹å…³ç³»ï¼ˆåå˜è¿”å›ï¼Œé€†å˜å‚æ•°ï¼‰"""
        if isinstance(other, FunctionType):
            return (other.domain.is_subtype_of(self.domain) and 
                   self.codomain.is_subtype_of(other.codomain))
        return False
    
    def unify_with(self, other: Type) -> Optional[Type]:
        """å‡½æ•°ç±»å‹ç»Ÿä¸€"""
        if isinstance(other, FunctionType):
            unified_domain = self.domain.unify_with(other.domain)
            unified_codomain = self.codomain.unify_with(other.codomain)
            
            if unified_domain and unified_codomain:
                return FunctionType(unified_domain, unified_codomain)
        return None

class PolymorphicType(Type):
    """å¤šæ€ç±»å‹"""
    
    def __init__(self, type_variable: str, body: Type):
        super().__init__(f"âˆ€{type_variable}.{body}", TypeKind.POLYMORPHIC)
        self.type_variable = type_variable
        self.body = body
    
    def is_subtype_of(self, other: Type) -> bool:
        """å¤šæ€ç±»å‹çš„å­ç±»å‹å…³ç³»"""
        if isinstance(other, PolymorphicType):
            return self.body.is_subtype_of(other.body)
        return False
    
    def unify_with(self, other: Type) -> Optional[Type]:
        """å¤šæ€ç±»å‹ç»Ÿä¸€"""
        if isinstance(other, PolymorphicType):
            unified_body = self.body.unify_with(other.body)
            if unified_body:
                return PolymorphicType(self.type_variable, unified_body)
        return None
    
    def instantiate(self, concrete_type: Type) -> Type:
        """å®ä¾‹åŒ–å¤šæ€ç±»å‹"""
        return self._substitute(self.type_variable, concrete_type, self.body)
    
    def _substitute(self, var: str, replacement: Type, target: Type) -> Type:
        """ç±»å‹æ›¿æ¢"""
        if isinstance(target, BasicType):
            return target
        elif isinstance(target, FunctionType):
            new_domain = self._substitute(var, replacement, target.domain)
            new_codomain = self._substitute(var, replacement, target.codomain)
            return FunctionType(new_domain, new_codomain)
        elif isinstance(target, PolymorphicType):
            if target.type_variable == var:
                return target
            else:
                new_body = self._substitute(var, replacement, target.body)
                return PolymorphicType(target.type_variable, new_body)
        return target

class UnionType(Type):
    """è”åˆç±»å‹"""
    
    def __init__(self, types: List[Type]):
        super().__init__(f"Union[{', '.join(str(t) for t in types)}]", TypeKind.UNION)
        self.types = types
    
    def is_subtype_of(self, other: Type) -> bool:
        """è”åˆç±»å‹çš„å­ç±»å‹å…³ç³»"""
        if isinstance(other, UnionType):
            return all(t.is_subtype_of(other) for t in self.types)
        return any(t.is_subtype_of(other) for t in self.types)
    
    def unify_with(self, other: Type) -> Optional[Type]:
        """è”åˆç±»å‹ç»Ÿä¸€"""
        if isinstance(other, UnionType):
            unified_types = []
            for t1 in self.types:
                for t2 in other.types:
                    unified = t1.unify_with(t2)
                    if unified:
                        unified_types.append(unified)
            
            if unified_types:
                return UnionType(unified_types)
        return None

### 2.2 ç±»å‹ç¯å¢ƒ

class TypeEnvironment:
    """ç±»å‹ç¯å¢ƒ"""
    
    def __init__(self):
        self.bindings: Dict[str, Type] = {}
        self.parent: Optional['TypeEnvironment'] = None
    
    def bind(self, name: str, type_: Type) -> None:
        """ç»‘å®šå˜é‡åˆ°ç±»å‹"""
        self.bindings[name] = type_
    
    def lookup(self, name: str) -> Optional[Type]:
        """æŸ¥æ‰¾å˜é‡ç±»å‹"""
        if name in self.bindings:
            return self.bindings[name]
        elif self.parent:
            return self.parent.lookup(name)
        return None
    
    def extend(self, name: str, type_: Type) -> 'TypeEnvironment':
        """æ‰©å±•ç¯å¢ƒ"""
        new_env = TypeEnvironment()
        new_env.bindings = self.bindings.copy()
        new_env.parent = self
        new_env.bind(name, type_)
        return new_env
    
    def __str__(self) -> str:
        bindings_str = ", ".join(f"{k}: {v}" for k, v in self.bindings.items())
        return f"{{{bindings_str}}}"

### 2.3 ç±»å‹æ£€æŸ¥å™¨

class TypeChecker:
    """ç±»å‹æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.type_variables: Dict[str, Type] = {}
        self.next_type_var_id = 0
    
    def fresh_type_variable(self) -> str:
        """ç”Ÿæˆæ–°çš„ç±»å‹å˜é‡"""
        var_name = f"Î±_{self.next_type_var_id}"
        self.next_type_var_id += 1
        return var_name
    
    def type_check(self, expr: 'Expression', env: TypeEnvironment) -> Type:
        """ç±»å‹æ£€æŸ¥è¡¨è¾¾å¼"""
        if isinstance(expr, Variable):
            return self._check_variable(expr, env)
        elif isinstance(expr, Lambda):
            return self._check_lambda(expr, env)
        elif isinstance(expr, Application):
            return self._check_application(expr, env)
        elif isinstance(expr, If):
            return self._check_if(expr, env)
        elif isinstance(expr, Let):
            return self._check_let(expr, env)
        else:
            raise TypeError(f"Unknown expression type: {type(expr)}")
    
    def _check_variable(self, expr: 'Variable', env: TypeEnvironment) -> Type:
        """æ£€æŸ¥å˜é‡ç±»å‹"""
        type_ = env.lookup(expr.name)
        if type_ is None:
            raise TypeError(f"Undefined variable: {expr.name}")
        return type_
    
    def _check_lambda(self, expr: 'Lambda', env: TypeEnvironment) -> Type:
        """æ£€æŸ¥lambdaè¡¨è¾¾å¼ç±»å‹"""
        # æ‰©å±•ç¯å¢ƒ
        extended_env = env.extend(expr.param, expr.param_type)
        
        # æ£€æŸ¥å‡½æ•°ä½“
        body_type = self.type_check(expr.body, extended_env)
        
        # è¿”å›å‡½æ•°ç±»å‹
        return FunctionType(expr.param_type, body_type)
    
    def _check_application(self, expr: 'Application', env: TypeEnvironment) -> Type:
        """æ£€æŸ¥å‡½æ•°åº”ç”¨ç±»å‹"""
        # æ£€æŸ¥å‡½æ•°
        func_type = self.type_check(expr.func, env)
        
        # æ£€æŸ¥å‚æ•°
        arg_type = self.type_check(expr.arg, env)
        
        # æ£€æŸ¥ç±»å‹åŒ¹é…
        if isinstance(func_type, FunctionType):
            if func_type.domain.is_subtype_of(arg_type):
                return func_type.codomain
            else:
                raise TypeError(f"Type mismatch: expected {func_type.domain}, got {arg_type}")
        else:
            raise TypeError(f"Expected function type, got {func_type}")
    
    def _check_if(self, expr: 'If', env: TypeEnvironment) -> Type:
        """æ£€æŸ¥æ¡ä»¶è¡¨è¾¾å¼ç±»å‹"""
        # æ£€æŸ¥æ¡ä»¶
        cond_type = self.type_check(expr.condition, env)
        if not isinstance(cond_type, BasicType) or cond_type.name != "Bool":
            raise TypeError(f"Expected boolean type, got {cond_type}")
        
        # æ£€æŸ¥åˆ†æ”¯
        then_type = self.type_check(expr.then_branch, env)
        else_type = self.type_check(expr.else_branch, env)
        
        # ç»Ÿä¸€åˆ†æ”¯ç±»å‹
        unified_type = then_type.unify_with(else_type)
        if unified_type is None:
            raise TypeError(f"Branch type mismatch: {then_type} vs {else_type}")
        
        return unified_type
    
    def _check_let(self, expr: 'Let', env: TypeEnvironment) -> Type:
        """æ£€æŸ¥letè¡¨è¾¾å¼ç±»å‹"""
        # æ£€æŸ¥ç»‘å®šå€¼
        value_type = self.type_check(expr.value, env)
        
        # æ‰©å±•ç¯å¢ƒ
        extended_env = env.extend(expr.name, value_type)
        
        # æ£€æŸ¥ä¸»ä½“
        return self.type_check(expr.body, extended_env)

### 2.4 è¡¨è¾¾å¼ç±»

@dataclass
class Expression(ABC):
    """è¡¨è¾¾å¼æŠ½è±¡åŸºç±»"""
    pass

@dataclass
class Variable(Expression):
    """å˜é‡è¡¨è¾¾å¼"""
    name: str

@dataclass
class Lambda(Expression):
    """Lambdaè¡¨è¾¾å¼"""
    param: str
    param_type: Type
    body: Expression

@dataclass
class Application(Expression):
    """å‡½æ•°åº”ç”¨è¡¨è¾¾å¼"""
    func: Expression
    arg: Expression

@dataclass
class If(Expression):
    """æ¡ä»¶è¡¨è¾¾å¼"""
    condition: Expression
    then_branch: Expression
    else_branch: Expression

@dataclass
class Let(Expression):
    """Letè¡¨è¾¾å¼"""
    name: str
    value: Expression
    body: Expression

@dataclass
class Literal(Expression):
    """å­—é¢é‡è¡¨è¾¾å¼"""
    value: Any
    type_: Type

### 2.5 ç±»å‹æ¨å¯¼

class TypeInference:
    """ç±»å‹æ¨å¯¼"""
    
    def __init__(self):
        self.type_checker = TypeChecker()
        self.constraints: List[Tuple[Type, Type]] = []
    
    def infer_type(self, expr: Expression, env: TypeEnvironment) -> Tuple[Type, List[Tuple[Type, Type]]]:
        """æ¨å¯¼è¡¨è¾¾å¼ç±»å‹"""
        self.constraints = []
        type_ = self._infer_expression(expr, env)
        return type_, self.constraints.copy()
    
    def _infer_expression(self, expr: Expression, env: TypeEnvironment) -> Type:
        """æ¨å¯¼è¡¨è¾¾å¼ç±»å‹"""
        if isinstance(expr, Variable):
            return self._infer_variable(expr, env)
        elif isinstance(expr, Lambda):
            return self._infer_lambda(expr, env)
        elif isinstance(expr, Application):
            return self._infer_application(expr, env)
        elif isinstance(expr, If):
            return self._infer_if(expr, env)
        elif isinstance(expr, Let):
            return self._infer_let(expr, env)
        elif isinstance(expr, Literal):
            return expr.type_
        else:
            raise TypeError(f"Unknown expression type: {type(expr)}")
    
    def _infer_variable(self, expr: Variable, env: TypeEnvironment) -> Type:
        """æ¨å¯¼å˜é‡ç±»å‹"""
        type_ = env.lookup(expr.name)
        if type_ is None:
            raise TypeError(f"Undefined variable: {expr.name}")
        return type_
    
    def _infer_lambda(self, expr: Lambda, env: TypeEnvironment) -> Type:
        """æ¨å¯¼lambdaè¡¨è¾¾å¼ç±»å‹"""
        # æ‰©å±•ç¯å¢ƒ
        extended_env = env.extend(expr.param, expr.param_type)
        
        # æ¨å¯¼å‡½æ•°ä½“ç±»å‹
        body_type = self._infer_expression(expr.body, extended_env)
        
        # è¿”å›å‡½æ•°ç±»å‹
        return FunctionType(expr.param_type, body_type)
    
    def _infer_application(self, expr: Application, env: TypeEnvironment) -> Type:
        """æ¨å¯¼å‡½æ•°åº”ç”¨ç±»å‹"""
        # æ¨å¯¼å‡½æ•°ç±»å‹
        func_type = self._infer_expression(expr.func, env)
        
        # æ¨å¯¼å‚æ•°ç±»å‹
        arg_type = self._infer_expression(expr.arg, env)
        
        # ç”Ÿæˆæ–°çš„è¿”å›ç±»å‹å˜é‡
        return_type = BasicType(self.type_checker.fresh_type_variable())
        
        # æ·»åŠ çº¦æŸ
        expected_func_type = FunctionType(arg_type, return_type)
        self.constraints.append((func_type, expected_func_type))
        
        return return_type
    
    def _infer_if(self, expr: If, env: TypeEnvironment) -> Type:
        """æ¨å¯¼æ¡ä»¶è¡¨è¾¾å¼ç±»å‹"""
        # æ¨å¯¼æ¡ä»¶ç±»å‹
        cond_type = self._infer_expression(expr.condition, env)
        
        # æ·»åŠ å¸ƒå°”ç±»å‹çº¦æŸ
        bool_type = BasicType("Bool")
        self.constraints.append((cond_type, bool_type))
        
        # æ¨å¯¼åˆ†æ”¯ç±»å‹
        then_type = self._infer_expression(expr.then_branch, env)
        else_type = self._infer_expression(expr.else_branch, env)
        
        # æ·»åŠ åˆ†æ”¯ç±»å‹ç»Ÿä¸€çº¦æŸ
        self.constraints.append((then_type, else_type))
        
        return then_type
    
    def _infer_let(self, expr: Let, env: TypeEnvironment) -> Type:
        """æ¨å¯¼letè¡¨è¾¾å¼ç±»å‹"""
        # æ¨å¯¼ç»‘å®šå€¼ç±»å‹
        value_type = self._infer_expression(expr.value, env)
        
        # æ‰©å±•ç¯å¢ƒ
        extended_env = env.extend(expr.name, value_type)
        
        # æ¨å¯¼ä¸»ä½“ç±»å‹
        return self._infer_expression(expr.body, extended_env)

### 2.6 çº¦æŸæ±‚è§£

class ConstraintSolver:
    """çº¦æŸæ±‚è§£å™¨"""
    
    def __init__(self):
        self.substitution: Dict[str, Type] = {}
    
    def solve_constraints(self, constraints: List[Tuple[Type, Type]]) -> Dict[str, Type]:
        """æ±‚è§£ç±»å‹çº¦æŸ"""
        self.substitution = {}
        
        for constraint in constraints:
            self._unify(constraint[0], constraint[1])
        
        return self.substitution.copy()
    
    def _unify(self, type1: Type, type2: Type) -> None:
        """ç»Ÿä¸€ä¸¤ä¸ªç±»å‹"""
        if isinstance(type1, BasicType) and isinstance(type2, BasicType):
            if type1.name != type2.name:
                raise TypeError(f"Cannot unify {type1} and {type2}")
        elif isinstance(type1, FunctionType) and isinstance(type2, FunctionType):
            self._unify(type1.domain, type2.domain)
            self._unify(type1.codomain, type2.codomain)
        elif isinstance(type1, PolymorphicType) and isinstance(type2, PolymorphicType):
            if type1.type_variable == type2.type_variable:
                self._unify(type1.body, type2.body)
            else:
                # å¤„ç†ç±»å‹å˜é‡æ›¿æ¢
                self._substitute_type_variable(type1.type_variable, type2)
        else:
            raise TypeError(f"Cannot unify {type1} and {type2}")
    
    def _substitute_type_variable(self, var: str, replacement: Type) -> None:
        """æ›¿æ¢ç±»å‹å˜é‡"""
        if var in self.substitution:
            self._unify(self.substitution[var], replacement)
        else:
            self.substitution[var] = replacement

## 3. æ•°å­¦è¯æ˜

### 3.1 ç±»å‹å®‰å…¨å®šç†

**å®šç† 3.1** (ç±»å‹å®‰å…¨)
å¦‚æœ $\Gamma \vdash e: T$ï¼Œé‚£ä¹ˆ $e$ ä¸ä¼šäº§ç”Ÿç±»å‹é”™è¯¯ã€‚

**è¯æ˜**:
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ï¼š
1. **åŸºç¡€æƒ…å†µ**: å˜é‡ã€å­—é¢é‡ç­‰åŸºæœ¬è¡¨è¾¾å¼
2. **å½’çº³æ­¥éª¤**: å‡½æ•°åº”ç”¨ã€æ¡ä»¶è¡¨è¾¾å¼ç­‰å¤åˆè¡¨è¾¾å¼
3. **ç±»å‹æ¨å¯¼è§„åˆ™**: ç¡®ä¿æ¯ä¸ªè¡¨è¾¾å¼éƒ½æœ‰æ­£ç¡®çš„ç±»å‹

### 3.2 ä¸»ä½“å½’çº¦å®šç†

**å®šç† 3.2** (ä¸»ä½“å½’çº¦)
å¦‚æœ $\Gamma \vdash e: T$ ä¸” $e \rightarrow e'$ï¼Œé‚£ä¹ˆ $\Gamma \vdash e': T$ã€‚

**è¯æ˜**:
1. **å‡½æ•°åº”ç”¨**: $(\lambda x: T. e) v \rightarrow e[x \mapsto v]$
2. **ç±»å‹ä¿æŒ**: æ›¿æ¢åçš„è¡¨è¾¾å¼ä¿æŒåŸç±»å‹
3. **ç±»å‹æ¨å¯¼**: é€šè¿‡ç±»å‹æ¨å¯¼è§„åˆ™éªŒè¯

### 3.3 å¼ºæ­£è§„åŒ–å®šç†

**å®šç† 3.3** (å¼ºæ­£è§„åŒ–)
åœ¨ç®€å•ç±»å‹lambdaæ¼”ç®—ä¸­ï¼Œæ‰€æœ‰è‰¯ç±»å‹é¡¹éƒ½æ˜¯å¼ºæ­£è§„åŒ–çš„ã€‚

**è¯æ˜**:
1. **ç±»å‹å¤§å°**: å®šä¹‰ç±»å‹çš„å¤§å°åº¦é‡
2. **å½’çº¦å‡å°‘**: æ¯æ¬¡å½’çº¦éƒ½å‡å°‘ç±»å‹å¤§å°
3. **ç»ˆæ­¢æ€§**: ç”±äºç±»å‹å¤§å°æœ‰é™ï¼Œå½’çº¦å¿…ç„¶ç»ˆæ­¢

## 4. åº”ç”¨åœºæ™¯

### 4.1 ç¼–ç¨‹è¯­è¨€è®¾è®¡

```python
class ProgrammingLanguageDesigner:
    """ç¼–ç¨‹è¯­è¨€è®¾è®¡å™¨"""
    
    def __init__(self):
        self.type_checker = TypeChecker()
        self.type_inference = TypeInference()
        self.constraint_solver = ConstraintSolver()
    
    def design_type_system(self, language_name: str) -> Dict[str, Any]:
        """è®¾è®¡ç±»å‹ç³»ç»Ÿ"""
        # å®šä¹‰åŸºæœ¬ç±»å‹
        basic_types = {
            "Int": BasicType("Int"),
            "Bool": BasicType("Bool"),
            "String": BasicType("String"),
            "Float": BasicType("Float")
        }
        
        # å®šä¹‰ç±»å‹ç³»ç»Ÿç‰¹æ€§
        type_system_features = {
            "polymorphism": True,
            "type_inference": True,
            "subtyping": True,
            "higher_order_functions": True
        }
        
        return {
            "language_name": language_name,
            "basic_types": basic_types,
            "features": type_system_features
        }
    
    def validate_program(self, program: List[Expression]) -> bool:
        """éªŒè¯ç¨‹åºç±»å‹æ­£ç¡®æ€§"""
        env = TypeEnvironment()
        
        try:
            for expr in program:
                self.type_checker.type_check(expr, env)
            return True
        except TypeError as e:
            print(f"Type error: {e}")
            return False
    
    def infer_program_types(self, program: List[Expression]) -> List[Type]:
        """æ¨å¯¼ç¨‹åºç±»å‹"""
        env = TypeEnvironment()
        types = []
        
        for expr in program:
            type_, constraints = self.type_inference.infer_type(expr, env)
            
            # æ±‚è§£çº¦æŸ
            substitution = self.constraint_solver.solve_constraints(constraints)
            
            # åº”ç”¨æ›¿æ¢
            final_type = self._apply_substitution(type_, substitution)
            types.append(final_type)
        
        return types
    
    def _apply_substitution(self, type_: Type, substitution: Dict[str, Type]) -> Type:
        """åº”ç”¨ç±»å‹æ›¿æ¢"""
        if isinstance(type_, BasicType):
            return type_
        elif isinstance(type_, FunctionType):
            new_domain = self._apply_substitution(type_.domain, substitution)
            new_codomain = self._apply_substitution(type_.codomain, substitution)
            return FunctionType(new_domain, new_codomain)
        elif isinstance(type_, PolymorphicType):
            new_body = self._apply_substitution(type_.body, substitution)
            return PolymorphicType(type_.type_variable, new_body)
        return type_

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_language_design():
    """æ¼”ç¤ºç¼–ç¨‹è¯­è¨€è®¾è®¡"""
    designer = ProgrammingLanguageDesigner()
    
    # è®¾è®¡ç±»å‹ç³»ç»Ÿ
    type_system = designer.design_type_system("MyLanguage")
    print(f"ç±»å‹ç³»ç»Ÿè®¾è®¡: {type_system}")
    
    # åˆ›å»ºæµ‹è¯•ç¨‹åº
    env = TypeEnvironment()
    env.bind("x", BasicType("Int"))
    env.bind("y", BasicType("Bool"))
    
    # æµ‹è¯•è¡¨è¾¾å¼
    test_expressions = [
        Variable("x"),
        Literal(42, BasicType("Int")),
        Literal(True, BasicType("Bool")),
        Application(
            Lambda("z", BasicType("Int"), Variable("z")),
            Literal(10, BasicType("Int"))
        )
    ]
    
    # éªŒè¯ç¨‹åº
    is_valid = designer.validate_program(test_expressions)
    print(f"ç¨‹åºç±»å‹æ­£ç¡®æ€§: {is_valid}")
    
    # æ¨å¯¼ç±»å‹
    types = designer.infer_program_types(test_expressions)
    print("æ¨å¯¼çš„ç±»å‹:")
    for i, type_ in enumerate(types):
        print(f"  è¡¨è¾¾å¼ {i+1}: {type_}")
```

### 4.2 ç¨‹åºéªŒè¯

```python
class ProgramVerifier:
    """ç¨‹åºéªŒè¯å™¨"""
    
    def __init__(self):
        self.type_checker = TypeChecker()
        self.verification_rules = []
    
    def add_verification_rule(self, rule: callable) -> None:
        """æ·»åŠ éªŒè¯è§„åˆ™"""
        self.verification_rules.append(rule)
    
    def verify_program(self, program: List[Expression], 
                      preconditions: List[str], 
                      postconditions: List[str]) -> bool:
        """éªŒè¯ç¨‹åºæ»¡è¶³è§„èŒƒ"""
        env = TypeEnvironment()
        
        # ç±»å‹æ£€æŸ¥
        try:
            for expr in program:
                self.type_checker.type_check(expr, env)
        except TypeError as e:
            print(f"Type error: {e}")
            return False
        
        # åº”ç”¨éªŒè¯è§„åˆ™
        for rule in self.verification_rules:
            if not rule(program, preconditions, postconditions):
                return False
        
        return True
    
    def generate_verification_conditions(self, program: List[Expression],
                                       preconditions: List[str],
                                       postconditions: List[str]) -> List[str]:
        """ç”ŸæˆéªŒè¯æ¡ä»¶"""
        conditions = []
        
        # æ·»åŠ å‰ç½®æ¡ä»¶
        conditions.extend(preconditions)
        
        # ä¸ºæ¯ä¸ªè¡¨è¾¾å¼ç”ŸæˆéªŒè¯æ¡ä»¶
        for expr in program:
            if isinstance(expr, If):
                conditions.append(f"condition({expr.condition}) -> {expr.then_branch}")
                conditions.append(f"!condition({expr.condition}) -> {expr.else_branch}")
            elif isinstance(expr, Application):
                conditions.append(f"function_type({expr.func}) -> valid_application")
        
        # æ·»åŠ åç½®æ¡ä»¶
        conditions.extend(postconditions)
        
        return conditions

# éªŒè¯è§„åˆ™ç¤ºä¾‹
def type_safety_rule(program: List[Expression], 
                    preconditions: List[str], 
                    postconditions: List[str]) -> bool:
    """ç±»å‹å®‰å…¨éªŒè¯è§„åˆ™"""
    # æ£€æŸ¥æ‰€æœ‰è¡¨è¾¾å¼éƒ½æœ‰ç±»å‹
    for expr in program:
        if not hasattr(expr, 'type_'):
            return False
    return True

def termination_rule(program: List[Expression], 
                   preconditions: List[str], 
                   postconditions: List[str]) -> bool:
    """ç»ˆæ­¢æ€§éªŒè¯è§„åˆ™"""
    # æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ— é™å¾ªç¯
    # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥é€’å½’è°ƒç”¨
    return True

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_program_verification():
    """æ¼”ç¤ºç¨‹åºéªŒè¯"""
    verifier = ProgramVerifier()
    
    # æ·»åŠ éªŒè¯è§„åˆ™
    verifier.add_verification_rule(type_safety_rule)
    verifier.add_verification_rule(termination_rule)
    
    # æµ‹è¯•ç¨‹åº
    test_program = [
        Literal(42, BasicType("Int")),
        Literal(True, BasicType("Bool"))
    ]
    
    # å‰ç½®å’Œåç½®æ¡ä»¶
    preconditions = ["input_valid"]
    postconditions = ["output_correct"]
    
    # éªŒè¯ç¨‹åº
    is_valid = verifier.verify_program(test_program, preconditions, postconditions)
    print(f"ç¨‹åºéªŒè¯ç»“æœ: {is_valid}")
    
    # ç”ŸæˆéªŒè¯æ¡ä»¶
    conditions = verifier.generate_verification_conditions(
        test_program, preconditions, postconditions
    )
    print("éªŒè¯æ¡ä»¶:")
    for condition in conditions:
        print(f"  {condition}")
```

## 5. æ€»ç»“

ç±»å‹ç†è®ºä¸ºè®¡ç®—æœºç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ï¼š

1. **ç±»å‹å®‰å…¨**: é€šè¿‡ç±»å‹æ£€æŸ¥ç¡®ä¿ç¨‹åºæ­£ç¡®æ€§
2. **ç±»å‹æ¨å¯¼**: è‡ªåŠ¨æ¨å¯¼è¡¨è¾¾å¼ç±»å‹ï¼Œå‡å°‘ç±»å‹æ³¨è§£
3. **å¤šæ€æ€§**: æ”¯æŒå‚æ•°åŒ–ç±»å‹å’Œç±»å‹æŠ½è±¡
4. **ç¨‹åºéªŒè¯**: ä¸ºå½¢å¼åŒ–ç¨‹åºéªŒè¯æä¾›åŸºç¡€

ç±»å‹ç†è®ºçš„ç ”ç©¶å°†ç»§ç»­æ¨åŠ¨ç¼–ç¨‹è¯­è¨€è®¾è®¡ã€ç¨‹åºéªŒè¯å’Œè½¯ä»¶å·¥ç¨‹çš„å‘å±•ã€‚

---

**ç›¸å…³é“¾æ¥**:

- [02-01 ç®—æ³•ç†è®º](./02-01-ç®—æ³•ç†è®º.md)
- [02-02 æ•°æ®ç»“æ„ç†è®º](./02-02-æ•°æ®ç»“æ„ç†è®º.md)
- [02-05 ç¼–ç¨‹è¯­è¨€ç†è®º](./02-05-ç¼–ç¨‹è¯­è¨€ç†è®º.md)
- [03-01 è½¯ä»¶å·¥ç¨‹æ–¹æ³•è®º](../03-å…·ä½“ç§‘å­¦/03-01-è½¯ä»¶å·¥ç¨‹æ–¹æ³•è®º.md)
