# 02-08 åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º

## ğŸ“‹ æ¦‚è¿°

åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒç†è®ºä¹‹ä¸€ï¼Œç ”ç©¶ç”±å¤šä¸ªç‹¬ç«‹è®¡ç®—æœºç»„æˆçš„ç³»ç»Ÿå¦‚ä½•é€šè¿‡ç½‘ç»œè¿›è¡Œé€šä¿¡å’Œåè°ƒã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µï¼Œæä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜ï¼Œå¹¶é€šè¿‡Pythonä»£ç å®ç°ç›¸å…³åˆ†å¸ƒå¼ç®—æ³•ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (åˆ†å¸ƒå¼ç³»ç»Ÿ)
åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$DS = (N, C, S, P, F)$$
å…¶ä¸­ï¼š

- $N = \{n_1, n_2, \ldots, n_k\}$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $C = (N, E)$ æ˜¯é€šä¿¡ç½‘ç»œï¼Œ$E \subseteq N \times N$ æ˜¯é€šä¿¡é“¾è·¯é›†åˆ
- $S = \{s_1, s_2, \ldots, s_m\}$ æ˜¯çŠ¶æ€é›†åˆ
- $P = \{p_1, p_2, \ldots, p_l\}$ æ˜¯åè®®é›†åˆ
- $F: N \rightarrow \{0, 1\}$ æ˜¯æ•…éšœå‡½æ•°ï¼Œ$F(n_i) = 1$ è¡¨ç¤ºèŠ‚ç‚¹ $n_i$ æ•…éšœ

**å®šä¹‰ 1.2** (èŠ‚ç‚¹)
èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$n = (id, state, neighbors, protocol)$$
å…¶ä¸­ï¼š

- $id$ æ˜¯èŠ‚ç‚¹å”¯ä¸€æ ‡è¯†ç¬¦
- $state \in S$ æ˜¯èŠ‚ç‚¹å½“å‰çŠ¶æ€
- $neighbors \subseteq N$ æ˜¯é‚»å±…èŠ‚ç‚¹é›†åˆ
- $protocol \in P$ æ˜¯èŠ‚ç‚¹æ‰§è¡Œçš„åè®®

**å®šä¹‰ 1.3** (æ¶ˆæ¯)
æ¶ˆæ¯æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$m = (from, to, type, data, timestamp)$$
å…¶ä¸­ï¼š

- $from, to \in N$ æ˜¯å‘é€å’Œæ¥æ”¶èŠ‚ç‚¹
- $type$ æ˜¯æ¶ˆæ¯ç±»å‹
- $data$ æ˜¯æ¶ˆæ¯æ•°æ®
- $timestamp$ æ˜¯æ—¶é—´æˆ³

#### 1.2 åˆ†å¸ƒå¼ç³»ç»Ÿå±æ€§

**å®šä¹‰ 1.4** (è¿é€šæ€§)
åˆ†å¸ƒå¼ç³»ç»Ÿ $DS$ æ˜¯è¿é€šçš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall n_i, n_j \in N: \exists \text{path}(n_i, n_j)$$

**å®šä¹‰ 1.5** (å®¹é”™æ€§)
åˆ†å¸ƒå¼ç³»ç»Ÿ $DS$ æ˜¯ $f$-å®¹é”™çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$|\{n \in N: F(n) = 1\}| \leq f \Rightarrow DS \text{ ä»èƒ½æ­£å¸¸å·¥ä½œ}$$

**å®šç† 1.1** (è¿é€šæ€§ä¿æŒ)
å¦‚æœåˆ†å¸ƒå¼ç³»ç»Ÿ $DS$ æ˜¯è¿é€šçš„ï¼Œä¸”æ•…éšœèŠ‚ç‚¹æ•°ä¸è¶…è¿‡ $f$ï¼Œåˆ™å‰©ä½™èŠ‚ç‚¹æ„æˆçš„å­å›¾ä»ç„¶æ˜¯è¿é€šçš„ã€‚

**è¯æ˜**ï¼š

1. è®¾ $DS = (N, C, S, P, F)$ æ˜¯è¿é€šåˆ†å¸ƒå¼ç³»ç»Ÿ
2. è®¾æ•…éšœèŠ‚ç‚¹é›†åˆä¸º $F = \{n_{f1}, n_{f2}, \ldots, n_{ff}\}$
3. å‰©ä½™èŠ‚ç‚¹é›†åˆä¸º $N' = N \setminus F$
4. å¯¹äºä»»æ„ $n_i, n_j \in N'$ï¼Œç”±äºåŸç³»ç»Ÿè¿é€šï¼Œå­˜åœ¨è·¯å¾„ $path(n_i, n_j)$
5. å¦‚æœè·¯å¾„ä¸­ä¸åŒ…å«æ•…éšœèŠ‚ç‚¹ï¼Œåˆ™è·¯å¾„ä»ç„¶æœ‰æ•ˆ
6. å¦‚æœè·¯å¾„åŒ…å«æ•…éšœèŠ‚ç‚¹ï¼Œç”±äº $|F| \leq f$ï¼Œå¯ä»¥é€šè¿‡å…¶ä»–è·¯å¾„ç»•è¿‡æ•…éšœèŠ‚ç‚¹
7. å› æ­¤ $N'$ ä¸­çš„ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´éƒ½å­˜åœ¨è·¯å¾„

### 2. ä¸€è‡´æ€§ç†è®º

#### 2.1 ä¸€è‡´æ€§æ¨¡å‹

**å®šä¹‰ 2.1** (ä¸€è‡´æ€§)
åˆ†å¸ƒå¼ç³»ç»Ÿè¾¾åˆ°ä¸€è‡´æ€§ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall n_i, n_j \in N: \text{State}(n_i) = \text{State}(n_j)$$

**å®šä¹‰ 2.2** (çº¿æ€§ä¸€è‡´æ€§)
æ“ä½œåºåˆ—æ»¡è¶³çº¿æ€§ä¸€è‡´æ€§ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\exists \text{total order} \prec: \forall \text{op}_1, \text{op}_2: \text{op}_1 \prec \text{op}_2 \Rightarrow \text{result}(\text{op}_1) \text{ åœ¨ } \text{op}_2 \text{ ä¹‹å‰å¯è§}$$

**å®šä¹‰ 2.3** (å› æœä¸€è‡´æ€§)
æ“ä½œåºåˆ—æ»¡è¶³å› æœä¸€è‡´æ€§ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\text{op}_1 \rightarrow \text{op}_2 \Rightarrow \text{op}_1 \prec \text{op}_2$$
å…¶ä¸­ $\rightarrow$ è¡¨ç¤ºå› æœä¾èµ–å…³ç³»ã€‚

#### 2.2 CAPå®šç†

**å®šç† 2.1** (CAPå®šç†)
åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œä¸å¯èƒ½åŒæ—¶æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªå±æ€§ï¼š

- ä¸€è‡´æ€§ (Consistency)
- å¯ç”¨æ€§ (Availability)  
- åˆ†åŒºå®¹é”™æ€§ (Partition tolerance)

**è¯æ˜**ï¼š

1. å‡è®¾å­˜åœ¨ä¸€ä¸ªç³»ç»ŸåŒæ—¶æ»¡è¶³CAPä¸‰ä¸ªå±æ€§
2. å½“ç½‘ç»œåˆ†åŒºå‘ç”Ÿæ—¶ï¼Œç³»ç»Ÿè¢«åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ† $P_1$ å’Œ $P_2$
3. ä¸ºäº†ä¿è¯å¯ç”¨æ€§ï¼Œ$P_1$ å’Œ $P_2$ éƒ½å¿…é¡»å“åº”è¯·æ±‚
4. ä¸ºäº†ä¿è¯ä¸€è‡´æ€§ï¼Œ$P_1$ å’Œ $P_2$ å¿…é¡»çœ‹åˆ°ç›¸åŒçš„æ•°æ®
5. ç”±äºç½‘ç»œåˆ†åŒºï¼Œ$P_1$ å’Œ $P_2$ æ— æ³•é€šä¿¡
6. è¿™å¯¼è‡´çŸ›ç›¾ï¼šæ—¢è¦æ±‚å“åº”ï¼ˆå¯ç”¨æ€§ï¼‰ï¼Œåˆè¦æ±‚æ•°æ®ä¸€è‡´ï¼ˆä¸€è‡´æ€§ï¼‰
7. å› æ­¤CAPä¸‰ä¸ªå±æ€§ä¸èƒ½åŒæ—¶æ»¡è¶³

**æ¨è®º 2.1** (PACELCæ‰©å±•)
åœ¨åˆ†åŒºå­˜åœ¨æ—¶é€‰æ‹©å¯ç”¨æ€§è¿˜æ˜¯ä¸€è‡´æ€§ï¼Œåœ¨åˆ†åŒºä¸å­˜åœ¨æ—¶é€‰æ‹©å»¶è¿Ÿè¿˜æ˜¯ä¸€è‡´æ€§ã€‚

### 3. å…±è¯†ç®—æ³•

#### 3.1 Paxosç®—æ³•

**å®šä¹‰ 3.1** (Paxosç®—æ³•)
Paxosç®—æ³•æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

- **å®‰å…¨æ€§**: å¦‚æœå€¼ $v$ è¢«é€‰æ‹©ï¼Œåˆ™æ‰€æœ‰èŠ‚ç‚¹æœ€ç»ˆå­¦ä¹ åˆ° $v$
- **æ´»æ€§**: å¦‚æœæè®®è€…æè®®å€¼ï¼Œåˆ™æœ€ç»ˆä¼šé€‰æ‹©ä¸€ä¸ªå€¼

**ç®—æ³• 3.1** (Paxosç®—æ³•)

```text
Phase 1a: æè®®è€…é€‰æ‹©ææ¡ˆç¼–å· nï¼Œå‘æ¥å—è€…å‘é€ Prepare(n)
Phase 1b: æ¥å—è€…å›å¤ Promise(n, v, n_v)ï¼Œå…¶ä¸­ v æ˜¯å·²æ¥å—çš„å€¼ï¼Œn_v æ˜¯ææ¡ˆç¼–å·
Phase 2a: æè®®è€…å‘é€ Accept(n, v)ï¼Œå…¶ä¸­ v æ˜¯æœ€é«˜ç¼–å·çš„å·²æ¥å—å€¼æˆ–æ–°å€¼
Phase 2b: æ¥å—è€…æ¥å— Accept(n, v)
```

**å®šç† 3.1** (Paxoså®‰å…¨æ€§)
Paxosç®—æ³•ä¿è¯å®‰å…¨æ€§ï¼šå¦‚æœå€¼ $v$ è¢«é€‰æ‹©ï¼Œåˆ™æ‰€æœ‰èŠ‚ç‚¹æœ€ç»ˆå­¦ä¹ åˆ° $v$ã€‚

**è¯æ˜**ï¼š

1. è®¾å€¼ $v$ è¢«é€‰æ‹©ï¼Œææ¡ˆç¼–å·ä¸º $n$
2. æ ¹æ®ç®—æ³•ï¼Œè‡³å°‘ $f+1$ ä¸ªæ¥å—è€…æ¥å—äº† $(n, v)$
3. å¯¹äºä»»ä½•åç»­ææ¡ˆ $n' > n$ï¼Œæè®®è€…å¿…é¡»é€‰æ‹© $v$
4. å› ä¸ºæ¥å—è€…æ‰¿è¯ºä¸æ¥å—ç¼–å·å°äº $n$ çš„ææ¡ˆ
5. å› æ­¤æ‰€æœ‰åç»­ææ¡ˆéƒ½ä¼šé€‰æ‹© $v$
6. æœ€ç»ˆæ‰€æœ‰èŠ‚ç‚¹éƒ½ä¼šå­¦ä¹ åˆ° $v$

#### 3.2 Raftç®—æ³•

**å®šä¹‰ 3.2** (Raftç®—æ³•)
Raftç®—æ³•å°†æ—¶é—´åˆ’åˆ†ä¸ºä»»æœŸï¼Œæ¯ä¸ªä»»æœŸæœ€å¤šæœ‰ä¸€ä¸ªé¢†å¯¼è€…ã€‚

**ç®—æ³• 3.2** (Rafté¢†å¯¼è€…é€‰ä¸¾)

```text
1. èŠ‚ç‚¹å¯åŠ¨æ—¶æˆä¸ºè·Ÿéšè€…
2. å¦‚æœè¶…æ—¶æœªæ”¶åˆ°é¢†å¯¼è€…æ¶ˆæ¯ï¼Œæˆä¸ºå€™é€‰äºº
3. å€™é€‰äººå‘é€ RequestVote ç»™å…¶ä»–èŠ‚ç‚¹
4. å¦‚æœè·å¾—å¤šæ•°ç¥¨ï¼Œæˆä¸ºé¢†å¯¼è€…
5. é¢†å¯¼è€…å®šæœŸå‘é€å¿ƒè·³æ¶ˆæ¯
```

**å®šç† 3.2** (Raftå®‰å…¨æ€§)
Raftç®—æ³•ä¿è¯å®‰å…¨æ€§ï¼šæ¯ä¸ªä»»æœŸæœ€å¤šæœ‰ä¸€ä¸ªé¢†å¯¼è€…ã€‚

**è¯æ˜**ï¼š

1. è®¾ä»»æœŸ $T$ æœ‰ä¸¤ä¸ªé¢†å¯¼è€… $L_1$ å’Œ $L_2$
2. æ ¹æ®ç®—æ³•ï¼Œé¢†å¯¼è€…å¿…é¡»è·å¾—å¤šæ•°ç¥¨
3. è®¾ $S_1$ å’Œ $S_2$ åˆ†åˆ«æ˜¯æŠ•ç¥¨ç»™ $L_1$ å’Œ $L_2$ çš„èŠ‚ç‚¹é›†åˆ
4. ç”±äº $|S_1| > n/2$ ä¸” $|S_2| > n/2$ï¼Œ$S_1 \cap S_2 \neq \emptyset$
5. è®¾ $n \in S_1 \cap S_2$ï¼Œåˆ™ $n$ æŠ•ç¥¨ç»™äº†ä¸¤ä¸ªå€™é€‰äºº
6. è¿™ä¸Raftçš„æŠ•ç¥¨è§„åˆ™çŸ›ç›¾
7. å› æ­¤æ¯ä¸ªä»»æœŸæœ€å¤šæœ‰ä¸€ä¸ªé¢†å¯¼è€…

### 4. æ•…éšœæ£€æµ‹

#### 4.1 æ•…éšœæ£€æµ‹å™¨

**å®šä¹‰ 4.1** (æ•…éšœæ£€æµ‹å™¨)
æ•…éšœæ£€æµ‹å™¨æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$FD: N \times \mathbb{R} \rightarrow \{0, 1\}$$
å…¶ä¸­ $FD(n, t) = 1$ è¡¨ç¤ºåœ¨æ—¶é—´ $t$ æ£€æµ‹åˆ°èŠ‚ç‚¹ $n$ æ•…éšœã€‚

**å®šä¹‰ 4.2** (å®Œç¾æ•…éšœæ£€æµ‹å™¨)
å®Œç¾æ•…éšœæ£€æµ‹å™¨æ»¡è¶³ï¼š

- **å®Œæ•´æ€§**: æ•…éšœèŠ‚ç‚¹æœ€ç»ˆè¢«æ‰€æœ‰æ­£ç¡®èŠ‚ç‚¹æ£€æµ‹åˆ°
- **å‡†ç¡®æ€§**: æ­£ç¡®èŠ‚ç‚¹æ°¸è¿œä¸ä¼šè¢«æ£€æµ‹ä¸ºæ•…éšœ

**å®šç† 4.1** (æ•…éšœæ£€æµ‹å™¨ä¸å¯èƒ½æ€§)
åœ¨å¼‚æ­¥ç³»ç»Ÿä¸­ï¼Œä¸å­˜åœ¨å®Œç¾çš„æ•…éšœæ£€æµ‹å™¨ã€‚

**è¯æ˜**ï¼š

1. å‡è®¾å­˜åœ¨å®Œç¾æ•…éšœæ£€æµ‹å™¨ $FD$
2. è€ƒè™‘èŠ‚ç‚¹ $n$ å’Œ $m$ ä¹‹é—´çš„é€šä¿¡
3. å¦‚æœ $n$ å‘é€æ¶ˆæ¯ç»™ $m$ï¼Œä½†æ¶ˆæ¯å»¶è¿Ÿ
4. $FD$ å¯èƒ½é”™è¯¯åœ°æ£€æµ‹åˆ° $m$ æ•…éšœ
5. è¿™ä¸å‡†ç¡®æ€§çŸ›ç›¾
6. å› æ­¤ä¸å­˜åœ¨å®Œç¾çš„æ•…éšœæ£€æµ‹å™¨

#### 4.2 å¿ƒè·³æœºåˆ¶

**ç®—æ³• 4.1** (å¿ƒè·³æ•…éšœæ£€æµ‹)

```text
1. æ¯ä¸ªèŠ‚ç‚¹å®šæœŸå‘é€å¿ƒè·³æ¶ˆæ¯
2. å¦‚æœè¶…æ—¶æœªæ”¶åˆ°å¿ƒè·³ï¼Œæ ‡è®°èŠ‚ç‚¹ä¸ºå¯ç–‘
3. å¦‚æœè¿ç»­å¤šæ¬¡æœªæ”¶åˆ°å¿ƒè·³ï¼Œæ ‡è®°èŠ‚ç‚¹ä¸ºæ•…éšœ
4. ä½¿ç”¨æŒ‡æ•°é€€é¿ç­–ç•¥è°ƒæ•´è¶…æ—¶æ—¶é—´
```

### 5. åˆ†å¸ƒå¼å“ˆå¸Œè¡¨

#### 5.1 DHTå®šä¹‰

**å®šä¹‰ 5.1** (åˆ†å¸ƒå¼å“ˆå¸Œè¡¨)
åˆ†å¸ƒå¼å“ˆå¸Œè¡¨æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$DHT = (K, V, N)$$
å…¶ä¸­ï¼š

- $K$ æ˜¯é”®ç©ºé—´
- $V$ æ˜¯å€¼ç©ºé—´  
- $N$ æ˜¯èŠ‚ç‚¹é›†åˆ

**å®šä¹‰ 5.2** (ä¸€è‡´æ€§å“ˆå¸Œ)
ä¸€è‡´æ€§å“ˆå¸Œæ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$h: K \rightarrow N$$
æ»¡è¶³ï¼š

- **å¹³è¡¡æ€§**: é”®å‡åŒ€åˆ†å¸ƒåˆ°èŠ‚ç‚¹
- **å•è°ƒæ€§**: èŠ‚ç‚¹åŠ å…¥/ç¦»å¼€æ—¶ï¼Œåªæœ‰å°‘é‡é”®éœ€è¦é‡æ–°åˆ†é…

#### 5.2 Chordç®—æ³•

**ç®—æ³• 5.1** (ChordæŸ¥æ‰¾)

```text
1. èŠ‚ç‚¹æŒ‰IDæ’åºå½¢æˆç¯å½¢ç»“æ„
2. æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤æŒ‡å‘åç»§èŠ‚ç‚¹çš„æŒ‡é’ˆ
3. æŸ¥æ‰¾æ—¶æ²¿ç¯é¡ºæ—¶é’ˆæŸ¥æ‰¾
4. ä½¿ç”¨è·³è¡¨ä¼˜åŒ–æŸ¥æ‰¾å¤æ‚åº¦
```

**å®šç† 5.1** (ChordæŸ¥æ‰¾å¤æ‚åº¦)
Chordç®—æ³•çš„æŸ¥æ‰¾å¤æ‚åº¦ä¸º $O(\log n)$ã€‚

**è¯æ˜**ï¼š

1. Chordä½¿ç”¨è·³è¡¨ç»“æ„ï¼Œæ¯å±‚èŠ‚ç‚¹æ•°å‡åŠ
2. è®¾æ€»èŠ‚ç‚¹æ•°ä¸º $n$ï¼Œè·³è¡¨å±‚æ•°ä¸º $\log n$
3. æ¯å±‚æœ€å¤šéœ€è¦ $\log n$ æ­¥æŸ¥æ‰¾
4. å› æ­¤æ€»æŸ¥æ‰¾å¤æ‚åº¦ä¸º $O(\log n)$

## ğŸ”§ Pythonå®ç°

### 2.1 åˆ†å¸ƒå¼èŠ‚ç‚¹æŠ½è±¡

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any, Callable
from enum import Enum
import asyncio
import time
import uuid
from collections import defaultdict
import networkx as nx
import json

class NodeState(Enum):
    """èŠ‚ç‚¹çŠ¶æ€æšä¸¾"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    FAILED = "failed"
    RECOVERING = "recovering"

class MessageType(Enum):
    """æ¶ˆæ¯ç±»å‹æšä¸¾"""
    HEARTBEAT = "heartbeat"
    DATA = "data"
    CONTROL = "control"
    ELECTION = "election"
    CONSENSUS = "consensus"

@dataclass
class Message:
    """æ¶ˆæ¯ç±»"""
    id: str
    from_node: str
    to_node: str
    type: MessageType
    data: Any
    timestamp: float = field(default_factory=time.time)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Node:
    """åˆ†å¸ƒå¼èŠ‚ç‚¹"""
    id: str
    address: str
    state: NodeState = NodeState.ACTIVE
    neighbors: Set[str] = field(default_factory=set)
    data: Dict[str, Any] = field(default_factory=dict)
    last_heartbeat: float = field(default_factory=time.time)
    
    def __str__(self) -> str:
        return f"Node({self.id}: {self.state.value})"

class DistributedSystem:
    """åˆ†å¸ƒå¼ç³»ç»Ÿ"""
    
    def __init__(self):
        self.nodes: Dict[str, Node] = {}
        self.network: nx.Graph = nx.Graph()
        self.messages: List[Message] = []
        self.fault_detector = None
        self.consensus_algorithm = None
        
    def add_node(self, node: Node) -> None:
        """æ·»åŠ èŠ‚ç‚¹"""
        self.nodes[node.id] = node
        self.network.add_node(node.id)
        
    def remove_node(self, node_id: str) -> None:
        """ç§»é™¤èŠ‚ç‚¹"""
        if node_id in self.nodes:
            del self.nodes[node_id]
            self.network.remove_node(node_id)
            
    def add_edge(self, node1_id: str, node2_id: str) -> None:
        """æ·»åŠ é€šä¿¡é“¾è·¯"""
        if node1_id in self.nodes and node2_id in self.nodes:
            self.network.add_edge(node1_id, node2_id)
            self.nodes[node1_id].neighbors.add(node2_id)
            self.nodes[node2_id].neighbors.add(node1_id)
            
    def is_connected(self) -> bool:
        """æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦è¿é€š"""
        return nx.is_connected(self.network)
    
    def get_shortest_path(self, source: str, target: str) -> Optional[List[str]]:
        """è·å–æœ€çŸ­è·¯å¾„"""
        try:
            return nx.shortest_path(self.network, source, target)
        except nx.NetworkXNoPath:
            return None
    
    def send_message(self, message: Message) -> bool:
        """å‘é€æ¶ˆæ¯"""
        if (message.from_node in self.nodes and 
            message.to_node in self.nodes):
            self.messages.append(message)
            return True
        return False
    
    def get_system_state(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        return {
            "total_nodes": len(self.nodes),
            "active_nodes": len([n for n in self.nodes.values() 
                               if n.state == NodeState.ACTIVE]),
            "connected": self.is_connected(),
            "network_diameter": nx.diameter(self.network) if self.is_connected() else float('inf')
        }
```

### 2.2 æ•…éšœæ£€æµ‹å™¨

```python
class FaultDetector:
    """æ•…éšœæ£€æµ‹å™¨"""
    
    def __init__(self, system: DistributedSystem, timeout: float = 5.0):
        self.system = system
        self.timeout = timeout
        self.suspected_nodes: Set[str] = set()
        self.failed_nodes: Set[str] = set()
        
    def check_node_health(self, node_id: str) -> bool:
        """æ£€æŸ¥èŠ‚ç‚¹å¥åº·çŠ¶æ€"""
        if node_id not in self.system.nodes:
            return False
            
        node = self.system.nodes[node_id]
        current_time = time.time()
        
        # æ£€æŸ¥å¿ƒè·³è¶…æ—¶
        if current_time - node.last_heartbeat > self.timeout:
            if node_id not in self.suspected_nodes:
                self.suspected_nodes.add(node_id)
            elif node_id in self.suspected_nodes:
                self.failed_nodes.add(node_id)
                node.state = NodeState.FAILED
            return False
        else:
            if node_id in self.suspected_nodes:
                self.suspected_nodes.remove(node_id)
            return True
    
    def get_failed_nodes(self) -> Set[str]:
        """è·å–æ•…éšœèŠ‚ç‚¹é›†åˆ"""
        return self.failed_nodes.copy()
    
    def get_suspected_nodes(self) -> Set[str]:
        """è·å–å¯ç–‘èŠ‚ç‚¹é›†åˆ"""
        return self.suspected_nodes.copy()
    
    def is_node_failed(self, node_id: str) -> bool:
        """æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æ•…éšœ"""
        return node_id in self.failed_nodes

class HeartbeatManager:
    """å¿ƒè·³ç®¡ç†å™¨"""
    
    def __init__(self, system: DistributedSystem, interval: float = 1.0):
        self.system = system
        self.interval = interval
        self.fault_detector = FaultDetector(system)
        
    async def start_heartbeat(self, node_id: str):
        """å¼€å§‹å¿ƒè·³"""
        while True:
            if node_id in self.system.nodes:
                # å‘é€å¿ƒè·³æ¶ˆæ¯
                heartbeat_msg = Message(
                    id="",
                    from_node=node_id,
                    to_node="broadcast",
                    type=MessageType.HEARTBEAT,
                    data={"timestamp": time.time()}
                )
                self.system.send_message(heartbeat_msg)
                
                # æ›´æ–°æœ€åå¿ƒè·³æ—¶é—´
                self.system.nodes[node_id].last_heartbeat = time.time()
                
            await asyncio.sleep(self.interval)
    
    async def monitor_heartbeats(self):
        """ç›‘æ§å¿ƒè·³"""
        while True:
            for node_id in self.system.nodes:
                self.fault_detector.check_node_health(node_id)
            await asyncio.sleep(0.5)
```

### 2.3 ä¸€è‡´æ€§ç®—æ³•

```python
class ConsensusAlgorithm(ABC):
    """ä¸€è‡´æ€§ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, system: DistributedSystem):
        self.system = system
        self.proposed_values: Dict[str, Any] = {}
        self.decided_values: Dict[str, Any] = {}
        
    @abstractmethod
    async def propose(self, value: Any) -> bool:
        """æè®®å€¼"""
        pass
    
    @abstractmethod
    async def decide(self, value: Any) -> bool:
        """å†³å®šå€¼"""
        pass

class PaxosAlgorithm(ConsensusAlgorithm):
    """Paxosç®—æ³•å®ç°"""
    
    def __init__(self, system: DistributedSystem):
        super().__init__(system)
        self.proposal_number = 0
        self.accepted_proposals: Dict[str, Dict] = {}
        self.promises: Dict[str, List] = {}
        
    async def propose(self, value: Any) -> bool:
        """Paxosæè®®é˜¶æ®µ"""
        self.proposal_number += 1
        proposal_id = f"proposal_{self.proposal_number}"
        
        # Phase 1a: å‘é€Prepareæ¶ˆæ¯
        prepare_msg = Message(
            id="",
            from_node="proposer",
            to_node="broadcast",
            type=MessageType.CONSENSUS,
            data={
                "phase": "prepare",
                "proposal_id": proposal_id,
                "proposal_number": self.proposal_number
            }
        )
        self.system.send_message(prepare_msg)
        
        # ç­‰å¾…Promiseå“åº”
        await asyncio.sleep(0.1)
        
        # æ£€æŸ¥æ˜¯å¦è·å¾—å¤šæ•°Promise
        if len(self.promises.get(proposal_id, [])) > len(self.system.nodes) // 2:
            # Phase 2a: å‘é€Acceptæ¶ˆæ¯
            accept_msg = Message(
                id="",
                from_node="proposer",
                to_node="broadcast",
                type=MessageType.CONSENSUS,
                data={
                    "phase": "accept",
                    "proposal_id": proposal_id,
                    "proposal_number": self.proposal_number,
                    "value": value
                }
            )
            self.system.send_message(accept_msg)
            return True
        
        return False
    
    async def decide(self, value: Any) -> bool:
        """Paxoså†³å®šé˜¶æ®µ"""
        # æ£€æŸ¥æ˜¯å¦è·å¾—å¤šæ•°Accept
        proposal_id = f"proposal_{self.proposal_number}"
        accepted_count = len(self.accepted_proposals.get(proposal_id, {}))
        
        if accepted_count > len(self.system.nodes) // 2:
            self.decided_values[proposal_id] = value
            return True
        
        return False

class RaftAlgorithm(ConsensusAlgorithm):
    """Raftç®—æ³•å®ç°"""
    
    def __init__(self, system: DistributedSystem):
        super().__init__(system)
        self.current_term = 0
        self.voted_for: Optional[str] = None
        self.leader_id: Optional[str] = None
        self.state = "follower"  # follower, candidate, leader
        self.election_timeout = 5.0
        self.last_election_time = time.time()
        
    async def start_election(self, node_id: str):
        """å¼€å§‹é¢†å¯¼è€…é€‰ä¸¾"""
        self.state = "candidate"
        self.current_term += 1
        self.voted_for = node_id
        self.last_election_time = time.time()
        
        # å‘é€RequestVoteæ¶ˆæ¯
        vote_request = Message(
            id="",
            from_node=node_id,
            to_node="broadcast",
            type=MessageType.ELECTION,
            data={
                "term": self.current_term,
                "candidate_id": node_id
            }
        )
        self.system.send_message(vote_request)
        
        # ç­‰å¾…æŠ•ç¥¨ç»“æœ
        await asyncio.sleep(0.1)
        
        # æ£€æŸ¥æ˜¯å¦è·å¾—å¤šæ•°ç¥¨
        votes_received = 1  # è‡ªå·±çš„ä¸€ç¥¨
        if votes_received > len(self.system.nodes) // 2:
            self.state = "leader"
            self.leader_id = node_id
            await self.start_heartbeat()
    
    async def start_heartbeat(self):
        """é¢†å¯¼è€…å¿ƒè·³"""
        while self.state == "leader":
            heartbeat = Message(
                id="",
                from_node=self.leader_id,
                to_node="broadcast",
                type=MessageType.HEARTBEAT,
                data={
                    "term": self.current_term,
                    "leader_id": self.leader_id
                }
            )
            self.system.send_message(heartbeat)
            await asyncio.sleep(1.0)
    
    async def propose(self, value: Any) -> bool:
        """Raftæè®®"""
        if self.state != "leader":
            return False
        
        # é¢†å¯¼è€…ç›´æ¥æè®®å€¼
        proposal = Message(
            id="",
            from_node=self.leader_id,
            to_node="broadcast",
            type=MessageType.CONSENSUS,
            data={
                "term": self.current_term,
                "value": value
            }
        )
        self.system.send_message(proposal)
        return True
    
    async def decide(self, value: Any) -> bool:
        """Raftå†³å®š"""
        # ç®€åŒ–å®ç°ï¼šé¢†å¯¼è€…å†³å®šå³ç³»ç»Ÿå†³å®š
        if self.state == "leader":
            self.decided_values[str(uuid.uuid4())] = value
            return True
        return False
```

### 2.4 åˆ†å¸ƒå¼å“ˆå¸Œè¡¨

```python
class DHTNode:
    """DHTèŠ‚ç‚¹"""
    
    def __init__(self, node_id: str, address: str):
        self.node_id = node_id
        self.address = address
        self.successor: Optional['DHTNode'] = None
        self.predecessor: Optional['DHTNode'] = None
        self.finger_table: List[Optional['DHTNode']] = [None] * 160  # SHA-1å“ˆå¸Œç©ºé—´
        self.data: Dict[str, Any] = {}
        
    def __str__(self) -> str:
        return f"DHTNode({self.node_id})"

class ChordDHT:
    """Chordåˆ†å¸ƒå¼å“ˆå¸Œè¡¨"""
    
    def __init__(self):
        self.nodes: Dict[str, DHTNode] = {}
        self.hash_ring: List[str] = []
        
    def add_node(self, node: DHTNode) -> None:
        """æ·»åŠ èŠ‚ç‚¹åˆ°DHT"""
        self.nodes[node.node_id] = node
        self.hash_ring.append(node.node_id)
        self.hash_ring.sort()
        self._update_finger_tables()
        
    def remove_node(self, node_id: str) -> None:
        """ä»DHTç§»é™¤èŠ‚ç‚¹"""
        if node_id in self.nodes:
            del self.nodes[node_id]
            self.hash_ring.remove(node_id)
            self._update_finger_tables()
    
    def _update_finger_tables(self) -> None:
        """æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹çš„æŒ‡è¡¨"""
        for i, node_id in enumerate(self.hash_ring):
            node = self.nodes[node_id]
            
            # æ›´æ–°åç»§å’Œå‰é©±
            next_index = (i + 1) % len(self.hash_ring)
            prev_index = (i - 1) % len(self.hash_ring)
            
            node.successor = self.nodes[self.hash_ring[next_index]]
            node.predecessor = self.nodes[self.hash_ring[prev_index]]
            
            # æ›´æ–°æŒ‡è¡¨
            for j in range(160):
                target_id = (int(node_id, 16) + 2**j) % (2**160)
                node.finger_table[j] = self._find_successor(target_id)
    
    def _find_successor(self, key: int) -> DHTNode:
        """æŸ¥æ‰¾é”®çš„åç»§èŠ‚ç‚¹"""
        if not self.hash_ring:
            return None
            
        # äºŒåˆ†æŸ¥æ‰¾
        left, right = 0, len(self.hash_ring)
        while left < right:
            mid = (left + right) // 2
            mid_id = int(self.hash_ring[mid], 16)
            
            if mid_id < key:
                left = mid + 1
            else:
                right = mid
        
        # è¿”å›åç»§èŠ‚ç‚¹
        successor_index = left % len(self.hash_ring)
        return self.nodes[self.hash_ring[successor_index]]
    
    def lookup(self, key: str) -> Optional[Any]:
        """æŸ¥æ‰¾é”®å€¼"""
        if not self.hash_ring:
            return None
            
        # è®¡ç®—é”®çš„å“ˆå¸Œå€¼
        key_hash = int(key, 16) if key.startswith('0x') else hash(key) % (2**160)
        
        # æ‰¾åˆ°è´Ÿè´£è¯¥é”®çš„èŠ‚ç‚¹
        responsible_node = self._find_successor(key_hash)
        
        # è¿”å›å­˜å‚¨çš„å€¼
        return responsible_node.data.get(key)
    
    def put(self, key: str, value: Any) -> bool:
        """å­˜å‚¨é”®å€¼å¯¹"""
        if not self.hash_ring:
            return False
            
        # è®¡ç®—é”®çš„å“ˆå¸Œå€¼
        key_hash = int(key, 16) if key.startswith('0x') else hash(key) % (2**160)
        
        # æ‰¾åˆ°è´Ÿè´£è¯¥é”®çš„èŠ‚ç‚¹
        responsible_node = self._find_successor(key_hash)
        
        # å­˜å‚¨å€¼
        responsible_node.data[key] = value
        return True
    
    def get_ring_info(self) -> Dict[str, Any]:
        """è·å–ç¯ä¿¡æ¯"""
        return {
            "total_nodes": len(self.nodes),
            "ring_order": self.hash_ring,
            "node_data": {node_id: len(node.data) for node_id, node in self.nodes.items()}
        }
```

### 2.5 ç³»ç»Ÿç›‘æ§å™¨

```python
class SystemMonitor:
    """ç³»ç»Ÿç›‘æ§å™¨"""
    
    def __init__(self, system: DistributedSystem):
        self.system = system
        self.metrics: Dict[str, List[float]] = defaultdict(list)
        self.alerts: List[str] = []
        
    def collect_metrics(self) -> Dict[str, Any]:
        """æ”¶é›†ç³»ç»ŸæŒ‡æ ‡"""
        current_time = time.time()
        
        # ç³»ç»ŸçŠ¶æ€æŒ‡æ ‡
        system_state = self.system.get_system_state()
        
        # èŠ‚ç‚¹å¥åº·æŒ‡æ ‡
        active_nodes = len([n for n in self.system.nodes.values() 
                          if n.state == NodeState.ACTIVE])
        failed_nodes = len([n for n in self.system.nodes.values() 
                          if n.state == NodeState.FAILED])
        
        # ç½‘ç»œæŒ‡æ ‡
        if self.system.is_connected():
            diameter = nx.diameter(self.system.network)
            avg_clustering = nx.average_clustering(self.system.network)
        else:
            diameter = float('inf')
            avg_clustering = 0.0
        
        # æ¶ˆæ¯æŒ‡æ ‡
        total_messages = len(self.system.messages)
        recent_messages = len([m for m in self.system.messages 
                             if current_time - m.timestamp < 60])
        
        metrics = {
            "timestamp": current_time,
            "total_nodes": system_state["total_nodes"],
            "active_nodes": active_nodes,
            "failed_nodes": failed_nodes,
            "network_diameter": diameter,
            "clustering_coefficient": avg_clustering,
            "total_messages": total_messages,
            "messages_per_minute": recent_messages,
            "connectivity": system_state["connected"]
        }
        
        # å­˜å‚¨å†å²æŒ‡æ ‡
        for key, value in metrics.items():
            if key != "timestamp":
                self.metrics[key].append(value)
                
                # ä¿æŒæœ€è¿‘100ä¸ªæ•°æ®ç‚¹
                if len(self.metrics[key]) > 100:
                    self.metrics[key] = self.metrics[key][-100:]
        
        return metrics
    
    def check_alerts(self, metrics: Dict[str, Any]) -> List[str]:
        """æ£€æŸ¥å‘Šè­¦"""
        alerts = []
        
        # æ£€æŸ¥èŠ‚ç‚¹æ•…éšœç‡
        total_nodes = metrics["total_nodes"]
        failed_nodes = metrics["failed_nodes"]
        failure_rate = failed_nodes / total_nodes if total_nodes > 0 else 0
        
        if failure_rate > 0.3:  # 30%æ•…éšœç‡å‘Šè­¦
            alerts.append(f"High failure rate: {failure_rate:.2%}")
        
        # æ£€æŸ¥ç½‘ç»œè¿é€šæ€§
        if not metrics["connectivity"]:
            alerts.append("Network disconnected")
        
        # æ£€æŸ¥ç½‘ç»œç›´å¾„
        if metrics["network_diameter"] > 10:
            alerts.append(f"Large network diameter: {metrics['network_diameter']}")
        
        # æ£€æŸ¥æ¶ˆæ¯é€Ÿç‡
        if metrics["messages_per_minute"] > 1000:
            alerts.append(f"High message rate: {metrics['messages_per_minute']} msg/min")
        
        self.alerts.extend(alerts)
        return alerts
    
    def get_performance_report(self) -> Dict[str, Any]:
        """è·å–æ€§èƒ½æŠ¥å‘Š"""
        if not self.metrics:
            return {}
        
        report = {}
        for metric_name, values in self.metrics.items():
            if values:
                report[metric_name] = {
                    "current": values[-1],
                    "average": sum(values) / len(values),
                    "min": min(values),
                    "max": max(values),
                    "trend": "increasing" if len(values) > 1 and values[-1] > values[-2] else "decreasing"
                }
        
        report["alerts"] = self.alerts[-10:]  # æœ€è¿‘10ä¸ªå‘Šè­¦
        return report
```

## ğŸ¯ åº”ç”¨åœºæ™¯

### 3.1 åˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿ

```python
class DistributedStorage:
    """åˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿ"""
    
    def __init__(self):
        self.dht = ChordDHT()
        self.replication_factor = 3
        
    def store_file(self, file_id: str, data: bytes) -> bool:
        """å­˜å‚¨æ–‡ä»¶"""
        # è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
        file_hash = str(hash(data))
        
        # å­˜å‚¨åˆ°DHT
        success = self.dht.put(file_id, {
            "data": data,
            "hash": file_hash,
            "timestamp": time.time(),
            "size": len(data)
        })
        
        # å¤åˆ¶åˆ°å¤šä¸ªèŠ‚ç‚¹
        if success:
            for i in range(self.replication_factor - 1):
                replica_id = f"{file_id}_replica_{i+1}"
                self.dht.put(replica_id, {
                    "data": data,
                    "hash": file_hash,
                    "timestamp": time.time(),
                    "size": len(data),
                    "is_replica": True
                })
        
        return success
    
    def retrieve_file(self, file_id: str) -> Optional[bytes]:
        """æ£€ç´¢æ–‡ä»¶"""
        file_data = self.dht.lookup(file_id)
        if file_data:
            return file_data["data"]
        return None
    
    def get_storage_stats(self) -> Dict[str, Any]:
        """è·å–å­˜å‚¨ç»Ÿè®¡"""
        ring_info = self.dht.get_ring_info()
        total_files = sum(ring_info["node_data"].values())
        
        return {
            "total_nodes": ring_info["total_nodes"],
            "total_files": total_files,
            "files_per_node": ring_info["node_data"],
            "replication_factor": self.replication_factor
        }
```

### 3.2 åˆ†å¸ƒå¼è®¡ç®—æ¡†æ¶

```python
class DistributedComputing:
    """åˆ†å¸ƒå¼è®¡ç®—æ¡†æ¶"""
    
    def __init__(self, system: DistributedSystem):
        self.system = system
        self.tasks: Dict[str, Dict] = {}
        self.results: Dict[str, Any] = {}
        
    def submit_task(self, task_id: str, task_func: Callable, 
                   input_data: Any) -> bool:
        """æäº¤ä»»åŠ¡"""
        # é€‰æ‹©æ‰§è¡ŒèŠ‚ç‚¹ï¼ˆç®€åŒ–ï¼šé€‰æ‹©ç¬¬ä¸€ä¸ªæ´»è·ƒèŠ‚ç‚¹ï¼‰
        executor_node = None
        for node in self.system.nodes.values():
            if node.state == NodeState.ACTIVE:
                executor_node = node
                break
        
        if not executor_node:
            return False
        
        # åˆ›å»ºä»»åŠ¡
        self.tasks[task_id] = {
            "function": task_func,
            "input": input_data,
            "executor": executor_node.id,
            "status": "pending",
            "submit_time": time.time()
        }
        
        # å‘é€ä»»åŠ¡åˆ°æ‰§è¡ŒèŠ‚ç‚¹
        task_msg = Message(
            id="",
            from_node="scheduler",
            to_node=executor_node.id,
            type=MessageType.DATA,
            data={
                "task_id": task_id,
                "function": task_func.__name__,
                "input": input_data
            }
        )
        self.system.send_message(task_msg)
        
        return True
    
    def get_result(self, task_id: str) -> Optional[Any]:
        """è·å–ä»»åŠ¡ç»“æœ"""
        return self.results.get(task_id)
    
    def get_task_status(self, task_id: str) -> Optional[str]:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        if task_id in self.tasks:
            return self.tasks[task_id]["status"]
        return None
    
    def get_computing_stats(self) -> Dict[str, Any]:
        """è·å–è®¡ç®—ç»Ÿè®¡"""
        pending_tasks = len([t for t in self.tasks.values() 
                           if t["status"] == "pending"])
        completed_tasks = len(self.results)
        
        return {
            "total_tasks": len(self.tasks),
            "pending_tasks": pending_tasks,
            "completed_tasks": completed_tasks,
            "completion_rate": completed_tasks / len(self.tasks) if self.tasks else 0
        }
```

## ğŸ“Š æ•°å­¦è¯æ˜

### 4.1 åˆ†å¸ƒå¼ç³»ç»Ÿæ€§è´¨è¯æ˜

**å®šç† 4.1** (åˆ†å¸ƒå¼ç³»ç»Ÿå®¹é”™æ€§)
å¦‚æœä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ $f$-å®¹é”™çš„ï¼Œä¸”èŠ‚ç‚¹æ€»æ•°ä¸º $n$ï¼Œåˆ™ï¼š
$$n \geq 2f + 1$$

**è¯æ˜**ï¼š

1. è®¾ç³»ç»ŸèŠ‚ç‚¹æ€»æ•°ä¸º $n$ï¼Œæ•…éšœèŠ‚ç‚¹æ•°ä¸º $f$
2. æ­£ç¡®èŠ‚ç‚¹æ•°ä¸º $n - f$
3. ä¸ºäº†ä¿è¯ç³»ç»Ÿæ­£å¸¸å·¥ä½œï¼Œæ­£ç¡®èŠ‚ç‚¹å¿…é¡»æ„æˆå¤šæ•°
4. å› æ­¤ $n - f > f$
5. å³ $n > 2f$
6. ç”±äº $n$ æ˜¯æ•´æ•°ï¼Œæ‰€ä»¥ $n \geq 2f + 1$

**å®šç† 4.2** (æ¶ˆæ¯ä¼ é€’å¯é æ€§)
åœ¨å¼‚æ­¥ç½‘ç»œä¸­ï¼Œå¦‚æœæ¶ˆæ¯å¯èƒ½ä¸¢å¤±ï¼Œåˆ™æ— æ³•ä¿è¯æ¶ˆæ¯ä¼ é€’çš„å¯é æ€§ã€‚

**è¯æ˜**ï¼š

1. å‡è®¾å­˜åœ¨å¯é çš„å¼‚æ­¥æ¶ˆæ¯ä¼ é€’åè®®
2. è€ƒè™‘ä¸¤ä¸ªèŠ‚ç‚¹ $A$ å’Œ $B$ ä¹‹é—´çš„é€šä¿¡
3. $A$ å‘é€æ¶ˆæ¯ $m$ ç»™ $B$
4. å¦‚æœæ¶ˆæ¯ä¸¢å¤±ï¼Œ$A$ æ— æ³•ç¡®å®š $B$ æ˜¯å¦æ”¶åˆ°æ¶ˆæ¯
5. $A$ å¿…é¡»é‡ä¼ æ¶ˆæ¯æˆ–è¶…æ—¶
6. ä½†é‡ä¼ å¯èƒ½å¯¼è‡´é‡å¤æ¶ˆæ¯ï¼Œè¶…æ—¶å¯èƒ½å¯¼è‡´æ¶ˆæ¯ä¸¢å¤±
7. å› æ­¤æ— æ³•ä¿è¯æ¶ˆæ¯ä¼ é€’çš„å¯é æ€§

### 4.2 ä¸€è‡´æ€§ç®—æ³•è¯æ˜

**å®šç† 4.3** (Paxosæ´»æ€§)
Paxosç®—æ³•ä¿è¯æ´»æ€§ï¼šå¦‚æœæè®®è€…æè®®å€¼ï¼Œåˆ™æœ€ç»ˆä¼šé€‰æ‹©ä¸€ä¸ªå€¼ã€‚

**è¯æ˜**ï¼š

1. è®¾æè®®è€… $P$ æè®®å€¼ $v$
2. å¦‚æœ $P$ è·å¾—å¤šæ•°Promiseï¼Œåˆ™è¿›å…¥Accepté˜¶æ®µ
3. å¦‚æœ $P$ æœªè·å¾—å¤šæ•°Promiseï¼Œåˆ™å¢åŠ ææ¡ˆç¼–å·é‡è¯•
4. ç”±äºææ¡ˆç¼–å·å•è°ƒé€’å¢ï¼Œæœ€ç»ˆä¼šé€‰æ‹©ä¸€ä¸ªææ¡ˆç¼–å·
5. ä¸€æ—¦é€‰æ‹©äº†ææ¡ˆç¼–å·ï¼Œå¯¹åº”çš„å€¼å°±ä¼šè¢«é€‰æ‹©
6. å› æ­¤æœ€ç»ˆä¼šé€‰æ‹©ä¸€ä¸ªå€¼

**å®šç† 4.4** (Rafté¢†å¯¼è€…å”¯ä¸€æ€§)
Raftç®—æ³•ä¿è¯æ¯ä¸ªä»»æœŸæœ€å¤šæœ‰ä¸€ä¸ªé¢†å¯¼è€…ã€‚

**è¯æ˜**ï¼š

1. è®¾ä»»æœŸ $T$ æœ‰ä¸¤ä¸ªé¢†å¯¼è€… $L_1$ å’Œ $L_2$
2. æ ¹æ®ç®—æ³•ï¼Œé¢†å¯¼è€…å¿…é¡»è·å¾—å¤šæ•°ç¥¨
3. è®¾ $S_1$ å’Œ $S_2$ åˆ†åˆ«æ˜¯æŠ•ç¥¨ç»™ $L_1$ å’Œ $L_2$ çš„èŠ‚ç‚¹é›†åˆ
4. ç”±äº $|S_1| > n/2$ ä¸” $|S_2| > n/2$ï¼Œ$S_1 \cap S_2 \neq \emptyset$
5. è®¾ $n \in S_1 \cap S_2$ï¼Œåˆ™ $n$ æŠ•ç¥¨ç»™äº†ä¸¤ä¸ªå€™é€‰äºº
6. è¿™ä¸Raftçš„æŠ•ç¥¨è§„åˆ™çŸ›ç›¾
7. å› æ­¤æ¯ä¸ªä»»æœŸæœ€å¤šæœ‰ä¸€ä¸ªé¢†å¯¼è€…

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [å¹¶å‘ç†è®º](02-07-å¹¶å‘ç†è®º.md)
- [ç½‘ç»œç†è®º](02-09-ç½‘ç»œç†è®º.md)
- [ç®—æ³•ç†è®º](02-01-ç®—æ³•ç†è®º.md)
- [æ•°æ®ç»“æ„ç†è®º](02-02-æ•°æ®ç»“æ„ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Lamport, L. (1998). The Part-Time Parliament
2. Ongaro, D., & Ousterhout, J. (2014). In Search of an Understandable Consensus Algorithm
3. Stoica, I., et al. (2001). Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications
4. Fischer, M. J., Lynch, N. A., & Paterson, M. S. (1985). Impossibility of Distributed Consensus with One Faulty Process
5. Chandra, T. D., & Toueg, S. (1996). Unreliable Failure Detectors for Reliable Distributed Systems

---

*åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºä¸ºæ„å»ºé«˜å¯ç”¨ã€é«˜å¯æ‰©å±•çš„è½¯ä»¶ç³»ç»Ÿæä¾›äº†ç†è®ºåŸºç¡€ï¼Œé€šè¿‡å½¢å¼åŒ–çš„æ•°å­¦å®šä¹‰å’Œä¸¥æ ¼çš„è¯æ˜ï¼Œæˆ‘ä»¬å»ºç«‹äº†åˆ†å¸ƒå¼ç³»ç»Ÿçš„å®Œæ•´ç†è®ºä½“ç³»ã€‚*
