# 02-08 分布式系统理论

## 📋 概述

分布式系统理论是计算机科学的核心理论之一，研究由多个独立计算机组成的系统如何通过网络进行通信和协调。本文档从形式化角度阐述分布式系统的核心概念，提供严格的数学定义和证明，并通过Python代码实现相关分布式算法。

## 🎯 核心概念

### 1. 分布式系统基础

#### 1.1 形式化定义

**定义 1.1** (分布式系统)
分布式系统是一个五元组：
$$DS = (N, C, S, P, F)$$
其中：

- $N = \{n_1, n_2, \ldots, n_k\}$ 是节点集合
- $C = (N, E)$ 是通信网络，$E \subseteq N \times N$ 是通信链路集合
- $S = \{s_1, s_2, \ldots, s_m\}$ 是状态集合
- $P = \{p_1, p_2, \ldots, p_l\}$ 是协议集合
- $F: N \rightarrow \{0, 1\}$ 是故障函数，$F(n_i) = 1$ 表示节点 $n_i$ 故障

**定义 1.2** (节点)
节点是一个四元组：
$$n = (id, state, neighbors, protocol)$$
其中：

- $id$ 是节点唯一标识符
- $state \in S$ 是节点当前状态
- $neighbors \subseteq N$ 是邻居节点集合
- $protocol \in P$ 是节点执行的协议

**定义 1.3** (消息)
消息是一个五元组：
$$m = (from, to, type, data, timestamp)$$
其中：

- $from, to \in N$ 是发送和接收节点
- $type$ 是消息类型
- $data$ 是消息数据
- $timestamp$ 是时间戳

#### 1.2 分布式系统属性

**定义 1.4** (连通性)
分布式系统 $DS$ 是连通的，当且仅当：
$$\forall n_i, n_j \in N: \exists \text{path}(n_i, n_j)$$

**定义 1.5** (容错性)
分布式系统 $DS$ 是 $f$-容错的，当且仅当：
$$|\{n \in N: F(n) = 1\}| \leq f \Rightarrow DS \text{ 仍能正常工作}$$

**定理 1.1** (连通性保持)
如果分布式系统 $DS$ 是连通的，且故障节点数不超过 $f$，则剩余节点构成的子图仍然是连通的。

**证明**：

1. 设 $DS = (N, C, S, P, F)$ 是连通分布式系统
2. 设故障节点集合为 $F = \{n_{f1}, n_{f2}, \ldots, n_{ff}\}$
3. 剩余节点集合为 $N' = N \setminus F$
4. 对于任意 $n_i, n_j \in N'$，由于原系统连通，存在路径 $path(n_i, n_j)$
5. 如果路径中不包含故障节点，则路径仍然有效
6. 如果路径包含故障节点，由于 $|F| \leq f$，可以通过其他路径绕过故障节点
7. 因此 $N'$ 中的任意两个节点间都存在路径

### 2. 一致性理论

#### 2.1 一致性模型

**定义 2.1** (一致性)
分布式系统达到一致性，当且仅当：
$$\forall n_i, n_j \in N: \text{State}(n_i) = \text{State}(n_j)$$

**定义 2.2** (线性一致性)
操作序列满足线性一致性，当且仅当：
$$\exists \text{total order} \prec: \forall \text{op}_1, \text{op}_2: \text{op}_1 \prec \text{op}_2 \Rightarrow \text{result}(\text{op}_1) \text{ 在 } \text{op}_2 \text{ 之前可见}$$

**定义 2.3** (因果一致性)
操作序列满足因果一致性，当且仅当：
$$\text{op}_1 \rightarrow \text{op}_2 \Rightarrow \text{op}_1 \prec \text{op}_2$$
其中 $\rightarrow$ 表示因果依赖关系。

#### 2.2 CAP定理

**定理 2.1** (CAP定理)
在分布式系统中，不可能同时满足以下三个属性：

- 一致性 (Consistency)
- 可用性 (Availability)  
- 分区容错性 (Partition tolerance)

**证明**：

1. 假设存在一个系统同时满足CAP三个属性
2. 当网络分区发生时，系统被分为两个部分 $P_1$ 和 $P_2$
3. 为了保证可用性，$P_1$ 和 $P_2$ 都必须响应请求
4. 为了保证一致性，$P_1$ 和 $P_2$ 必须看到相同的数据
5. 由于网络分区，$P_1$ 和 $P_2$ 无法通信
6. 这导致矛盾：既要求响应（可用性），又要求数据一致（一致性）
7. 因此CAP三个属性不能同时满足

**推论 2.1** (PACELC扩展)
在分区存在时选择可用性还是一致性，在分区不存在时选择延迟还是一致性。

### 3. 共识算法

#### 3.1 Paxos算法

**定义 3.1** (Paxos算法)
Paxos算法满足以下性质：

- **安全性**: 如果值 $v$ 被选择，则所有节点最终学习到 $v$
- **活性**: 如果提议者提议值，则最终会选择一个值

**算法 3.1** (Paxos算法)

```text
Phase 1a: 提议者选择提案编号 n，向接受者发送 Prepare(n)
Phase 1b: 接受者回复 Promise(n, v, n_v)，其中 v 是已接受的值，n_v 是提案编号
Phase 2a: 提议者发送 Accept(n, v)，其中 v 是最高编号的已接受值或新值
Phase 2b: 接受者接受 Accept(n, v)
```

**定理 3.1** (Paxos安全性)
Paxos算法保证安全性：如果值 $v$ 被选择，则所有节点最终学习到 $v$。

**证明**：

1. 设值 $v$ 被选择，提案编号为 $n$
2. 根据算法，至少 $f+1$ 个接受者接受了 $(n, v)$
3. 对于任何后续提案 $n' > n$，提议者必须选择 $v$
4. 因为接受者承诺不接受编号小于 $n$ 的提案
5. 因此所有后续提案都会选择 $v$
6. 最终所有节点都会学习到 $v$

#### 3.2 Raft算法

**定义 3.2** (Raft算法)
Raft算法将时间划分为任期，每个任期最多有一个领导者。

**算法 3.2** (Raft领导者选举)

```text
1. 节点启动时成为跟随者
2. 如果超时未收到领导者消息，成为候选人
3. 候选人发送 RequestVote 给其他节点
4. 如果获得多数票，成为领导者
5. 领导者定期发送心跳消息
```

**定理 3.2** (Raft安全性)
Raft算法保证安全性：每个任期最多有一个领导者。

**证明**：

1. 设任期 $T$ 有两个领导者 $L_1$ 和 $L_2$
2. 根据算法，领导者必须获得多数票
3. 设 $S_1$ 和 $S_2$ 分别是投票给 $L_1$ 和 $L_2$ 的节点集合
4. 由于 $|S_1| > n/2$ 且 $|S_2| > n/2$，$S_1 \cap S_2 \neq \emptyset$
5. 设 $n \in S_1 \cap S_2$，则 $n$ 投票给了两个候选人
6. 这与Raft的投票规则矛盾
7. 因此每个任期最多有一个领导者

### 4. 故障检测

#### 4.1 故障检测器

**定义 4.1** (故障检测器)
故障检测器是一个函数：
$$FD: N \times \mathbb{R} \rightarrow \{0, 1\}$$
其中 $FD(n, t) = 1$ 表示在时间 $t$ 检测到节点 $n$ 故障。

**定义 4.2** (完美故障检测器)
完美故障检测器满足：

- **完整性**: 故障节点最终被所有正确节点检测到
- **准确性**: 正确节点永远不会被检测为故障

**定理 4.1** (故障检测器不可能性)
在异步系统中，不存在完美的故障检测器。

**证明**：

1. 假设存在完美故障检测器 $FD$
2. 考虑节点 $n$ 和 $m$ 之间的通信
3. 如果 $n$ 发送消息给 $m$，但消息延迟
4. $FD$ 可能错误地检测到 $m$ 故障
5. 这与准确性矛盾
6. 因此不存在完美的故障检测器

#### 4.2 心跳机制

**算法 4.1** (心跳故障检测)

```text
1. 每个节点定期发送心跳消息
2. 如果超时未收到心跳，标记节点为可疑
3. 如果连续多次未收到心跳，标记节点为故障
4. 使用指数退避策略调整超时时间
```

### 5. 分布式哈希表

#### 5.1 DHT定义

**定义 5.1** (分布式哈希表)
分布式哈希表是一个三元组：
$$DHT = (K, V, N)$$
其中：

- $K$ 是键空间
- $V$ 是值空间  
- $N$ 是节点集合

**定义 5.2** (一致性哈希)
一致性哈希是一个函数：
$$h: K \rightarrow N$$
满足：

- **平衡性**: 键均匀分布到节点
- **单调性**: 节点加入/离开时，只有少量键需要重新分配

#### 5.2 Chord算法

**算法 5.1** (Chord查找)

```text
1. 节点按ID排序形成环形结构
2. 每个节点维护指向后继节点的指针
3. 查找时沿环顺时针查找
4. 使用跳表优化查找复杂度
```

**定理 5.1** (Chord查找复杂度)
Chord算法的查找复杂度为 $O(\log n)$。

**证明**：

1. Chord使用跳表结构，每层节点数减半
2. 设总节点数为 $n$，跳表层数为 $\log n$
3. 每层最多需要 $\log n$ 步查找
4. 因此总查找复杂度为 $O(\log n)$

## 🔧 Python实现

### 2.1 分布式节点抽象

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any, Callable
from enum import Enum
import asyncio
import time
import uuid
from collections import defaultdict
import networkx as nx
import json

class NodeState(Enum):
    """节点状态枚举"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    FAILED = "failed"
    RECOVERING = "recovering"

class MessageType(Enum):
    """消息类型枚举"""
    HEARTBEAT = "heartbeat"
    DATA = "data"
    CONTROL = "control"
    ELECTION = "election"
    CONSENSUS = "consensus"

@dataclass
class Message:
    """消息类"""
    id: str
    from_node: str
    to_node: str
    type: MessageType
    data: Any
    timestamp: float = field(default_factory=time.time)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Node:
    """分布式节点"""
    id: str
    address: str
    state: NodeState = NodeState.ACTIVE
    neighbors: Set[str] = field(default_factory=set)
    data: Dict[str, Any] = field(default_factory=dict)
    last_heartbeat: float = field(default_factory=time.time)
    
    def __str__(self) -> str:
        return f"Node({self.id}: {self.state.value})"

class DistributedSystem:
    """分布式系统"""
    
    def __init__(self):
        self.nodes: Dict[str, Node] = {}
        self.network: nx.Graph = nx.Graph()
        self.messages: List[Message] = []
        self.fault_detector = None
        self.consensus_algorithm = None
        
    def add_node(self, node: Node) -> None:
        """添加节点"""
        self.nodes[node.id] = node
        self.network.add_node(node.id)
        
    def remove_node(self, node_id: str) -> None:
        """移除节点"""
        if node_id in self.nodes:
            del self.nodes[node_id]
            self.network.remove_node(node_id)
            
    def add_edge(self, node1_id: str, node2_id: str) -> None:
        """添加通信链路"""
        if node1_id in self.nodes and node2_id in self.nodes:
            self.network.add_edge(node1_id, node2_id)
            self.nodes[node1_id].neighbors.add(node2_id)
            self.nodes[node2_id].neighbors.add(node1_id)
            
    def is_connected(self) -> bool:
        """检查系统是否连通"""
        return nx.is_connected(self.network)
    
    def get_shortest_path(self, source: str, target: str) -> Optional[List[str]]:
        """获取最短路径"""
        try:
            return nx.shortest_path(self.network, source, target)
        except nx.NetworkXNoPath:
            return None
    
    def send_message(self, message: Message) -> bool:
        """发送消息"""
        if (message.from_node in self.nodes and 
            message.to_node in self.nodes):
            self.messages.append(message)
            return True
        return False
    
    def get_system_state(self) -> Dict[str, Any]:
        """获取系统状态"""
        return {
            "total_nodes": len(self.nodes),
            "active_nodes": len([n for n in self.nodes.values() 
                               if n.state == NodeState.ACTIVE]),
            "connected": self.is_connected(),
            "network_diameter": nx.diameter(self.network) if self.is_connected() else float('inf')
        }
```

### 2.2 故障检测器

```python
class FaultDetector:
    """故障检测器"""
    
    def __init__(self, system: DistributedSystem, timeout: float = 5.0):
        self.system = system
        self.timeout = timeout
        self.suspected_nodes: Set[str] = set()
        self.failed_nodes: Set[str] = set()
        
    def check_node_health(self, node_id: str) -> bool:
        """检查节点健康状态"""
        if node_id not in self.system.nodes:
            return False
            
        node = self.system.nodes[node_id]
        current_time = time.time()
        
        # 检查心跳超时
        if current_time - node.last_heartbeat > self.timeout:
            if node_id not in self.suspected_nodes:
                self.suspected_nodes.add(node_id)
            elif node_id in self.suspected_nodes:
                self.failed_nodes.add(node_id)
                node.state = NodeState.FAILED
            return False
        else:
            if node_id in self.suspected_nodes:
                self.suspected_nodes.remove(node_id)
            return True
    
    def get_failed_nodes(self) -> Set[str]:
        """获取故障节点集合"""
        return self.failed_nodes.copy()
    
    def get_suspected_nodes(self) -> Set[str]:
        """获取可疑节点集合"""
        return self.suspected_nodes.copy()
    
    def is_node_failed(self, node_id: str) -> bool:
        """检查节点是否故障"""
        return node_id in self.failed_nodes

class HeartbeatManager:
    """心跳管理器"""
    
    def __init__(self, system: DistributedSystem, interval: float = 1.0):
        self.system = system
        self.interval = interval
        self.fault_detector = FaultDetector(system)
        
    async def start_heartbeat(self, node_id: str):
        """开始心跳"""
        while True:
            if node_id in self.system.nodes:
                # 发送心跳消息
                heartbeat_msg = Message(
                    id="",
                    from_node=node_id,
                    to_node="broadcast",
                    type=MessageType.HEARTBEAT,
                    data={"timestamp": time.time()}
                )
                self.system.send_message(heartbeat_msg)
                
                # 更新最后心跳时间
                self.system.nodes[node_id].last_heartbeat = time.time()
                
            await asyncio.sleep(self.interval)
    
    async def monitor_heartbeats(self):
        """监控心跳"""
        while True:
            for node_id in self.system.nodes:
                self.fault_detector.check_node_health(node_id)
            await asyncio.sleep(0.5)
```

### 2.3 一致性算法

```python
class ConsensusAlgorithm(ABC):
    """一致性算法抽象基类"""
    
    def __init__(self, system: DistributedSystem):
        self.system = system
        self.proposed_values: Dict[str, Any] = {}
        self.decided_values: Dict[str, Any] = {}
        
    @abstractmethod
    async def propose(self, value: Any) -> bool:
        """提议值"""
        pass
    
    @abstractmethod
    async def decide(self, value: Any) -> bool:
        """决定值"""
        pass

class PaxosAlgorithm(ConsensusAlgorithm):
    """Paxos算法实现"""
    
    def __init__(self, system: DistributedSystem):
        super().__init__(system)
        self.proposal_number = 0
        self.accepted_proposals: Dict[str, Dict] = {}
        self.promises: Dict[str, List] = {}
        
    async def propose(self, value: Any) -> bool:
        """Paxos提议阶段"""
        self.proposal_number += 1
        proposal_id = f"proposal_{self.proposal_number}"
        
        # Phase 1a: 发送Prepare消息
        prepare_msg = Message(
            id="",
            from_node="proposer",
            to_node="broadcast",
            type=MessageType.CONSENSUS,
            data={
                "phase": "prepare",
                "proposal_id": proposal_id,
                "proposal_number": self.proposal_number
            }
        )
        self.system.send_message(prepare_msg)
        
        # 等待Promise响应
        await asyncio.sleep(0.1)
        
        # 检查是否获得多数Promise
        if len(self.promises.get(proposal_id, [])) > len(self.system.nodes) // 2:
            # Phase 2a: 发送Accept消息
            accept_msg = Message(
                id="",
                from_node="proposer",
                to_node="broadcast",
                type=MessageType.CONSENSUS,
                data={
                    "phase": "accept",
                    "proposal_id": proposal_id,
                    "proposal_number": self.proposal_number,
                    "value": value
                }
            )
            self.system.send_message(accept_msg)
            return True
        
        return False
    
    async def decide(self, value: Any) -> bool:
        """Paxos决定阶段"""
        # 检查是否获得多数Accept
        proposal_id = f"proposal_{self.proposal_number}"
        accepted_count = len(self.accepted_proposals.get(proposal_id, {}))
        
        if accepted_count > len(self.system.nodes) // 2:
            self.decided_values[proposal_id] = value
            return True
        
        return False

class RaftAlgorithm(ConsensusAlgorithm):
    """Raft算法实现"""
    
    def __init__(self, system: DistributedSystem):
        super().__init__(system)
        self.current_term = 0
        self.voted_for: Optional[str] = None
        self.leader_id: Optional[str] = None
        self.state = "follower"  # follower, candidate, leader
        self.election_timeout = 5.0
        self.last_election_time = time.time()
        
    async def start_election(self, node_id: str):
        """开始领导者选举"""
        self.state = "candidate"
        self.current_term += 1
        self.voted_for = node_id
        self.last_election_time = time.time()
        
        # 发送RequestVote消息
        vote_request = Message(
            id="",
            from_node=node_id,
            to_node="broadcast",
            type=MessageType.ELECTION,
            data={
                "term": self.current_term,
                "candidate_id": node_id
            }
        )
        self.system.send_message(vote_request)
        
        # 等待投票结果
        await asyncio.sleep(0.1)
        
        # 检查是否获得多数票
        votes_received = 1  # 自己的一票
        if votes_received > len(self.system.nodes) // 2:
            self.state = "leader"
            self.leader_id = node_id
            await self.start_heartbeat()
    
    async def start_heartbeat(self):
        """领导者心跳"""
        while self.state == "leader":
            heartbeat = Message(
                id="",
                from_node=self.leader_id,
                to_node="broadcast",
                type=MessageType.HEARTBEAT,
                data={
                    "term": self.current_term,
                    "leader_id": self.leader_id
                }
            )
            self.system.send_message(heartbeat)
            await asyncio.sleep(1.0)
    
    async def propose(self, value: Any) -> bool:
        """Raft提议"""
        if self.state != "leader":
            return False
        
        # 领导者直接提议值
        proposal = Message(
            id="",
            from_node=self.leader_id,
            to_node="broadcast",
            type=MessageType.CONSENSUS,
            data={
                "term": self.current_term,
                "value": value
            }
        )
        self.system.send_message(proposal)
        return True
    
    async def decide(self, value: Any) -> bool:
        """Raft决定"""
        # 简化实现：领导者决定即系统决定
        if self.state == "leader":
            self.decided_values[str(uuid.uuid4())] = value
            return True
        return False
```

### 2.4 分布式哈希表

```python
class DHTNode:
    """DHT节点"""
    
    def __init__(self, node_id: str, address: str):
        self.node_id = node_id
        self.address = address
        self.successor: Optional['DHTNode'] = None
        self.predecessor: Optional['DHTNode'] = None
        self.finger_table: List[Optional['DHTNode']] = [None] * 160  # SHA-1哈希空间
        self.data: Dict[str, Any] = {}
        
    def __str__(self) -> str:
        return f"DHTNode({self.node_id})"

class ChordDHT:
    """Chord分布式哈希表"""
    
    def __init__(self):
        self.nodes: Dict[str, DHTNode] = {}
        self.hash_ring: List[str] = []
        
    def add_node(self, node: DHTNode) -> None:
        """添加节点到DHT"""
        self.nodes[node.node_id] = node
        self.hash_ring.append(node.node_id)
        self.hash_ring.sort()
        self._update_finger_tables()
        
    def remove_node(self, node_id: str) -> None:
        """从DHT移除节点"""
        if node_id in self.nodes:
            del self.nodes[node_id]
            self.hash_ring.remove(node_id)
            self._update_finger_tables()
    
    def _update_finger_tables(self) -> None:
        """更新所有节点的指表"""
        for i, node_id in enumerate(self.hash_ring):
            node = self.nodes[node_id]
            
            # 更新后继和前驱
            next_index = (i + 1) % len(self.hash_ring)
            prev_index = (i - 1) % len(self.hash_ring)
            
            node.successor = self.nodes[self.hash_ring[next_index]]
            node.predecessor = self.nodes[self.hash_ring[prev_index]]
            
            # 更新指表
            for j in range(160):
                target_id = (int(node_id, 16) + 2**j) % (2**160)
                node.finger_table[j] = self._find_successor(target_id)
    
    def _find_successor(self, key: int) -> DHTNode:
        """查找键的后继节点"""
        if not self.hash_ring:
            return None
            
        # 二分查找
        left, right = 0, len(self.hash_ring)
        while left < right:
            mid = (left + right) // 2
            mid_id = int(self.hash_ring[mid], 16)
            
            if mid_id < key:
                left = mid + 1
            else:
                right = mid
        
        # 返回后继节点
        successor_index = left % len(self.hash_ring)
        return self.nodes[self.hash_ring[successor_index]]
    
    def lookup(self, key: str) -> Optional[Any]:
        """查找键值"""
        if not self.hash_ring:
            return None
            
        # 计算键的哈希值
        key_hash = int(key, 16) if key.startswith('0x') else hash(key) % (2**160)
        
        # 找到负责该键的节点
        responsible_node = self._find_successor(key_hash)
        
        # 返回存储的值
        return responsible_node.data.get(key)
    
    def put(self, key: str, value: Any) -> bool:
        """存储键值对"""
        if not self.hash_ring:
            return False
            
        # 计算键的哈希值
        key_hash = int(key, 16) if key.startswith('0x') else hash(key) % (2**160)
        
        # 找到负责该键的节点
        responsible_node = self._find_successor(key_hash)
        
        # 存储值
        responsible_node.data[key] = value
        return True
    
    def get_ring_info(self) -> Dict[str, Any]:
        """获取环信息"""
        return {
            "total_nodes": len(self.nodes),
            "ring_order": self.hash_ring,
            "node_data": {node_id: len(node.data) for node_id, node in self.nodes.items()}
        }
```

### 2.5 系统监控器

```python
class SystemMonitor:
    """系统监控器"""
    
    def __init__(self, system: DistributedSystem):
        self.system = system
        self.metrics: Dict[str, List[float]] = defaultdict(list)
        self.alerts: List[str] = []
        
    def collect_metrics(self) -> Dict[str, Any]:
        """收集系统指标"""
        current_time = time.time()
        
        # 系统状态指标
        system_state = self.system.get_system_state()
        
        # 节点健康指标
        active_nodes = len([n for n in self.system.nodes.values() 
                          if n.state == NodeState.ACTIVE])
        failed_nodes = len([n for n in self.system.nodes.values() 
                          if n.state == NodeState.FAILED])
        
        # 网络指标
        if self.system.is_connected():
            diameter = nx.diameter(self.system.network)
            avg_clustering = nx.average_clustering(self.system.network)
        else:
            diameter = float('inf')
            avg_clustering = 0.0
        
        # 消息指标
        total_messages = len(self.system.messages)
        recent_messages = len([m for m in self.system.messages 
                             if current_time - m.timestamp < 60])
        
        metrics = {
            "timestamp": current_time,
            "total_nodes": system_state["total_nodes"],
            "active_nodes": active_nodes,
            "failed_nodes": failed_nodes,
            "network_diameter": diameter,
            "clustering_coefficient": avg_clustering,
            "total_messages": total_messages,
            "messages_per_minute": recent_messages,
            "connectivity": system_state["connected"]
        }
        
        # 存储历史指标
        for key, value in metrics.items():
            if key != "timestamp":
                self.metrics[key].append(value)
                
                # 保持最近100个数据点
                if len(self.metrics[key]) > 100:
                    self.metrics[key] = self.metrics[key][-100:]
        
        return metrics
    
    def check_alerts(self, metrics: Dict[str, Any]) -> List[str]:
        """检查告警"""
        alerts = []
        
        # 检查节点故障率
        total_nodes = metrics["total_nodes"]
        failed_nodes = metrics["failed_nodes"]
        failure_rate = failed_nodes / total_nodes if total_nodes > 0 else 0
        
        if failure_rate > 0.3:  # 30%故障率告警
            alerts.append(f"High failure rate: {failure_rate:.2%}")
        
        # 检查网络连通性
        if not metrics["connectivity"]:
            alerts.append("Network disconnected")
        
        # 检查网络直径
        if metrics["network_diameter"] > 10:
            alerts.append(f"Large network diameter: {metrics['network_diameter']}")
        
        # 检查消息速率
        if metrics["messages_per_minute"] > 1000:
            alerts.append(f"High message rate: {metrics['messages_per_minute']} msg/min")
        
        self.alerts.extend(alerts)
        return alerts
    
    def get_performance_report(self) -> Dict[str, Any]:
        """获取性能报告"""
        if not self.metrics:
            return {}
        
        report = {}
        for metric_name, values in self.metrics.items():
            if values:
                report[metric_name] = {
                    "current": values[-1],
                    "average": sum(values) / len(values),
                    "min": min(values),
                    "max": max(values),
                    "trend": "increasing" if len(values) > 1 and values[-1] > values[-2] else "decreasing"
                }
        
        report["alerts"] = self.alerts[-10:]  # 最近10个告警
        return report
```

## 🎯 应用场景

### 3.1 分布式存储系统

```python
class DistributedStorage:
    """分布式存储系统"""
    
    def __init__(self):
        self.dht = ChordDHT()
        self.replication_factor = 3
        
    def store_file(self, file_id: str, data: bytes) -> bool:
        """存储文件"""
        # 计算文件哈希
        file_hash = str(hash(data))
        
        # 存储到DHT
        success = self.dht.put(file_id, {
            "data": data,
            "hash": file_hash,
            "timestamp": time.time(),
            "size": len(data)
        })
        
        # 复制到多个节点
        if success:
            for i in range(self.replication_factor - 1):
                replica_id = f"{file_id}_replica_{i+1}"
                self.dht.put(replica_id, {
                    "data": data,
                    "hash": file_hash,
                    "timestamp": time.time(),
                    "size": len(data),
                    "is_replica": True
                })
        
        return success
    
    def retrieve_file(self, file_id: str) -> Optional[bytes]:
        """检索文件"""
        file_data = self.dht.lookup(file_id)
        if file_data:
            return file_data["data"]
        return None
    
    def get_storage_stats(self) -> Dict[str, Any]:
        """获取存储统计"""
        ring_info = self.dht.get_ring_info()
        total_files = sum(ring_info["node_data"].values())
        
        return {
            "total_nodes": ring_info["total_nodes"],
            "total_files": total_files,
            "files_per_node": ring_info["node_data"],
            "replication_factor": self.replication_factor
        }
```

### 3.2 分布式计算框架

```python
class DistributedComputing:
    """分布式计算框架"""
    
    def __init__(self, system: DistributedSystem):
        self.system = system
        self.tasks: Dict[str, Dict] = {}
        self.results: Dict[str, Any] = {}
        
    def submit_task(self, task_id: str, task_func: Callable, 
                   input_data: Any) -> bool:
        """提交任务"""
        # 选择执行节点（简化：选择第一个活跃节点）
        executor_node = None
        for node in self.system.nodes.values():
            if node.state == NodeState.ACTIVE:
                executor_node = node
                break
        
        if not executor_node:
            return False
        
        # 创建任务
        self.tasks[task_id] = {
            "function": task_func,
            "input": input_data,
            "executor": executor_node.id,
            "status": "pending",
            "submit_time": time.time()
        }
        
        # 发送任务到执行节点
        task_msg = Message(
            id="",
            from_node="scheduler",
            to_node=executor_node.id,
            type=MessageType.DATA,
            data={
                "task_id": task_id,
                "function": task_func.__name__,
                "input": input_data
            }
        )
        self.system.send_message(task_msg)
        
        return True
    
    def get_result(self, task_id: str) -> Optional[Any]:
        """获取任务结果"""
        return self.results.get(task_id)
    
    def get_task_status(self, task_id: str) -> Optional[str]:
        """获取任务状态"""
        if task_id in self.tasks:
            return self.tasks[task_id]["status"]
        return None
    
    def get_computing_stats(self) -> Dict[str, Any]:
        """获取计算统计"""
        pending_tasks = len([t for t in self.tasks.values() 
                           if t["status"] == "pending"])
        completed_tasks = len(self.results)
        
        return {
            "total_tasks": len(self.tasks),
            "pending_tasks": pending_tasks,
            "completed_tasks": completed_tasks,
            "completion_rate": completed_tasks / len(self.tasks) if self.tasks else 0
        }
```

## 📊 数学证明

### 4.1 分布式系统性质证明

**定理 4.1** (分布式系统容错性)
如果一个分布式系统是 $f$-容错的，且节点总数为 $n$，则：
$$n \geq 2f + 1$$

**证明**：

1. 设系统节点总数为 $n$，故障节点数为 $f$
2. 正确节点数为 $n - f$
3. 为了保证系统正常工作，正确节点必须构成多数
4. 因此 $n - f > f$
5. 即 $n > 2f$
6. 由于 $n$ 是整数，所以 $n \geq 2f + 1$

**定理 4.2** (消息传递可靠性)
在异步网络中，如果消息可能丢失，则无法保证消息传递的可靠性。

**证明**：

1. 假设存在可靠的异步消息传递协议
2. 考虑两个节点 $A$ 和 $B$ 之间的通信
3. $A$ 发送消息 $m$ 给 $B$
4. 如果消息丢失，$A$ 无法确定 $B$ 是否收到消息
5. $A$ 必须重传消息或超时
6. 但重传可能导致重复消息，超时可能导致消息丢失
7. 因此无法保证消息传递的可靠性

### 4.2 一致性算法证明

**定理 4.3** (Paxos活性)
Paxos算法保证活性：如果提议者提议值，则最终会选择一个值。

**证明**：

1. 设提议者 $P$ 提议值 $v$
2. 如果 $P$ 获得多数Promise，则进入Accept阶段
3. 如果 $P$ 未获得多数Promise，则增加提案编号重试
4. 由于提案编号单调递增，最终会选择一个提案编号
5. 一旦选择了提案编号，对应的值就会被选择
6. 因此最终会选择一个值

**定理 4.4** (Raft领导者唯一性)
Raft算法保证每个任期最多有一个领导者。

**证明**：

1. 设任期 $T$ 有两个领导者 $L_1$ 和 $L_2$
2. 根据算法，领导者必须获得多数票
3. 设 $S_1$ 和 $S_2$ 分别是投票给 $L_1$ 和 $L_2$ 的节点集合
4. 由于 $|S_1| > n/2$ 且 $|S_2| > n/2$，$S_1 \cap S_2 \neq \emptyset$
5. 设 $n \in S_1 \cap S_2$，则 $n$ 投票给了两个候选人
6. 这与Raft的投票规则矛盾
7. 因此每个任期最多有一个领导者

## 🔗 相关概念

- [并发理论](02-07-并发理论.md)
- [网络理论](02-09-网络理论.md)
- [算法理论](02-01-算法理论.md)
- [数据结构理论](02-02-数据结构理论.md)

## 📚 参考文献

1. Lamport, L. (1998). The Part-Time Parliament
2. Ongaro, D., & Ousterhout, J. (2014). In Search of an Understandable Consensus Algorithm
3. Stoica, I., et al. (2001). Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications
4. Fischer, M. J., Lynch, N. A., & Paterson, M. S. (1985). Impossibility of Distributed Consensus with One Faulty Process
5. Chandra, T. D., & Toueg, S. (1996). Unreliable Failure Detectors for Reliable Distributed Systems

---

*分布式系统理论为构建高可用、高可扩展的软件系统提供了理论基础，通过形式化的数学定义和严格的证明，我们建立了分布式系统的完整理论体系。*
