# 01. 算法与数据结构

## 1.1 算法基础

### 1.1.1 算法定义

**定义 1.1.1** (算法): 算法是解决特定问题的有限步骤序列。

**定义 1.1.2** (算法正确性): 算法 $A$ 对于输入 $I$ 是正确的，当且仅当 $A(I)$ 产生期望的输出。

**定义 1.1.3** (算法终止性): 算法 $A$ 是终止的，当且仅当对于所有有效输入，$A$ 在有限步后停止。

### 1.1.2 复杂度分析

**定义 1.1.4** (时间复杂度): 算法的时间复杂度 $T(n)$ 是输入规模 $n$ 的函数，表示算法执行所需的基本操作次数。

**定义 1.1.5** (空间复杂度): 算法的空间复杂度 $S(n)$ 是输入规模 $n$ 的函数，表示算法执行所需的额外存储空间。

**渐近记号**:

- $O(f(n))$: 上界
- $\Omega(f(n))$: 下界  
- $\Theta(f(n))$: 紧界

## 1.2 数据结构基础

### 1.2.1 抽象数据类型

**定义 1.2.1** (ADT): 抽象数据类型是数据对象和操作的数学规范。

**定义 1.2.2** (接口): ADT的接口定义了可执行的操作集合。

### 1.2.2 基本数据结构

**线性结构**:

- 数组: $O(1)$ 访问，$O(n)$ 插入/删除
- 链表: $O(n)$ 访问，$O(1)$ 插入/删除
- 栈: LIFO原则
- 队列: FIFO原则

**树形结构**:

- 二叉树: 每个节点最多两个子节点
- 二叉搜索树: 左子树 < 根 < 右子树
- 平衡树: 高度平衡的搜索树

**图结构**:

- 有向图: $G = (V, E)$
- 无向图: 边无方向
- 加权图: 边有权重

## 1.3 Python实现

### 1.3.1 基础数据结构

```python
from typing import TypeVar, Generic, Optional, List, Dict, Any
from dataclasses import dataclass
from abc import ABC, abstractmethod
import heapq
from collections import deque

T = TypeVar('T')

class Node(Generic[T]):
    """链表节点"""
    def __init__(self, data: T):
        self.data = data
        self.next: Optional[Node[T]] = None

class LinkedList(Generic[T]):
    """链表实现"""
    
    def __init__(self):
        self.head: Optional[Node[T]] = None
        self.size = 0
    
    def insert_at_beginning(self, data: T):
        """在开头插入"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    def insert_at_end(self, data: T):
        """在末尾插入"""
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        self.size += 1
    
    def delete(self, data: T) -> bool:
        """删除指定元素"""
        if not self.head:
            return False
        
        if self.head.data == data:
            self.head = self.head.next
            self.size -= 1
            return True
        
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                self.size -= 1
                return True
            current = current.next
        
        return False
    
    def search(self, data: T) -> Optional[Node[T]]:
        """搜索元素"""
        current = self.head
        while current:
            if current.data == data:
                return current
            current = current.next
        return None
    
    def __str__(self):
        result = []
        current = self.head
        while current:
            result.append(str(current.data))
            current = current.next
        return " -> ".join(result)

class Stack(Generic[T]):
    """栈实现"""
    
    def __init__(self):
        self.items: List[T] = []
    
    def push(self, item: T):
        """入栈"""
        self.items.append(item)
    
    def pop(self) -> Optional[T]:
        """出栈"""
        return self.items.pop() if self.items else None
    
    def peek(self) -> Optional[T]:
        """查看栈顶"""
        return self.items[-1] if self.items else None
    
    def is_empty(self) -> bool:
        """是否为空"""
        return len(self.items) == 0
    
    def size(self) -> int:
        """栈大小"""
        return len(self.items)

class Queue(Generic[T]):
    """队列实现"""
    
    def __init__(self):
        self.items: deque[T] = deque()
    
    def enqueue(self, item: T):
        """入队"""
        self.items.append(item)
    
    def dequeue(self) -> Optional[T]:
        """出队"""
        return self.items.popleft() if self.items else None
    
    def front(self) -> Optional[T]:
        """查看队首"""
        return self.items[0] if self.items else None
    
    def is_empty(self) -> bool:
        """是否为空"""
        return len(self.items) == 0
    
    def size(self) -> int:
        """队列大小"""
        return len(self.items)

# 使用示例
def demonstrate_basic_structures():
    """演示基础数据结构"""
    # 链表
    linked_list = LinkedList[int]()
    linked_list.insert_at_end(1)
    linked_list.insert_at_end(2)
    linked_list.insert_at_end(3)
    print(f"LinkedList: {linked_list}")
    
    # 栈
    stack = Stack[int]()
    stack.push(1)
    stack.push(2)
    stack.push(3)
    print(f"Stack pop: {stack.pop()}")
    print(f"Stack peek: {stack.peek()}")
    
    # 队列
    queue = Queue[int]()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)
    print(f"Queue dequeue: {queue.dequeue()}")
    print(f"Queue front: {queue.front()}")

if __name__ == "__main__":
    demonstrate_basic_structures()
```

### 1.3.2 树形数据结构

```python
from typing import TypeVar, Generic, Optional, List
from dataclasses import dataclass

T = TypeVar('T')

class TreeNode(Generic[T]):
    """树节点"""
    def __init__(self, data: T):
        self.data = data
        self.left: Optional[TreeNode[T]] = None
        self.right: Optional[TreeNode[T]] = None

class BinaryTree(Generic[T]):
    """二叉树"""
    
    def __init__(self):
        self.root: Optional[TreeNode[T]] = None
    
    def insert(self, data: T):
        """插入节点"""
        if not self.root:
            self.root = TreeNode(data)
            return
        
        queue = [self.root]
        while queue:
            node = queue.pop(0)
            if not node.left:
                node.left = TreeNode(data)
                return
            if not node.right:
                node.right = TreeNode(data)
                return
            queue.append(node.left)
            queue.append(node.right)
    
    def inorder_traversal(self) -> List[T]:
        """中序遍历"""
        result = []
        self._inorder_helper(self.root, result)
        return result
    
    def _inorder_helper(self, node: Optional[TreeNode[T]], result: List[T]):
        if node:
            self._inorder_helper(node.left, result)
            result.append(node.data)
            self._inorder_helper(node.right, result)
    
    def preorder_traversal(self) -> List[T]:
        """前序遍历"""
        result = []
        self._preorder_helper(self.root, result)
        return result
    
    def _preorder_helper(self, node: Optional[TreeNode[T]], result: List[T]):
        if node:
            result.append(node.data)
            self._preorder_helper(node.left, result)
            self._preorder_helper(node.right, result)
    
    def postorder_traversal(self) -> List[T]:
        """后序遍历"""
        result = []
        self._postorder_helper(self.root, result)
        return result
    
    def _postorder_helper(self, node: Optional[TreeNode[T]], result: List[T]):
        if node:
            self._postorder_helper(node.left, result)
            self._postorder_helper(node.right, result)
            result.append(node.data)

class BinarySearchTree(Generic[T]):
    """二叉搜索树"""
    
    def __init__(self):
        self.root: Optional[TreeNode[T]] = None
    
    def insert(self, data: T):
        """插入节点"""
        self.root = self._insert_helper(self.root, data)
    
    def _insert_helper(self, node: Optional[TreeNode[T]], data: T) -> TreeNode[T]:
        if not node:
            return TreeNode(data)
        
        if data < node.data:
            node.left = self._insert_helper(node.left, data)
        elif data > node.data:
            node.right = self._insert_helper(node.right, data)
        
        return node
    
    def search(self, data: T) -> Optional[TreeNode[T]]:
        """搜索节点"""
        return self._search_helper(self.root, data)
    
    def _search_helper(self, node: Optional[TreeNode[T]], data: T) -> Optional[TreeNode[T]]:
        if not node or node.data == data:
            return node
        
        if data < node.data:
            return self._search_helper(node.left, data)
        return self._search_helper(node.right, data)
    
    def delete(self, data: T):
        """删除节点"""
        self.root = self._delete_helper(self.root, data)
    
    def _delete_helper(self, node: Optional[TreeNode[T]], data: T) -> Optional[TreeNode[T]]:
        if not node:
            return node
        
        if data < node.data:
            node.left = self._delete_helper(node.left, data)
        elif data > node.data:
            node.right = self._delete_helper(node.right, data)
        else:
            # 找到要删除的节点
            if not node.left:
                return node.right
            elif not node.right:
                return node.left
            
            # 有两个子节点，找到右子树的最小值
            min_node = self._find_min(node.right)
            node.data = min_node.data
            node.right = self._delete_helper(node.right, min_node.data)
        
        return node
    
    def _find_min(self, node: TreeNode[T]) -> TreeNode[T]:
        while node.left:
            node = node.left
        return node

# 使用示例
def demonstrate_tree_structures():
    """演示树形数据结构"""
    # 二叉树
    tree = BinaryTree[int]()
    for i in [1, 2, 3, 4, 5]:
        tree.insert(i)
    
    print(f"Inorder: {tree.inorder_traversal()}")
    print(f"Preorder: {tree.preorder_traversal()}")
    print(f"Postorder: {tree.postorder_traversal()}")
    
    # 二叉搜索树
    bst = BinarySearchTree[int]()
    for i in [5, 3, 7, 1, 4, 6, 8]:
        bst.insert(i)
    
    print(f"BST inorder: {bst.inorder_traversal()}")
    
    # 搜索
    found = bst.search(4)
    print(f"Found 4: {found.data if found else None}")
    
    # 删除
    bst.delete(3)
    print(f"After deleting 3: {bst.inorder_traversal()}")

if __name__ == "__main__":
    demonstrate_tree_structures()
```

### 1.3.3 图数据结构

```python
from typing import TypeVar, Generic, Dict, List, Set, Optional, Tuple
from dataclasses import dataclass
from collections import defaultdict

T = TypeVar('T')

class Graph(Generic[T]):
    """图实现"""
    
    def __init__(self, directed: bool = False):
        self.directed = directed
        self.adjacency_list: Dict[T, List[T]] = defaultdict(list)
        self.vertices: Set[T] = set()
    
    def add_vertex(self, vertex: T):
        """添加顶点"""
        self.vertices.add(vertex)
    
    def add_edge(self, from_vertex: T, to_vertex: T):
        """添加边"""
        self.add_vertex(from_vertex)
        self.add_vertex(to_vertex)
        self.adjacency_list[from_vertex].append(to_vertex)
        
        if not self.directed:
            self.adjacency_list[to_vertex].append(from_vertex)
    
    def remove_edge(self, from_vertex: T, to_vertex: T):
        """删除边"""
        if from_vertex in self.adjacency_list:
            self.adjacency_list[from_vertex] = [
                v for v in self.adjacency_list[from_vertex] if v != to_vertex
            ]
        
        if not self.directed and to_vertex in self.adjacency_list:
            self.adjacency_list[to_vertex] = [
                v for v in self.adjacency_list[to_vertex] if v != from_vertex
            ]
    
    def get_neighbors(self, vertex: T) -> List[T]:
        """获取邻居"""
        return self.adjacency_list.get(vertex, [])
    
    def dfs(self, start: T) -> List[T]:
        """深度优先搜索"""
        visited = set()
        result = []
        
        def dfs_helper(vertex: T):
            if vertex in visited:
                return
            visited.add(vertex)
            result.append(vertex)
            for neighbor in self.get_neighbors(vertex):
                dfs_helper(neighbor)
        
        dfs_helper(start)
        return result
    
    def bfs(self, start: T) -> List[T]:
        """广度优先搜索"""
        visited = set()
        result = []
        queue = [start]
        visited.add(start)
        
        while queue:
            vertex = queue.pop(0)
            result.append(vertex)
            
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return result
    
    def has_cycle(self) -> bool:
        """检测环"""
        visited = set()
        rec_stack = set()
        
        def has_cycle_helper(vertex: T) -> bool:
            visited.add(vertex)
            rec_stack.add(vertex)
            
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    if has_cycle_helper(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(vertex)
            return False
        
        for vertex in self.vertices:
            if vertex not in visited:
                if has_cycle_helper(vertex):
                    return True
        
        return False

class WeightedGraph(Generic[T]):
    """加权图"""
    
    def __init__(self, directed: bool = False):
        self.directed = directed
        self.adjacency_list: Dict[T, List[Tuple[T, float]]] = defaultdict(list)
        self.vertices: Set[T] = set()
    
    def add_vertex(self, vertex: T):
        """添加顶点"""
        self.vertices.add(vertex)
    
    def add_edge(self, from_vertex: T, to_vertex: T, weight: float):
        """添加加权边"""
        self.add_vertex(from_vertex)
        self.add_vertex(to_vertex)
        self.adjacency_list[from_vertex].append((to_vertex, weight))
        
        if not self.directed:
            self.adjacency_list[to_vertex].append((from_vertex, weight))
    
    def dijkstra(self, start: T) -> Dict[T, float]:
        """Dijkstra最短路径算法"""
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[start] = 0
        pq = [(0, start)]
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_distance > distances[current_vertex]:
                continue
            
            for neighbor, weight in self.adjacency_list[current_vertex]:
                distance = current_distance + weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        
        return distances

# 使用示例
def demonstrate_graph_structures():
    """演示图数据结构"""
    # 无向图
    graph = Graph[int]()
    graph.add_edge(0, 1)
    graph.add_edge(0, 2)
    graph.add_edge(1, 2)
    graph.add_edge(2, 3)
    graph.add_edge(3, 4)
    
    print(f"DFS from 0: {graph.dfs(0)}")
    print(f"BFS from 0: {graph.bfs(0)}")
    print(f"Has cycle: {graph.has_cycle()}")
    
    # 加权图
    wgraph = WeightedGraph[int]()
    wgraph.add_edge(0, 1, 4)
    wgraph.add_edge(0, 2, 2)
    wgraph.add_edge(1, 2, 1)
    wgraph.add_edge(1, 3, 5)
    wgraph.add_edge(2, 3, 8)
    wgraph.add_edge(2, 4, 10)
    wgraph.add_edge(3, 4, 2)
    
    distances = wgraph.dijkstra(0)
    print(f"Shortest distances from 0: {distances}")

if __name__ == "__main__":
    demonstrate_graph_structures()
```

## 1.4 算法分析

### 1.4.1 排序算法

```python
def bubble_sort(arr: List[int]) -> List[int]:
    """冒泡排序 - O(n²)"""
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def merge_sort(arr: List[int]) -> List[int]:
    """归并排序 - O(n log n)"""
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left: List[int], right: List[int]) -> List[int]:
    """合并两个有序数组"""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

def quick_sort(arr: List[int]) -> List[int]:
    """快速排序 - O(n log n) 平均情况"""
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# 使用示例
def demonstrate_sorting():
    """演示排序算法"""
    arr = [64, 34, 25, 12, 22, 11, 90]
    
    print(f"Original: {arr}")
    print(f"Bubble sort: {bubble_sort(arr.copy())}")
    print(f"Merge sort: {merge_sort(arr.copy())}")
    print(f"Quick sort: {quick_sort(arr.copy())}")

if __name__ == "__main__":
    demonstrate_sorting()
```

### 1.4.2 搜索算法

```python
def linear_search(arr: List[int], target: int) -> Optional[int]:
    """线性搜索 - O(n)"""
    for i, value in enumerate(arr):
        if value == target:
            return i
    return None

def binary_search(arr: List[int], target: int) -> Optional[int]:
    """二分搜索 - O(log n)"""
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return None

def depth_first_search(graph: Graph[T], start: T) -> List[T]:
    """深度优先搜索"""
    return graph.dfs(start)

def breadth_first_search(graph: Graph[T], start: T) -> List[T]:
    """广度优先搜索"""
    return graph.bfs(start)

# 使用示例
def demonstrate_searching():
    """演示搜索算法"""
    arr = [1, 3, 5, 7, 9, 11, 13, 15]
    
    print(f"Array: {arr}")
    print(f"Linear search for 7: {linear_search(arr, 7)}")
    print(f"Binary search for 7: {binary_search(arr, 7)}")
    print(f"Linear search for 10: {linear_search(arr, 10)}")
    print(f"Binary search for 10: {binary_search(arr, 10)}")

if __name__ == "__main__":
    demonstrate_searching()
```

## 1.5 复杂度分析

### 1.5.1 时间复杂度

| 算法 | 最好情况 | 平均情况 | 最坏情况 |
|------|----------|----------|----------|
| 冒泡排序 | O(n) | O(n²) | O(n²) |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) |
| 快速排序 | O(n log n) | O(n log n) | O(n²) |
| 线性搜索 | O(1) | O(n) | O(n) |
| 二分搜索 | O(1) | O(log n) | O(log n) |

### 1.5.2 空间复杂度

| 数据结构 | 空间复杂度 |
|----------|------------|
| 数组 | O(n) |
| 链表 | O(n) |
| 栈 | O(n) |
| 队列 | O(n) |
| 二叉树 | O(n) |
| 图 | O(V + E) |

## 1.6 总结

算法与数据结构是计算机科学的核心基础。通过形式化定义、Python实现和复杂度分析，我们建立了从理论到实践的完整知识体系。
