# 02.01 ç®—æ³•ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç®—æ³•ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒï¼Œç ”ç©¶ç®—æ³•çš„è®¾è®¡ã€åˆ†æå’Œä¼˜åŒ–ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰ç®—æ³•ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
ç®—æ³•æ˜¯ä¸€ä¸ªæœ‰é™çš„è®¡ç®—è¿‡ç¨‹ï¼š$A: I \rightarrow O$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯è¾“å…¥é›†åˆ
- $O$ æ˜¯è¾“å‡ºé›†åˆ
- $A$ åœ¨æœ‰é™æ­¥éª¤å†…ç»ˆæ­¢

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, Callable, Any, List, Dict
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import time

I = TypeVar('I')  # è¾“å…¥ç±»å‹
O = TypeVar('O')  # è¾“å‡ºç±»å‹

class AlgorithmType(Enum):
    SEARCHING = "searching"
    SORTING = "sorting"
    GRAPH = "graph"
    DYNAMIC_PROGRAMMING = "dynamic_programming"
    GREEDY = "greedy"
    DIVIDE_AND_CONQUER = "divide_and_conquer"

@dataclass
class AlgorithmResult:
    """ç®—æ³•æ‰§è¡Œç»“æœ"""
    output: O
    execution_time: float
    steps_count: int
    memory_usage: int

class Algorithm(ABC):
    """ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, algorithm_type: AlgorithmType):
        self.name = name
        self.algorithm_type = algorithm_type
        self.steps_count = 0
    
    @abstractmethod
    def execute(self, input_data: I) -> O:
        """æ‰§è¡Œç®—æ³•"""
        pass
    
    def run_with_metrics(self, input_data: I) -> AlgorithmResult:
        """è¿è¡Œç®—æ³•å¹¶æ”¶é›†æŒ‡æ ‡"""
        start_time = time.time()
        start_memory = self._get_memory_usage()
        
        self.steps_count = 0
        result = self.execute(input_data)
        
        end_time = time.time()
        end_memory = self._get_memory_usage()
        
        return AlgorithmResult(
            output=result,
            execution_time=end_time - start_time,
            steps_count=self.steps_count,
            memory_usage=end_memory - start_memory
        )
    
    def _get_memory_usage(self) -> int:
        """è·å–å†…å­˜ä½¿ç”¨é‡ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        import sys
        return sys.getsizeof(self)
    
    def _increment_steps(self):
        """å¢åŠ æ­¥éª¤è®¡æ•°"""
        self.steps_count += 1

# ç¤ºä¾‹ï¼šçº¿æ€§æœç´¢ç®—æ³•
class LinearSearch(Algorithm):
    """çº¿æ€§æœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Linear Search", AlgorithmType.SEARCHING)
    
    def execute(self, input_data: tuple[List[Any], Any]) -> int:
        """æ‰§è¡Œçº¿æ€§æœç´¢"""
        array, target = input_data
        
        for i, element in enumerate(array):
            self._increment_steps()
            if element == target:
                return i
        
        return -1

# ç¤ºä¾‹ï¼šäºŒåˆ†æœç´¢ç®—æ³•
class BinarySearch(Algorithm):
    """äºŒåˆ†æœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Binary Search", AlgorithmType.SEARCHING)
    
    def execute(self, input_data: tuple[List[Any], Any]) -> int:
        """æ‰§è¡ŒäºŒåˆ†æœç´¢"""
        array, target = input_data
        left, right = 0, len(array) - 1
        
        while left <= right:
            self._increment_steps()
            mid = (left + right) // 2
            
            if array[mid] == target:
                return mid
            elif array[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1

# ç¤ºä¾‹ï¼šå†’æ³¡æ’åºç®—æ³•
class BubbleSort(Algorithm):
    """å†’æ³¡æ’åºç®—æ³•"""
    
    def __init__(self):
        super().__init__("Bubble Sort", AlgorithmType.SORTING)
    
    def execute(self, input_data: List[Any]) -> List[Any]:
        """æ‰§è¡Œå†’æ³¡æ’åº"""
        array = input_data.copy()
        n = len(array)
        
        for i in range(n):
            for j in range(0, n - i - 1):
                self._increment_steps()
                if array[j] > array[j + 1]:
                    array[j], array[j + 1] = array[j + 1], array[j]
        
        return array

# ç¤ºä¾‹ï¼šå¿«é€Ÿæ’åºç®—æ³•
class QuickSort(Algorithm):
    """å¿«é€Ÿæ’åºç®—æ³•"""
    
    def __init__(self):
        super().__init__("Quick Sort", AlgorithmType.SORTING)
    
    def execute(self, input_data: List[Any]) -> List[Any]:
        """æ‰§è¡Œå¿«é€Ÿæ’åº"""
        array = input_data.copy()
        return self._quicksort(array)
    
    def _quicksort(self, array: List[Any]) -> List[Any]:
        """å¿«é€Ÿæ’åºé€’å½’å®ç°"""
        if len(array) <= 1:
            return array
        
        self._increment_steps()
        pivot = array[len(array) // 2]
        left = [x for x in array if x < pivot]
        middle = [x for x in array if x == pivot]
        right = [x for x in array if x > pivot]
        
        return self._quicksort(left) + middle + self._quicksort(right)

# ç¤ºä¾‹ï¼šåŠ¨æ€è§„åˆ’ç®—æ³•
class FibonacciDP(Algorithm):
    """æ–æ³¢é‚£å¥‘åŠ¨æ€è§„åˆ’ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Fibonacci DP", AlgorithmType.DYNAMIC_PROGRAMMING)
        self.memo = {}
    
    def execute(self, input_data: int) -> int:
        """æ‰§è¡Œæ–æ³¢é‚£å¥‘åŠ¨æ€è§„åˆ’"""
        return self._fibonacci(input_data)
    
    def _fibonacci(self, n: int) -> int:
        """æ–æ³¢é‚£å¥‘é€’å½’å®ç°"""
        if n in self.memo:
            return self.memo[n]
        
        self._increment_steps()
        
        if n <= 1:
            result = n
        else:
            result = self._fibonacci(n - 1) + self._fibonacci(n - 2)
        
        self.memo[n] = result
        return result

# ç¤ºä¾‹ï¼šè´ªå¿ƒç®—æ³•
class ActivitySelection(Algorithm):
    """æ´»åŠ¨é€‰æ‹©è´ªå¿ƒç®—æ³•"""
    
    def __init__(self):
        super().__init__("Activity Selection", AlgorithmType.GREEDY)
    
    def execute(self, input_data: List[tuple[int, int]]) -> List[tuple[int, int]]:
        """æ‰§è¡Œæ´»åŠ¨é€‰æ‹©è´ªå¿ƒç®—æ³•"""
        activities = sorted(input_data, key=lambda x: x[1])  # æŒ‰ç»“æŸæ—¶é—´æ’åº
        selected = []
        last_end_time = 0
        
        for activity in activities:
            self._increment_steps()
            if activity[0] >= last_end_time:
                selected.append(activity)
                last_end_time = activity[1]
        
        return selected

# ç¤ºä¾‹ï¼šåˆ†æ²»ç®—æ³•
class MergeSort(Algorithm):
    """å½’å¹¶æ’åºåˆ†æ²»ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Merge Sort", AlgorithmType.DIVIDE_AND_CONQUER)
    
    def execute(self, input_data: List[Any]) -> List[Any]:
        """æ‰§è¡Œå½’å¹¶æ’åº"""
        array = input_data.copy()
        return self._merge_sort(array)
    
    def _merge_sort(self, array: List[Any]) -> List[Any]:
        """å½’å¹¶æ’åºé€’å½’å®ç°"""
        if len(array) <= 1:
            return array
        
        self._increment_steps()
        mid = len(array) // 2
        left = self._merge_sort(array[:mid])
        right = self._merge_sort(array[mid:])
        
        return self._merge(left, right)
    
    def _merge(self, left: List[Any], right: List[Any]) -> List[Any]:
        """åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result

# ç¤ºä¾‹ï¼šç®—æ³•æ¯”è¾ƒ
def compare_algorithms():
    """æ¯”è¾ƒä¸åŒç®—æ³•çš„æ€§èƒ½"""
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        BubbleSort(),
        QuickSort(),
        FibonacciDP(),
        ActivitySelection(),
        MergeSort()
    ]
    
    # æµ‹è¯•æ•°æ®
    test_cases = {
        "Linear Search": ([1, 2, 3, 4, 5], 3),
        "Binary Search": ([1, 2, 3, 4, 5], 3),
        "Bubble Sort": [5, 2, 4, 1, 3],
        "Quick Sort": [5, 2, 4, 1, 3],
        "Fibonacci DP": 10,
        "Activity Selection": [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8)],
        "Merge Sort": [5, 2, 4, 1, 3]
    }
    
    print("=== ç®—æ³•æ€§èƒ½æ¯”è¾ƒ ===")
    
    for algorithm in algorithms:
        if algorithm.name in test_cases:
            test_data = test_cases[algorithm.name]
            result = algorithm.run_with_metrics(test_data)
            
            print(f"\n{algorithm.name}:")
            print(f"  è¾“å‡º: {result.output}")
            print(f"  æ‰§è¡Œæ—¶é—´: {result.execution_time:.6f}ç§’")
            print(f"  æ­¥éª¤æ•°: {result.steps_count}")
            print(f"  å†…å­˜ä½¿ç”¨: {result.memory_usage}å­—èŠ‚")
    
    return algorithms

# è¿è¡Œç¤ºä¾‹
algorithm_comparison = compare_algorithms()
```

### 2. ç®—æ³•å¤æ‚åº¦åˆ†æ

#### 2.1 æ—¶é—´å¤æ‚åº¦

**æ•°å­¦å®šä¹‰**ï¼š
æ—¶é—´å¤æ‚åº¦ $T(n)$ è¡¨ç¤ºç®—æ³•æ‰§è¡Œæ—¶é—´ä¸è¾“å…¥è§„æ¨¡ $n$ çš„å…³ç³»ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Callable, List, Dict, Any
import time
import math

class ComplexityAnalyzer:
    """ç®—æ³•å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.complexity_classes = {
            'O(1)': lambda n: 1,
            'O(log n)': lambda n: math.log(n),
            'O(n)': lambda n: n,
            'O(n log n)': lambda n: n * math.log(n),
            'O(nÂ²)': lambda n: n ** 2,
            'O(nÂ³)': lambda n: n ** 3,
            'O(2â¿)': lambda n: 2 ** n,
            'O(n!)': lambda n: math.factorial(n)
        }
    
    def measure_time_complexity(self, algorithm: Algorithm, 
                              input_sizes: List[int]) -> Dict[int, float]:
        """æµ‹é‡ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦"""
        measurements = {}
        
        for size in input_sizes:
            # ç”Ÿæˆæµ‹è¯•æ•°æ®
            test_data = self._generate_test_data(algorithm, size)
            
            # æµ‹é‡æ‰§è¡Œæ—¶é—´
            result = algorithm.run_with_metrics(test_data)
            measurements[size] = result.execution_time
        
        return measurements
    
    def _generate_test_data(self, algorithm: Algorithm, size: int) -> Any:
        """ç”Ÿæˆæµ‹è¯•æ•°æ®"""
        if algorithm.algorithm_type == AlgorithmType.SEARCHING:
            array = list(range(size))
            target = size // 2
            return (array, target)
        elif algorithm.algorithm_type == AlgorithmType.SORTING:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
        elif algorithm.algorithm_type == AlgorithmType.DYNAMIC_PROGRAMMING:
            return size
        elif algorithm.algorithm_type == AlgorithmType.GREEDY:
            import random
            activities = []
            for _ in range(size):
                start = random.randint(0, 10)
                end = start + random.randint(1, 5)
                activities.append((start, end))
            return activities
        else:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
    
    def analyze_complexity(self, measurements: Dict[int, float]) -> str:
        """åˆ†æå¤æ‚åº¦"""
        sizes = list(measurements.keys())
        times = list(measurements.values())
        
        if len(sizes) < 2:
            return "æ•°æ®ä¸è¶³ï¼Œæ— æ³•åˆ†æ"
        
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            time_ratio = times[i] / times[i-1]
            growth_rates.append(time_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # ç¡®å®šå¤æ‚åº¦ç±»åˆ«
        if avg_growth < 1.1:
            return "O(1) - å¸¸æ•°æ—¶é—´"
        elif avg_growth < 1.5:
            return "O(log n) - å¯¹æ•°æ—¶é—´"
        elif avg_growth < 2.0:
            return "O(n) - çº¿æ€§æ—¶é—´"
        elif avg_growth < 3.0:
            return "O(n log n) - çº¿æ€§å¯¹æ•°æ—¶é—´"
        elif avg_growth < 10.0:
            return "O(nÂ²) - å¹³æ–¹æ—¶é—´"
        elif avg_growth < 100.0:
            return "O(nÂ³) - ç«‹æ–¹æ—¶é—´"
        else:
            return "O(2â¿) æˆ–æ›´é«˜ - æŒ‡æ•°æ—¶é—´"
    
    def compare_complexities(self, algorithms: List[Algorithm], 
                           max_size: int = 100) -> Dict[str, str]:
        """æ¯”è¾ƒå¤šä¸ªç®—æ³•çš„å¤æ‚åº¦"""
        input_sizes = [10, 20, 50, 100][:max_size//25]
        results = {}
        
        for algorithm in algorithms:
            measurements = self.measure_time_complexity(algorithm, input_sizes)
            complexity = self.analyze_complexity(measurements)
            results[algorithm.name] = complexity
        
        return results

# ç¤ºä¾‹ï¼šå¤æ‚åº¦åˆ†æ
def demonstrate_complexity_analysis():
    """æ¼”ç¤ºå¤æ‚åº¦åˆ†æ"""
    analyzer = ComplexityAnalyzer()
    
    # æµ‹è¯•ç®—æ³•
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        BubbleSort(),
        QuickSort(),
        MergeSort()
    ]
    
    print("=== ç®—æ³•å¤æ‚åº¦åˆ†æ ===")
    
    # åˆ†ææ¯ä¸ªç®—æ³•çš„å¤æ‚åº¦
    complexities = analyzer.compare_complexities(algorithms, max_size=50)
    
    for algorithm_name, complexity in complexities.items():
        print(f"{algorithm_name}: {complexity}")
    
    return analyzer

# è¿è¡Œç¤ºä¾‹
complexity_analysis = demonstrate_complexity_analysis()
```

#### 2.2 ç©ºé—´å¤æ‚åº¦

**æ•°å­¦å®šä¹‰**ï¼š
ç©ºé—´å¤æ‚åº¦ $S(n)$ è¡¨ç¤ºç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰€éœ€çš„æœ€å¤§å†…å­˜ç©ºé—´ã€‚

**Pythonå®ç°**ï¼š

```python
import sys
import tracemalloc

class SpaceComplexityAnalyzer:
    """ç©ºé—´å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.memory_measurements = {}
    
    def measure_space_complexity(self, algorithm: Algorithm, 
                               input_sizes: List[int]) -> Dict[int, int]:
        """æµ‹é‡ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦"""
        measurements = {}
        
        for size in input_sizes:
            # ç”Ÿæˆæµ‹è¯•æ•°æ®
            test_data = self._generate_test_data(algorithm, size)
            
            # å¼€å§‹å†…å­˜è·Ÿè¸ª
            tracemalloc.start()
            
            # æ‰§è¡Œç®—æ³•
            result = algorithm.run_with_metrics(test_data)
            
            # è·å–å†…å­˜ä½¿ç”¨
            current, peak = tracemalloc.get_traced_memory()
            tracemalloc.stop()
            
            measurements[size] = peak
        
        return measurements
    
    def _generate_test_data(self, algorithm: Algorithm, size: int) -> Any:
        """ç”Ÿæˆæµ‹è¯•æ•°æ®ï¼ˆä¸æ—¶é—´å¤æ‚åº¦åˆ†æç›¸åŒï¼‰"""
        if algorithm.algorithm_type == AlgorithmType.SEARCHING:
            array = list(range(size))
            target = size // 2
            return (array, target)
        elif algorithm.algorithm_type == AlgorithmType.SORTING:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
        else:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
    
    def analyze_space_complexity(self, measurements: Dict[int, int]) -> str:
        """åˆ†æç©ºé—´å¤æ‚åº¦"""
        sizes = list(measurements.keys())
        memory = list(measurements.values())
        
        if len(sizes) < 2:
            return "æ•°æ®ä¸è¶³ï¼Œæ— æ³•åˆ†æ"
        
        # è®¡ç®—å†…å­˜å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            memory_ratio = memory[i] / memory[i-1]
            growth_rates.append(memory_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # ç¡®å®šç©ºé—´å¤æ‚åº¦ç±»åˆ«
        if avg_growth < 1.1:
            return "O(1) - å¸¸æ•°ç©ºé—´"
        elif avg_growth < 1.5:
            return "O(log n) - å¯¹æ•°ç©ºé—´"
        elif avg_growth < 2.0:
            return "O(n) - çº¿æ€§ç©ºé—´"
        elif avg_growth < 3.0:
            return "O(n log n) - çº¿æ€§å¯¹æ•°ç©ºé—´"
        elif avg_growth < 10.0:
            return "O(nÂ²) - å¹³æ–¹ç©ºé—´"
        else:
            return "O(nÂ³) æˆ–æ›´é«˜ - ç«‹æ–¹æˆ–æ›´é«˜ç©ºé—´"

# ç¤ºä¾‹ï¼šç©ºé—´å¤æ‚åº¦åˆ†æ
def demonstrate_space_complexity():
    """æ¼”ç¤ºç©ºé—´å¤æ‚åº¦åˆ†æ"""
    analyzer = SpaceComplexityAnalyzer()
    
    # æµ‹è¯•ç®—æ³•
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        BubbleSort(),
        QuickSort(),
        MergeSort()
    ]
    
    print("=== ç®—æ³•ç©ºé—´å¤æ‚åº¦åˆ†æ ===")
    
    input_sizes = [10, 20, 50]
    
    for algorithm in algorithms:
        measurements = analyzer.measure_space_complexity(algorithm, input_sizes)
        complexity = analyzer.analyze_space_complexity(measurements)
        
        print(f"{algorithm.name}: {complexity}")
        print(f"  å†…å­˜æµ‹é‡: {measurements}")
    
    return analyzer

# è¿è¡Œç¤ºä¾‹
space_complexity_analysis = demonstrate_space_complexity()
```

### 3. ç®—æ³•è®¾è®¡æ¨¡å¼

#### 3.1 åˆ†æ²»æ¨¡å¼

**æ•°å­¦å®šä¹‰**ï¼š
åˆ†æ²»ç®—æ³•å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼š$T(n) = aT(n/b) + f(n)$

**Pythonå®ç°**ï¼š

```python
class DivideAndConquerPattern:
    """åˆ†æ²»æ¨¡å¼"""
    
    @staticmethod
    def solve(problem: Any, divide_func: Callable, 
              conquer_func: Callable, combine_func: Callable) -> Any:
        """åˆ†æ²»ç®—æ³•æ¨¡æ¿"""
        # åŸºæœ¬æƒ…å†µ
        if conquer_func(problem):
            return conquer_func(problem)
        
        # åˆ†è§£
        subproblems = divide_func(problem)
        
        # é€’å½’è§£å†³
        solutions = []
        for subproblem in subproblems:
            solution = DivideAndConquerPattern.solve(
                subproblem, divide_func, conquer_func, combine_func
            )
            solutions.append(solution)
        
        # åˆå¹¶
        return combine_func(solutions)

# ç¤ºä¾‹ï¼šåˆ†æ²»æ¨¡å¼åº”ç”¨
def demonstrate_divide_and_conquer():
    """æ¼”ç¤ºåˆ†æ²»æ¨¡å¼"""
    # å½’å¹¶æ’åºçš„åˆ†æ²»å®ç°
    def divide(array: List[int]) -> List[List[int]]:
        mid = len(array) // 2
        return [array[:mid], array[mid:]]
    
    def conquer(array: List[int]) -> bool:
        return len(array) <= 1
    
    def conquer_simple(array: List[int]) -> List[int]:
        return array
    
    def combine(solutions: List[List[int]]) -> List[int]:
        if len(solutions) != 2:
            return solutions[0] if solutions else []
        
        left, right = solutions
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    # æµ‹è¯•
    test_array = [5, 2, 4, 1, 3]
    result = DivideAndConquerPattern.solve(
        test_array, divide, conquer, combine
    )
    
    print("åˆ†æ²»æ¨¡å¼ç¤ºä¾‹:")
    print(f"åŸå§‹æ•°ç»„: {test_array}")
    print(f"æ’åºç»“æœ: {result}")
    
    return result

# è¿è¡Œç¤ºä¾‹
divide_conquer_demo = demonstrate_divide_and_conquer()
```

#### 3.2 åŠ¨æ€è§„åˆ’æ¨¡å¼

**æ•°å­¦å®šä¹‰**ï¼š
åŠ¨æ€è§„åˆ’åŸºäºæœ€ä¼˜å­ç»“æ„ï¼š$OPT(i) = \max_{j \in S_i} \{OPT(j) + f(i,j)\}$

**Pythonå®ç°**ï¼š

```python
from functools import lru_cache

class DynamicProgrammingPattern:
    """åŠ¨æ€è§„åˆ’æ¨¡å¼"""
    
    @staticmethod
    def solve_with_memoization(problem: Any, 
                              subproblem_func: Callable,
                              base_case_func: Callable,
                              transition_func: Callable) -> Any:
        """å¸¦è®°å¿†åŒ–çš„åŠ¨æ€è§„åˆ’"""
        memo = {}
        
        def dp_solve(current_problem):
            if current_problem in memo:
                return memo[current_problem]
            
            # åŸºæœ¬æƒ…å†µ
            if base_case_func(current_problem):
                result = base_case_func(current_problem)
            else:
                # è·å–å­é—®é¢˜
                subproblems = subproblem_func(current_problem)
                
                # é€’å½’è§£å†³
                sub_results = []
                for subproblem in subproblems:
                    sub_result = dp_solve(subproblem)
                    sub_results.append(sub_result)
                
                # çŠ¶æ€è½¬ç§»
                result = transition_func(current_problem, sub_results)
            
            memo[current_problem] = result
            return result
        
        return dp_solve(problem)
    
    @staticmethod
    def solve_with_tabulation(problem_size: int,
                             base_cases: Dict[int, Any],
                             transition_func: Callable) -> Any:
        """è¡¨æ ¼åŒ–çš„åŠ¨æ€è§„åˆ’"""
        dp_table = {}
        
        # åˆå§‹åŒ–åŸºæœ¬æƒ…å†µ
        for case, value in base_cases.items():
            dp_table[case] = value
        
        # å¡«å……è¡¨æ ¼
        for i in range(max(base_cases.keys()) + 1, problem_size + 1):
            dp_table[i] = transition_func(i, dp_table)
        
        return dp_table[problem_size]

# ç¤ºä¾‹ï¼šåŠ¨æ€è§„åˆ’æ¨¡å¼åº”ç”¨
def demonstrate_dynamic_programming():
    """æ¼”ç¤ºåŠ¨æ€è§„åˆ’æ¨¡å¼"""
    # æ–æ³¢é‚£å¥‘æ•°åˆ—çš„åŠ¨æ€è§„åˆ’
    def fibonacci_subproblems(n: int) -> List[int]:
        return [n - 1, n - 2]
    
    def fibonacci_base_case(n: int) -> bool:
        return n <= 1
    
    def fibonacci_base_case_value(n: int) -> int:
        return n
    
    def fibonacci_transition(n: int, sub_results: List[int]) -> int:
        return sub_results[0] + sub_results[1]
    
    # ä½¿ç”¨è®°å¿†åŒ–
    result1 = DynamicProgrammingPattern.solve_with_memoization(
        10, fibonacci_subproblems, fibonacci_base_case, fibonacci_transition
    )
    
    # ä½¿ç”¨è¡¨æ ¼åŒ–
    base_cases = {0: 0, 1: 1}
    result2 = DynamicProgrammingPattern.solve_with_tabulation(
        10, base_cases, lambda n, table: table[n-1] + table[n-2]
    )
    
    print("åŠ¨æ€è§„åˆ’æ¨¡å¼ç¤ºä¾‹:")
    print(f"æ–æ³¢é‚£å¥‘(10) - è®°å¿†åŒ–: {result1}")
    print(f"æ–æ³¢é‚£å¥‘(10) - è¡¨æ ¼åŒ–: {result2}")
    
    return result1, result2

# è¿è¡Œç¤ºä¾‹
dp_demo = demonstrate_dynamic_programming()
```

## ğŸ“Š ç®—æ³•ç†è®ºæ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µ

1. **ç®—æ³•å®šä¹‰**ï¼šæœ‰é™çš„è®¡ç®—è¿‡ç¨‹
2. **å¤æ‚åº¦åˆ†æ**ï¼šæ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
3. **è®¾è®¡æ¨¡å¼**ï¼šåˆ†æ²»ã€åŠ¨æ€è§„åˆ’ã€è´ªå¿ƒç­‰
4. **ç®—æ³•åˆ†ç±»**ï¼šæœç´¢ã€æ’åºã€å›¾ç®—æ³•ç­‰

### æ•°å­¦å½¢å¼åŒ–

ç®—æ³•ç†è®ºå¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦ç»“æ„è¡¨ç¤ºï¼š

$$AlgorithmTheory = (Definition, Complexity, Design, Analysis)$$

### Pythonå®ç°éªŒè¯

```python
class AlgorithmTheoryValidator:
    """ç®—æ³•ç†è®ºéªŒè¯å™¨"""
    
    def __init__(self):
        self.test_algorithms = [
            LinearSearch(),
            BinarySearch(),
            BubbleSort(),
            QuickSort()
        ]
    
    def validate_algorithm_execution(self) -> bool:
        """éªŒè¯ç®—æ³•æ‰§è¡Œ"""
        test_data = [5, 2, 4, 1, 3]
        expected_sorted = [1, 2, 3, 4, 5]
        
        for algorithm in self.test_algorithms:
            if algorithm.algorithm_type == AlgorithmType.SORTING:
                result = algorithm.execute(test_data)
                if result != expected_sorted:
                    return False
        
        return True
    
    def validate_complexity_analysis(self) -> bool:
        """éªŒè¯å¤æ‚åº¦åˆ†æ"""
        analyzer = ComplexityAnalyzer()
        measurements = analyzer.measure_time_complexity(
            LinearSearch(), [10, 20, 50]
        )
        
        return len(measurements) == 3
    
    def validate_design_patterns(self) -> bool:
        """éªŒè¯è®¾è®¡æ¨¡å¼"""
        # æµ‹è¯•åˆ†æ²»æ¨¡å¼
        test_array = [3, 1, 2]
        result = DivideAndConquerPattern.solve(
            test_array,
            lambda x: [x[:len(x)//2], x[len(x)//2:]],
            lambda x: len(x) <= 1,
            lambda x: x[0] if len(x) == 1 else x[0] + x[1]
        )
        
        return result == [1, 2, 3]
    
    def run_all_tests(self) -> Dict[str, bool]:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        tests = {
            'algorithm_execution': self.validate_algorithm_execution(),
            'complexity_analysis': self.validate_complexity_analysis(),
            'design_patterns': self.validate_design_patterns()
        }
        
        print("=== ç®—æ³•ç†è®ºéªŒè¯ç»“æœ ===")
        for test_name, result in tests.items():
            print(f"{test_name}: {'PASS' if result else 'FAIL'}")
        
        return tests

# ä½¿ç”¨ç¤ºä¾‹
validator = AlgorithmTheoryValidator()
test_results = validator.run_all_tests()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [01.03 å›¾è®ºåŸºç¡€](../01-å½¢å¼ç§‘å­¦/01.03-å›¾è®ºåŸºç¡€.md)
- [02.02 æ•°æ®ç»“æ„ç†è®º](./02.02-æ•°æ®ç»“æ„ç†è®º.md)
- [03.01 è®¾è®¡æ¨¡å¼ç§‘å­¦](../03-å…·ä½“ç§‘å­¦/03.01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md)

---

*ç®—æ³•ç†è®ºä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†è®¡ç®—åŸºç¡€ï¼Œé€šè¿‡å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥è®¾è®¡ã€åˆ†æå’Œä¼˜åŒ–å„ç§ç®—æ³•ã€‚*
