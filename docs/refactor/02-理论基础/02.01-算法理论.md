# 02.01 ç®—æ³•ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç®—æ³•ç†è®ºæ˜¯è½¯ä»¶å·¥ç¨‹çš„ç†è®ºåŸºç¡€ï¼Œç ”ç©¶ç®—æ³•çš„è®¾è®¡ã€åˆ†æã€æ­£ç¡®æ€§å’Œæ•ˆç‡ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰ç®—æ³•çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç®—æ³•å®šä¹‰

**å®šä¹‰ 2.1 (ç®—æ³•)**ï¼š
ç®—æ³•æ˜¯ä¸€ä¸ªæœ‰é™çš„ã€æ˜ç¡®çš„ã€å¯æ‰§è¡Œçš„æŒ‡ä»¤åºåˆ—ï¼Œç”¨äºè§£å†³ç‰¹å®šé—®é¢˜æˆ–å®Œæˆç‰¹å®šä»»åŠ¡ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Algorithm} = \langle \text{Input}, \text{Output}, \text{Steps}, \text{Termination} \rangle$$

å…¶ä¸­ï¼š

- $\text{Input}$ æ˜¯è¾“å…¥é›†åˆ
- $\text{Output}$ æ˜¯è¾“å‡ºé›†åˆ
- $\text{Steps}$ æ˜¯æ‰§è¡Œæ­¥éª¤
- $\text{Termination}$ æ˜¯ç»ˆæ­¢æ¡ä»¶

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, Generic, Callable, Any, List, Optional
from dataclasses import dataclass
from abc import ABC, abstractmethod
from enum import Enum
import time

T = TypeVar('T')
U = TypeVar('U')

class AlgorithmType(Enum):
    """ç®—æ³•ç±»å‹"""
    SORTING = "sorting"
    SEARCHING = "searching"
    GRAPH = "graph"
    DYNAMIC_PROGRAMMING = "dynamic_programming"
    GREEDY = "greedy"
    DIVIDE_AND_CONQUER = "divide_and_conquer"

@dataclass
class AlgorithmResult(Generic[T]):
    """ç®—æ³•ç»“æœ"""
    output: T
    execution_time: float
    memory_usage: Optional[float] = None
    steps_count: Optional[int] = None

class Algorithm(ABC, Generic[T, U]):
    """ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, algorithm_type: AlgorithmType):
        self.name = name
        self.algorithm_type = algorithm_type
        self.complexity_analysis = {}
    
    @abstractmethod
    def execute(self, input_data: T) -> U:
        """æ‰§è¡Œç®—æ³•"""
        pass
    
    def analyze_complexity(self, input_size: int) -> Dict[str, str]:
        """åˆ†æå¤æ‚åº¦"""
        return self.complexity_analysis
    
    def benchmark(self, input_data: T, iterations: int = 1) -> AlgorithmResult[U]:
        """æ€§èƒ½åŸºå‡†æµ‹è¯•"""
        start_time = time.time()
        
        for _ in range(iterations):
            result = self.execute(input_data)
        
        end_time = time.time()
        execution_time = (end_time - start_time) / iterations
        
        return AlgorithmResult(
            output=result,
            execution_time=execution_time
        )

class AlgorithmLibrary:
    """ç®—æ³•åº“"""
    
    def __init__(self):
        self.algorithms: Dict[str, Algorithm] = {}
    
    def register_algorithm(self, algorithm: Algorithm) -> None:
        """æ³¨å†Œç®—æ³•"""
        self.algorithms[algorithm.name] = algorithm
    
    def get_algorithm(self, name: str) -> Optional[Algorithm]:
        """è·å–ç®—æ³•"""
        return self.algorithms.get(name)
    
    def list_algorithms(self, algorithm_type: Optional[AlgorithmType] = None) -> List[str]:
        """åˆ—å‡ºç®—æ³•"""
        if algorithm_type is None:
            return list(self.algorithms.keys())
        
        return [name for name, alg in self.algorithms.items() 
                if alg.algorithm_type == algorithm_type]
    
    def compare_algorithms(self, algorithm_names: List[str], 
                          input_data: Any, iterations: int = 1) -> Dict[str, AlgorithmResult]:
        """æ¯”è¾ƒç®—æ³•æ€§èƒ½"""
        results = {}
        
        for name in algorithm_names:
            algorithm = self.get_algorithm(name)
            if algorithm:
                results[name] = algorithm.benchmark(input_data, iterations)
        
        return results

# ç¤ºä¾‹ï¼šç®—æ³•åº“
algorithm_library = AlgorithmLibrary()
```

### 2. ç®—æ³•å¤æ‚åº¦åˆ†æ

**å®šä¹‰ 2.2 (æ—¶é—´å¤æ‚åº¦)**ï¼š
ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ $T(n)$ è¡¨ç¤ºç®—æ³•æ‰§è¡Œæ—¶é—´ä¸è¾“å…¥è§„æ¨¡ $n$ çš„å…³ç³»ã€‚

**å®šä¹‰ 2.3 (ç©ºé—´å¤æ‚åº¦)**ï¼š
ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦ $S(n)$ è¡¨ç¤ºç®—æ³•æ‰€éœ€å­˜å‚¨ç©ºé—´ä¸è¾“å…¥è§„æ¨¡ $n$ çš„å…³ç³»ã€‚

**æ¸è¿‘è®°å·**ï¼š

- $O(f(n))$ï¼šä¸Šç•Œï¼Œ$T(n) \leq c \cdot f(n)$ å¯¹æ‰€æœ‰ $n \geq n_0$ æˆç«‹
- $\Omega(f(n))$ï¼šä¸‹ç•Œï¼Œ$T(n) \geq c \cdot f(n)$ å¯¹æ‰€æœ‰ $n \geq n_0$ æˆç«‹
- $\Theta(f(n))$ï¼šç´§ç•Œï¼Œ$c_1 \cdot f(n) \leq T(n) \leq c_2 \cdot f(n)$ å¯¹æ‰€æœ‰ $n \geq n_0$ æˆç«‹

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Callable, Any, Tuple
from dataclasses import dataclass
import time
import random
import matplotlib.pyplot as plt
import numpy as np

@dataclass
class ComplexityAnalysis:
    """å¤æ‚åº¦åˆ†æç»“æœ"""
    best_case: str
    average_case: str
    worst_case: str
    space_complexity: str
    description: str

class ComplexityAnalyzer:
    """å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.analysis_results: Dict[str, ComplexityAnalysis] = {}
    
    def analyze_algorithm(self, algorithm: Algorithm, 
                         input_generator: Callable[[int], Any],
                         max_size: int = 1000) -> ComplexityAnalysis:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        sizes = []
        times = []
        
        # æµ‹è¯•ä¸åŒè¾“å…¥è§„æ¨¡
        for size in range(10, max_size, 50):
            input_data = input_generator(size)
            
            start_time = time.time()
            algorithm.execute(input_data)
            end_time = time.time()
            
            sizes.append(size)
            times.append(end_time - start_time)
        
        # æ‹Ÿåˆå¤æ‚åº¦å‡½æ•°
        complexity = self._fit_complexity(sizes, times)
        
        return ComplexityAnalysis(
            best_case=complexity,
            average_case=complexity,
            worst_case=complexity,
            space_complexity="O(1)",  # ç®€åŒ–å®ç°
            description=f"ç®—æ³• {algorithm.name} çš„å¤æ‚åº¦åˆ†æ"
        )
    
    def _fit_complexity(self, sizes: List[int], times: List[float]) -> str:
        """æ‹Ÿåˆå¤æ‚åº¦å‡½æ•°"""
        # ç®€åŒ–å®ç°ï¼šåŸºäºç»éªŒåˆ¤æ–­
        if len(sizes) < 2:
            return "O(1)"
        
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            time_ratio = times[i] / times[i-1]
            growth_rates.append(time_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # åˆ¤æ–­å¤æ‚åº¦ç±»å‹
        if avg_growth < 0.1:
            return "O(1)"
        elif avg_growth < 0.5:
            return "O(log n)"
        elif avg_growth < 1.5:
            return "O(n)"
        elif avg_growth < 2.5:
            return "O(n log n)"
        elif avg_growth < 3.5:
            return "O(nÂ²)"
        else:
            return "O(nÂ³) æˆ–æ›´é«˜"
    
    def plot_complexity(self, algorithm: Algorithm,
                       input_generator: Callable[[int], Any],
                       max_size: int = 1000) -> None:
        """ç»˜åˆ¶å¤æ‚åº¦å›¾è¡¨"""
        sizes = []
        times = []
        
        for size in range(10, max_size, 50):
            input_data = input_generator(size)
            
            start_time = time.time()
            algorithm.execute(input_data)
            end_time = time.time()
            
            sizes.append(size)
            times.append(end_time - start_time)
        
        plt.figure(figsize=(10, 6))
        plt.plot(sizes, times, 'b-', label=f'{algorithm.name}')
        plt.xlabel('Input Size')
        plt.ylabel('Execution Time (seconds)')
        plt.title(f'Complexity Analysis: {algorithm.name}')
        plt.legend()
        plt.grid(True)
        plt.show()

# ç¤ºä¾‹ï¼šå¤æ‚åº¦åˆ†æ
analyzer = ComplexityAnalyzer()
```

### 3. æ’åºç®—æ³•

**å®šä¹‰ 2.4 (æ’åºé—®é¢˜)**ï¼š
ç»™å®šåºåˆ— $A = [a_1, a_2, ..., a_n]$ï¼Œæ‰¾åˆ°æ’åˆ— $\pi$ ä½¿å¾— $a_{\pi(1)} \leq a_{\pi(2)} \leq ... \leq a_{\pi(n)}$ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import List, TypeVar, Callable
from copy import deepcopy

T = TypeVar('T')

class SortingAlgorithm(Algorithm[List[T], List[T]]):
    """æ’åºç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str):
        super().__init__(name, AlgorithmType.SORTING)
        self.comparison_count = 0
        self.swap_count = 0
    
    def reset_counters(self) -> None:
        """é‡ç½®è®¡æ•°å™¨"""
        self.comparison_count = 0
        self.swap_count = 0
    
    def compare(self, a: T, b: T) -> bool:
        """æ¯”è¾ƒæ“ä½œ"""
        self.comparison_count += 1
        return a <= b
    
    def swap(self, arr: List[T], i: int, j: int) -> None:
        """äº¤æ¢æ“ä½œ"""
        self.swap_count += 1
        arr[i], arr[j] = arr[j], arr[i]

class BubbleSort(SortingAlgorithm[T]):
    """å†’æ³¡æ’åº"""
    
    def __init__(self):
        super().__init__("Bubble Sort")
        self.complexity_analysis = {
            "time": "O(nÂ²)",
            "space": "O(1)",
            "stable": True
        }
    
    def execute(self, input_data: List[T]) -> List[T]:
        """æ‰§è¡Œå†’æ³¡æ’åº"""
        self.reset_counters()
        arr = deepcopy(input_data)
        n = len(arr)
        
        for i in range(n):
            swapped = False
            for j in range(0, n - i - 1):
                if not self.compare(arr[j], arr[j + 1]):
                    self.swap(arr, j, j + 1)
                    swapped = True
            
            if not swapped:
                break
        
        return arr

class QuickSort(SortingAlgorithm[T]):
    """å¿«é€Ÿæ’åº"""
    
    def __init__(self):
        super().__init__("Quick Sort")
        self.complexity_analysis = {
            "time": "O(n log n)",
            "space": "O(log n)",
            "stable": False
        }
    
    def execute(self, input_data: List[T]) -> List[T]:
        """æ‰§è¡Œå¿«é€Ÿæ’åº"""
        self.reset_counters()
        arr = deepcopy(input_data)
        self._quicksort(arr, 0, len(arr) - 1)
        return arr
    
    def _quicksort(self, arr: List[T], low: int, high: int) -> None:
        """å¿«é€Ÿæ’åºé€’å½’å®ç°"""
        if low < high:
            pi = self._partition(arr, low, high)
            self._quicksort(arr, low, pi - 1)
            self._quicksort(arr, pi + 1, high)
    
    def _partition(self, arr: List[T], low: int, high: int) -> int:
        """åˆ†åŒºæ“ä½œ"""
        pivot = arr[high]
        i = low - 1
        
        for j in range(low, high):
            if self.compare(arr[j], pivot):
                i += 1
                self.swap(arr, i, j)
        
        self.swap(arr, i + 1, high)
        return i + 1

class MergeSort(SortingAlgorithm[T]):
    """å½’å¹¶æ’åº"""
    
    def __init__(self):
        super().__init__("Merge Sort")
        self.complexity_analysis = {
            "time": "O(n log n)",
            "space": "O(n)",
            "stable": True
        }
    
    def execute(self, input_data: List[T]) -> List[T]:
        """æ‰§è¡Œå½’å¹¶æ’åº"""
        self.reset_counters()
        arr = deepcopy(input_data)
        return self._mergesort(arr)
    
    def _mergesort(self, arr: List[T]) -> List[T]:
        """å½’å¹¶æ’åºé€’å½’å®ç°"""
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = self._mergesort(arr[:mid])
        right = self._mergesort(arr[mid:])
        
        return self._merge(left, right)
    
    def _merge(self, left: List[T], right: List[T]) -> List[T]:
        """åˆå¹¶æ“ä½œ"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if self.compare(left[i], right[j]):
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result

# ç¤ºä¾‹ï¼šæ’åºç®—æ³•æ¯”è¾ƒ
def sorting_comparison_example():
    """æ’åºç®—æ³•æ¯”è¾ƒç¤ºä¾‹"""
    # æ³¨å†Œç®—æ³•
    algorithm_library.register_algorithm(BubbleSort())
    algorithm_library.register_algorithm(QuickSort())
    algorithm_library.register_algorithm(MergeSort())
    
    # ç”Ÿæˆæµ‹è¯•æ•°æ®
    test_data = [random.randint(1, 1000) for _ in range(100)]
    
    print(f"æ’åºç®—æ³•æ¯”è¾ƒ:")
    print(f"  æµ‹è¯•æ•°æ®: {test_data[:10]}... (å…±{len(test_data)}ä¸ªå…ƒç´ )")
    
    # æ¯”è¾ƒæ€§èƒ½
    algorithm_names = ["Bubble Sort", "Quick Sort", "Merge Sort"]
    results = algorithm_library.compare_algorithms(algorithm_names, test_data)
    
    for name, result in results.items():
        algorithm = algorithm_library.get_algorithm(name)
        print(f"\n  {name}:")
        print(f"    æ‰§è¡Œæ—¶é—´: {result.execution_time:.6f} ç§’")
        print(f"    æ¯”è¾ƒæ¬¡æ•°: {algorithm.comparison_count}")
        print(f"    äº¤æ¢æ¬¡æ•°: {algorithm.swap_count}")
        print(f"    æ—¶é—´å¤æ‚åº¦: {algorithm.complexity_analysis['time']}")
        print(f"    ç©ºé—´å¤æ‚åº¦: {algorithm.complexity_analysis['space']}")
        print(f"    ç¨³å®šæ€§: {algorithm.complexity_analysis['stable']}")
    
    return results

sorting_results = sorting_comparison_example()
```

### 4. æœç´¢ç®—æ³•

**å®šä¹‰ 2.5 (æœç´¢é—®é¢˜)**ï¼š
åœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾ç‰¹å®šå…ƒç´ æˆ–æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„å…ƒç´ ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import List, TypeVar, Optional, Callable, Any
from dataclasses import dataclass

T = TypeVar('T')

@dataclass
class SearchResult:
    """æœç´¢ç»“æœ"""
    found: bool
    index: Optional[int] = None
    value: Optional[T] = None
    comparisons: int = 0

class SearchAlgorithm(Algorithm[Tuple[List[T], T], SearchResult]):
    """æœç´¢ç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str):
        super().__init__(name, AlgorithmType.SEARCHING)
        self.comparison_count = 0
    
    def reset_counter(self) -> None:
        """é‡ç½®è®¡æ•°å™¨"""
        self.comparison_count = 0
    
    def compare(self, a: T, b: T) -> int:
        """æ¯”è¾ƒæ“ä½œï¼Œè¿”å›-1, 0, 1"""
        self.comparison_count += 1
        if a < b:
            return -1
        elif a > b:
            return 1
        else:
            return 0

class LinearSearch(SearchAlgorithm[T]):
    """çº¿æ€§æœç´¢"""
    
    def __init__(self):
        super().__init__("Linear Search")
        self.complexity_analysis = {
            "time": "O(n)",
            "space": "O(1)"
        }
    
    def execute(self, input_data: Tuple[List[T], T]) -> SearchResult:
        """æ‰§è¡Œçº¿æ€§æœç´¢"""
        self.reset_counter()
        arr, target = input_data
        
        for i, element in enumerate(arr):
            if self.compare(element, target) == 0:
                return SearchResult(
                    found=True,
                    index=i,
                    value=element,
                    comparisons=self.comparison_count
                )
        
        return SearchResult(
            found=False,
            comparisons=self.comparison_count
        )

class BinarySearch(SearchAlgorithm[T]):
    """äºŒåˆ†æœç´¢"""
    
    def __init__(self):
        super().__init__("Binary Search")
        self.complexity_analysis = {
            "time": "O(log n)",
            "space": "O(1)"
        }
    
    def execute(self, input_data: Tuple[List[T], T]) -> SearchResult:
        """æ‰§è¡ŒäºŒåˆ†æœç´¢"""
        self.reset_counter()
        arr, target = input_data
        
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            comparison = self.compare(arr[mid], target)
            
            if comparison == 0:
                return SearchResult(
                    found=True,
                    index=mid,
                    value=arr[mid],
                    comparisons=self.comparison_count
                )
            elif comparison < 0:
                left = mid + 1
            else:
                right = mid - 1
        
        return SearchResult(
            found=False,
            comparisons=self.comparison_count
        )

class HashSearch(SearchAlgorithm[T]):
    """å“ˆå¸Œæœç´¢"""
    
    def __init__(self):
        super().__init__("Hash Search")
        self.complexity_analysis = {
            "time": "O(1) å¹³å‡",
            "space": "O(n)"
        }
        self.hash_table = {}
    
    def build_hash_table(self, arr: List[T]) -> None:
        """æ„å»ºå“ˆå¸Œè¡¨"""
        self.hash_table.clear()
        for i, element in enumerate(arr):
            self.hash_table[element] = i
    
    def execute(self, input_data: Tuple[List[T], T]) -> SearchResult:
        """æ‰§è¡Œå“ˆå¸Œæœç´¢"""
        self.reset_counter()
        arr, target = input_data
        
        # æ„å»ºå“ˆå¸Œè¡¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰æ„å»ºï¼‰
        if not self.hash_table:
            self.build_hash_table(arr)
        
        self.comparison_count += 1
        if target in self.hash_table:
            index = self.hash_table[target]
            return SearchResult(
                found=True,
                index=index,
                value=target,
                comparisons=self.comparison_count
            )
        
        return SearchResult(
            found=False,
            comparisons=self.comparison_count
        )

# ç¤ºä¾‹ï¼šæœç´¢ç®—æ³•æ¯”è¾ƒ
def search_comparison_example():
    """æœç´¢ç®—æ³•æ¯”è¾ƒç¤ºä¾‹"""
    # æ³¨å†Œç®—æ³•
    algorithm_library.register_algorithm(LinearSearch())
    algorithm_library.register_algorithm(BinarySearch())
    algorithm_library.register_algorithm(HashSearch())
    
    # ç”Ÿæˆæµ‹è¯•æ•°æ®
    test_data = sorted([random.randint(1, 1000) for _ in range(1000)])
    target = random.choice(test_data)
    
    print(f"æœç´¢ç®—æ³•æ¯”è¾ƒ:")
    print(f"  æ•°æ®è§„æ¨¡: {len(test_data)} ä¸ªå…ƒç´ ")
    print(f"  æœç´¢ç›®æ ‡: {target}")
    
    # æ¯”è¾ƒæ€§èƒ½
    algorithm_names = ["Linear Search", "Binary Search", "Hash Search"]
    results = algorithm_library.compare_algorithms(
        algorithm_names, 
        (test_data, target)
    )
    
    for name, result in results.items():
        algorithm = algorithm_library.get_algorithm(name)
        print(f"\n  {name}:")
        print(f"    æ‰§è¡Œæ—¶é—´: {result.execution_time:.6f} ç§’")
        print(f"    æ¯”è¾ƒæ¬¡æ•°: {algorithm.comparison_count}")
        print(f"    æ—¶é—´å¤æ‚åº¦: {algorithm.complexity_analysis['time']}")
        print(f"    ç©ºé—´å¤æ‚åº¦: {algorithm.complexity_analysis['space']}")
    
    return results

search_results = search_comparison_example()
```

### 5. åŠ¨æ€è§„åˆ’

**å®šä¹‰ 2.6 (åŠ¨æ€è§„åˆ’)**ï¼š
åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç§é€šè¿‡å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜æ¥è§£å†³å¤æ‚é—®é¢˜çš„ç®—æ³•è®¾è®¡æ–¹æ³•ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š

1. æœ€ä¼˜å­ç»“æ„ï¼šé—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å­é—®é¢˜çš„æœ€ä¼˜è§£
2. é‡å å­é—®é¢˜ï¼šå­é—®é¢˜è¢«é‡å¤è®¡ç®—

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Callable, Any, TypeVar
from functools import lru_cache
import time

T = TypeVar('T')

class DynamicProgramming:
    """åŠ¨æ€è§„åˆ’æ¡†æ¶"""
    
    def __init__(self):
        self.memo: Dict[str, Any] = {}
        self.calls_count = 0
    
    def reset(self) -> None:
        """é‡ç½®çŠ¶æ€"""
        self.memo.clear()
        self.calls_count = 0
    
    def memoized_fibonacci(self, n: int) -> int:
        """è®°å¿†åŒ–æ–æ³¢é‚£å¥‘"""
        if n in self.memo:
            return self.memo[n]
        
        self.calls_count += 1
        
        if n <= 1:
            result = n
        else:
            result = self.memoized_fibonacci(n - 1) + self.memoized_fibonacci(n - 2)
        
        self.memo[n] = result
        return result
    
    def tabulated_fibonacci(self, n: int) -> int:
        """è¡¨æ ¼åŒ–æ–æ³¢é‚£å¥‘"""
        if n <= 1:
            return n
        
        dp = [0] * (n + 1)
        dp[1] = 1
        
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
    
    def longest_common_subsequence(self, text1: str, text2: str) -> int:
        """æœ€é•¿å…¬å…±å­åºåˆ—"""
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n]
    
    def knapsack_01(self, weights: List[int], values: List[int], capacity: int) -> int:
        """0-1èƒŒåŒ…é—®é¢˜"""
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i - 1] <= w:
                    dp[i][w] = max(dp[i - 1][w], 
                                 dp[i - 1][w - weights[i - 1]] + values[i - 1])
                else:
                    dp[i][w] = dp[i - 1][w]
        
        return dp[n][capacity]
    
    def coin_change(self, coins: List[int], amount: int) -> int:
        """ç¡¬å¸æ‰¾é›¶é—®é¢˜"""
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)
        
        return dp[amount] if dp[amount] != float('inf') else -1

# ç¤ºä¾‹ï¼šåŠ¨æ€è§„åˆ’åº”ç”¨
def dynamic_programming_example():
    """åŠ¨æ€è§„åˆ’ç¤ºä¾‹"""
    dp = DynamicProgramming()
    
    print(f"åŠ¨æ€è§„åˆ’ç¤ºä¾‹:")
    
    # æ–æ³¢é‚£å¥‘æ•°åˆ—
    n = 30
    print(f"\n  æ–æ³¢é‚£å¥‘æ•°åˆ— F({n}):")
    
    start_time = time.time()
    fib_memo = dp.memoized_fibonacci(n)
    memo_time = time.time() - start_time
    print(f"    è®°å¿†åŒ–æ–¹æ³•: {fib_memo} (è°ƒç”¨æ¬¡æ•°: {dp.calls_count}, æ—¶é—´: {memo_time:.6f}s)")
    
    dp.reset()
    start_time = time.time()
    fib_tab = dp.tabulated_fibonacci(n)
    tab_time = time.time() - start_time
    print(f"    è¡¨æ ¼åŒ–æ–¹æ³•: {fib_tab} (æ—¶é—´: {tab_time:.6f}s)")
    
    # æœ€é•¿å…¬å…±å­åºåˆ—
    text1, text2 = "ABCDGH", "AEDFHR"
    lcs = dp.longest_common_subsequence(text1, text2)
    print(f"\n  æœ€é•¿å…¬å…±å­åºåˆ— '{text1}' å’Œ '{text2}': {lcs}")
    
    # 0-1èƒŒåŒ…é—®é¢˜
    weights = [2, 1, 3, 2]
    values = [12, 10, 20, 15]
    capacity = 5
    max_value = dp.knapsack_01(weights, values, capacity)
    print(f"\n  0-1èƒŒåŒ…é—®é¢˜:")
    print(f"    é‡é‡: {weights}")
    print(f"    ä»·å€¼: {values}")
    print(f"    å®¹é‡: {capacity}")
    print(f"    æœ€å¤§ä»·å€¼: {max_value}")
    
    # ç¡¬å¸æ‰¾é›¶
    coins = [1, 2, 5]
    amount = 11
    min_coins = dp.coin_change(coins, amount)
    print(f"\n  ç¡¬å¸æ‰¾é›¶:")
    print(f"    ç¡¬å¸é¢å€¼: {coins}")
    print(f"    ç›®æ ‡é‡‘é¢: {amount}")
    print(f"    æœ€å°‘ç¡¬å¸æ•°: {min_coins}")
    
    return dp

dp_example = dynamic_programming_example()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [02.02 æ•°æ®ç»“æ„](./02.02-æ•°æ®ç»“æ„.md)
- [02.03 è®¡ç®—ç†è®º](./02.03-è®¡ç®—ç†è®º.md)
- [02.04 å¤æ‚åº¦ç†è®º](./02.04-å¤æ‚åº¦ç†è®º.md)
- [03.01 è®¾è®¡æ¨¡å¼ç§‘å­¦](../03-å…·ä½“ç§‘å­¦/03.01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md)
- [06.01 åŸºç¡€ç®—æ³•](../06-ç»„ä»¶ç®—æ³•/06.01-åŸºç¡€ç®—æ³•.md)

---

**æœ€åæ›´æ–°**: 2024-01-XX  
**ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: AI Assistant
