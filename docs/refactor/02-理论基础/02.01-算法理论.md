# 02.01 算法理论

## 📋 概述

算法理论是计算机科学的核心，研究算法的设计、分析和优化。本文档从形式化角度定义算法理论的核心概念，并提供Python实现。

## 🎯 核心概念

### 1. 算法的形式化定义

**数学定义**：
算法是一个有限的计算过程：$A: I \rightarrow O$，其中：

- $I$ 是输入集合
- $O$ 是输出集合
- $A$ 在有限步骤内终止

**Python实现**：

```python
from typing import TypeVar, Callable, Any, List, Dict
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import time

I = TypeVar('I')  # 输入类型
O = TypeVar('O')  # 输出类型

class AlgorithmType(Enum):
    SEARCHING = "searching"
    SORTING = "sorting"
    GRAPH = "graph"
    DYNAMIC_PROGRAMMING = "dynamic_programming"
    GREEDY = "greedy"
    DIVIDE_AND_CONQUER = "divide_and_conquer"

@dataclass
class AlgorithmResult:
    """算法执行结果"""
    output: O
    execution_time: float
    steps_count: int
    memory_usage: int

class Algorithm(ABC):
    """算法抽象基类"""
    
    def __init__(self, name: str, algorithm_type: AlgorithmType):
        self.name = name
        self.algorithm_type = algorithm_type
        self.steps_count = 0
    
    @abstractmethod
    def execute(self, input_data: I) -> O:
        """执行算法"""
        pass
    
    def run_with_metrics(self, input_data: I) -> AlgorithmResult:
        """运行算法并收集指标"""
        start_time = time.time()
        start_memory = self._get_memory_usage()
        
        self.steps_count = 0
        result = self.execute(input_data)
        
        end_time = time.time()
        end_memory = self._get_memory_usage()
        
        return AlgorithmResult(
            output=result,
            execution_time=end_time - start_time,
            steps_count=self.steps_count,
            memory_usage=end_memory - start_memory
        )
    
    def _get_memory_usage(self) -> int:
        """获取内存使用量（简化实现）"""
        import sys
        return sys.getsizeof(self)
    
    def _increment_steps(self):
        """增加步骤计数"""
        self.steps_count += 1

# 示例：线性搜索算法
class LinearSearch(Algorithm):
    """线性搜索算法"""
    
    def __init__(self):
        super().__init__("Linear Search", AlgorithmType.SEARCHING)
    
    def execute(self, input_data: tuple[List[Any], Any]) -> int:
        """执行线性搜索"""
        array, target = input_data
        
        for i, element in enumerate(array):
            self._increment_steps()
            if element == target:
                return i
        
        return -1

# 示例：二分搜索算法
class BinarySearch(Algorithm):
    """二分搜索算法"""
    
    def __init__(self):
        super().__init__("Binary Search", AlgorithmType.SEARCHING)
    
    def execute(self, input_data: tuple[List[Any], Any]) -> int:
        """执行二分搜索"""
        array, target = input_data
        left, right = 0, len(array) - 1
        
        while left <= right:
            self._increment_steps()
            mid = (left + right) // 2
            
            if array[mid] == target:
                return mid
            elif array[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1

# 示例：冒泡排序算法
class BubbleSort(Algorithm):
    """冒泡排序算法"""
    
    def __init__(self):
        super().__init__("Bubble Sort", AlgorithmType.SORTING)
    
    def execute(self, input_data: List[Any]) -> List[Any]:
        """执行冒泡排序"""
        array = input_data.copy()
        n = len(array)
        
        for i in range(n):
            for j in range(0, n - i - 1):
                self._increment_steps()
                if array[j] > array[j + 1]:
                    array[j], array[j + 1] = array[j + 1], array[j]
        
        return array

# 示例：快速排序算法
class QuickSort(Algorithm):
    """快速排序算法"""
    
    def __init__(self):
        super().__init__("Quick Sort", AlgorithmType.SORTING)
    
    def execute(self, input_data: List[Any]) -> List[Any]:
        """执行快速排序"""
        array = input_data.copy()
        return self._quicksort(array)
    
    def _quicksort(self, array: List[Any]) -> List[Any]:
        """快速排序递归实现"""
        if len(array) <= 1:
            return array
        
        self._increment_steps()
        pivot = array[len(array) // 2]
        left = [x for x in array if x < pivot]
        middle = [x for x in array if x == pivot]
        right = [x for x in array if x > pivot]
        
        return self._quicksort(left) + middle + self._quicksort(right)

# 示例：动态规划算法
class FibonacciDP(Algorithm):
    """斐波那契动态规划算法"""
    
    def __init__(self):
        super().__init__("Fibonacci DP", AlgorithmType.DYNAMIC_PROGRAMMING)
        self.memo = {}
    
    def execute(self, input_data: int) -> int:
        """执行斐波那契动态规划"""
        return self._fibonacci(input_data)
    
    def _fibonacci(self, n: int) -> int:
        """斐波那契递归实现"""
        if n in self.memo:
            return self.memo[n]
        
        self._increment_steps()
        
        if n <= 1:
            result = n
        else:
            result = self._fibonacci(n - 1) + self._fibonacci(n - 2)
        
        self.memo[n] = result
        return result

# 示例：贪心算法
class ActivitySelection(Algorithm):
    """活动选择贪心算法"""
    
    def __init__(self):
        super().__init__("Activity Selection", AlgorithmType.GREEDY)
    
    def execute(self, input_data: List[tuple[int, int]]) -> List[tuple[int, int]]:
        """执行活动选择贪心算法"""
        activities = sorted(input_data, key=lambda x: x[1])  # 按结束时间排序
        selected = []
        last_end_time = 0
        
        for activity in activities:
            self._increment_steps()
            if activity[0] >= last_end_time:
                selected.append(activity)
                last_end_time = activity[1]
        
        return selected

# 示例：分治算法
class MergeSort(Algorithm):
    """归并排序分治算法"""
    
    def __init__(self):
        super().__init__("Merge Sort", AlgorithmType.DIVIDE_AND_CONQUER)
    
    def execute(self, input_data: List[Any]) -> List[Any]:
        """执行归并排序"""
        array = input_data.copy()
        return self._merge_sort(array)
    
    def _merge_sort(self, array: List[Any]) -> List[Any]:
        """归并排序递归实现"""
        if len(array) <= 1:
            return array
        
        self._increment_steps()
        mid = len(array) // 2
        left = self._merge_sort(array[:mid])
        right = self._merge_sort(array[mid:])
        
        return self._merge(left, right)
    
    def _merge(self, left: List[Any], right: List[Any]) -> List[Any]:
        """合并两个有序数组"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result

# 示例：算法比较
def compare_algorithms():
    """比较不同算法的性能"""
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        BubbleSort(),
        QuickSort(),
        FibonacciDP(),
        ActivitySelection(),
        MergeSort()
    ]
    
    # 测试数据
    test_cases = {
        "Linear Search": ([1, 2, 3, 4, 5], 3),
        "Binary Search": ([1, 2, 3, 4, 5], 3),
        "Bubble Sort": [5, 2, 4, 1, 3],
        "Quick Sort": [5, 2, 4, 1, 3],
        "Fibonacci DP": 10,
        "Activity Selection": [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8)],
        "Merge Sort": [5, 2, 4, 1, 3]
    }
    
    print("=== 算法性能比较 ===")
    
    for algorithm in algorithms:
        if algorithm.name in test_cases:
            test_data = test_cases[algorithm.name]
            result = algorithm.run_with_metrics(test_data)
            
            print(f"\n{algorithm.name}:")
            print(f"  输出: {result.output}")
            print(f"  执行时间: {result.execution_time:.6f}秒")
            print(f"  步骤数: {result.steps_count}")
            print(f"  内存使用: {result.memory_usage}字节")
    
    return algorithms

# 运行示例
algorithm_comparison = compare_algorithms()
```

### 2. 算法复杂度分析

#### 2.1 时间复杂度

**数学定义**：
时间复杂度 $T(n)$ 表示算法执行时间与输入规模 $n$ 的关系。

**Python实现**：

```python
from typing import Callable, List, Dict, Any
import time
import math

class ComplexityAnalyzer:
    """算法复杂度分析器"""
    
    def __init__(self):
        self.complexity_classes = {
            'O(1)': lambda n: 1,
            'O(log n)': lambda n: math.log(n),
            'O(n)': lambda n: n,
            'O(n log n)': lambda n: n * math.log(n),
            'O(n²)': lambda n: n ** 2,
            'O(n³)': lambda n: n ** 3,
            'O(2ⁿ)': lambda n: 2 ** n,
            'O(n!)': lambda n: math.factorial(n)
        }
    
    def measure_time_complexity(self, algorithm: Algorithm, 
                              input_sizes: List[int]) -> Dict[int, float]:
        """测量算法的时间复杂度"""
        measurements = {}
        
        for size in input_sizes:
            # 生成测试数据
            test_data = self._generate_test_data(algorithm, size)
            
            # 测量执行时间
            result = algorithm.run_with_metrics(test_data)
            measurements[size] = result.execution_time
        
        return measurements
    
    def _generate_test_data(self, algorithm: Algorithm, size: int) -> Any:
        """生成测试数据"""
        if algorithm.algorithm_type == AlgorithmType.SEARCHING:
            array = list(range(size))
            target = size // 2
            return (array, target)
        elif algorithm.algorithm_type == AlgorithmType.SORTING:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
        elif algorithm.algorithm_type == AlgorithmType.DYNAMIC_PROGRAMMING:
            return size
        elif algorithm.algorithm_type == AlgorithmType.GREEDY:
            import random
            activities = []
            for _ in range(size):
                start = random.randint(0, 10)
                end = start + random.randint(1, 5)
                activities.append((start, end))
            return activities
        else:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
    
    def analyze_complexity(self, measurements: Dict[int, float]) -> str:
        """分析复杂度"""
        sizes = list(measurements.keys())
        times = list(measurements.values())
        
        if len(sizes) < 2:
            return "数据不足，无法分析"
        
        # 计算增长率
        growth_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            time_ratio = times[i] / times[i-1]
            growth_rates.append(time_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # 确定复杂度类别
        if avg_growth < 1.1:
            return "O(1) - 常数时间"
        elif avg_growth < 1.5:
            return "O(log n) - 对数时间"
        elif avg_growth < 2.0:
            return "O(n) - 线性时间"
        elif avg_growth < 3.0:
            return "O(n log n) - 线性对数时间"
        elif avg_growth < 10.0:
            return "O(n²) - 平方时间"
        elif avg_growth < 100.0:
            return "O(n³) - 立方时间"
        else:
            return "O(2ⁿ) 或更高 - 指数时间"
    
    def compare_complexities(self, algorithms: List[Algorithm], 
                           max_size: int = 100) -> Dict[str, str]:
        """比较多个算法的复杂度"""
        input_sizes = [10, 20, 50, 100][:max_size//25]
        results = {}
        
        for algorithm in algorithms:
            measurements = self.measure_time_complexity(algorithm, input_sizes)
            complexity = self.analyze_complexity(measurements)
            results[algorithm.name] = complexity
        
        return results

# 示例：复杂度分析
def demonstrate_complexity_analysis():
    """演示复杂度分析"""
    analyzer = ComplexityAnalyzer()
    
    # 测试算法
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        BubbleSort(),
        QuickSort(),
        MergeSort()
    ]
    
    print("=== 算法复杂度分析 ===")
    
    # 分析每个算法的复杂度
    complexities = analyzer.compare_complexities(algorithms, max_size=50)
    
    for algorithm_name, complexity in complexities.items():
        print(f"{algorithm_name}: {complexity}")
    
    return analyzer

# 运行示例
complexity_analysis = demonstrate_complexity_analysis()
```

#### 2.2 空间复杂度

**数学定义**：
空间复杂度 $S(n)$ 表示算法执行过程中所需的最大内存空间。

**Python实现**：

```python
import sys
import tracemalloc

class SpaceComplexityAnalyzer:
    """空间复杂度分析器"""
    
    def __init__(self):
        self.memory_measurements = {}
    
    def measure_space_complexity(self, algorithm: Algorithm, 
                               input_sizes: List[int]) -> Dict[int, int]:
        """测量算法的空间复杂度"""
        measurements = {}
        
        for size in input_sizes:
            # 生成测试数据
            test_data = self._generate_test_data(algorithm, size)
            
            # 开始内存跟踪
            tracemalloc.start()
            
            # 执行算法
            result = algorithm.run_with_metrics(test_data)
            
            # 获取内存使用
            current, peak = tracemalloc.get_traced_memory()
            tracemalloc.stop()
            
            measurements[size] = peak
        
        return measurements
    
    def _generate_test_data(self, algorithm: Algorithm, size: int) -> Any:
        """生成测试数据（与时间复杂度分析相同）"""
        if algorithm.algorithm_type == AlgorithmType.SEARCHING:
            array = list(range(size))
            target = size // 2
            return (array, target)
        elif algorithm.algorithm_type == AlgorithmType.SORTING:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
        else:
            import random
            return [random.randint(1, 1000) for _ in range(size)]
    
    def analyze_space_complexity(self, measurements: Dict[int, int]) -> str:
        """分析空间复杂度"""
        sizes = list(measurements.keys())
        memory = list(measurements.values())
        
        if len(sizes) < 2:
            return "数据不足，无法分析"
        
        # 计算内存增长率
        growth_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            memory_ratio = memory[i] / memory[i-1]
            growth_rates.append(memory_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # 确定空间复杂度类别
        if avg_growth < 1.1:
            return "O(1) - 常数空间"
        elif avg_growth < 1.5:
            return "O(log n) - 对数空间"
        elif avg_growth < 2.0:
            return "O(n) - 线性空间"
        elif avg_growth < 3.0:
            return "O(n log n) - 线性对数空间"
        elif avg_growth < 10.0:
            return "O(n²) - 平方空间"
        else:
            return "O(n³) 或更高 - 立方或更高空间"

# 示例：空间复杂度分析
def demonstrate_space_complexity():
    """演示空间复杂度分析"""
    analyzer = SpaceComplexityAnalyzer()
    
    # 测试算法
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        BubbleSort(),
        QuickSort(),
        MergeSort()
    ]
    
    print("=== 算法空间复杂度分析 ===")
    
    input_sizes = [10, 20, 50]
    
    for algorithm in algorithms:
        measurements = analyzer.measure_space_complexity(algorithm, input_sizes)
        complexity = analyzer.analyze_space_complexity(measurements)
        
        print(f"{algorithm.name}: {complexity}")
        print(f"  内存测量: {measurements}")
    
    return analyzer

# 运行示例
space_complexity_analysis = demonstrate_space_complexity()
```

### 3. 算法设计模式

#### 3.1 分治模式

**数学定义**：
分治算法将问题分解为子问题：$T(n) = aT(n/b) + f(n)$

**Python实现**：

```python
class DivideAndConquerPattern:
    """分治模式"""
    
    @staticmethod
    def solve(problem: Any, divide_func: Callable, 
              conquer_func: Callable, combine_func: Callable) -> Any:
        """分治算法模板"""
        # 基本情况
        if conquer_func(problem):
            return conquer_func(problem)
        
        # 分解
        subproblems = divide_func(problem)
        
        # 递归解决
        solutions = []
        for subproblem in subproblems:
            solution = DivideAndConquerPattern.solve(
                subproblem, divide_func, conquer_func, combine_func
            )
            solutions.append(solution)
        
        # 合并
        return combine_func(solutions)

# 示例：分治模式应用
def demonstrate_divide_and_conquer():
    """演示分治模式"""
    # 归并排序的分治实现
    def divide(array: List[int]) -> List[List[int]]:
        mid = len(array) // 2
        return [array[:mid], array[mid:]]
    
    def conquer(array: List[int]) -> bool:
        return len(array) <= 1
    
    def conquer_simple(array: List[int]) -> List[int]:
        return array
    
    def combine(solutions: List[List[int]]) -> List[int]:
        if len(solutions) != 2:
            return solutions[0] if solutions else []
        
        left, right = solutions
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    # 测试
    test_array = [5, 2, 4, 1, 3]
    result = DivideAndConquerPattern.solve(
        test_array, divide, conquer, combine
    )
    
    print("分治模式示例:")
    print(f"原始数组: {test_array}")
    print(f"排序结果: {result}")
    
    return result

# 运行示例
divide_conquer_demo = demonstrate_divide_and_conquer()
```

#### 3.2 动态规划模式

**数学定义**：
动态规划基于最优子结构：$OPT(i) = \max_{j \in S_i} \{OPT(j) + f(i,j)\}$

**Python实现**：

```python
from functools import lru_cache

class DynamicProgrammingPattern:
    """动态规划模式"""
    
    @staticmethod
    def solve_with_memoization(problem: Any, 
                              subproblem_func: Callable,
                              base_case_func: Callable,
                              transition_func: Callable) -> Any:
        """带记忆化的动态规划"""
        memo = {}
        
        def dp_solve(current_problem):
            if current_problem in memo:
                return memo[current_problem]
            
            # 基本情况
            if base_case_func(current_problem):
                result = base_case_func(current_problem)
            else:
                # 获取子问题
                subproblems = subproblem_func(current_problem)
                
                # 递归解决
                sub_results = []
                for subproblem in subproblems:
                    sub_result = dp_solve(subproblem)
                    sub_results.append(sub_result)
                
                # 状态转移
                result = transition_func(current_problem, sub_results)
            
            memo[current_problem] = result
            return result
        
        return dp_solve(problem)
    
    @staticmethod
    def solve_with_tabulation(problem_size: int,
                             base_cases: Dict[int, Any],
                             transition_func: Callable) -> Any:
        """表格化的动态规划"""
        dp_table = {}
        
        # 初始化基本情况
        for case, value in base_cases.items():
            dp_table[case] = value
        
        # 填充表格
        for i in range(max(base_cases.keys()) + 1, problem_size + 1):
            dp_table[i] = transition_func(i, dp_table)
        
        return dp_table[problem_size]

# 示例：动态规划模式应用
def demonstrate_dynamic_programming():
    """演示动态规划模式"""
    # 斐波那契数列的动态规划
    def fibonacci_subproblems(n: int) -> List[int]:
        return [n - 1, n - 2]
    
    def fibonacci_base_case(n: int) -> bool:
        return n <= 1
    
    def fibonacci_base_case_value(n: int) -> int:
        return n
    
    def fibonacci_transition(n: int, sub_results: List[int]) -> int:
        return sub_results[0] + sub_results[1]
    
    # 使用记忆化
    result1 = DynamicProgrammingPattern.solve_with_memoization(
        10, fibonacci_subproblems, fibonacci_base_case, fibonacci_transition
    )
    
    # 使用表格化
    base_cases = {0: 0, 1: 1}
    result2 = DynamicProgrammingPattern.solve_with_tabulation(
        10, base_cases, lambda n, table: table[n-1] + table[n-2]
    )
    
    print("动态规划模式示例:")
    print(f"斐波那契(10) - 记忆化: {result1}")
    print(f"斐波那契(10) - 表格化: {result2}")
    
    return result1, result2

# 运行示例
dp_demo = demonstrate_dynamic_programming()
```

## 📊 算法理论总结

### 核心概念

1. **算法定义**：有限的计算过程
2. **复杂度分析**：时间和空间复杂度
3. **设计模式**：分治、动态规划、贪心等
4. **算法分类**：搜索、排序、图算法等

### 数学形式化

算法理论可以用以下数学结构表示：

$$AlgorithmTheory = (Definition, Complexity, Design, Analysis)$$

### Python实现验证

```python
class AlgorithmTheoryValidator:
    """算法理论验证器"""
    
    def __init__(self):
        self.test_algorithms = [
            LinearSearch(),
            BinarySearch(),
            BubbleSort(),
            QuickSort()
        ]
    
    def validate_algorithm_execution(self) -> bool:
        """验证算法执行"""
        test_data = [5, 2, 4, 1, 3]
        expected_sorted = [1, 2, 3, 4, 5]
        
        for algorithm in self.test_algorithms:
            if algorithm.algorithm_type == AlgorithmType.SORTING:
                result = algorithm.execute(test_data)
                if result != expected_sorted:
                    return False
        
        return True
    
    def validate_complexity_analysis(self) -> bool:
        """验证复杂度分析"""
        analyzer = ComplexityAnalyzer()
        measurements = analyzer.measure_time_complexity(
            LinearSearch(), [10, 20, 50]
        )
        
        return len(measurements) == 3
    
    def validate_design_patterns(self) -> bool:
        """验证设计模式"""
        # 测试分治模式
        test_array = [3, 1, 2]
        result = DivideAndConquerPattern.solve(
            test_array,
            lambda x: [x[:len(x)//2], x[len(x)//2:]],
            lambda x: len(x) <= 1,
            lambda x: x[0] if len(x) == 1 else x[0] + x[1]
        )
        
        return result == [1, 2, 3]
    
    def run_all_tests(self) -> Dict[str, bool]:
        """运行所有测试"""
        tests = {
            'algorithm_execution': self.validate_algorithm_execution(),
            'complexity_analysis': self.validate_complexity_analysis(),
            'design_patterns': self.validate_design_patterns()
        }
        
        print("=== 算法理论验证结果 ===")
        for test_name, result in tests.items():
            print(f"{test_name}: {'PASS' if result else 'FAIL'}")
        
        return tests

# 使用示例
validator = AlgorithmTheoryValidator()
test_results = validator.run_all_tests()
```

## 🔗 相关链接

- [01.03 图论基础](../01-形式科学/01.03-图论基础.md)
- [02.02 数据结构理论](./02.02-数据结构理论.md)
- [03.01 设计模式科学](../03-具体科学/03.01-设计模式科学.md)

---

*算法理论为软件工程提供了计算基础，通过形式化定义和Python实现，我们可以设计、分析和优化各种算法。*
