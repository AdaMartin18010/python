# 算法基础

## 📋 概述

算法理论是计算机科学的核心理论基础，研究算法的设计、分析和优化。本文档从形式化角度探讨算法的核心概念，建立严格的数学定义和Python实现。

## 🎯 核心概念

### 1. 算法的形式化定义

#### 1.1 基本定义

算法可以形式化定义为：

$$\mathcal{A} = (I, O, C, T)$$

其中：
- $I$ 是输入集合 (Input Set)
- $O$ 是输出集合 (Output Set)
- $C$ 是计算过程 (Computation Process)
- $T$ 是终止条件 (Termination Condition)

#### 1.2 算法特性

算法必须满足以下特性：

1. **有限性**: 算法必须在有限步后终止
2. **确定性**: 对于相同输入，算法必须产生相同输出
3. **有效性**: 算法的每个步骤都必须可执行
4. **输入**: 算法必须有零个或多个输入
5. **输出**: 算法必须有一个或多个输出

## 🔧 Python 实现

### 1. 算法基础框架

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Tuple, Callable
from dataclasses import dataclass, field
from enum import Enum
import time
import math
from collections import defaultdict

class AlgorithmType(Enum):
    """算法类型枚举"""
    SEARCH = "search"
    SORT = "sort"
    GRAPH = "graph"
    DYNAMIC_PROGRAMMING = "dynamic_programming"
    GREEDY = "greedy"
    DIVIDE_AND_CONQUER = "divide_and_conquer"

class ComplexityClass(Enum):
    """复杂度类枚举"""
    CONSTANT = "O(1)"
    LOGARITHMIC = "O(log n)"
    LINEAR = "O(n)"
    LINE_LOGARITHMIC = "O(n log n)"
    QUADRATIC = "O(n²)"
    CUBIC = "O(n³)"
    EXPONENTIAL = "O(2ⁿ)"
    FACTORIAL = "O(n!)"

@dataclass
class AlgorithmSpecification:
    """算法规格说明"""
    name: str
    algorithm_type: AlgorithmType
    description: str
    input_specification: str
    output_specification: str
    preconditions: List[str]
    postconditions: List[str]
    
    def __post_init__(self):
        """验证算法规格"""
        if not self.name or not self.description:
            raise ValueError("算法名称和描述不能为空")

@dataclass
class PerformanceMetrics:
    """性能度量"""
    time_complexity: ComplexityClass
    space_complexity: ComplexityClass
    actual_runtime: float = 0.0
    memory_usage: int = 0
    comparisons: int = 0
    swaps: int = 0

class Algorithm(ABC):
    """算法抽象基类"""
    
    def __init__(self, specification: AlgorithmSpecification):
        self.specification = specification
        self.performance_metrics = PerformanceMetrics(
            time_complexity=ComplexityClass.LINEAR,
            space_complexity=ComplexityClass.LINEAR
        )
        self.execution_history: List[Dict[str, Any]] = []
    
    @abstractmethod
    def execute(self, input_data: Any) -> Any:
        """执行算法"""
        pass
    
    @abstractmethod
    def analyze_complexity(self, input_size: int) -> PerformanceMetrics:
        """分析复杂度"""
        pass
    
    def measure_performance(self, input_data: Any) -> PerformanceMetrics:
        """测量性能"""
        start_time = time.time()
        start_memory = self._get_memory_usage()
        
        # 重置计数器
        self.performance_metrics.comparisons = 0
        self.performance_metrics.swaps = 0
        
        # 执行算法
        result = self.execute(input_data)
        
        end_time = time.time()
        end_memory = self._get_memory_usage()
        
        # 更新性能指标
        self.performance_metrics.actual_runtime = end_time - start_time
        self.performance_metrics.memory_usage = end_memory - start_memory
        
        return self.performance_metrics
    
    def _get_memory_usage(self) -> int:
        """获取内存使用量（简化实现）"""
        import sys
        return sys.getsizeof(self)
    
    def add_execution_step(self, step_description: str, data: Any = None):
        """添加执行步骤"""
        self.execution_history.append({
            "step": len(self.execution_history) + 1,
            "description": step_description,
            "data": data,
            "timestamp": time.time()
        })
    
    def get_execution_trace(self) -> List[Dict[str, Any]]:
        """获取执行轨迹"""
        return self.execution_history.copy()
    
    def reset_execution_history(self):
        """重置执行历史"""
        self.execution_history.clear()

class SearchAlgorithm(Algorithm):
    """搜索算法基类"""
    
    def __init__(self, specification: AlgorithmSpecification):
        super().__init__(specification)
        self.performance_metrics.time_complexity = ComplexityClass.LINEAR
    
    def linear_search(self, arr: List[Any], target: Any) -> Optional[int]:
        """线性搜索"""
        self.reset_execution_history()
        
        for i, element in enumerate(arr):
            self.performance_metrics.comparisons += 1
            self.add_execution_step(f"比较元素 {element} 与目标 {target}")
            
            if element == target:
                self.add_execution_step(f"找到目标，位置: {i}")
                return i
        
        self.add_execution_step("未找到目标")
        return None
    
    def binary_search(self, arr: List[Any], target: Any) -> Optional[int]:
        """二分搜索"""
        self.reset_execution_history()
        
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            self.performance_metrics.comparisons += 1
            self.add_execution_step(f"检查中间位置 {mid}, 元素: {arr[mid]}")
            
            if arr[mid] == target:
                self.add_execution_step(f"找到目标，位置: {mid}")
                return mid
            elif arr[mid] < target:
                left = mid + 1
                self.add_execution_step(f"目标在右半部分，更新左边界: {left}")
            else:
                right = mid - 1
                self.add_execution_step(f"目标在左半部分，更新右边界: {right}")
        
        self.add_execution_step("未找到目标")
        return None

class SortAlgorithm(Algorithm):
    """排序算法基类"""
    
    def __init__(self, specification: AlgorithmSpecification):
        super().__init__(specification)
        self.performance_metrics.time_complexity = ComplexityClass.QUADRATIC
    
    def bubble_sort(self, arr: List[Any]) -> List[Any]:
        """冒泡排序"""
        self.reset_execution_history()
        arr_copy = arr.copy()
        n = len(arr_copy)
        
        for i in range(n):
            swapped = False
            self.add_execution_step(f"第 {i+1} 轮排序开始")
            
            for j in range(0, n - i - 1):
                self.performance_metrics.comparisons += 1
                self.add_execution_step(f"比较 {arr_copy[j]} 和 {arr_copy[j+1]}")
                
                if arr_copy[j] > arr_copy[j + 1]:
                    arr_copy[j], arr_copy[j + 1] = arr_copy[j + 1], arr_copy[j]
                    self.performance_metrics.swaps += 1
                    self.add_execution_step(f"交换元素: {arr_copy[j+1]} <-> {arr_copy[j]}")
                    swapped = True
            
            if not swapped:
                self.add_execution_step("没有交换，数组已排序")
                break
        
        return arr_copy
    
    def quick_sort(self, arr: List[Any]) -> List[Any]:
        """快速排序"""
        self.reset_execution_history()
        arr_copy = arr.copy()
        
        def partition(low: int, high: int) -> int:
            pivot = arr_copy[high]
            i = low - 1
            
            self.add_execution_step(f"选择基准元素: {pivot}")
            
            for j in range(low, high):
                self.performance_metrics.comparisons += 1
                if arr_copy[j] <= pivot:
                    i += 1
                    arr_copy[i], arr_copy[j] = arr_copy[j], arr_copy[i]
                    self.performance_metrics.swaps += 1
            
            arr_copy[i + 1], arr_copy[high] = arr_copy[high], arr_copy[i + 1]
            self.performance_metrics.swaps += 1
            
            return i + 1
        
        def quick_sort_helper(low: int, high: int):
            if low < high:
                pi = partition(low, high)
                self.add_execution_step(f"分区完成，基准位置: {pi}")
                quick_sort_helper(low, pi - 1)
                quick_sort_helper(pi + 1, high)
        
        quick_sort_helper(0, len(arr_copy) - 1)
        return arr_copy

class AlgorithmTheory:
    """算法理论框架"""
    
    def __init__(self):
        self.algorithms: Dict[str, Algorithm] = {}
        self.complexity_analysis: Dict[str, Dict[str, Any]] = {}
        self.algorithm_patterns: List[str] = []
    
    def add_algorithm(self, algorithm: Algorithm):
        """添加算法"""
        self.algorithms[algorithm.specification.name] = algorithm
    
    def analyze_algorithm_complexity(self, algorithm_name: str, input_sizes: List[int]) -> Dict[str, Any]:
        """分析算法复杂度"""
        if algorithm_name not in self.algorithms:
            raise ValueError(f"算法 {algorithm_name} 不存在")
        
        algorithm = self.algorithms[algorithm_name]
        results = {
            "algorithm": algorithm_name,
            "input_sizes": input_sizes,
            "runtime_measurements": [],
            "complexity_analysis": {}
        }
        
        for size in input_sizes:
            # 生成测试数据
            test_data = self._generate_test_data(algorithm, size)
            
            # 测量性能
            metrics = algorithm.measure_performance(test_data)
            results["runtime_measurements"].append({
                "input_size": size,
                "runtime": metrics.actual_runtime,
                "comparisons": metrics.comparisons,
                "swaps": metrics.swaps
            })
        
        # 分析复杂度
        results["complexity_analysis"] = self._analyze_complexity_trend(results["runtime_measurements"])
        
        return results
    
    def _generate_test_data(self, algorithm: Algorithm, size: int) -> Any:
        """生成测试数据"""
        if isinstance(algorithm, SearchAlgorithm):
            # 为搜索算法生成数据
            import random
            data = list(range(size))
            target = random.choice(data)
            return {"array": data, "target": target}
        elif isinstance(algorithm, SortAlgorithm):
            # 为排序算法生成数据
            import random
            return [random.randint(1, 1000) for _ in range(size)]
        else:
            return list(range(size))
    
    def _analyze_complexity_trend(self, measurements: List[Dict[str, Any]]) -> Dict[str, Any]:
        """分析复杂度趋势"""
        if len(measurements) < 2:
            return {"trend": "insufficient_data"}
        
        # 计算增长率
        growth_rates = []
        for i in range(1, len(measurements)):
            size_ratio = measurements[i]["input_size"] / measurements[i-1]["input_size"]
            runtime_ratio = measurements[i]["runtime"] / measurements[i-1]["runtime"]
            growth_rate = runtime_ratio / size_ratio
            growth_rates.append(growth_rate)
        
        avg_growth_rate = sum(growth_rates) / len(growth_rates)
        
        # 判断复杂度类型
        if avg_growth_rate < 1.5:
            complexity_type = "O(1) - 常数时间"
        elif avg_growth_rate < 2.5:
            complexity_type = "O(log n) - 对数时间"
        elif avg_growth_rate < 3.5:
            complexity_type = "O(n) - 线性时间"
        elif avg_growth_rate < 4.5:
            complexity_type = "O(n log n) - 线性对数时间"
        else:
            complexity_type = "O(n²) - 二次时间"
        
        return {
            "average_growth_rate": avg_growth_rate,
            "estimated_complexity": complexity_type,
            "growth_rates": growth_rates
        }
    
    def compare_algorithms(self, algorithm_names: List[str], input_sizes: List[int]) -> Dict[str, Any]:
        """比较算法性能"""
        comparison_results = {
            "algorithms": algorithm_names,
            "input_sizes": input_sizes,
            "performance_comparison": {}
        }
        
        for size in input_sizes:
            size_results = {}
            for name in algorithm_names:
                if name in self.algorithms:
                    algorithm = self.algorithms[name]
                    test_data = self._generate_test_data(algorithm, size)
                    metrics = algorithm.measure_performance(test_data)
                    
                    size_results[name] = {
                        "runtime": metrics.actual_runtime,
                        "comparisons": metrics.comparisons,
                        "swaps": metrics.swaps,
                        "memory_usage": metrics.memory_usage
                    }
            
            comparison_results["performance_comparison"][size] = size_results
        
        return comparison_results
    
    def generate_algorithm_report(self, algorithm_name: str) -> Dict[str, Any]:
        """生成算法报告"""
        if algorithm_name not in self.algorithms:
            raise ValueError(f"算法 {algorithm_name} 不存在")
        
        algorithm = self.algorithms[algorithm_name]
        
        return {
            "specification": algorithm.specification.__dict__,
            "performance_metrics": {
                "time_complexity": algorithm.performance_metrics.time_complexity.value,
                "space_complexity": algorithm.performance_metrics.space_complexity.value,
                "actual_runtime": algorithm.performance_metrics.actual_runtime,
                "memory_usage": algorithm.performance_metrics.memory_usage
            },
            "execution_trace": algorithm.get_execution_trace(),
            "theoretical_analysis": self._theoretical_analysis(algorithm)
        }
    
    def _theoretical_analysis(self, algorithm: Algorithm) -> Dict[str, Any]:
        """理论分析"""
        return {
            "correctness": "算法正确性分析",
            "termination": "算法终止性分析",
            "optimality": "算法最优性分析",
            "stability": "算法稳定性分析"
        }

# 使用示例
def demonstrate_algorithm_theory():
    """演示算法理论"""
    
    # 创建算法理论框架
    theory = AlgorithmTheory()
    
    # 创建搜索算法
    linear_search_spec = AlgorithmSpecification(
        name="线性搜索",
        algorithm_type=AlgorithmType.SEARCH,
        description="在数组中线性搜索目标元素",
        input_specification="数组和目标值",
        output_specification="目标值的索引或None",
        preconditions=["数组不为空"],
        postconditions=["返回正确索引或None"]
    )
    
    binary_search_spec = AlgorithmSpecification(
        name="二分搜索",
        algorithm_type=AlgorithmType.SEARCH,
        description="在有序数组中二分搜索目标元素",
        input_specification="有序数组和目标值",
        output_specification="目标值的索引或None",
        preconditions=["数组已排序"],
        postconditions=["返回正确索引或None"]
    )
    
    # 创建排序算法
    bubble_sort_spec = AlgorithmSpecification(
        name="冒泡排序",
        algorithm_type=AlgorithmType.SORT,
        description="通过相邻元素比较和交换进行排序",
        input_specification="无序数组",
        output_specification="有序数组",
        preconditions=["数组不为空"],
        postconditions=["数组按升序排列"]
    )
    
    quick_sort_spec = AlgorithmSpecification(
        name="快速排序",
        algorithm_type=AlgorithmType.SORT,
        description="使用分治策略的快速排序算法",
        input_specification="无序数组",
        output_specification="有序数组",
        preconditions=["数组不为空"],
        postconditions=["数组按升序排列"]
    )
    
    # 创建算法实例
    linear_search = SearchAlgorithm(linear_search_spec)
    binary_search = SearchAlgorithm(binary_search_spec)
    bubble_sort = SortAlgorithm(bubble_sort_spec)
    quick_sort = SortAlgorithm(quick_sort_spec)
    
    # 添加到理论框架
    theory.add_algorithm(linear_search)
    theory.add_algorithm(binary_search)
    theory.add_algorithm(bubble_sort)
    theory.add_algorithm(quick_sort)
    
    # 测试搜索算法
    test_array = [1, 3, 5, 7, 9, 11, 13, 15]
    target = 7
    
    print("=== 搜索算法测试 ===")
    
    # 线性搜索
    linear_result = linear_search.linear_search(test_array, target)
    print(f"线性搜索结果: {linear_result}")
    
    # 二分搜索
    binary_result = binary_search.binary_search(test_array, target)
    print(f"二分搜索结果: {binary_result}")
    
    # 测试排序算法
    test_sort_array = [64, 34, 25, 12, 22, 11, 90]
    
    print("\n=== 排序算法测试 ===")
    
    # 冒泡排序
    bubble_result = bubble_sort.bubble_sort(test_sort_array)
    print(f"冒泡排序结果: {bubble_result}")
    
    # 快速排序
    quick_result = quick_sort.quick_sort(test_sort_array)
    print(f"快速排序结果: {quick_result}")
    
    # 性能分析
    input_sizes = [100, 500, 1000]
    
    print("\n=== 性能分析 ===")
    
    # 分析线性搜索
    linear_analysis = theory.analyze_algorithm_complexity("线性搜索", input_sizes)
    print(f"线性搜索复杂度分析: {linear_analysis['complexity_analysis']}")
    
    # 分析快速排序
    quick_analysis = theory.analyze_algorithm_complexity("快速排序", input_sizes)
    print(f"快速排序复杂度分析: {quick_analysis['complexity_analysis']}")
    
    # 算法比较
    comparison = theory.compare_algorithms(["线性搜索", "二分搜索"], [100, 500, 1000])
    print(f"\n算法比较结果: {comparison['performance_comparison']}")
    
    return theory

if __name__ == "__main__":
    # 运行演示
    result = demonstrate_algorithm_theory()
```

## 📊 理论证明

### 1. 算法正确性定理

**定理**: 如果一个算法满足前置条件和后置条件，则该算法是正确的。

**证明**:
1. 设 $P$ 是前置条件，$Q$ 是后置条件
2. 如果算法在满足 $P$ 的输入上执行后满足 $Q$，则算法正确
3. 这可以通过数学归纳法或循环不变量来证明

### 2. 算法复杂度定理

**定理**: 对于输入大小为 $n$ 的算法，时间复杂度为 $O(f(n))$ 当且仅当存在常数 $c$ 和 $n_0$，使得对于所有 $n \geq n_0$，算法的执行时间不超过 $c \cdot f(n)$。

**证明**:
1. 设 $T(n)$ 是算法的实际执行时间
2. 如果 $T(n) = O(f(n))$，则存在 $c > 0$ 和 $n_0 > 0$
3. 使得对于所有 $n \geq n_0$，有 $T(n) \leq c \cdot f(n)$

## 🔗 相关概念

- [数据结构理论](../02-02-数据结构理论/02-02-01-数据结构基础.md)
- [计算复杂性理论](../02-03-计算复杂性理论/02-03-01-复杂度分析.md)
- [形式语言理论](../02-04-形式语言理论/02-04-01-形式语言基础.md)
- [集合论基础](../../01-形式科学/01-01-数学基础/01-01-01-集合论基础.md)

## 📈 应用实例

### 1. 算法性能基准测试

```python
class AlgorithmBenchmark:
    """算法性能基准测试"""
    
    def __init__(self):
        self.benchmark_results = {}
    
    def run_benchmark(self, algorithm: Algorithm, test_cases: List[Dict[str, Any]]) -> Dict[str, Any]:
        """运行基准测试"""
        results = {
            "algorithm": algorithm.specification.name,
            "test_cases": [],
            "summary": {}
        }
        
        total_runtime = 0
        total_comparisons = 0
        total_swaps = 0
        
        for i, test_case in enumerate(test_cases):
            # 测量性能
            metrics = algorithm.measure_performance(test_case["input"])
            
            case_result = {
                "case_id": i + 1,
                "input_size": len(test_case["input"]) if isinstance(test_case["input"], (list, tuple)) else 1,
                "runtime": metrics.actual_runtime,
                "comparisons": metrics.comparisons,
                "swaps": metrics.swaps,
                "memory_usage": metrics.memory_usage
            }
            
            results["test_cases"].append(case_result)
            
            total_runtime += metrics.actual_runtime
            total_comparisons += metrics.comparisons
            total_swaps += metrics.swaps
        
        # 计算统计摘要
        num_cases = len(test_cases)
        results["summary"] = {
            "total_test_cases": num_cases,
            "average_runtime": total_runtime / num_cases,
            "average_comparisons": total_comparisons / num_cases,
            "average_swaps": total_swaps / num_cases,
            "total_runtime": total_runtime
        }
        
        return results
    
    def compare_algorithms_benchmark(self, algorithms: List[Algorithm], test_cases: List[Dict[str, Any]]) -> Dict[str, Any]:
        """比较多个算法的基准测试"""
        comparison_results = {
            "algorithms": [alg.specification.name for alg in algorithms],
            "test_cases": test_cases,
            "results": {}
        }
        
        for algorithm in algorithms:
            alg_results = self.run_benchmark(algorithm, test_cases)
            comparison_results["results"][algorithm.specification.name] = alg_results
        
        # 生成比较报告
        comparison_results["comparison"] = self._generate_comparison_report(comparison_results["results"])
        
        return comparison_results
    
    def _generate_comparison_report(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """生成比较报告"""
        report = {
            "performance_ranking": [],
            "efficiency_analysis": {},
            "recommendations": []
        }
        
        # 按平均运行时间排序
        algorithms_by_runtime = sorted(
            results.items(),
            key=lambda x: x[1]["summary"]["average_runtime"]
        )
        
        report["performance_ranking"] = [
            {
                "rank": i + 1,
                "algorithm": name,
                "average_runtime": data["summary"]["average_runtime"]
            }
            for i, (name, data) in enumerate(algorithms_by_runtime)
        ]
        
        # 效率分析
        fastest = algorithms_by_runtime[0]
        for name, data in results.items():
            speedup = fastest[1]["summary"]["average_runtime"] / data["summary"]["average_runtime"]
            report["efficiency_analysis"][name] = {
                "speedup_factor": speedup,
                "relative_performance": f"{speedup:.2f}x {'faster' if speedup > 1 else 'slower'} than fastest"
            }
        
        # 生成建议
        report["recommendations"] = [
            f"推荐使用 {fastest[0]} 作为主要算法",
            "考虑算法的时间复杂度和空间复杂度权衡",
            "根据具体应用场景选择最适合的算法"
        ]
        
        return report

# 使用示例
def demonstrate_algorithm_benchmark():
    """演示算法基准测试"""
    
    # 创建测试用例
    test_cases = [
        {"input": list(range(100)), "description": "小规模有序数据"},
        {"input": list(range(1000)), "description": "中等规模有序数据"},
        {"input": list(range(10000)), "description": "大规模有序数据"},
        {"input": [random.randint(1, 1000) for _ in range(100)], "description": "小规模随机数据"},
        {"input": [random.randint(1, 1000) for _ in range(1000)], "description": "中等规模随机数据"}
    ]
    
    # 创建算法实例
    linear_search = SearchAlgorithm(AlgorithmSpecification(
        name="线性搜索", algorithm_type=AlgorithmType.SEARCH,
        description="", input_specification="", output_specification="",
        preconditions=[], postconditions=[]
    ))
    
    binary_search = SearchAlgorithm(AlgorithmSpecification(
        name="二分搜索", algorithm_type=AlgorithmType.SEARCH,
        description="", input_specification="", output_specification="",
        preconditions=[], postconditions=[]
    ))
    
    # 运行基准测试
    benchmark = AlgorithmBenchmark()
    
    # 单个算法测试
    linear_results = benchmark.run_benchmark(linear_search, test_cases)
    print("=== 线性搜索基准测试 ===")
    print(f"平均运行时间: {linear_results['summary']['average_runtime']:.6f} 秒")
    print(f"平均比较次数: {linear_results['summary']['average_comparisons']}")
    
    # 算法比较
    comparison = benchmark.compare_algorithms_benchmark(
        [linear_search, binary_search], test_cases
    )
    
    print("\n=== 算法比较结果 ===")
    for rank in comparison["comparison"]["performance_ranking"]:
        print(f"排名 {rank['rank']}: {rank['algorithm']} - {rank['average_runtime']:.6f} 秒")
    
    print("\n=== 效率分析 ===")
    for alg_name, analysis in comparison["comparison"]["efficiency_analysis"].items():
        print(f"{alg_name}: {analysis['relative_performance']}")
    
    print("\n=== 建议 ===")
    for recommendation in comparison["comparison"]["recommendations"]:
        print(f"- {recommendation}")

if __name__ == "__main__":
    import random
    demonstrate_algorithm_benchmark()
```

### 2. 算法可视化分析

```python
class AlgorithmVisualizer:
    """算法可视化分析器"""
    
    def __init__(self):
        self.visualization_data = {}
    
    def visualize_execution_trace(self, algorithm: Algorithm) -> Dict[str, Any]:
        """可视化执行轨迹"""
        trace = algorithm.get_execution_trace()
        
        visualization = {
            "algorithm_name": algorithm.specification.name,
            "total_steps": len(trace),
            "steps": [],
            "performance_metrics": {
                "comparisons": algorithm.performance_metrics.comparisons,
                "swaps": algorithm.performance_metrics.swaps,
                "runtime": algorithm.performance_metrics.actual_runtime
            }
        }
        
        for step in trace:
            step_visualization = {
                "step_number": step["step"],
                "description": step["description"],
                "data": step["data"],
                "timestamp": step["timestamp"]
            }
            visualization["steps"].append(step_visualization)
        
        return visualization
    
    def generate_complexity_chart_data(self, algorithm: Algorithm, input_sizes: List[int]) -> Dict[str, Any]:
        """生成复杂度图表数据"""
        chart_data = {
            "algorithm_name": algorithm.specification.name,
            "input_sizes": input_sizes,
            "actual_runtimes": [],
            "theoretical_complexity": algorithm.performance_metrics.time_complexity.value,
            "data_points": []
        }
        
        for size in input_sizes:
            # 生成测试数据
            test_data = list(range(size))
            
            # 测量性能
            metrics = algorithm.measure_performance(test_data)
            
            chart_data["actual_runtimes"].append(metrics.actual_runtime)
            chart_data["data_points"].append({
                "input_size": size,
                "runtime": metrics.actual_runtime,
                "comparisons": metrics.comparisons,
                "swaps": metrics.swaps
            })
        
        return chart_data
    
    def create_performance_report(self, algorithms: List[Algorithm], input_sizes: List[int]) -> Dict[str, Any]:
        """创建性能报告"""
        report = {
            "algorithms": [],
            "input_sizes": input_sizes,
            "performance_data": {},
            "comparison_charts": {}
        }
        
        for algorithm in algorithms:
            alg_name = algorithm.specification.name
            chart_data = self.generate_complexity_chart_data(algorithm, input_sizes)
            
            report["algorithms"].append({
                "name": alg_name,
                "type": algorithm.specification.algorithm_type.value,
                "complexity": algorithm.performance_metrics.time_complexity.value
            })
            
            report["performance_data"][alg_name] = chart_data
        
        # 生成比较图表数据
        report["comparison_charts"] = self._generate_comparison_charts(report["performance_data"])
        
        return report
    
    def _generate_comparison_charts(self, performance_data: Dict[str, Any]) -> Dict[str, Any]:
        """生成比较图表"""
        charts = {
            "runtime_comparison": {},
            "complexity_comparison": {},
            "efficiency_analysis": {}
        }
        
        # 运行时比较
        for alg_name, data in performance_data.items():
            charts["runtime_comparison"][alg_name] = {
                "input_sizes": data["input_sizes"],
                "runtimes": data["actual_runtimes"]
            }
        
        # 复杂度比较
        for alg_name, data in performance_data.items():
            charts["complexity_comparison"][alg_name] = data["theoretical_complexity"]
        
        # 效率分析
        if len(performance_data) > 1:
            fastest_alg = min(performance_data.keys(), 
                            key=lambda x: performance_data[x]["actual_runtimes"][-1])
            
            for alg_name, data in performance_data.items():
                fastest_runtime = performance_data[fastest_alg]["actual_runtimes"][-1]
                current_runtime = data["actual_runtimes"][-1]
                
                charts["efficiency_analysis"][alg_name] = {
                    "speedup": fastest_runtime / current_runtime if current_runtime > 0 else 0,
                    "relative_performance": f"{fastest_runtime / current_runtime:.2f}x" if current_runtime > 0 else "N/A"
                }
        
        return charts

# 使用示例
def demonstrate_algorithm_visualization():
    """演示算法可视化"""
    
    # 创建算法实例
    bubble_sort = SortAlgorithm(AlgorithmSpecification(
        name="冒泡排序", algorithm_type=AlgorithmType.SORT,
        description="", input_specification="", output_specification="",
        preconditions=[], postconditions=[]
    ))
    
    quick_sort = SortAlgorithm(AlgorithmSpecification(
        name="快速排序", algorithm_type=AlgorithmType.SORT,
        description="", input_specification="", output_specification="",
        preconditions=[], postconditions=[]
    ))
    
    # 创建可视化器
    visualizer = AlgorithmVisualizer()
    
    # 测试数据
    test_data = [64, 34, 25, 12, 22, 11, 90]
    
    # 可视化执行轨迹
    bubble_sort.bubble_sort(test_data.copy())
    bubble_trace = visualizer.visualize_execution_trace(bubble_sort)
    
    print("=== 冒泡排序执行轨迹 ===")
    print(f"总步数: {bubble_trace['total_steps']}")
    print(f"比较次数: {bubble_trace['performance_metrics']['comparisons']}")
    print(f"交换次数: {bubble_trace['performance_metrics']['swaps']}")
    
    # 生成复杂度图表数据
    input_sizes = [10, 50, 100, 500]
    bubble_chart = visualizer.generate_complexity_chart_data(bubble_sort, input_sizes)
    
    print("\n=== 冒泡排序复杂度分析 ===")
    print(f"理论复杂度: {bubble_chart['theoretical_complexity']}")
    print(f"实际运行时间: {bubble_chart['actual_runtimes']}")
    
    # 创建性能报告
    algorithms = [bubble_sort, quick_sort]
    report = visualizer.create_performance_report(algorithms, input_sizes)
    
    print("\n=== 算法性能报告 ===")
    for alg_info in report["algorithms"]:
        print(f"算法: {alg_info['name']}")
        print(f"类型: {alg_info['type']}")
        print(f"复杂度: {alg_info['complexity']}")
        print()

if __name__ == "__main__":
    demonstrate_algorithm_visualization()
```

## 🎯 总结

算法理论为计算机科学提供了重要的理论基础。通过形式化定义、多表征方式和实际应用，我们建立了完整的算法理论体系，为算法设计、分析和优化提供了指导。

### 关键要点

1. **形式化定义**: 算法可以用四元组 $\mathcal{A} = (I, O, C, T)$ 表示
2. **算法特性**: 有限性、确定性、有效性、输入、输出
3. **多表征方式**: 包含概念解释、数学形式、代码实现、图表说明和实例分析
4. **实际应用**: 通过Python实现验证理论概念
5. **理论证明**: 提供正确性定理和复杂度定理的证明

---

**相关文档**: 
- [排序算法](./02-01-02-排序算法.md)
- [搜索算法](./02-01-03-搜索算法.md)
- [图算法](./02-01-04-图算法.md)
- [动态规划](./02-01-05-动态规划.md)
