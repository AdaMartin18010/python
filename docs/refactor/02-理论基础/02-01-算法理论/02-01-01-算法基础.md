# 02-01-01 算法基础

## 📋 概述

算法是计算科学的核心概念，是解决特定问题的有限步骤序列。本文档从形式化角度定义算法，建立算法分析的理论基础，并提供完整的Python实现。

## 🎯 核心概念

### 1. 算法的形式化定义

#### 1.1 基本定义

**定义 1.1** (算法)
算法是一个六元组：
$$A = (I, O, S, T, F, C)$$

其中：

- $I$ 为输入集合
- $O$ 为输出集合  
- $S$ 为状态集合
- $T$ 为转换函数：$T: S \times I \rightarrow S \times O$
- $F$ 为终止条件：$F: S \rightarrow \{True, False\}$
- $C$ 为计算资源约束

**定义 1.2** (算法的正确性)
算法 $A$ 对于问题 $P$ 是正确的，当且仅当：
$$\forall x \in I_P, A(x) = P(x)$$

**定义 1.3** (算法的终止性)
算法 $A$ 是终止的，当且仅当：
$$\forall x \in I, \exists n \in \mathbb{N}, F(T^n(x)) = True$$

#### 1.2 Python实现

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Any, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import time
import psutil
import os

Input = TypeVar('Input')
Output = TypeVar('Output')
State = TypeVar('State')

class AlgorithmStatus(Enum):
    """算法状态"""
    NOT_STARTED = "not_started"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"

@dataclass
class AlgorithmMetrics:
    """算法性能指标"""
    execution_time: float = 0.0
    memory_usage: float = 0.0
    cpu_usage: float = 0.0
    steps_count: int = 0
    input_size: int = 0
    output_size: int = 0

class Algorithm(ABC, Generic[Input, Output, State]):
    """算法抽象基类"""
    
    def __init__(self, name: str, description: str = ""):
        self.name = name
        self.description = description
        self.status = AlgorithmStatus.NOT_STARTED
        self.metrics = AlgorithmMetrics()
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None
    
    @abstractmethod
    def initialize_state(self, input_data: Input) -> State:
        """初始化状态"""
        pass
    
    @abstractmethod
    def transition(self, state: State, input_data: Input) -> tuple[State, Optional[Output]]:
        """状态转换函数"""
        pass
    
    @abstractmethod
    def is_terminated(self, state: State) -> bool:
        """终止条件检查"""
        pass
    
    @abstractmethod
    def extract_output(self, state: State) -> Output:
        """提取输出"""
        pass
    
    def execute(self, input_data: Input, timeout: Optional[float] = None) -> Output:
        """执行算法"""
        self.status = AlgorithmStatus.RUNNING
        self.start_time = time.time()
        self.metrics.input_size = self._measure_input_size(input_data)
        
        # 记录初始资源使用
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        initial_cpu = process.cpu_percent()
        
        try:
            # 初始化状态
            state = self.initialize_state(input_data)
            
            # 主循环
            while not self.is_terminated(state):
                # 检查超时
                if timeout and (time.time() - self.start_time) > timeout:
                    self.status = AlgorithmStatus.TIMEOUT
                    raise TimeoutError(f"Algorithm {self.name} timed out after {timeout} seconds")
                
                # 执行转换
                state, output = self.transition(state, input_data)
                self.metrics.steps_count += 1
                
                # 如果转换产生输出，返回
                if output is not None:
                    result = output
                    break
            else:
                # 从最终状态提取输出
                result = self.extract_output(state)
            
            # 记录最终指标
            self.end_time = time.time()
            self.metrics.execution_time = self.end_time - self.start_time
            self.metrics.memory_usage = (process.memory_info().rss / 1024 / 1024) - initial_memory
            self.metrics.cpu_usage = process.cpu_percent() - initial_cpu
            self.metrics.output_size = self._measure_output_size(result)
            
            self.status = AlgorithmStatus.COMPLETED
            return result
            
        except Exception as e:
            self.status = AlgorithmStatus.FAILED
            raise e
    
    def _measure_input_size(self, input_data: Input) -> int:
        """测量输入大小"""
        if hasattr(input_data, '__len__'):
            return len(input_data)
        elif hasattr(input_data, '__sizeof__'):
            return input_data.__sizeof__()
        else:
            return 1
    
    def _measure_output_size(self, output_data: Output) -> int:
        """测量输出大小"""
        if hasattr(output_data, '__len__'):
            return len(output_data)
        elif hasattr(output_data, '__sizeof__'):
            return output_data.__sizeof__()
        else:
            return 1
    
    def get_complexity_analysis(self) -> dict[str, Any]:
        """获取复杂度分析"""
        return {
            "time_complexity": self._analyze_time_complexity(),
            "space_complexity": self._analyze_space_complexity(),
            "empirical_metrics": self.metrics
        }
    
    @abstractmethod
    def _analyze_time_complexity(self) -> str:
        """分析时间复杂度"""
        pass
    
    @abstractmethod
    def _analyze_space_complexity(self) -> str:
        """分析空间复杂度"""
        pass

class LinearSearchAlgorithm(Algorithm[list[int], Optional[int], int]):
    """线性搜索算法实现"""
    
    def __init__(self):
        super().__init__("Linear Search", "在数组中查找目标值的线性搜索算法")
    
    def initialize_state(self, input_data: tuple[list[int], int]) -> int:
        """初始化状态为索引0"""
        return 0
    
    def transition(self, state: int, input_data: tuple[list[int], int]) -> tuple[int, Optional[int]]:
        """状态转换：检查当前元素，如果匹配则返回，否则移动到下一个"""
        array, target = input_data
        
        if state >= len(array):
            return state, None  # 未找到
        
        if array[state] == target:
            return state, state  # 找到目标
        
        return state + 1, None  # 移动到下一个位置
    
    def is_terminated(self, state: int) -> bool:
        """终止条件：已检查完所有元素"""
        return False  # 在transition中处理终止
    
    def extract_output(self, state: int) -> Optional[int]:
        """提取输出：返回找到的索引或None"""
        return None
    
    def _analyze_time_complexity(self) -> str:
        return "O(n) - 最坏情况下需要检查所有n个元素"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1) - 只使用常数额外空间"

class BinarySearchAlgorithm(Algorithm[list[int], Optional[int], tuple[int, int]]):
    """二分搜索算法实现"""
    
    def __init__(self):
        super().__init__("Binary Search", "在有序数组中查找目标值的二分搜索算法")
    
    def initialize_state(self, input_data: tuple[list[int], int]) -> tuple[int, int]:
        """初始化状态为搜索范围 [0, len(array)-1]"""
        array, _ = input_data
        return (0, len(array) - 1)
    
    def transition(self, state: tuple[int, int], input_data: tuple[list[int], int]) -> tuple[tuple[int, int], Optional[int]]:
        """状态转换：计算中点，比较目标值，缩小搜索范围"""
        array, target = input_data
        left, right = state
        
        if left > right:
            return state, None  # 未找到
        
        mid = (left + right) // 2
        
        if array[mid] == target:
            return state, mid  # 找到目标
        elif array[mid] < target:
            return (mid + 1, right), None  # 搜索右半部分
        else:
            return (left, mid - 1), None  # 搜索左半部分
    
    def is_terminated(self, state: tuple[int, int]) -> bool:
        """终止条件：搜索范围为空"""
        left, right = state
        return left > right
    
    def extract_output(self, state: tuple[int, int]) -> Optional[int]:
        """提取输出：返回找到的索引或None"""
        return None
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n) - 每次迭代将搜索范围减半"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1) - 只使用常数额外空间"

class BubbleSortAlgorithm(Algorithm[list[int], list[int], tuple[list[int], int, int]]):
    """冒泡排序算法实现"""
    
    def __init__(self):
        super().__init__("Bubble Sort", "通过相邻元素比较和交换进行排序的算法")
    
    def initialize_state(self, input_data: list[int]) -> tuple[list[int], int, int]:
        """初始化状态：数组副本，外层循环索引，内层循环索引"""
        return (input_data.copy(), 0, 0)
    
    def transition(self, state: tuple[list[int], int, int], input_data: list[int]) -> tuple[tuple[list[int], int, int], Optional[list[int]]]:
        """状态转换：执行一次比较和可能的交换"""
        array, i, j = state
        n = len(array)
        
        # 检查是否需要交换
        if j < n - i - 1:
            if array[j] > array[j + 1]:
                array[j], array[j + 1] = array[j + 1], array[j]
            return (array, i, j + 1), None
        else:
            # 完成一轮，开始下一轮
            if i < n - 1:
                return (array, i + 1, 0), None
            else:
                # 排序完成
                return state, array
    
    def is_terminated(self, state: tuple[list[int], int, int]) -> bool:
        """终止条件：所有轮次完成"""
        array, i, j = state
        return i >= len(array) - 1
    
    def extract_output(self, state: tuple[list[int], int, int]) -> list[int]:
        """提取输出：返回排序后的数组"""
        array, _, _ = state
        return array
    
    def _analyze_time_complexity(self) -> str:
        return "O(n²) - 两层嵌套循环，最坏情况下需要n²次比较"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1) - 原地排序，只使用常数额外空间"

class QuickSortAlgorithm(Algorithm[list[int], list[int], tuple[list[int], int, int, Optional[int]]]):
    """快速排序算法实现"""
    
    def __init__(self):
        super().__init__("Quick Sort", "使用分治策略的高效排序算法")
        self.stack: list[tuple[int, int]] = []
    
    def initialize_state(self, input_data: list[int]) -> tuple[list[int], int, int, Optional[int]]:
        """初始化状态：数组副本，左边界，右边界，分区点"""
        self.stack = [(0, len(input_data) - 1)]
        return (input_data.copy(), 0, len(input_data) - 1, None)
    
    def transition(self, state: tuple[list[int], int, int, Optional[int]], input_data: list[int]) -> tuple[tuple[list[int], int, int, Optional[int]], Optional[list[int]]]:
        """状态转换：执行分区或递归调用"""
        array, left, right, pivot = state
        
        if pivot is None:
            # 需要分区
            if left < right:
                pivot = self._partition(array, left, right)
                # 将子问题加入栈
                if left < pivot - 1:
                    self.stack.append((left, pivot - 1))
                if pivot + 1 < right:
                    self.stack.append((pivot + 1, right))
                return (array, left, right, pivot), None
            else:
                # 单个元素或空区间，从栈中取下一个子问题
                if self.stack:
                    next_left, next_right = self.stack.pop()
                    return (array, next_left, next_right, None), None
                else:
                    # 所有子问题完成
                    return state, array
        else:
            # 分区完成，从栈中取下一个子问题
            if self.stack:
                next_left, next_right = self.stack.pop()
                return (array, next_left, next_right, None), None
            else:
                # 所有子问题完成
                return state, array
    
    def _partition(self, array: list[int], left: int, right: int) -> int:
        """分区函数：选择最后一个元素作为基准，将小于基准的元素移到左边"""
        pivot = array[right]
        i = left - 1
        
        for j in range(left, right):
            if array[j] <= pivot:
                i += 1
                array[i], array[j] = array[j], array[i]
        
        array[i + 1], array[right] = array[right], array[i + 1]
        return i + 1
    
    def is_terminated(self, state: tuple[list[int], int, int, Optional[int]]) -> bool:
        """终止条件：所有子问题完成"""
        return len(self.stack) == 0 and state[3] is not None
    
    def extract_output(self, state: tuple[list[int], int, int, Optional[int]]) -> list[int]:
        """提取输出：返回排序后的数组"""
        array, _, _, _ = state
        return array
    
    def _analyze_time_complexity(self) -> str:
        return "O(n log n) - 平均情况，最坏情况O(n²)"
    
    def _analyze_space_complexity(self) -> str:
        return "O(log n) - 递归调用栈深度"

# 算法测试和演示
def demonstrate_algorithms():
    """演示各种算法的使用"""
    
    # 测试数据
    test_array = [64, 34, 25, 12, 22, 11, 90]
    sorted_array = sorted(test_array)
    target_value = 22
    
    print("=== 算法演示 ===\n")
    
    # 1. 线性搜索
    print("1. 线性搜索算法")
    linear_search = LinearSearchAlgorithm()
    result = linear_search.execute((test_array, target_value))
    print(f"在数组 {test_array} 中查找 {target_value}")
    print(f"结果: 索引 {result}")
    print(f"性能指标: {linear_search.metrics}")
    print(f"复杂度分析: {linear_search.get_complexity_analysis()}\n")
    
    # 2. 二分搜索
    print("2. 二分搜索算法")
    binary_search = BinarySearchAlgorithm()
    result = binary_search.execute((sorted_array, target_value))
    print(f"在有序数组 {sorted_array} 中查找 {target_value}")
    print(f"结果: 索引 {result}")
    print(f"性能指标: {binary_search.metrics}")
    print(f"复杂度分析: {binary_search.get_complexity_analysis()}\n")
    
    # 3. 冒泡排序
    print("3. 冒泡排序算法")
    bubble_sort = BubbleSortAlgorithm()
    result = bubble_sort.execute(test_array.copy())
    print(f"原始数组: {test_array}")
    print(f"排序结果: {result}")
    print(f"性能指标: {bubble_sort.metrics}")
    print(f"复杂度分析: {bubble_sort.get_complexity_analysis()}\n")
    
    # 4. 快速排序
    print("4. 快速排序算法")
    quick_sort = QuickSortAlgorithm()
    result = quick_sort.execute(test_array.copy())
    print(f"原始数组: {test_array}")
    print(f"排序结果: {result}")
    print(f"性能指标: {quick_sort.metrics}")
    print(f"复杂度分析: {quick_sort.get_complexity_analysis()}\n")

if __name__ == "__main__":
    demonstrate_algorithms()
```

## 📊 算法分类

### 2.1 按问题类型分类

#### 2.1.1 搜索算法

**定义 2.1** (搜索问题)
搜索问题是寻找满足特定条件的元素的问题：
$$Search(A, P) = \{x \in A \mid P(x) = True\}$$

其中：

- $A$ 为搜索空间
- $P$ 为谓词函数

**定理 2.1** (线性搜索复杂度)
线性搜索的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

**证明**:

1. 最坏情况下需要检查所有 $n$ 个元素
2. 每次检查需要常数时间
3. 因此总时间复杂度为 $O(n)$
4. 只使用常数额外空间，因此空间复杂度为 $O(1)$

#### 2.1.2 排序算法

**定义 2.2** (排序问题)
排序问题是重新排列元素使其满足特定顺序的问题：
$$Sort(A, \leq) = [a_1, a_2, ..., a_n]$$

其中 $\forall i < j, a_i \leq a_j$

**定理 2.2** (比较排序下界)
任何基于比较的排序算法的最坏情况时间复杂度为 $\Omega(n \log n)$。

**证明**:

1. $n$ 个元素有 $n!$ 种可能的排列
2. 每次比较最多将可能排列数减半
3. 需要至少 $\log_2(n!)$ 次比较
4. 根据斯特林公式：$\log_2(n!) = \Theta(n \log n)$

### 2.2 按设计策略分类

#### 2.2.1 分治算法

**定义 2.3** (分治算法)
分治算法将问题分解为子问题，递归解决，然后合并结果：
$$DivideAndConquer(P) = Combine(Solve(Divide(P)))$$

**定理 2.3** (分治算法复杂度)
如果分治算法满足：

- 分解时间：$D(n) = O(n^d)$
- 子问题数量：$a$
- 子问题规模：$n/b$
- 合并时间：$C(n) = O(n^c)$

则时间复杂度为：
$$T(n) = \begin{cases}
O(n^{\max(c, d)}) & \text{if } \log_b a < \max(c, d) \\
O(n^{\max(c, d)} \log n) & \text{if } \log_b a = \max(c, d) \\
O(n^{\log_b a}) & \text{if } \log_b a > \max(c, d)
\end{cases}$$

#### 2.2.2 动态规划

**定义 2.4** (动态规划)
动态规划通过存储子问题的解来避免重复计算：
$$DP[i] = f(DP[j] \mid j < i)$$

**定理 2.4** (动态规划优化原理)
如果问题具有最优子结构性质，则可以使用动态规划求解。

## 🔍 算法分析

### 3.1 时间复杂度分析

#### 3.1.1 渐进分析

**定义 3.1** (大O记号)
函数 $f(n) = O(g(n))$ 当且仅当：
$$\exists c > 0, n_0 > 0, \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**定义 3.2** (大Ω记号)
函数 $f(n) = \Omega(g(n))$ 当且仅当：
$$\exists c > 0, n_0 > 0, \forall n \geq n_0, f(n) \geq c \cdot g(n)$$

**定义 3.3** (大Θ记号)
函数 $f(n) = \Theta(g(n))$ 当且仅当：
$$f(n) = O(g(n)) \land f(n) = \Omega(g(n))$$

#### 3.1.2 常见复杂度类

| 复杂度 | 名称 | 示例算法 |
|--------|------|----------|
| $O(1)$ | 常数时间 | 数组访问 |
| $O(\log n)$ | 对数时间 | 二分搜索 |
| $O(n)$ | 线性时间 | 线性搜索 |
| $O(n \log n)$ | 线性对数时间 | 快速排序 |
| $O(n^2)$ | 平方时间 | 冒泡排序 |
| $O(2^n)$ | 指数时间 | 穷举搜索 |

### 3.2 空间复杂度分析

#### 3.2.1 空间复杂度定义

**定义 3.4** (空间复杂度)
算法的空间复杂度是算法执行过程中使用的额外空间量：
$$Space(A, n) = \max_{|input| = n} Memory(A, input)$$

#### 3.2.2 空间复杂度分类

- **原地算法**: $O(1)$ 额外空间
- **线性空间**: $O(n)$ 额外空间
- **多项式空间**: $O(n^k)$ 额外空间

## 🎯 算法设计原则

### 4.1 正确性

**原则 1**: 算法必须产生正确的输出
**验证方法**: 形式化证明、测试用例、不变式

### 4.2 效率

**原则 2**: 算法应该在合理时间内完成
**评估方法**: 时间复杂度分析、实际性能测试

### 4.3 简洁性

**原则 3**: 算法应该易于理解和实现
**实现方法**: 清晰的代码结构、充分的注释

### 4.4 鲁棒性

**原则 4**: 算法应该处理各种输入情况
**处理方法**: 边界条件检查、异常处理

## 📈 算法优化技术

### 5.1 算法优化策略

#### 5.1.1 减少计算量

- **缓存**: 存储中间结果
- **剪枝**: 提前终止不必要的计算
- **近似**: 使用近似算法

#### 5.1.2 改进数据结构

- **索引**: 建立快速查找索引
- **压缩**: 减少存储空间
- **分块**: 将大问题分解为小问题

### 5.2 并行化优化

#### 5.2.1 并行算法设计

**定义 5.1** (并行算法)
并行算法是可以在多个处理器上同时执行的算法：
$$Parallel(A) = \cup_{i=1}^{p} A_i$$

其中 $p$ 为处理器数量。

## 🔗 相关链接

- [02-01-02 算法分析](./02-01-02-算法分析.md)
- [02-01-03 算法设计](./02-01-03-算法设计.md)
- [02-02-01 线性结构](../02-02-数据结构/02-02-01-线性结构.md)
- [06-02-01 排序算法](../../06-组件算法/06-02-算法实现/06-02-01-排序算法.md)

---

*本文档建立了算法的基础理论框架，从形式化定义到实际实现，为后续的算法分析和设计奠定了坚实的基础。*
