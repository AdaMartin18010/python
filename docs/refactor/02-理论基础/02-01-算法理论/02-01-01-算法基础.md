# 02-01-01 ç®—æ³•åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

ç®—æ³•æ˜¯è®¡ç®—ç§‘å­¦çš„æ ¸å¿ƒæ¦‚å¿µï¼Œæ˜¯è§£å†³ç‰¹å®šé—®é¢˜çš„æœ‰é™æ­¥éª¤åºåˆ—ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰ç®—æ³•ï¼Œå»ºç«‹ç®—æ³•åˆ†æçš„ç†è®ºåŸºç¡€ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1** (ç®—æ³•)
ç®—æ³•æ˜¯ä¸€ä¸ªå…­å…ƒç»„ï¼š
$$A = (I, O, S, T, F, C)$$

å…¶ä¸­ï¼š

- $I$ ä¸ºè¾“å…¥é›†åˆ
- $O$ ä¸ºè¾“å‡ºé›†åˆ  
- $S$ ä¸ºçŠ¶æ€é›†åˆ
- $T$ ä¸ºè½¬æ¢å‡½æ•°ï¼š$T: S \times I \rightarrow S \times O$
- $F$ ä¸ºç»ˆæ­¢æ¡ä»¶ï¼š$F: S \rightarrow \{True, False\}$
- $C$ ä¸ºè®¡ç®—èµ„æºçº¦æŸ

**å®šä¹‰ 1.2** (ç®—æ³•çš„æ­£ç¡®æ€§)
ç®—æ³• $A$ å¯¹äºé—®é¢˜ $P$ æ˜¯æ­£ç¡®çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x \in I_P, A(x) = P(x)$$

**å®šä¹‰ 1.3** (ç®—æ³•çš„ç»ˆæ­¢æ€§)
ç®—æ³• $A$ æ˜¯ç»ˆæ­¢çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x \in I, \exists n \in \mathbb{N}, F(T^n(x)) = True$$

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Any, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import time
import psutil
import os

Input = TypeVar('Input')
Output = TypeVar('Output')
State = TypeVar('State')

class AlgorithmStatus(Enum):
    """ç®—æ³•çŠ¶æ€"""
    NOT_STARTED = "not_started"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"

@dataclass
class AlgorithmMetrics:
    """ç®—æ³•æ€§èƒ½æŒ‡æ ‡"""
    execution_time: float = 0.0
    memory_usage: float = 0.0
    cpu_usage: float = 0.0
    steps_count: int = 0
    input_size: int = 0
    output_size: int = 0

class Algorithm(ABC, Generic[Input, Output, State]):
    """ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, description: str = ""):
        self.name = name
        self.description = description
        self.status = AlgorithmStatus.NOT_STARTED
        self.metrics = AlgorithmMetrics()
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None
    
    @abstractmethod
    def initialize_state(self, input_data: Input) -> State:
        """åˆå§‹åŒ–çŠ¶æ€"""
        pass
    
    @abstractmethod
    def transition(self, state: State, input_data: Input) -> tuple[State, Optional[Output]]:
        """çŠ¶æ€è½¬æ¢å‡½æ•°"""
        pass
    
    @abstractmethod
    def is_terminated(self, state: State) -> bool:
        """ç»ˆæ­¢æ¡ä»¶æ£€æŸ¥"""
        pass
    
    @abstractmethod
    def extract_output(self, state: State) -> Output:
        """æå–è¾“å‡º"""
        pass
    
    def execute(self, input_data: Input, timeout: Optional[float] = None) -> Output:
        """æ‰§è¡Œç®—æ³•"""
        self.status = AlgorithmStatus.RUNNING
        self.start_time = time.time()
        self.metrics.input_size = self._measure_input_size(input_data)
        
        # è®°å½•åˆå§‹èµ„æºä½¿ç”¨
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        initial_cpu = process.cpu_percent()
        
        try:
            # åˆå§‹åŒ–çŠ¶æ€
            state = self.initialize_state(input_data)
            
            # ä¸»å¾ªç¯
            while not self.is_terminated(state):
                # æ£€æŸ¥è¶…æ—¶
                if timeout and (time.time() - self.start_time) > timeout:
                    self.status = AlgorithmStatus.TIMEOUT
                    raise TimeoutError(f"Algorithm {self.name} timed out after {timeout} seconds")
                
                # æ‰§è¡Œè½¬æ¢
                state, output = self.transition(state, input_data)
                self.metrics.steps_count += 1
                
                # å¦‚æœè½¬æ¢äº§ç”Ÿè¾“å‡ºï¼Œè¿”å›
                if output is not None:
                    result = output
                    break
            else:
                # ä»æœ€ç»ˆçŠ¶æ€æå–è¾“å‡º
                result = self.extract_output(state)
            
            # è®°å½•æœ€ç»ˆæŒ‡æ ‡
            self.end_time = time.time()
            self.metrics.execution_time = self.end_time - self.start_time
            self.metrics.memory_usage = (process.memory_info().rss / 1024 / 1024) - initial_memory
            self.metrics.cpu_usage = process.cpu_percent() - initial_cpu
            self.metrics.output_size = self._measure_output_size(result)
            
            self.status = AlgorithmStatus.COMPLETED
            return result
            
        except Exception as e:
            self.status = AlgorithmStatus.FAILED
            raise e
    
    def _measure_input_size(self, input_data: Input) -> int:
        """æµ‹é‡è¾“å…¥å¤§å°"""
        if hasattr(input_data, '__len__'):
            return len(input_data)
        elif hasattr(input_data, '__sizeof__'):
            return input_data.__sizeof__()
        else:
            return 1
    
    def _measure_output_size(self, output_data: Output) -> int:
        """æµ‹é‡è¾“å‡ºå¤§å°"""
        if hasattr(output_data, '__len__'):
            return len(output_data)
        elif hasattr(output_data, '__sizeof__'):
            return output_data.__sizeof__()
        else:
            return 1
    
    def get_complexity_analysis(self) -> dict[str, Any]:
        """è·å–å¤æ‚åº¦åˆ†æ"""
        return {
            "time_complexity": self._analyze_time_complexity(),
            "space_complexity": self._analyze_space_complexity(),
            "empirical_metrics": self.metrics
        }
    
    @abstractmethod
    def _analyze_time_complexity(self) -> str:
        """åˆ†ææ—¶é—´å¤æ‚åº¦"""
        pass
    
    @abstractmethod
    def _analyze_space_complexity(self) -> str:
        """åˆ†æç©ºé—´å¤æ‚åº¦"""
        pass

class LinearSearchAlgorithm(Algorithm[list[int], Optional[int], int]):
    """çº¿æ€§æœç´¢ç®—æ³•å®ç°"""
    
    def __init__(self):
        super().__init__("Linear Search", "åœ¨æ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼çš„çº¿æ€§æœç´¢ç®—æ³•")
    
    def initialize_state(self, input_data: tuple[list[int], int]) -> int:
        """åˆå§‹åŒ–çŠ¶æ€ä¸ºç´¢å¼•0"""
        return 0
    
    def transition(self, state: int, input_data: tuple[list[int], int]) -> tuple[int, Optional[int]]:
        """çŠ¶æ€è½¬æ¢ï¼šæ£€æŸ¥å½“å‰å…ƒç´ ï¼Œå¦‚æœåŒ¹é…åˆ™è¿”å›ï¼Œå¦åˆ™ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª"""
        array, target = input_data
        
        if state >= len(array):
            return state, None  # æœªæ‰¾åˆ°
        
        if array[state] == target:
            return state, state  # æ‰¾åˆ°ç›®æ ‡
        
        return state + 1, None  # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªä½ç½®
    
    def is_terminated(self, state: int) -> bool:
        """ç»ˆæ­¢æ¡ä»¶ï¼šå·²æ£€æŸ¥å®Œæ‰€æœ‰å…ƒç´ """
        return False  # åœ¨transitionä¸­å¤„ç†ç»ˆæ­¢
    
    def extract_output(self, state: int) -> Optional[int]:
        """æå–è¾“å‡ºï¼šè¿”å›æ‰¾åˆ°çš„ç´¢å¼•æˆ–None"""
        return None
    
    def _analyze_time_complexity(self) -> str:
        return "O(n) - æœ€åæƒ…å†µä¸‹éœ€è¦æ£€æŸ¥æ‰€æœ‰nä¸ªå…ƒç´ "
    
    def _analyze_space_complexity(self) -> str:
        return "O(1) - åªä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´"

class BinarySearchAlgorithm(Algorithm[list[int], Optional[int], tuple[int, int]]):
    """äºŒåˆ†æœç´¢ç®—æ³•å®ç°"""
    
    def __init__(self):
        super().__init__("Binary Search", "åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼çš„äºŒåˆ†æœç´¢ç®—æ³•")
    
    def initialize_state(self, input_data: tuple[list[int], int]) -> tuple[int, int]:
        """åˆå§‹åŒ–çŠ¶æ€ä¸ºæœç´¢èŒƒå›´ [0, len(array)-1]"""
        array, _ = input_data
        return (0, len(array) - 1)
    
    def transition(self, state: tuple[int, int], input_data: tuple[list[int], int]) -> tuple[tuple[int, int], Optional[int]]:
        """çŠ¶æ€è½¬æ¢ï¼šè®¡ç®—ä¸­ç‚¹ï¼Œæ¯”è¾ƒç›®æ ‡å€¼ï¼Œç¼©å°æœç´¢èŒƒå›´"""
        array, target = input_data
        left, right = state
        
        if left > right:
            return state, None  # æœªæ‰¾åˆ°
        
        mid = (left + right) // 2
        
        if array[mid] == target:
            return state, mid  # æ‰¾åˆ°ç›®æ ‡
        elif array[mid] < target:
            return (mid + 1, right), None  # æœç´¢å³åŠéƒ¨åˆ†
        else:
            return (left, mid - 1), None  # æœç´¢å·¦åŠéƒ¨åˆ†
    
    def is_terminated(self, state: tuple[int, int]) -> bool:
        """ç»ˆæ­¢æ¡ä»¶ï¼šæœç´¢èŒƒå›´ä¸ºç©º"""
        left, right = state
        return left > right
    
    def extract_output(self, state: tuple[int, int]) -> Optional[int]:
        """æå–è¾“å‡ºï¼šè¿”å›æ‰¾åˆ°çš„ç´¢å¼•æˆ–None"""
        return None
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n) - æ¯æ¬¡è¿­ä»£å°†æœç´¢èŒƒå›´å‡åŠ"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1) - åªä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´"

class BubbleSortAlgorithm(Algorithm[list[int], list[int], tuple[list[int], int, int]]):
    """å†’æ³¡æ’åºç®—æ³•å®ç°"""
    
    def __init__(self):
        super().__init__("Bubble Sort", "é€šè¿‡ç›¸é‚»å…ƒç´ æ¯”è¾ƒå’Œäº¤æ¢è¿›è¡Œæ’åºçš„ç®—æ³•")
    
    def initialize_state(self, input_data: list[int]) -> tuple[list[int], int, int]:
        """åˆå§‹åŒ–çŠ¶æ€ï¼šæ•°ç»„å‰¯æœ¬ï¼Œå¤–å±‚å¾ªç¯ç´¢å¼•ï¼Œå†…å±‚å¾ªç¯ç´¢å¼•"""
        return (input_data.copy(), 0, 0)
    
    def transition(self, state: tuple[list[int], int, int], input_data: list[int]) -> tuple[tuple[list[int], int, int], Optional[list[int]]]:
        """çŠ¶æ€è½¬æ¢ï¼šæ‰§è¡Œä¸€æ¬¡æ¯”è¾ƒå’Œå¯èƒ½çš„äº¤æ¢"""
        array, i, j = state
        n = len(array)
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦äº¤æ¢
        if j < n - i - 1:
            if array[j] > array[j + 1]:
                array[j], array[j + 1] = array[j + 1], array[j]
            return (array, i, j + 1), None
        else:
            # å®Œæˆä¸€è½®ï¼Œå¼€å§‹ä¸‹ä¸€è½®
            if i < n - 1:
                return (array, i + 1, 0), None
            else:
                # æ’åºå®Œæˆ
                return state, array
    
    def is_terminated(self, state: tuple[list[int], int, int]) -> bool:
        """ç»ˆæ­¢æ¡ä»¶ï¼šæ‰€æœ‰è½®æ¬¡å®Œæˆ"""
        array, i, j = state
        return i >= len(array) - 1
    
    def extract_output(self, state: tuple[list[int], int, int]) -> list[int]:
        """æå–è¾“å‡ºï¼šè¿”å›æ’åºåçš„æ•°ç»„"""
        array, _, _ = state
        return array
    
    def _analyze_time_complexity(self) -> str:
        return "O(nÂ²) - ä¸¤å±‚åµŒå¥—å¾ªç¯ï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦nÂ²æ¬¡æ¯”è¾ƒ"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1) - åŸåœ°æ’åºï¼Œåªä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´"

class QuickSortAlgorithm(Algorithm[list[int], list[int], tuple[list[int], int, int, Optional[int]]]):
    """å¿«é€Ÿæ’åºç®—æ³•å®ç°"""
    
    def __init__(self):
        super().__init__("Quick Sort", "ä½¿ç”¨åˆ†æ²»ç­–ç•¥çš„é«˜æ•ˆæ’åºç®—æ³•")
        self.stack: list[tuple[int, int]] = []
    
    def initialize_state(self, input_data: list[int]) -> tuple[list[int], int, int, Optional[int]]:
        """åˆå§‹åŒ–çŠ¶æ€ï¼šæ•°ç»„å‰¯æœ¬ï¼Œå·¦è¾¹ç•Œï¼Œå³è¾¹ç•Œï¼Œåˆ†åŒºç‚¹"""
        self.stack = [(0, len(input_data) - 1)]
        return (input_data.copy(), 0, len(input_data) - 1, None)
    
    def transition(self, state: tuple[list[int], int, int, Optional[int]], input_data: list[int]) -> tuple[tuple[list[int], int, int, Optional[int]], Optional[list[int]]]:
        """çŠ¶æ€è½¬æ¢ï¼šæ‰§è¡Œåˆ†åŒºæˆ–é€’å½’è°ƒç”¨"""
        array, left, right, pivot = state
        
        if pivot is None:
            # éœ€è¦åˆ†åŒº
            if left < right:
                pivot = self._partition(array, left, right)
                # å°†å­é—®é¢˜åŠ å…¥æ ˆ
                if left < pivot - 1:
                    self.stack.append((left, pivot - 1))
                if pivot + 1 < right:
                    self.stack.append((pivot + 1, right))
                return (array, left, right, pivot), None
            else:
                # å•ä¸ªå…ƒç´ æˆ–ç©ºåŒºé—´ï¼Œä»æ ˆä¸­å–ä¸‹ä¸€ä¸ªå­é—®é¢˜
                if self.stack:
                    next_left, next_right = self.stack.pop()
                    return (array, next_left, next_right, None), None
                else:
                    # æ‰€æœ‰å­é—®é¢˜å®Œæˆ
                    return state, array
        else:
            # åˆ†åŒºå®Œæˆï¼Œä»æ ˆä¸­å–ä¸‹ä¸€ä¸ªå­é—®é¢˜
            if self.stack:
                next_left, next_right = self.stack.pop()
                return (array, next_left, next_right, None), None
            else:
                # æ‰€æœ‰å­é—®é¢˜å®Œæˆ
                return state, array
    
    def _partition(self, array: list[int], left: int, right: int) -> int:
        """åˆ†åŒºå‡½æ•°ï¼šé€‰æ‹©æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†ï¼Œå°†å°äºåŸºå‡†çš„å…ƒç´ ç§»åˆ°å·¦è¾¹"""
        pivot = array[right]
        i = left - 1
        
        for j in range(left, right):
            if array[j] <= pivot:
                i += 1
                array[i], array[j] = array[j], array[i]
        
        array[i + 1], array[right] = array[right], array[i + 1]
        return i + 1
    
    def is_terminated(self, state: tuple[list[int], int, int, Optional[int]]) -> bool:
        """ç»ˆæ­¢æ¡ä»¶ï¼šæ‰€æœ‰å­é—®é¢˜å®Œæˆ"""
        return len(self.stack) == 0 and state[3] is not None
    
    def extract_output(self, state: tuple[list[int], int, int, Optional[int]]) -> list[int]:
        """æå–è¾“å‡ºï¼šè¿”å›æ’åºåçš„æ•°ç»„"""
        array, _, _, _ = state
        return array
    
    def _analyze_time_complexity(self) -> str:
        return "O(n log n) - å¹³å‡æƒ…å†µï¼Œæœ€åæƒ…å†µO(nÂ²)"
    
    def _analyze_space_complexity(self) -> str:
        return "O(log n) - é€’å½’è°ƒç”¨æ ˆæ·±åº¦"

# ç®—æ³•æµ‹è¯•å’Œæ¼”ç¤º
def demonstrate_algorithms():
    """æ¼”ç¤ºå„ç§ç®—æ³•çš„ä½¿ç”¨"""
    
    # æµ‹è¯•æ•°æ®
    test_array = [64, 34, 25, 12, 22, 11, 90]
    sorted_array = sorted(test_array)
    target_value = 22
    
    print("=== ç®—æ³•æ¼”ç¤º ===\n")
    
    # 1. çº¿æ€§æœç´¢
    print("1. çº¿æ€§æœç´¢ç®—æ³•")
    linear_search = LinearSearchAlgorithm()
    result = linear_search.execute((test_array, target_value))
    print(f"åœ¨æ•°ç»„ {test_array} ä¸­æŸ¥æ‰¾ {target_value}")
    print(f"ç»“æœ: ç´¢å¼• {result}")
    print(f"æ€§èƒ½æŒ‡æ ‡: {linear_search.metrics}")
    print(f"å¤æ‚åº¦åˆ†æ: {linear_search.get_complexity_analysis()}\n")
    
    # 2. äºŒåˆ†æœç´¢
    print("2. äºŒåˆ†æœç´¢ç®—æ³•")
    binary_search = BinarySearchAlgorithm()
    result = binary_search.execute((sorted_array, target_value))
    print(f"åœ¨æœ‰åºæ•°ç»„ {sorted_array} ä¸­æŸ¥æ‰¾ {target_value}")
    print(f"ç»“æœ: ç´¢å¼• {result}")
    print(f"æ€§èƒ½æŒ‡æ ‡: {binary_search.metrics}")
    print(f"å¤æ‚åº¦åˆ†æ: {binary_search.get_complexity_analysis()}\n")
    
    # 3. å†’æ³¡æ’åº
    print("3. å†’æ³¡æ’åºç®—æ³•")
    bubble_sort = BubbleSortAlgorithm()
    result = bubble_sort.execute(test_array.copy())
    print(f"åŸå§‹æ•°ç»„: {test_array}")
    print(f"æ’åºç»“æœ: {result}")
    print(f"æ€§èƒ½æŒ‡æ ‡: {bubble_sort.metrics}")
    print(f"å¤æ‚åº¦åˆ†æ: {bubble_sort.get_complexity_analysis()}\n")
    
    # 4. å¿«é€Ÿæ’åº
    print("4. å¿«é€Ÿæ’åºç®—æ³•")
    quick_sort = QuickSortAlgorithm()
    result = quick_sort.execute(test_array.copy())
    print(f"åŸå§‹æ•°ç»„: {test_array}")
    print(f"æ’åºç»“æœ: {result}")
    print(f"æ€§èƒ½æŒ‡æ ‡: {quick_sort.metrics}")
    print(f"å¤æ‚åº¦åˆ†æ: {quick_sort.get_complexity_analysis()}\n")

if __name__ == "__main__":
    demonstrate_algorithms()
```

## ğŸ“Š ç®—æ³•åˆ†ç±»

### 2.1 æŒ‰é—®é¢˜ç±»å‹åˆ†ç±»

#### 2.1.1 æœç´¢ç®—æ³•

**å®šä¹‰ 2.1** (æœç´¢é—®é¢˜)
æœç´¢é—®é¢˜æ˜¯å¯»æ‰¾æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„å…ƒç´ çš„é—®é¢˜ï¼š
$$Search(A, P) = \{x \in A \mid P(x) = True\}$$

å…¶ä¸­ï¼š

- $A$ ä¸ºæœç´¢ç©ºé—´
- $P$ ä¸ºè°“è¯å‡½æ•°

**å®šç† 2.1** (çº¿æ€§æœç´¢å¤æ‚åº¦)
çº¿æ€§æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ã€‚

**è¯æ˜**:

1. æœ€åæƒ…å†µä¸‹éœ€è¦æ£€æŸ¥æ‰€æœ‰ $n$ ä¸ªå…ƒç´ 
2. æ¯æ¬¡æ£€æŸ¥éœ€è¦å¸¸æ•°æ—¶é—´
3. å› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$
4. åªä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(1)$

#### 2.1.2 æ’åºç®—æ³•

**å®šä¹‰ 2.2** (æ’åºé—®é¢˜)
æ’åºé—®é¢˜æ˜¯é‡æ–°æ’åˆ—å…ƒç´ ä½¿å…¶æ»¡è¶³ç‰¹å®šé¡ºåºçš„é—®é¢˜ï¼š
$$Sort(A, \leq) = [a_1, a_2, ..., a_n]$$

å…¶ä¸­ $\forall i < j, a_i \leq a_j$

**å®šç† 2.2** (æ¯”è¾ƒæ’åºä¸‹ç•Œ)
ä»»ä½•åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•çš„æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ä¸º $\Omega(n \log n)$ã€‚

**è¯æ˜**:

1. $n$ ä¸ªå…ƒç´ æœ‰ $n!$ ç§å¯èƒ½çš„æ’åˆ—
2. æ¯æ¬¡æ¯”è¾ƒæœ€å¤šå°†å¯èƒ½æ’åˆ—æ•°å‡åŠ
3. éœ€è¦è‡³å°‘ $\log_2(n!)$ æ¬¡æ¯”è¾ƒ
4. æ ¹æ®æ–¯ç‰¹æ—å…¬å¼ï¼š$\log_2(n!) = \Theta(n \log n)$

### 2.2 æŒ‰è®¾è®¡ç­–ç•¥åˆ†ç±»

#### 2.2.1 åˆ†æ²»ç®—æ³•

**å®šä¹‰ 2.3** (åˆ†æ²»ç®—æ³•)
åˆ†æ²»ç®—æ³•å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œé€’å½’è§£å†³ï¼Œç„¶ååˆå¹¶ç»“æœï¼š
$$DivideAndConquer(P) = Combine(Solve(Divide(P)))$$

**å®šç† 2.3** (åˆ†æ²»ç®—æ³•å¤æ‚åº¦)
å¦‚æœåˆ†æ²»ç®—æ³•æ»¡è¶³ï¼š

- åˆ†è§£æ—¶é—´ï¼š$D(n) = O(n^d)$
- å­é—®é¢˜æ•°é‡ï¼š$a$
- å­é—®é¢˜è§„æ¨¡ï¼š$n/b$
- åˆå¹¶æ—¶é—´ï¼š$C(n) = O(n^c)$

åˆ™æ—¶é—´å¤æ‚åº¦ä¸ºï¼š
$$T(n) = \begin{cases}
O(n^{\max(c, d)}) & \text{if } \log_b a < \max(c, d) \\
O(n^{\max(c, d)} \log n) & \text{if } \log_b a = \max(c, d) \\
O(n^{\log_b a}) & \text{if } \log_b a > \max(c, d)
\end{cases}$$

#### 2.2.2 åŠ¨æ€è§„åˆ’

**å®šä¹‰ 2.4** (åŠ¨æ€è§„åˆ’)
åŠ¨æ€è§„åˆ’é€šè¿‡å­˜å‚¨å­é—®é¢˜çš„è§£æ¥é¿å…é‡å¤è®¡ç®—ï¼š
$$DP[i] = f(DP[j] \mid j < i)$$

**å®šç† 2.4** (åŠ¨æ€è§„åˆ’ä¼˜åŒ–åŸç†)
å¦‚æœé—®é¢˜å…·æœ‰æœ€ä¼˜å­ç»“æ„æ€§è´¨ï¼Œåˆ™å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ã€‚

## ğŸ” ç®—æ³•åˆ†æ

### 3.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

#### 3.1.1 æ¸è¿›åˆ†æ

**å®šä¹‰ 3.1** (å¤§Oè®°å·)
å‡½æ•° $f(n) = O(g(n))$ å½“ä¸”ä»…å½“ï¼š
$$\exists c > 0, n_0 > 0, \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**å®šä¹‰ 3.2** (å¤§Î©è®°å·)
å‡½æ•° $f(n) = \Omega(g(n))$ å½“ä¸”ä»…å½“ï¼š
$$\exists c > 0, n_0 > 0, \forall n \geq n_0, f(n) \geq c \cdot g(n)$$

**å®šä¹‰ 3.3** (å¤§Î˜è®°å·)
å‡½æ•° $f(n) = \Theta(g(n))$ å½“ä¸”ä»…å½“ï¼š
$$f(n) = O(g(n)) \land f(n) = \Omega(g(n))$$

#### 3.1.2 å¸¸è§å¤æ‚åº¦ç±»

| å¤æ‚åº¦ | åç§° | ç¤ºä¾‹ç®—æ³• |
|--------|------|----------|
| $O(1)$ | å¸¸æ•°æ—¶é—´ | æ•°ç»„è®¿é—® |
| $O(\log n)$ | å¯¹æ•°æ—¶é—´ | äºŒåˆ†æœç´¢ |
| $O(n)$ | çº¿æ€§æ—¶é—´ | çº¿æ€§æœç´¢ |
| $O(n \log n)$ | çº¿æ€§å¯¹æ•°æ—¶é—´ | å¿«é€Ÿæ’åº |
| $O(n^2)$ | å¹³æ–¹æ—¶é—´ | å†’æ³¡æ’åº |
| $O(2^n)$ | æŒ‡æ•°æ—¶é—´ | ç©·ä¸¾æœç´¢ |

### 3.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

#### 3.2.1 ç©ºé—´å¤æ‚åº¦å®šä¹‰

**å®šä¹‰ 3.4** (ç©ºé—´å¤æ‚åº¦)
ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦æ˜¯ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­ä½¿ç”¨çš„é¢å¤–ç©ºé—´é‡ï¼š
$$Space(A, n) = \max_{|input| = n} Memory(A, input)$$

#### 3.2.2 ç©ºé—´å¤æ‚åº¦åˆ†ç±»

- **åŸåœ°ç®—æ³•**: $O(1)$ é¢å¤–ç©ºé—´
- **çº¿æ€§ç©ºé—´**: $O(n)$ é¢å¤–ç©ºé—´
- **å¤šé¡¹å¼ç©ºé—´**: $O(n^k)$ é¢å¤–ç©ºé—´

## ğŸ¯ ç®—æ³•è®¾è®¡åŸåˆ™

### 4.1 æ­£ç¡®æ€§

**åŸåˆ™ 1**: ç®—æ³•å¿…é¡»äº§ç”Ÿæ­£ç¡®çš„è¾“å‡º
**éªŒè¯æ–¹æ³•**: å½¢å¼åŒ–è¯æ˜ã€æµ‹è¯•ç”¨ä¾‹ã€ä¸å˜å¼

### 4.2 æ•ˆç‡

**åŸåˆ™ 2**: ç®—æ³•åº”è¯¥åœ¨åˆç†æ—¶é—´å†…å®Œæˆ
**è¯„ä¼°æ–¹æ³•**: æ—¶é—´å¤æ‚åº¦åˆ†æã€å®é™…æ€§èƒ½æµ‹è¯•

### 4.3 ç®€æ´æ€§

**åŸåˆ™ 3**: ç®—æ³•åº”è¯¥æ˜“äºç†è§£å’Œå®ç°
**å®ç°æ–¹æ³•**: æ¸…æ™°çš„ä»£ç ç»“æ„ã€å……åˆ†çš„æ³¨é‡Š

### 4.4 é²æ£’æ€§

**åŸåˆ™ 4**: ç®—æ³•åº”è¯¥å¤„ç†å„ç§è¾“å…¥æƒ…å†µ
**å¤„ç†æ–¹æ³•**: è¾¹ç•Œæ¡ä»¶æ£€æŸ¥ã€å¼‚å¸¸å¤„ç†

## ğŸ“ˆ ç®—æ³•ä¼˜åŒ–æŠ€æœ¯

### 5.1 ç®—æ³•ä¼˜åŒ–ç­–ç•¥

#### 5.1.1 å‡å°‘è®¡ç®—é‡

- **ç¼“å­˜**: å­˜å‚¨ä¸­é—´ç»“æœ
- **å‰ªæ**: æå‰ç»ˆæ­¢ä¸å¿…è¦çš„è®¡ç®—
- **è¿‘ä¼¼**: ä½¿ç”¨è¿‘ä¼¼ç®—æ³•

#### 5.1.2 æ”¹è¿›æ•°æ®ç»“æ„

- **ç´¢å¼•**: å»ºç«‹å¿«é€ŸæŸ¥æ‰¾ç´¢å¼•
- **å‹ç¼©**: å‡å°‘å­˜å‚¨ç©ºé—´
- **åˆ†å—**: å°†å¤§é—®é¢˜åˆ†è§£ä¸ºå°é—®é¢˜

### 5.2 å¹¶è¡ŒåŒ–ä¼˜åŒ–

#### 5.2.1 å¹¶è¡Œç®—æ³•è®¾è®¡

**å®šä¹‰ 5.1** (å¹¶è¡Œç®—æ³•)
å¹¶è¡Œç®—æ³•æ˜¯å¯ä»¥åœ¨å¤šä¸ªå¤„ç†å™¨ä¸ŠåŒæ—¶æ‰§è¡Œçš„ç®—æ³•ï¼š
$$Parallel(A) = \cup_{i=1}^{p} A_i$$

å…¶ä¸­ $p$ ä¸ºå¤„ç†å™¨æ•°é‡ã€‚

## ğŸ”— ç›¸å…³é“¾æ¥

- [02-01-02 ç®—æ³•åˆ†æ](./02-01-02-ç®—æ³•åˆ†æ.md)
- [02-01-03 ç®—æ³•è®¾è®¡](./02-01-03-ç®—æ³•è®¾è®¡.md)
- [02-02-01 çº¿æ€§ç»“æ„](../02-02-æ•°æ®ç»“æ„/02-02-01-çº¿æ€§ç»“æ„.md)
- [06-02-01 æ’åºç®—æ³•](../../06-ç»„ä»¶ç®—æ³•/06-02-ç®—æ³•å®ç°/06-02-01-æ’åºç®—æ³•.md)

---

*æœ¬æ–‡æ¡£å»ºç«‹äº†ç®—æ³•çš„åŸºç¡€ç†è®ºæ¡†æ¶ï¼Œä»å½¢å¼åŒ–å®šä¹‰åˆ°å®é™…å®ç°ï¼Œä¸ºåç»­çš„ç®—æ³•åˆ†æå’Œè®¾è®¡å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚*
