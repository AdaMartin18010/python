# 02-01-01 算法基础

## 📋 概述

算法是解决特定问题的有限步骤序列。本文档从形式化角度定义算法，建立算法分析的理论基础，并提供完整的Python实现。

## 1. 形式化定义

### 1.1 算法定义

**定义 1.1** (算法)
算法是一个六元组：
$$A = (I, O, S, \delta, \sigma, \tau)$$
其中：

- $I$ 为输入集合
- $O$ 为输出集合  
- $S$ 为状态集合
- $\delta: S \times I \rightarrow S$ 为状态转移函数
- $\sigma: S \rightarrow O$ 为输出函数
- $\tau: S \rightarrow \{true, false\}$ 为终止条件函数

**定义 1.2** (算法正确性)
算法 $A$ 对于问题 $P$ 是正确的，当且仅当：
$$\forall x \in I: \sigma(\delta^*(s_0, x)) \in P(x)$$

其中 $\delta^*$ 为状态转移函数的闭包，$s_0$ 为初始状态，$P(x)$ 为问题 $P$ 在输入 $x$ 下的解集。

**定义 1.3** (算法终止性)
算法 $A$ 是终止的，当且仅当：
$$\forall x \in I: \exists n \in \mathbb{N}: \tau(\delta^n(s_0, x)) = true$$

### 1.2 复杂度定义

**定义 1.4** (时间复杂度)
算法 $A$ 的时间复杂度为：
$$T_A(n) = \max\{steps(A, x) \mid |x| = n\}$$

**定义 1.5** (空间复杂度)
算法 $A$ 的空间复杂度为：
$$S_A(n) = \max\{space(A, x) \mid |x| = n\}$$

**定义 1.6** (渐近复杂度)
对于函数 $f(n)$ 和 $g(n)$：
- $f(n) = O(g(n))$ 当且仅当 $\exists c, n_0: \forall n \geq n_0: f(n) \leq c \cdot g(n)$
- $f(n) = \Omega(g(n))$ 当且仅当 $\exists c, n_0: \forall n \geq n_0: f(n) \geq c \cdot g(n)$
- $f(n) = \Theta(g(n))$ 当且仅当 $f(n) = O(g(n))$ 且 $f(n) = \Omega(g(n))$

## 2. Python实现

### 2.1 算法抽象基类

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Any, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import time
import psutil
import os

T = TypeVar('T')
U = TypeVar('U')

class AlgorithmState(Enum):
    """算法状态"""
    INITIALIZED = "initialized"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class AlgorithmMetrics:
    """算法性能指标"""
    execution_time: float
    memory_usage: float
    cpu_usage: float
    input_size: int
    output_size: int
    steps_count: int

class Algorithm(ABC, Generic[T, U]):
    """算法抽象基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.state = AlgorithmState.INITIALIZED
        self.metrics: Optional[AlgorithmMetrics] = None
        self._start_time: Optional[float] = None
        self._start_memory: Optional[float] = None
    
    @abstractmethod
    def solve(self, input_data: T) -> U:
        """解决算法问题"""
        pass
    
    @abstractmethod
    def is_correct(self, input_data: T, output: U) -> bool:
        """验证算法正确性"""
        pass
    
    def execute(self, input_data: T) -> U:
        """执行算法并收集指标"""
        self.state = AlgorithmState.RUNNING
        self._start_time = time.time()
        self._start_memory = self._get_memory_usage()
        
        try:
            result = self.solve(input_data)
            self.state = AlgorithmState.COMPLETED
            self._record_metrics(input_data, result)
            return result
        except Exception as e:
            self.state = AlgorithmState.FAILED
            raise e
    
    def _get_memory_usage(self) -> float:
        """获取当前内存使用量"""
        process = psutil.Process(os.getpid())
        return process.memory_info().rss / 1024 / 1024  # MB
    
    def _record_metrics(self, input_data: T, output: U) -> None:
        """记录性能指标"""
        end_time = time.time()
        end_memory = self._get_memory_usage()
        
        self.metrics = AlgorithmMetrics(
            execution_time=end_time - self._start_time,
            memory_usage=end_memory - self._start_memory,
            cpu_usage=psutil.cpu_percent(),
            input_size=self._calculate_input_size(input_data),
            output_size=self._calculate_output_size(output),
            steps_count=self._count_steps()
        )
    
    def _calculate_input_size(self, input_data: T) -> int:
        """计算输入大小"""
        if isinstance(input_data, (list, tuple)):
            return len(input_data)
        elif isinstance(input_data, dict):
            return len(input_data)
        elif isinstance(input_data, str):
            return len(input_data)
        else:
            return 1
    
    def _calculate_output_size(self, output: U) -> int:
        """计算输出大小"""
        if isinstance(output, (list, tuple)):
            return len(output)
        elif isinstance(output, dict):
            return len(output)
        elif isinstance(output, str):
            return len(output)
        else:
            return 1
    
    def _count_steps(self) -> int:
        """计算执行步数（子类可重写）"""
        return 0
    
    def get_complexity_analysis(self) -> dict:
        """获取复杂度分析"""
        return {
            "time_complexity": self._analyze_time_complexity(),
            "space_complexity": self._analyze_space_complexity(),
            "best_case": self._analyze_best_case(),
            "worst_case": self._analyze_worst_case(),
            "average_case": self._analyze_average_case()
        }
    
    @abstractmethod
    def _analyze_time_complexity(self) -> str:
        """分析时间复杂度"""
        pass
    
    @abstractmethod
    def _analyze_space_complexity(self) -> str:
        """分析空间复杂度"""
        pass
    
    @abstractmethod
    def _analyze_best_case(self) -> str:
        """分析最佳情况"""
        pass
    
    @abstractmethod
    def _analyze_worst_case(self) -> str:
        """分析最坏情况"""
        pass
    
    @abstractmethod
    def _analyze_average_case(self) -> str:
        """分析平均情况"""
        pass
```

### 2.2 算法验证器

```python
class AlgorithmValidator:
    """算法验证器"""
    
    def __init__(self):
        self.test_cases: list = []
        self.performance_tests: list = []
    
    def add_test_case(self, input_data: T, expected_output: U, description: str = ""):
        """添加测试用例"""
        self.test_cases.append({
            "input": input_data,
            "expected": expected_output,
            "description": description
        })
    
    def validate_algorithm(self, algorithm: Algorithm[T, U]) -> dict:
        """验证算法"""
        results = {
            "correctness": self._test_correctness(algorithm),
            "performance": self._test_performance(algorithm),
            "robustness": self._test_robustness(algorithm)
        }
        
        return results
    
    def _test_correctness(self, algorithm: Algorithm[T, U]) -> dict:
        """测试正确性"""
        passed = 0
        failed = 0
        errors = []
        
        for i, test_case in enumerate(self.test_cases):
            try:
                result = algorithm.execute(test_case["input"])
                if algorithm.is_correct(test_case["input"], result):
                    passed += 1
                else:
                    failed += 1
                    errors.append(f"Test case {i}: Expected {test_case['expected']}, got {result}")
            except Exception as e:
                failed += 1
                errors.append(f"Test case {i}: Exception {str(e)}")
        
        return {
            "passed": passed,
            "failed": failed,
            "total": len(self.test_cases),
            "success_rate": passed / len(self.test_cases) if self.test_cases else 0,
            "errors": errors
        }
    
    def _test_performance(self, algorithm: Algorithm[T, U]) -> dict:
        """测试性能"""
        if not algorithm.metrics:
            return {"error": "No metrics available"}
        
        return {
            "execution_time": algorithm.metrics.execution_time,
            "memory_usage": algorithm.metrics.memory_usage,
            "cpu_usage": algorithm.metrics.cpu_usage,
            "steps_count": algorithm.metrics.steps_count
        }
    
    def _test_robustness(self, algorithm: Algorithm[T, U]) -> dict:
        """测试健壮性"""
        # 测试边界条件
        edge_cases = self._generate_edge_cases()
        robustness_results = []
        
        for edge_case in edge_cases:
            try:
                result = algorithm.execute(edge_case)
                robustness_results.append({
                    "case": edge_case,
                    "status": "passed",
                    "result": result
                })
            except Exception as e:
                robustness_results.append({
                    "case": edge_case,
                    "status": "failed",
                    "error": str(e)
                })
        
        return {
            "edge_cases_tested": len(edge_cases),
            "passed": sum(1 for r in robustness_results if r["status"] == "passed"),
            "failed": sum(1 for r in robustness_results if r["status"] == "failed"),
            "results": robustness_results
        }
    
    def _generate_edge_cases(self) -> list:
        """生成边界测试用例"""
        return [
            [],  # 空输入
            [1],  # 单个元素
            [1, 1, 1, 1, 1],  # 重复元素
            list(range(1000)),  # 大输入
            [float('inf')],  # 无穷大
            [float('-inf')],  # 负无穷大
            [None],  # None值
        ]
```

### 2.3 复杂度分析器

```python
class ComplexityAnalyzer:
    """复杂度分析器"""
    
    def __init__(self):
        self.analysis_results = {}
    
    def analyze_algorithm(self, algorithm: Algorithm[T, U], 
                         input_sizes: list[int]) -> dict:
        """分析算法复杂度"""
        results = []
        
        for size in input_sizes:
            # 生成测试数据
            test_data = self._generate_test_data(size)
            
            # 执行算法
            start_time = time.time()
            result = algorithm.execute(test_data)
            execution_time = time.time() - start_time
            
            results.append({
                "input_size": size,
                "execution_time": execution_time,
                "memory_usage": algorithm.metrics.memory_usage if algorithm.metrics else 0
            })
        
        # 分析趋势
        time_complexity = self._analyze_time_trend(results)
        space_complexity = self._analyze_space_trend(results)
        
        return {
            "empirical_time_complexity": time_complexity,
            "empirical_space_complexity": space_complexity,
            "theoretical_complexity": algorithm.get_complexity_analysis(),
            "measurements": results
        }
    
    def _generate_test_data(self, size: int) -> T:
        """生成测试数据"""
        # 子类可重写以生成特定类型的测试数据
        return list(range(size))
    
    def _analyze_time_trend(self, results: list) -> str:
        """分析时间趋势"""
        if len(results) < 2:
            return "Insufficient data"
        
        # 计算增长率
        growth_rates = []
        for i in range(1, len(results)):
            size_ratio = results[i]["input_size"] / results[i-1]["input_size"]
            time_ratio = results[i]["execution_time"] / results[i-1]["execution_time"]
            growth_rates.append(time_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # 判断复杂度
        if avg_growth < 1.1:
            return "O(1)"
        elif avg_growth < 1.5:
            return "O(log n)"
        elif avg_growth < 2.5:
            return "O(n)"
        elif avg_growth < 4:
            return "O(n log n)"
        elif avg_growth < 8:
            return "O(n²)"
        else:
            return "O(n³) or higher"
    
    def _analyze_space_trend(self, results: list) -> str:
        """分析空间趋势"""
        if len(results) < 2:
            return "Insufficient data"
        
        # 计算空间增长率
        growth_rates = []
        for i in range(1, len(results)):
            size_ratio = results[i]["input_size"] / results[i-1]["input_size"]
            space_ratio = results[i]["memory_usage"] / results[i-1]["memory_usage"]
            growth_rates.append(space_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # 判断复杂度
        if avg_growth < 1.1:
            return "O(1)"
        elif avg_growth < 1.5:
            return "O(log n)"
        elif avg_growth < 2.5:
            return "O(n)"
        else:
            return "O(n²) or higher"
```

## 3. 理论证明

### 3.1 算法正确性证明

**定理 1.1** (算法正确性验证)
如果算法 $A$ 满足以下条件，则 $A$ 是正确的：

1. **初始化正确性**: 初始状态满足前置条件
2. **保持性**: 每次迭代后状态仍满足循环不变量
3. **终止性**: 算法最终会终止
4. **后置条件**: 终止时满足后置条件

**证明**:
设 $P$ 为前置条件，$Q$ 为后置条件，$I$ 为循环不变量。

1. 初始化时：$P \Rightarrow I$ ✓
2. 保持性：$\{I \land B\} S \{I\}$ ✓  
3. 终止性：$I \land \neg B \Rightarrow Q$ ✓

因此，$\{P\} A \{Q\}$ 成立。

### 3.2 复杂度分析证明

**定理 1.2** (主定理)
对于递归算法 $T(n) = aT(n/b) + f(n)$，其中 $a \geq 1, b > 1$：

- 如果 $f(n) = O(n^{\log_b a - \epsilon})$，则 $T(n) = \Theta(n^{\log_b a})$
- 如果 $f(n) = \Theta(n^{\log_b a})$，则 $T(n) = \Theta(n^{\log_b a} \log n)$
- 如果 $f(n) = \Omega(n^{\log_b a + \epsilon})$，则 $T(n) = \Theta(f(n))$

**证明**:
通过递归树分析和几何级数求和可得。

## 4. 应用示例

### 4.1 线性搜索算法

```python
class LinearSearch(Algorithm[list[int], Optional[int]]):
    """线性搜索算法"""
    
    def __init__(self, target: int):
        super().__init__("Linear Search")
        self.target = target
        self.steps = 0
    
    def solve(self, input_data: list[int]) -> Optional[int]:
        """执行线性搜索"""
        for i, value in enumerate(input_data):
            self.steps += 1
            if value == self.target:
                return i
        return None
    
    def is_correct(self, input_data: list[int], output: Optional[int]) -> bool:
        """验证正确性"""
        if output is None:
            return self.target not in input_data
        else:
            return 0 <= output < len(input_data) and input_data[output] == self.target
    
    def _count_steps(self) -> int:
        return self.steps
    
    def _analyze_time_complexity(self) -> str:
        return "O(n)"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1)"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - 目标在第一个位置"
    
    def _analyze_worst_case(self) -> str:
        return "O(n) - 目标在最后一个位置或不存在"
    
    def _analyze_average_case(self) -> str:
        return "O(n) - 平均需要检查一半的元素"
```

### 4.2 二分搜索算法

```python
class BinarySearch(Algorithm[list[int], Optional[int]]):
    """二分搜索算法"""
    
    def __init__(self, target: int):
        super().__init__("Binary Search")
        self.target = target
        self.steps = 0
    
    def solve(self, input_data: list[int]) -> Optional[int]:
        """执行二分搜索"""
        left, right = 0, len(input_data) - 1
        
        while left <= right:
            self.steps += 1
            mid = (left + right) // 2
            
            if input_data[mid] == self.target:
                return mid
            elif input_data[mid] < self.target:
                left = mid + 1
            else:
                right = mid - 1
        
        return None
    
    def is_correct(self, input_data: list[int], output: Optional[int]) -> bool:
        """验证正确性"""
        if output is None:
            return self.target not in input_data
        else:
            return 0 <= output < len(input_data) and input_data[output] == self.target
    
    def _count_steps(self) -> int:
        return self.steps
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n)"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1)"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - 目标在中间位置"
    
    def _analyze_worst_case(self) -> str:
        return "O(log n) - 目标不存在或在最边缘"
    
    def _analyze_average_case(self) -> str:
        return "O(log n) - 平均需要 log₂n 次比较"
```

## 5. 测试与验证

```python
def test_algorithms():
    """测试算法实现"""
    
    # 创建测试数据
    test_data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    
    # 测试线性搜索
    linear_search = LinearSearch(7)
    result1 = linear_search.execute(test_data)
    print(f"Linear Search Result: {result1}")
    print(f"Linear Search Metrics: {linear_search.metrics}")
    
    # 测试二分搜索
    binary_search = BinarySearch(7)
    result2 = binary_search.execute(test_data)
    print(f"Binary Search Result: {result2}")
    print(f"Binary Search Metrics: {binary_search.metrics}")
    
    # 验证算法
    validator = AlgorithmValidator()
    validator.add_test_case(test_data, 3, "Find 7 in sorted array")
    validator.add_test_case(test_data, None, "Find 6 in sorted array")
    
    results1 = validator.validate_algorithm(linear_search)
    results2 = validator.validate_algorithm(binary_search)
    
    print(f"Linear Search Validation: {results1}")
    print(f"Binary Search Validation: {results2}")
    
    # 复杂度分析
    analyzer = ComplexityAnalyzer()
    input_sizes = [100, 1000, 10000, 100000]
    
    analysis1 = analyzer.analyze_algorithm(linear_search, input_sizes)
    analysis2 = analyzer.analyze_algorithm(binary_search, input_sizes)
    
    print(f"Linear Search Analysis: {analysis1}")
    print(f"Binary Search Analysis: {analysis2}")

if __name__ == "__main__":
    test_algorithms()
```

## 6. 总结

本文档建立了算法理论的完整形式化框架：

1. **形式化定义**: 提供了算法的严格数学定义
2. **Python实现**: 完整的算法抽象和实现框架
3. **理论证明**: 算法正确性和复杂度的形式化证明
4. **实践应用**: 具体的算法实现和测试验证

这个框架为后续的算法研究提供了坚实的基础，确保所有算法都有严格的理论支撑和完整的实现验证。

---

*下一节：[02-01-02 排序算法理论](./02-01-02-排序算法理论.md)*
