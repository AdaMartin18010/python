# 02-01-03 æœç´¢ç®—æ³•ç†è®º

## ğŸ“‹ æ¦‚è¿°

æœç´¢ç®—æ³•æ˜¯åœ¨æ•°æ®é›†åˆä¸­æŸ¥æ‰¾ç‰¹å®šå…ƒç´ æˆ–æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„å…ƒç´ çš„è¿‡ç¨‹ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰æœç´¢é—®é¢˜ï¼Œåˆ†æå„ç§æœç´¢ç®—æ³•çš„ç†è®ºæ€§è´¨ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 æœç´¢é—®é¢˜å®šä¹‰

**å®šä¹‰ 1.1** (æœç´¢é—®é¢˜)
æœç´¢é—®é¢˜æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$S = (U, P, f, g)$$
å…¶ä¸­ï¼š

- $U$ ä¸ºæœç´¢ç©ºé—´ï¼ˆå…¨é›†ï¼‰
- $P$ ä¸ºé—®é¢˜å®ä¾‹é›†åˆ
- $f: P \times U \rightarrow \{true, false\}$ ä¸ºåŒ¹é…å‡½æ•°
- $g: P \times U \rightarrow \mathbb{R}$ ä¸ºè¯„ä¼°å‡½æ•°

**å®šä¹‰ 1.2** (ç²¾ç¡®æœç´¢)
ç²¾ç¡®æœç´¢å¯»æ‰¾æ»¡è¶³ $f(p, x) = true$ çš„å…ƒç´ ï¼š
$$Search(p) = \{x \in U \mid f(p, x) = true\}$$

**å®šä¹‰ 1.3** (ä¼˜åŒ–æœç´¢)
ä¼˜åŒ–æœç´¢å¯»æ‰¾ä½¿ $g(p, x)$ æœ€å¤§åŒ–çš„å…ƒç´ ï¼š
$$OptSearch(p) = \arg\max_{x \in U} g(p, x)$$

### 1.2 æœç´¢ç®—æ³•åˆ†ç±»

**å®šä¹‰ 1.4** (çº¿æ€§æœç´¢)
çº¿æ€§æœç´¢æŒ‰é¡ºåºæ£€æŸ¥æ¯ä¸ªå…ƒç´ ï¼š
$$T(n) = O(n)$$

**å®šä¹‰ 1.5** (äºŒåˆ†æœç´¢)
äºŒåˆ†æœç´¢åœ¨æœ‰åºæ•°æ®ä¸Šä½¿ç”¨åˆ†æ²»ç­–ç•¥ï¼š
$$T(n) = O(\log n)$$

**å®šä¹‰ 1.6** (å¯å‘å¼æœç´¢)
å¯å‘å¼æœç´¢ä½¿ç”¨å¯å‘å‡½æ•°æŒ‡å¯¼æœç´¢æ–¹å‘ï¼š
$$T(n) = O(b^d)$$ å…¶ä¸­ $b$ ä¸ºåˆ†æ”¯å› å­ï¼Œ$d$ ä¸ºæ·±åº¦

## 2. Pythonå®ç°

### 2.1 æœç´¢ç®—æ³•åŸºç±»

```python
from abc import abstractmethod
from typing import List, TypeVar, Callable, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import heapq
import math

T = TypeVar('T')
U = TypeVar('U')

class SearchType(Enum):
    """æœç´¢ç±»å‹"""
    EXACT = "exact"
    OPTIMIZATION = "optimization"
    APPROXIMATE = "approximate"

@dataclass
class SearchResult:
    """æœç´¢ç»“æœ"""
    found: bool
    value: Optional[T]
    index: Optional[int]
    path: List[T]
    cost: float
    iterations: int

class SearchAlgorithm(Algorithm[List[T], SearchResult]):
    """æœç´¢ç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str, search_type: SearchType):
        super().__init__(name)
        self.search_type = search_type
        self.iterations = 0
        self.target: Optional[T] = None
    
    @abstractmethod
    def search(self, data: List[T], target: T) -> SearchResult:
        """æ‰§è¡Œæœç´¢"""
        pass
    
    def solve(self, input_data: List[T]) -> SearchResult:
        """è§£å†³æœç´¢é—®é¢˜"""
        if self.target is None:
            raise ValueError("Target not set")
        return self.search(input_data, self.target)
    
    def set_target(self, target: T) -> None:
        """è®¾ç½®æœç´¢ç›®æ ‡"""
        self.target = target
    
    def is_correct(self, input_data: List[T], output: SearchResult) -> bool:
        """éªŒè¯æœç´¢æ­£ç¡®æ€§"""
        if not output.found:
            return self.target not in input_data
        else:
            return (0 <= output.index < len(input_data) and 
                   input_data[output.index] == self.target)
    
    def _count_steps(self) -> int:
        return self.iterations
```

### 2.2 çº¿æ€§æœç´¢

```python
class LinearSearch(SearchAlgorithm[T]):
    """çº¿æ€§æœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Linear Search", SearchType.EXACT)
    
    def search(self, data: List[T], target: T) -> SearchResult:
        """æ‰§è¡Œçº¿æ€§æœç´¢"""
        path = []
        
        for i, item in enumerate(data):
            self.iterations += 1
            path.append(item)
            
            if item == target:
                return SearchResult(
                    found=True,
                    value=item,
                    index=i,
                    path=path,
                    cost=i + 1,
                    iterations=self.iterations
                )
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=path,
            cost=len(data),
            iterations=self.iterations
        )
    
    def _analyze_time_complexity(self) -> str:
        return "O(n)"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1)"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - ç›®æ ‡åœ¨ç¬¬ä¸€ä¸ªä½ç½®"
    
    def _analyze_worst_case(self) -> str:
        return "O(n) - ç›®æ ‡åœ¨æœ€åä¸€ä¸ªä½ç½®æˆ–ä¸å­˜åœ¨"
    
    def _analyze_average_case(self) -> str:
        return "O(n) - å¹³å‡éœ€è¦æ£€æŸ¥ä¸€åŠçš„å…ƒç´ "
```

### 2.3 äºŒåˆ†æœç´¢

```python
class BinarySearch(SearchAlgorithm[T]):
    """äºŒåˆ†æœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Binary Search", SearchType.EXACT)
    
    def search(self, data: List[T], target: T) -> SearchResult:
        """æ‰§è¡ŒäºŒåˆ†æœç´¢"""
        if not data:
            return SearchResult(
                found=False,
                value=None,
                index=None,
                path=[],
                cost=0,
                iterations=0
            )
        
        left, right = 0, len(data) - 1
        path = []
        
        while left <= right:
            self.iterations += 1
            mid = (left + right) // 2
            current = data[mid]
            path.append(current)
            
            if current == target:
                return SearchResult(
                    found=True,
                    value=current,
                    index=mid,
                    path=path,
                    cost=self.iterations,
                    iterations=self.iterations
                )
            elif current < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=path,
            cost=self.iterations,
            iterations=self.iterations
        )
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n)"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1)"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - ç›®æ ‡åœ¨ä¸­é—´ä½ç½®"
    
    def _analyze_worst_case(self) -> str:
        return "O(log n) - ç›®æ ‡ä¸å­˜åœ¨æˆ–åœ¨æœ€è¾¹ç¼˜"
    
    def _analyze_average_case(self) -> str:
        return "O(log n) - å¹³å‡éœ€è¦ logâ‚‚n æ¬¡æ¯”è¾ƒ"
```

### 2.4 æ’å€¼æœç´¢

```python
class InterpolationSearch(SearchAlgorithm[int]):
    """æ’å€¼æœç´¢ç®—æ³•ï¼ˆé€‚ç”¨äºå‡åŒ€åˆ†å¸ƒçš„æ•´æ•°ï¼‰"""
    
    def __init__(self):
        super().__init__("Interpolation Search", SearchType.EXACT)
    
    def search(self, data: List[int], target: int) -> SearchResult:
        """æ‰§è¡Œæ’å€¼æœç´¢"""
        if not data:
            return SearchResult(
                found=False,
                value=None,
                index=None,
                path=[],
                cost=0,
                iterations=0
            )
        
        left, right = 0, len(data) - 1
        path = []
        
        while (left <= right and 
               target >= data[left] and 
               target <= data[right]):
            
            self.iterations += 1
            
            # æ’å€¼å…¬å¼
            if data[right] == data[left]:
                pos = left
            else:
                pos = left + int(((target - data[left]) * (right - left)) / 
                                (data[right] - data[left]))
            
            current = data[pos]
            path.append(current)
            
            if current == target:
                return SearchResult(
                    found=True,
                    value=current,
                    index=pos,
                    path=path,
                    cost=self.iterations,
                    iterations=self.iterations
                )
            elif current < target:
                left = pos + 1
            else:
                right = pos - 1
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=path,
            cost=self.iterations,
            iterations=self.iterations
        )
    
    def _analyze_time_complexity(self) -> str:
        return "O(log log n) å¹³å‡ï¼ŒO(n) æœ€å"
    
    def _analyze_space_complexity(self) -> str:
        return "O(1)"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - ç›®æ ‡åœ¨æ’å€¼ä½ç½®"
    
    def _analyze_worst_case(self) -> str:
        return "O(n) - æ•°æ®åˆ†å¸ƒæä¸å‡åŒ€"
    
    def _analyze_average_case(self) -> str:
        return "O(log log n) - æ•°æ®å‡åŒ€åˆ†å¸ƒ"
```

### 2.5 æ·±åº¦ä¼˜å…ˆæœç´¢

```python
class DepthFirstSearch(SearchAlgorithm[T]):
    """æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Depth First Search", SearchType.EXACT)
        self.visited = set()
    
    def search(self, data: List[T], target: T) -> SearchResult:
        """æ‰§è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢"""
        self.visited.clear()
        path = []
        
        # å°†åˆ—è¡¨è§†ä¸ºå›¾ï¼Œæ¯ä¸ªå…ƒç´ è¿æ¥åˆ°ç›¸é‚»å…ƒç´ 
        for i, item in enumerate(data):
            if i not in self.visited:
                result = self._dfs(data, i, target, path)
                if result.found:
                    return result
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=path,
            cost=self.iterations,
            iterations=self.iterations
        )
    
    def _dfs(self, data: List[T], index: int, target: T, path: List[T]) -> SearchResult:
        """é€’å½’æ·±åº¦ä¼˜å…ˆæœç´¢"""
        if index in self.visited or index >= len(data):
            return SearchResult(
                found=False,
                value=None,
                index=None,
                path=path,
                cost=self.iterations,
                iterations=self.iterations
            )
        
        self.iterations += 1
        self.visited.add(index)
        current = data[index]
        path.append(current)
        
        if current == target:
            return SearchResult(
                found=True,
                value=current,
                index=index,
                path=path,
                cost=self.iterations,
                iterations=self.iterations
            )
        
        # æœç´¢ç›¸é‚»å…ƒç´ 
        for neighbor in [index - 1, index + 1]:
            if 0 <= neighbor < len(data) and neighbor not in self.visited:
                result = self._dfs(data, neighbor, target, path)
                if result.found:
                    return result
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=path,
            cost=self.iterations,
            iterations=self.iterations
        )
    
    def _analyze_time_complexity(self) -> str:
        return "O(V + E) å…¶ä¸­Væ˜¯é¡¶ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°"
    
    def _analyze_space_complexity(self) -> str:
        return "O(V) - é€’å½’æ ˆæ·±åº¦"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - ç›®æ ‡åœ¨èµ·å§‹ä½ç½®"
    
    def _analyze_worst_case(self) -> str:
        return "O(V + E) - éœ€è¦è®¿é—®æ‰€æœ‰é¡¶ç‚¹å’Œè¾¹"
    
    def _analyze_average_case(self) -> str:
        return "O(V + E) - å¹³å‡æƒ…å†µ"
```

### 2.6 å¹¿åº¦ä¼˜å…ˆæœç´¢

```python
from collections import deque

class BreadthFirstSearch(SearchAlgorithm[T]):
    """å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Breadth First Search", SearchType.EXACT)
        self.visited = set()
    
    def search(self, data: List[T], target: T) -> SearchResult:
        """æ‰§è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢"""
        self.visited.clear()
        path = []
        
        # å°†åˆ—è¡¨è§†ä¸ºå›¾ï¼Œæ¯ä¸ªå…ƒç´ è¿æ¥åˆ°ç›¸é‚»å…ƒç´ 
        for i, item in enumerate(data):
            if i not in self.visited:
                result = self._bfs(data, i, target, path)
                if result.found:
                    return result
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=path,
            cost=self.iterations,
            iterations=self.iterations
        )
    
    def _bfs(self, data: List[T], start: int, target: T, path: List[T]) -> SearchResult:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
        queue = deque([(start, [data[start]])])
        self.visited.add(start)
        
        while queue:
            self.iterations += 1
            index, current_path = queue.popleft()
            current = data[index]
            path.extend(current_path)
            
            if current == target:
                return SearchResult(
                    found=True,
                    value=current,
                    index=index,
                    path=path,
                    cost=self.iterations,
                    iterations=self.iterations
                )
            
            # æ·»åŠ ç›¸é‚»å…ƒç´ åˆ°é˜Ÿåˆ—
            for neighbor in [index - 1, index + 1]:
                if (0 <= neighbor < len(data) and 
                    neighbor not in self.visited):
                    self.visited.add(neighbor)
                    new_path = current_path + [data[neighbor]]
                    queue.append((neighbor, new_path))
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=path,
            cost=self.iterations,
            iterations=self.iterations
        )
    
    def _analyze_time_complexity(self) -> str:
        return "O(V + E) å…¶ä¸­Væ˜¯é¡¶ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°"
    
    def _analyze_space_complexity(self) -> str:
        return "O(V) - é˜Ÿåˆ—å¤§å°"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - ç›®æ ‡åœ¨èµ·å§‹ä½ç½®"
    
    def _analyze_worst_case(self) -> str:
        return "O(V + E) - éœ€è¦è®¿é—®æ‰€æœ‰é¡¶ç‚¹å’Œè¾¹"
    
    def _analyze_average_case(self) -> str:
        return "O(V + E) - å¹³å‡æƒ…å†µ"
```

### 2.7 A*æœç´¢

```python
@dataclass
class Node:
    """æœç´¢èŠ‚ç‚¹"""
    index: int
    value: T
    g_cost: float  # ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„æˆæœ¬
    h_cost: float  # å¯å‘å¼æˆæœ¬
    parent: Optional['Node'] = None
    
    @property
    def f_cost(self) -> float:
        return self.g_cost + self.h_cost
    
    def __lt__(self, other):
        return self.f_cost < other.f_cost

class AStarSearch(SearchAlgorithm[T]):
    """A*æœç´¢ç®—æ³•"""
    
    def __init__(self, heuristic_func: Optional[Callable[[T, T], float]] = None):
        super().__init__("A* Search", SearchType.OPTIMIZATION)
        self.heuristic_func = heuristic_func or self._default_heuristic
    
    def _default_heuristic(self, current: T, target: T) -> float:
        """é»˜è®¤å¯å‘å‡½æ•°"""
        if isinstance(current, (int, float)) and isinstance(target, (int, float)):
            return abs(current - target)
        return 0
    
    def search(self, data: List[T], target: T) -> SearchResult:
        """æ‰§è¡ŒA*æœç´¢"""
        if not data:
            return SearchResult(
                found=False,
                value=None,
                index=None,
                path=[],
                cost=0,
                iterations=0
            )
        
        # åˆå§‹åŒ–å¼€æ”¾åˆ—è¡¨å’Œå…³é—­åˆ—è¡¨
        open_list = []
        closed_set = set()
        
        # åˆ›å»ºèµ·å§‹èŠ‚ç‚¹
        start_node = Node(
            index=0,
            value=data[0],
            g_cost=0,
            h_cost=self.heuristic_func(data[0], target)
        )
        
        heapq.heappush(open_list, start_node)
        
        while open_list:
            self.iterations += 1
            current_node = heapq.heappop(open_list)
            
            if current_node.value == target:
                # é‡å»ºè·¯å¾„
                path = self._reconstruct_path(current_node, data)
                return SearchResult(
                    found=True,
                    value=current_node.value,
                    index=current_node.index,
                    path=path,
                    cost=current_node.g_cost,
                    iterations=self.iterations
                )
            
            closed_set.add(current_node.index)
            
            # æ£€æŸ¥ç›¸é‚»èŠ‚ç‚¹
            for neighbor_idx in [current_node.index - 1, current_node.index + 1]:
                if (0 <= neighbor_idx < len(data) and 
                    neighbor_idx not in closed_set):
                    
                    neighbor_value = data[neighbor_idx]
                    g_cost = current_node.g_cost + 1  # å‡è®¾æ¯æ­¥æˆæœ¬ä¸º1
                    h_cost = self.heuristic_func(neighbor_value, target)
                    
                    neighbor_node = Node(
                        index=neighbor_idx,
                        value=neighbor_value,
                        g_cost=g_cost,
                        h_cost=h_cost,
                        parent=current_node
                    )
                    
                    heapq.heappush(open_list, neighbor_node)
        
        return SearchResult(
            found=False,
            value=None,
            index=None,
            path=[],
            cost=float('inf'),
            iterations=self.iterations
        )
    
    def _reconstruct_path(self, node: Node, data: List[T]) -> List[T]:
        """é‡å»ºè·¯å¾„"""
        path = []
        current = node
        while current:
            path.append(current.value)
            current = current.parent
        return list(reversed(path))
    
    def _analyze_time_complexity(self) -> str:
        return "O(b^d) å…¶ä¸­bæ˜¯åˆ†æ”¯å› å­ï¼Œdæ˜¯è§£æ·±åº¦"
    
    def _analyze_space_complexity(self) -> str:
        return "O(b^d) - å¼€æ”¾åˆ—è¡¨å¤§å°"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - ç›®æ ‡åœ¨èµ·å§‹ä½ç½®"
    
    def _analyze_worst_case(self) -> str:
        return "O(b^d) - éœ€è¦æ¢ç´¢æ‰€æœ‰å¯èƒ½è·¯å¾„"
    
    def _analyze_average_case(self) -> str:
        return "O(b^d) - å¹³å‡æƒ…å†µ"
```

## 3. ç†è®ºè¯æ˜

### 3.1 äºŒåˆ†æœç´¢æ­£ç¡®æ€§

**å®šç† 3.1** (äºŒåˆ†æœç´¢æ­£ç¡®æ€§)
äºŒåˆ†æœç´¢ç®—æ³•åœ¨æœ‰åºæ•°ç»„ä¸Šæ˜¯æ­£ç¡®çš„ã€‚

**è¯æ˜**:
1. **åˆå§‹åŒ–**: æœç´¢èŒƒå›´åŒ…å«æ•´ä¸ªæ•°ç»„ âœ“
2. **ä¿æŒæ€§**: æ¯æ¬¡è¿­ä»£åï¼Œå¦‚æœç›®æ ‡å­˜åœ¨ï¼Œå®ƒä»åœ¨æœç´¢èŒƒå›´å†… âœ“
3. **ç»ˆæ­¢æ€§**: æœç´¢èŒƒå›´æ¯æ¬¡è‡³å°‘å‡åŠï¼Œæœ€ç»ˆä¼šå˜ä¸ºç©º âœ“
4. **æ­£ç¡®æ€§**: æ‰¾åˆ°çš„å…ƒç´ ç­‰äºç›®æ ‡ï¼Œæˆ–ç›®æ ‡ä¸å­˜åœ¨ âœ“

### 3.2 æ’å€¼æœç´¢å¤æ‚åº¦

**å®šç† 3.2** (æ’å€¼æœç´¢å¤æ‚åº¦)
å¯¹äºå‡åŒ€åˆ†å¸ƒçš„æ•°æ®ï¼Œæ’å€¼æœç´¢çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(\log \log n)$ã€‚

**è¯æ˜**:
æ’å€¼æœç´¢ä½¿ç”¨çº¿æ€§æ’å€¼ä¼°è®¡ç›®æ ‡ä½ç½®ï¼Œåœ¨å‡åŒ€åˆ†å¸ƒä¸‹ï¼Œæ¯æ¬¡è¿­ä»£å°†æœç´¢ç©ºé—´ç¼©å°åˆ° $\sqrt{n}$ï¼Œå› æ­¤éœ€è¦ $\log \log n$ æ¬¡è¿­ä»£ã€‚

### 3.3 A*æœç´¢æœ€ä¼˜æ€§

**å®šç† 3.3** (A*æœç´¢æœ€ä¼˜æ€§)
å¦‚æœå¯å‘å‡½æ•°æ˜¯å¯æ¥å—çš„ï¼ˆä¸é«˜ä¼°ï¼‰ï¼ŒA*æœç´¢ä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£ã€‚

**è¯æ˜**:
1. è®¾ $f^*(n)$ ä¸ºä»èµ·ç‚¹ç»è¿‡èŠ‚ç‚¹nåˆ°ç›®æ ‡çš„æœ€ä¼˜æˆæœ¬
2. å¯¹äºå¯æ¥å—å¯å‘å‡½æ•°ï¼š$h(n) \leq h^*(n)$
3. å› æ­¤ï¼š$f(n) = g(n) + h(n) \leq g(n) + h^*(n) = f^*(n)$
4. A*æ€»æ˜¯é€‰æ‹©få€¼æœ€å°çš„èŠ‚ç‚¹ï¼Œå› æ­¤æ‰¾åˆ°æœ€ä¼˜è§£

## 4. æ€§èƒ½æ¯”è¾ƒ

```python
def compare_search_algorithms():
    """æ¯”è¾ƒä¸åŒæœç´¢ç®—æ³•çš„æ€§èƒ½"""
    
    # åˆ›å»ºæµ‹è¯•æ•°æ®
    test_sizes = [1000, 10000, 100000]
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        InterpolationSearch(),
        DepthFirstSearch(),
        BreadthFirstSearch(),
        AStarSearch()
    ]
    
    results = {}
    
    for size in test_sizes:
        print(f"\næµ‹è¯•æ•°æ®å¤§å°: {size}")
        print("-" * 60)
        
        # ç”Ÿæˆæœ‰åºæµ‹è¯•æ•°æ®
        test_data = list(range(size))
        target = size // 2  # ç›®æ ‡åœ¨ä¸­é—´
        
        for algorithm in algorithms:
            try:
                # è®¾ç½®ç›®æ ‡
                algorithm.set_target(target)
                
                # é‡ç½®æŒ‡æ ‡
                algorithm.reset_metrics()
                
                # æ‰§è¡Œæœç´¢
                result = algorithm.execute(test_data)
                
                # è®°å½•ç»“æœ
                if algorithm.name not in results:
                    results[algorithm.name] = []
                
                results[algorithm.name].append({
                    "size": size,
                    "time": algorithm.metrics.execution_time,
                    "iterations": algorithm.iterations,
                    "found": result.found,
                    "cost": result.cost
                })
                
                print(f"{algorithm.name:20} | "
                      f"æ—¶é—´: {algorithm.metrics.execution_time:.6f}s | "
                      f"è¿­ä»£: {algorithm.iterations:6} | "
                      f"æ‰¾åˆ°: {'æ˜¯' if result.found else 'å¦'}")
                
            except Exception as e:
                print(f"{algorithm.name:20} | é”™è¯¯: {str(e)}")
    
    return results

def test_search_correctness():
    """æµ‹è¯•æœç´¢ç®—æ³•æ­£ç¡®æ€§"""
    
    # åˆ›å»ºæµ‹è¯•æ•°æ®
    test_data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    targets = [7, 10, 1, 19]  # å­˜åœ¨å’Œä¸å­˜åœ¨çš„æƒ…å†µ
    
    algorithms = [
        LinearSearch(),
        BinarySearch(),
        InterpolationSearch(),
        DepthFirstSearch(),
        BreadthFirstSearch(),
        AStarSearch()
    ]
    
    print("\næœç´¢ç®—æ³•æ­£ç¡®æ€§æµ‹è¯•")
    print("=" * 60)
    
    for target in targets:
        print(f"\næœç´¢ç›®æ ‡: {target}")
        print("-" * 40)
        
        for algorithm in algorithms:
            try:
                algorithm.set_target(target)
                result = algorithm.execute(test_data)
                
                expected_found = target in test_data
                expected_index = test_data.index(target) if expected_found else None
                
                correct = (result.found == expected_found and 
                          (not expected_found or result.index == expected_index))
                
                print(f"{algorithm.name:20} | "
                      f"æ­£ç¡®: {'æ˜¯' if correct else 'å¦'} | "
                      f"æ‰¾åˆ°: {'æ˜¯' if result.found else 'å¦'} | "
                      f"ä½ç½®: {result.index}")
                
            except Exception as e:
                print(f"{algorithm.name:20} | é”™è¯¯: {str(e)}")

if __name__ == "__main__":
    # æ€§èƒ½æ¯”è¾ƒ
    performance_results = compare_search_algorithms()
    
    # æ­£ç¡®æ€§æµ‹è¯•
    test_search_correctness()
```

## 5. æ€»ç»“

æœ¬æ–‡æ¡£å»ºç«‹äº†æœç´¢ç®—æ³•çš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†æœç´¢é—®é¢˜çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **ç®—æ³•å®ç°**: å®Œæ•´çš„æœç´¢ç®—æ³•Pythonå®ç°
3. **ç†è®ºè¯æ˜**: æœç´¢ç®—æ³•çš„æ­£ç¡®æ€§å’Œå¤æ‚åº¦è¯æ˜
4. **æ€§èƒ½åˆ†æ**: ä¸åŒæœç´¢ç®—æ³•çš„æ€§èƒ½æ¯”è¾ƒ

### æœç´¢ç®—æ³•ç‰¹æ€§æ€»ç»“

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ç‰¹ç‚¹ |
|------|------------|------------|----------|------|
| çº¿æ€§æœç´¢ | O(n) | O(1) | æ— åºæ•°æ® | ç®€å•ï¼Œé€šç”¨ |
| äºŒåˆ†æœç´¢ | O(log n) | O(1) | æœ‰åºæ•°æ® | é«˜æ•ˆï¼Œè¦æ±‚æœ‰åº |
| æ’å€¼æœç´¢ | O(log log n) | O(1) | å‡åŒ€åˆ†å¸ƒæœ‰åºæ•°æ® | æœ€å¿«ï¼Œè¦æ±‚å‡åŒ€åˆ†å¸ƒ |
| æ·±åº¦ä¼˜å…ˆæœç´¢ | O(V + E) | O(V) | å›¾æœç´¢ | å†…å­˜æ•ˆç‡é«˜ |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ | O(V + E) | O(V) | å›¾æœç´¢ï¼Œæœ€çŸ­è·¯å¾„ | ä¿è¯æœ€çŸ­è·¯å¾„ |
| A*æœç´¢ | O(b^d) | O(b^d) | å¯å‘å¼æœç´¢ | æœ€ä¼˜è§£ï¼Œå¯å‘å¼ |

---

*ä¸‹ä¸€èŠ‚ï¼š[02-01-04 å›¾ç®—æ³•ç†è®º](./02-01-04-å›¾ç®—æ³•ç†è®º.md)* 