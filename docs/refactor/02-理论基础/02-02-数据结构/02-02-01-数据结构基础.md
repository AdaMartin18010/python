# 02-02-01 æ•°æ®ç»“æ„åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°æ®ç»“æ„æ˜¯ç»„ç»‡å’Œå­˜å‚¨æ•°æ®çš„æ–¹å¼ï¼Œæ˜¯ç®—æ³•è®¾è®¡çš„åŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰æ•°æ®ç»“æ„ï¼Œå»ºç«‹æ•°æ®ç»“æ„åˆ†æçš„ç†è®ºåŸºç¡€ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 æ•°æ®ç»“æ„å®šä¹‰

**å®šä¹‰ 1.1** (æ•°æ®ç»“æ„)
æ•°æ®ç»“æ„æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$DS = (D, O, C, I, A)$$
å…¶ä¸­ï¼š

- $D$ ä¸ºæ•°æ®åŸŸ
- $O$ ä¸ºæ“ä½œé›†åˆ
- $C$ ä¸ºçº¦æŸæ¡ä»¶
- $I$ ä¸ºä¸å˜å¼
- $A$ ä¸ºæŠ½è±¡è¡¨ç¤º

**å®šä¹‰ 1.2** (æ•°æ®ç»“æ„æ“ä½œ)
æ“ä½œ $op \in O$ å®šä¹‰ä¸ºï¼š
$$op: D \times P \rightarrow D \times R$$
å…¶ä¸­ $P$ ä¸ºå‚æ•°é›†åˆï¼Œ$R$ ä¸ºç»“æœé›†åˆã€‚

**å®šä¹‰ 1.3** (æ•°æ®ç»“æ„ä¸å˜å¼)
ä¸å˜å¼ $I$ æ»¡è¶³ï¼š
$$\forall d \in D: I(d) = true$$

### 1.2 æŠ½è±¡æ•°æ®ç±»å‹

**å®šä¹‰ 1.4** (æŠ½è±¡æ•°æ®ç±»å‹)
æŠ½è±¡æ•°æ®ç±»å‹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$ADT = (T, O, A)$$
å…¶ä¸­ï¼š

- $T$ ä¸ºç±»å‹é›†åˆ
- $O$ ä¸ºæ“ä½œé›†åˆ
- $A$ ä¸ºå…¬ç†é›†åˆ

**å®šä¹‰ 1.5** (ADTå…¬ç†)
å…¬ç† $a \in A$ å®šä¹‰ä¸ºï¼š
$$\forall x_1, ..., x_n: a(op_1, ..., op_m)$$

## 2. Pythonå®ç°

### 2.1 æ•°æ®ç»“æ„åŸºç±»

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Any, Optional, Iterator
from dataclasses import dataclass
from enum import Enum
import time

T = TypeVar('T')

class DataStructureType(Enum):
    """æ•°æ®ç»“æ„ç±»å‹"""
    LINEAR = "linear"
    TREE = "tree"
    GRAPH = "graph"
    HASH = "hash"
    HEAP = "heap"

@dataclass
class OperationMetrics:
    """æ“ä½œæ€§èƒ½æŒ‡æ ‡"""
    operation_name: str
    execution_time: float
    memory_usage: float
    input_size: int
    success: bool

class DataStructure(ABC, Generic[T]):
    """æ•°æ®ç»“æ„æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, ds_type: DataStructureType):
        self.name = name
        self.ds_type = ds_type
        self.size = 0
        self.operations_history: list[OperationMetrics] = []
    
    @abstractmethod
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        pass
    
    @abstractmethod
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        pass
    
    @abstractmethod
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        pass
    
    @abstractmethod
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        pass
    
    @abstractmethod
    def clear(self) -> None:
        """æ¸…ç©ºæ•°æ®ç»“æ„"""
        pass
    
    def get_size(self) -> int:
        """è·å–å¤§å°"""
        return self.size
    
    def measure_operation(self, operation_name: str, func: callable, *args, **kwargs):
        """æµ‹é‡æ“ä½œæ€§èƒ½"""
        start_time = time.time()
        start_memory = self._get_memory_usage()
        
        try:
            result = func(*args, **kwargs)
            success = True
        except Exception as e:
            result = None
            success = False
        
        end_time = time.time()
        end_memory = self._get_memory_usage()
        
        metrics = OperationMetrics(
            operation_name=operation_name,
            execution_time=end_time - start_time,
            memory_usage=end_memory - start_memory,
            input_size=self.size,
            success=success
        )
        
        self.operations_history.append(metrics)
        return result
    
    def _get_memory_usage(self) -> float:
        """è·å–å†…å­˜ä½¿ç”¨é‡"""
        import psutil
        import os
        process = psutil.Process(os.getpid())
        return process.memory_info().rss / 1024 / 1024  # MB
    
    def get_performance_stats(self) -> dict:
        """è·å–æ€§èƒ½ç»Ÿè®¡"""
        if not self.operations_history:
            return {}
        
        stats = {}
        for op_name in set(op.operation_name for op in self.operations_history):
            op_metrics = [op for op in self.operations_history if op.operation_name == op_name]
            stats[op_name] = {
                "count": len(op_metrics),
                "avg_time": sum(op.execution_time for op in op_metrics) / len(op_metrics),
                "avg_memory": sum(op.memory_usage for op in op_metrics) / len(op_metrics),
                "success_rate": sum(1 for op in op_metrics if op.success) / len(op_metrics)
            }
        
        return stats
```

### 2.2 çº¿æ€§æ•°æ®ç»“æ„

#### 2.2.1 æ•°ç»„

```python
class Array(DataStructure[T]):
    """æ•°ç»„æ•°æ®ç»“æ„"""
    
    def __init__(self, initial_capacity: int = 10):
        super().__init__("Array", DataStructureType.LINEAR)
        self.capacity = initial_capacity
        self.data: list[Optional[T]] = [None] * initial_capacity
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        def _insert():
            if self.size >= self.capacity:
                self._resize(self.capacity * 2)
            
            self.data[self.size] = item
            self.size += 1
            return True
        
        return self.measure_operation("insert", _insert)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            index = self._find_index(item)
            if index == -1:
                return False
            
            # ç§»åŠ¨å…ƒç´ 
            for i in range(index, self.size - 1):
                self.data[i] = self.data[i + 1]
            
            self.data[self.size - 1] = None
            self.size -= 1
            
            # å¦‚æœå¤§å°å°äºå®¹é‡çš„1/4ï¼Œç¼©å°æ•°ç»„
            if self.size < self.capacity // 4:
                self._resize(self.capacity // 2)
            
            return True
        
        return self.measure_operation("delete", _delete)
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            index = self._find_index(item)
            return self.data[index] if index != -1 else None
        
        return self.measure_operation("search", _search)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.size == 0
    
    def clear(self) -> None:
        """æ¸…ç©ºæ•°ç»„"""
        self.data = [None] * self.capacity
        self.size = 0
    
    def _find_index(self, item: T) -> int:
        """æŸ¥æ‰¾å…ƒç´ ç´¢å¼•"""
        for i in range(self.size):
            if self.data[i] == item:
                return i
        return -1
    
    def _resize(self, new_capacity: int) -> None:
        """è°ƒæ•´æ•°ç»„å¤§å°"""
        new_data = [None] * new_capacity
        for i in range(self.size):
            new_data[i] = self.data[i]
        self.data = new_data
        self.capacity = new_capacity
    
    def __getitem__(self, index: int) -> T:
        """è·å–å…ƒç´ """
        if 0 <= index < self.size:
            return self.data[index]
        raise IndexError("Index out of range")
    
    def __setitem__(self, index: int, value: T) -> None:
        """è®¾ç½®å…ƒç´ """
        if 0 <= index < self.size:
            self.data[index] = value
        else:
            raise IndexError("Index out of range")
    
    def __len__(self) -> int:
        return self.size
    
    def __iter__(self) -> Iterator[T]:
        for i in range(self.size):
            yield self.data[i]
```

#### 2.2.2 é“¾è¡¨

```python
@dataclass
class Node(Generic[T]):
    """é“¾è¡¨èŠ‚ç‚¹"""
    data: T
    next: Optional['Node[T]'] = None

class LinkedList(DataStructure[T]):
    """é“¾è¡¨æ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("LinkedList", DataStructureType.LINEAR)
        self.head: Optional[Node[T]] = None
        self.tail: Optional[Node[T]] = None
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ åˆ°æœ«å°¾"""
        def _insert():
            new_node = Node(item)
            
            if self.is_empty():
                self.head = new_node
                self.tail = new_node
            else:
                self.tail.next = new_node
                self.tail = new_node
            
            self.size += 1
            return True
        
        return self.measure_operation("insert", _insert)
    
    def insert_at_beginning(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ åˆ°å¼€å¤´"""
        def _insert_beginning():
            new_node = Node(item, self.head)
            self.head = new_node
            
            if self.is_empty():
                self.tail = new_node
            
            self.size += 1
            return True
        
        return self.measure_operation("insert_at_beginning", _insert_beginning)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            if self.is_empty():
                return False
            
            # åˆ é™¤å¤´èŠ‚ç‚¹
            if self.head.data == item:
                self.head = self.head.next
                if self.head is None:
                    self.tail = None
                self.size -= 1
                return True
            
            # åˆ é™¤å…¶ä»–èŠ‚ç‚¹
            current = self.head
            while current.next:
                if current.next.data == item:
                    current.next = current.next.next
                    if current.next is None:
                        self.tail = current
                    self.size -= 1
                    return True
                current = current.next
            
            return False
        
        return self.measure_operation("delete", _delete)
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            current = self.head
            while current:
                if current.data == item:
                    return current.data
                current = current.next
            return None
        
        return self.measure_operation("search", _search)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.head is None
    
    def clear(self) -> None:
        """æ¸…ç©ºé“¾è¡¨"""
        self.head = None
        self.tail = None
        self.size = 0
    
    def reverse(self) -> None:
        """åè½¬é“¾è¡¨"""
        def _reverse():
            prev = None
            current = self.head
            
            while current:
                next_node = current.next
                current.next = prev
                prev = current
                current = next_node
            
            self.tail = self.head
            self.head = prev
        
        self.measure_operation("reverse", _reverse)
    
    def __iter__(self) -> Iterator[T]:
        current = self.head
        while current:
            yield current.data
            current = current.next
```

#### 2.2.3 æ ˆ

```python
class Stack(DataStructure[T]):
    """æ ˆæ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("Stack", DataStructureType.LINEAR)
        self.data: list[T] = []
    
    def push(self, item: T) -> bool:
        """å‹å…¥å…ƒç´ """
        def _push():
            self.data.append(item)
            self.size += 1
            return True
        
        return self.measure_operation("push", _push)
    
    def pop(self) -> Optional[T]:
        """å¼¹å‡ºå…ƒç´ """
        def _pop():
            if self.is_empty():
                return None
            
            item = self.data.pop()
            self.size -= 1
            return item
        
        return self.measure_operation("pop", _pop)
    
    def peek(self) -> Optional[T]:
        """æŸ¥çœ‹æ ˆé¡¶å…ƒç´ """
        def _peek():
            return self.data[-1] if not self.is_empty() else None
        
        return self.measure_operation("peek", _peek)
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ ï¼ˆå‹å…¥æ ˆï¼‰"""
        return self.push(item)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ ï¼ˆå¼¹å‡ºæ ˆï¼‰"""
        popped = self.pop()
        return popped == item
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            for i in range(len(self.data) - 1, -1, -1):
                if self.data[i] == item:
                    return self.data[i]
            return None
        
        return self.measure_operation("search", _search)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return len(self.data) == 0
    
    def clear(self) -> None:
        """æ¸…ç©ºæ ˆ"""
        self.data.clear()
        self.size = 0
    
    def __iter__(self) -> Iterator[T]:
        for item in reversed(self.data):
            yield item
```

#### 2.2.4 é˜Ÿåˆ—

```python
from collections import deque

class Queue(DataStructure[T]):
    """é˜Ÿåˆ—æ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("Queue", DataStructureType.LINEAR)
        self.data: deque[T] = deque()
    
    def enqueue(self, item: T) -> bool:
        """å…¥é˜Ÿ"""
        def _enqueue():
            self.data.append(item)
            self.size += 1
            return True
        
        return self.measure_operation("enqueue", _enqueue)
    
    def dequeue(self) -> Optional[T]:
        """å‡ºé˜Ÿ"""
        def _dequeue():
            if self.is_empty():
                return None
            
            item = self.data.popleft()
            self.size -= 1
            return item
        
        return self.measure_operation("dequeue", _dequeue)
    
    def front(self) -> Optional[T]:
        """æŸ¥çœ‹é˜Ÿé¦–å…ƒç´ """
        def _front():
            return self.data[0] if not self.is_empty() else None
        
        return self.measure_operation("front", _front)
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ ï¼ˆå…¥é˜Ÿï¼‰"""
        return self.enqueue(item)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ ï¼ˆå‡ºé˜Ÿï¼‰"""
        dequeued = self.dequeue()
        return dequeued == item
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            for element in self.data:
                if element == item:
                    return element
            return None
        
        return self.measure_operation("search", _search)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return len(self.data) == 0
    
    def clear(self) -> None:
        """æ¸…ç©ºé˜Ÿåˆ—"""
        self.data.clear()
        self.size = 0
    
    def __iter__(self) -> Iterator[T]:
        for item in self.data:
            yield item
```

### 2.3 æ ‘å½¢æ•°æ®ç»“æ„

#### 2.3.1 äºŒå‰æ ‘

```python
@dataclass
class TreeNode(Generic[T]):
    """äºŒå‰æ ‘èŠ‚ç‚¹"""
    data: T
    left: Optional['TreeNode[T]'] = None
    right: Optional['TreeNode[T]'] = None

class BinaryTree(DataStructure[T]):
    """äºŒå‰æ ‘æ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("BinaryTree", DataStructureType.TREE)
        self.root: Optional[TreeNode[T]] = None
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        def _insert():
            if self.root is None:
                self.root = TreeNode(item)
            else:
                self._insert_recursive(self.root, item)
            self.size += 1
            return True
        
        return self.measure_operation("insert", _insert)
    
    def _insert_recursive(self, node: TreeNode[T], item: T) -> None:
        """é€’å½’æ’å…¥"""
        if item < node.data:
            if node.left is None:
                node.left = TreeNode(item)
            else:
                self._insert_recursive(node.left, item)
        else:
            if node.right is None:
                node.right = TreeNode(item)
            else:
                self._insert_recursive(node.right, item)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            self.root = self._delete_recursive(self.root, item)
            return True
        
        return self.measure_operation("delete", _delete)
    
    def _delete_recursive(self, node: Optional[TreeNode[T]], item: T) -> Optional[TreeNode[T]]:
        """é€’å½’åˆ é™¤"""
        if node is None:
            return None
        
        if item < node.data:
            node.left = self._delete_recursive(node.left, item)
        elif item > node.data:
            node.right = self._delete_recursive(node.right, item)
        else:
            # æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                # æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæ‰¾åˆ°å³å­æ ‘çš„æœ€å°å€¼
                min_node = self._find_min(node.right)
                node.data = min_node.data
                node.right = self._delete_recursive(node.right, min_node.data)
        
        return node
    
    def _find_min(self, node: TreeNode[T]) -> TreeNode[T]:
        """æ‰¾åˆ°æœ€å°å€¼èŠ‚ç‚¹"""
        while node.left:
            node = node.left
        return node
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            return self._search_recursive(self.root, item)
        
        return self.measure_operation("search", _search)
    
    def _search_recursive(self, node: Optional[TreeNode[T]], item: T) -> Optional[T]:
        """é€’å½’æœç´¢"""
        if node is None or node.data == item:
            return node.data if node else None
        
        if item < node.data:
            return self._search_recursive(node.left, item)
        else:
            return self._search_recursive(node.right, item)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.root is None
    
    def clear(self) -> None:
        """æ¸…ç©ºæ ‘"""
        self.root = None
        self.size = 0
    
    def inorder_traversal(self) -> list[T]:
        """ä¸­åºéå†"""
        def _inorder(node: Optional[TreeNode[T]], result: list[T]) -> None:
            if node:
                _inorder(node.left, result)
                result.append(node.data)
                _inorder(node.right, result)
        
        result = []
        _inorder(self.root, result)
        return result
    
    def preorder_traversal(self) -> list[T]:
        """å‰åºéå†"""
        def _preorder(node: Optional[TreeNode[T]], result: list[T]) -> None:
            if node:
                result.append(node.data)
                _preorder(node.left, result)
                _preorder(node.right, result)
        
        result = []
        _preorder(self.root, result)
        return result
    
    def postorder_traversal(self) -> list[T]:
        """ååºéå†"""
        def _postorder(node: Optional[TreeNode[T]], result: list[T]) -> None:
            if node:
                _postorder(node.left, result)
                _postorder(node.right, result)
                result.append(node.data)
        
        result = []
        _postorder(self.root, result)
        return result
    
    def get_height(self) -> int:
        """è·å–æ ‘çš„é«˜åº¦"""
        def _height(node: Optional[TreeNode[T]]) -> int:
            if node is None:
                return 0
            return 1 + max(_height(node.left), _height(node.right))
        
        return _height(self.root)
    
    def __iter__(self) -> Iterator[T]:
        for item in self.inorder_traversal():
            yield item
```

## 3. ç†è®ºè¯æ˜

### 3.1 æ•°ç»„æ“ä½œå¤æ‚åº¦

**å®šç† 1.1** (æ•°ç»„æ“ä½œå¤æ‚åº¦)
å¯¹äºåŠ¨æ€æ•°ç»„ï¼š
- æ’å…¥æ“ä½œï¼šå¹³å‡ $O(1)$ï¼Œæœ€å $O(n)$
- åˆ é™¤æ“ä½œï¼šå¹³å‡ $O(n)$ï¼Œæœ€å $O(n)$
- æœç´¢æ“ä½œï¼š$O(n)$

**è¯æ˜**:
1. **æ’å…¥**: å¹³å‡æƒ…å†µä¸‹åœ¨æœ«å°¾æ’å…¥ä¸º $O(1)$ï¼Œä½†éœ€è¦æ‰©å®¹æ—¶ä¸º $O(n)$
2. **åˆ é™¤**: éœ€è¦ç§»åŠ¨å…ƒç´ ï¼Œå¹³å‡å’Œæœ€åéƒ½æ˜¯ $O(n)$
3. **æœç´¢**: éœ€è¦éå†æ•°ç»„ï¼Œæ€»æ˜¯ $O(n)$

### 3.2 é“¾è¡¨æ“ä½œå¤æ‚åº¦

**å®šç† 1.2** (é“¾è¡¨æ“ä½œå¤æ‚åº¦)
å¯¹äºé“¾è¡¨ï¼š
- æ’å…¥æ“ä½œï¼š$O(1)$ï¼ˆå·²çŸ¥ä½ç½®ï¼‰
- åˆ é™¤æ“ä½œï¼š$O(1)$ï¼ˆå·²çŸ¥ä½ç½®ï¼‰
- æœç´¢æ“ä½œï¼š$O(n)$

**è¯æ˜**:
1. **æ’å…¥/åˆ é™¤**: åœ¨å·²çŸ¥ä½ç½®æ“ä½œåªéœ€è¦ä¿®æ”¹æŒ‡é’ˆï¼Œ$O(1)$
2. **æœç´¢**: éœ€è¦éå†é“¾è¡¨ï¼Œ$O(n)$

### 3.3 æ ˆå’Œé˜Ÿåˆ—æ“ä½œå¤æ‚åº¦

**å®šç† 1.3** (æ ˆå’Œé˜Ÿåˆ—æ“ä½œå¤æ‚åº¦)
å¯¹äºæ ˆå’Œé˜Ÿåˆ—ï¼š
- å‹å…¥/å…¥é˜Ÿï¼š$O(1)$
- å¼¹å‡º/å‡ºé˜Ÿï¼š$O(1)$
- æŸ¥çœ‹ï¼š$O(1)$

**è¯æ˜**:
æ ˆå’Œé˜Ÿåˆ—çš„æ“ä½œéƒ½åªæ¶‰åŠä¸€ç«¯ï¼Œä¸éœ€è¦éå†ï¼Œå› æ­¤éƒ½æ˜¯ $O(1)$ã€‚

### 3.4 äºŒå‰æ ‘æ“ä½œå¤æ‚åº¦

**å®šç† 1.4** (äºŒå‰æ ‘æ“ä½œå¤æ‚åº¦)
å¯¹äºå¹³è¡¡äºŒå‰æ ‘ï¼š
- æ’å…¥æ“ä½œï¼š$O(\log n)$
- åˆ é™¤æ“ä½œï¼š$O(\log n)$
- æœç´¢æ“ä½œï¼š$O(\log n)$

**è¯æ˜**:
åœ¨å¹³è¡¡äºŒå‰æ ‘ä¸­ï¼Œæ¯æ¬¡æ“ä½œéƒ½å°†æœç´¢ç©ºé—´å‡åŠï¼Œå› æ­¤å¤æ‚åº¦ä¸º $O(\log n)$ã€‚

## 4. æ€§èƒ½æµ‹è¯•

```python
def test_data_structures():
    """æµ‹è¯•æ•°æ®ç»“æ„æ€§èƒ½"""
    
    # åˆ›å»ºæµ‹è¯•æ•°æ®
    test_data = list(range(1000))
    
    # æµ‹è¯•çš„æ•°æ®ç»“æ„
    structures = [
        Array(),
        LinkedList(),
        Stack(),
        Queue(),
        BinaryTree()
    ]
    
    print("æ•°æ®ç»“æ„æ€§èƒ½æµ‹è¯•")
    print("=" * 60)
    
    for structure in structures:
        print(f"\n{structure.name}:")
        print("-" * 30)
        
        # æµ‹è¯•æ’å…¥æ€§èƒ½
        start_time = time.time()
        for item in test_data:
            structure.insert(item)
        insert_time = time.time() - start_time
        
        # æµ‹è¯•æœç´¢æ€§èƒ½
        start_time = time.time()
        for item in test_data[:100]:  # åªæµ‹è¯•å‰100ä¸ª
            structure.search(item)
        search_time = time.time() - start_time
        
        # æµ‹è¯•åˆ é™¤æ€§èƒ½
        start_time = time.time()
        for item in test_data[:100]:  # åªæµ‹è¯•å‰100ä¸ª
            structure.delete(item)
        delete_time = time.time() - start_time
        
        print(f"æ’å…¥æ—¶é—´: {insert_time:.6f}s")
        print(f"æœç´¢æ—¶é—´: {search_time:.6f}s")
        print(f"åˆ é™¤æ—¶é—´: {delete_time:.6f}s")
        print(f"æœ€ç»ˆå¤§å°: {structure.get_size()}")
        
        # æ˜¾ç¤ºæ€§èƒ½ç»Ÿè®¡
        stats = structure.get_performance_stats()
        if stats:
            print("æ“ä½œç»Ÿè®¡:")
            for op, metrics in stats.items():
                print(f"  {op}: å¹³å‡æ—¶é—´={metrics['avg_time']:.6f}s, "
                      f"æˆåŠŸç‡={metrics['success_rate']:.2%}")

def compare_linear_structures():
    """æ¯”è¾ƒçº¿æ€§æ•°æ®ç»“æ„"""
    
    test_data = list(range(1000))
    
    print("\nçº¿æ€§æ•°æ®ç»“æ„æ¯”è¾ƒ")
    print("=" * 40)
    
    structures = [
        ("Array", Array()),
        ("LinkedList", LinkedList()),
        ("Stack", Stack()),
        ("Queue", Queue())
    ]
    
    for name, structure in structures:
        print(f"\n{name}:")
        
        # æ’å…¥æµ‹è¯•
        start_time = time.time()
        for item in test_data:
            structure.insert(item)
        insert_time = time.time() - start_time
        
        # æœç´¢æµ‹è¯•
        start_time = time.time()
        for item in test_data[:100]:
            structure.search(item)
        search_time = time.time() - start_time
        
        print(f"  æ’å…¥: {insert_time:.6f}s")
        print(f"  æœç´¢: {search_time:.6f}s")

if __name__ == "__main__":
    test_data_structures()
    compare_linear_structures()
```

## 5. æ€»ç»“

æœ¬æ–‡æ¡£å»ºç«‹äº†æ•°æ®ç»“æ„çš„åŸºç¡€ç†è®ºæ¡†æ¶ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†æ•°æ®ç»“æ„çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **Pythonå®ç°**: å®Œæ•´çš„æ•°æ®ç»“æ„å®ç°
3. **ç†è®ºè¯æ˜**: æ•°æ®ç»“æ„æ“ä½œçš„å¤æ‚åº¦è¯æ˜
4. **æ€§èƒ½åˆ†æ**: ä¸åŒæ•°æ®ç»“æ„çš„æ€§èƒ½æ¯”è¾ƒ

### æ•°æ®ç»“æ„ç‰¹æ€§æ€»ç»“

| æ•°æ®ç»“æ„ | æ’å…¥ | åˆ é™¤ | æœç´¢ | ç©ºé—´å¤æ‚åº¦ | ç‰¹ç‚¹ |
|----------|------|------|------|------------|------|
| æ•°ç»„ | O(1) | O(n) | O(n) | O(n) | éšæœºè®¿é—®å¿« |
| é“¾è¡¨ | O(1) | O(1) | O(n) | O(n) | æ’å…¥åˆ é™¤å¿« |
| æ ˆ | O(1) | O(1) | O(n) | O(n) | LIFO |
| é˜Ÿåˆ— | O(1) | O(1) | O(n) | O(n) | FIFO |
| äºŒå‰æ ‘ | O(log n) | O(log n) | O(log n) | O(n) | æœ‰åºå­˜å‚¨ |

---

*ä¸‹ä¸€èŠ‚ï¼š[02-02-02 é«˜çº§æ•°æ®ç»“æ„](./02-02-02-é«˜çº§æ•°æ®ç»“æ„.md)* 