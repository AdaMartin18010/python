# 02-02-02 é«˜çº§æ•°æ®ç»“æ„

## ğŸ“‹ æ¦‚è¿°

é«˜çº§æ•°æ®ç»“æ„æ˜¯åœ¨åŸºç¡€æ•°æ®ç»“æ„åŸºç¡€ä¸Šå‘å±•å‡ºæ¥çš„æ›´å¤æ‚ã€æ›´é«˜æ•ˆçš„æ•°æ®ç»„ç»‡æ–¹å¼ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰å„ç§é«˜çº§æ•°æ®ç»“æ„ï¼Œåˆ†æå…¶ç†è®ºæ€§è´¨ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 å¹³è¡¡æ ‘å®šä¹‰

**å®šä¹‰ 1.1** (å¹³è¡¡æ ‘)
å¹³è¡¡æ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ï¼Œæ»¡è¶³ï¼š
$$\forall v \in V: |h(left(v)) - h(right(v))| \leq 1$$
å…¶ä¸­ $h(v)$ è¡¨ç¤ºä»¥ $v$ ä¸ºæ ¹çš„å­æ ‘é«˜åº¦ã€‚

**å®šä¹‰ 1.2** (AVLæ ‘)
AVLæ ‘æ˜¯ä¸€ç§å¹³è¡¡æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­å®šä¹‰ä¸ºï¼š
$$bf(v) = h(right(v)) - h(left(v))$$
æ»¡è¶³ï¼š$\forall v \in V: |bf(v)| \leq 1$

**å®šä¹‰ 1.3** (çº¢é»‘æ ‘)
çº¢é»‘æ ‘æ˜¯ä¸€ç§å¹³è¡¡æ ‘ï¼Œæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

1. æ¯ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²
2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²
3. çº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²
4. ä»æ ¹åˆ°å¶å­çš„æ‰€æœ‰è·¯å¾„åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹

### 1.2 å †å®šä¹‰

**å®šä¹‰ 1.4** (å †)
å †æ˜¯ä¸€ç§å®Œå…¨äºŒå‰æ ‘ï¼Œæ»¡è¶³å †æ€§è´¨ï¼š
$$\forall v \in V: v \geq parent(v) \text{ (æœ€å¤§å †)}$$
æˆ–
$$\forall v \in V: v \leq parent(v) \text{ (æœ€å°å †)}$$

**å®šä¹‰ 1.5** (ä¼˜å…ˆé˜Ÿåˆ—)
ä¼˜å…ˆé˜Ÿåˆ—æ˜¯ä¸€ä¸ªæŠ½è±¡æ•°æ®ç±»å‹ï¼Œæ”¯æŒï¼š

- $insert(x)$: æ’å…¥å…ƒç´  $x$
- $extract\_max()$: æå–æœ€å¤§å…ƒç´ 
- $peek()$: æŸ¥çœ‹æœ€å¤§å…ƒç´ 

### 1.3 å“ˆå¸Œè¡¨å®šä¹‰

**å®šä¹‰ 1.6** (å“ˆå¸Œè¡¨)
å“ˆå¸Œè¡¨æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$H: K \rightarrow V$$
å…¶ä¸­ $K$ ä¸ºé”®é›†åˆï¼Œ$V$ ä¸ºå€¼é›†åˆã€‚

**å®šä¹‰ 1.7** (å“ˆå¸Œå‡½æ•°)
å“ˆå¸Œå‡½æ•° $h: U \rightarrow \{0, 1, ..., m-1\}$ å°†é”®æ˜ å°„åˆ°æ§½ä½ã€‚

**å®šä¹‰ 1.8** (è´Ÿè½½å› å­)
è´Ÿè½½å› å­å®šä¹‰ä¸ºï¼š
$$\alpha = \frac{n}{m}$$
å…¶ä¸­ $n$ ä¸ºå…ƒç´ æ•°é‡ï¼Œ$m$ ä¸ºæ§½ä½æ•°é‡ã€‚

## 2. Pythonå®ç°

### 2.1 AVLæ ‘

```python
from enum import Enum
from typing import Optional, TypeVar, Generic

T = TypeVar('T')

class Color(Enum):
    """èŠ‚ç‚¹é¢œè‰²"""
    RED = "red"
    BLACK = "black"

@dataclass
class AVLNode(Generic[T]):
    """AVLæ ‘èŠ‚ç‚¹"""
    data: T
    left: Optional['AVLNode[T]'] = None
    right: Optional['AVLNode[T]'] = None
    height: int = 1

class AVLTree(DataStructure[T]):
    """AVLå¹³è¡¡æ ‘"""
    
    def __init__(self):
        super().__init__("AVL Tree", DataStructureType.TREE)
        self.root: Optional[AVLNode[T]] = None
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        def _insert():
            self.root = self._insert_recursive(self.root, item)
            return True
        
        return self.measure_operation("insert", _insert)
    
    def _insert_recursive(self, node: Optional[AVLNode[T]], item: T) -> AVLNode[T]:
        """é€’å½’æ’å…¥"""
        if node is None:
            return AVLNode(item)
        
        if item < node.data:
            node.left = self._insert_recursive(node.left, item)
        elif item > node.data:
            node.right = self._insert_recursive(node.right, item)
        else:
            return node  # é‡å¤å…ƒç´ 
        
        # æ›´æ–°é«˜åº¦
        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))
        
        # è·å–å¹³è¡¡å› å­
        balance = self._get_balance(node)
        
        # å·¦å·¦æƒ…å†µ
        if balance > 1 and item < node.left.data:
            return self._right_rotate(node)
        
        # å³å³æƒ…å†µ
        if balance < -1 and item > node.right.data:
            return self._left_rotate(node)
        
        # å·¦å³æƒ…å†µ
        if balance > 1 and item > node.left.data:
            node.left = self._left_rotate(node.left)
            return self._right_rotate(node)
        
        # å³å·¦æƒ…å†µ
        if balance < -1 and item < node.right.data:
            node.right = self._right_rotate(node.right)
            return self._left_rotate(node)
        
        return node
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            self.root = self._delete_recursive(self.root, item)
            return True
        
        return self.measure_operation("delete", _delete)
    
    def _delete_recursive(self, node: Optional[AVLNode[T]], item: T) -> Optional[AVLNode[T]]:
        """é€’å½’åˆ é™¤"""
        if node is None:
            return None
        
        if item < node.data:
            node.left = self._delete_recursive(node.left, item)
        elif item > node.data:
            node.right = self._delete_recursive(node.right, item)
        else:
            # æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                # æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
                successor = self._find_min(node.right)
                node.data = successor.data
                node.right = self._delete_recursive(node.right, successor.data)
        
        if node is None:
            return None
        
        # æ›´æ–°é«˜åº¦
        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))
        
        # è·å–å¹³è¡¡å› å­
        balance = self._get_balance(node)
        
        # å·¦å·¦æƒ…å†µ
        if balance > 1 and self._get_balance(node.left) >= 0:
            return self._right_rotate(node)
        
        # å·¦å³æƒ…å†µ
        if balance > 1 and self._get_balance(node.left) < 0:
            node.left = self._left_rotate(node.left)
            return self._right_rotate(node)
        
        # å³å³æƒ…å†µ
        if balance < -1 and self._get_balance(node.right) <= 0:
            return self._left_rotate(node)
        
        # å³å·¦æƒ…å†µ
        if balance < -1 and self._get_balance(node.right) > 0:
            node.right = self._right_rotate(node.right)
            return self._left_rotate(node)
        
        return node
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            return self._search_recursive(self.root, item)
        
        return self.measure_operation("search", _search)
    
    def _search_recursive(self, node: Optional[AVLNode[T]], item: T) -> Optional[T]:
        """é€’å½’æœç´¢"""
        if node is None or node.data == item:
            return node.data if node else None
        
        if item < node.data:
            return self._search_recursive(node.left, item)
        else:
            return self._search_recursive(node.right, item)
    
    def _get_height(self, node: Optional[AVLNode[T]]) -> int:
        """è·å–èŠ‚ç‚¹é«˜åº¦"""
        return node.height if node else 0
    
    def _get_balance(self, node: Optional[AVLNode[T]]) -> int:
        """è·å–å¹³è¡¡å› å­"""
        if node is None:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)
    
    def _left_rotate(self, node: AVLNode[T]) -> AVLNode[T]:
        """å·¦æ—‹"""
        right_child = node.right
        left_grandchild = right_child.left
        
        right_child.left = node
        node.right = left_grandchild
        
        # æ›´æ–°é«˜åº¦
        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))
        right_child.height = 1 + max(self._get_height(right_child.left), self._get_height(right_child.right))
        
        return right_child
    
    def _right_rotate(self, node: AVLNode[T]) -> AVLNode[T]:
        """å³æ—‹"""
        left_child = node.left
        right_grandchild = left_child.right
        
        left_child.right = node
        node.left = right_grandchild
        
        # æ›´æ–°é«˜åº¦
        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))
        left_child.height = 1 + max(self._get_height(left_child.left), self._get_height(left_child.right))
        
        return left_child
    
    def _find_min(self, node: AVLNode[T]) -> AVLNode[T]:
        """æ‰¾åˆ°æœ€å°å€¼èŠ‚ç‚¹"""
        while node.left:
            node = node.left
        return node
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.root is None
    
    def clear(self) -> None:
        """æ¸…ç©ºæ ‘"""
        self.root = None
        self.size = 0
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n) - å¹³è¡¡æ ‘"
    
    def _analyze_space_complexity(self) -> str:
        return "O(n) - èŠ‚ç‚¹å­˜å‚¨"
    
    def _analyze_best_case(self) -> str:
        return "O(log n) - å¹³è¡¡æƒ…å†µ"
    
    def _analyze_worst_case(self) -> str:
        return "O(log n) - æ€»æ˜¯å¹³è¡¡"
    
    def _analyze_average_case(self) -> str:
        return "O(log n) - å¹³å‡æƒ…å†µ"
```

### 2.2 çº¢é»‘æ ‘

```python
@dataclass
class RedBlackNode(Generic[T]):
    """çº¢é»‘æ ‘èŠ‚ç‚¹"""
    data: T
    left: Optional['RedBlackNode[T]'] = None
    right: Optional['RedBlackNode[T]'] = None
    parent: Optional['RedBlackNode[T]'] = None
    color: Color = Color.RED

class RedBlackTree(DataStructure[T]):
    """çº¢é»‘æ ‘"""
    
    def __init__(self):
        super().__init__("Red-Black Tree", DataStructureType.TREE)
        self.root: Optional[RedBlackNode[T]] = None
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        def _insert():
            node = RedBlackNode(item)
            self._insert_node(node)
            self._fix_insert(node)
            return True
        
        return self.measure_operation("insert", _insert)
    
    def _insert_node(self, node: RedBlackNode[T]) -> None:
        """æ’å…¥èŠ‚ç‚¹"""
        if self.root is None:
            self.root = node
            node.color = Color.BLACK
            return
        
        current = self.root
        parent = None
        
        while current:
            parent = current
            if node.data < current.data:
                current = current.left
            else:
                current = current.right
        
        node.parent = parent
        if node.data < parent.data:
            parent.left = node
        else:
            parent.right = node
    
    def _fix_insert(self, node: RedBlackNode[T]) -> None:
        """ä¿®å¤æ’å…¥åçš„çº¢é»‘æ ‘æ€§è´¨"""
        while node != self.root and node.parent.color == Color.RED:
            if node.parent == node.parent.parent.left:
                uncle = node.parent.parent.right
                if uncle and uncle.color == Color.RED:
                    node.parent.color = Color.BLACK
                    uncle.color = Color.BLACK
                    node.parent.parent.color = Color.RED
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        node = node.parent
                        self._left_rotate(node)
                    node.parent.color = Color.BLACK
                    node.parent.parent.color = Color.RED
                    self._right_rotate(node.parent.parent)
            else:
                uncle = node.parent.parent.left
                if uncle and uncle.color == Color.RED:
                    node.parent.color = Color.BLACK
                    uncle.color = Color.BLACK
                    node.parent.parent.color = Color.RED
                    node = node.parent.parent
                else:
                    if node == node.parent.left:
                        node = node.parent
                        self._right_rotate(node)
                    node.parent.color = Color.BLACK
                    node.parent.parent.color = Color.RED
                    self._left_rotate(node.parent.parent)
        
        self.root.color = Color.BLACK
    
    def _left_rotate(self, node: RedBlackNode[T]) -> None:
        """å·¦æ—‹"""
        right_child = node.right
        node.right = right_child.left
        
        if right_child.left:
            right_child.left.parent = node
        
        right_child.parent = node.parent
        
        if node.parent is None:
            self.root = right_child
        elif node == node.parent.left:
            node.parent.left = right_child
        else:
            node.parent.right = right_child
        
        right_child.left = node
        node.parent = right_child
    
    def _right_rotate(self, node: RedBlackNode[T]) -> None:
        """å³æ—‹"""
        left_child = node.left
        node.left = left_child.right
        
        if left_child.right:
            left_child.right.parent = node
        
        left_child.parent = node.parent
        
        if node.parent is None:
            self.root = left_child
        elif node == node.parent.right:
            node.parent.right = left_child
        else:
            node.parent.left = left_child
        
        left_child.right = node
        node.parent = left_child
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            node = self._find_node(item)
            if node:
                self._delete_node(node)
                return True
            return False
        
        return self.measure_operation("delete", _delete)
    
    def _find_node(self, item: T) -> Optional[RedBlackNode[T]]:
        """æŸ¥æ‰¾èŠ‚ç‚¹"""
        current = self.root
        while current:
            if item == current.data:
                return current
            elif item < current.data:
                current = current.left
            else:
                current = current.right
        return None
    
    def _delete_node(self, node: RedBlackNode[T]) -> None:
        """åˆ é™¤èŠ‚ç‚¹"""
        # å®ç°åˆ é™¤é€»è¾‘ï¼ˆç®€åŒ–ç‰ˆï¼‰
        pass
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            node = self._find_node(item)
            return node.data if node else None
        
        return self.measure_operation("search", _search)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.root is None
    
    def clear(self) -> None:
        """æ¸…ç©ºæ ‘"""
        self.root = None
        self.size = 0
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n) - çº¢é»‘æ ‘"
    
    def _analyze_space_complexity(self) -> str:
        return "O(n) - èŠ‚ç‚¹å­˜å‚¨"
    
    def _analyze_best_case(self) -> str:
        return "O(log n) - å¹³è¡¡æƒ…å†µ"
    
    def _analyze_worst_case(self) -> str:
        return "O(log n) - æ€»æ˜¯å¹³è¡¡"
    
    def _analyze_average_case(self) -> str:
        return "O(log n) - å¹³å‡æƒ…å†µ"
```

### 2.3 å †å’Œä¼˜å…ˆé˜Ÿåˆ—

```python
@dataclass
class HeapNode(Generic[T]):
    """å †èŠ‚ç‚¹"""
    data: T
    priority: float

class MinHeap(DataStructure[HeapNode[T]]):
    """æœ€å°å †"""
    
    def __init__(self):
        super().__init__("Min Heap", DataStructureType.HEAP)
        self.heap: List[HeapNode[T]] = []
    
    def insert(self, item: HeapNode[T]) -> bool:
        """æ’å…¥å…ƒç´ """
        def _insert():
            self.heap.append(item)
            self._heapify_up(len(self.heap) - 1)
            return True
        
        return self.measure_operation("insert", _insert)
    
    def extract_min(self) -> Optional[HeapNode[T]]:
        """æå–æœ€å°å…ƒç´ """
        def _extract():
            if not self.heap:
                return None
            
            min_element = self.heap[0]
            self.heap[0] = self.heap[-1]
            self.heap.pop()
            
            if self.heap:
                self._heapify_down(0)
            
            return min_element
        
        return self.measure_operation("extract_min", _extract)
    
    def peek(self) -> Optional[HeapNode[T]]:
        """æŸ¥çœ‹æœ€å°å…ƒç´ """
        def _peek():
            return self.heap[0] if self.heap else None
        
        return self.measure_operation("peek", _peek)
    
    def _heapify_up(self, index: int) -> None:
        """å‘ä¸Šè°ƒæ•´"""
        parent = (index - 1) // 2
        if parent >= 0 and self.heap[index].priority < self.heap[parent].priority:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)
    
    def _heapify_down(self, index: int) -> None:
        """å‘ä¸‹è°ƒæ•´"""
        left_child = 2 * index + 1
        right_child = 2 * index + 2
        smallest = index
        
        if left_child < len(self.heap) and self.heap[left_child].priority < self.heap[smallest].priority:
            smallest = left_child
        
        if right_child < len(self.heap) and self.heap[right_child].priority < self.heap[smallest].priority:
            smallest = right_child
        
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._heapify_down(smallest)
    
    def delete(self, item: HeapNode[T]) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            for i, node in enumerate(self.heap):
                if node.data == item.data:
                    self.heap[i] = self.heap[-1]
                    self.heap.pop()
                    if i < len(self.heap):
                        self._heapify_down(i)
                    return True
            return False
        
        return self.measure_operation("delete", _delete)
    
    def search(self, item: HeapNode[T]) -> Optional[HeapNode[T]]:
        """æœç´¢å…ƒç´ """
        def _search():
            for node in self.heap:
                if node.data == item.data:
                    return node
            return None
        
        return self.measure_operation("search", _search)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return len(self.heap) == 0
    
    def clear(self) -> None:
        """æ¸…ç©ºå †"""
        self.heap.clear()
        self.size = 0
    
    def get_size(self) -> int:
        """è·å–å¤§å°"""
        return len(self.heap)
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n) - å †æ“ä½œ"
    
    def _analyze_space_complexity(self) -> str:
        return "O(n) - æ•°ç»„å­˜å‚¨"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - æ’å…¥åˆ°æ ¹"
    
    def _analyze_worst_case(self) -> str:
        return "O(log n) - éœ€è¦è°ƒæ•´åˆ°å¶å­"
    
    def _analyze_average_case(self) -> str:
        return "O(log n) - å¹³å‡æƒ…å†µ"
```

### 2.4 å“ˆå¸Œè¡¨

```python
class HashTable(DataStructure[T]):
    """å“ˆå¸Œè¡¨"""
    
    def __init__(self, initial_capacity: int = 16, load_factor: float = 0.75):
        super().__init__("Hash Table", DataStructureType.HASH)
        self.capacity = initial_capacity
        self.load_factor = load_factor
        self.buckets: List[List[Tuple[str, T]]] = [[] for _ in range(initial_capacity)]
        self.size = 0
    
    def _hash(self, key: str) -> int:
        """å“ˆå¸Œå‡½æ•°"""
        hash_value = 0
        for char in key:
            hash_value = (hash_value * 31 + ord(char)) % self.capacity
        return hash_value
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        def _insert():
            key = str(item)
            hash_value = self._hash(key)
            
            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            for i, (existing_key, _) in enumerate(self.buckets[hash_value]):
                if existing_key == key:
                    self.buckets[hash_value][i] = (key, item)
                    return True
            
            # æ’å…¥æ–°å…ƒç´ 
            self.buckets[hash_value].append((key, item))
            self.size += 1
            
            # æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
            if self.size / self.capacity > self.load_factor:
                self._resize()
            
            return True
        
        return self.measure_operation("insert", _insert)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            key = str(item)
            hash_value = self._hash(key)
            
            for i, (existing_key, _) in enumerate(self.buckets[hash_value]):
                if existing_key == key:
                    del self.buckets[hash_value][i]
                    self.size -= 1
                    return True
            
            return False
        
        return self.measure_operation("delete", _delete)
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            key = str(item)
            hash_value = self._hash(key)
            
            for existing_key, value in self.buckets[hash_value]:
                if existing_key == key:
                    return value
            
            return None
        
        return self.measure_operation("search", _search)
    
    def _resize(self) -> None:
        """æ‰©å®¹"""
        old_buckets = self.buckets
        self.capacity *= 2
        self.buckets = [[] for _ in range(self.capacity)]
        self.size = 0
        
        for bucket in old_buckets:
            for key, value in bucket:
                self.insert(value)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.size == 0
    
    def clear(self) -> None:
        """æ¸…ç©ºå“ˆå¸Œè¡¨"""
        self.buckets = [[] for _ in range(self.capacity)]
        self.size = 0
    
    def get_load_factor(self) -> float:
        """è·å–è´Ÿè½½å› å­"""
        return self.size / self.capacity
    
    def _analyze_time_complexity(self) -> str:
        return "O(1) å¹³å‡ï¼ŒO(n) æœ€å"
    
    def _analyze_space_complexity(self) -> str:
        return "O(n) - æ¡¶æ•°ç»„"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - æ— å†²çª"
    
    def _analyze_worst_case(self) -> str:
        return "O(n) - æ‰€æœ‰å…ƒç´ å†²çª"
    
    def _analyze_average_case(self) -> str:
        return "O(1) - å¹³å‡æƒ…å†µ"
```

### 2.5 è·³è¡¨

```python
@dataclass
class SkipListNode(Generic[T]):
    """è·³è¡¨èŠ‚ç‚¹"""
    data: T
    next_nodes: List[Optional['SkipListNode[T]']]
    level: int

class SkipList(DataStructure[T]):
    """è·³è¡¨"""
    
    def __init__(self, max_level: int = 16):
        super().__init__("Skip List", DataStructureType.LINEAR)
        self.max_level = max_level
        self.head = SkipListNode(None, [None] * max_level, max_level)
        self.level = 0
    
    def _random_level(self) -> int:
        """éšæœºç”Ÿæˆå±‚æ•°"""
        level = 1
        while level < self.max_level and random.random() < 0.5:
            level += 1
        return level
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        def _insert():
            update = [None] * self.max_level
            current = self.head
            
            # æ‰¾åˆ°æ’å…¥ä½ç½®
            for i in range(self.level - 1, -1, -1):
                while (current.next_nodes[i] and 
                       current.next_nodes[i].data < item):
                    current = current.next_nodes[i]
                update[i] = current
            
            # ç”Ÿæˆéšæœºå±‚æ•°
            new_level = self._random_level()
            if new_level > self.level:
                for i in range(self.level, new_level):
                    update[i] = self.head
                self.level = new_level
            
            # åˆ›å»ºæ–°èŠ‚ç‚¹
            new_node = SkipListNode(item, [None] * new_level, new_level)
            
            # æ›´æ–°æŒ‡é’ˆ
            for i in range(new_level):
                new_node.next_nodes[i] = update[i].next_nodes[i]
                update[i].next_nodes[i] = new_node
            
            self.size += 1
            return True
        
        return self.measure_operation("insert", _insert)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            update = [None] * self.max_level
            current = self.head
            
            # æ‰¾åˆ°åˆ é™¤ä½ç½®
            for i in range(self.level - 1, -1, -1):
                while (current.next_nodes[i] and 
                       current.next_nodes[i].data < item):
                    current = current.next_nodes[i]
                update[i] = current
            
            # æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°å…ƒç´ 
            if (not current.next_nodes[0] or 
                current.next_nodes[0].data != item):
                return False
            
            # åˆ é™¤èŠ‚ç‚¹
            node_to_delete = current.next_nodes[0]
            for i in range(self.level):
                if update[i].next_nodes[i] != node_to_delete:
                    break
                update[i].next_nodes[i] = node_to_delete.next_nodes[i]
            
            # æ›´æ–°å±‚æ•°
            while (self.level > 0 and 
                   self.head.next_nodes[self.level - 1] is None):
                self.level -= 1
            
            self.size -= 1
            return True
        
        return self.measure_operation("delete", _delete)
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        def _search():
            current = self.head
            
            # ä»æœ€é«˜å±‚å¼€å§‹æœç´¢
            for i in range(self.level - 1, -1, -1):
                while (current.next_nodes[i] and 
                       current.next_nodes[i].data < item):
                    current = current.next_nodes[i]
            
            # æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°
            if (current.next_nodes[0] and 
                current.next_nodes[0].data == item):
                return current.next_nodes[0].data
            
            return None
        
        return self.measure_operation("search", _search)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.size == 0
    
    def clear(self) -> None:
        """æ¸…ç©ºè·³è¡¨"""
        self.head = SkipListNode(None, [None] * self.max_level, self.max_level)
        self.level = 0
        self.size = 0
    
    def _analyze_time_complexity(self) -> str:
        return "O(log n) å¹³å‡"
    
    def _analyze_space_complexity(self) -> str:
        return "O(n) - èŠ‚ç‚¹å­˜å‚¨"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - åœ¨æœ€é«˜å±‚æ‰¾åˆ°"
    
    def _analyze_worst_case(self) -> str:
        return "O(n) - éœ€è¦éå†æ‰€æœ‰å±‚"
    
    def _analyze_average_case(self) -> str:
        return "O(log n) - å¹³å‡æƒ…å†µ"
```

### 2.6 å¹¶æŸ¥é›†

```python
class UnionFind(DataStructure[T]):
    """å¹¶æŸ¥é›†"""
    
    def __init__(self):
        super().__init__("Union-Find", DataStructureType.LINEAR)
        self.parent: Dict[T, T] = {}
        self.rank: Dict[T, int] = {}
    
    def make_set(self, item: T) -> bool:
        """åˆ›å»ºé›†åˆ"""
        def _make_set():
            if item not in self.parent:
                self.parent[item] = item
                self.rank[item] = 0
                self.size += 1
                return True
            return False
        
        return self.measure_operation("make_set", _make_set)
    
    def find(self, item: T) -> Optional[T]:
        """æŸ¥æ‰¾æ ¹èŠ‚ç‚¹"""
        def _find():
            if item not in self.parent:
                return None
            
            # è·¯å¾„å‹ç¼©
            if self.parent[item] != item:
                self.parent[item] = self.find(self.parent[item])
            
            return self.parent[item]
        
        return self.measure_operation("find", _find)
    
    def union(self, x: T, y: T) -> bool:
        """åˆå¹¶é›†åˆ"""
        def _union():
            root_x = self.find(x)
            root_y = self.find(y)
            
            if root_x is None or root_y is None:
                return False
            
            if root_x == root_y:
                return True  # å·²ç»åœ¨åŒä¸€é›†åˆ
            
            # æŒ‰ç§©åˆå¹¶
            if self.rank[root_x] < self.rank[root_y]:
                root_x, root_y = root_y, root_x
            
            self.parent[root_y] = root_x
            
            if self.rank[root_x] == self.rank[root_y]:
                self.rank[root_x] += 1
            
            return True
        
        return self.measure_operation("union", _union)
    
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ ï¼ˆåˆ›å»ºé›†åˆï¼‰"""
        return self.make_set(item)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        def _delete():
            if item in self.parent:
                # åˆ é™¤å…ƒç´ ï¼ˆç®€åŒ–å®ç°ï¼‰
                del self.parent[item]
                del self.rank[item]
                self.size -= 1
                return True
            return False
        
        return self.measure_operation("delete", _delete)
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ ï¼ˆæŸ¥æ‰¾æ ¹èŠ‚ç‚¹ï¼‰"""
        return self.find(item)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return self.size == 0
    
    def clear(self) -> None:
        """æ¸…ç©ºå¹¶æŸ¥é›†"""
        self.parent.clear()
        self.rank.clear()
        self.size = 0
    
    def get_set_count(self) -> int:
        """è·å–é›†åˆæ•°é‡"""
        roots = set()
        for item in self.parent:
            root = self.find(item)
            if root:
                roots.add(root)
        return len(roots)
    
    def _analyze_time_complexity(self) -> str:
        return "O(Î±(n)) - é˜¿å…‹æ›¼å‡½æ•°çš„åå‡½æ•°"
    
    def _analyze_space_complexity(self) -> str:
        return "O(n) - çˆ¶èŠ‚ç‚¹å’Œç§©æ•°ç»„"
    
    def _analyze_best_case(self) -> str:
        return "O(1) - ç®€å•æ“ä½œ"
    
    def _analyze_worst_case(self) -> str:
        return "O(log n) - æ— è·¯å¾„å‹ç¼©"
    
    def _analyze_average_case(self) -> str:
        return "O(Î±(n)) - å¹³å‡æƒ…å†µ"
```

## 3. ç†è®ºè¯æ˜

### 3.1 AVLæ ‘é«˜åº¦è¯æ˜

**å®šç† 2.1** (AVLæ ‘é«˜åº¦)
AVLæ ‘çš„é«˜åº¦ä¸º $O(\log n)$ã€‚

**è¯æ˜**:
è®¾ $N(h)$ ä¸ºé«˜åº¦ä¸º $h$ çš„AVLæ ‘çš„æœ€å°èŠ‚ç‚¹æ•°ã€‚

é€’æ¨å…³ç³»ï¼š
$$N(h) = N(h-1) + N(h-2) + 1$$

è¿™ä¸æ–æ³¢é‚£å¥‘æ•°åˆ—ç±»ä¼¼ï¼Œå› æ­¤ï¼š
$$N(h) \geq F(h+2) - 1$$

å…¶ä¸­ $F(n)$ ä¸ºæ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚

ç”±äº $F(n) \approx \frac{\phi^n}{\sqrt{5}}$ï¼Œå…¶ä¸­ $\phi = \frac{1+\sqrt{5}}{2}$ï¼Œ

å› æ­¤ï¼š
$$h = O(\log n)$$

### 3.2 çº¢é»‘æ ‘é«˜åº¦è¯æ˜

**å®šç† 2.2** (çº¢é»‘æ ‘é«˜åº¦)
çº¢é»‘æ ‘çš„é«˜åº¦ä¸º $O(\log n)$ã€‚

**è¯æ˜**:

1. ä»æ ¹åˆ°å¶å­çš„æ‰€æœ‰è·¯å¾„åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹
2. çº¢è‰²èŠ‚ç‚¹ä¸èƒ½è¿ç»­
3. å› æ­¤ï¼Œæœ€çŸ­è·¯å¾„ï¼ˆå…¨é»‘ï¼‰å’Œæœ€é•¿è·¯å¾„ï¼ˆçº¢é»‘äº¤æ›¿ï¼‰çš„é•¿åº¦å·®ä¸è¶…è¿‡2å€
4. æ‰€ä»¥é«˜åº¦ä¸º $O(\log n)$

### 3.3 å †æ“ä½œå¤æ‚åº¦è¯æ˜

**å®šç† 2.3** (å †æ“ä½œå¤æ‚åº¦)
å †çš„æ’å…¥å’Œåˆ é™¤æ“ä½œå¤æ‚åº¦ä¸º $O(\log n)$ã€‚

**è¯æ˜**:

1. **æ’å…¥**: éœ€è¦å‘ä¸Šè°ƒæ•´ï¼Œæœ€å¤šè°ƒæ•´ $\log n$ å±‚
2. **åˆ é™¤**: éœ€è¦å‘ä¸‹è°ƒæ•´ï¼Œæœ€å¤šè°ƒæ•´ $\log n$ å±‚
3. æ¯æ¬¡è°ƒæ•´çš„å¤æ‚åº¦ä¸º $O(1)$
4. å› æ­¤æ€»å¤æ‚åº¦ä¸º $O(\log n)$

### 3.4 å“ˆå¸Œè¡¨æ€§èƒ½è¯æ˜

**å®šç† 2.4** (å“ˆå¸Œè¡¨æ€§èƒ½)
åœ¨å‡åŒ€å“ˆå¸Œå‡½æ•°ä¸‹ï¼Œå“ˆå¸Œè¡¨çš„å¹³å‡æŸ¥æ‰¾æ—¶é—´ä¸º $O(1)$ã€‚

**è¯æ˜**:
è®¾ $n$ ä¸ºå…ƒç´ æ•°é‡ï¼Œ$m$ ä¸ºæ¡¶æ•°é‡ï¼Œ$\alpha = \frac{n}{m}$ ä¸ºè´Ÿè½½å› å­ã€‚

åœ¨å‡åŒ€å“ˆå¸Œä¸‹ï¼Œæ¯ä¸ªæ¡¶çš„æœŸæœ›å…ƒç´ æ•°ä¸º $\alpha$ã€‚

å› æ­¤ï¼Œå¹³å‡æŸ¥æ‰¾æ—¶é—´ä¸º $O(1 + \alpha)$ã€‚

å½“ $\alpha = O(1)$ æ—¶ï¼Œå¹³å‡æŸ¥æ‰¾æ—¶é—´ä¸º $O(1)$ã€‚

### 3.5 è·³è¡¨æ€§èƒ½è¯æ˜

**å®šç† 2.5** (è·³è¡¨æ€§èƒ½)
è·³è¡¨çš„å¹³å‡æŸ¥æ‰¾æ—¶é—´ä¸º $O(\log n)$ã€‚

**è¯æ˜**:

1. æ¯ä¸ªå…ƒç´ ä»¥æ¦‚ç‡ $\frac{1}{2}$ å‡ºç°åœ¨ç¬¬ $i$ å±‚
2. æœŸæœ›å±‚æ•°ä¸º $\log n$
3. æ¯å±‚çš„æœŸæœ›æœç´¢æ—¶é—´ä¸º $O(1)$
4. å› æ­¤æ€»æœŸæœ›æ—¶é—´ä¸º $O(\log n)$

## 4. æ€§èƒ½æµ‹è¯•

```python
def test_advanced_data_structures():
    """æµ‹è¯•é«˜çº§æ•°æ®ç»“æ„æ€§èƒ½"""
    
    # æµ‹è¯•æ•°æ®
    test_data = list(range(1000))
    
    # æµ‹è¯•çš„æ•°æ®ç»“æ„
    structures = [
        AVLTree(),
        RedBlackTree(),
        MinHeap(),
        HashTable(),
        SkipList(),
        UnionFind()
    ]
    
    print("é«˜çº§æ•°æ®ç»“æ„æ€§èƒ½æµ‹è¯•")
    print("=" * 60)
    
    for structure in structures:
        print(f"\n{structure.name}:")
        print("-" * 30)
        
        # æµ‹è¯•æ’å…¥æ€§èƒ½
        start_time = time.time()
        for item in test_data:
            if isinstance(structure, MinHeap):
                structure.insert(HeapNode(item, float(item)))
            elif isinstance(structure, UnionFind):
                structure.make_set(item)
            else:
                structure.insert(item)
        insert_time = time.time() - start_time
        
        # æµ‹è¯•æœç´¢æ€§èƒ½
        start_time = time.time()
        for item in test_data[:100]:  # åªæµ‹è¯•å‰100ä¸ª
            if isinstance(structure, MinHeap):
                structure.search(HeapNode(item, float(item)))
            else:
                structure.search(item)
        search_time = time.time() - start_time
        
        # æµ‹è¯•åˆ é™¤æ€§èƒ½
        start_time = time.time()
        for item in test_data[:100]:  # åªæµ‹è¯•å‰100ä¸ª
            if isinstance(structure, MinHeap):
                structure.delete(HeapNode(item, float(item)))
            else:
                structure.delete(item)
        delete_time = time.time() - start_time
        
        print(f"æ’å…¥æ—¶é—´: {insert_time:.6f}s")
        print(f"æœç´¢æ—¶é—´: {search_time:.6f}s")
        print(f"åˆ é™¤æ—¶é—´: {delete_time:.6f}s")
        print(f"æœ€ç»ˆå¤§å°: {structure.get_size()}")
        
        # æ˜¾ç¤ºæ€§èƒ½ç»Ÿè®¡
        stats = structure.get_performance_stats()
        if stats:
            print("æ“ä½œç»Ÿè®¡:")
            for op, metrics in stats.items():
                print(f"  {op}: å¹³å‡æ—¶é—´={metrics['avg_time']:.6f}s, "
                      f"æˆåŠŸç‡={metrics['success_rate']:.2%}")

def compare_tree_structures():
    """æ¯”è¾ƒæ ‘ç»“æ„æ€§èƒ½"""
    
    test_data = list(range(1000))
    
    print("\næ ‘ç»“æ„æ€§èƒ½æ¯”è¾ƒ")
    print("=" * 40)
    
    trees = [
        ("AVL Tree", AVLTree()),
        ("Red-Black Tree", RedBlackTree())
    ]
    
    for name, tree in trees:
        print(f"\n{name}:")
        
        # æ’å…¥æµ‹è¯•
        start_time = time.time()
        for item in test_data:
            tree.insert(item)
        insert_time = time.time() - start_time
        
        # æœç´¢æµ‹è¯•
        start_time = time.time()
        for item in test_data[:100]:
            tree.search(item)
        search_time = time.time() - start_time
        
        # åˆ é™¤æµ‹è¯•
        start_time = time.time()
        for item in test_data[:100]:
            tree.delete(item)
        delete_time = time.time() - start_time
        
        print(f"  æ’å…¥: {insert_time:.6f}s")
        print(f"  æœç´¢: {search_time:.6f}s")
        print(f"  åˆ é™¤: {delete_time:.6f}s")

def test_hash_table_performance():
    """æµ‹è¯•å“ˆå¸Œè¡¨æ€§èƒ½"""
    
    print("\nå“ˆå¸Œè¡¨æ€§èƒ½æµ‹è¯•")
    print("=" * 40)
    
    # æµ‹è¯•ä¸åŒè´Ÿè½½å› å­
    load_factors = [0.5, 0.75, 0.9]
    
    for load_factor in load_factors:
        print(f"\nè´Ÿè½½å› å­: {load_factor}")
        
        hash_table = HashTable(load_factor=load_factor)
        
        # æ’å…¥æµ‹è¯•
        start_time = time.time()
        for i in range(1000):
            hash_table.insert(f"key_{i}")
        insert_time = time.time() - start_time
        
        # æœç´¢æµ‹è¯•
        start_time = time.time()
        for i in range(100):
            hash_table.search(f"key_{i}")
        search_time = time.time() - start_time
        
        print(f"  æ’å…¥: {insert_time:.6f}s")
        print(f"  æœç´¢: {search_time:.6f}s")
        print(f"  å®é™…è´Ÿè½½å› å­: {hash_table.get_load_factor():.2f}")

if __name__ == "__main__":
    test_advanced_data_structures()
    compare_tree_structures()
    test_hash_table_performance()
```

## 5. æ€»ç»“

æœ¬æ–‡æ¡£å»ºç«‹äº†é«˜çº§æ•°æ®ç»“æ„çš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†å„ç§é«˜çº§æ•°æ®ç»“æ„çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **ç®—æ³•å®ç°**: å®Œæ•´çš„é«˜çº§æ•°æ®ç»“æ„Pythonå®ç°
3. **ç†è®ºè¯æ˜**: é«˜çº§æ•°æ®ç»“æ„çš„æ­£ç¡®æ€§å’Œå¤æ‚åº¦è¯æ˜
4. **æ€§èƒ½åˆ†æ**: ä¸åŒé«˜çº§æ•°æ®ç»“æ„çš„æ€§èƒ½æ¯”è¾ƒ

### é«˜çº§æ•°æ®ç»“æ„ç‰¹æ€§æ€»ç»“

| æ•°æ®ç»“æ„ | æ’å…¥ | åˆ é™¤ | æœç´¢ | ç©ºé—´å¤æ‚åº¦ | ç‰¹ç‚¹ |
|----------|------|------|------|------------|------|
| AVLæ ‘ | O(log n) | O(log n) | O(log n) | O(n) | ä¸¥æ ¼å¹³è¡¡ |
| çº¢é»‘æ ‘ | O(log n) | O(log n) | O(log n) | O(n) | è¿‘ä¼¼å¹³è¡¡ |
| å † | O(log n) | O(log n) | O(n) | O(n) | ä¼˜å…ˆé˜Ÿåˆ— |
| å“ˆå¸Œè¡¨ | O(1) | O(1) | O(1) | O(n) | å¹³å‡O(1) |
| è·³è¡¨ | O(log n) | O(log n) | O(log n) | O(n) | æ¦‚ç‡å¹³è¡¡ |
| å¹¶æŸ¥é›† | O(Î±(n)) | O(Î±(n)) | O(Î±(n)) | O(n) | é›†åˆæ“ä½œ |

---

*ä¸‹ä¸€èŠ‚ï¼š[02-03-è®¡ç®—å¤æ‚æ€§ç†è®º](./02-03-è®¡ç®—å¤æ‚æ€§ç†è®º.md)*
