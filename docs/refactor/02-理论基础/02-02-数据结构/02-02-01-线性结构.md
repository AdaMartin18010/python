# 02-02-01 线性结构

## 📋 概述

线性结构是计算机科学中最基本的数据组织方式，元素之间存在一对一的前驱后继关系。本文档从形式化角度定义线性结构，建立完整的理论体系，并提供高效的Python实现。

## 🎯 核心概念

### 1. 线性结构的形式化定义

#### 1.1 基本定义

**定义 1.1** (线性结构)
线性结构是一个三元组：
$$L = (E, R, O)$$

其中：

- $E$ 为元素集合
- $R$ 为关系集合：$R \subseteq E \times E$
- $O$ 为操作集合

**定义 1.2** (线性关系)
关系 $R$ 是线性的，当且仅当：
$$\forall x, y \in E, (x, y) \in R \lor (y, x) \in R \lor x = y$$

**定义 1.3** (线性结构的长度)
线性结构 $L$ 的长度定义为：
$$|L| = |E|$$

#### 1.2 Python实现

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Optional, Iterator, Any
from dataclasses import dataclass, field
from enum import Enum
import array
import ctypes

T = TypeVar('T')

class LinearStructure(ABC, Generic[T]):
    """线性结构抽象基类"""
    
    def __init__(self):
        self._size = 0
    
    @abstractmethod
    def is_empty(self) -> bool:
        """检查是否为空"""
        pass
    
    @abstractmethod
    def size(self) -> int:
        """获取大小"""
        pass
    
    @abstractmethod
    def clear(self) -> None:
        """清空结构"""
        pass
    
    def __len__(self) -> int:
        return self.size()
    
    def __bool__(self) -> bool:
        return not self.is_empty()

class Array(LinearStructure[T]):
    """数组实现"""
    
    def __init__(self, capacity: int = 10):
        super().__init__()
        self._capacity = capacity
        self._data: list[Optional[T]] = [None] * capacity
        self._size = 0
    
    def is_empty(self) -> bool:
        return self._size == 0
    
    def size(self) -> int:
        return self._size
    
    def capacity(self) -> int:
        return self._capacity
    
    def get(self, index: int) -> T:
        """获取指定位置的元素"""
        if not 0 <= index < self._size:
            raise IndexError(f"Index {index} out of bounds")
        return self._data[index]
    
    def set(self, index: int, element: T) -> None:
        """设置指定位置的元素"""
        if not 0 <= index < self._size:
            raise IndexError(f"Index {index} out of bounds")
        self._data[index] = element
    
    def add(self, element: T) -> None:
        """添加元素到末尾"""
        self._ensure_capacity(self._size + 1)
        self._data[self._size] = element
        self._size += 1
    
    def insert(self, index: int, element: T) -> None:
        """在指定位置插入元素"""
        if not 0 <= index <= self._size:
            raise IndexError(f"Index {index} out of bounds")
        
        self._ensure_capacity(self._size + 1)
        
        # 移动元素
        for i in range(self._size, index, -1):
            self._data[i] = self._data[i - 1]
        
        self._data[index] = element
        self._size += 1
    
    def remove(self, index: int) -> T:
        """删除指定位置的元素"""
        if not 0 <= index < self._size:
            raise IndexError(f"Index {index} out of bounds")
        
        element = self._data[index]
        
        # 移动元素
        for i in range(index, self._size - 1):
            self._data[i] = self._data[i + 1]
        
        self._data[self._size - 1] = None
        self._size -= 1
        
        return element
    
    def index_of(self, element: T) -> int:
        """查找元素第一次出现的索引"""
        for i in range(self._size):
            if self._data[i] == element:
                return i
        return -1
    
    def contains(self, element: T) -> bool:
        """检查是否包含元素"""
        return self.index_of(element) != -1
    
    def _ensure_capacity(self, min_capacity: int) -> None:
        """确保容量足够"""
        if min_capacity > self._capacity:
            new_capacity = max(self._capacity * 2, min_capacity)
            new_data = [None] * new_capacity
            for i in range(self._size):
                new_data[i] = self._data[i]
            self._data = new_data
            self._capacity = new_capacity
    
    def clear(self) -> None:
        self._data = [None] * self._capacity
        self._size = 0
    
    def __getitem__(self, index: int) -> T:
        return self.get(index)
    
    def __setitem__(self, index: int, element: T) -> None:
        self.set(index, element)
    
    def __iter__(self) -> Iterator[T]:
        for i in range(self._size):
            yield self._data[i]
    
    def __str__(self) -> str:
        return f"Array({list(self)})"

class Node(Generic[T]):
    """链表节点"""
    
    def __init__(self, data: T, next_node: Optional['Node[T]'] = None):
        self.data = data
        self.next = next_node
    
    def __str__(self) -> str:
        return str(self.data)

class LinkedList(LinearStructure[T]):
    """链表实现"""
    
    def __init__(self):
        super().__init__()
        self._head: Optional[Node[T]] = None
        self._tail: Optional[Node[T]] = None
        self._size = 0
    
    def is_empty(self) -> bool:
        return self._head is None
    
    def size(self) -> int:
        return self._size
    
    def add_first(self, element: T) -> None:
        """在头部添加元素"""
        new_node = Node(element, self._head)
        self._head = new_node
        if self._tail is None:
            self._tail = new_node
        self._size += 1
    
    def add_last(self, element: T) -> None:
        """在尾部添加元素"""
        new_node = Node(element)
        if self._tail is None:
            self._head = new_node
            self._tail = new_node
        else:
            self._tail.next = new_node
            self._tail = new_node
        self._size += 1
    
    def add(self, element: T) -> None:
        """添加元素（默认添加到尾部）"""
        self.add_last(element)
    
    def insert(self, index: int, element: T) -> None:
        """在指定位置插入元素"""
        if not 0 <= index <= self._size:
            raise IndexError(f"Index {index} out of bounds")
        
        if index == 0:
            self.add_first(element)
        elif index == self._size:
            self.add_last(element)
        else:
            current = self._head
            for _ in range(index - 1):
                current = current.next
            new_node = Node(element, current.next)
            current.next = new_node
            self._size += 1
    
    def get(self, index: int) -> T:
        """获取指定位置的元素"""
        if not 0 <= index < self._size:
            raise IndexError(f"Index {index} out of bounds")
        
        current = self._head
        for _ in range(index):
            current = current.next
        return current.data
    
    def set(self, index: int, element: T) -> None:
        """设置指定位置的元素"""
        if not 0 <= index < self._size:
            raise IndexError(f"Index {index} out of bounds")
        
        current = self._head
        for _ in range(index):
            current = current.next
        current.data = element
    
    def remove_first(self) -> T:
        """删除头部元素"""
        if self.is_empty():
            raise IndexError("Cannot remove from empty list")
        
        element = self._head.data
        self._head = self._head.next
        self._size -= 1
        
        if self._size == 0:
            self._tail = None
        
        return element
    
    def remove_last(self) -> T:
        """删除尾部元素"""
        if self.is_empty():
            raise IndexError("Cannot remove from empty list")
        
        if self._size == 1:
            element = self._head.data
            self._head = None
            self._tail = None
            self._size = 0
            return element
        
        current = self._head
        while current.next != self._tail:
            current = current.next
        
        element = self._tail.data
        current.next = None
        self._tail = current
        self._size -= 1
        
        return element
    
    def remove(self, index: int) -> T:
        """删除指定位置的元素"""
        if not 0 <= index < self._size:
            raise IndexError(f"Index {index} out of bounds")
        
        if index == 0:
            return self.remove_first()
        elif index == self._size - 1:
            return self.remove_last()
        else:
            current = self._head
            for _ in range(index - 1):
                current = current.next
            element = current.next.data
            current.next = current.next.next
            self._size -= 1
            return element
    
    def index_of(self, element: T) -> int:
        """查找元素第一次出现的索引"""
        current = self._head
        index = 0
        while current is not None:
            if current.data == element:
                return index
            current = current.next
            index += 1
        return -1
    
    def contains(self, element: T) -> bool:
        """检查是否包含元素"""
        return self.index_of(element) != -1
    
    def clear(self) -> None:
        self._head = None
        self._tail = None
        self._size = 0
    
    def __getitem__(self, index: int) -> T:
        return self.get(index)
    
    def __setitem__(self, index: int, element: T) -> None:
        self.set(index, element)
    
    def __iter__(self) -> Iterator[T]:
        current = self._head
        while current is not None:
            yield current.data
            current = current.next
    
    def __str__(self) -> str:
        return f"LinkedList({list(self)})"

class Stack(LinearStructure[T]):
    """栈实现（后进先出）"""
    
    def __init__(self):
        super().__init__()
        self._data: list[T] = []
        self._size = 0
    
    def is_empty(self) -> bool:
        return self._size == 0
    
    def size(self) -> int:
        return self._size
    
    def push(self, element: T) -> None:
        """压入元素"""
        self._data.append(element)
        self._size += 1
    
    def pop(self) -> T:
        """弹出元素"""
        if self.is_empty():
            raise IndexError("Cannot pop from empty stack")
        element = self._data.pop()
        self._size -= 1
        return element
    
    def peek(self) -> T:
        """查看栈顶元素"""
        if self.is_empty():
            raise IndexError("Cannot peek empty stack")
        return self._data[-1]
    
    def clear(self) -> None:
        self._data.clear()
        self._size = 0
    
    def __iter__(self) -> Iterator[T]:
        return iter(reversed(self._data))
    
    def __str__(self) -> str:
        return f"Stack({list(self)})"

class Queue(LinearStructure[T]):
    """队列实现（先进先出）"""
    
    def __init__(self):
        super().__init__()
        self._data: list[T] = []
        self._size = 0
    
    def is_empty(self) -> bool:
        return self._size == 0
    
    def size(self) -> int:
        return self._size
    
    def enqueue(self, element: T) -> None:
        """入队"""
        self._data.append(element)
        self._size += 1
    
    def dequeue(self) -> T:
        """出队"""
        if self.is_empty():
            raise IndexError("Cannot dequeue from empty queue")
        element = self._data.pop(0)
        self._size -= 1
        return element
    
    def front(self) -> T:
        """查看队首元素"""
        if self.is_empty():
            raise IndexError("Cannot peek empty queue")
        return self._data[0]
    
    def clear(self) -> None:
        self._data.clear()
        self._size = 0
    
    def __iter__(self) -> Iterator[T]:
        return iter(self._data)
    
    def __str__(self) -> str:
        return f"Queue({list(self)})"

class Deque(LinearStructure[T]):
    """双端队列实现"""
    
    def __init__(self):
        super().__init__()
        self._data: list[T] = []
        self._size = 0
    
    def is_empty(self) -> bool:
        return self._size == 0
    
    def size(self) -> int:
        return self._size
    
    def add_first(self, element: T) -> None:
        """在头部添加元素"""
        self._data.insert(0, element)
        self._size += 1
    
    def add_last(self, element: T) -> None:
        """在尾部添加元素"""
        self._data.append(element)
        self._size += 1
    
    def remove_first(self) -> T:
        """删除头部元素"""
        if self.is_empty():
            raise IndexError("Cannot remove from empty deque")
        element = self._data.pop(0)
        self._size -= 1
        return element
    
    def remove_last(self) -> T:
        """删除尾部元素"""
        if self.is_empty():
            raise IndexError("Cannot remove from empty deque")
        element = self._data.pop()
        self._size -= 1
        return element
    
    def get_first(self) -> T:
        """获取头部元素"""
        if self.is_empty():
            raise IndexError("Cannot get from empty deque")
        return self._data[0]
    
    def get_last(self) -> T:
        """获取尾部元素"""
        if self.is_empty():
            raise IndexError("Cannot get from empty deque")
        return self._data[-1]
    
    def clear(self) -> None:
        self._data.clear()
        self._size = 0
    
    def __iter__(self) -> Iterator[T]:
        return iter(self._data)
    
    def __str__(self) -> str:
        return f"Deque({list(self)})"

# 性能测试和演示
def demonstrate_linear_structures():
    """演示各种线性结构的使用"""
    
    print("=== 线性结构演示 ===\n")
    
    # 1. 数组演示
    print("1. 数组 (Array)")
    arr = Array[int](5)
    arr.add(1)
    arr.add(2)
    arr.add(3)
    arr.insert(1, 5)
    print(f"数组: {arr}")
    print(f"大小: {arr.size()}")
    print(f"容量: {arr.capacity()}")
    print(f"索引2的元素: {arr[2]}")
    arr[2] = 10
    print(f"修改后: {arr}")
    arr.remove(1)
    print(f"删除索引1后: {arr}\n")
    
    # 2. 链表演示
    print("2. 链表 (LinkedList)")
    linked_list = LinkedList[int]()
    linked_list.add(1)
    linked_list.add(2)
    linked_list.add(3)
    linked_list.add_first(0)
    linked_list.add_last(4)
    print(f"链表: {linked_list}")
    print(f"大小: {linked_list.size()}")
    print(f"索引2的元素: {linked_list[2]}")
    linked_list.insert(2, 10)
    print(f"在索引2插入10后: {linked_list}")
    linked_list.remove(2)
    print(f"删除索引2后: {linked_list}\n")
    
    # 3. 栈演示
    print("3. 栈 (Stack)")
    stack = Stack[int]()
    stack.push(1)
    stack.push(2)
    stack.push(3)
    print(f"栈: {stack}")
    print(f"栈顶元素: {stack.peek()}")
    print(f"弹出元素: {stack.pop()}")
    print(f"弹出后: {stack}\n")
    
    # 4. 队列演示
    print("4. 队列 (Queue)")
    queue = Queue[int]()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)
    print(f"队列: {queue}")
    print(f"队首元素: {queue.front()}")
    print(f"出队元素: {queue.dequeue()}")
    print(f"出队后: {queue}\n")
    
    # 5. 双端队列演示
    print("5. 双端队列 (Deque)")
    deque = Deque[int]()
    deque.add_first(1)
    deque.add_last(2)
    deque.add_first(0)
    deque.add_last(3)
    print(f"双端队列: {deque}")
    print(f"头部元素: {deque.get_first()}")
    print(f"尾部元素: {deque.get_last()}")
    print(f"删除头部: {deque.remove_first()}")
    print(f"删除尾部: {deque.remove_last()}")
    print(f"删除后: {deque}\n")

if __name__ == "__main__":
    demonstrate_linear_structures()
```

## 📊 线性结构分类

### 2.1 按访问方式分类

#### 2.1.1 随机访问结构

**定义 2.1** (随机访问)
随机访问结构允许在常数时间内访问任意位置的元素：
$$Access(L, i) = O(1)$$

**定理 2.1** (数组访问复杂度)
数组的随机访问时间复杂度为 $O(1)$。

**证明**:

1. 数组在内存中连续存储
2. 元素地址 = 基地址 + 索引 × 元素大小
3. 地址计算为常数时间操作
4. 因此访问时间为 $O(1)$

#### 2.1.2 顺序访问结构

**定义 2.2** (顺序访问)
顺序访问结构需要从头开始遍历到目标位置：
$$Access(L, i) = O(i)$$

**定理 2.2** (链表访问复杂度)
链表的随机访问时间复杂度为 $O(n)$。

**证明**:

1. 链表节点在内存中不连续
2. 需要从头节点开始遍历
3. 最坏情况下需要遍历 $n$ 个节点
4. 因此访问时间为 $O(n)$

### 2.2 按操作特性分类

#### 2.2.1 栈（后进先出）

**定义 2.3** (栈)
栈是一种后进先出（LIFO）的线性结构：
$$Stack = (E, push, pop, peek)$$

**栈操作**:

- $push(e)$: 将元素 $e$ 压入栈顶
- $pop()$: 弹出栈顶元素
- $peek()$: 查看栈顶元素

**定理 2.3** (栈操作复杂度)
栈的所有操作时间复杂度为 $O(1)$。

#### 2.2.2 队列（先进先出）

**定义 2.4** (队列)
队列是一种先进先出（FIFO）的线性结构：
$$Queue = (E, enqueue, dequeue, front)$$

**队列操作**:

- $enqueue(e)$: 将元素 $e$ 加入队尾
- $dequeue()$: 从队首移除元素
- $front()$: 查看队首元素

**定理 2.4** (队列操作复杂度)
队列的基本操作时间复杂度为 $O(1)$。

## 🔍 性能分析

### 3.1 时间复杂度分析

| 操作 | 数组 | 链表 | 栈 | 队列 |
|------|------|------|----|----|
| 访问 | $O(1)$ | $O(n)$ | $O(1)$ | $O(1)$ |
| 插入 | $O(n)$ | $O(n)$ | $O(1)$ | $O(1)$ |
| 删除 | $O(n)$ | $O(n)$ | $O(1)$ | $O(1)$ |
| 查找 | $O(n)$ | $O(n)$ | $O(n)$ | $O(n)$ |

### 3.2 空间复杂度分析

| 结构 | 空间复杂度 | 说明 |
|------|------------|------|
| 数组 | $O(n)$ | 连续存储，可能有未使用空间 |
| 链表 | $O(n)$ | 每个节点包含数据和指针 |
| 栈 | $O(n)$ | 基于数组或链表实现 |
| 队列 | $O(n)$ | 基于数组或链表实现 |

### 3.3 内存布局分析

#### 3.3.1 数组内存布局

```latex
内存地址: [1000] [1004] [1008] [1012] [1016]
数组索引:    0      1      2      3      4
元素值:    [ 10 ] [ 20 ] [ 30 ] [ 40 ] [ 50 ]
```

**地址计算公式**:
$$Address[i] = BaseAddress + i \times ElementSize$$

#### 3.3.2 链表内存布局

```latex
节点1: [数据:10] -> [指针:2000]
节点2: [数据:20] -> [指针:3000]  
节点3: [数据:30] -> [指针:null]
```

## 🎯 应用场景

### 4.1 数组应用

- **数值计算**: 矩阵运算、图像处理
- **缓存系统**: 最近最少使用（LRU）缓存
- **哈希表**: 冲突解决中的链地址法

### 4.2 链表应用

- **内存管理**: 空闲内存块链表
- **文件系统**: 文件分配表（FAT）
- **撤销系统**: 操作历史记录

### 4.3 栈应用

- **函数调用**: 调用栈
- **表达式求值**: 后缀表达式计算
- **括号匹配**: 语法分析

### 4.4 队列应用

- **任务调度**: 进程队列
- **消息传递**: 消息队列
- **广度优先搜索**: 图遍历

## 📈 优化技术

### 5.1 动态扩容

#### 5.1.1 数组扩容策略

**定理 5.1** (均摊分析)
如果数组每次扩容时容量翻倍，则插入操作的均摊时间复杂度为 $O(1)$。

**证明**:

1. 设扩容前容量为 $n$，扩容后为 $2n$
2. 扩容成本为 $O(n)$
3. 下次扩容前需要 $n$ 次插入
4. 均摊成本：$O(n)/n = O(1)$

#### 5.1.2 实现代码

```python
def _ensure_capacity(self, min_capacity: int) -> None:
    """确保容量足够"""
    if min_capacity > self._capacity:
        new_capacity = max(self._capacity * 2, min_capacity)
        new_data = [None] * new_capacity
        for i in range(self._size):
            new_data[i] = self._data[i]
        self._data = new_data
        self._capacity = new_capacity
```

### 5.2 循环队列

#### 5.2.1 循环队列定义

**定义 5.1** (循环队列)
循环队列使用固定大小的数组，通过模运算实现循环：
$$Queue[i] = Array[i \bmod capacity]$$

#### 5.2.2 实现优势

- **空间效率**: 避免数组移动
- **时间效率**: 入队出队均为 $O(1)$
- **内存友好**: 减少内存分配

## 🔗 相关链接

- [02-02-02 树形结构](./02-02-02-树形结构.md)
- [02-02-03 图结构](./02-02-03-图结构.md)
- [06-03-01 线性结构实现](../../06-组件算法/06-03-数据结构实现/06-03-01-线性结构实现.md)
- [03-01-01 创建型模式](../../03-具体科学/03-01-设计模式/03-01-01-创建型模式.md)

---

*本文档建立了线性结构的完整理论框架，从形式化定义到实际实现，为后续的数据结构学习奠定了坚实的基础。*
