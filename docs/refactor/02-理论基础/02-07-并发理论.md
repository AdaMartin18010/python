# 02-07 å¹¶å‘ç†è®º

## ğŸ“‹ æ¦‚è¿°

å¹¶å‘ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ç ”ç©¶å¤šè¿›ç¨‹ã€å¤šçº¿ç¨‹å¹¶å‘æ‰§è¡Œçš„é‡è¦åˆ†æ”¯ï¼Œä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿã€å¹¶è¡Œè®¡ç®—å’Œç³»ç»Ÿè®¾è®¡æä¾›äº†ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦ç³»ç»Ÿä»‹ç»å¹¶å‘ç†è®ºçš„åŸºæœ¬æ¦‚å¿µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 å¹¶å‘ç³»ç»ŸåŸºç¡€

**å®šä¹‰ 1.1** (å¹¶å‘ç³»ç»Ÿ)
å¹¶å‘ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$CS = (P, R, T)$$
å…¶ä¸­ï¼š

- $P$ æ˜¯è¿›ç¨‹é›†åˆï¼š$P = \{p_1, p_2, ..., p_n\}$
- $R$ æ˜¯èµ„æºé›†åˆï¼š$R = \{r_1, r_2, ..., r_m\}$
- $T$ æ˜¯è½¬æ¢å…³ç³»é›†åˆï¼š$T \subseteq P \times R \times P$

**å®šä¹‰ 1.2** (è¿›ç¨‹çŠ¶æ€)
è¿›ç¨‹ $p$ çš„çŠ¶æ€æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$State(p) = (PC, Registers, Stack)$$
å…¶ä¸­ï¼š

- $PC$ æ˜¯ç¨‹åºè®¡æ•°å™¨
- $Registers$ æ˜¯å¯„å­˜å™¨çŠ¶æ€
- $Stack$ æ˜¯æ ˆçŠ¶æ€

**å®šä¹‰ 1.3** (ç³»ç»ŸçŠ¶æ€)
ç³»ç»ŸçŠ¶æ€æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$\sigma: P \rightarrow State(P)$$

### 1.2 å¹¶å‘æ‰§è¡Œæ¨¡å‹

**å®šä¹‰ 1.4** (äº¤é”™æ‰§è¡Œ)
ä¸¤ä¸ªè¿›ç¨‹ $p_1$ å’Œ $p_2$ çš„äº¤é”™æ‰§è¡Œå®šä¹‰ä¸ºï¼š
$$p_1 \parallel p_2 = \{s_1 \cdot s_2 \mid s_1 \in p_1, s_2 \in p_2\}$$

**å®šä¹‰ 1.5** (å¹¶å‘æ‰§è¡Œ)
å¹¶å‘æ‰§è¡Œæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

1. **åŸå­æ€§**: æ¯ä¸ªæ“ä½œè¦ä¹ˆå®Œå…¨æ‰§è¡Œï¼Œè¦ä¹ˆå®Œå…¨ä¸æ‰§è¡Œ
2. **ä¸€è‡´æ€§**: ç³»ç»Ÿä»ä¸€ä¸ªä¸€è‡´çŠ¶æ€è½¬æ¢åˆ°å¦ä¸€ä¸ªä¸€è‡´çŠ¶æ€
3. **éš”ç¦»æ€§**: å¹¶å‘è¿›ç¨‹çš„æ‰§è¡Œç›¸äº’ç‹¬ç«‹
4. **æŒä¹…æ€§**: å·²æäº¤çš„æ“ä½œæ°¸ä¹…ä¿å­˜

### 1.3 åŒæ­¥æœºåˆ¶

**å®šä¹‰ 1.6** (äº’æ–¥é”)
äº’æ–¥é”æ˜¯ä¸€ä¸ªäºŒå…ƒçŠ¶æ€å˜é‡ï¼š
$$Mutex = \{0, 1\}$$
å…¶ä¸­ï¼š

- $0$ è¡¨ç¤ºæœªé”å®šçŠ¶æ€
- $1$ è¡¨ç¤ºé”å®šçŠ¶æ€

**å®šä¹‰ 1.7** (ä¿¡å·é‡)
ä¿¡å·é‡æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$Semaphore = (value, queue, operations)$$
å…¶ä¸­ï¼š

- $value$ æ˜¯å½“å‰å€¼
- $queue$ æ˜¯ç­‰å¾…é˜Ÿåˆ—
- $operations$ æ˜¯æ“ä½œé›†åˆ $\{P(), V()\}$

**å®šä¹‰ 1.8** (æ¡ä»¶å˜é‡)
æ¡ä»¶å˜é‡æ˜¯ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼š
$$Condition = \{p_1, p_2, ..., p_n\}$$

## 2. Pythonå®ç°

### 2.1 å¹¶å‘ç³»ç»ŸåŸºç¡€

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Optional, Union, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import threading
import time
import queue
import random
from collections import defaultdict, deque

class ProcessState(Enum):
    """è¿›ç¨‹çŠ¶æ€"""
    READY = "ready"
    RUNNING = "running"
    WAITING = "waiting"
    TERMINATED = "terminated"

class ResourceType(Enum):
    """èµ„æºç±»å‹"""
    CPU = "cpu"
    MEMORY = "memory"
    DISK = "disk"
    NETWORK = "network"
    LOCK = "lock"

@dataclass
class Process:
    """è¿›ç¨‹"""
    pid: int
    name: str
    state: ProcessState = ProcessState.READY
    priority: int = 0
    arrival_time: float = 0.0
    burst_time: float = 0.0
    remaining_time: float = 0.0
    waiting_time: float = 0.0
    turnaround_time: float = 0.0
    
    def __str__(self) -> str:
        return f"Process({self.pid}: {self.name}, {self.state.value})"

@dataclass
class Resource:
    """èµ„æº"""
    rid: int
    name: str
    resource_type: ResourceType
    capacity: int
    available: int
    allocated: Dict[int, int] = field(default_factory=dict)  # pid -> amount
    
    def __str__(self) -> str:
        return f"Resource({self.rid}: {self.name}, {self.available}/{self.capacity})"

class ConcurrentSystem:
    """å¹¶å‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.processes: Dict[int, Process] = {}
        self.resources: Dict[int, Resource] = {}
        self.ready_queue: deque = deque()
        self.waiting_queue: deque = deque()
        self.running_process: Optional[Process] = None
        self.system_time: float = 0.0
        self.scheduler = None
        self.deadlock_detector = None
    
    def add_process(self, process: Process) -> None:
        """æ·»åŠ è¿›ç¨‹"""
        self.processes[process.pid] = process
        self.ready_queue.append(process)
    
    def add_resource(self, resource: Resource) -> None:
        """æ·»åŠ èµ„æº"""
        self.resources[resource.rid] = resource
    
    def allocate_resource(self, pid: int, rid: int, amount: int) -> bool:
        """åˆ†é…èµ„æº"""
        if rid not in self.resources:
            return False
        
        resource = self.resources[rid]
        if resource.available >= amount:
            resource.available -= amount
            resource.allocated[pid] = resource.allocated.get(pid, 0) + amount
            return True
        return False
    
    def release_resource(self, pid: int, rid: int, amount: int) -> bool:
        """é‡Šæ”¾èµ„æº"""
        if rid not in self.resources:
            return False
        
        resource = self.resources[rid]
        if pid in resource.allocated and resource.allocated[pid] >= amount:
            resource.allocated[pid] -= amount
            resource.available += amount
            if resource.allocated[pid] == 0:
                del resource.allocated[pid]
            return True
        return False
    
    def get_system_state(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        return {
            "time": self.system_time,
            "running_process": self.running_process,
            "ready_queue_size": len(self.ready_queue),
            "waiting_queue_size": len(self.waiting_queue),
            "total_processes": len(self.processes),
            "total_resources": len(self.resources)
        }

### 2.2 è°ƒåº¦ç®—æ³•

class Scheduler(ABC):
    """è°ƒåº¦å™¨æŠ½è±¡åŸºç±»"""
    
    def __init__(self, system: ConcurrentSystem):
        self.system = system
    
    @abstractmethod
    def schedule(self) -> Optional[Process]:
        """è°ƒåº¦ä¸‹ä¸€ä¸ªè¿›ç¨‹"""
        pass
    
    @abstractmethod
    def add_process(self, process: Process) -> None:
        """æ·»åŠ è¿›ç¨‹åˆ°è°ƒåº¦é˜Ÿåˆ—"""
        pass

class FCFSScheduler(Scheduler):
    """å…ˆæ¥å…ˆæœåŠ¡è°ƒåº¦å™¨"""
    
    def __init__(self, system: ConcurrentSystem):
        super().__init__(system)
        self.queue: deque = deque()
    
    def schedule(self) -> Optional[Process]:
        """FCFSè°ƒåº¦"""
        if self.queue:
            return self.queue.popleft()
        return None
    
    def add_process(self, process: Process) -> None:
        """æ·»åŠ è¿›ç¨‹"""
        self.queue.append(process)

class RoundRobinScheduler(Scheduler):
    """è½®è½¬è°ƒåº¦å™¨"""
    
    def __init__(self, system: ConcurrentSystem, time_quantum: float):
        super().__init__(system)
        self.queue: deque = deque()
        self.time_quantum = time_quantum
        self.current_process: Optional[Process] = None
        self.remaining_quantum: float = time_quantum
    
    def schedule(self) -> Optional[Process]:
        """è½®è½¬è°ƒåº¦"""
        if self.current_process and self.remaining_quantum > 0:
            return self.current_process
        
        if self.current_process:
            self.queue.append(self.current_process)
        
        if self.queue:
            self.current_process = self.queue.popleft()
            self.remaining_quantum = self.time_quantum
            return self.current_process
        
        return None
    
    def add_process(self, process: Process) -> None:
        """æ·»åŠ è¿›ç¨‹"""
        if not self.current_process:
            self.current_process = process
            self.remaining_quantum = self.time_quantum
        else:
            self.queue.append(process)
    
    def update_quantum(self, time_used: float) -> None:
        """æ›´æ–°å‰©ä½™æ—¶é—´ç‰‡"""
        self.remaining_quantum -= time_used

class PriorityScheduler(Scheduler):
    """ä¼˜å…ˆçº§è°ƒåº¦å™¨"""
    
    def __init__(self, system: ConcurrentSystem):
        super().__init__(system)
        self.queues: Dict[int, deque] = defaultdict(deque)
        self.max_priority = 0
    
    def schedule(self) -> Optional[Process]:
        """ä¼˜å…ˆçº§è°ƒåº¦"""
        for priority in range(self.max_priority, -1, -1):
            if priority in self.queues and self.queues[priority]:
                return self.queues[priority].popleft()
        return None
    
    def add_process(self, process: Process) -> None:
        """æ·»åŠ è¿›ç¨‹"""
        self.queues[process.priority].append(process)
        self.max_priority = max(self.max_priority, process.priority)

### 2.3 åŒæ­¥æœºåˆ¶

class Mutex:
    """äº’æ–¥é”"""
    
    def __init__(self):
        self.locked = False
        self.owner: Optional[int] = None
        self.waiting_queue: deque = deque()
    
    def acquire(self, pid: int) -> bool:
        """è·å–é”"""
        if not self.locked:
            self.locked = True
            self.owner = pid
            return True
        else:
            self.waiting_queue.append(pid)
            return False
    
    def release(self, pid: int) -> bool:
        """é‡Šæ”¾é”"""
        if self.owner == pid:
            self.locked = False
            self.owner = None
            
            # å”¤é†’ç­‰å¾…çš„è¿›ç¨‹
            if self.waiting_queue:
                next_pid = self.waiting_queue.popleft()
                self.locked = True
                self.owner = next_pid
            
            return True
        return False
    
    def is_locked(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¢«é”å®š"""
        return self.locked

class Semaphore:
    """ä¿¡å·é‡"""
    
    def __init__(self, initial_value: int):
        self.value = initial_value
        self.waiting_queue: deque = deque()
    
    def P(self, pid: int) -> bool:
        """Pæ“ä½œï¼ˆç­‰å¾…ï¼‰"""
        if self.value > 0:
            self.value -= 1
            return True
        else:
            self.waiting_queue.append(pid)
            return False
    
    def V(self) -> Optional[int]:
        """Væ“ä½œï¼ˆé‡Šæ”¾ï¼‰"""
        if self.waiting_queue:
            # å”¤é†’ç­‰å¾…çš„è¿›ç¨‹
            return self.waiting_queue.popleft()
        else:
            self.value += 1
            return None
    
    def get_value(self) -> int:
        """è·å–å½“å‰å€¼"""
        return self.value

class ConditionVariable:
    """æ¡ä»¶å˜é‡"""
    
    def __init__(self):
        self.waiting_queue: deque = deque()
    
    def wait(self, pid: int) -> None:
        """ç­‰å¾…"""
        self.waiting_queue.append(pid)
    
    def signal(self) -> Optional[int]:
        """å”¤é†’ä¸€ä¸ªç­‰å¾…çš„è¿›ç¨‹"""
        if self.waiting_queue:
            return self.waiting_queue.popleft()
        return None
    
    def broadcast(self) -> List[int]:
        """å”¤é†’æ‰€æœ‰ç­‰å¾…çš„è¿›ç¨‹"""
        woken_processes = list(self.waiting_queue)
        self.waiting_queue.clear()
        return woken_processes

### 2.4 æ­»é”æ£€æµ‹

class DeadlockDetector:
    """æ­»é”æ£€æµ‹å™¨"""
    
    def __init__(self, system: ConcurrentSystem):
        self.system = system
    
    def detect_deadlock(self) -> List[List[int]]:
        """æ£€æµ‹æ­»é”"""
        # æ„å»ºèµ„æºåˆ†é…å›¾
        allocation_matrix = self._build_allocation_matrix()
        request_matrix = self._build_request_matrix()
        available_resources = self._get_available_resources()
        
        # ä½¿ç”¨é“¶è¡Œå®¶ç®—æ³•æ£€æµ‹æ­»é”
        return self._bankers_algorithm(allocation_matrix, request_matrix, available_resources)
    
    def _build_allocation_matrix(self) -> List[List[int]]:
        """æ„å»ºåˆ†é…çŸ©é˜µ"""
        processes = list(self.system.processes.keys())
        resources = list(self.system.resources.keys())
        
        matrix = [[0] * len(resources) for _ in range(len(processes))]
        
        for i, pid in enumerate(processes):
            for j, rid in enumerate(resources):
                if rid in self.system.resources:
                    matrix[i][j] = self.system.resources[rid].allocated.get(pid, 0)
        
        return matrix
    
    def _build_request_matrix(self) -> List[List[int]]:
        """æ„å»ºè¯·æ±‚çŸ©é˜µï¼ˆç®€åŒ–å®ç°ï¼‰"""
        processes = list(self.system.processes.keys())
        resources = list(self.system.resources.keys())
        
        # ç®€åŒ–å®ç°ï¼šå‡è®¾æ‰€æœ‰è¿›ç¨‹éƒ½å¯èƒ½è¯·æ±‚æ‰€æœ‰èµ„æº
        matrix = [[1] * len(resources) for _ in range(len(processes))]
        return matrix
    
    def _get_available_resources(self) -> List[int]:
        """è·å–å¯ç”¨èµ„æºå‘é‡"""
        resources = list(self.system.resources.keys())
        available = []
        
        for rid in resources:
            available.append(self.system.resources[rid].available)
        
        return available
    
    def _bankers_algorithm(self, allocation: List[List[int]], 
                          request: List[List[int]], 
                          available: List[int]) -> List[List[int]]:
        """é“¶è¡Œå®¶ç®—æ³•"""
        n_processes = len(allocation)
        n_resources = len(available)
        
        # å·¥ä½œå‘é‡
        work = available.copy()
        
        # å®Œæˆå‘é‡
        finish = [False] * n_processes
        
        # å®‰å…¨åºåˆ—
        safe_sequence = []
        
        # æŸ¥æ‰¾å¯ä»¥å®Œæˆçš„è¿›ç¨‹
        while len(safe_sequence) < n_processes:
            found = False
            
            for i in range(n_processes):
                if not finish[i]:
                    # æ£€æŸ¥è¿›ç¨‹iæ˜¯å¦å¯ä»¥å®Œæˆ
                    can_allocate = True
                    for j in range(n_resources):
                        if request[i][j] > work[j]:
                            can_allocate = False
                            break
                    
                    if can_allocate:
                        # åˆ†é…èµ„æºç»™è¿›ç¨‹i
                        for j in range(n_resources):
                            work[j] += allocation[i][j]
                        
                        finish[i] = True
                        safe_sequence.append(i)
                        found = True
            
            if not found:
                # æ²¡æœ‰æ‰¾åˆ°å¯ä»¥å®Œæˆçš„è¿›ç¨‹ï¼Œå­˜åœ¨æ­»é”
                break
        
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ­»é”
        deadlocked_processes = []
        for i in range(n_processes):
            if not finish[i]:
                deadlocked_processes.append(i)
        
        return [deadlocked_processes] if deadlocked_processes else []

class ResourceAllocationGraph:
    """èµ„æºåˆ†é…å›¾"""
    
    def __init__(self):
        self.processes: Set[int] = set()
        self.resources: Set[int] = set()
        self.edges: List[Tuple[int, int, str]] = []  # (from, to, type)
    
    def add_process(self, pid: int) -> None:
        """æ·»åŠ è¿›ç¨‹"""
        self.processes.add(pid)
    
    def add_resource(self, rid: int) -> None:
        """æ·»åŠ èµ„æº"""
        self.resources.add(rid)
    
    def add_allocation_edge(self, pid: int, rid: int) -> None:
        """æ·»åŠ åˆ†é…è¾¹"""
        self.edges.append((pid, rid, "allocation"))
    
    def add_request_edge(self, pid: int, rid: int) -> None:
        """æ·»åŠ è¯·æ±‚è¾¹"""
        self.edges.append((pid, rid, "request"))
    
    def detect_cycle(self) -> List[int]:
        """æ£€æµ‹ç¯ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢æ£€æµ‹ç¯
        visited = set()
        rec_stack = set()
        
        def dfs(node: int, path: List[int]) -> Optional[List[int]]:
            if node in rec_stack:
                # æ‰¾åˆ°ç¯
                cycle_start = path.index(node)
                return path[cycle_start:]
            
            if node in visited:
                return None
            
            visited.add(node)
            rec_stack.add(node)
            path.append(node)
            
            # æŸ¥æ‰¾ç›¸é‚»èŠ‚ç‚¹
            for edge in self.edges:
                if edge[0] == node:
                    result = dfs(edge[1], path.copy())
                    if result:
                        return result
            
            rec_stack.remove(node)
            return None
        
        # ä»æ¯ä¸ªèŠ‚ç‚¹å¼€å§‹æœç´¢
        for node in self.processes | self.resources:
            if node not in visited:
                result = dfs(node, [])
                if result:
                    return result
        
        return []

### 2.5 å¹¶å‘æ§åˆ¶

class ConcurrentController:
    """å¹¶å‘æ§åˆ¶å™¨"""
    
    def __init__(self, system: ConcurrentSystem):
        self.system = system
        self.mutexes: Dict[str, Mutex] = {}
        self.semaphores: Dict[str, Semaphore] = {}
        self.conditions: Dict[str, ConditionVariable] = {}
        self.deadlock_detector = DeadlockDetector(system)
        self.resource_graph = ResourceAllocationGraph()
    
    def create_mutex(self, name: str) -> Mutex:
        """åˆ›å»ºäº’æ–¥é”"""
        mutex = Mutex()
        self.mutexes[name] = mutex
        return mutex
    
    def create_semaphore(self, name: str, initial_value: int) -> Semaphore:
        """åˆ›å»ºä¿¡å·é‡"""
        semaphore = Semaphore(initial_value)
        self.semaphores[name] = semaphore
        return semaphore
    
    def create_condition(self, name: str) -> ConditionVariable:
        """åˆ›å»ºæ¡ä»¶å˜é‡"""
        condition = ConditionVariable()
        self.conditions[name] = condition
        return condition
    
    def acquire_resource(self, pid: int, rid: int, amount: int) -> bool:
        """è·å–èµ„æº"""
        # æ›´æ–°èµ„æºåˆ†é…å›¾
        self.resource_graph.add_process(pid)
        self.resource_graph.add_resource(rid)
        self.resource_graph.add_request_edge(pid, rid)
        
        # æ£€æŸ¥æ˜¯å¦ä¼šå¯¼è‡´æ­»é”
        if self._would_cause_deadlock(pid, rid, amount):
            return False
        
        # åˆ†é…èµ„æº
        success = self.system.allocate_resource(pid, rid, amount)
        if success:
            # æ›´æ–°èµ„æºåˆ†é…å›¾
            self.resource_graph.add_allocation_edge(pid, rid)
        
        return success
    
    def release_resource(self, pid: int, rid: int, amount: int) -> bool:
        """é‡Šæ”¾èµ„æº"""
        return self.system.release_resource(pid, rid, amount)
    
    def _would_cause_deadlock(self, pid: int, rid: int, amount: int) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¼šå¯¼è‡´æ­»é”"""
        # ä¸´æ—¶åˆ†é…èµ„æº
        original_available = self.system.resources[rid].available
        self.system.resources[rid].available -= amount
        
        # æ£€æµ‹æ­»é”
        deadlocked = self.deadlock_detector.detect_deadlock()
        
        # æ¢å¤åŸå§‹çŠ¶æ€
        self.system.resources[rid].available = original_available
        
        return len(deadlocked) > 0
    
    def detect_deadlock(self) -> List[List[int]]:
        """æ£€æµ‹æ­»é”"""
        return self.deadlock_detector.detect_deadlock()
    
    def get_system_status(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        status = self.system.get_system_state()
        status.update({
            "mutexes": len(self.mutexes),
            "semaphores": len(self.semaphores),
            "conditions": len(self.conditions),
            "deadlock_detected": len(self.detect_deadlock()) > 0
        })
        return status

## 3. æ•°å­¦è¯æ˜

### 3.1 æ­»é”å¿…è¦æ¡ä»¶

**å®šç† 3.1** (æ­»é”å¿…è¦æ¡ä»¶)
æ­»é”å‘ç”Ÿçš„å››ä¸ªå¿…è¦æ¡ä»¶æ˜¯ï¼š
1. **äº’æ–¥æ¡ä»¶**: èµ„æºä¸èƒ½è¢«å¤šä¸ªè¿›ç¨‹åŒæ—¶ä½¿ç”¨
2. **å æœ‰å’Œç­‰å¾…æ¡ä»¶**: è¿›ç¨‹å æœ‰èµ„æºçš„åŒæ—¶ç­‰å¾…å…¶ä»–èµ„æº
3. **éæŠ¢å æ¡ä»¶**: èµ„æºä¸èƒ½è¢«å¼ºåˆ¶ä»è¿›ç¨‹ä¸­å‰¥å¤º
4. **å¾ªç¯ç­‰å¾…æ¡ä»¶**: å­˜åœ¨è¿›ç¨‹ç­‰å¾…é“¾å½¢æˆç¯

**è¯æ˜**:
å¦‚æœè¿™å››ä¸ªæ¡ä»¶ä¸­ä»»ä½•ä¸€ä¸ªä¸æ»¡è¶³ï¼Œæ­»é”å°±ä¸ä¼šå‘ç”Ÿï¼š
- å¦‚æœä¸æ»¡è¶³äº’æ–¥æ¡ä»¶ï¼Œèµ„æºå¯ä»¥è¢«å…±äº«
- å¦‚æœä¸æ»¡è¶³å æœ‰å’Œç­‰å¾…æ¡ä»¶ï¼Œè¿›ç¨‹è¦ä¹ˆé‡Šæ”¾æ‰€æœ‰èµ„æºå†è¯·æ±‚
- å¦‚æœä¸æ»¡è¶³éæŠ¢å æ¡ä»¶ï¼Œå¯ä»¥å¼ºåˆ¶å‰¥å¤ºèµ„æº
- å¦‚æœä¸æ»¡è¶³å¾ªç¯ç­‰å¾…æ¡ä»¶ï¼Œç­‰å¾…é“¾ä¸ä¼šå½¢æˆç¯

### 3.2 é“¶è¡Œå®¶ç®—æ³•å®‰å…¨æ€§

**å®šç† 3.2** (é“¶è¡Œå®¶ç®—æ³•å®‰å…¨æ€§)
å¦‚æœé“¶è¡Œå®¶ç®—æ³•æ‰¾åˆ°ä¸€ä¸ªå®‰å…¨åºåˆ—ï¼Œé‚£ä¹ˆç³»ç»Ÿå¤„äºå®‰å…¨çŠ¶æ€ã€‚

**è¯æ˜**:
1. **å®‰å…¨åºåˆ—å­˜åœ¨**: å¦‚æœå­˜åœ¨å®‰å…¨åºåˆ—ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½èƒ½æŒ‰é¡ºåºå®Œæˆ
2. **èµ„æºåˆ†é…**: æ¯ä¸ªè¿›ç¨‹éƒ½èƒ½è·å¾—æ‰€éœ€èµ„æº
3. **æ— æ­»é”**: æ‰€æœ‰è¿›ç¨‹éƒ½èƒ½å®Œæˆï¼Œä¸ä¼šå‘ç”Ÿæ­»é”

### 3.3 äº’æ–¥é”æ­£ç¡®æ€§

**å®šç† 3.3** (äº’æ–¥é”æ­£ç¡®æ€§)
äº’æ–¥é”ç¡®ä¿ä¸´ç•ŒåŒºäº’æ–¥è®¿é—®ã€‚

**è¯æ˜**:
1. **å”¯ä¸€æ€§**: ä»»ä½•æ—¶å€™åªæœ‰ä¸€ä¸ªè¿›ç¨‹æŒæœ‰é”
2. **åŸå­æ€§**: é”çš„è·å–å’Œé‡Šæ”¾æ˜¯åŸå­æ“ä½œ
3. **å…¬å¹³æ€§**: ç­‰å¾…çš„è¿›ç¨‹æœ€ç»ˆä¼šè·å¾—é”

## 4. åº”ç”¨åœºæ™¯

### 4.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜

```python
class ProducerConsumer:
    """ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜"""
    
    def __init__(self, buffer_size: int):
        self.buffer_size = buffer_size
        self.buffer = queue.Queue(maxsize=buffer_size)
        self.mutex = threading.Lock()
        self.empty = threading.Semaphore(buffer_size)
        self.full = threading.Semaphore(0)
        self.produced_count = 0
        self.consumed_count = 0
    
    def producer(self, producer_id: int, items: int):
        """ç”Ÿäº§è€…"""
        for i in range(items):
            # ç­‰å¾…ç¼“å†²åŒºæœ‰ç©ºé—´
            self.empty.acquire()
            
            # è·å–äº’æ–¥é”
            with self.mutex:
                item = f"Item-{producer_id}-{i}"
                self.buffer.put(item)
                self.produced_count += 1
                print(f"Producer {producer_id} produced: {item}")
            
            # é‡Šæ”¾ä¿¡å·é‡
            self.full.release()
    
    def consumer(self, consumer_id: int, items: int):
        """æ¶ˆè´¹è€…"""
        for i in range(items):
            # ç­‰å¾…ç¼“å†²åŒºæœ‰æ•°æ®
            self.full.acquire()
            
            # è·å–äº’æ–¥é”
            with self.mutex:
                item = self.buffer.get()
                self.consumed_count += 1
                print(f"Consumer {consumer_id} consumed: {item}")
            
            # é‡Šæ”¾ä¿¡å·é‡
            self.empty.release()
    
    def run_simulation(self, num_producers: int, num_consumers: int, 
                      items_per_producer: int):
        """è¿è¡Œæ¨¡æ‹Ÿ"""
        threads = []
        
        # åˆ›å»ºç”Ÿäº§è€…çº¿ç¨‹
        for i in range(num_producers):
            thread = threading.Thread(
                target=self.producer, 
                args=(i, items_per_producer)
            )
            threads.append(thread)
        
        # åˆ›å»ºæ¶ˆè´¹è€…çº¿ç¨‹
        for i in range(num_consumers):
            thread = threading.Thread(
                target=self.consumer, 
                args=(i, items_per_producer * num_producers // num_consumers)
            )
            threads.append(thread)
        
        # å¯åŠ¨æ‰€æœ‰çº¿ç¨‹
        for thread in threads:
            thread.start()
        
        # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for thread in threads:
            thread.join()
        
        print(f"Simulation completed. Produced: {self.produced_count}, Consumed: {self.consumed_count}")

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_producer_consumer():
    """æ¼”ç¤ºç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜"""
    pc = ProducerConsumer(buffer_size=5)
    pc.run_simulation(num_producers=2, num_consumers=3, items_per_producer=10)
```

### 4.2 å“²å­¦å®¶å°±é¤é—®é¢˜

```python
class DiningPhilosophers:
    """å“²å­¦å®¶å°±é¤é—®é¢˜"""
    
    def __init__(self, num_philosophers: int):
        self.num_philosophers = num_philosophers
        self.forks = [threading.Lock() for _ in range(num_philosophers)]
        self.philosophers = []
        self.eating_times = [0] * num_philosophers
        self.thinking_times = [0] * num_philosophers
    
    def philosopher(self, philosopher_id: int):
        """å“²å­¦å®¶è¡Œä¸º"""
        left_fork = philosopher_id
        right_fork = (philosopher_id + 1) % self.num_philosophers
        
        while True:
            # æ€è€ƒ
            think_time = random.uniform(1, 3)
            time.sleep(think_time)
            self.thinking_times[philosopher_id] += think_time
            
            print(f"Philosopher {philosopher_id} is thinking")
            
            # å°è¯•è·å–å‰å­
            if philosopher_id % 2 == 0:
                # å¶æ•°å“²å­¦å®¶å…ˆæ‹¿å·¦å‰å­
                self.forks[left_fork].acquire()
                self.forks[right_fork].acquire()
            else:
                # å¥‡æ•°å“²å­¦å®¶å…ˆæ‹¿å³å‰å­
                self.forks[right_fork].acquire()
                self.forks[left_fork].acquire()
            
            # å°±é¤
            eat_time = random.uniform(1, 2)
            time.sleep(eat_time)
            self.eating_times[philosopher_id] += eat_time
            
            print(f"Philosopher {philosopher_id} is eating")
            
            # é‡Šæ”¾å‰å­
            self.forks[left_fork].release()
            self.forks[right_fork].release()
    
    def run_simulation(self, duration: float):
        """è¿è¡Œæ¨¡æ‹Ÿ"""
        threads = []
        
        # åˆ›å»ºå“²å­¦å®¶çº¿ç¨‹
        for i in range(self.num_philosophers):
            thread = threading.Thread(target=self.philosopher, args=(i,))
            thread.daemon = True  # è®¾ç½®ä¸ºå®ˆæŠ¤çº¿ç¨‹
            threads.append(thread)
        
        # å¯åŠ¨æ‰€æœ‰çº¿ç¨‹
        for thread in threads:
            thread.start()
        
        # è¿è¡ŒæŒ‡å®šæ—¶é—´
        time.sleep(duration)
        
        # æ‰“å°ç»Ÿè®¡ä¿¡æ¯
        print("\nSimulation completed. Statistics:")
        for i in range(self.num_philosophers):
            print(f"Philosopher {i}: Eating={self.eating_times[i]:.2f}s, "
                  f"Thinking={self.thinking_times[i]:.2f}s")

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_dining_philosophers():
    """æ¼”ç¤ºå“²å­¦å®¶å°±é¤é—®é¢˜"""
    dp = DiningPhilosophers(num_philosophers=5)
    dp.run_simulation(duration=10.0)
```

## 5. æ€»ç»“

å¹¶å‘ç†è®ºä¸ºè®¡ç®—æœºç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ï¼š

1. **è¿›ç¨‹ç®¡ç†**: æä¾›äº†è¿›ç¨‹è°ƒåº¦å’Œèµ„æºåˆ†é…çš„ç†è®ºåŸºç¡€
2. **åŒæ­¥æœºåˆ¶**: ä¸ºå¹¶å‘ç¨‹åºæä¾›äº†äº’æ–¥ã€åŒæ­¥å’Œé€šä¿¡æœºåˆ¶
3. **æ­»é”å¤„ç†**: æä¾›äº†æ­»é”æ£€æµ‹ã€é¢„é˜²å’Œé¿å…çš„æ–¹æ³•
4. **å¹¶å‘æ§åˆ¶**: ä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿå’Œå¹¶è¡Œè®¡ç®—æä¾›äº†ç†è®ºåŸºç¡€

å¹¶å‘ç†è®ºçš„ç ”ç©¶å°†ç»§ç»­æ¨åŠ¨åˆ†å¸ƒå¼ç³»ç»Ÿã€å¹¶è¡Œè®¡ç®—å’Œç³»ç»Ÿè®¾è®¡çš„å‘å±•ã€‚

---

**ç›¸å…³é“¾æ¥**:

- [02-01 ç®—æ³•ç†è®º](./02-01-ç®—æ³•ç†è®º.md)
- [02-02 æ•°æ®ç»“æ„ç†è®º](./02-02-æ•°æ®ç»“æ„ç†è®º.md)
- [03-02 å¹¶å‘ç¼–ç¨‹ç§‘å­¦](../03-å…·ä½“ç§‘å­¦/03-02-å¹¶å‘ç¼–ç¨‹ç§‘å­¦.md)
- [05-01 å¾®æœåŠ¡æ¶æ„](../05-æ¶æ„é¢†åŸŸ/05-01-å¾®æœåŠ¡æ¶æ„.md)
