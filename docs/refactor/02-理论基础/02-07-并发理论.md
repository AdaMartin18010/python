# 02-07 并发理论

## 📋 概述

并发理论是计算机科学中研究多进程、多线程并发执行的重要分支，为分布式系统、并行计算和系统设计提供了理论基础。本文档从形式化角度系统介绍并发理论的基本概念。

## 1. 形式化定义

### 1.1 并发系统基础

**定义 1.1** (并发系统)
并发系统是一个三元组：
$$CS = (P, R, T)$$
其中：

- $P$ 是进程集合：$P = \{p_1, p_2, ..., p_n\}$
- $R$ 是资源集合：$R = \{r_1, r_2, ..., r_m\}$
- $T$ 是转换关系集合：$T \subseteq P \times R \times P$

**定义 1.2** (进程状态)
进程 $p$ 的状态是一个三元组：
$$State(p) = (PC, Registers, Stack)$$
其中：

- $PC$ 是程序计数器
- $Registers$ 是寄存器状态
- $Stack$ 是栈状态

**定义 1.3** (系统状态)
系统状态是一个映射：
$$\sigma: P \rightarrow State(P)$$

### 1.2 并发执行模型

**定义 1.4** (交错执行)
两个进程 $p_1$ 和 $p_2$ 的交错执行定义为：
$$p_1 \parallel p_2 = \{s_1 \cdot s_2 \mid s_1 \in p_1, s_2 \in p_2\}$$

**定义 1.5** (并发执行)
并发执行满足以下性质：

1. **原子性**: 每个操作要么完全执行，要么完全不执行
2. **一致性**: 系统从一个一致状态转换到另一个一致状态
3. **隔离性**: 并发进程的执行相互独立
4. **持久性**: 已提交的操作永久保存

### 1.3 同步机制

**定义 1.6** (互斥锁)
互斥锁是一个二元状态变量：
$$Mutex = \{0, 1\}$$
其中：

- $0$ 表示未锁定状态
- $1$ 表示锁定状态

**定义 1.7** (信号量)
信号量是一个三元组：
$$Semaphore = (value, queue, operations)$$
其中：

- $value$ 是当前值
- $queue$ 是等待队列
- $operations$ 是操作集合 $\{P(), V()\}$

**定义 1.8** (条件变量)
条件变量是一个等待队列：
$$Condition = \{p_1, p_2, ..., p_n\}$$

## 2. Python实现

### 2.1 并发系统基础

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Optional, Union, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import threading
import time
import queue
import random
from collections import defaultdict, deque

class ProcessState(Enum):
    """进程状态"""
    READY = "ready"
    RUNNING = "running"
    WAITING = "waiting"
    TERMINATED = "terminated"

class ResourceType(Enum):
    """资源类型"""
    CPU = "cpu"
    MEMORY = "memory"
    DISK = "disk"
    NETWORK = "network"
    LOCK = "lock"

@dataclass
class Process:
    """进程"""
    pid: int
    name: str
    state: ProcessState = ProcessState.READY
    priority: int = 0
    arrival_time: float = 0.0
    burst_time: float = 0.0
    remaining_time: float = 0.0
    waiting_time: float = 0.0
    turnaround_time: float = 0.0
    
    def __str__(self) -> str:
        return f"Process({self.pid}: {self.name}, {self.state.value})"

@dataclass
class Resource:
    """资源"""
    rid: int
    name: str
    resource_type: ResourceType
    capacity: int
    available: int
    allocated: Dict[int, int] = field(default_factory=dict)  # pid -> amount
    
    def __str__(self) -> str:
        return f"Resource({self.rid}: {self.name}, {self.available}/{self.capacity})"

class ConcurrentSystem:
    """并发系统"""
    
    def __init__(self):
        self.processes: Dict[int, Process] = {}
        self.resources: Dict[int, Resource] = {}
        self.ready_queue: deque = deque()
        self.waiting_queue: deque = deque()
        self.running_process: Optional[Process] = None
        self.system_time: float = 0.0
        self.scheduler = None
        self.deadlock_detector = None
    
    def add_process(self, process: Process) -> None:
        """添加进程"""
        self.processes[process.pid] = process
        self.ready_queue.append(process)
    
    def add_resource(self, resource: Resource) -> None:
        """添加资源"""
        self.resources[resource.rid] = resource
    
    def allocate_resource(self, pid: int, rid: int, amount: int) -> bool:
        """分配资源"""
        if rid not in self.resources:
            return False
        
        resource = self.resources[rid]
        if resource.available >= amount:
            resource.available -= amount
            resource.allocated[pid] = resource.allocated.get(pid, 0) + amount
            return True
        return False
    
    def release_resource(self, pid: int, rid: int, amount: int) -> bool:
        """释放资源"""
        if rid not in self.resources:
            return False
        
        resource = self.resources[rid]
        if pid in resource.allocated and resource.allocated[pid] >= amount:
            resource.allocated[pid] -= amount
            resource.available += amount
            if resource.allocated[pid] == 0:
                del resource.allocated[pid]
            return True
        return False
    
    def get_system_state(self) -> Dict[str, Any]:
        """获取系统状态"""
        return {
            "time": self.system_time,
            "running_process": self.running_process,
            "ready_queue_size": len(self.ready_queue),
            "waiting_queue_size": len(self.waiting_queue),
            "total_processes": len(self.processes),
            "total_resources": len(self.resources)
        }

### 2.2 调度算法

class Scheduler(ABC):
    """调度器抽象基类"""
    
    def __init__(self, system: ConcurrentSystem):
        self.system = system
    
    @abstractmethod
    def schedule(self) -> Optional[Process]:
        """调度下一个进程"""
        pass
    
    @abstractmethod
    def add_process(self, process: Process) -> None:
        """添加进程到调度队列"""
        pass

class FCFSScheduler(Scheduler):
    """先来先服务调度器"""
    
    def __init__(self, system: ConcurrentSystem):
        super().__init__(system)
        self.queue: deque = deque()
    
    def schedule(self) -> Optional[Process]:
        """FCFS调度"""
        if self.queue:
            return self.queue.popleft()
        return None
    
    def add_process(self, process: Process) -> None:
        """添加进程"""
        self.queue.append(process)

class RoundRobinScheduler(Scheduler):
    """轮转调度器"""
    
    def __init__(self, system: ConcurrentSystem, time_quantum: float):
        super().__init__(system)
        self.queue: deque = deque()
        self.time_quantum = time_quantum
        self.current_process: Optional[Process] = None
        self.remaining_quantum: float = time_quantum
    
    def schedule(self) -> Optional[Process]:
        """轮转调度"""
        if self.current_process and self.remaining_quantum > 0:
            return self.current_process
        
        if self.current_process:
            self.queue.append(self.current_process)
        
        if self.queue:
            self.current_process = self.queue.popleft()
            self.remaining_quantum = self.time_quantum
            return self.current_process
        
        return None
    
    def add_process(self, process: Process) -> None:
        """添加进程"""
        if not self.current_process:
            self.current_process = process
            self.remaining_quantum = self.time_quantum
        else:
            self.queue.append(process)
    
    def update_quantum(self, time_used: float) -> None:
        """更新剩余时间片"""
        self.remaining_quantum -= time_used

class PriorityScheduler(Scheduler):
    """优先级调度器"""
    
    def __init__(self, system: ConcurrentSystem):
        super().__init__(system)
        self.queues: Dict[int, deque] = defaultdict(deque)
        self.max_priority = 0
    
    def schedule(self) -> Optional[Process]:
        """优先级调度"""
        for priority in range(self.max_priority, -1, -1):
            if priority in self.queues and self.queues[priority]:
                return self.queues[priority].popleft()
        return None
    
    def add_process(self, process: Process) -> None:
        """添加进程"""
        self.queues[process.priority].append(process)
        self.max_priority = max(self.max_priority, process.priority)

### 2.3 同步机制

class Mutex:
    """互斥锁"""
    
    def __init__(self):
        self.locked = False
        self.owner: Optional[int] = None
        self.waiting_queue: deque = deque()
    
    def acquire(self, pid: int) -> bool:
        """获取锁"""
        if not self.locked:
            self.locked = True
            self.owner = pid
            return True
        else:
            self.waiting_queue.append(pid)
            return False
    
    def release(self, pid: int) -> bool:
        """释放锁"""
        if self.owner == pid:
            self.locked = False
            self.owner = None
            
            # 唤醒等待的进程
            if self.waiting_queue:
                next_pid = self.waiting_queue.popleft()
                self.locked = True
                self.owner = next_pid
            
            return True
        return False
    
    def is_locked(self) -> bool:
        """检查是否被锁定"""
        return self.locked

class Semaphore:
    """信号量"""
    
    def __init__(self, initial_value: int):
        self.value = initial_value
        self.waiting_queue: deque = deque()
    
    def P(self, pid: int) -> bool:
        """P操作（等待）"""
        if self.value > 0:
            self.value -= 1
            return True
        else:
            self.waiting_queue.append(pid)
            return False
    
    def V(self) -> Optional[int]:
        """V操作（释放）"""
        if self.waiting_queue:
            # 唤醒等待的进程
            return self.waiting_queue.popleft()
        else:
            self.value += 1
            return None
    
    def get_value(self) -> int:
        """获取当前值"""
        return self.value

class ConditionVariable:
    """条件变量"""
    
    def __init__(self):
        self.waiting_queue: deque = deque()
    
    def wait(self, pid: int) -> None:
        """等待"""
        self.waiting_queue.append(pid)
    
    def signal(self) -> Optional[int]:
        """唤醒一个等待的进程"""
        if self.waiting_queue:
            return self.waiting_queue.popleft()
        return None
    
    def broadcast(self) -> List[int]:
        """唤醒所有等待的进程"""
        woken_processes = list(self.waiting_queue)
        self.waiting_queue.clear()
        return woken_processes

### 2.4 死锁检测

class DeadlockDetector:
    """死锁检测器"""
    
    def __init__(self, system: ConcurrentSystem):
        self.system = system
    
    def detect_deadlock(self) -> List[List[int]]:
        """检测死锁"""
        # 构建资源分配图
        allocation_matrix = self._build_allocation_matrix()
        request_matrix = self._build_request_matrix()
        available_resources = self._get_available_resources()
        
        # 使用银行家算法检测死锁
        return self._bankers_algorithm(allocation_matrix, request_matrix, available_resources)
    
    def _build_allocation_matrix(self) -> List[List[int]]:
        """构建分配矩阵"""
        processes = list(self.system.processes.keys())
        resources = list(self.system.resources.keys())
        
        matrix = [[0] * len(resources) for _ in range(len(processes))]
        
        for i, pid in enumerate(processes):
            for j, rid in enumerate(resources):
                if rid in self.system.resources:
                    matrix[i][j] = self.system.resources[rid].allocated.get(pid, 0)
        
        return matrix
    
    def _build_request_matrix(self) -> List[List[int]]:
        """构建请求矩阵（简化实现）"""
        processes = list(self.system.processes.keys())
        resources = list(self.system.resources.keys())
        
        # 简化实现：假设所有进程都可能请求所有资源
        matrix = [[1] * len(resources) for _ in range(len(processes))]
        return matrix
    
    def _get_available_resources(self) -> List[int]:
        """获取可用资源向量"""
        resources = list(self.system.resources.keys())
        available = []
        
        for rid in resources:
            available.append(self.system.resources[rid].available)
        
        return available
    
    def _bankers_algorithm(self, allocation: List[List[int]], 
                          request: List[List[int]], 
                          available: List[int]) -> List[List[int]]:
        """银行家算法"""
        n_processes = len(allocation)
        n_resources = len(available)
        
        # 工作向量
        work = available.copy()
        
        # 完成向量
        finish = [False] * n_processes
        
        # 安全序列
        safe_sequence = []
        
        # 查找可以完成的进程
        while len(safe_sequence) < n_processes:
            found = False
            
            for i in range(n_processes):
                if not finish[i]:
                    # 检查进程i是否可以完成
                    can_allocate = True
                    for j in range(n_resources):
                        if request[i][j] > work[j]:
                            can_allocate = False
                            break
                    
                    if can_allocate:
                        # 分配资源给进程i
                        for j in range(n_resources):
                            work[j] += allocation[i][j]
                        
                        finish[i] = True
                        safe_sequence.append(i)
                        found = True
            
            if not found:
                # 没有找到可以完成的进程，存在死锁
                break
        
        # 检查是否存在死锁
        deadlocked_processes = []
        for i in range(n_processes):
            if not finish[i]:
                deadlocked_processes.append(i)
        
        return [deadlocked_processes] if deadlocked_processes else []

class ResourceAllocationGraph:
    """资源分配图"""
    
    def __init__(self):
        self.processes: Set[int] = set()
        self.resources: Set[int] = set()
        self.edges: List[Tuple[int, int, str]] = []  # (from, to, type)
    
    def add_process(self, pid: int) -> None:
        """添加进程"""
        self.processes.add(pid)
    
    def add_resource(self, rid: int) -> None:
        """添加资源"""
        self.resources.add(rid)
    
    def add_allocation_edge(self, pid: int, rid: int) -> None:
        """添加分配边"""
        self.edges.append((pid, rid, "allocation"))
    
    def add_request_edge(self, pid: int, rid: int) -> None:
        """添加请求边"""
        self.edges.append((pid, rid, "request"))
    
    def detect_cycle(self) -> List[int]:
        """检测环（简化实现）"""
        # 使用深度优先搜索检测环
        visited = set()
        rec_stack = set()
        
        def dfs(node: int, path: List[int]) -> Optional[List[int]]:
            if node in rec_stack:
                # 找到环
                cycle_start = path.index(node)
                return path[cycle_start:]
            
            if node in visited:
                return None
            
            visited.add(node)
            rec_stack.add(node)
            path.append(node)
            
            # 查找相邻节点
            for edge in self.edges:
                if edge[0] == node:
                    result = dfs(edge[1], path.copy())
                    if result:
                        return result
            
            rec_stack.remove(node)
            return None
        
        # 从每个节点开始搜索
        for node in self.processes | self.resources:
            if node not in visited:
                result = dfs(node, [])
                if result:
                    return result
        
        return []

### 2.5 并发控制

class ConcurrentController:
    """并发控制器"""
    
    def __init__(self, system: ConcurrentSystem):
        self.system = system
        self.mutexes: Dict[str, Mutex] = {}
        self.semaphores: Dict[str, Semaphore] = {}
        self.conditions: Dict[str, ConditionVariable] = {}
        self.deadlock_detector = DeadlockDetector(system)
        self.resource_graph = ResourceAllocationGraph()
    
    def create_mutex(self, name: str) -> Mutex:
        """创建互斥锁"""
        mutex = Mutex()
        self.mutexes[name] = mutex
        return mutex
    
    def create_semaphore(self, name: str, initial_value: int) -> Semaphore:
        """创建信号量"""
        semaphore = Semaphore(initial_value)
        self.semaphores[name] = semaphore
        return semaphore
    
    def create_condition(self, name: str) -> ConditionVariable:
        """创建条件变量"""
        condition = ConditionVariable()
        self.conditions[name] = condition
        return condition
    
    def acquire_resource(self, pid: int, rid: int, amount: int) -> bool:
        """获取资源"""
        # 更新资源分配图
        self.resource_graph.add_process(pid)
        self.resource_graph.add_resource(rid)
        self.resource_graph.add_request_edge(pid, rid)
        
        # 检查是否会导致死锁
        if self._would_cause_deadlock(pid, rid, amount):
            return False
        
        # 分配资源
        success = self.system.allocate_resource(pid, rid, amount)
        if success:
            # 更新资源分配图
            self.resource_graph.add_allocation_edge(pid, rid)
        
        return success
    
    def release_resource(self, pid: int, rid: int, amount: int) -> bool:
        """释放资源"""
        return self.system.release_resource(pid, rid, amount)
    
    def _would_cause_deadlock(self, pid: int, rid: int, amount: int) -> bool:
        """检查是否会导致死锁"""
        # 临时分配资源
        original_available = self.system.resources[rid].available
        self.system.resources[rid].available -= amount
        
        # 检测死锁
        deadlocked = self.deadlock_detector.detect_deadlock()
        
        # 恢复原始状态
        self.system.resources[rid].available = original_available
        
        return len(deadlocked) > 0
    
    def detect_deadlock(self) -> List[List[int]]:
        """检测死锁"""
        return self.deadlock_detector.detect_deadlock()
    
    def get_system_status(self) -> Dict[str, Any]:
        """获取系统状态"""
        status = self.system.get_system_state()
        status.update({
            "mutexes": len(self.mutexes),
            "semaphores": len(self.semaphores),
            "conditions": len(self.conditions),
            "deadlock_detected": len(self.detect_deadlock()) > 0
        })
        return status

## 3. 数学证明

### 3.1 死锁必要条件

**定理 3.1** (死锁必要条件)
死锁发生的四个必要条件是：
1. **互斥条件**: 资源不能被多个进程同时使用
2. **占有和等待条件**: 进程占有资源的同时等待其他资源
3. **非抢占条件**: 资源不能被强制从进程中剥夺
4. **循环等待条件**: 存在进程等待链形成环

**证明**:
如果这四个条件中任何一个不满足，死锁就不会发生：
- 如果不满足互斥条件，资源可以被共享
- 如果不满足占有和等待条件，进程要么释放所有资源再请求
- 如果不满足非抢占条件，可以强制剥夺资源
- 如果不满足循环等待条件，等待链不会形成环

### 3.2 银行家算法安全性

**定理 3.2** (银行家算法安全性)
如果银行家算法找到一个安全序列，那么系统处于安全状态。

**证明**:
1. **安全序列存在**: 如果存在安全序列，每个进程都能按顺序完成
2. **资源分配**: 每个进程都能获得所需资源
3. **无死锁**: 所有进程都能完成，不会发生死锁

### 3.3 互斥锁正确性

**定理 3.3** (互斥锁正确性)
互斥锁确保临界区互斥访问。

**证明**:
1. **唯一性**: 任何时候只有一个进程持有锁
2. **原子性**: 锁的获取和释放是原子操作
3. **公平性**: 等待的进程最终会获得锁

## 4. 应用场景

### 4.1 生产者-消费者问题

```python
class ProducerConsumer:
    """生产者-消费者问题"""
    
    def __init__(self, buffer_size: int):
        self.buffer_size = buffer_size
        self.buffer = queue.Queue(maxsize=buffer_size)
        self.mutex = threading.Lock()
        self.empty = threading.Semaphore(buffer_size)
        self.full = threading.Semaphore(0)
        self.produced_count = 0
        self.consumed_count = 0
    
    def producer(self, producer_id: int, items: int):
        """生产者"""
        for i in range(items):
            # 等待缓冲区有空间
            self.empty.acquire()
            
            # 获取互斥锁
            with self.mutex:
                item = f"Item-{producer_id}-{i}"
                self.buffer.put(item)
                self.produced_count += 1
                print(f"Producer {producer_id} produced: {item}")
            
            # 释放信号量
            self.full.release()
    
    def consumer(self, consumer_id: int, items: int):
        """消费者"""
        for i in range(items):
            # 等待缓冲区有数据
            self.full.acquire()
            
            # 获取互斥锁
            with self.mutex:
                item = self.buffer.get()
                self.consumed_count += 1
                print(f"Consumer {consumer_id} consumed: {item}")
            
            # 释放信号量
            self.empty.release()
    
    def run_simulation(self, num_producers: int, num_consumers: int, 
                      items_per_producer: int):
        """运行模拟"""
        threads = []
        
        # 创建生产者线程
        for i in range(num_producers):
            thread = threading.Thread(
                target=self.producer, 
                args=(i, items_per_producer)
            )
            threads.append(thread)
        
        # 创建消费者线程
        for i in range(num_consumers):
            thread = threading.Thread(
                target=self.consumer, 
                args=(i, items_per_producer * num_producers // num_consumers)
            )
            threads.append(thread)
        
        # 启动所有线程
        for thread in threads:
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        print(f"Simulation completed. Produced: {self.produced_count}, Consumed: {self.consumed_count}")

# 使用示例
def demonstrate_producer_consumer():
    """演示生产者-消费者问题"""
    pc = ProducerConsumer(buffer_size=5)
    pc.run_simulation(num_producers=2, num_consumers=3, items_per_producer=10)
```

### 4.2 哲学家就餐问题

```python
class DiningPhilosophers:
    """哲学家就餐问题"""
    
    def __init__(self, num_philosophers: int):
        self.num_philosophers = num_philosophers
        self.forks = [threading.Lock() for _ in range(num_philosophers)]
        self.philosophers = []
        self.eating_times = [0] * num_philosophers
        self.thinking_times = [0] * num_philosophers
    
    def philosopher(self, philosopher_id: int):
        """哲学家行为"""
        left_fork = philosopher_id
        right_fork = (philosopher_id + 1) % self.num_philosophers
        
        while True:
            # 思考
            think_time = random.uniform(1, 3)
            time.sleep(think_time)
            self.thinking_times[philosopher_id] += think_time
            
            print(f"Philosopher {philosopher_id} is thinking")
            
            # 尝试获取叉子
            if philosopher_id % 2 == 0:
                # 偶数哲学家先拿左叉子
                self.forks[left_fork].acquire()
                self.forks[right_fork].acquire()
            else:
                # 奇数哲学家先拿右叉子
                self.forks[right_fork].acquire()
                self.forks[left_fork].acquire()
            
            # 就餐
            eat_time = random.uniform(1, 2)
            time.sleep(eat_time)
            self.eating_times[philosopher_id] += eat_time
            
            print(f"Philosopher {philosopher_id} is eating")
            
            # 释放叉子
            self.forks[left_fork].release()
            self.forks[right_fork].release()
    
    def run_simulation(self, duration: float):
        """运行模拟"""
        threads = []
        
        # 创建哲学家线程
        for i in range(self.num_philosophers):
            thread = threading.Thread(target=self.philosopher, args=(i,))
            thread.daemon = True  # 设置为守护线程
            threads.append(thread)
        
        # 启动所有线程
        for thread in threads:
            thread.start()
        
        # 运行指定时间
        time.sleep(duration)
        
        # 打印统计信息
        print("\nSimulation completed. Statistics:")
        for i in range(self.num_philosophers):
            print(f"Philosopher {i}: Eating={self.eating_times[i]:.2f}s, "
                  f"Thinking={self.thinking_times[i]:.2f}s")

# 使用示例
def demonstrate_dining_philosophers():
    """演示哲学家就餐问题"""
    dp = DiningPhilosophers(num_philosophers=5)
    dp.run_simulation(duration=10.0)
```

## 5. 总结

并发理论为计算机科学提供了重要的理论基础：

1. **进程管理**: 提供了进程调度和资源分配的理论基础
2. **同步机制**: 为并发程序提供了互斥、同步和通信机制
3. **死锁处理**: 提供了死锁检测、预防和避免的方法
4. **并发控制**: 为分布式系统和并行计算提供了理论基础

并发理论的研究将继续推动分布式系统、并行计算和系统设计的发展。

---

**相关链接**:

- [02-01 算法理论](./02-01-算法理论.md)
- [02-02 数据结构理论](./02-02-数据结构理论.md)
- [03-02 并发编程科学](../03-具体科学/03-02-并发编程科学.md)
- [05-01 微服务架构](../05-架构领域/05-01-微服务架构.md)
