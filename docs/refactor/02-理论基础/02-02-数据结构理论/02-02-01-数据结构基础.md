# æ•°æ®ç»“æ„åŸºç¡€

## ğŸ“š æ¦‚è¿°

æ•°æ®ç»“æ„ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒåŸºç¡€ï¼Œç ”ç©¶æ•°æ®çš„ç»„ç»‡ã€å­˜å‚¨å’Œæ“ä½œæ–¹å¼ã€‚æœ¬æ–‡æ¡£ä»ç†è®ºåŸºç¡€çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»æ•°æ®ç»“æ„ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æ•°æ®ç»“æ„çš„æŠ½è±¡å®šä¹‰

#### 1.1 æ•°æ®ç»“æ„çš„æ•°å­¦å®šä¹‰

æ•°æ®ç»“æ„å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$DS = (D, O, C)$$

å…¶ä¸­ï¼š

- $D$ æ˜¯æ•°æ®åŸŸ
- $O$ æ˜¯æ“ä½œé›†åˆ
- $C$ æ˜¯çº¦æŸæ¡ä»¶

æ¯ä¸ªæ“ä½œ $op \in O$ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$op: D^n \rightarrow D \times \text{Result}$$

#### 1.2 æ•°æ®ç»“æ„çš„Pythonå®ç°

```python
from typing import Any, List, Dict, Set, Optional, Callable, Generic, TypeVar
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
import time

T = TypeVar('T')

class OperationType(Enum):
    """æ“ä½œç±»å‹æšä¸¾"""
    INSERT = "insert"
    DELETE = "delete"
    SEARCH = "search"
    UPDATE = "update"
    TRAVERSE = "traverse"

@dataclass
class Operation:
    """æ•°æ®ç»“æ„æ“ä½œ"""
    name: str
    type: OperationType
    parameters: List[Any] = field(default_factory=list)
    result: Any = None
    execution_time: float = 0.0

@dataclass
class DataStructureMetrics:
    """æ•°æ®ç»“æ„æ€§èƒ½æŒ‡æ ‡"""
    space_complexity: str
    time_complexity: Dict[str, str]
    operation_count: int = 0
    total_time: float = 0.0

class DataStructure(ABC, Generic[T]):
    """æŠ½è±¡æ•°æ®ç»“æ„åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.metrics = DataStructureMetrics(
            space_complexity="O(1)",
            time_complexity={}
        )
        self.operations: List[Operation] = []
    
    @abstractmethod
    def insert(self, item: T) -> bool:
        """æ’å…¥å…ƒç´ """
        pass
    
    @abstractmethod
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        pass
    
    @abstractmethod
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        pass
    
    @abstractmethod
    def size(self) -> int:
        """è·å–å¤§å°"""
        pass
    
    @abstractmethod
    def is_empty(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç©º"""
        pass
    
    def execute_operation(self, op_type: OperationType, 
                         func: Callable, *args, **kwargs) -> Any:
        """æ‰§è¡Œæ“ä½œå¹¶è®°å½•æŒ‡æ ‡"""
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            operation = Operation(
                name=func.__name__,
                type=op_type,
                parameters=list(args),
                result=result,
                execution_time=execution_time
            )
            
            self.operations.append(operation)
            self.metrics.operation_count += 1
            self.metrics.total_time += execution_time
            
            return result
        
        except Exception as e:
            execution_time = time.time() - start_time
            self.metrics.total_time += execution_time
            raise e
    
    def get_average_operation_time(self) -> float:
        """è·å–å¹³å‡æ“ä½œæ—¶é—´"""
        if self.metrics.operation_count == 0:
            return 0.0
        return self.metrics.total_time / self.metrics.operation_count
    
    def get_operation_statistics(self) -> Dict[str, Any]:
        """è·å–æ“ä½œç»Ÿè®¡ä¿¡æ¯"""
        if not self.operations:
            return {}
        
        op_types = {}
        for op in self.operations:
            op_type = op.type.value
            if op_type not in op_types:
                op_types[op_type] = {
                    'count': 0,
                    'total_time': 0.0,
                    'avg_time': 0.0
                }
            
            op_types[op_type]['count'] += 1
            op_types[op_type]['total_time'] += op.execution_time
        
        # è®¡ç®—å¹³å‡æ—¶é—´
        for op_type in op_types:
            count = op_types[op_type]['count']
            total_time = op_types[op_type]['total_time']
            op_types[op_type]['avg_time'] = total_time / count
        
        return op_types

class LinearDataStructure(DataStructure[T]):
    """çº¿æ€§æ•°æ®ç»“æ„åŸºç±»"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.elements: List[T] = []
    
    def size(self) -> int:
        return len(self.elements)
    
    def is_empty(self) -> bool:
        return len(self.elements) == 0
    
    def clear(self):
        """æ¸…ç©ºæ•°æ®ç»“æ„"""
        self.elements.clear()
    
    def to_list(self) -> List[T]:
        """è½¬æ¢ä¸ºåˆ—è¡¨"""
        return self.elements.copy()
    
    def __str__(self) -> str:
        return f"{self.name}: {self.elements}"

# ä½¿ç”¨ç¤ºä¾‹
class SimpleList(LinearDataStructure[int]):
    """ç®€å•åˆ—è¡¨å®ç°"""
    
    def __init__(self):
        super().__init__("SimpleList")
        self.metrics.space_complexity = "O(n)"
        self.metrics.time_complexity = {
            "insert": "O(1)",
            "delete": "O(n)",
            "search": "O(n)"
        }
    
    def insert(self, item: int) -> bool:
        return self.execute_operation(
            OperationType.INSERT,
            self._insert_impl,
            item
        )
    
    def _insert_impl(self, item: int) -> bool:
        self.elements.append(item)
        return True
    
    def delete(self, item: int) -> bool:
        return self.execute_operation(
            OperationType.DELETE,
            self._delete_impl,
            item
        )
    
    def _delete_impl(self, item: int) -> bool:
        try:
            self.elements.remove(item)
            return True
        except ValueError:
            return False
    
    def search(self, item: int) -> Optional[int]:
        return self.execute_operation(
            OperationType.SEARCH,
            self._search_impl,
            item
        )
    
    def _search_impl(self, item: int) -> Optional[int]:
        try:
            index = self.elements.index(item)
            return self.elements[index]
        except ValueError:
            return None

# æµ‹è¯•æ•°æ®ç»“æ„
simple_list = SimpleList()
simple_list.insert(1)
simple_list.insert(2)
simple_list.insert(3)

print(f"æ•°æ®ç»“æ„: {simple_list}")
print(f"å¤§å°: {simple_list.size()}")
print(f"æœç´¢2: {simple_list.search(2)}")
print(f"åˆ é™¤2: {simple_list.delete(2)}")
print(f"åˆ é™¤å: {simple_list}")

# æ€§èƒ½ç»Ÿè®¡
stats = simple_list.get_operation_statistics()
print(f"æ“ä½œç»Ÿè®¡: {stats}")
print(f"å¹³å‡æ“ä½œæ—¶é—´: {simple_list.get_average_operation_time():.6f}s")
```

### 2. çº¿æ€§æ•°æ®ç»“æ„

#### 2.1 æ ˆï¼ˆStackï¼‰

```python
class Stack(LinearDataStructure[T]):
    """æ ˆæ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("Stack")
        self.metrics.space_complexity = "O(n)"
        self.metrics.time_complexity = {
            "push": "O(1)",
            "pop": "O(1)",
            "peek": "O(1)",
            "search": "O(n)"
        }
    
    def push(self, item: T) -> bool:
        """å…¥æ ˆ"""
        return self.execute_operation(
            OperationType.INSERT,
            self._push_impl,
            item
        )
    
    def _push_impl(self, item: T) -> bool:
        self.elements.append(item)
        return True
    
    def pop(self) -> Optional[T]:
        """å‡ºæ ˆ"""
        return self.execute_operation(
            OperationType.DELETE,
            self._pop_impl
        )
    
    def _pop_impl(self) -> Optional[T]:
        if self.is_empty():
            return None
        return self.elements.pop()
    
    def peek(self) -> Optional[T]:
        """æŸ¥çœ‹æ ˆé¡¶å…ƒç´ """
        if self.is_empty():
            return None
        return self.elements[-1]
    
    def insert(self, item: T) -> bool:
        """æ’å…¥ï¼ˆå…¥æ ˆï¼‰"""
        return self.push(item)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤ï¼ˆå‡ºæ ˆï¼‰"""
        popped = self.pop()
        return popped is not None
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        return self.execute_operation(
            OperationType.SEARCH,
            self._search_impl,
            item
        )
    
    def _search_impl(self, item: T) -> Optional[T]:
        try:
            index = self.elements.index(item)
            return self.elements[index]
        except ValueError:
            return None
    
    def __str__(self) -> str:
        return f"Stack: {self.elements} (top -> bottom)"

class Queue(LinearDataStructure[T]):
    """é˜Ÿåˆ—æ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("Queue")
        self.metrics.space_complexity = "O(n)"
        self.metrics.time_complexity = {
            "enqueue": "O(1)",
            "dequeue": "O(1)",
            "front": "O(1)",
            "search": "O(n)"
        }
    
    def enqueue(self, item: T) -> bool:
        """å…¥é˜Ÿ"""
        return self.execute_operation(
            OperationType.INSERT,
            self._enqueue_impl,
            item
        )
    
    def _enqueue_impl(self, item: T) -> bool:
        self.elements.append(item)
        return True
    
    def dequeue(self) -> Optional[T]:
        """å‡ºé˜Ÿ"""
        return self.execute_operation(
            OperationType.DELETE,
            self._dequeue_impl
        )
    
    def _dequeue_impl(self) -> Optional[T]:
        if self.is_empty():
            return None
        return self.elements.pop(0)
    
    def front(self) -> Optional[T]:
        """æŸ¥çœ‹é˜Ÿé¦–å…ƒç´ """
        if self.is_empty():
            return None
        return self.elements[0]
    
    def insert(self, item: T) -> bool:
        """æ’å…¥ï¼ˆå…¥é˜Ÿï¼‰"""
        return self.enqueue(item)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤ï¼ˆå‡ºé˜Ÿï¼‰"""
        dequeued = self.dequeue()
        return dequeued is not None
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        return self.execute_operation(
            OperationType.SEARCH,
            self._search_impl,
            item
        )
    
    def _search_impl(self, item: T) -> Optional[T]:
        try
            index = self.elements.index(item)
            return self.elements[index]
        except ValueError:
            return None
    
    def __str__(self) -> str:
        return f"Queue: {self.elements} (front -> rear)"

# ä½¿ç”¨ç¤ºä¾‹
# æ ˆæ“ä½œ
stack = Stack[int]()
stack.push(1)
stack.push(2)
stack.push(3)

print(f"æ ˆ: {stack}")
print(f"æ ˆé¡¶: {stack.peek()}")
print(f"å‡ºæ ˆ: {stack.pop()}")
print(f"å‡ºæ ˆå: {stack}")

# é˜Ÿåˆ—æ“ä½œ
queue = Queue[int]()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)

print(f"é˜Ÿåˆ—: {queue}")
print(f"é˜Ÿé¦–: {queue.front()}")
print(f"å‡ºé˜Ÿ: {queue.dequeue()}")
print(f"å‡ºé˜Ÿå: {queue}")
```

#### 2.2 é“¾è¡¨ï¼ˆLinked Listï¼‰

```python
@dataclass
class Node(Generic[T]):
    """é“¾è¡¨èŠ‚ç‚¹"""
    data: T
    next: Optional['Node[T]'] = None
    
    def __str__(self) -> str:
        return str(self.data)

class LinkedList(DataStructure[T]):
    """é“¾è¡¨æ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("LinkedList")
        self.head: Optional[Node[T]] = None
        self.tail: Optional[Node[T]] = None
        self._size = 0
        
        self.metrics.space_complexity = "O(n)"
        self.metrics.time_complexity = {
            "insert_at_head": "O(1)",
            "insert_at_tail": "O(1)",
            "insert_at_position": "O(n)",
            "delete": "O(n)",
            "search": "O(n)",
            "access": "O(n)"
        }
    
    def insert_at_head(self, item: T) -> bool:
        """åœ¨å¤´éƒ¨æ’å…¥"""
        return self.execute_operation(
            OperationType.INSERT,
            self._insert_at_head_impl,
            item
        )
    
    def _insert_at_head_impl(self, item: T) -> bool:
        new_node = Node(item, self.head)
        self.head = new_node
        
        if self.tail is None:
            self.tail = new_node
        
        self._size += 1
        return True
    
    def insert_at_tail(self, item: T) -> bool:
        """åœ¨å°¾éƒ¨æ’å…¥"""
        return self.execute_operation(
            OperationType.INSERT,
            self._insert_at_tail_impl,
            item
        )
    
    def _insert_at_tail_impl(self, item: T) -> bool:
        new_node = Node(item)
        
        if self.tail is None:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
        
        self._size += 1
        return True
    
    def insert_at_position(self, item: T, position: int) -> bool:
        """åœ¨æŒ‡å®šä½ç½®æ’å…¥"""
        return self.execute_operation(
            OperationType.INSERT,
            self._insert_at_position_impl,
            item,
            position
        )
    
    def _insert_at_position_impl(self, item: T, position: int) -> bool:
        if position < 0 or position > self._size:
            return False
        
        if position == 0:
            return self._insert_at_head_impl(item)
        
        if position == self._size:
            return self._insert_at_tail_impl(item)
        
        current = self.head
        for _ in range(position - 1):
            current = current.next
        
        new_node = Node(item, current.next)
        current.next = new_node
        self._size += 1
        return True
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤å…ƒç´ """
        return self.execute_operation(
            OperationType.DELETE,
            self._delete_impl,
            item
        )
    
    def _delete_impl(self, item: T) -> bool:
        if self.head is None:
            return False
        
        # åˆ é™¤å¤´èŠ‚ç‚¹
        if self.head.data == item:
            self.head = self.head.next
            if self.head is None:
                self.tail = None
            self._size -= 1
            return True
        
        # åˆ é™¤å…¶ä»–èŠ‚ç‚¹
        current = self.head
        while current.next is not None:
            if current.next.data == item:
                current.next = current.next.next
                if current.next is None:
                    self.tail = current
                self._size -= 1
                return True
            current = current.next
        
        return False
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢å…ƒç´ """
        return self.execute_operation(
            OperationType.SEARCH,
            self._search_impl,
            item
        )
    
    def _search_impl(self, item: T) -> Optional[T]:
        current = self.head
        while current is not None:
            if current.data == item:
                return current.data
            current = current.next
        return None
    
    def get_at_position(self, position: int) -> Optional[T]:
        """è·å–æŒ‡å®šä½ç½®çš„å…ƒç´ """
        if position < 0 or position >= self._size:
            return None
        
        current = self.head
        for _ in range(position):
            current = current.next
        
        return current.data
    
    def size(self) -> int:
        return self._size
    
    def is_empty(self) -> bool:
        return self._size == 0
    
    def reverse(self):
        """åè½¬é“¾è¡¨"""
        prev = None
        current = self.head
        
        while current is not None:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        
        self.tail = self.head
        self.head = prev
    
    def to_list(self) -> List[T]:
        """è½¬æ¢ä¸ºåˆ—è¡¨"""
        result = []
        current = self.head
        while current is not None:
            result.append(current.data)
            current = current.next
        return result
    
    def __str__(self) -> str:
        elements = self.to_list()
        return f"LinkedList: {' -> '.join(map(str, elements))}"

# ä½¿ç”¨ç¤ºä¾‹
linked_list = LinkedList[int]()
linked_list.insert_at_head(1)
linked_list.insert_at_tail(3)
linked_list.insert_at_position(2, 1)

print(f"é“¾è¡¨: {linked_list}")
print(f"å¤§å°: {linked_list.size()}")
print(f"ä½ç½®1çš„å…ƒç´ : {linked_list.get_at_position(1)}")
print(f"æœç´¢2: {linked_list.search(2)}")

linked_list.reverse()
print(f"åè½¬å: {linked_list}")

linked_list.delete(2)
print(f"åˆ é™¤2å: {linked_list}")
```

### 3. éçº¿æ€§æ•°æ®ç»“æ„

#### 3.1 æ ‘ï¼ˆTreeï¼‰

```python
@dataclass
class TreeNode(Generic[T]):
    """æ ‘èŠ‚ç‚¹"""
    data: T
    children: List['TreeNode[T]'] = field(default_factory=list)
    parent: Optional['TreeNode[T]'] = None
    
    def add_child(self, child: 'TreeNode[T]'):
        """æ·»åŠ å­èŠ‚ç‚¹"""
        child.parent = self
        self.children.append(child)
    
    def remove_child(self, child: 'TreeNode[T]'):
        """ç§»é™¤å­èŠ‚ç‚¹"""
        if child in self.children:
            child.parent = None
            self.children.remove(child)
    
    def is_leaf(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¶å­èŠ‚ç‚¹"""
        return len(self.children) == 0
    
    def get_height(self) -> int:
        """è·å–èŠ‚ç‚¹é«˜åº¦"""
        if self.is_leaf():
            return 0
        
        return 1 + max(child.get_height() for child in self.children)
    
    def get_depth(self) -> int:
        """è·å–èŠ‚ç‚¹æ·±åº¦"""
        if self.parent is None:
            return 0
        return 1 + self.parent.get_depth()

class Tree(DataStructure[T]):
    """æ ‘æ•°æ®ç»“æ„"""
    
    def __init__(self):
        super().__init__("Tree")
        self.root: Optional[TreeNode[T]] = None
        self._size = 0
        
        self.metrics.space_complexity = "O(n)"
        self.metrics.time_complexity = {
            "insert": "O(1)",
            "delete": "O(n)",
            "search": "O(n)",
            "traverse": "O(n)"
        }
    
    def insert(self, item: T, parent_data: Optional[T] = None) -> bool:
        """æ’å…¥èŠ‚ç‚¹"""
        return self.execute_operation(
            OperationType.INSERT,
            self._insert_impl,
            item,
            parent_data
        )
    
    def _insert_impl(self, item: T, parent_data: Optional[T] = None) -> bool:
        new_node = TreeNode(item)
        
        if self.root is None:
            self.root = new_node
        elif parent_data is None:
            # æ’å…¥ä¸ºæ ¹èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
            self.root.add_child(new_node)
        else:
            # æŸ¥æ‰¾çˆ¶èŠ‚ç‚¹
            parent_node = self._find_node(parent_data)
            if parent_node is None:
                return False
            parent_node.add_child(new_node)
        
        self._size += 1
        return True
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤èŠ‚ç‚¹"""
        return self.execute_operation(
            OperationType.DELETE,
            self._delete_impl,
            item
        )
    
    def _delete_impl(self, item: T) -> bool:
        if self.root is None:
            return False
        
        if self.root.data == item:
            # åˆ é™¤æ ¹èŠ‚ç‚¹
            if len(self.root.children) == 0:
                self.root = None
            elif len(self.root.children) == 1:
                self.root = self.root.children[0]
                self.root.parent = None
            else:
                # æ ¹èŠ‚ç‚¹æœ‰å¤šä¸ªå­èŠ‚ç‚¹ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹
                new_root = self.root.children[0]
                new_root.parent = None
                for child in self.root.children[1:]:
                    new_root.add_child(child)
                self.root = new_root
            
            self._size -= 1
            return True
        
        # åˆ é™¤éæ ¹èŠ‚ç‚¹
        node = self._find_node(item)
        if node is None:
            return False
        
        if node.parent is not None:
            node.parent.remove_child(node)
            # å°†å­èŠ‚ç‚¹æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹
            for child in node.children:
                node.parent.add_child(child)
        
        self._size -= 1
        return True
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢èŠ‚ç‚¹"""
        return self.execute_operation(
            OperationType.SEARCH,
            self._search_impl,
            item
        )
    
    def _search_impl(self, item: T) -> Optional[T]:
        node = self._find_node(item)
        return node.data if node else None
    
    def _find_node(self, item: T) -> Optional[TreeNode[T]]:
        """æŸ¥æ‰¾èŠ‚ç‚¹"""
        if self.root is None:
            return None
        
        return self._find_node_recursive(self.root, item)
    
    def _find_node_recursive(self, node: TreeNode[T], item: T) -> Optional[TreeNode[T]]:
        """é€’å½’æŸ¥æ‰¾èŠ‚ç‚¹"""
        if node.data == item:
            return node
        
        for child in node.children:
            result = self._find_node_recursive(child, item)
            if result is not None:
                return result
        
        return None
    
    def traverse_preorder(self) -> List[T]:
        """å‰åºéå†"""
        result = []
        if self.root is not None:
            self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node: TreeNode[T], result: List[T]):
        """é€’å½’å‰åºéå†"""
        result.append(node.data)
        for child in node.children:
            self._preorder_recursive(child, result)
    
    def traverse_inorder(self) -> List[T]:
        """ä¸­åºéå†"""
        result = []
        if self.root is not None:
            self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node: TreeNode[T], result: List[T]):
        """é€’å½’ä¸­åºéå†"""
        if len(node.children) > 0:
            self._inorder_recursive(node.children[0], result)
        result.append(node.data)
        for child in node.children[1:]:
            self._inorder_recursive(child, result)
    
    def traverse_postorder(self) -> List[T]:
        """ååºéå†"""
        result = []
        if self.root is not None:
            self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node: TreeNode[T], result: List[T]):
        """é€’å½’ååºéå†"""
        for child in node.children:
            self._postorder_recursive(child, result)
        result.append(node.data)
    
    def get_height(self) -> int:
        """è·å–æ ‘çš„é«˜åº¦"""
        if self.root is None:
            return -1
        return self.root.get_height()
    
    def size(self) -> int:
        return self._size
    
    def is_empty(self) -> bool:
        return self._size == 0
    
    def __str__(self) -> str:
        if self.root is None:
            return "Tree: empty"
        
        def build_string(node: TreeNode[T], prefix: str = "", is_last: bool = True) -> str:
            result = prefix + ("â””â”€â”€ " if is_last else "â”œâ”€â”€ ") + str(node.data) + "\n"
            prefix += "    " if is_last else "â”‚   "
            
            for i, child in enumerate(node.children):
                result += build_string(child, prefix, i == len(node.children) - 1)
            
            return result
        
        return "Tree:\n" + build_string(self.root, "", True)

# ä½¿ç”¨ç¤ºä¾‹
tree = Tree[int]()
tree.insert(1)  # æ ¹èŠ‚ç‚¹
tree.insert(2, 1)  # 1çš„å­èŠ‚ç‚¹
tree.insert(3, 1)  # 1çš„å­èŠ‚ç‚¹
tree.insert(4, 2)  # 2çš„å­èŠ‚ç‚¹
tree.insert(5, 2)  # 2çš„å­èŠ‚ç‚¹

print(f"æ ‘ç»“æ„:\n{tree}")
print(f"æ ‘é«˜åº¦: {tree.get_height()}")
print(f"å‰åºéå†: {tree.traverse_preorder()}")
print(f"ä¸­åºéå†: {tree.traverse_inorder()}")
print(f"ååºéå†: {tree.traverse_postorder()}")

print(f"æœç´¢4: {tree.search(4)}")
tree.delete(2)
print(f"åˆ é™¤2å:\n{tree}")
```

#### 3.2 å›¾ï¼ˆGraphï¼‰

```python
@dataclass
class Edge(Generic[T]):
    """å›¾çš„è¾¹"""
    source: T
    target: T
    weight: float = 1.0
    
    def __str__(self) -> str:
        return f"{self.source} -> {self.target} (weight: {self.weight})"

class Graph(DataStructure[T]):
    """å›¾æ•°æ®ç»“æ„"""
    
    def __init__(self, directed: bool = False):
        super().__init__("Graph")
        self.directed = directed
        self.vertices: Set[T] = set()
        self.edges: List[Edge[T]] = []
        self.adjacency_list: Dict[T, List[T]] = {}
        
        self.metrics.space_complexity = "O(V + E)"
        self.metrics.time_complexity = {
            "add_vertex": "O(1)",
            "add_edge": "O(1)",
            "remove_vertex": "O(E)",
            "remove_edge": "O(E)",
            "search": "O(V + E)"
        }
    
    def add_vertex(self, vertex: T) -> bool:
        """æ·»åŠ é¡¶ç‚¹"""
        return self.execute_operation(
            OperationType.INSERT,
            self._add_vertex_impl,
            vertex
        )
    
    def _add_vertex_impl(self, vertex: T) -> bool:
        if vertex in self.vertices:
            return False
        
        self.vertices.add(vertex)
        self.adjacency_list[vertex] = []
        return True
    
    def add_edge(self, source: T, target: T, weight: float = 1.0) -> bool:
        """æ·»åŠ è¾¹"""
        return self.execute_operation(
            OperationType.INSERT,
            self._add_edge_impl,
            source,
            target,
            weight
        )
    
    def _add_edge_impl(self, source: T, target: T, weight: float = 1.0) -> bool:
        if source not in self.vertices or target not in self.vertices:
            return False
        
        edge = Edge(source, target, weight)
        self.edges.append(edge)
        self.adjacency_list[source].append(target)
        
        if not self.directed:
            # æ— å‘å›¾éœ€è¦æ·»åŠ åå‘è¾¹
            reverse_edge = Edge(target, source, weight)
            self.edges.append(reverse_edge)
            self.adjacency_list[target].append(source)
        
        return True
    
    def remove_vertex(self, vertex: T) -> bool:
        """åˆ é™¤é¡¶ç‚¹"""
        return self.execute_operation(
            OperationType.DELETE,
            self._remove_vertex_impl,
            vertex
        )
    
    def _remove_vertex_impl(self, vertex: T) -> bool:
        if vertex not in self.vertices:
            return False
        
        # åˆ é™¤é¡¶ç‚¹
        self.vertices.remove(vertex)
        
        # åˆ é™¤ç›¸å…³çš„è¾¹
        self.edges = [edge for edge in self.edges 
                     if edge.source != vertex and edge.target != vertex]
        
        # æ›´æ–°é‚»æ¥è¡¨
        del self.adjacency_list[vertex]
        for adj_list in self.adjacency_list.values():
            if vertex in adj_list:
                adj_list.remove(vertex)
        
        return True
    
    def remove_edge(self, source: T, target: T) -> bool:
        """åˆ é™¤è¾¹"""
        return self.execute_operation(
            OperationType.DELETE,
            self._remove_edge_impl,
            source,
            target
        )
    
    def _remove_edge_impl(self, source: T, target: T) -> bool:
        # åˆ é™¤è¾¹
        self.edges = [edge for edge in self.edges 
                     if not (edge.source == source and edge.target == target)]
        
        # æ›´æ–°é‚»æ¥è¡¨
        if source in self.adjacency_list and target in self.adjacency_list[source]:
            self.adjacency_list[source].remove(target)
        
        if not self.directed:
            # æ— å‘å›¾éœ€è¦åˆ é™¤åå‘è¾¹
            if target in self.adjacency_list and source in self.adjacency_list[target]:
                self.adjacency_list[target].remove(source)
        
        return True
    
    def get_neighbors(self, vertex: T) -> List[T]:
        """è·å–é¡¶ç‚¹çš„é‚»å±…"""
        return self.adjacency_list.get(vertex, [])
    
    def has_edge(self, source: T, target: T) -> bool:
        """æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¾¹"""
        return target in self.get_neighbors(source)
    
    def get_edge_weight(self, source: T, target: T) -> Optional[float]:
        """è·å–è¾¹çš„æƒé‡"""
        for edge in self.edges:
            if edge.source == source and edge.target == target:
                return edge.weight
        return None
    
    def bfs(self, start: T) -> List[T]:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
        if start not in self.vertices:
            return []
        
        visited = set()
        queue = [start]
        result = []
        
        while queue:
            vertex = queue.pop(0)
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return result
    
    def dfs(self, start: T) -> List[T]:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        if start not in self.vertices:
            return []
        
        visited = set()
        result = []
        
        def dfs_recursive(vertex: T):
            visited.add(vertex)
            result.append(vertex)
            
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    dfs_recursive(neighbor)
        
        dfs_recursive(start)
        return result
    
    def insert(self, item: T) -> bool:
        """æ’å…¥ï¼ˆæ·»åŠ é¡¶ç‚¹ï¼‰"""
        return self.add_vertex(item)
    
    def delete(self, item: T) -> bool:
        """åˆ é™¤ï¼ˆåˆ é™¤é¡¶ç‚¹ï¼‰"""
        return self.remove_vertex(item)
    
    def search(self, item: T) -> Optional[T]:
        """æœç´¢ï¼ˆæ£€æŸ¥é¡¶ç‚¹æ˜¯å¦å­˜åœ¨ï¼‰"""
        return item if item in self.vertices else None
    
    def size(self) -> int:
        return len(self.vertices)
    
    def is_empty(self) -> bool:
        return len(self.vertices) == 0
    
    def get_edge_count(self) -> int:
        """è·å–è¾¹çš„æ•°é‡"""
        return len(self.edges)
    
    def __str__(self) -> str:
        result = f"Graph ({'Directed' if self.directed else 'Undirected'}):\n"
        result += f"Vertices: {list(self.vertices)}\n"
        result += f"Edges: {[str(edge) for edge in self.edges]}"
        return result

# ä½¿ç”¨ç¤ºä¾‹
graph = Graph[int](directed=False)
graph.add_vertex(1)
graph.add_vertex(2)
graph.add_vertex(3)
graph.add_vertex(4)

graph.add_edge(1, 2, 1.0)
graph.add_edge(1, 3, 2.0)
graph.add_edge(2, 4, 1.5)
graph.add_edge(3, 4, 1.0)

print(f"å›¾ç»“æ„:\n{graph}")
print(f"é¡¶ç‚¹æ•°é‡: {graph.size()}")
print(f"è¾¹æ•°é‡: {graph.get_edge_count()}")
print(f"é¡¶ç‚¹1çš„é‚»å±…: {graph.get_neighbors(1)}")
print(f"BFSéå†: {graph.bfs(1)}")
print(f"DFSéå†: {graph.dfs(1)}")

print(f"è¾¹(1,2)çš„æƒé‡: {graph.get_edge_weight(1, 2)}")
print(f"å­˜åœ¨è¾¹(1,4): {graph.has_edge(1, 4)}")

graph.remove_edge(1, 2)
print(f"åˆ é™¤è¾¹(1,2)å:\n{graph}")
```

### 4. æ•°æ®ç»“æ„åˆ†æ

#### 4.1 å¤æ‚åº¦åˆ†æ

```python
class DataStructureAnalyzer:
    """æ•°æ®ç»“æ„åˆ†æå™¨"""
    
    def __init__(self):
        self.structures = {}
    
    def register_structure(self, name: str, structure: DataStructure):
        """æ³¨å†Œæ•°æ®ç»“æ„"""
        self.structures[name] = structure
    
    def benchmark_operations(self, test_data: List[Any]) -> Dict[str, Dict[str, float]]:
        """åŸºå‡†æµ‹è¯•æ“ä½œ"""
        results = {}
        
        for name, structure in self.structures.items():
            results[name] = {
                'insert_time': 0.0,
                'search_time': 0.0,
                'delete_time': 0.0,
                'memory_usage': 0.0
            }
            
            # æµ‹è¯•æ’å…¥æ“ä½œ
            start_time = time.time()
            for item in test_data:
                structure.insert(item)
            results[name]['insert_time'] = time.time() - start_time
            
            # æµ‹è¯•æœç´¢æ“ä½œ
            start_time = time.time()
            for item in test_data[:10]:  # åªæµ‹è¯•å‰10ä¸ªå…ƒç´ 
                structure.search(item)
            results[name]['search_time'] = time.time() - start_time
            
            # æµ‹è¯•åˆ é™¤æ“ä½œ
            start_time = time.time()
            for item in test_data[:10]:  # åªæµ‹è¯•å‰10ä¸ªå…ƒç´ 
                structure.delete(item)
            results[name]['delete_time'] = time.time() - start_time
            
            # ä¼°ç®—å†…å­˜ä½¿ç”¨
            results[name]['memory_usage'] = structure.size() * 8  # å‡è®¾æ¯ä¸ªå…ƒç´ 8å­—èŠ‚
        
        return results
    
    def compare_performance(self, results: Dict[str, Dict[str, float]]) -> Dict[str, str]:
        """æ¯”è¾ƒæ€§èƒ½"""
        comparison = {}
        
        # æ‰¾å‡ºæœ€ä½³æ€§èƒ½
        best_insert = min(results.items(), key=lambda x: x[1]['insert_time'])
        best_search = min(results.items(), key=lambda x: x[1]['search_time'])
        best_delete = min(results.items(), key=lambda x: x[1]['delete_time'])
        best_memory = min(results.items(), key=lambda x: x[1]['memory_usage'])
        
        comparison['best_insert'] = best_insert[0]
        comparison['best_search'] = best_search[0]
        comparison['best_delete'] = best_delete[0]
        comparison['best_memory'] = best_memory[0]
        
        return comparison
    
    def generate_report(self, results: Dict[str, Dict[str, float]], 
                       comparison: Dict[str, str]) -> str:
        """ç”ŸæˆæŠ¥å‘Š"""
        report = "æ•°æ®ç»“æ„æ€§èƒ½åˆ†ææŠ¥å‘Š\n"
        report += "=" * 50 + "\n\n"
        
        for name, metrics in results.items():
            report += f"{name}:\n"
            report += f"  æ’å…¥æ—¶é—´: {metrics['insert_time']:.6f}s\n"
            report += f"  æœç´¢æ—¶é—´: {metrics['search_time']:.6f}s\n"
            report += f"  åˆ é™¤æ—¶é—´: {metrics['delete_time']:.6f}s\n"
            report += f"  å†…å­˜ä½¿ç”¨: {metrics['memory_usage']:.0f} bytes\n\n"
        
        report += "æ€§èƒ½æ¯”è¾ƒ:\n"
        report += f"  æœ€ä½³æ’å…¥æ€§èƒ½: {comparison['best_insert']}\n"
        report += f"  æœ€ä½³æœç´¢æ€§èƒ½: {comparison['best_search']}\n"
        report += f"  æœ€ä½³åˆ é™¤æ€§èƒ½: {comparison['best_delete']}\n"
        report += f"  æœ€ä½³å†…å­˜æ•ˆç‡: {comparison['best_memory']}\n"
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
analyzer = DataStructureAnalyzer()

# åˆ›å»ºæµ‹è¯•æ•°æ®ç»“æ„
simple_list = SimpleList()
stack = Stack[int]()
queue = Queue[int]()
linked_list = LinkedList[int]()
tree = Tree[int]()
graph = Graph[int]()

# æ³¨å†Œæ•°æ®ç»“æ„
analyzer.register_structure("SimpleList", simple_list)
analyzer.register_structure("Stack", stack)
analyzer.register_structure("Queue", queue)
analyzer.register_structure("LinkedList", linked_list)
analyzer.register_structure("Tree", tree)
analyzer.register_structure("Graph", graph)

# ç”Ÿæˆæµ‹è¯•æ•°æ®
test_data = list(range(100))

# æ‰§è¡ŒåŸºå‡†æµ‹è¯•
results = analyzer.benchmark_operations(test_data)
comparison = analyzer.compare_performance(results)

# ç”ŸæˆæŠ¥å‘Š
report = analyzer.generate_report(results, comparison)
print(report)
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. é“¾è¡¨æ“ä½œå¤æ‚åº¦å®šç†

**å®šç†**: åœ¨é“¾è¡¨ä¸­ï¼Œæ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯é“¾è¡¨é•¿åº¦ã€‚

**è¯æ˜**: åœ¨æœ€åæƒ…å†µä¸‹ï¼Œéœ€è¦éå†æ•´ä¸ªé“¾è¡¨æ‰èƒ½æ‰¾åˆ°ç›®æ ‡ä½ç½®ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

### 2. æ ‘éå†å¤æ‚åº¦å®šç†

**å®šç†**: æ ‘çš„å‰åºã€ä¸­åºã€ååºéå†çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯èŠ‚ç‚¹æ•°é‡ã€‚

**è¯æ˜**: æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. è¡¨è¾¾å¼æ±‚å€¼å™¨

```python
class ExpressionEvaluator:
    """è¡¨è¾¾å¼æ±‚å€¼å™¨"""
    
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }
        self.precedence = {
            '+': 1, '-': 1,
            '*': 2, '/': 2,
            '^': 3
        }
    
    def evaluate_postfix(self, expression: str) -> float:
        """è®¡ç®—åç¼€è¡¨è¾¾å¼"""
        stack = Stack[float]()
        tokens = expression.split()
        
        for token in tokens:
            if token in self.operators:
                # æ“ä½œç¬¦
                if stack.size() < 2:
                    raise ValueError("Invalid expression")
                
                b = stack.pop()
                a = stack.pop()
                result = self.operators[token](a, b)
                stack.push(result)
            else:
                # æ“ä½œæ•°
                try:
                    number = float(token)
                    stack.push(number)
                except ValueError:
                    raise ValueError(f"Invalid token: {token}")
        
        if stack.size() != 1:
            raise ValueError("Invalid expression")
        
        return stack.pop()
    
    def infix_to_postfix(self, expression: str) -> str:
        """ä¸­ç¼€è½¬åç¼€"""
        output = []
        operator_stack = Stack[str]()
        
        tokens = self._tokenize(expression)
        
        for token in tokens:
            if token.isdigit() or '.' in token:
                # æ“ä½œæ•°
                output.append(token)
            elif token in self.operators:
                # æ“ä½œç¬¦
                while (not operator_stack.is_empty() and 
                       operator_stack.peek() in self.operators and
                       self.precedence[operator_stack.peek()] >= self.precedence[token]):
                    output.append(operator_stack.pop())
                operator_stack.push(token)
            elif token == '(':
                operator_stack.push(token)
            elif token == ')':
                while (not operator_stack.is_empty() and 
                       operator_stack.peek() != '('):
                    output.append(operator_stack.pop())
                if not operator_stack.is_empty():
                    operator_stack.pop()  # å¼¹å‡º '('
        
        while not operator_stack.is_empty():
            output.append(operator_stack.pop())
        
        return ' '.join(output)
    
    def _tokenize(self, expression: str) -> List[str]:
        """åˆ†è¯"""
        tokens = []
        current = ""
        
        for char in expression:
            if char.isdigit() or char == '.':
                current += char
            elif char in self.operators or char in '()':
                if current:
                    tokens.append(current)
                    current = ""
                tokens.append(char)
            elif char.isspace():
                if current:
                    tokens.append(current)
                    current = ""
        
        if current:
            tokens.append(current)
        
        return tokens

# ä½¿ç”¨ç¤ºä¾‹
evaluator = ExpressionEvaluator()

# ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€
infix = "3 + 4 * 2 - 1"
postfix = evaluator.infix_to_postfix(infix)
print(f"ä¸­ç¼€è¡¨è¾¾å¼: {infix}")
print(f"åç¼€è¡¨è¾¾å¼: {postfix}")

# è®¡ç®—åç¼€è¡¨è¾¾å¼
result = evaluator.evaluate_postfix(postfix)
print(f"è®¡ç®—ç»“æœ: {result}")
```

### 2. ä»»åŠ¡è°ƒåº¦å™¨

```python
@dataclass
class Task:
    """ä»»åŠ¡"""
    id: str
    priority: int
    duration: float
    description: str
    
    def __lt__(self, other: 'Task') -> bool:
        return self.priority > other.priority  # ä¼˜å…ˆçº§é«˜çš„å…ˆæ‰§è¡Œ

class TaskScheduler:
    """ä»»åŠ¡è°ƒåº¦å™¨"""
    
    def __init__(self):
        self.tasks = []
        self.completed_tasks = []
    
    def add_task(self, task: Task):
        """æ·»åŠ ä»»åŠ¡"""
        self.tasks.append(task)
        # æŒ‰ä¼˜å…ˆçº§æ’åº
        self.tasks.sort()
    
    def schedule_tasks(self) -> List[Task]:
        """è°ƒåº¦ä»»åŠ¡"""
        scheduled = []
        
        while self.tasks:
            task = self.tasks.pop(0)
            scheduled.append(task)
            self.completed_tasks.append(task)
        
        return scheduled
    
    def get_task_statistics(self) -> Dict[str, Any]:
        """è·å–ä»»åŠ¡ç»Ÿè®¡ä¿¡æ¯"""
        if not self.completed_tasks:
            return {}
        
        total_duration = sum(task.duration for task in self.completed_tasks)
        avg_priority = sum(task.priority for task in self.completed_tasks) / len(self.completed_tasks)
        
        return {
            'total_tasks': len(self.completed_tasks),
            'total_duration': total_duration,
            'average_priority': avg_priority,
            'completion_rate': 1.0
        }

# ä½¿ç”¨ç¤ºä¾‹
scheduler = TaskScheduler()

# æ·»åŠ ä»»åŠ¡
tasks = [
    Task("T1", 3, 2.0, "é«˜ä¼˜å…ˆçº§ä»»åŠ¡"),
    Task("T2", 1, 1.5, "ä½ä¼˜å…ˆçº§ä»»åŠ¡"),
    Task("T3", 5, 3.0, "æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡"),
    Task("T4", 2, 1.0, "ä¸­ç­‰ä¼˜å…ˆçº§ä»»åŠ¡")
]

for task in tasks:
    scheduler.add_task(task)

# è°ƒåº¦ä»»åŠ¡
scheduled = scheduler.schedule_tasks()
print("ä»»åŠ¡è°ƒåº¦é¡ºåº:")
for i, task in enumerate(scheduled, 1):
    print(f"{i}. {task.id} - {task.description} (ä¼˜å…ˆçº§: {task.priority})")

# ç»Ÿè®¡ä¿¡æ¯
stats = scheduler.get_task_statistics()
print(f"\nä»»åŠ¡ç»Ÿè®¡: {stats}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [æ•°æ®ç»“æ„ç†è®ºæ¦‚è¿°](../README.md)
- [ç®—æ³•ç†è®º](../02-01-ç®—æ³•ç†è®º/README.md)
- [è®¡ç®—å¤æ‚æ€§ç†è®º](../02-03-è®¡ç®—å¤æ‚æ€§ç†è®º/README.md)
- [å½¢å¼ç§‘å­¦](../01-å½¢å¼ç§‘å­¦/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms. MIT Press.
2. Sedgewick, R., & Wayne, K. (2011). Algorithms. Addison-Wesley.
3. Knuth, D. E. (1997). The Art of Computer Programming. Addison-Wesley.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
