# 00.01 è®¡ç®—å“²å­¦åŸºç¡€

## ğŸ“– æ¦‚è¿°

è®¡ç®—å“²å­¦æ˜¯ç ”ç©¶è®¡ç®—æœ¬è´¨ã€è®¡ç®—æ€ç»´å’Œè®¡ç®—æ–¹æ³•çš„å“²å­¦åˆ†æ”¯ã€‚å®ƒæ¢è®¨è®¡ç®—çš„åŸºæœ¬æ¦‚å¿µã€è®¡ç®—è¿‡ç¨‹çš„æœ¬è´¨ç‰¹å¾ï¼Œä»¥åŠè®¡ç®—åœ¨è®¤çŸ¥å’Œæ™ºèƒ½ä¸­çš„ä½œç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¡ç®—çš„å®šä¹‰

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾ $A$ ä¸ºè¾“å…¥é›†åˆï¼Œ$B$ ä¸ºè¾“å‡ºé›†åˆï¼Œ$f: A \rightarrow B$ ä¸ºå‡½æ•°ï¼Œåˆ™è®¡ç®—è¿‡ç¨‹å¯ä»¥å®šä¹‰ä¸ºï¼š

$$\text{Compute}(f, a) = f(a) \quad \text{where} \quad a \in A$$

**Pythonå®ç°**ï¼š
```python
from typing import TypeVar, Callable, Any
from abc import ABC, abstractmethod

A = TypeVar('A')
B = TypeVar('B')

class Computation(ABC):
    """è®¡ç®—è¿‡ç¨‹çš„æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def compute(self, input_data: A) -> B:
        """æ‰§è¡Œè®¡ç®—è¿‡ç¨‹"""
        pass

class FunctionComputation(Computation[A, B]):
    """åŸºäºå‡½æ•°çš„è®¡ç®—å®ç°"""
    
    def __init__(self, function: Callable[[A], B]):
        self.function = function
    
    def compute(self, input_data: A) -> B:
        return self.function(input_data)

# ç¤ºä¾‹ï¼šè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—
def fibonacci(n: int) -> int:
    """è®¡ç®—ç¬¬nä¸ªæ–æ³¢é‚£å¥‘æ•°"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# åˆ›å»ºè®¡ç®—å®ä¾‹
fib_computation = FunctionComputation(fibonacci)
result = fib_computation.compute(10)
print(f"Fibonacci(10) = {result}")
```

### 2. è®¡ç®—æ€ç»´

**å®šä¹‰**ï¼šè®¡ç®—æ€ç»´æ˜¯ä¸€ç§è§£å†³é—®é¢˜çš„æ€ç»´æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

1. **åˆ†è§£** (Decomposition)
2. **æ¨¡å¼è¯†åˆ«** (Pattern Recognition)
3. **æŠ½è±¡** (Abstraction)
4. **ç®—æ³•è®¾è®¡** (Algorithm Design)

**Pythonå®ç°**ï¼š
```python
from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class ComputationalThinking:
    """è®¡ç®—æ€ç»´æ¡†æ¶"""
    
    def decompose(self, problem: Any) -> List[Any]:
        """åˆ†è§£é—®é¢˜ä¸ºå­é—®é¢˜"""
        # å…·ä½“å®ç°ä¾èµ–äºé—®é¢˜ç±»å‹
        return [problem]
    
    def recognize_patterns(self, data: List[Any]) -> Dict[str, Any]:
        """è¯†åˆ«æ•°æ®ä¸­çš„æ¨¡å¼"""
        patterns = {}
        # å®ç°æ¨¡å¼è¯†åˆ«é€»è¾‘
        return patterns
    
    def abstract(self, concrete_instances: List[Any]) -> Any:
        """ä»å…·ä½“å®ä¾‹ä¸­æŠ½è±¡å‡ºä¸€èˆ¬æ¦‚å¿µ"""
        # å®ç°æŠ½è±¡é€»è¾‘
        return type(concrete_instances[0]) if concrete_instances else None
    
    def design_algorithm(self, problem: Any) -> Callable:
        """è®¾è®¡è§£å†³é—®é¢˜çš„ç®—æ³•"""
        # è¿”å›ç®—æ³•å‡½æ•°
        return lambda x: x

# ä½¿ç”¨ç¤ºä¾‹
ct = ComputationalThinking()
problem = "æ’åºä¸€ä¸ªæ•°ç»„"
sub_problems = ct.decompose(problem)
patterns = ct.recognize_patterns([1, 2, 3, 4, 5])
abstraction = ct.abstract([1, 2, 3])
algorithm = ct.design_algorithm(problem)
```

### 3. è®¡ç®—å¤æ‚æ€§

**ç†è®ºå®šä¹‰**ï¼š
å¯¹äºç®—æ³• $A$ï¼Œå…¶æ—¶é—´å¤æ‚åº¦å®šä¹‰ä¸ºï¼š

$$T_A(n) = O(f(n))$$

å…¶ä¸­ $n$ æ˜¯è¾“å…¥è§„æ¨¡ï¼Œ$f(n)$ æ˜¯å¢é•¿å‡½æ•°ã€‚

**Pythonå®ç°**ï¼š
```python
import time
from typing import Callable, Any
from functools import wraps

def time_complexity(func: Callable) -> Callable:
    """è£…é¥°å™¨ï¼šæµ‹é‡å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"{func.__name__} æ‰§è¡Œæ—¶é—´: {execution_time:.6f} ç§’")
        return result
    return wrapper

class ComplexityAnalyzer:
    """å¤æ‚åº¦åˆ†æå™¨"""
    
    @staticmethod
    def analyze_algorithm(algorithm: Callable, test_cases: List[Any]) -> Dict[str, float]:
        """åˆ†æç®—æ³•çš„å¤æ‚åº¦"""
        results = {}
        for case in test_cases:
            start_time = time.time()
            algorithm(case)
            end_time = time.time()
            results[str(case)] = end_time - start_time
        return results

# ç¤ºä¾‹ï¼šåˆ†ææ’åºç®—æ³•å¤æ‚åº¦
@time_complexity
def bubble_sort(arr: List[int]) -> List[int]:
    """å†’æ³¡æ’åº - O(nÂ²)"""
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# æµ‹è¯•
test_data = [64, 34, 25, 12, 22, 11, 90]
sorted_data = bubble_sort(test_data.copy())
print(f"æ’åºç»“æœ: {sorted_data}")
```

## ğŸ”¬ å“²å­¦åŸç†

### 1. ä¸˜å¥‡-å›¾çµè®ºé¢˜

**è¡¨è¿°**ï¼šä»»ä½•å¯è®¡ç®—çš„å‡½æ•°éƒ½å¯ä»¥ç”±å›¾çµæœºè®¡ç®—ã€‚

**Pythonå®ç°**ï¼š
```python
from typing import Any, Callable
from enum import Enum

class TapeDirection(Enum):
    LEFT = -1
    RIGHT = 1
    STAY = 0

class TuringMachine:
    """å›¾çµæœºå®ç°"""
    
    def __init__(self, states: set, alphabet: set, transition_function: dict):
        self.states = states
        self.alphabet = alphabet
        self.transition_function = transition_function
        self.current_state = None
        self.tape = []
        self.head_position = 0
    
    def run(self, input_string: str) -> str:
        """è¿è¡Œå›¾çµæœº"""
        self.tape = list(input_string)
        self.current_state = 'q0'
        self.head_position = 0
        
        while self.current_state not in {'accept', 'reject'}:
            current_symbol = self.tape[self.head_position] if self.head_position < len(self.tape) else '_'
            
            if (self.current_state, current_symbol) not in self.transition_function:
                return 'reject'
            
            new_state, new_symbol, direction = self.transition_function[(self.current_state, current_symbol)]
            
            # æ›´æ–°çŠ¶æ€å’Œç£å¸¦
            self.current_state = new_state
            if self.head_position < len(self.tape):
                self.tape[self.head_position] = new_symbol
            else:
                self.tape.append(new_symbol)
            
            # ç§»åŠ¨è¯»å†™å¤´
            self.head_position += direction.value
            
            if self.head_position < 0:
                self.tape.insert(0, '_')
                self.head_position = 0
        
        return ''.join(self.tape).rstrip('_')

# ç¤ºä¾‹ï¼šå®ç°ä¸€ä¸ªç®€å•çš„å›¾çµæœº
def create_simple_turing_machine() -> TuringMachine:
    """åˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾çµæœºç¤ºä¾‹"""
    states = {'q0', 'q1', 'accept', 'reject'}
    alphabet = {'0', '1', '_'}
    
    # è½¬ç§»å‡½æ•°ï¼šå°†è¾“å…¥å­—ç¬¦ä¸²åè½¬
    transition_function = {
        ('q0', '0'): ('q1', '1', TapeDirection.RIGHT),
        ('q0', '1'): ('q1', '0', TapeDirection.RIGHT),
        ('q0', '_'): ('accept', '_', TapeDirection.STAY),
        ('q1', '0'): ('q1', '1', TapeDirection.RIGHT),
        ('q1', '1'): ('q1', '0', TapeDirection.RIGHT),
        ('q1', '_'): ('accept', '_', TapeDirection.STAY),
    }
    
    return TuringMachine(states, alphabet, transition_function)

# æµ‹è¯•å›¾çµæœº
tm = create_simple_turing_machine()
result = tm.run("101")
print(f"è¾“å…¥: 101, è¾“å‡º: {result}")
```

### 2. è®¡ç®—ç­‰ä»·æ€§

**å®šä¹‰**ï¼šä¸¤ä¸ªè®¡ç®—æ¨¡å‹æ˜¯ç­‰ä»·çš„ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬èƒ½è®¡ç®—ç›¸åŒçš„å‡½æ•°ç±»ã€‚

**Pythonå®ç°**ï¼š
```python
from typing import TypeVar, Protocol, Callable

T = TypeVar('T')

class Computable(Protocol[T]):
    """å¯è®¡ç®—æ¥å£"""
    def compute(self, input_data: Any) -> T:
        ...

class LambdaCalculus:
    """Î»æ¼”ç®—å®ç°"""
    
    def __init__(self):
        self.variables = {}
    
    def apply(self, function: Callable, argument: Any) -> Any:
        """å‡½æ•°åº”ç”¨"""
        return function(argument)
    
    def abstract(self, variable: str, body: Callable) -> Callable:
        """Î»æŠ½è±¡"""
        return lambda x: body(x) if variable == 'x' else body

class RecursiveFunctions:
    """é€’å½’å‡½æ•°å®ç°"""
    
    @staticmethod
    def zero() -> int:
        """é›¶å‡½æ•°"""
        return 0
    
    @staticmethod
    def successor(n: int) -> int:
        """åç»§å‡½æ•°"""
        return n + 1
    
    @staticmethod
    def projection(n: int, i: int) -> Callable:
        """æŠ•å½±å‡½æ•°"""
        def proj(*args):
            return args[i-1] if i <= len(args) else 0
        return proj

# è¯æ˜ç­‰ä»·æ€§
def demonstrate_equivalence():
    """æ¼”ç¤ºä¸åŒè®¡ç®—æ¨¡å‹çš„ç­‰ä»·æ€§"""
    
    # Î»æ¼”ç®—å®ç°åŠ æ³•
    lambda_add = lambda x: lambda y: x + y
    
    # é€’å½’å‡½æ•°å®ç°åŠ æ³•
    def recursive_add(x: int, y: int) -> int:
        if y == 0:
            return x
        return recursive_add(successor(x), y - 1)
    
    # æµ‹è¯•ç­‰ä»·æ€§
    test_cases = [(2, 3), (5, 7), (0, 10)]
    
    for x, y in test_cases:
        lambda_result = lambda_add(x)(y)
        recursive_result = recursive_add(x, y)
        assert lambda_result == recursive_result, f"ä¸ç­‰ä»·: {lambda_result} != {recursive_result}"
    
    print("Î»æ¼”ç®—å’Œé€’å½’å‡½æ•°åœ¨åŠ æ³•è¿ç®—ä¸Šç­‰ä»·")

demonstrate_equivalence()
```

## ğŸ§  è®¤çŸ¥è®¡ç®—

### 1. ä¿¡æ¯å¤„ç†æ¨¡å‹

**å®šä¹‰**ï¼šè®¤çŸ¥è®¡ç®—æ˜¯æ¨¡æ‹Ÿäººç±»è®¤çŸ¥è¿‡ç¨‹çš„è®¡ç®—æ¨¡å‹ã€‚

**Pythonå®ç°**ï¼š
```python
from typing import List, Dict, Any
import numpy as np

class CognitiveProcessor:
    """è®¤çŸ¥å¤„ç†å™¨"""
    
    def __init__(self):
        self.memory = {}
        self.attention = []
        self.learning_rate = 0.1
    
    def perceive(self, stimulus: Any) -> Dict[str, Any]:
        """æ„ŸçŸ¥å¤„ç†"""
        return {
            'raw_input': stimulus,
            'processed': self._process_stimulus(stimulus),
            'attention_level': self._calculate_attention(stimulus)
        }
    
    def _process_stimulus(self, stimulus: Any) -> Any:
        """å¤„ç†åˆºæ¿€"""
        # ç®€åŒ–çš„åˆºæ¿€å¤„ç†
        if isinstance(stimulus, str):
            return stimulus.lower()
        elif isinstance(stimulus, (int, float)):
            return abs(stimulus)
        return stimulus
    
    def _calculate_attention(self, stimulus: Any) -> float:
        """è®¡ç®—æ³¨æ„åŠ›æ°´å¹³"""
        # ç®€åŒ–çš„æ³¨æ„åŠ›è®¡ç®—
        if isinstance(stimulus, str) and len(stimulus) > 10:
            return 0.8
        elif isinstance(stimulus, (int, float)) and abs(stimulus) > 100:
            return 0.9
        return 0.5
    
    def learn(self, input_data: Any, output_data: Any):
        """å­¦ä¹ è¿‡ç¨‹"""
        key = hash(str(input_data))
        self.memory[key] = {
            'input': input_data,
            'output': output_data,
            'strength': 1.0
        }
    
    def recall(self, input_data: Any) -> Any:
        """å›å¿†è¿‡ç¨‹"""
        key = hash(str(input_data))
        if key in self.memory:
            return self.memory[key]['output']
        return None

# ä½¿ç”¨ç¤ºä¾‹
cognitive_system = CognitiveProcessor()

# æ„ŸçŸ¥å¤„ç†
perception = cognitive_system.perceive("Hello World")
print(f"æ„ŸçŸ¥ç»“æœ: {perception}")

# å­¦ä¹ è¿‡ç¨‹
cognitive_system.learn("2+2", 4)
cognitive_system.learn("Python", "Programming Language")

# å›å¿†è¿‡ç¨‹
result1 = cognitive_system.recall("2+2")
result2 = cognitive_system.recall("Python")
print(f"å›å¿†ç»“æœ: 2+2 = {result1}, Python = {result2}")
```

## ğŸ“Š æ•°å­¦å½¢å¼åŒ–

### 1. è®¡ç®—å‡½æ•°çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰**ï¼šè®¡ç®—å‡½æ•° $f: \mathbb{N}^n \rightarrow \mathbb{N}$ æ˜¯éƒ¨åˆ†é€’å½’çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

1. $f$ æ˜¯åŸºæœ¬å‡½æ•°ï¼Œæˆ–
2. $f$ é€šè¿‡ç»„åˆã€é€’å½’æˆ–æœ€å°åŒ–ä»åŸºæœ¬å‡½æ•°å¾—åˆ°

**Pythonå®ç°**ï¼š
```python
from typing import Callable, List, Optional
from functools import reduce

class RecursiveFunction:
    """é€’å½’å‡½æ•°ç±»"""
    
    @staticmethod
    def zero() -> Callable[[], int]:
        """é›¶å‡½æ•° Z(x) = 0"""
        return lambda: 0
    
    @staticmethod
    def successor() -> Callable[[int], int]:
        """åç»§å‡½æ•° S(x) = x + 1"""
        return lambda x: x + 1
    
    @staticmethod
    def projection(n: int, i: int) -> Callable[..., int]:
        """æŠ•å½±å‡½æ•° P_i^n(x_1, ..., x_n) = x_i"""
        def proj(*args):
            return args[i-1] if i <= len(args) else 0
        return proj
    
    @staticmethod
    def composition(f: Callable, g_list: List[Callable]) -> Callable:
        """ç»„åˆå‡½æ•° h(x) = f(g_1(x), ..., g_n(x))"""
        def composed(*args):
            g_results = [g(*args) for g in g_list]
            return f(*g_results)
        return composed
    
    @staticmethod
    def primitive_recursion(f: Callable, g: Callable) -> Callable:
        """åŸå§‹é€’å½’
        h(x, 0) = f(x)
        h(x, y+1) = g(x, y, h(x, y))
        """
        def recursive(*args):
            x = args[:-1]
            y = args[-1]
            
            if y == 0:
                return f(*x)
            else:
                prev_result = recursive(*x, y - 1)
                return g(*x, y - 1, prev_result)
        
        return recursive

# ç¤ºä¾‹ï¼šæ„é€ åŠ æ³•å‡½æ•°
def create_addition_function() -> Callable[[int, int], int]:
    """ä½¿ç”¨åŸå§‹é€’å½’æ„é€ åŠ æ³•å‡½æ•°"""
    
    # f(x) = x (æŠ•å½±å‡½æ•° P_1^1)
    f = RecursiveFunction.projection(1, 1)
    
    # g(x, y, z) = S(z) (åç»§å‡½æ•°)
    g = lambda x, y, z: RecursiveFunction.successor()(z)
    
    # åŠ æ³•å‡½æ•°: add(x, 0) = x, add(x, y+1) = S(add(x, y))
    add = RecursiveFunction.primitive_recursion(f, g)
    
    return add

# æµ‹è¯•åŠ æ³•å‡½æ•°
addition = create_addition_function()
print(f"3 + 5 = {addition(3, 5)}")
print(f"0 + 7 = {addition(0, 7)}")
print(f"10 + 0 = {addition(10, 0)}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.02 å½¢å¼åŒ–æ€ç»´æ–¹æ³•](./00.02-å½¢å¼åŒ–æ€ç»´æ–¹æ³•.md)
- [01.01 æ•°å­¦åŸºç¡€](../01-å½¢å¼ç§‘å­¦/01.01-æ•°å­¦åŸºç¡€.md)
- [02.01 è®¡ç®—ç†è®º](../02-ç†è®ºåŸºç¡€/02.01-è®¡ç®—ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Church, A. (1936). An unsolvable problem of elementary number theory. American Journal of Mathematics, 58(2), 345-363.
2. Turing, A. M. (1936). On computable numbers, with an application to the Entscheidungsproblem. Proceedings of the London Mathematical Society, 42(1), 230-265.
3. Wing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0.0 