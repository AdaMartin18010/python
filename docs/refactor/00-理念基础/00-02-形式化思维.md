# 00-02-å½¢å¼åŒ–æ€ç»´

## ğŸ“‹ æ¦‚è¿°

å½¢å¼åŒ–æ€ç»´æ˜¯ä½¿ç”¨ä¸¥æ ¼çš„æ•°å­¦è¯­è¨€å’Œé€»è¾‘ç¬¦å·æ¥æè¿°ã€åˆ†æå’Œè§£å†³é—®é¢˜çš„æ€ç»´æ–¹å¼ã€‚å®ƒæ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„åŸºç¡€ï¼Œç¡®ä¿æ¨ç†çš„ä¸¥è°¨æ€§å’Œç»“è®ºçš„å¯é æ€§ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å½¢å¼åŒ–è¯­è¨€ (Formal Language)

**æ¦‚å¿µå®šä¹‰**: å½¢å¼åŒ–è¯­è¨€æ˜¯ç”±ç²¾ç¡®å®šä¹‰çš„ç¬¦å·å’Œè§„åˆ™ç»„æˆçš„è¯­è¨€ç³»ç»Ÿï¼Œç”¨äºæ— æ­§ä¹‰åœ°è¡¨è¾¾æ¦‚å¿µå’Œæ¨ç†è¿‡ç¨‹ã€‚

**æ•°å­¦å½¢å¼**:
å½¢å¼åŒ–è¯­è¨€å¯ä»¥å®šä¹‰ä¸ºå››å…ƒç»„ï¼š

$$L = (V, T, P, S)$$

å…¶ä¸­ï¼š

- $V$ æ˜¯å˜é‡é›†åˆ (Variables)
- $T$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ (Terminals)
- $P$ æ˜¯äº§ç”Ÿå¼è§„åˆ™é›†åˆ (Production Rules)
- $S$ æ˜¯èµ·å§‹ç¬¦å· (Start Symbol)

**Pythonå®ç°**:

```python
from typing import Set, List, Tuple, Dict, Any
from dataclasses import dataclass
from enum import Enum
import re

class SymbolType(Enum):
    """ç¬¦å·ç±»å‹"""
    VARIABLE = "variable"
    TERMINAL = "terminal"
    START = "start"

@dataclass
class Symbol:
    """ç¬¦å·å®šä¹‰"""
    name: str
    symbol_type: SymbolType
    description: str = ""

@dataclass
class ProductionRule:
    """äº§ç”Ÿå¼è§„åˆ™"""
    left_side: str
    right_side: List[str]
    description: str = ""

class FormalLanguage:
    """å½¢å¼åŒ–è¯­è¨€å®ç°"""
    
    def __init__(self, name: str):
        self.name = name
        self.variables: Set[str] = set()
        self.terminals: Set[str] = set()
        self.productions: List[ProductionRule] = []
        self.start_symbol: str = ""
        self.symbols: Dict[str, Symbol] = {}
    
    def add_variable(self, name: str, description: str = "") -> None:
        """æ·»åŠ å˜é‡"""
        self.variables.add(name)
        self.symbols[name] = Symbol(name, SymbolType.VARIABLE, description)
    
    def add_terminal(self, name: str, description: str = "") -> None:
        """æ·»åŠ ç»ˆç»“ç¬¦"""
        self.terminals.add(name)
        self.symbols[name] = Symbol(name, SymbolType.TERMINAL, description)
    
    def add_production(self, left: str, right: List[str], description: str = "") -> None:
        """æ·»åŠ äº§ç”Ÿå¼è§„åˆ™"""
        rule = ProductionRule(left, right, description)
        self.productions.append(rule)
    
    def set_start_symbol(self, symbol: str) -> None:
        """è®¾ç½®èµ·å§‹ç¬¦å·"""
        if symbol in self.variables:
            self.start_symbol = symbol
            self.symbols[symbol].symbol_type = SymbolType.START
        else:
            raise ValueError(f"èµ·å§‹ç¬¦å· {symbol} å¿…é¡»æ˜¯å˜é‡")
    
    def generate_string(self, max_steps: int = 10) -> str:
        """ç”Ÿæˆè¯­è¨€ä¸­çš„å­—ç¬¦ä¸²"""
        if not self.start_symbol:
            raise ValueError("æœªè®¾ç½®èµ·å§‹ç¬¦å·")
        
        current = [self.start_symbol]
        steps = 0
        
        while steps < max_steps:
            # æŸ¥æ‰¾å¯åº”ç”¨çš„è§„åˆ™
            applicable_rules = []
            for rule in self.productions:
                if rule.left_side in current:
                    applicable_rules.append(rule)
            
            if not applicable_rules:
                break
            
            # éšæœºé€‰æ‹©ä¸€ä¸ªè§„åˆ™åº”ç”¨
            import random
            rule = random.choice(applicable_rules)
            
            # åº”ç”¨è§„åˆ™
            for i, symbol in enumerate(current):
                if symbol == rule.left_side:
                    current[i:i+1] = rule.right_side
                    break
            
            steps += 1
        
        return ''.join(current)
    
    def validate_string(self, string: str) -> bool:
        """éªŒè¯å­—ç¬¦ä¸²æ˜¯å¦å±äºè¯¥è¯­è¨€"""
        # ç®€åŒ–çš„éªŒè¯ï¼šæ£€æŸ¥æ˜¯å¦åªåŒ…å«ç»ˆç»“ç¬¦
        for char in string:
            if char not in self.terminals:
                return False
        return True
    
    def get_grammar_summary(self) -> Dict[str, Any]:
        """è·å–è¯­æ³•æ‘˜è¦"""
        return {
            'name': self.name,
            'variables': list(self.variables),
            'terminals': list(self.terminals),
            'start_symbol': self.start_symbol,
            'production_count': len(self.productions),
            'productions': [
                {
                    'left': rule.left_side,
                    'right': ' '.join(rule.right_side),
                    'description': rule.description
                }
                for rule in self.productions
            ]
        }

# ä½¿ç”¨ç¤ºä¾‹ï¼šå®šä¹‰ç®€å•ç®—æœ¯è¡¨è¾¾å¼è¯­è¨€
def create_arithmetic_language() -> FormalLanguage:
    """åˆ›å»ºç®—æœ¯è¡¨è¾¾å¼å½¢å¼åŒ–è¯­è¨€"""
    lang = FormalLanguage("Arithmetic Expressions")
    
    # æ·»åŠ å˜é‡
    lang.add_variable("E", "è¡¨è¾¾å¼")
    lang.add_variable("T", "é¡¹")
    lang.add_variable("F", "å› å­")
    
    # æ·»åŠ ç»ˆç»“ç¬¦
    lang.add_terminal("+", "åŠ æ³•è¿ç®—ç¬¦")
    lang.add_terminal("*", "ä¹˜æ³•è¿ç®—ç¬¦")
    lang.add_terminal("(", "å·¦æ‹¬å·")
    lang.add_terminal(")", "å³æ‹¬å·")
    lang.add_terminal("n", "æ•°å­—")
    
    # æ·»åŠ äº§ç”Ÿå¼è§„åˆ™
    lang.add_production("E", ["E", "+", "T"], "è¡¨è¾¾å¼å¯ä»¥æ˜¯è¡¨è¾¾å¼åŠ é¡¹")
    lang.add_production("E", ["T"], "è¡¨è¾¾å¼å¯ä»¥æ˜¯é¡¹")
    lang.add_production("T", ["T", "*", "F"], "é¡¹å¯ä»¥æ˜¯é¡¹ä¹˜å› å­")
    lang.add_production("T", ["F"], "é¡¹å¯ä»¥æ˜¯å› å­")
    lang.add_production("F", ["(", "E", ")"], "å› å­å¯ä»¥æ˜¯æ‹¬å·è¡¨è¾¾å¼")
    lang.add_production("F", ["n"], "å› å­å¯ä»¥æ˜¯æ•°å­—")
    
    # è®¾ç½®èµ·å§‹ç¬¦å·
    lang.set_start_symbol("E")
    
    return lang

### 2. é€»è¾‘æ¨ç† (Logical Reasoning)

**æ¦‚å¿µå®šä¹‰**: é€»è¾‘æ¨ç†æ˜¯ä½¿ç”¨å½¢å¼åŒ–è§„åˆ™ä»å·²çŸ¥å‰ææ¨å¯¼å‡ºç»“è®ºçš„è¿‡ç¨‹ã€‚

**æ•°å­¦å½¢å¼**:
é€»è¾‘æ¨ç†å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$P_1, P_2, ..., P_n \vdash C$$

å…¶ä¸­ï¼š
- $P_i$ æ˜¯å‰æ (Premises)
- $C$ æ˜¯ç»“è®º (Conclusion)
- $\vdash$ è¡¨ç¤ºé€»è¾‘æ¨å¯¼å…³ç³»

**Pythonå®ç°**:

```python
from typing import List, Dict, Set, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import re

class LogicOperator(Enum):
    """é€»è¾‘è¿ç®—ç¬¦"""
    AND = "âˆ§"
    OR = "âˆ¨"
    NOT = "Â¬"
    IMPLIES = "â†’"
    EQUIVALENT = "â†”"

@dataclass
class LogicalExpression:
    """é€»è¾‘è¡¨è¾¾å¼"""
    operator: Optional[LogicOperator]
    operands: List[str]
    is_atomic: bool = False
    
    def __str__(self) -> str:
        if self.is_atomic:
            return self.operands[0]
        
        if self.operator == LogicOperator.NOT:
            return f"Â¬({self.operands[0]})"
        elif self.operator == LogicOperator.AND:
            return f"({' âˆ§ '.join(self.operands)})"
        elif self.operator == LogicOperator.OR:
            return f"({' âˆ¨ '.join(self.operands)})"
        elif self.operator == LogicOperator.IMPLIES:
            return f"({self.operands[0]} â†’ {self.operands[1]})"
        elif self.operator == LogicOperator.EQUIVALENT:
            return f"({self.operands[0]} â†” {self.operands[1]})"
        
        return str(self.operands)

class LogicalReasoning:
    """é€»è¾‘æ¨ç†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.premises: List[LogicalExpression] = []
        self.conclusions: List[LogicalExpression] = []
        self.rules: Dict[str, callable] = {}
        self._setup_inference_rules()
    
    def add_premise(self, expression: LogicalExpression) -> None:
        """æ·»åŠ å‰æ"""
        self.premises.append(expression)
    
    def add_conclusion(self, expression: LogicalExpression) -> None:
        """æ·»åŠ ç»“è®º"""
        self.conclusions.append(expression)
    
    def _setup_inference_rules(self) -> None:
        """è®¾ç½®æ¨ç†è§„åˆ™"""
        self.rules = {
            'modus_ponens': self._modus_ponens,
            'modus_tollens': self._modus_tollens,
            'hypothetical_syllogism': self._hypothetical_syllogism,
            'disjunctive_syllogism': self._disjunctive_syllogism,
            'conjunction': self._conjunction,
            'simplification': self._simplification,
            'addition': self._addition
        }
    
    def _modus_ponens(self, p: str, p_implies_q: str) -> Optional[str]:
        """å‡è¨€æ¨ç†ï¼šå¦‚æœ P ä¸” Pâ†’Qï¼Œåˆ™ Q"""
        if self._is_implication(p_implies_q) and self._get_antecedent(p_implies_q) == p:
            return self._get_consequent(p_implies_q)
        return None
    
    def _modus_tollens(self, not_q: str, p_implies_q: str) -> Optional[str]:
        """æ‹’å–å¼ï¼šå¦‚æœ Â¬Q ä¸” Pâ†’Qï¼Œåˆ™ Â¬P"""
        if (self._is_negation(not_q) and self._is_implication(p_implies_q) and
            self._get_consequent(p_implies_q) == self._get_negated_expression(not_q)):
            return f"Â¬{self._get_antecedent(p_implies_q)}"
        return None
    
    def _hypothetical_syllogism(self, p_implies_q: str, q_implies_r: str) -> Optional[str]:
        """å‡è¨€ä¸‰æ®µè®ºï¼šå¦‚æœ Pâ†’Q ä¸” Qâ†’Rï¼Œåˆ™ Pâ†’R"""
        if (self._is_implication(p_implies_q) and self._is_implication(q_implies_r) and
            self._get_consequent(p_implies_q) == self._get_antecedent(q_implies_r)):
            antecedent = self._get_antecedent(p_implies_q)
            consequent = self._get_consequent(q_implies_r)
            return f"{antecedent} â†’ {consequent}"
        return None
    
    def _disjunctive_syllogism(self, p_or_q: str, not_p: str) -> Optional[str]:
        """é€‰è¨€ä¸‰æ®µè®ºï¼šå¦‚æœ Pâˆ¨Q ä¸” Â¬Pï¼Œåˆ™ Q"""
        if (self._is_disjunction(p_or_q) and self._is_negation(not_p)):
            operands = self._get_disjunction_operands(p_or_q)
            negated = self._get_negated_expression(not_p)
            for operand in operands:
                if operand != negated:
                    return operand
        return None
    
    def _conjunction(self, p: str, q: str) -> str:
        """åˆå–ï¼šå¦‚æœ P ä¸” Qï¼Œåˆ™ Pâˆ§Q"""
        return f"({p} âˆ§ {q})"
    
    def _simplification(self, p_and_q: str) -> List[str]:
        """ç®€åŒ–ï¼šå¦‚æœ Pâˆ§Qï¼Œåˆ™ P ä¸” Q"""
        if self._is_conjunction(p_and_q):
            return self._get_conjunction_operands(p_and_q)
        return []
    
    def _addition(self, p: str) -> str:
        """é™„åŠ ï¼šå¦‚æœ Pï¼Œåˆ™ Pâˆ¨Qï¼ˆå¯¹ä»»æ„ Qï¼‰"""
        return f"({p} âˆ¨ Q)"
    
    def infer(self) -> List[str]:
        """æ‰§è¡Œæ¨ç†"""
        results = []
        known_expressions = [str(premise) for premise in self.premises]
        
        # åº”ç”¨æ¨ç†è§„åˆ™
        for rule_name, rule_func in self.rules.items():
            if rule_name in ['modus_ponens', 'modus_tollens', 'hypothetical_syllogism', 'disjunctive_syllogism']:
                # äºŒå…ƒè§„åˆ™
                for i, expr1 in enumerate(known_expressions):
                    for j, expr2 in enumerate(known_expressions):
                        if i != j:
                            result = rule_func(expr1, expr2)
                            if result and result not in known_expressions:
                                results.append(f"{rule_name}: {expr1}, {expr2} âŠ¢ {result}")
                                known_expressions.append(result)
            
            elif rule_name == 'conjunction':
                # åˆå–è§„åˆ™
                for i, expr1 in enumerate(known_expressions):
                    for j, expr2 in enumerate(known_expressions):
                        if i != j:
                            result = rule_func(expr1, expr2)
                            if result not in known_expressions:
                                results.append(f"{rule_name}: {expr1}, {expr2} âŠ¢ {result}")
                                known_expressions.append(result)
            
            elif rule_name == 'simplification':
                # ç®€åŒ–è§„åˆ™
                for expr in known_expressions:
                    simplified = rule_func(expr)
                    for simple_expr in simplified:
                        if simple_expr not in known_expressions:
                            results.append(f"{rule_name}: {expr} âŠ¢ {simple_expr}")
                            known_expressions.append(simple_expr)
            
            elif rule_name == 'addition':
                # é™„åŠ è§„åˆ™
                for expr in known_expressions:
                    result = rule_func(expr)
                    if result not in known_expressions:
                        results.append(f"{rule_name}: {expr} âŠ¢ {result}")
                        known_expressions.append(result)
        
        return results
    
    def _is_implication(self, expr: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºè•´å«å¼"""
        return "â†’" in expr
    
    def _is_negation(self, expr: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¦å®šå¼"""
        return expr.startswith("Â¬")
    
    def _is_disjunction(self, expr: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæå–å¼"""
        return "âˆ¨" in expr
    
    def _is_conjunction(self, expr: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºåˆå–å¼"""
        return "âˆ§" in expr
    
    def _get_antecedent(self, implication: str) -> str:
        """è·å–è•´å«å¼çš„å‰ä»¶"""
        parts = implication.split("â†’")
        return parts[0].strip("()")
    
    def _get_consequent(self, implication: str) -> str:
        """è·å–è•´å«å¼çš„åä»¶"""
        parts = implication.split("â†’")
        return parts[1].strip("()")
    
    def _get_negated_expression(self, negation: str) -> str:
        """è·å–å¦å®šå¼ä¸­çš„è¡¨è¾¾å¼"""
        return negation[1:].strip("()")
    
    def _get_disjunction_operands(self, disjunction: str) -> List[str]:
        """è·å–æå–å¼çš„æ“ä½œæ•°"""
        # ç®€åŒ–å®ç°ï¼Œå‡è®¾æ ¼å¼ä¸º (P âˆ¨ Q)
        content = disjunction.strip("()")
        return [op.strip() for op in content.split("âˆ¨")]
    
    def _get_conjunction_operands(self, conjunction: str) -> List[str]:
        """è·å–åˆå–å¼çš„æ“ä½œæ•°"""
        # ç®€åŒ–å®ç°ï¼Œå‡è®¾æ ¼å¼ä¸º (P âˆ§ Q)
        content = conjunction.strip("()")
        return [op.strip() for op in content.split("âˆ§")]

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_logical_reasoning():
    """æ¼”ç¤ºé€»è¾‘æ¨ç†"""
    lr = LogicalReasoning()
    
    # æ·»åŠ å‰æ
    p = LogicalExpression(None, ["P"], is_atomic=True)
    p_implies_q = LogicalExpression(LogicOperator.IMPLIES, ["P", "Q"])
    q_implies_r = LogicalExpression(LogicOperator.IMPLIES, ["Q", "R"])
    
    lr.add_premise(p)
    lr.add_premise(p_implies_q)
    lr.add_premise(q_implies_r)
    
    print("=== é€»è¾‘æ¨ç†æ¼”ç¤º ===")
    print("å‰æ:")
    for premise in lr.premises:
        print(f"  {premise}")
    
    # æ‰§è¡Œæ¨ç†
    results = lr.infer()
    
    print("\næ¨ç†ç»“æœ:")
    for result in results:
        print(f"  {result}")

if __name__ == "__main__":
    demonstrate_logical_reasoning()
```

### 3. å½¢å¼åŒ–è¯æ˜ (Formal Proof)

**æ¦‚å¿µå®šä¹‰**: å½¢å¼åŒ–è¯æ˜æ˜¯ä½¿ç”¨ä¸¥æ ¼çš„æ•°å­¦è§„åˆ™å’Œé€»è¾‘æ¨ç†æ¥éªŒè¯å‘½é¢˜æ­£ç¡®æ€§çš„è¿‡ç¨‹ã€‚

**æ•°å­¦å½¢å¼**:
å½¢å¼åŒ–è¯æ˜å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$\Gamma \vdash \phi$$

å…¶ä¸­ï¼š

- $\Gamma$ æ˜¯å…¬ç†å’Œå‡è®¾é›†åˆ
- $\phi$ æ˜¯è¦è¯æ˜çš„å‘½é¢˜
- $\vdash$ è¡¨ç¤ºå¯è¯æ˜å…³ç³»

**Pythonå®ç°**:

```python
from typing import List, Dict, Set, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import json

class ProofStepType(Enum):
    """è¯æ˜æ­¥éª¤ç±»å‹"""
    AXIOM = "axiom"
    ASSUMPTION = "assumption"
    MODUS_PONENS = "modus_ponens"
    UNIVERSAL_GENERALIZATION = "universal_generalization"
    EXISTENTIAL_INTRODUCTION = "existential_introduction"
    CONTRADICTION = "contradiction"

@dataclass
class ProofStep:
    """è¯æ˜æ­¥éª¤"""
    step_number: int
    step_type: ProofStepType
    statement: str
    justification: str
    dependencies: List[int] = None
    
    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = []

class FormalProof:
    """å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ"""
    
    def __init__(self, theorem_name: str):
        self.theorem_name = theorem_name
        self.axioms: List[str] = []
        self.assumptions: List[str] = []
        self.steps: List[ProofStep] = []
        self.conclusion: str = ""
        self.proof_complete = False
    
    def add_axiom(self, axiom: str) -> None:
        """æ·»åŠ å…¬ç†"""
        self.axioms.append(axiom)
        step = ProofStep(
            step_number=len(self.steps) + 1,
            step_type=ProofStepType.AXIOM,
            statement=axiom,
            justification="å…¬ç†"
        )
        self.steps.append(step)
    
    def add_assumption(self, assumption: str) -> None:
        """æ·»åŠ å‡è®¾"""
        self.assumptions.append(assumption)
        step = ProofStep(
            step_number=len(self.steps) + 1,
            step_type=ProofStepType.ASSUMPTION,
            statement=assumption,
            justification="å‡è®¾"
        )
        self.steps.append(step)
    
    def add_step(self, statement: str, step_type: ProofStepType, 
                 justification: str, dependencies: List[int] = None) -> None:
        """æ·»åŠ è¯æ˜æ­¥éª¤"""
        step = ProofStep(
            step_number=len(self.steps) + 1,
            step_type=step_type,
            statement=statement,
            justification=justification,
            dependencies=dependencies or []
        )
        self.steps.append(step)
    
    def set_conclusion(self, conclusion: str) -> None:
        """è®¾ç½®ç»“è®º"""
        self.conclusion = conclusion
    
    def verify_proof(self) -> Dict[str, Any]:
        """éªŒè¯è¯æ˜çš„æ­£ç¡®æ€§"""
        verification_result = {
            'valid': True,
            'errors': [],
            'warnings': []
        }
        
        # æ£€æŸ¥æ¯ä¸ªæ­¥éª¤çš„ä¾èµ–
        for i, step in enumerate(self.steps):
            # æ£€æŸ¥ä¾èµ–æ˜¯å¦æœ‰æ•ˆ
            for dep in step.dependencies:
                if dep < 1 or dep > len(self.steps):
                    verification_result['errors'].append(
                        f"æ­¥éª¤ {step.step_number}: æ— æ•ˆä¾èµ– {dep}"
                    )
                    verification_result['valid'] = False
                elif dep >= step.step_number:
                    verification_result['errors'].append(
                        f"æ­¥éª¤ {step.step_number}: ä¾èµ–æœªæ¥æ­¥éª¤ {dep}"
                    )
                    verification_result['valid'] = False
            
            # æ£€æŸ¥é€»è¾‘ä¸€è‡´æ€§
            if not self._verify_step_logic(step):
                verification_result['warnings'].append(
                    f"æ­¥éª¤ {step.step_number}: é€»è¾‘éªŒè¯å¤±è´¥"
                )
        
        # æ£€æŸ¥ç»“è®º
        if self.conclusion and self.steps:
            last_step = self.steps[-1]
            if last_step.statement != self.conclusion:
                verification_result['warnings'].append(
                    "æœ€åæ­¥éª¤ä¸ç»“è®ºä¸åŒ¹é…"
                )
        
        return verification_result
    
    def _verify_step_logic(self, step: ProofStep) -> bool:
        """éªŒè¯å•ä¸ªæ­¥éª¤çš„é€»è¾‘"""
        # ç®€åŒ–çš„é€»è¾‘éªŒè¯
        if step.step_type == ProofStepType.AXIOM:
            return True
        elif step.step_type == ProofStepType.ASSUMPTION:
            return True
        elif step.step_type == ProofStepType.MODUS_PONENS:
            # æ£€æŸ¥æ˜¯å¦çœŸçš„æ˜¯å‡è¨€æ¨ç†
            return self._verify_modus_ponens(step)
        else:
            return True  # å…¶ä»–ç±»å‹æš‚æ—¶å‡è®¾æ­£ç¡®
    
    def _verify_modus_ponens(self, step: ProofStep) -> bool:
        """éªŒè¯å‡è¨€æ¨ç†"""
        if len(step.dependencies) != 2:
            return False
        
        # è·å–ä¾èµ–çš„æ­¥éª¤
        dep1 = self.steps[step.dependencies[0] - 1]
        dep2 = self.steps[step.dependencies[1] - 1]
        
        # æ£€æŸ¥æ˜¯å¦ä¸€ä¸ªæ˜¯è•´å«å¼ï¼Œå¦ä¸€ä¸ªæ˜¯å‰ä»¶
        if "â†’" in dep1.statement and dep2.statement in dep1.statement.split("â†’")[0]:
            return True
        elif "â†’" in dep2.statement and dep1.statement in dep2.statement.split("â†’")[0]:
            return True
        
        return False
    
    def export_proof(self) -> Dict[str, Any]:
        """å¯¼å‡ºè¯æ˜"""
        return {
            'theorem_name': self.theorem_name,
            'axioms': self.axioms,
            'assumptions': self.assumptions,
            'steps': [
                {
                    'step_number': step.step_number,
                    'step_type': step.step_type.value,
                    'statement': step.statement,
                    'justification': step.justification,
                    'dependencies': step.dependencies
                }
                for step in self.steps
            ],
            'conclusion': self.conclusion,
            'verification': self.verify_proof()
        }
    
    def print_proof(self) -> None:
        """æ‰“å°è¯æ˜"""
        print(f"å®šç†: {self.theorem_name}")
        print("=" * 50)
        
        if self.axioms:
            print("å…¬ç†:")
            for axiom in self.axioms:
                print(f"  {axiom}")
            print()
        
        if self.assumptions:
            print("å‡è®¾:")
            for assumption in self.assumptions:
                print(f"  {assumption}")
            print()
        
        print("è¯æ˜:")
        for step in self.steps:
            deps_str = f" [{', '.join(map(str, step.dependencies))}]" if step.dependencies else ""
            print(f"{step.step_number:2d}. {step.statement:<30} {step.justification}{deps_str}")
        
        if self.conclusion:
            print(f"\nç»“è®º: {self.conclusion}")

# ä½¿ç”¨ç¤ºä¾‹ï¼šè¯æ˜ä¸€ä¸ªç®€å•çš„é€»è¾‘å®šç†
def prove_simple_theorem():
    """è¯æ˜ç®€å•å®šç†ï¼šå¦‚æœ Pâ†’Q ä¸” Qâ†’Rï¼Œåˆ™ Pâ†’R"""
    proof = FormalProof("å‡è¨€ä¸‰æ®µè®º")
    
    # æ·»åŠ å‡è®¾
    proof.add_assumption("P â†’ Q")
    proof.add_assumption("Q â†’ R")
    proof.add_assumption("P")
    
    # è¯æ˜æ­¥éª¤
    proof.add_step("Q", ProofStepType.MODUS_PONENS, "å‡è¨€æ¨ç†", [1, 3])
    proof.add_step("R", ProofStepType.MODUS_PONENS, "å‡è¨€æ¨ç†", [2, 4])
    
    # è®¾ç½®ç»“è®º
    proof.set_conclusion("R")
    
    print("=== å½¢å¼åŒ–è¯æ˜æ¼”ç¤º ===")
    proof.print_proof()
    
    # éªŒè¯è¯æ˜
    verification = proof.verify_proof()
    print(f"\néªŒè¯ç»“æœ: {'æœ‰æ•ˆ' if verification['valid'] else 'æ— æ•ˆ'}")
    
    if verification['errors']:
        print("é”™è¯¯:")
        for error in verification['errors']:
            print(f"  {error}")
    
    if verification['warnings']:
        print("è­¦å‘Š:")
        for warning in verification['warnings']:
            print(f"  {warning}")

if __name__ == "__main__":
    prove_simple_theorem()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00-01-ç¼–ç¨‹å“²å­¦](./00-01-ç¼–ç¨‹å“²å­¦.md)
- [00-03-è®¡ç®—æ€ç»´](./00-03-è®¡ç®—æ€ç»´.md)
- [01-02-é€»è¾‘å­¦åŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-02-é€»è¾‘å­¦åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to automata theory, languages, and computation.
2. Enderton, H. B. (2001). A mathematical introduction to logic.
3. Mendelson, E. (2015). Introduction to mathematical logic.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
