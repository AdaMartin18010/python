# 00-02-形式化思维

## 概述

形式化思维是软件工程和计算科学的核心思维方法，通过严格的数学语言和逻辑推理来分析和解决问题。本文档建立形式化思维的理论基础和实践方法。

## 1. 形式化思维基础

### 1.1 概念定义

**形式化思维** (Formal Thinking) 是使用精确的数学语言、符号系统和逻辑推理方法进行问题分析和解决的能力。

### 1.2 数学形式化定义

设 $F$ 为形式化思维，$P$ 为问题空间，$S$ 为符号系统，$L$ 为逻辑系统，$R$ 为推理规则，则：

$$F: P \times S \times L \times R \rightarrow S$$

其中：

- $P$ 表示问题空间
- $S$ 表示符号系统
- $L$ 表示逻辑系统
- $R$ 表示推理规则

### 1.3 形式化思维的特征

1. **精确性**: 使用精确的数学语言
2. **严谨性**: 遵循严格的逻辑推理
3. **抽象性**: 抽象问题的本质特征
4. **系统性**: 系统性的分析方法

## 2. 符号系统

### 2.1 数学符号

#### 2.1.1 集合论符号

```python
from typing import Set, List, Dict, Any, Union, Optional
from dataclasses import dataclass
from enum import Enum
import math

class SetTheory:
    """集合论符号系统"""
    
    def __init__(self):
        self.universal_set: Set[Any] = set()
        self.sets: Dict[str, Set[Any]] = {}
    
    def create_set(self, name: str, elements: Set[Any]) -> None:
        """创建集合 A = {a, b, c}"""
        self.sets[name] = elements
        self.universal_set.update(elements)
    
    def union(self, set_a: str, set_b: str) -> Set[Any]:
        """并集 A ∪ B"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] | self.sets[set_b]
        return set()
    
    def intersection(self, set_a: str, set_b: str) -> Set[Any]:
        """交集 A ∩ B"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] & self.sets[set_b]
        return set()
    
    def difference(self, set_a: str, set_b: str) -> Set[Any]:
        """差集 A - B"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] - self.sets[set_b]
        return set()
    
    def complement(self, set_name: str) -> Set[Any]:
        """补集 A'"""
        if set_name in self.sets:
            return self.universal_set - self.sets[set_name]
        return set()
    
    def is_subset(self, set_a: str, set_b: str) -> bool:
        """子集 A ⊆ B"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a].issubset(self.sets[set_b])
        return False
    
    def is_proper_subset(self, set_a: str, set_b: str) -> bool:
        """真子集 A ⊂ B"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] < self.sets[set_b]
        return False
    
    def cartesian_product(self, set_a: str, set_b: str) -> Set[tuple]:
        """笛卡尔积 A × B"""
        if set_a in self.sets and set_b in self.sets:
            return {(a, b) for a in self.sets[set_a] for b in self.sets[set_b]}
        return set()

# 使用示例
def test_set_theory():
    """测试集合论"""
    st = SetTheory()
    
    # 创建集合
    st.create_set("A", {1, 2, 3, 4})
    st.create_set("B", {3, 4, 5, 6})
    st.create_set("C", {1, 2})
    
    print(f"集合 A: {st.sets['A']}")
    print(f"集合 B: {st.sets['B']}")
    print(f"并集 A ∪ B: {st.union('A', 'B')}")
    print(f"交集 A ∩ B: {st.intersection('A', 'B')}")
    print(f"差集 A - B: {st.difference('A', 'B')}")
    print(f"C 是 A 的子集: {st.is_subset('C', 'A')}")
    print(f"笛卡尔积 A × C: {st.cartesian_product('A', 'C')}")

if __name__ == "__main__":
    test_set_theory()
```

#### 2.1.2 逻辑符号

```python
class LogicSymbols:
    """逻辑符号系统"""
    
    def __init__(self):
        self.propositions: Dict[str, bool] = {}
        self.operators = {
            '∧': lambda x, y: x and y,  # 与
            '∨': lambda x, y: x or y,   # 或
            '¬': lambda x: not x,       # 非
            '→': lambda x, y: (not x) or y,  # 蕴含
            '↔': lambda x, y: x == y,   # 等价
            '⊕': lambda x, y: x != y    # 异或
        }
    
    def set_proposition(self, name: str, value: bool) -> None:
        """设置命题值"""
        self.propositions[name] = value
    
    def evaluate_expression(self, expr: str) -> bool:
        """评估逻辑表达式"""
        # 替换命题为值
        for name, value in self.propositions.items():
            expr = expr.replace(name, str(value).lower())
        
        # 替换逻辑运算符
        for symbol, operator in self.operators.items():
            if symbol in expr:
                # 这里需要更复杂的表达式解析
                # 简化版本
                pass
        
        return eval(expr)
    
    def truth_table(self, variables: List[str]) -> List[Dict[str, bool]]:
        """生成真值表"""
        table = []
        n = len(variables)
        
        for i in range(2**n):
            row = {}
            for j, var in enumerate(variables):
                row[var] = bool((i >> j) & 1)
            table.append(row)
        
        return table

class FormalLogic:
    """形式逻辑系统"""
    
    def __init__(self):
        self.axioms: Set[str] = set()
        self.theorems: Dict[str, str] = {}
        self.rules: Dict[str, callable] = {}
    
    def add_axiom(self, axiom: str) -> None:
        """添加公理"""
        self.axioms.add(axiom)
    
    def add_rule(self, name: str, rule: callable) -> None:
        """添加推理规则"""
        self.rules[name] = rule
    
    def modus_ponens(self, premise: str, implication: str) -> Optional[str]:
        """假言推理 (P → Q, P ⊢ Q)"""
        if premise in self.axioms and implication.startswith(f"{premise} →"):
            conclusion = implication.split(" → ")[1]
            return conclusion
        return None
    
    def modus_tollens(self, premise: str, implication: str) -> Optional[str]:
        """拒取式 (P → Q, ¬Q ⊢ ¬P)"""
        if premise.startswith("¬") and implication.startswith("P →"):
            # 简化实现
            return "¬P"
        return None
    
    def proof_by_contradiction(self, statement: str) -> bool:
        """反证法"""
        # 假设结论为假，如果能推出矛盾，则原命题为真
        try:
            # 这里需要更复杂的逻辑推理实现
            return True
        except:
            return False

# 使用示例
def test_logic_symbols():
    """测试逻辑符号"""
    ls = LogicSymbols()
    
    # 设置命题
    ls.set_proposition("P", True)
    ls.set_proposition("Q", False)
    
    # 生成真值表
    table = ls.truth_table(["P", "Q"])
    print("真值表:")
    for row in table:
        print(row)

def test_formal_logic():
    """测试形式逻辑"""
    fl = FormalLogic()
    
    # 添加公理
    fl.add_axiom("P")
    fl.add_axiom("P → Q")
    
    # 应用推理规则
    conclusion = fl.modus_ponens("P", "P → Q")
    print(f"推理结论: {conclusion}")

if __name__ == "__main__":
    test_logic_symbols()
    test_formal_logic()
```

### 2.2 编程语言符号

```python
class ProgrammingSymbols:
    """编程语言符号系统"""
    
    def __init__(self):
        self.symbols = {
            # 赋值符号
            'assignment': '=',
            'augmented_assignment': ['+=', '-=', '*=', '/=', '%=', '**=', '//='],
            
            # 比较符号
            'comparison': ['==', '!=', '<', '>', '<=', '>='],
            
            # 逻辑符号
            'logical': ['and', 'or', 'not'],
            
            # 位运算符号
            'bitwise': ['&', '|', '^', '~', '<<', '>>'],
            
            # 集合符号
            'set_operations': ['in', 'not in', 'is', 'is not'],
            
            # 函数符号
            'function': ['def', 'lambda', 'return', 'yield'],
            
            # 控制流符号
            'control_flow': ['if', 'elif', 'else', 'for', 'while', 'break', 'continue'],
            
            # 异常处理符号
            'exception': ['try', 'except', 'finally', 'raise'],
            
            # 类符号
            'class': ['class', 'self', 'super', 'staticmethod', 'classmethod'],
            
            # 模块符号
            'module': ['import', 'from', 'as'],
        }
    
    def get_symbols_by_category(self, category: str) -> List[str]:
        """获取指定类别的符号"""
        return self.symbols.get(category, [])
    
    def is_valid_symbol(self, symbol: str, category: str) -> bool:
        """检查符号是否有效"""
        category_symbols = self.get_symbols_by_category(category)
        return symbol in category_symbols
    
    def get_symbol_meaning(self, symbol: str) -> Dict[str, str]:
        """获取符号含义"""
        meanings = {
            '=': '赋值操作',
            '==': '相等比较',
            '!=': '不等比较',
            '<': '小于比较',
            '>': '大于比较',
            'and': '逻辑与',
            'or': '逻辑或',
            'not': '逻辑非',
            'def': '函数定义',
            'class': '类定义',
            'import': '模块导入',
            'if': '条件判断',
            'for': '循环语句',
            'try': '异常处理',
        }
        return {symbol: meanings.get(symbol, '未知符号')}

# 使用示例
def test_programming_symbols():
    """测试编程符号"""
    ps = ProgrammingSymbols()
    
    print("比较符号:", ps.get_symbols_by_category('comparison'))
    print("逻辑符号:", ps.get_symbols_by_category('logical'))
    print("'==' 是否有效比较符号:", ps.is_valid_symbol('==', 'comparison'))
    print("符号含义:", ps.get_symbol_meaning('=='))

if __name__ == "__main__":
    test_programming_symbols()
```

## 3. 形式化推理

### 3.1 演绎推理

演绎推理是从一般原理推导出特殊结论的推理方法。

#### 3.1.1 三段论

```python
class Syllogism:
    """三段论推理"""
    
    def __init__(self):
        self.major_premise: str = ""
        self.minor_premise: str = ""
        self.conclusion: str = ""
    
    def set_premises(self, major: str, minor: str) -> None:
        """设置前提"""
        self.major_premise = major
        self.minor_premise = minor
    
    def derive_conclusion(self) -> str:
        """推导结论"""
        # 简化的三段论推理
        # 大前提: 所有M都是P
        # 小前提: 所有S都是M
        # 结论: 所有S都是P
        
        if "所有" in self.major_premise and "所有" in self.minor_premise:
            # 提取中项M
            major_parts = self.major_premise.split("都是")
            minor_parts = self.minor_premise.split("都是")
            
            if len(major_parts) == 2 and len(minor_parts) == 2:
                major_subject = major_parts[0].replace("所有", "").strip()
                major_predicate = major_parts[1].strip()
                minor_subject = minor_parts[0].replace("所有", "").strip()
                minor_predicate = minor_parts[1].strip()
                
                # 检查中项
                if major_subject == minor_predicate:
                    self.conclusion = f"所有{minor_subject}都是{major_predicate}"
                    return self.conclusion
        
        return "无法推导出有效结论"
    
    def validate_syllogism(self) -> bool:
        """验证三段论的有效性"""
        # 检查是否包含中项
        if not self.conclusion:
            return False
        
        # 检查结论是否逻辑有效
        return "所有" in self.conclusion and "都是" in self.conclusion

# 使用示例
def test_syllogism():
    """测试三段论"""
    syllogism = Syllogism()
    
    # 经典三段论例子
    syllogism.set_premises("所有人类都是动物", "所有哲学家都是人类")
    conclusion = syllogism.derive_conclusion()
    print(f"大前提: {syllogism.major_premise}")
    print(f"小前提: {syllogism.minor_premise}")
    print(f"结论: {conclusion}")
    print(f"有效性: {syllogism.validate_syllogism()}")

if __name__ == "__main__":
    test_syllogism()
```

#### 3.1.2 数学归纳法

```python
class MathematicalInduction:
    """数学归纳法"""
    
    def __init__(self):
        self.base_case: int = 0
        self.predicate: Optional[callable] = None
    
    def set_predicate(self, predicate: callable) -> None:
        """设置谓词函数"""
        self.predicate = predicate
    
    def set_base_case(self, base: int) -> None:
        """设置基础情况"""
        self.base_case = base
    
    def prove_by_induction(self, max_n: int = 100) -> bool:
        """使用数学归纳法证明"""
        if not self.predicate:
            return False
        
        # 基础情况
        if not self.predicate(self.base_case):
            print(f"基础情况失败: P({self.base_case}) = False")
            return False
        
        # 归纳步骤
        for n in range(self.base_case, max_n):
            if self.predicate(n) and not self.predicate(n + 1):
                print(f"归纳步骤失败: P({n}) = True 但 P({n + 1}) = False")
                return False
        
        print("数学归纳法证明成功")
        return True
    
    def strong_induction(self, max_n: int = 100) -> bool:
        """强归纳法"""
        if not self.predicate:
            return False
        
        # 基础情况
        if not self.predicate(self.base_case):
            return False
        
        # 强归纳步骤
        for n in range(self.base_case + 1, max_n):
            # 假设对所有 k < n，P(k) 为真
            all_previous_true = all(self.predicate(k) for k in range(self.base_case, n))
            if all_previous_true and not self.predicate(n):
                return False
        
        return True

# 使用示例
def test_mathematical_induction():
    """测试数学归纳法"""
    induction = MathematicalInduction()
    
    # 证明 1 + 2 + ... + n = n(n+1)/2
    def sum_formula(n: int) -> bool:
        return sum(range(1, n + 1)) == n * (n + 1) // 2
    
    induction.set_predicate(sum_formula)
    induction.set_base_case(1)
    
    result = induction.prove_by_induction(10)
    print(f"数学归纳法证明结果: {result}")
    
    # 强归纳法证明斐波那契数列性质
    def fibonacci_property(n: int) -> bool:
        if n < 2:
            return True
        # 证明 F(n) < 2^n
        fib = [1, 1]
        for i in range(2, n + 1):
            fib.append(fib[i-1] + fib[i-2])
        return fib[n] < 2**n
    
    induction.set_predicate(fibonacci_property)
    induction.set_base_case(0)
    
    strong_result = induction.strong_induction(10)
    print(f"强归纳法证明结果: {strong_result}")

if __name__ == "__main__":
    test_mathematical_induction()
```

### 3.2 归纳推理

归纳推理是从特殊事实推导出一般原理的推理方法。

```python
class InductiveReasoning:
    """归纳推理"""
    
    def __init__(self):
        self.observations: List[Any] = []
        self.patterns: List[str] = []
        self.hypotheses: List[str] = []
    
    def add_observation(self, observation: Any) -> None:
        """添加观察"""
        self.observations.append(observation)
    
    def find_patterns(self) -> List[str]:
        """寻找模式"""
        if len(self.observations) < 2:
            return []
        
        patterns = []
        
        # 数值模式
        if all(isinstance(x, (int, float)) for x in self.observations):
            patterns.extend(self._find_numerical_patterns())
        
        # 序列模式
        patterns.extend(self._find_sequence_patterns())
        
        # 结构模式
        patterns.extend(self._find_structural_patterns())
        
        self.patterns = patterns
        return patterns
    
    def _find_numerical_patterns(self) -> List[str]:
        """寻找数值模式"""
        patterns = []
        nums = [float(x) for x in self.observations]
        
        # 检查等差数列
        if len(nums) >= 3:
            diffs = [nums[i+1] - nums[i] for i in range(len(nums)-1)]
            if len(set(diffs)) == 1:
                patterns.append(f"等差数列，公差为 {diffs[0]}")
        
        # 检查等比数列
        if len(nums) >= 3:
            ratios = [nums[i+1] / nums[i] for i in range(len(nums)-1)]
            if len(set(ratios)) == 1:
                patterns.append(f"等比数列，公比为 {ratios[0]}")
        
        return patterns
    
    def _find_sequence_patterns(self) -> List[str]:
        """寻找序列模式"""
        patterns = []
        
        # 检查重复模式
        if len(self.observations) >= 4:
            for pattern_length in range(1, len(self.observations) // 2 + 1):
                pattern = self.observations[:pattern_length]
                if self._is_repeating_pattern(pattern):
                    patterns.append(f"重复模式: {pattern}")
        
        return patterns
    
    def _find_structural_patterns(self) -> List[str]:
        """寻找结构模式"""
        patterns = []
        
        # 检查类型模式
        type_counts = {}
        for obs in self.observations:
            obs_type = type(obs).__name__
            type_counts[obs_type] = type_counts.get(obs_type, 0) + 1
        
        if len(type_counts) == 1:
            patterns.append(f"统一类型: {list(type_counts.keys())[0]}")
        
        return patterns
    
    def _is_repeating_pattern(self, pattern: List[Any]) -> bool:
        """检查是否为重复模式"""
        pattern_len = len(pattern)
        if len(self.observations) < pattern_len * 2:
            return False
        
        for i in range(pattern_len, len(self.observations), pattern_len):
            if i + pattern_len > len(self.observations):
                break
            if self.observations[i:i+pattern_len] != pattern:
                return False
        
        return True
    
    def generate_hypotheses(self) -> List[str]:
        """生成假设"""
        if not self.patterns:
            self.find_patterns()
        
        hypotheses = []
        
        for pattern in self.patterns:
            if "等差数列" in pattern:
                hypotheses.append("序列遵循线性增长规律")
            elif "等比数列" in pattern:
                hypotheses.append("序列遵循指数增长规律")
            elif "重复模式" in pattern:
                hypotheses.append("序列具有周期性特征")
            elif "统一类型" in pattern:
                hypotheses.append("所有元素属于同一类型")
        
        self.hypotheses = hypotheses
        return hypotheses
    
    def test_hypothesis(self, hypothesis: str, new_observations: List[Any]) -> bool:
        """测试假设"""
        if "线性增长" in hypothesis:
            return self._test_linear_growth(new_observations)
        elif "指数增长" in hypothesis:
            return self._test_exponential_growth(new_observations)
        elif "周期性" in hypothesis:
            return self._test_periodicity(new_observations)
        
        return False
    
    def _test_linear_growth(self, new_obs: List[Any]) -> bool:
        """测试线性增长假设"""
        if not all(isinstance(x, (int, float)) for x in new_obs):
            return False
        
        all_nums = [float(x) for x in self.observations + new_obs]
        if len(all_nums) < 3:
            return False
        
        diffs = [all_nums[i+1] - all_nums[i] for i in range(len(all_nums)-1)]
        return len(set(diffs)) == 1
    
    def _test_exponential_growth(self, new_obs: List[Any]) -> bool:
        """测试指数增长假设"""
        if not all(isinstance(x, (int, float)) for x in new_obs):
            return False
        
        all_nums = [float(x) for x in self.observations + new_obs]
        if len(all_nums) < 3:
            return False
        
        ratios = [all_nums[i+1] / all_nums[i] for i in range(len(all_nums)-1)]
        return len(set(ratios)) == 1
    
    def _test_periodicity(self, new_obs: List[Any]) -> bool:
        """测试周期性假设"""
        # 简化实现
        return len(new_obs) > 0

# 使用示例
def test_inductive_reasoning():
    """测试归纳推理"""
    reasoning = InductiveReasoning()
    
    # 添加观察数据
    observations = [2, 4, 6, 8, 10, 12]
    for obs in observations:
        reasoning.add_observation(obs)
    
    # 寻找模式
    patterns = reasoning.find_patterns()
    print(f"发现的模式: {patterns}")
    
    # 生成假设
    hypotheses = reasoning.generate_hypotheses()
    print(f"生成的假设: {hypotheses}")
    
    # 测试假设
    new_observations = [14, 16, 18]
    for hypothesis in hypotheses:
        result = reasoning.test_hypothesis(hypothesis, new_observations)
        print(f"假设 '{hypothesis}' 测试结果: {result}")

if __name__ == "__main__":
    test_inductive_reasoning()
```

## 4. 形式化证明

### 4.1 证明方法

```python
class FormalProof:
    """形式化证明系统"""
    
    def __init__(self):
        self.axioms: Set[str] = set()
        self.theorems: Dict[str, str] = {}
        self.proof_steps: List[str] = []
    
    def add_axiom(self, axiom: str) -> None:
        """添加公理"""
        self.axioms.add(axiom)
    
    def add_theorem(self, name: str, statement: str) -> None:
        """添加定理"""
        self.theorems[name] = statement
    
    def direct_proof(self, premise: str, conclusion: str) -> bool:
        """直接证明"""
        self.proof_steps = []
        self.proof_steps.append(f"前提: {premise}")
        
        # 简化的直接证明
        if premise in self.axioms:
            self.proof_steps.append(f"应用公理: {premise}")
            self.proof_steps.append(f"结论: {conclusion}")
            return True
        
        return False
    
    def proof_by_contradiction(self, statement: str) -> bool:
        """反证法"""
        self.proof_steps = []
        self.proof_steps.append(f"要证明: {statement}")
        self.proof_steps.append(f"假设: ¬{statement}")
        
        # 尝试推导矛盾
        try:
            # 这里需要更复杂的逻辑推理
            self.proof_steps.append("推导出矛盾")
            self.proof_steps.append(f"因此 {statement} 为真")
            return True
        except:
            self.proof_steps.append("无法推导出矛盾")
            return False
    
    def proof_by_induction(self, predicate: callable, base_case: int = 0) -> bool:
        """数学归纳法证明"""
        self.proof_steps = []
        self.proof_steps.append("使用数学归纳法")
        
        # 基础情况
        if not predicate(base_case):
            self.proof_steps.append(f"基础情况 P({base_case}) 失败")
            return False
        
        self.proof_steps.append(f"基础情况 P({base_case}) 成立")
        
        # 归纳步骤
        for n in range(base_case, 100):  # 限制范围
            if predicate(n) and not predicate(n + 1):
                self.proof_steps.append(f"归纳步骤失败: P({n}) 成立但 P({n + 1}) 不成立")
                return False
        
        self.proof_steps.append("归纳步骤成立")
        self.proof_steps.append("因此对所有 n ≥ 0，P(n) 成立")
        return True
    
    def get_proof_steps(self) -> List[str]:
        """获取证明步骤"""
        return self.proof_steps.copy()

# 使用示例
def test_formal_proof():
    """测试形式化证明"""
    proof = FormalProof()
    
    # 添加公理
    proof.add_axiom("P")
    proof.add_axiom("P → Q")
    
    # 直接证明
    result = proof.direct_proof("P", "Q")
    print(f"直接证明结果: {result}")
    print("证明步骤:")
    for step in proof.get_proof_steps():
        print(f"  {step}")
    
    # 数学归纳法证明
    def sum_formula(n: int) -> bool:
        return sum(range(1, n + 1)) == n * (n + 1) // 2
    
    induction_result = proof.proof_by_induction(sum_formula, 1)
    print(f"\n数学归纳法证明结果: {induction_result}")
    print("证明步骤:")
    for step in proof.get_proof_steps():
        print(f"  {step}")

if __name__ == "__main__":
    test_formal_proof()
```

## 5. 形式化思维在编程中的应用

### 5.1 算法正确性证明

```python
class AlgorithmCorrectness:
    """算法正确性证明"""
    
    def __init__(self):
        self.preconditions: List[str] = []
        self.postconditions: List[str] = []
        self.invariants: List[str] = []
    
    def set_preconditions(self, conditions: List[str]) -> None:
        """设置前置条件"""
        self.preconditions = conditions
    
    def set_postconditions(self, conditions: List[str]) -> None:
        """设置后置条件"""
        self.postconditions = conditions
    
    def add_invariant(self, invariant: str) -> None:
        """添加循环不变量"""
        self.invariants.append(invariant)
    
    def prove_termination(self, algorithm: callable, *args) -> bool:
        """证明算法终止性"""
        try:
            # 尝试执行算法
            result = algorithm(*args)
            return True
        except RecursionError:
            return False
        except Exception:
            return True  # 其他异常不影响终止性
    
    def prove_correctness(self, algorithm: callable, test_cases: List[tuple]) -> bool:
        """证明算法正确性"""
        for args, expected in test_cases:
            try:
                result = algorithm(*args)
                if result != expected:
                    print(f"测试失败: 输入 {args}, 期望 {expected}, 实际 {result}")
                    return False
            except Exception as e:
                print(f"算法执行错误: {e}")
                return False
        
        return True
    
    def prove_complexity(self, algorithm: callable, input_sizes: List[int]) -> str:
        """分析算法复杂度"""
        import time
        
        times = []
        for size in input_sizes:
            # 生成测试数据
            test_data = list(range(size))
            
            start_time = time.time()
            algorithm(test_data)
            end_time = time.time()
            
            times.append(end_time - start_time)
        
        # 分析增长趋势
        if len(times) >= 2:
            ratios = [times[i] / times[i-1] for i in range(1, len(times))]
            avg_ratio = sum(ratios) / len(ratios)
            
            if avg_ratio < 1.5:
                return "O(1) - 常数时间"
            elif avg_ratio < 2.5:
                return "O(log n) - 对数时间"
            elif avg_ratio < 4:
                return "O(n) - 线性时间"
            elif avg_ratio < 8:
                return "O(n log n) - 线性对数时间"
            else:
                return "O(n²) - 平方时间"
        
        return "无法确定"

# 使用示例
def test_algorithm_correctness():
    """测试算法正确性证明"""
    correctness = AlgorithmCorrectness()
    
    # 设置条件
    correctness.set_preconditions(["输入数组不为空"])
    correctness.set_postconditions(["返回排序后的数组"])
    correctness.add_invariant("子数组保持有序")
    
    # 测试排序算法
    def bubble_sort(arr: List[int]) -> List[int]:
        """冒泡排序"""
        arr = arr.copy()
        n = len(arr)
        for i in range(n):
            for j in range(0, n - i - 1):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
        return arr
    
    # 测试用例
    test_cases = [
        ([3, 1, 4, 1, 5], [1, 1, 3, 4, 5]),
        ([1], [1]),
        ([], []),
        ([5, 4, 3, 2, 1], [1, 2, 3, 4, 5])
    ]
    
    # 证明正确性
    is_correct = correctness.prove_correctness(bubble_sort, test_cases)
    print(f"算法正确性: {is_correct}")
    
    # 证明终止性
    terminates = correctness.prove_termination(bubble_sort, [1, 2, 3])
    print(f"算法终止性: {terminates}")
    
    # 分析复杂度
    complexity = correctness.prove_complexity(bubble_sort, [100, 200, 400, 800])
    print(f"算法复杂度: {complexity}")

if __name__ == "__main__":
    test_algorithm_correctness()
```

## 6. 总结

形式化思维为软件工程提供了严格的推理基础，包括：

1. **符号系统**: 提供精确的数学和逻辑符号
2. **推理方法**: 演绎推理和归纳推理
3. **证明技术**: 直接证明、反证法、数学归纳法
4. **应用实践**: 算法正确性证明和复杂度分析

这些形式化方法确保了软件系统的可靠性和正确性，为后续的理论基础层提供了严格的数学支撑。

## 相关链接

- [00-01-编程哲学](./00-01-编程哲学.md)
- [00-03-计算思维](./00-03-计算思维.md)
- [01-01-数学基础](../01-形式科学/01-01-数学基础.md)
- [01-02-逻辑学](../01-形式科学/01-02-逻辑学.md)
- [02-01-算法理论](../02-理论基础/02-01-算法理论.md)
