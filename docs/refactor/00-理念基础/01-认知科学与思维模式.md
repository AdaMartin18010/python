# 01. 认知科学与思维模式

## 概述

认知科学是研究人类思维、学习和智能的跨学科领域。在软件工程中，理解认知科学原理有助于设计更符合人类认知特点的系统和工具。

## 1. 认知模型形式化

### 1.1 工作记忆模型

**形式化定义**：

```math
工作记忆系统 W = (S, C, A, R)
```

其中：

- $S$ 是短期存储空间，容量有限
- $C$ 是中央执行器，负责注意控制
- $A$ 是语音环路，处理语言信息
- $R$ 是视觉空间画板，处理视觉信息

**容量限制定理**：

```math
|S| ≤ 7 ± 2 \text{ 个信息块}
```

**Python实现**：

```python
from typing import List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import asyncio
from collections import deque

class InformationType(Enum):
    """信息类型枚举"""
    VERBAL = "verbal"
    VISUAL = "visual"
    SPATIAL = "spatial"
    NUMERICAL = "numerical"

@dataclass
class InformationChunk:
    """信息块"""
    id: str
    content: Any
    type: InformationType
    priority: float
    timestamp: float
    associations: List[str]

class WorkingMemory:
    """工作记忆模型"""
    
    def __init__(self, capacity: int = 7):
        self.capacity = capacity
        self.short_term_store: deque[InformationChunk] = deque(maxlen=capacity)
        self.central_executive = CentralExecutive()
        self.phonological_loop = PhonologicalLoop()
        self.visuospatial_sketchpad = VisuospatialSketchpad()
    
    def add_information(self, chunk: InformationChunk) -> bool:
        """添加信息到工作记忆"""
        if len(self.short_term_store) >= self.capacity:
            # 移除最低优先级的信息
            self._remove_lowest_priority()
        
        self.short_term_store.append(chunk)
        return True
    
    def _remove_lowest_priority(self):
        """移除最低优先级的信息"""
        if not self.short_term_store:
            return
        
        min_priority = min(chunk.priority for chunk in self.short_term_store)
        self.short_term_store = deque(
            [chunk for chunk in self.short_term_store if chunk.priority > min_priority],
            maxlen=self.capacity
        )
    
    def retrieve_information(self, chunk_id: str) -> Optional[InformationChunk]:
        """检索信息"""
        for chunk in self.short_term_store:
            if chunk.id == chunk_id:
                return chunk
        return None
    
    def get_memory_load(self) -> float:
        """获取记忆负载"""
        return len(self.short_term_store) / self.capacity

class CentralExecutive:
    """中央执行器"""
    
    def __init__(self):
        self.attention_focus: Optional[str] = None
        self.task_switching_cost = 0.5
    
    def focus_attention(self, chunk_id: str):
        """聚焦注意力"""
        self.attention_focus = chunk_id
    
    def switch_task(self) -> float:
        """任务切换成本"""
        return self.task_switching_cost

class PhonologicalLoop:
    """语音环路"""
    
    def __init__(self):
        self.verbal_buffer: List[str] = []
        self.articulatory_rehearsal_rate = 2.0  # 每秒重复次数
    
    def add_verbal_info(self, text: str):
        """添加语言信息"""
        self.verbal_buffer.append(text)
    
    def rehearse(self, duration: float) -> int:
        """语音复述"""
        rehearsal_count = int(duration * self.articulatory_rehearsal_rate)
        return rehearsal_count

class VisuospatialSketchpad:
    """视觉空间画板"""
    
    def __init__(self):
        self.visual_buffer: List[Any] = []
        self.spatial_buffer: List[tuple] = []
    
    def add_visual_info(self, visual_data: Any):
        """添加视觉信息"""
        self.visual_buffer.append(visual_data)
    
    def add_spatial_info(self, spatial_data: tuple):
        """添加空间信息"""
        self.spatial_buffer.append(spatial_data)

# 使用示例
async def demonstrate_working_memory():
    """演示工作记忆模型"""
    memory = WorkingMemory(capacity=5)
    
    # 添加不同类型的信息
    chunks = [
        InformationChunk("chunk1", "算法复杂度", InformationType.VERBAL, 0.9, 1.0, []),
        InformationChunk("chunk2", "流程图", InformationType.VISUAL, 0.8, 1.1, []),
        InformationChunk("chunk3", "坐标位置", InformationType.SPATIAL, 0.7, 1.2, []),
        InformationChunk("chunk4", "数值计算", InformationType.NUMERICAL, 0.6, 1.3, []),
        InformationChunk("chunk5", "代码片段", InformationType.VERBAL, 0.5, 1.4, []),
        InformationChunk("chunk6", "错误信息", InformationType.VERBAL, 0.4, 1.5, []),
    ]
    
    for chunk in chunks:
        success = memory.add_information(chunk)
        print(f"添加 {chunk.id}: {'成功' if success else '失败'}")
        print(f"当前记忆负载: {memory.get_memory_load():.2f}")
    
    # 检索信息
    retrieved = memory.retrieve_information("chunk1")
    if retrieved:
        print(f"检索到: {retrieved.content}")

if __name__ == "__main__":
    asyncio.run(demonstrate_working_memory())
```

### 1.2 注意力模型

**形式化定义**：

```math
注意力系统 A = (F, S, C, D)
```

其中：

- $F$ 是焦点注意，容量为1
- $S$ 是分散注意，容量为 $n$
- $C$ 是注意控制机制
- $D$ 是注意分配策略

**注意分配定理**：

```math
\sum_{i=1}^{n} a_i = 1, \text{ where } a_i \geq 0
```

**Python实现**：

```python
from typing import Dict, List, Tuple
import numpy as np
from dataclasses import dataclass

@dataclass
class AttentionTarget:
    """注意目标"""
    id: str
    salience: float  # 显著性
    relevance: float  # 相关性
    priority: float  # 优先级

class AttentionSystem:
    """注意力系统"""
    
    def __init__(self):
        self.focused_attention: Optional[AttentionTarget] = None
        self.divided_attention: List[AttentionTarget] = []
        self.attention_capacity = 1.0
        self.current_allocation = 0.0
    
    def focus_attention(self, target: AttentionTarget) -> bool:
        """聚焦注意"""
        if self.current_allocation + target.priority <= self.attention_capacity:
            self.focused_attention = target
            self.current_allocation += target.priority
            return True
        return False
    
    def divide_attention(self, targets: List[AttentionTarget]) -> Dict[str, float]:
        """分散注意"""
        total_salience = sum(target.salience for target in targets)
        if total_salience == 0:
            return {}
        
        allocations = {}
        for target in targets:
            allocation = (target.salience / total_salience) * self.attention_capacity
            allocations[target.id] = allocation
        
        return allocations
    
    def get_attention_load(self) -> float:
        """获取注意负载"""
        return self.current_allocation / self.attention_capacity

# 注意力分配算法
def attention_allocation_algorithm(targets: List[AttentionTarget]) -> Dict[str, float]:
    """基于显著性理论的注意分配算法"""
    
    # 计算每个目标的综合得分
    scores = {}
    for target in targets:
        # 综合得分 = 显著性 × 相关性 × 优先级
        score = target.salience * target.relevance * target.priority
        scores[target.id] = score
    
    # 归一化分配
    total_score = sum(scores.values())
    if total_score == 0:
        return {target.id: 0.0 for target in targets}
    
    allocations = {}
    for target in targets:
        allocation = scores[target.id] / total_score
        allocations[target.id] = allocation
    
    return allocations
```

## 2. 思维模式分类

### 2.1 形式化思维

**定义**：基于逻辑推理和数学证明的思维模式

**特征**：

- 严格的逻辑结构
- 形式化证明
- 抽象化处理
- 符号化表示

**Python实现**：

```python
from abc import ABC, abstractmethod
from typing import Any, List, Dict
import sympy as sp

class FormalReasoning(ABC):
    """形式化推理基类"""
    
    @abstractmethod
    def premise(self) -> List[str]:
        """前提条件"""
        pass
    
    @abstractmethod
    def conclusion(self) -> str:
        """结论"""
        pass
    
    @abstractmethod
    def proof(self) -> str:
        """证明过程"""
        pass

class MathematicalProof(FormalReasoning):
    """数学证明"""
    
    def __init__(self, theorem: str):
        self.theorem = theorem
        self.premises = []
        self.steps = []
    
    def add_premise(self, premise: str):
        """添加前提"""
        self.premises.append(premise)
    
    def add_proof_step(self, step: str, justification: str):
        """添加证明步骤"""
        self.steps.append((step, justification))
    
    def premise(self) -> List[str]:
        return self.premises
    
    def conclusion(self) -> str:
        return self.theorem
    
    def proof(self) -> str:
        proof_text = f"定理: {self.theorem}\n\n"
        proof_text += "前提:\n"
        for i, premise in enumerate(self.premises, 1):
            proof_text += f"{i}. {premise}\n"
        
        proof_text += "\n证明:\n"
        for i, (step, justification) in enumerate(self.steps, 1):
            proof_text += f"{i}. {step} ({justification})\n"
        
        return proof_text

# 示例：证明算法复杂度
def prove_algorithm_complexity():
    """证明快速排序的平均时间复杂度"""
    proof = MathematicalProof("快速排序的平均时间复杂度为 O(n log n)")
    
    proof.add_premise("快速排序使用分治策略")
    proof.add_premise("每次分割的时间复杂度为 O(n)")
    proof.add_premise("平均情况下分割深度为 log n")
    proof.add_premise("递归树的高度为 log n")
    
    proof.add_proof_step("T(n) = 2T(n/2) + O(n)", "递归关系")
    proof.add_proof_step("T(n) = O(n log n)", "主定理")
    
    return proof.proof()
```

### 2.2 系统思维

**定义**：将问题视为相互关联的整体系统

**特征**：

- 整体性视角
- 关联性分析
- 反馈循环
- 涌现性理解

**Python实现**：

```python
from typing import Set, Dict, List, Tuple
import networkx as nx
import matplotlib.pyplot as plt

class SystemComponent:
    """系统组件"""
    
    def __init__(self, id: str, name: str, properties: Dict[str, Any]):
        self.id = id
        self.name = name
        self.properties = properties
        self.inputs: Set[str] = set()
        self.outputs: Set[str] = set()

class SystemModel:
    """系统模型"""
    
    def __init__(self, name: str):
        self.name = name
        self.components: Dict[str, SystemComponent] = {}
        self.relationships: List[Tuple[str, str, str]] = []  # (from, to, type)
        self.graph = nx.DiGraph()
    
    def add_component(self, component: SystemComponent):
        """添加组件"""
        self.components[component.id] = component
        self.graph.add_node(component.id, **component.properties)
    
    def add_relationship(self, from_id: str, to_id: str, rel_type: str):
        """添加关系"""
        self.relationships.append((from_id, to_id, rel_type))
        self.graph.add_edge(from_id, to_id, type=rel_type)
    
    def analyze_feedback_loops(self) -> List[List[str]]:
        """分析反馈循环"""
        try:
            cycles = list(nx.simple_cycles(self.graph))
            return cycles
        except nx.NetworkXNoCycle:
            return []
    
    def analyze_system_stability(self) -> Dict[str, Any]:
        """分析系统稳定性"""
        analysis = {
            "feedback_loops": self.analyze_feedback_loops(),
            "connectivity": nx.density(self.graph),
            "centrality": nx.degree_centrality(self.graph),
            "components_count": len(self.components),
            "relationships_count": len(self.relationships)
        }
        return analysis
    
    def visualize_system(self):
        """可视化系统"""
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(self.graph)
        nx.draw(self.graph, pos, with_labels=True, node_color='lightblue', 
                node_size=2000, font_size=10, font_weight='bold')
        plt.title(f"系统模型: {self.name}")
        plt.show()

# 示例：软件系统建模
def model_software_system():
    """建模软件系统"""
    system = SystemModel("微服务架构系统")
    
    # 添加组件
    components = [
        SystemComponent("api_gateway", "API网关", {"type": "gateway"}),
        SystemComponent("user_service", "用户服务", {"type": "service"}),
        SystemComponent("order_service", "订单服务", {"type": "service"}),
        SystemComponent("payment_service", "支付服务", {"type": "service"}),
        SystemComponent("database", "数据库", {"type": "storage"}),
        SystemComponent("cache", "缓存", {"type": "storage"}),
    ]
    
    for component in components:
        system.add_component(component)
    
    # 添加关系
    relationships = [
        ("api_gateway", "user_service", "HTTP"),
        ("api_gateway", "order_service", "HTTP"),
        ("order_service", "payment_service", "RPC"),
        ("user_service", "database", "SQL"),
        ("order_service", "database", "SQL"),
        ("payment_service", "database", "SQL"),
        ("user_service", "cache", "Redis"),
        ("order_service", "cache", "Redis"),
    ]
    
    for from_id, to_id, rel_type in relationships:
        system.add_relationship(from_id, to_id, rel_type)
    
    # 分析系统
    analysis = system.analyze_system_stability()
    print("系统分析结果:")
    for key, value in analysis.items():
        print(f"{key}: {value}")
    
    return system
```

### 2.3 创造性思维

**定义**：产生新颖、有用想法的思维过程

**特征**：

- 发散性思维
- 联想能力
- 模式识别
- 创新突破

**Python实现**：

```python
from typing import List, Set, Dict, Any
import random
import itertools

class CreativeThinking:
    """创造性思维模型"""
    
    def __init__(self):
        self.knowledge_base: Set[str] = set()
        self.associations: Dict[str, Set[str]] = {}
        self.patterns: List[str] = []
    
    def add_knowledge(self, concept: str):
        """添加知识"""
        self.knowledge_base.add(concept)
    
    def add_association(self, concept1: str, concept2: str, strength: float):
        """添加概念关联"""
        if concept1 not in self.associations:
            self.associations[concept1] = {}
        if concept2 not in self.associations:
            self.associations[concept2] = {}
        
        self.associations[concept1][concept2] = strength
        self.associations[concept2][concept1] = strength
    
    def divergent_thinking(self, problem: str, max_ideas: int = 10) -> List[str]:
        """发散性思维"""
        ideas = []
        related_concepts = self._find_related_concepts(problem)
        
        # 基于关联的概念组合
        for i in range(max_ideas):
            if len(related_concepts) >= 2:
                combination = self._combine_concepts(related_concepts)
                ideas.append(f"想法{i+1}: {combination}")
            else:
                ideas.append(f"想法{i+1}: 基于{problem}的创新方案")
        
        return ideas
    
    def _find_related_concepts(self, concept: str) -> List[str]:
        """查找相关概念"""
        related = []
        if concept in self.associations:
            related = list(self.associations[concept].keys())
        return related[:5]  # 限制数量
    
    def _combine_concepts(self, concepts: List[str]) -> str:
        """组合概念"""
        if len(concepts) < 2:
            return concepts[0] if concepts else ""
        
        # 随机选择2-3个概念进行组合
        num_concepts = min(random.randint(2, 3), len(concepts))
        selected = random.sample(concepts, num_concepts)
        return " + ".join(selected)
    
    def pattern_recognition(self, data: List[Any]) -> List[str]:
        """模式识别"""
        patterns = []
        
        # 寻找重复模式
        if len(data) >= 3:
            for i in range(len(data) - 2):
                if data[i] == data[i+1] == data[i+2]:
                    patterns.append(f"重复模式: {data[i]}")
        
        # 寻找递增/递减模式
        if len(data) >= 3:
            if all(data[i] <= data[i+1] for i in range(len(data)-1)):
                patterns.append("递增模式")
            elif all(data[i] >= data[i+1] for i in range(len(data)-1)):
                patterns.append("递减模式")
        
        return patterns

# 示例：算法创新
def creative_algorithm_design():
    """创造性算法设计"""
    creative = CreativeThinking()
    
    # 添加算法相关知识
    algorithms = ["排序", "搜索", "图算法", "动态规划", "贪心", "分治"]
    data_structures = ["数组", "链表", "树", "图", "哈希表", "堆"]
    optimization_techniques = ["缓存", "并行", "近似", "启发式", "随机化"]
    
    for algo in algorithms:
        creative.add_knowledge(algo)
    for ds in data_structures:
        creative.add_knowledge(ds)
    for opt in optimization_techniques:
        creative.add_knowledge(opt)
    
    # 添加关联
    creative.add_association("排序", "数组", 0.9)
    creative.add_association("搜索", "树", 0.8)
    creative.add_association("图算法", "图", 0.9)
    creative.add_association("动态规划", "缓存", 0.7)
    creative.add_association("并行", "分治", 0.6)
    
    # 发散性思维
    problem = "大规模数据处理"
    ideas = creative.divergent_thinking(problem, 5)
    
    print("创造性算法设计想法:")
    for idea in ideas:
        print(f"- {idea}")
    
    return ideas
```

## 3. 认知负荷理论

### 3.1 认知负荷分类

**形式化定义**：

```math
总认知负荷 C_{total} = C_{intrinsic} + C_{extraneous} + C_{germane}
```

其中：

- $C_{intrinsic}$ 是内在认知负荷
- $C_{extraneous}$ 是外在认知负荷
- $C_{germane}$ 是生成认知负荷

**Python实现**：

```python
from dataclasses import dataclass
from typing import List, Dict, Any
import numpy as np

@dataclass
class CognitiveLoad:
    """认知负荷"""
    intrinsic: float  # 内在负荷
    extraneous: float  # 外在负荷
    germane: float  # 生成负荷
    
    @property
    def total(self) -> float:
        """总认知负荷"""
        return self.intrinsic + self.extraneous + self.germane
    
    @property
    def efficiency(self) -> float:
        """认知效率"""
        return self.germane / (self.intrinsic + self.extraneous) if (self.intrinsic + self.extraneous) > 0 else 0

class CognitiveLoadAnalyzer:
    """认知负荷分析器"""
    
    def __init__(self):
        self.complexity_factors = {
            "algorithm_complexity": 0.3,
            "data_structure_complexity": 0.2,
            "conceptual_abstraction": 0.25,
            "interaction_complexity": 0.25
        }
    
    def analyze_intrinsic_load(self, task: Dict[str, float]) -> float:
        """分析内在认知负荷"""
        load = 0.0
        for factor, weight in self.complexity_factors.items():
            if factor in task:
                load += task[factor] * weight
        return min(load, 1.0)  # 归一化到[0,1]
    
    def analyze_extraneous_load(self, interface: Dict[str, float]) -> float:
        """分析外在认知负荷"""
        factors = {
            "visual_clutter": 0.3,
            "navigation_complexity": 0.25,
            "information_density": 0.25,
            "interaction_overhead": 0.2
        }
        
        load = 0.0
        for factor, weight in factors.items():
            if factor in interface:
                load += interface[factor] * weight
        return min(load, 1.0)
    
    def analyze_germane_load(self, learning_context: Dict[str, float]) -> float:
        """分析生成认知负荷"""
        factors = {
            "prior_knowledge": 0.4,
            "learning_strategy": 0.3,
            "motivation": 0.3
        }
        
        load = 0.0
        for factor, weight in factors.items():
            if factor in learning_context:
                load += learning_context[factor] * weight
        return min(load, 1.0)
    
    def optimize_cognitive_load(self, current_load: CognitiveLoad) -> Dict[str, float]:
        """优化认知负荷建议"""
        suggestions = {}
        
        if current_load.intrinsic > 0.7:
            suggestions["reduce_intrinsic"] = "简化任务复杂度，分解复杂概念"
        
        if current_load.extraneous > 0.6:
            suggestions["reduce_extraneous"] = "优化界面设计，减少视觉干扰"
        
        if current_load.germane < 0.3:
            suggestions["increase_germane"] = "增强学习策略，提高动机水平"
        
        return suggestions

# 示例：分析编程任务的认知负荷
def analyze_programming_task():
    """分析编程任务的认知负荷"""
    analyzer = CognitiveLoadAnalyzer()
    
    # 分析内在负荷
    task = {
        "algorithm_complexity": 0.8,  # 复杂算法
        "data_structure_complexity": 0.6,  # 复杂数据结构
        "conceptual_abstraction": 0.7,  # 高抽象概念
        "interaction_complexity": 0.5  # 中等交互复杂度
    }
    intrinsic_load = analyzer.analyze_intrinsic_load(task)
    
    # 分析外在负荷
    interface = {
        "visual_clutter": 0.4,  # 界面杂乱
        "navigation_complexity": 0.3,  # 导航复杂
        "information_density": 0.6,  # 信息密度高
        "interaction_overhead": 0.2  # 交互开销
    }
    extraneous_load = analyzer.analyze_extraneous_load(interface)
    
    # 分析生成负荷
    learning_context = {
        "prior_knowledge": 0.6,  # 先验知识
        "learning_strategy": 0.5,  # 学习策略
        "motivation": 0.7  # 动机水平
    }
    germane_load = analyzer.analyze_germane_load(learning_context)
    
    # 计算总负荷
    total_load = CognitiveLoad(intrinsic_load, extraneous_load, germane_load)
    
    print(f"认知负荷分析结果:")
    print(f"内在负荷: {intrinsic_load:.2f}")
    print(f"外在负荷: {extraneous_load:.2f}")
    print(f"生成负荷: {germane_load:.2f}")
    print(f"总负荷: {total_load.total:.2f}")
    print(f"认知效率: {total_load.efficiency:.2f}")
    
    # 优化建议
    suggestions = analyzer.optimize_cognitive_load(total_load)
    print(f"\n优化建议:")
    for suggestion, description in suggestions.items():
        print(f"- {description}")
    
    return total_load
```

## 4. 学习理论应用

### 4.1 建构主义学习

**核心原理**：学习者主动建构知识，而非被动接受

**Python实现**：

```python
from typing import Dict, List, Set, Any
from dataclasses import dataclass
import random

@dataclass
class KnowledgeNode:
    """知识节点"""
    id: str
    concept: str
    prerequisites: Set[str]
    difficulty: float
    connections: Set[str]

class ConstructivistLearning:
    """建构主义学习模型"""
    
    def __init__(self):
        self.knowledge_graph: Dict[str, KnowledgeNode] = {}
        self.learner_knowledge: Set[str] = set()
        self.learning_path: List[str] = []
    
    def add_knowledge_node(self, node: KnowledgeNode):
        """添加知识节点"""
        self.knowledge_graph[node.id] = node
    
    def can_learn(self, concept_id: str) -> bool:
        """检查是否可以学习某个概念"""
        if concept_id not in self.knowledge_graph:
            return False
        
        node = self.knowledge_graph[concept_id]
        return node.prerequisites.issubset(self.learner_knowledge)
    
    def get_available_concepts(self) -> List[str]:
        """获取可学习的概念"""
        available = []
        for concept_id in self.knowledge_graph:
            if self.can_learn(concept_id):
                available.append(concept_id)
        return available
    
    def learn_concept(self, concept_id: str) -> bool:
        """学习概念"""
        if not self.can_learn(concept_id):
            return False
        
        self.learner_knowledge.add(concept_id)
        self.learning_path.append(concept_id)
        return True
    
    def construct_knowledge(self, new_connection: tuple) -> bool:
        """建构新知识连接"""
        source, target = new_connection
        if source in self.learner_knowledge and target in self.learner_knowledge:
            # 学习者发现了新的知识连接
            return True
        return False
    
    def get_learning_progress(self) -> Dict[str, Any]:
        """获取学习进度"""
        total_concepts = len(self.knowledge_graph)
        learned_concepts = len(self.learner_knowledge)
        
        return {
            "total_concepts": total_concepts,
            "learned_concepts": learned_concepts,
            "progress_percentage": (learned_concepts / total_concepts) * 100,
            "learning_path": self.learning_path,
            "available_next": self.get_available_concepts()
        }

# 示例：编程知识学习路径
def create_programming_learning_path():
    """创建编程学习路径"""
    learning = ConstructivistLearning()
    
    # 定义知识节点
    knowledge_nodes = [
        KnowledgeNode("variables", "变量", set(), 0.1, {"data_types"}),
        KnowledgeNode("data_types", "数据类型", {"variables"}, 0.2, {"control_flow"}),
        KnowledgeNode("control_flow", "控制流", {"data_types"}, 0.3, {"functions"}),
        KnowledgeNode("functions", "函数", {"control_flow"}, 0.4, {"classes"}),
        KnowledgeNode("classes", "类", {"functions"}, 0.5, {"algorithms"}),
        KnowledgeNode("algorithms", "算法", {"classes"}, 0.6, {"data_structures"}),
        KnowledgeNode("data_structures", "数据结构", {"algorithms"}, 0.7, {"design_patterns"}),
        KnowledgeNode("design_patterns", "设计模式", {"data_structures"}, 0.8, set()),
    ]
    
    for node in knowledge_nodes:
        learning.add_knowledge_node(node)
    
    # 模拟学习过程
    print("开始学习编程...")
    
    while learning.get_available_concepts():
        available = learning.get_available_concepts()
        if not available:
            break
        
        # 选择下一个要学习的概念
        next_concept = available[0]
        success = learning.learn_concept(next_concept)
        
        if success:
            node = learning.knowledge_graph[next_concept]
            print(f"学习了: {node.concept} (难度: {node.difficulty:.1f})")
        
        # 检查进度
        progress = learning.get_learning_progress()
        print(f"学习进度: {progress['progress_percentage']:.1f}%")
    
    print("学习完成!")
    return learning
```

## 5. 认知科学在软件工程中的应用

### 5.1 用户界面设计

**认知负荷最小化原则**：

```python
class UIDesignPrinciples:
    """UI设计认知原则"""
    
    @staticmethod
    def minimize_cognitive_load(interface_elements: List[Dict]) -> Dict[str, Any]:
        """最小化认知负荷"""
        analysis = {
            "visual_complexity": 0.0,
            "information_density": 0.0,
            "navigation_depth": 0.0,
            "interaction_steps": 0.0
        }
        
        # 分析视觉复杂度
        analysis["visual_complexity"] = len(interface_elements) / 10.0
        
        # 分析信息密度
        total_info = sum(elem.get("information_content", 0) for elem in interface_elements)
        analysis["information_density"] = total_info / 100.0
        
        # 分析导航深度
        max_depth = max(elem.get("depth", 0) for elem in interface_elements)
        analysis["navigation_depth"] = max_depth / 5.0
        
        # 分析交互步骤
        total_steps = sum(elem.get("interaction_steps", 0) for elem in interface_elements)
        analysis["interaction_steps"] = total_steps / 20.0
        
        return analysis
    
    @staticmethod
    def apply_gestalt_principles(design: Dict) -> Dict:
        """应用格式塔原则"""
        principles = {
            "proximity": "相近元素分组",
            "similarity": "相似元素归类",
            "closure": "完整图形感知",
            "continuity": "连续性引导",
            "figure_ground": "图形背景分离"
        }
        
        return {
            "applied_principles": principles,
            "design_improvements": [
                "减少视觉噪音",
                "增强信息层次",
                "优化空间布局",
                "统一视觉风格"
            ]
        }
```

### 5.2 代码可读性优化

**认知负荷分析**：

```python
class CodeReadabilityAnalyzer:
    """代码可读性分析器"""
    
    def __init__(self):
        self.complexity_thresholds = {
            "cyclomatic_complexity": 10,
            "nesting_depth": 4,
            "function_length": 50,
            "variable_count": 7
        }
    
    def analyze_function(self, code: str) -> Dict[str, Any]:
        """分析函数可读性"""
        analysis = {
            "cyclomatic_complexity": self._calculate_cyclomatic_complexity(code),
            "nesting_depth": self._calculate_nesting_depth(code),
            "function_length": len(code.split('\n')),
            "variable_count": self._count_variables(code),
            "cognitive_load_score": 0.0
        }
        
        # 计算认知负荷得分
        load_score = 0.0
        for metric, value in analysis.items():
            if metric in self.complexity_thresholds:
                threshold = self.complexity_thresholds[metric]
                if value > threshold:
                    load_score += (value - threshold) / threshold
        
        analysis["cognitive_load_score"] = min(load_score, 1.0)
        analysis["readability_level"] = self._get_readability_level(analysis["cognitive_load_score"])
        
        return analysis
    
    def _calculate_cyclomatic_complexity(self, code: str) -> int:
        """计算圈复杂度"""
        complexity = 1  # 基础复杂度
        
        # 统计决策点
        decision_keywords = ['if', 'elif', 'else', 'for', 'while', 'and', 'or']
        for keyword in decision_keywords:
            complexity += code.count(keyword)
        
        return complexity
    
    def _calculate_nesting_depth(self, code: str) -> int:
        """计算嵌套深度"""
        max_depth = 0
        current_depth = 0
        
        for line in code.split('\n'):
            indent = len(line) - len(line.lstrip())
            current_depth = indent // 4  # 假设4空格缩进
            max_depth = max(max_depth, current_depth)
        
        return max_depth
    
    def _count_variables(self, code: str) -> int:
        """统计变量数量"""
        import re
        # 简单的变量统计（实际应用中需要更复杂的解析）
        assignments = re.findall(r'(\w+)\s*=', code)
        return len(set(assignments))
    
    def _get_readability_level(self, load_score: float) -> str:
        """获取可读性等级"""
        if load_score < 0.3:
            return "优秀"
        elif load_score < 0.6:
            return "良好"
        elif load_score < 0.8:
            return "一般"
        else:
            return "需要改进"

# 示例：分析代码可读性
def analyze_code_readability():
    """分析代码可读性示例"""
    analyzer = CodeReadabilityAnalyzer()
    
    # 示例代码
    sample_code = """
def process_data(data_list, threshold=10):
    result = []
    for item in data_list:
        if item > threshold:
            if item % 2 == 0:
                result.append(item * 2)
            else:
                result.append(item + 1)
        else:
            if item < 0:
                result.append(abs(item))
            else:
                result.append(item)
    return result
"""
    
    analysis = analyzer.analyze_function(sample_code)
    
    print("代码可读性分析结果:")
    for metric, value in analysis.items():
        print(f"{metric}: {value}")
    
    return analysis
```

## 6. 总结

认知科学为软件工程提供了重要的理论基础，通过理解人类的认知过程和思维模式，我们可以：

1. **设计更好的用户界面**：减少认知负荷，提高用户体验
2. **编写更易读的代码**：考虑程序员的认知特点
3. **优化学习路径**：基于认知理论设计培训材料
4. **改进问题解决**：应用不同的思维模式

通过形式化建模和Python实现，我们可以将这些认知科学原理应用到实际的软件开发中，提高系统的可用性和开发效率。

---

**下一步**：[02. 软件工程哲学](./02-软件工程哲学.md)
