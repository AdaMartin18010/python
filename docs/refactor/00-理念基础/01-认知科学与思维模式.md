# 00.1 è®¤çŸ¥ç§‘å­¦ä¸æ€ç»´æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

è®¤çŸ¥ç§‘å­¦æ˜¯ç ”ç©¶äººç±»æ€ç»´ã€å­¦ä¹ å’Œæ™ºèƒ½çš„è·¨å­¦ç§‘é¢†åŸŸï¼Œä¸ºè½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚æœ¬ç« èŠ‚ä»è®¤çŸ¥ç§‘å­¦çš„è§’åº¦åˆ†æè½¯ä»¶å¼€å‘ä¸­çš„æ€ç»´æ¨¡å¼ï¼Œå»ºç«‹å½¢å¼åŒ–çš„è®¤çŸ¥æ¨¡å‹ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¤çŸ¥è¿‡ç¨‹çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 è®¤çŸ¥çŠ¶æ€ç©ºé—´

å®šä¹‰è®¤çŸ¥çŠ¶æ€ç©ºé—´ $\mathcal{C}$ ä¸ºï¼š

$$\mathcal{C} = \{c_1, c_2, \ldots, c_n\}$$

å…¶ä¸­æ¯ä¸ªè®¤çŸ¥çŠ¶æ€ $c_i$ åŒ…å«ï¼š
- **æ„ŸçŸ¥ä¿¡æ¯** $P_i$
- **è®°å¿†å†…å®¹** $M_i$  
- **æ¨ç†è¿‡ç¨‹** $R_i$
- **å†³ç­–ç»“æœ** $D_i$

#### 1.2 è®¤çŸ¥è½¬æ¢å‡½æ•°

è®¤çŸ¥è½¬æ¢å‡½æ•° $f_c: \mathcal{C} \times \mathcal{I} \rightarrow \mathcal{C}$ å®šä¹‰ä¸ºï¼š

$$f_c(c_i, i_j) = c_k$$

å…¶ä¸­ï¼š
- $c_i$ æ˜¯å½“å‰è®¤çŸ¥çŠ¶æ€
- $i_j$ æ˜¯è¾“å…¥ä¿¡æ¯
- $c_k$ æ˜¯è½¬æ¢åçš„è®¤çŸ¥çŠ¶æ€

### 2. æ€ç»´æ¨¡å¼åˆ†ç±»

#### 2.1 å½¢å¼åŒ–æ€ç»´æ¨¡å¼

**å®šä¹‰ 2.1.1** å½¢å¼åŒ–æ€ç»´æ¨¡å¼æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{F} = (L, R, P)$ï¼Œå…¶ä¸­ï¼š
- $L$ æ˜¯å½¢å¼åŒ–è¯­è¨€
- $R$ æ˜¯æ¨ç†è§„åˆ™é›†
- $P$ æ˜¯è¯æ˜ç³»ç»Ÿ

**Python å®ç°**ï¼š

```python
from typing import Set, Dict, Any, Callable
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class FormalThinkingMode:
    """å½¢å¼åŒ–æ€ç»´æ¨¡å¼"""
    language: Set[str]  # å½¢å¼åŒ–è¯­è¨€ç¬¦å·é›†
    rules: Dict[str, Callable]  # æ¨ç†è§„åˆ™
    proof_system: Dict[str, Any]  # è¯æ˜ç³»ç»Ÿ
    
    def apply_rule(self, rule_name: str, premises: list) -> Any:
        """åº”ç”¨æ¨ç†è§„åˆ™"""
        if rule_name in self.rules:
            return self.rules[rule_name](premises)
        raise ValueError(f"Unknown rule: {rule_name}")
    
    def verify_proof(self, proof: list) -> bool:
        """éªŒè¯è¯æ˜çš„æ­£ç¡®æ€§"""
        # å®ç°è¯æ˜éªŒè¯é€»è¾‘
        return True

class CognitiveState:
    """è®¤çŸ¥çŠ¶æ€"""
    def __init__(self, perception: dict, memory: dict, reasoning: dict, decision: dict):
        self.perception = perception
        self.memory = memory
        self.reasoning = reasoning
        self.decision = decision
    
    def transition(self, input_info: dict) -> 'CognitiveState':
        """è®¤çŸ¥çŠ¶æ€è½¬æ¢"""
        # å®ç°è®¤çŸ¥çŠ¶æ€è½¬æ¢é€»è¾‘
        new_perception = self._update_perception(input_info)
        new_memory = self._update_memory(input_info)
        new_reasoning = self._apply_reasoning(new_perception, new_memory)
        new_decision = self._make_decision(new_reasoning)
        
        return CognitiveState(new_perception, new_memory, new_reasoning, new_decision)
    
    def _update_perception(self, input_info: dict) -> dict:
        """æ›´æ–°æ„ŸçŸ¥ä¿¡æ¯"""
        return {**self.perception, **input_info}
    
    def _update_memory(self, input_info: dict) -> dict:
        """æ›´æ–°è®°å¿†å†…å®¹"""
        # å®ç°è®°å¿†æ›´æ–°é€»è¾‘
        return self.memory
    
    def _apply_reasoning(self, perception: dict, memory: dict) -> dict:
        """åº”ç”¨æ¨ç†è¿‡ç¨‹"""
        # å®ç°æ¨ç†é€»è¾‘
        return {}
    
    def _make_decision(self, reasoning: dict) -> dict:
        """åšå‡ºå†³ç­–"""
        # å®ç°å†³ç­–é€»è¾‘
        return {}
```

#### 2.2 è®¡ç®—æ€ç»´æ¨¡å¼

**å®šä¹‰ 2.2.1** è®¡ç®—æ€ç»´æ¨¡å¼ $\mathcal{CT}$ åŒ…å«ä»¥ä¸‹æ ¸å¿ƒè¦ç´ ï¼š

1. **åˆ†è§£ (Decomposition)**: $D: P \rightarrow \{p_1, p_2, \ldots, p_n\}$
2. **æ¨¡å¼è¯†åˆ« (Pattern Recognition)**: $PR: \{p_i\} \rightarrow \mathcal{P}$
3. **æŠ½è±¡ (Abstraction)**: $A: \mathcal{P} \rightarrow \mathcal{M}$
4. **ç®—æ³•è®¾è®¡ (Algorithm Design)**: $AD: \mathcal{M} \rightarrow \mathcal{A}$

**Python å®ç°**ï¼š

```python
from typing import List, TypeVar, Generic, Any
from abc import ABC, abstractmethod

T = TypeVar('T')
P = TypeVar('P')  # Pattern
M = TypeVar('M')  # Model
A = TypeVar('A')  # Algorithm

class ComputationalThinking(Generic[T, P, M, A]):
    """è®¡ç®—æ€ç»´æ¨¡å¼"""
    
    def decompose(self, problem: T) -> List[T]:
        """åˆ†è§£é—®é¢˜"""
        # å®ç°é—®é¢˜åˆ†è§£é€»è¾‘
        return [problem]  # ç®€åŒ–å®ç°
    
    def recognize_patterns(self, subproblems: List[T]) -> List[P]:
        """è¯†åˆ«æ¨¡å¼"""
        patterns = []
        for subproblem in subproblems:
            pattern = self._extract_pattern(subproblem)
            patterns.append(pattern)
        return patterns
    
    def abstract(self, patterns: List[P]) -> M:
        """æŠ½è±¡å»ºæ¨¡"""
        # å®ç°æŠ½è±¡é€»è¾‘
        return self._create_model(patterns)
    
    def design_algorithm(self, model: M) -> A:
        """è®¾è®¡ç®—æ³•"""
        # å®ç°ç®—æ³•è®¾è®¡é€»è¾‘
        return self._create_algorithm(model)
    
    def solve(self, problem: T) -> Any:
        """å®Œæ•´çš„é—®é¢˜è§£å†³è¿‡ç¨‹"""
        # 1. åˆ†è§£
        subproblems = self.decompose(problem)
        
        # 2. æ¨¡å¼è¯†åˆ«
        patterns = self.recognize_patterns(subproblems)
        
        # 3. æŠ½è±¡
        model = self.abstract(patterns)
        
        # 4. ç®—æ³•è®¾è®¡
        algorithm = self.design_algorithm(model)
        
        # 5. æ‰§è¡Œç®—æ³•
        return self._execute_algorithm(algorithm, problem)
    
    def _extract_pattern(self, subproblem: T) -> P:
        """æå–æ¨¡å¼"""
        # å®ç°æ¨¡å¼æå–é€»è¾‘
        pass
    
    def _create_model(self, patterns: List[P]) -> M:
        """åˆ›å»ºæ¨¡å‹"""
        # å®ç°æ¨¡å‹åˆ›å»ºé€»è¾‘
        pass
    
    def _create_algorithm(self, model: M) -> A:
        """åˆ›å»ºç®—æ³•"""
        # å®ç°ç®—æ³•åˆ›å»ºé€»è¾‘
        pass
    
    def _execute_algorithm(self, algorithm: A, problem: T) -> Any:
        """æ‰§è¡Œç®—æ³•"""
        # å®ç°ç®—æ³•æ‰§è¡Œé€»è¾‘
        pass

# å…·ä½“å®ç°ç¤ºä¾‹
class SoftwareDesignThinking(ComputationalThinking[dict, str, dict, callable]):
    """è½¯ä»¶è®¾è®¡æ€ç»´"""
    
    def decompose(self, problem: dict) -> List[dict]:
        """å°†è½¯ä»¶éœ€æ±‚åˆ†è§£ä¸ºåŠŸèƒ½æ¨¡å—"""
        modules = []
        requirements = problem.get('requirements', [])
        
        for req in requirements:
            module = {
                'name': req.get('name'),
                'functionality': req.get('description'),
                'dependencies': req.get('dependencies', [])
            }
            modules.append(module)
        
        return modules
    
    def recognize_patterns(self, subproblems: List[dict]) -> List[str]:
        """è¯†åˆ«è®¾è®¡æ¨¡å¼"""
        patterns = []
        for module in subproblems:
            if self._is_singleton_pattern(module):
                patterns.append('Singleton')
            elif self._is_factory_pattern(module):
                patterns.append('Factory')
            elif self._is_observer_pattern(module):
                patterns.append('Observer')
            else:
                patterns.append('Custom')
        return patterns
    
    def _is_singleton_pattern(self, module: dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå•ä¾‹æ¨¡å¼"""
        return 'global' in module.get('functionality', '').lower()
    
    def _is_factory_pattern(self, module: dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå·¥å‚æ¨¡å¼"""
        return 'create' in module.get('functionality', '').lower()
    
    def _is_observer_pattern(self, module: dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºè§‚å¯Ÿè€…æ¨¡å¼"""
        return 'notify' in module.get('functionality', '').lower()
```

### 3. è®¤çŸ¥è´Ÿè·ç†è®º

#### 3.1 è®¤çŸ¥è´Ÿè·å®šä¹‰

**å®šä¹‰ 3.1.1** è®¤çŸ¥è´Ÿè· $CL$ æ˜¯è®¤çŸ¥ç³»ç»Ÿå¤„ç†ä¿¡æ¯æ—¶æ‰€éœ€çš„å¿ƒç†èµ„æºé‡ï¼š

$$CL = \alpha \cdot I + \beta \cdot E + \gamma \cdot G$$

å…¶ä¸­ï¼š
- $I$ æ˜¯å†…åœ¨è®¤çŸ¥è´Ÿè· (Intrinsic Cognitive Load)
- $E$ æ˜¯å¤–åœ¨è®¤çŸ¥è´Ÿè· (Extraneous Cognitive Load)  
- $G$ æ˜¯ç”Ÿæˆè®¤çŸ¥è´Ÿè· (Germane Cognitive Load)
- $\alpha, \beta, \gamma$ æ˜¯æƒé‡ç³»æ•°

#### 3.2 è®¤çŸ¥è´Ÿè·ä¼˜åŒ–

**å®šç† 3.2.1** è®¤çŸ¥è´Ÿè·ä¼˜åŒ–å®šç†

å¯¹äºç»™å®šçš„è®¤çŸ¥ä»»åŠ¡ $T$ï¼Œå­˜åœ¨æœ€ä¼˜çš„è®¤çŸ¥è´Ÿè·åˆ†é…ï¼š

$$\min_{CL} \sum_{i=1}^{n} w_i \cdot CL_i$$

çº¦æŸæ¡ä»¶ï¼š
- $\sum_{i=1}^{n} CL_i \leq CL_{max}$
- $CL_i \geq 0, \forall i$

**Python å®ç°**ï¼š

```python
import numpy as np
from scipy.optimize import minimize
from typing import List, Tuple

class CognitiveLoadOptimizer:
    """è®¤çŸ¥è´Ÿè·ä¼˜åŒ–å™¨"""
    
    def __init__(self, max_load: float):
        self.max_load = max_load
        self.weights = {'intrinsic': 0.4, 'extraneous': 0.3, 'germane': 0.3}
    
    def calculate_cognitive_load(self, task_complexity: float, 
                               interface_complexity: float,
                               learning_effort: float) -> float:
        """è®¡ç®—è®¤çŸ¥è´Ÿè·"""
        intrinsic_load = task_complexity * self.weights['intrinsic']
        extraneous_load = interface_complexity * self.weights['extraneous']
        germane_load = learning_effort * self.weights['germane']
        
        return intrinsic_load + extraneous_load + germane_load
    
    def optimize_task_decomposition(self, tasks: List[dict]) -> List[dict]:
        """ä¼˜åŒ–ä»»åŠ¡åˆ†è§£ä»¥æœ€å°åŒ–è®¤çŸ¥è´Ÿè·"""
        n_tasks = len(tasks)
        
        # å®šä¹‰ç›®æ ‡å‡½æ•°
        def objective(x):
            total_load = 0
            for i, task in enumerate(tasks):
                load = self.calculate_cognitive_load(
                    x[i] * task['complexity'],
                    task['interface_complexity'],
                    task['learning_effort']
                )
                total_load += load
            return total_load
        
        # çº¦æŸæ¡ä»¶
        constraints = [
            {'type': 'ineq', 'fun': lambda x: self.max_load - sum(x)},
        ]
        
        # å˜é‡è¾¹ç•Œ
        bounds = [(0, 1) for _ in range(n_tasks)]
        
        # åˆå§‹çŒœæµ‹
        x0 = [1.0/n_tasks for _ in range(n_tasks)]
        
        # ä¼˜åŒ–
        result = minimize(objective, x0, method='SLSQP', 
                         bounds=bounds, constraints=constraints)
        
        # è¿”å›ä¼˜åŒ–åçš„ä»»åŠ¡åˆ†é…
        optimized_tasks = []
        for i, task in enumerate(tasks):
            optimized_task = task.copy()
            optimized_task['allocated_complexity'] = result.x[i] * task['complexity']
            optimized_tasks.append(optimized_task)
        
        return optimized_tasks

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_cognitive_load_optimization():
    """æ¼”ç¤ºè®¤çŸ¥è´Ÿè·ä¼˜åŒ–"""
    optimizer = CognitiveLoadOptimizer(max_load=100.0)
    
    # å®šä¹‰ä»»åŠ¡
    tasks = [
        {
            'name': 'éœ€æ±‚åˆ†æ',
            'complexity': 30.0,
            'interface_complexity': 10.0,
            'learning_effort': 15.0
        },
        {
            'name': 'ç³»ç»Ÿè®¾è®¡',
            'complexity': 40.0,
            'interface_complexity': 15.0,
            'learning_effort': 20.0
        },
        {
            'name': 'ç¼–ç å®ç°',
            'complexity': 25.0,
            'interface_complexity': 8.0,
            'learning_effort': 10.0
        }
    ]
    
    # ä¼˜åŒ–ä»»åŠ¡åˆ†è§£
    optimized_tasks = optimizer.optimize_task_decomposition(tasks)
    
    print("ä¼˜åŒ–åçš„ä»»åŠ¡åˆ†é…:")
    for task in optimized_tasks:
        print(f"{task['name']}: åˆ†é…å¤æ‚åº¦ = {task['allocated_complexity']:.2f}")
    
    return optimized_tasks
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.2 è½¯ä»¶å·¥ç¨‹å“²å­¦](./02-è½¯ä»¶å·¥ç¨‹å“²å­¦.md)
- [00.3 è®¡ç®—æ€ç»´](./03-è®¡ç®—æ€ç»´.md)
- [01.1 æ•°å­¦åŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-æ•°å­¦åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Newell, A., & Simon, H. A. (1972). Human problem solving. Prentice-Hall.
2. Sweller, J. (1988). Cognitive load during problem solving: Effects on learning. Cognitive Science, 12(2), 257-285.
3. Wing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35.

---

**ä¸‹ä¸€èŠ‚**: [00.2 è½¯ä»¶å·¥ç¨‹å“²å­¦](./02-è½¯ä»¶å·¥ç¨‹å“²å­¦.md) 