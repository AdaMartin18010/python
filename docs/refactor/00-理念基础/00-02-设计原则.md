# 00-02 è®¾è®¡åŸåˆ™ (Design Principles)

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. SOLIDåŸåˆ™](#1-solidåŸåˆ™)
- [2. DRYåŸåˆ™](#2-dryåŸåˆ™)
- [3. KISSåŸåˆ™](#3-kissåŸåˆ™)
- [4. YAGNIåŸåˆ™](#4-yagniåŸåˆ™)
- [5. å½¢å¼åŒ–è¡¨ç¤º](#5-å½¢å¼åŒ–è¡¨ç¤º)
- [6. Pythonå®ç°](#6-pythonå®ç°)
- [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## æ¦‚è¿°

è®¾è®¡åŸåˆ™æ˜¯è½¯ä»¶è®¾è®¡çš„æŒ‡å¯¼æ–¹é’ˆï¼Œä¸ºåˆ›å»ºé«˜è´¨é‡ã€å¯ç»´æŠ¤çš„è½¯ä»¶ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰å„ç§è®¾è®¡åŸåˆ™ï¼Œå¹¶æä¾›Pythonå®ç°ç¤ºä¾‹ã€‚

## 1. SOLIDåŸåˆ™

### 1.1 å•ä¸€èŒè´£åŸåˆ™ (Single Responsibility Principle, SRP)

**å®šä¹‰**: ä¸€ä¸ªç±»åº”è¯¥åªæœ‰ä¸€ä¸ªå¼•èµ·å®ƒå˜åŒ–çš„åŸå› ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\forall c \in \mathcal{C}: |\text{Responsibilities}(c)| = 1$$

å…¶ä¸­ $\mathcal{C}$ æ˜¯ç±»é›†åˆï¼Œ$\text{Responsibilities}(c)$ æ˜¯ç±» $c$ çš„èŒè´£é›†åˆã€‚

### 1.2 å¼€é—­åŸåˆ™ (Open-Closed Principle, OCP)

**å®šä¹‰**: è½¯ä»¶å®ä½“åº”è¯¥å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\forall e \in \mathcal{E}: \text{Extensible}(e) \land \neg\text{Modifiable}(e)$$

å…¶ä¸­ $\mathcal{E}$ æ˜¯è½¯ä»¶å®ä½“é›†åˆã€‚

### 1.3 é‡Œæ°æ›¿æ¢åŸåˆ™ (Liskov Substitution Principle, LSP)

**å®šä¹‰**: å­ç±»å¯¹è±¡åº”è¯¥èƒ½å¤Ÿæ›¿æ¢å…¶åŸºç±»å¯¹è±¡ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\forall s \in \text{Subclass}(b): \text{Behavior}(s) \subseteq \text{Behavior}(b)$$

å…¶ä¸­ $b$ æ˜¯åŸºç±»ï¼Œ$s$ æ˜¯å­ç±»ã€‚

### 1.4 æ¥å£éš”ç¦»åŸåˆ™ (Interface Segregation Principle, ISP)

**å®šä¹‰**: å®¢æˆ·ç«¯ä¸åº”è¯¥è¢«è¿«ä¾èµ–å®ƒä¸ä½¿ç”¨çš„æ¥å£ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\forall i \in \mathcal{I}: \text{Methods}(i) \subseteq \text{RequiredMethods}(i)$$

å…¶ä¸­ $\mathcal{I}$ æ˜¯æ¥å£é›†åˆã€‚

### 1.5 ä¾èµ–å€’ç½®åŸåˆ™ (Dependency Inversion Principle, DIP)

**å®šä¹‰**: é«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–ä½å±‚æ¨¡å—ï¼Œä¸¤è€…éƒ½åº”è¯¥ä¾èµ–æŠ½è±¡ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\text{HighLevel} \rightarrow \text{Abstraction} \leftarrow \text{LowLevel}$$

## 2. DRYåŸåˆ™

### 2.1 å®šä¹‰

**DRY (Don't Repeat Yourself)**: é¿å…ä»£ç é‡å¤ï¼Œæé«˜ä»£ç å¤ç”¨æ€§ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\forall c_1, c_2 \in \mathcal{C}: \text{Similar}(c_1, c_2) \Rightarrow \text{Extract}(c_1, c_2)$$

### 2.2 é‡å¤ç±»å‹

1. **ä»£ç é‡å¤**: ç›¸åŒçš„ä»£ç ç‰‡æ®µ
2. **æ•°æ®é‡å¤**: ç›¸åŒçš„æ•°æ®ç»“æ„
3. **æ–‡æ¡£é‡å¤**: ç›¸åŒçš„æ–‡æ¡£å†…å®¹
4. **è®¾è®¡é‡å¤**: ç›¸åŒçš„è®¾è®¡æ¨¡å¼

## 3. KISSåŸåˆ™

### 3.1 å®šä¹‰

**KISS (Keep It Simple, Stupid)**: ä¿æŒç®€å•ï¼Œé¿å…è¿‡åº¦å¤æ‚åŒ–ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\text{Complexity}(solution) \leq \text{Complexity}(problem)$$

### 3.2 å¤æ‚åº¦åº¦é‡

$$C(S) = \sum_{i=1}^{n} w_i \cdot c_i(S)$$

å…¶ä¸­ $c_i(S)$ æ˜¯ç¬¬ $i$ ä¸ªå¤æ‚åº¦æŒ‡æ ‡ã€‚

## 4. YAGNIåŸåˆ™

### 4.1 å®šä¹‰

**YAGNI (You Aren't Gonna Need It)**: ä¸è¦å®ç°å½“å‰ä¸éœ€è¦çš„åŠŸèƒ½ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\forall f \in \mathcal{F}: \text{Needed}(f) \Rightarrow \text{Implement}(f)$$

å…¶ä¸­ $\mathcal{F}$ æ˜¯åŠŸèƒ½é›†åˆã€‚

## 5. å½¢å¼åŒ–è¡¨ç¤º

### 5.1 åŸåˆ™ç»„åˆ

è®¾è®¡åŸåˆ™çš„ç»„åˆå¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$\text{Principles} = \{\text{SRP}, \text{OCP}, \text{LSP}, \text{ISP}, \text{DIP}, \text{DRY}, \text{KISS}, \text{YAGNI}\}$$

### 5.2 åŸåˆ™å†²çª

å½“åŸåˆ™ä¹‹é—´å‘ç”Ÿå†²çªæ—¶ï¼š

$$\text{Resolve}(conflict) = \arg\max_{p \in \text{Principles}} \text{Priority}(p)$$

## 6. Pythonå®ç°

### 6.1 SOLIDåŸåˆ™å®ç°

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Protocol
from dataclasses import dataclass
from enum import Enum
import logging

# 1. å•ä¸€èŒè´£åŸåˆ™ (SRP)
class UserAuthentication:
    """ç”¨æˆ·è®¤è¯ - å•ä¸€èŒè´£ï¼šåªè´Ÿè´£è®¤è¯"""
    
    def authenticate(self, username: str, password: str) -> bool:
        """éªŒè¯ç”¨æˆ·å‡­æ®"""
        # å®ç°è®¤è¯é€»è¾‘
        return username == "admin" and password == "password"

class UserRepository:
    """ç”¨æˆ·æ•°æ®è®¿é—® - å•ä¸€èŒè´£ï¼šåªè´Ÿè´£æ•°æ®è®¿é—®"""
    
    def save_user(self, user: Dict[str, Any]) -> bool:
        """ä¿å­˜ç”¨æˆ·æ•°æ®"""
        # å®ç°æ•°æ®ä¿å­˜é€»è¾‘
        return True
    
    def get_user(self, user_id: str) -> Dict[str, Any]:
        """è·å–ç”¨æˆ·æ•°æ®"""
        # å®ç°æ•°æ®è·å–é€»è¾‘
        return {"id": user_id, "name": "John Doe"}

# 2. å¼€é—­åŸåˆ™ (OCP)
class PaymentMethod(ABC):
    """æ”¯ä»˜æ–¹æ³•æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def process_payment(self, amount: float) -> bool:
        pass

class CreditCardPayment(PaymentMethod):
    """ä¿¡ç”¨å¡æ”¯ä»˜ - æ‰©å±•æ”¯ä»˜æ–¹æ³•"""
    
    def process_payment(self, amount: float) -> bool:
        print(f"Processing credit card payment: ${amount}")
        return True

class PayPalPayment(PaymentMethod):
    """PayPalæ”¯ä»˜ - æ‰©å±•æ”¯ä»˜æ–¹æ³•"""
    
    def process_payment(self, amount: float) -> bool:
        print(f"Processing PayPal payment: ${amount}")
        return True

class PaymentProcessor:
    """æ”¯ä»˜å¤„ç†å™¨ - å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­"""
    
    def __init__(self):
        self.payment_methods: List[PaymentMethod] = []
    
    def add_payment_method(self, method: PaymentMethod):
        """æ·»åŠ æ–°çš„æ”¯ä»˜æ–¹æ³• - æ‰©å±•"""
        self.payment_methods.append(method)
    
    def process_payment(self, method_index: int, amount: float) -> bool:
        """å¤„ç†æ”¯ä»˜ - ä¸éœ€è¦ä¿®æ”¹ç°æœ‰ä»£ç """
        if 0 <= method_index < len(self.payment_methods):
            return self.payment_methods[method_index].process_payment(amount)
        return False

# 3. é‡Œæ°æ›¿æ¢åŸåˆ™ (LSP)
class Bird:
    """é¸Ÿç±»åŸºç±»"""
    
    def fly(self) -> str:
        return "I can fly"
    
    def eat(self) -> str:
        return "I can eat"

class Sparrow(Bird):
    """éº»é›€ - å¯ä»¥æ›¿æ¢Bird"""
    
    def fly(self) -> str:
        return "Sparrow flying"
    
    def eat(self) -> str:
        return "Sparrow eating seeds"

class Penguin(Bird):
    """ä¼é¹… - è¿åLSPï¼Œä¸èƒ½é£"""
    
    def fly(self) -> str:
        raise NotImplementedError("Penguins cannot fly")
    
    def eat(self) -> str:
        return "Penguin eating fish"

# 4. æ¥å£éš”ç¦»åŸåˆ™ (ISP)
class Printer(Protocol):
    """æ‰“å°æœºæ¥å£"""
    
    def print_document(self, document: str) -> bool:
        ...

class Scanner(Protocol):
    """æ‰«æä»ªæ¥å£"""
    
    def scan_document(self) -> str:
        ...

class Fax(Protocol):
    """ä¼ çœŸæ¥å£"""
    
    def fax_document(self, document: str, recipient: str) -> bool:
        ...

class SimplePrinter:
    """ç®€å•æ‰“å°æœº - åªå®ç°æ‰“å°åŠŸèƒ½"""
    
    def print_document(self, document: str) -> bool:
        print(f"Printing: {document}")
        return True

class AllInOnePrinter:
    """å¤šåŠŸèƒ½æ‰“å°æœº - å®ç°æ‰€æœ‰åŠŸèƒ½"""
    
    def print_document(self, document: str) -> bool:
        print(f"Printing: {document}")
        return True
    
    def scan_document(self) -> str:
        return "Scanned document content"
    
    def fax_document(self, document: str, recipient: str) -> bool:
        print(f"Faxing {document} to {recipient}")
        return True

# 5. ä¾èµ–å€’ç½®åŸåˆ™ (DIP)
class Database(ABC):
    """æ•°æ®åº“æŠ½è±¡æ¥å£"""
    
    @abstractmethod
    def save(self, data: Dict[str, Any]) -> bool:
        pass
    
    @abstractmethod
    def load(self, id: str) -> Dict[str, Any]:
        pass

class MySQLDatabase(Database):
    """MySQLæ•°æ®åº“å®ç°"""
    
    def save(self, data: Dict[str, Any]) -> bool:
        print(f"Saving to MySQL: {data}")
        return True
    
    def load(self, id: str) -> Dict[str, Any]:
        print(f"Loading from MySQL: {id}")
        return {"id": id, "data": "MySQL data"}

class PostgreSQLDatabase(Database):
    """PostgreSQLæ•°æ®åº“å®ç°"""
    
    def save(self, data: Dict[str, Any]) -> bool:
        print(f"Saving to PostgreSQL: {data}")
        return True
    
    def load(self, id: str) -> Dict[str, Any]:
        print(f"Loading from PostgreSQL: {id}")
        return {"id": id, "data": "PostgreSQL data"}

class UserService:
    """ç”¨æˆ·æœåŠ¡ - ä¾èµ–æŠ½è±¡"""
    
    def __init__(self, database: Database):
        self.database = database  # ä¾èµ–æŠ½è±¡ï¼Œä¸ä¾èµ–å…·ä½“å®ç°
    
    def create_user(self, user_data: Dict[str, Any]) -> bool:
        return self.database.save(user_data)
    
    def get_user(self, user_id: str) -> Dict[str, Any]:
        return self.database.load(user_id)

# 6. DRYåŸåˆ™å®ç°
class CodeAnalyzer:
    """ä»£ç åˆ†æå™¨ - æ£€æµ‹é‡å¤ä»£ç """
    
    def __init__(self):
        self.code_patterns: Dict[str, int] = {}
    
    def analyze_code(self, code_lines: List[str]) -> Dict[str, Any]:
        """åˆ†æä»£ç é‡å¤"""
        duplicates = {}
        
        for i, line in enumerate(code_lines):
            line_hash = hash(line.strip())
            if line_hash in self.code_patterns:
                if line_hash not in duplicates:
                    duplicates[line_hash] = {
                        'pattern': line.strip(),
                        'occurrences': [self.code_patterns[line_hash], i]
                    }
                else:
                    duplicates[line_hash]['occurrences'].append(i)
            else:
                self.code_patterns[line_hash] = i
        
        return duplicates
    
    def extract_common_method(self, duplicate_patterns: Dict[str, Any]) -> str:
        """æå–å…¬å…±æ–¹æ³•"""
        extracted_methods = []
        
        for pattern_hash, info in duplicate_patterns.items():
            if len(info['occurrences']) > 1:
                method_name = f"common_method_{len(extracted_methods)}"
                extracted_methods.append({
                    'name': method_name,
                    'pattern': info['pattern'],
                    'occurrences': info['occurrences']
                })
        
        return extracted_methods

# 7. KISSåŸåˆ™å®ç°
class ComplexityAnalyzer:
    """å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.complexity_metrics = {
            'cyclomatic': 0,
            'cognitive': 0,
            'halstead': 0
        }
    
    def calculate_cyclomatic_complexity(self, code: str) -> int:
        """è®¡ç®—åœˆå¤æ‚åº¦"""
        complexity = 1  # åŸºç¡€å¤æ‚åº¦
        
        # è®¡ç®—å†³ç­–ç‚¹
        decision_keywords = ['if', 'elif', 'else', 'for', 'while', 'except', 'and', 'or']
        for keyword in decision_keywords:
            complexity += code.count(keyword)
        
        return complexity
    
    def calculate_cognitive_complexity(self, code: str) -> int:
        """è®¡ç®—è®¤çŸ¥å¤æ‚åº¦"""
        cognitive = 0
        
        # åµŒå¥—å±‚çº§
        indent_level = 0
        for line in code.split('\n'):
            current_indent = len(line) - len(line.lstrip())
            if current_indent > indent_level:
                cognitive += current_indent - indent_level
            indent_level = current_indent
        
        return cognitive
    
    def is_simple_enough(self, code: str, threshold: int = 10) -> bool:
        """åˆ¤æ–­ä»£ç æ˜¯å¦è¶³å¤Ÿç®€å•"""
        cyclomatic = self.calculate_cyclomatic_complexity(code)
        cognitive = self.calculate_cognitive_complexity(code)
        
        return cyclomatic <= threshold and cognitive <= threshold

# 8. YAGNIåŸåˆ™å®ç°
class FeatureManager:
    """åŠŸèƒ½ç®¡ç†å™¨ - å®ç°YAGNIåŸåˆ™"""
    
    def __init__(self):
        self.implemented_features: set = set()
        self.planned_features: set = set()
    
    def add_planned_feature(self, feature: str):
        """æ·»åŠ è®¡åˆ’ä¸­çš„åŠŸèƒ½"""
        self.planned_features.add(feature)
    
    def implement_feature(self, feature: str):
        """å®ç°åŠŸèƒ½"""
        if feature in self.planned_features:
            self.implemented_features.add(feature)
            self.planned_features.remove(feature)
            print(f"Implemented feature: {feature}")
        else:
            print(f"Warning: Implementing unplanned feature: {feature}")
    
    def get_unnecessary_features(self) -> set:
        """è·å–ä¸å¿…è¦çš„åŠŸèƒ½"""
        return self.planned_features - self.implemented_features
    
    def cleanup_unnecessary_features(self):
        """æ¸…ç†ä¸å¿…è¦çš„åŠŸèƒ½"""
        unnecessary = self.get_unnecessary_features()
        for feature in unnecessary:
            self.planned_features.remove(feature)
            print(f"Removed unnecessary feature: {feature}")

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_design_principles():
    """æ¼”ç¤ºè®¾è®¡åŸåˆ™"""
    
    print("=== SOLIDåŸåˆ™æ¼”ç¤º ===\n")
    
    # 1. å•ä¸€èŒè´£åŸåˆ™
    auth = UserAuthentication()
    repo = UserRepository()
    print("1. å•ä¸€èŒè´£åŸåˆ™:")
    print(f"   è®¤è¯ç»“æœ: {auth.authenticate('admin', 'password')}")
    print(f"   ä¿å­˜ç”¨æˆ·: {repo.save_user({'id': '1', 'name': 'John'})}")
    
    # 2. å¼€é—­åŸåˆ™
    processor = PaymentProcessor()
    processor.add_payment_method(CreditCardPayment())
    processor.add_payment_method(PayPalPayment())
    print("\n2. å¼€é—­åŸåˆ™:")
    processor.process_payment(0, 100.0)
    processor.process_payment(1, 50.0)
    
    # 3. é‡Œæ°æ›¿æ¢åŸåˆ™
    print("\n3. é‡Œæ°æ›¿æ¢åŸåˆ™:")
    birds = [Sparrow(), Penguin()]
    for bird in birds:
        try:
            print(f"   {type(bird).__name__}: {bird.eat()}")
            print(f"   {type(bird).__name__}: {bird.fly()}")
        except NotImplementedError as e:
            print(f"   {type(bird).__name__}: {e}")
    
    # 4. æ¥å£éš”ç¦»åŸåˆ™
    print("\n4. æ¥å£éš”ç¦»åŸåˆ™:")
    simple_printer = SimplePrinter()
    all_in_one = AllInOnePrinter()
    print(f"   ç®€å•æ‰“å°æœº: {simple_printer.print_document('test.pdf')}")
    print(f"   å¤šåŠŸèƒ½æ‰“å°æœº: {all_in_one.print_document('test.pdf')}")
    
    # 5. ä¾èµ–å€’ç½®åŸåˆ™
    print("\n5. ä¾èµ–å€’ç½®åŸåˆ™:")
    mysql_db = MySQLDatabase()
    user_service = UserService(mysql_db)
    print(f"   åˆ›å»ºç”¨æˆ·: {user_service.create_user({'id': '1', 'name': 'Alice'})}")
    print(f"   è·å–ç”¨æˆ·: {user_service.get_user('1')}")
    
    print("\n=== DRYåŸåˆ™æ¼”ç¤º ===")
    analyzer = CodeAnalyzer()
    sample_code = [
        "def calculate_area(radius):",
        "    return 3.14159 * radius * radius",
        "def calculate_perimeter(radius):",
        "    return 2 * 3.14159 * radius",
        "def calculate_volume(radius):",
        "    return 4/3 * 3.14159 * radius * radius * radius"
    ]
    duplicates = analyzer.analyze_code(sample_code)
    print(f"é‡å¤æ¨¡å¼: {duplicates}")
    
    print("\n=== KISSåŸåˆ™æ¼”ç¤º ===")
    complexity_analyzer = ComplexityAnalyzer()
    simple_code = "def add(a, b):\n    return a + b"
    complex_code = "def process_data(data):\n    if data:\n        for item in data:\n            if item > 0:\n                if item % 2 == 0:\n                    return item\n    return None"
    
    print(f"ç®€å•ä»£ç å¤æ‚åº¦: {complexity_analyzer.calculate_cyclomatic_complexity(simple_code)}")
    print(f"å¤æ‚ä»£ç å¤æ‚åº¦: {complexity_analyzer.calculate_cyclomatic_complexity(complex_code)}")
    print(f"ç®€å•ä»£ç æ˜¯å¦è¶³å¤Ÿç®€å•: {complexity_analyzer.is_simple_enough(simple_code)}")
    print(f"å¤æ‚ä»£ç æ˜¯å¦è¶³å¤Ÿç®€å•: {complexity_analyzer.is_simple_enough(complex_code)}")
    
    print("\n=== YAGNIåŸåˆ™æ¼”ç¤º ===")
    feature_manager = FeatureManager()
    feature_manager.add_planned_feature("user_authentication")
    feature_manager.add_planned_feature("advanced_reporting")
    feature_manager.add_planned_feature("real_time_chat")
    
    feature_manager.implement_feature("user_authentication")
    feature_manager.implement_feature("unplanned_feature")
    
    print(f"ä¸å¿…è¦çš„åŠŸèƒ½: {feature_manager.get_unnecessary_features()}")
    feature_manager.cleanup_unnecessary_features()

if __name__ == "__main__":
    demonstrate_design_principles()
```

### 6.2 åŸåˆ™éªŒè¯å™¨

```python
from typing import Dict, List, Any, Callable
import ast
import inspect

class DesignPrincipleValidator:
    """è®¾è®¡åŸåˆ™éªŒè¯å™¨"""
    
    def __init__(self):
        self.violations: Dict[str, List[str]] = {}
    
    def validate_srp(self, class_obj: type) -> List[str]:
        """éªŒè¯å•ä¸€èŒè´£åŸåˆ™"""
        violations = []
        
        # åˆ†æç±»çš„æ–¹æ³•
        methods = inspect.getmembers(class_obj, predicate=inspect.isfunction)
        
        # ç®€å•å¯å‘å¼ï¼šæ£€æŸ¥æ–¹æ³•æ•°é‡å’Œæ–¹æ³•åå¤šæ ·æ€§
        if len(methods) > 10:
            violations.append(f"ç±» {class_obj.__name__} æ–¹æ³•è¿‡å¤šï¼Œå¯èƒ½è¿åSRP")
        
        # æ£€æŸ¥æ–¹æ³•åæ˜¯å¦å±äºä¸åŒé¢†åŸŸ
        method_names = [name for name, _ in methods]
        domains = self._categorize_methods_by_domain(method_names)
        
        if len(domains) > 3:
            violations.append(f"ç±» {class_obj.__name__} æ¶‰åŠå¤šä¸ªé¢†åŸŸï¼Œå¯èƒ½è¿åSRP")
        
        return violations
    
    def _categorize_methods_by_domain(self, method_names: List[str]) -> List[str]:
        """æŒ‰é¢†åŸŸåˆ†ç±»æ–¹æ³•"""
        domains = set()
        
        for name in method_names:
            if any(keyword in name.lower() for keyword in ['get', 'set', 'save', 'load']):
                domains.add('data_access')
            elif any(keyword in name.lower() for keyword in ['validate', 'check', 'verify']):
                domains.add('validation')
            elif any(keyword in name.lower() for keyword in ['format', 'parse', 'convert']):
                domains.add('formatting')
            elif any(keyword in name.lower() for keyword in ['send', 'receive', 'connect']):
                domains.add('communication')
            else:
                domains.add('business_logic')
        
        return list(domains)
    
    def validate_ocp(self, class_obj: type) -> List[str]:
        """éªŒè¯å¼€é—­åŸåˆ™"""
        violations = []
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æŠ½è±¡æ–¹æ³•
        abstract_methods = []
        for name, method in inspect.getmembers(class_obj, predicate=inspect.isfunction):
            if hasattr(method, '__isabstractmethod__'):
                abstract_methods.append(name)
        
        if not abstract_methods and not inspect.isabstract(class_obj):
            violations.append(f"ç±» {class_obj.__name__} æ²¡æœ‰æŠ½è±¡æ–¹æ³•ï¼Œå¯èƒ½è¿åOCP")
        
        return violations
    
    def validate_lsp(self, base_class: type, derived_class: type) -> List[str]:
        """éªŒè¯é‡Œæ°æ›¿æ¢åŸåˆ™"""
        violations = []
        
        # æ£€æŸ¥æ´¾ç”Ÿç±»æ˜¯å¦å®ç°äº†æ‰€æœ‰åŸºç±»æ–¹æ³•
        base_methods = set(name for name, _ in inspect.getmembers(base_class, predicate=inspect.isfunction))
        derived_methods = set(name for name, _ in inspect.getmembers(derived_class, predicate=inspect.isfunction))
        
        missing_methods = base_methods - derived_methods
        if missing_methods:
            violations.append(f"æ´¾ç”Ÿç±» {derived_class.__name__} ç¼ºå°‘æ–¹æ³•: {missing_methods}")
        
        return violations
    
    def validate_dry(self, code: str) -> List[str]:
        """éªŒè¯DRYåŸåˆ™"""
        violations = []
        
        # åˆ†æä»£ç é‡å¤
        lines = code.split('\n')
        line_counts = {}
        
        for line in lines:
            stripped_line = line.strip()
            if stripped_line:
                line_counts[stripped_line] = line_counts.get(stripped_line, 0) + 1
        
        # æ£€æŸ¥é‡å¤è¡Œ
        duplicates = {line: count for line, count in line_counts.items() if count > 1}
        
        if duplicates:
            violations.append(f"å‘ç°é‡å¤ä»£ç : {duplicates}")
        
        return violations
    
    def validate_kiss(self, code: str) -> List[str]:
        """éªŒè¯KISSåŸåˆ™"""
        violations = []
        
        # è®¡ç®—å¤æ‚åº¦
        complexity_analyzer = ComplexityAnalyzer()
        cyclomatic = complexity_analyzer.calculate_cyclomatic_complexity(code)
        cognitive = complexity_analyzer.calculate_cognitive_complexity(code)
        
        if cyclomatic > 10:
            violations.append(f"åœˆå¤æ‚åº¦è¿‡é«˜: {cyclomatic}")
        
        if cognitive > 10:
            violations.append(f"è®¤çŸ¥å¤æ‚åº¦è¿‡é«˜: {cognitive}")
        
        return violations
    
    def validate_all_principles(self, code: str, classes: List[type]) -> Dict[str, List[str]]:
        """éªŒè¯æ‰€æœ‰è®¾è®¡åŸåˆ™"""
        self.violations = {}
        
        # éªŒè¯SRP
        for class_obj in classes:
            srp_violations = self.validate_srp(class_obj)
            if srp_violations:
                self.violations['SRP'] = srp_violations
        
        # éªŒè¯OCP
        for class_obj in classes:
            ocp_violations = self.validate_ocp(class_obj)
            if ocp_violations:
                self.violations['OCP'] = ocp_violations
        
        # éªŒè¯DRY
        dry_violations = self.validate_dry(code)
        if dry_violations:
            self.violations['DRY'] = dry_violations
        
        # éªŒè¯KISS
        kiss_violations = self.validate_kiss(code)
        if kiss_violations:
            self.violations['KISS'] = kiss_violations
        
        return self.violations

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_principle_validation():
    """æ¼”ç¤ºåŸåˆ™éªŒè¯"""
    
    validator = DesignPrincipleValidator()
    
    # æµ‹è¯•ä»£ç 
    test_code = """
class BadUserManager:
    def authenticate_user(self, username, password):
        return username == "admin" and password == "password"
    
    def save_user(self, user_data):
        return True
    
    def format_user_data(self, user_data):
        return str(user_data)
    
    def send_email(self, user_email, message):
        return True
    
    def validate_email(self, email):
        return "@" in email

class GoodUserManager:
    def manage_user(self, user_data):
        return True
    """
    
    # æµ‹è¯•ç±»
    class BadUserManager:
        def authenticate_user(self, username, password):
            return username == "admin" and password == "password"
        
        def save_user(self, user_data):
            return True
        
        def format_user_data(self, user_data):
            return str(user_data)
        
        def send_email(self, user_email, message):
            return True
        
        def validate_email(self, email):
            return "@" in email
    
    class GoodUserManager:
        def manage_user(self, user_data):
            return True
    
    # éªŒè¯åŸåˆ™
    violations = validator.validate_all_principles(
        test_code, 
        [BadUserManager, GoodUserManager]
    )
    
    print("è®¾è®¡åŸåˆ™éªŒè¯ç»“æœ:")
    for principle, violation_list in violations.items():
        print(f"\n{principle} åŸåˆ™è¿å:")
        for violation in violation_list:
            print(f"  - {violation}")

if __name__ == "__main__":
    demonstrate_principle_validation()
```

## 7. å‚è€ƒæ–‡çŒ®

1. Martin, R. C. (2000). "Design Principles and Design Patterns".
2. Gamma, E., et al. (1994). "Design Patterns: Elements of Reusable Object-Oriented Software".
3. Hunt, A., & Thomas, D. (1999). "The Pragmatic Programmer".
4. Beck, K. (2000). "Extreme Programming Explained".

---

**ç›¸å…³æ–‡æ¡£**:
- [00-01-ç¼–ç¨‹å“²å­¦](./00-01-ç¼–ç¨‹å“²å­¦.md)
- [00-03-è®¡ç®—æ€ç»´](./00-03-è®¡ç®—æ€ç»´.md)
- [03-01-è®¾è®¡æ¨¡å¼ç†è®º](./../03-å…·ä½“ç§‘å­¦/03-01-è®¾è®¡æ¨¡å¼ç†è®º.md)

**æœ€åæ›´æ–°**: 2024-01-XX  
**ç‰ˆæœ¬**: 1.0.0 