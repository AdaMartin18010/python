# 00.01.03 ç¼–ç¨‹èŒƒå¼

## ğŸ“‹ æ¦‚è¿°

ç¼–ç¨‹èŒƒå¼æ˜¯ç¼–ç¨‹çš„åŸºæœ¬é£æ ¼å’Œæ–¹æ³•è®ºï¼Œå®šä¹‰äº†ç¨‹åºçš„ç»“æ„ã€æ‰§è¡Œæ–¹å¼å’Œæ€ç»´æ–¹å¼ã€‚

## ğŸ¯ æ ¸å¿ƒç¼–ç¨‹èŒƒå¼

### 1. å‘½ä»¤å¼ç¼–ç¨‹ (Imperative Programming)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
```math
å‘½ä»¤å¼ç¨‹åºP = (S, I, T)
å…¶ä¸­ï¼š
- Sæ˜¯çŠ¶æ€é›†åˆ
- Iæ˜¯æŒ‡ä»¤åºåˆ—
- Tæ˜¯çŠ¶æ€è½¬æ¢å‡½æ•°ï¼šS Ã— I â†’ S
```

**Pythonå®ç°**ï¼š

```python
from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class BankAccount:
    """é“¶è¡Œè´¦æˆ·ï¼šå‘½ä»¤å¼ç¼–ç¨‹ç¤ºä¾‹"""
    account_number: str
    balance: float
    owner: str
    
    def deposit(self, amount: float) -> None:
        """å­˜æ¬¾æ“ä½œï¼šç›´æ¥ä¿®æ”¹çŠ¶æ€"""
        if amount > 0:
            self.balance += amount
            print(f"Deposited ${amount}. New balance: ${self.balance}")
    
    def withdraw(self, amount: float) -> bool:
        """å–æ¬¾æ“ä½œï¼šç›´æ¥ä¿®æ”¹çŠ¶æ€"""
        if amount > 0 and self.balance >= amount:
            self.balance -= amount
            print(f"Withdrew ${amount}. New balance: ${self.balance}")
            return True
        else:
            print("Insufficient funds or invalid amount")
            return False
    
    def transfer(self, target_account: 'BankAccount', amount: float) -> bool:
        """è½¬è´¦æ“ä½œï¼šå‘½ä»¤å¼çŠ¶æ€ä¿®æ”¹"""
        if self.withdraw(amount):
            target_account.deposit(amount)
            return True
        return False

class CommandProcessor:
    """å‘½ä»¤å¤„ç†å™¨ï¼šå‘½ä»¤å¼ç¼–ç¨‹çš„æ ¸å¿ƒ"""
    
    def __init__(self):
        self.accounts: Dict[str, BankAccount] = {}
        self.transaction_history: List[Dict[str, Any]] = []
    
    def create_account(self, account_number: str, owner: str, initial_balance: float = 0.0) -> BankAccount:
        """åˆ›å»ºè´¦æˆ·"""
        account = BankAccount(account_number, initial_balance, owner)
        self.accounts[account_number] = account
        self._log_transaction("CREATE", account_number, initial_balance)
        return account
    
    def execute_transaction(self, from_account: str, to_account: str, amount: float) -> bool:
        """æ‰§è¡Œäº¤æ˜“ï¼šå‘½ä»¤å¼æ“ä½œåºåˆ—"""
        if from_account not in self.accounts or to_account not in self.accounts:
            return False
        
        source = self.accounts[from_account]
        target = self.accounts[to_account]
        
        # å‘½ä»¤å¼æ“ä½œåºåˆ—
        if source.transfer(target, amount):
            self._log_transaction("TRANSFER", from_account, amount, to_account)
            return True
        return False
    
    def _log_transaction(self, transaction_type: str, account: str, amount: float, target_account: str = None):
        """è®°å½•äº¤æ˜“"""
        transaction = {
            'type': transaction_type,
            'account': account,
            'amount': amount,
            'target_account': target_account,
            'timestamp': self._get_current_time()
        }
        self.transaction_history.append(transaction)
    
    def _get_current_time(self) -> str:
        """è·å–å½“å‰æ—¶é—´"""
        from datetime import datetime
        return datetime.now().isoformat()

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_imperative():
    """æ¼”ç¤ºå‘½ä»¤å¼ç¼–ç¨‹"""
    processor = CommandProcessor()
    
    # åˆ›å»ºè´¦æˆ·
    account1 = processor.create_account("ACC001", "John Doe", 1000.0)
    account2 = processor.create_account("ACC002", "Jane Smith", 500.0)
    
    # æ‰§è¡Œå‘½ä»¤å¼æ“ä½œ
    processor.execute_transaction("ACC001", "ACC002", 300.0)
    
    print(f"Account 1 balance: ${account1.balance}")
    print(f"Account 2 balance: ${account2.balance}")
    print(f"Transaction history: {len(processor.transaction_history)} transactions")
```

### 2. å‡½æ•°å¼ç¼–ç¨‹ (Functional Programming)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
```math
å‡½æ•°å¼ç¨‹åºP = (F, C, E)
å…¶ä¸­ï¼š
- Fæ˜¯çº¯å‡½æ•°é›†åˆ
- Cæ˜¯ç»„åˆæ“ä½œ
- Eæ˜¯è¡¨è¾¾å¼æ±‚å€¼è§„åˆ™

çº¯å‡½æ•°fæ»¡è¶³ï¼š
âˆ€x, y: x = y â‡’ f(x) = f(y) ä¸” fæ— å‰¯ä½œç”¨
```

**Pythonå®ç°**ï¼š

```python
from typing import List, Callable, TypeVar, Any
from functools import reduce, partial
from dataclasses import dataclass
from enum import Enum

T = TypeVar('T')
U = TypeVar('U')

class TransactionType(Enum):
    DEPOSIT = "deposit"
    WITHDRAWAL = "withdrawal"
    TRANSFER = "transfer"

@dataclass(frozen=True)
class Transaction:
    """ä¸å¯å˜äº¤æ˜“è®°å½•"""
    id: str
    type: TransactionType
    amount: float
    from_account: str
    to_account: str = None
    timestamp: str = None

@dataclass(frozen=True)
class Account:
    """ä¸å¯å˜è´¦æˆ·"""
    account_number: str
    balance: float
    owner: str
    transactions: List[Transaction] = None
    
    def __post_init__(self):
        if self.transactions is None:
            object.__setattr__(self, 'transactions', [])

class FunctionalBanking:
    """å‡½æ•°å¼é“¶è¡Œç³»ç»Ÿ"""
    
    @staticmethod
    def create_account(account_number: str, owner: str, initial_balance: float = 0.0) -> Account:
        """åˆ›å»ºè´¦æˆ·ï¼šçº¯å‡½æ•°"""
        return Account(account_number, initial_balance, owner)
    
    @staticmethod
    def deposit(account: Account, amount: float) -> Account:
        """å­˜æ¬¾ï¼šè¿”å›æ–°è´¦æˆ·ï¼Œä¸ä¿®æ”¹åŸè´¦æˆ·"""
        if amount <= 0:
            return account
        
        new_balance = account.balance + amount
        transaction = Transaction(
            id=f"tx_{len(account.transactions) + 1}",
            type=TransactionType.DEPOSIT,
            amount=amount,
            from_account=account.account_number
        )
        
        new_transactions = account.transactions + [transaction]
        return Account(account.account_number, new_balance, account.owner, new_transactions)
    
    @staticmethod
    def withdraw(account: Account, amount: float) -> Account:
        """å–æ¬¾ï¼šè¿”å›æ–°è´¦æˆ·"""
        if amount <= 0 or account.balance < amount:
            return account
        
        new_balance = account.balance - amount
        transaction = Transaction(
            id=f"tx_{len(account.transactions) + 1}",
            type=TransactionType.WITHDRAWAL,
            amount=amount,
            from_account=account.account_number
        )
        
        new_transactions = account.transactions + [transaction]
        return Account(account.account_number, new_balance, account.owner, new_transactions)
    
    @staticmethod
    def transfer(from_account: Account, to_account: Account, amount: float) -> tuple[Account, Account]:
        """è½¬è´¦ï¼šè¿”å›ä¸¤ä¸ªæ–°è´¦æˆ·"""
        if amount <= 0 or from_account.balance < amount:
            return from_account, to_account
        
        # ä»æºè´¦æˆ·å–æ¬¾
        new_from_account = FunctionalBanking.withdraw(from_account, amount)
        
        # å‘ç›®æ ‡è´¦æˆ·å­˜æ¬¾
        new_to_account = FunctionalBanking.deposit(to_account, amount)
        
        # æ·»åŠ è½¬è´¦è®°å½•
        transfer_transaction = Transaction(
            id=f"tx_{len(from_account.transactions) + 1}",
            type=TransactionType.TRANSFER,
            amount=amount,
            from_account=from_account.account_number,
            to_account=to_account.account_number
        )
        
        final_from = Account(
            new_from_account.account_number,
            new_from_account.balance,
            new_from_account.owner,
            new_from_account.transactions + [transfer_transaction]
        )
        
        return final_from, new_to_account

# é«˜é˜¶å‡½æ•°å’Œå‡½æ•°ç»„åˆ
class FunctionalOperations:
    """å‡½æ•°å¼æ“ä½œå·¥å…·"""
    
    @staticmethod
    def map_transactions(accounts: List[Account], func: Callable[[Transaction], U]) -> List[List[U]]:
        """æ˜ å°„äº¤æ˜“è®°å½•"""
        return [list(map(func, account.transactions)) for account in accounts]
    
    @staticmethod
    def filter_transactions(accounts: List[Account], predicate: Callable[[Transaction], bool]) -> List[List[Transaction]]:
        """è¿‡æ»¤äº¤æ˜“è®°å½•"""
        return [list(filter(predicate, account.transactions)) for account in accounts]
    
    @staticmethod
    def reduce_accounts(accounts: List[Account], func: Callable[[float, Account], float], initial: float = 0.0) -> float:
        """å½’çº¦è´¦æˆ·æ•°æ®"""
        return reduce(func, accounts, initial)
    
    @staticmethod
    def compose(*functions: Callable) -> Callable:
        """å‡½æ•°ç»„åˆ"""
        def composed(x):
            result = x
            for f in reversed(functions):
                result = f(result)
            return result
        return composed

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_functional():
    """æ¼”ç¤ºå‡½æ•°å¼ç¼–ç¨‹"""
    # åˆ›å»ºè´¦æˆ·
    account1 = FunctionalBanking.create_account("ACC001", "John Doe", 1000.0)
    account2 = FunctionalBanking.create_account("ACC002", "Jane Smith", 500.0)
    
    # å‡½æ•°å¼æ“ä½œ
    account1_after_deposit = FunctionalBanking.deposit(account1, 200.0)
    account1_final, account2_final = FunctionalBanking.transfer(account1_after_deposit, account2, 300.0)
    
    print(f"Original account1 balance: ${account1.balance}")
    print(f"Final account1 balance: ${account1_final.balance}")
    print(f"Final account2 balance: ${account2_final.balance}")
    
    # é«˜é˜¶å‡½æ•°æ“ä½œ
    accounts = [account1_final, account2_final]
    
    # è·å–æ‰€æœ‰äº¤æ˜“é‡‘é¢
    amounts = FunctionalOperations.map_transactions(accounts, lambda t: t.amount)
    print(f"Transaction amounts: {amounts}")
    
    # è¿‡æ»¤å­˜æ¬¾äº¤æ˜“
    deposits = FunctionalOperations.filter_transactions(accounts, lambda t: t.type == TransactionType.DEPOSIT)
    print(f"Deposit transactions: {deposits}")
    
    # è®¡ç®—æ€»ä½™é¢
    total_balance = FunctionalOperations.reduce_accounts(accounts, lambda acc, account: acc + account.balance)
    print(f"Total balance: ${total_balance}")
```

### 3. é¢å‘å¯¹è±¡ç¼–ç¨‹ (Object-Oriented Programming)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
```math
é¢å‘å¯¹è±¡ç³»ç»ŸO = (C, I, H, P)
å…¶ä¸­ï¼š
- Cæ˜¯ç±»é›†åˆ
- Iæ˜¯æ¥å£é›†åˆ
- Hæ˜¯ç»§æ‰¿å±‚æ¬¡å…³ç³»
- Pæ˜¯å¤šæ€å…³ç³»

ç±»C = (A, M, S)
å…¶ä¸­ï¼š
- Aæ˜¯å±æ€§é›†åˆ
- Mæ˜¯æ–¹æ³•é›†åˆ
- Sæ˜¯çŠ¶æ€ç©ºé—´
```

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

class AccountType(Enum):
    SAVINGS = "savings"
    CHECKING = "checking"
    BUSINESS = "business"

class Account(ABC):
    """è´¦æˆ·æŠ½è±¡åŸºç±»"""
    
    def __init__(self, account_number: str, owner: str, initial_balance: float = 0.0):
        self._account_number = account_number
        self._owner = owner
        self._balance = initial_balance
        self._transactions: List[Dict[str, Any]] = []
    
    @property
    def account_number(self) -> str:
        return self._account_number
    
    @property
    def owner(self) -> str:
        return self._owner
    
    @property
    def balance(self) -> float:
        return self._balance
    
    @property
    def transactions(self) -> List[Dict[str, Any]]:
        return self._transactions.copy()
    
    @abstractmethod
    def calculate_interest(self) -> float:
        """è®¡ç®—åˆ©æ¯ï¼šæŠ½è±¡æ–¹æ³•"""
        pass
    
    def deposit(self, amount: float) -> bool:
        """å­˜æ¬¾"""
        if amount > 0:
            self._balance += amount
            self._add_transaction("deposit", amount)
            return True
        return False
    
    def withdraw(self, amount: float) -> bool:
        """å–æ¬¾"""
        if amount > 0 and self._can_withdraw(amount):
            self._balance -= amount
            self._add_transaction("withdrawal", amount)
            return True
        return False
    
    def transfer(self, target_account: 'Account', amount: float) -> bool:
        """è½¬è´¦"""
        if self.withdraw(amount):
            if target_account.deposit(amount):
                self._add_transaction("transfer_out", amount, target_account.account_number)
                target_account._add_transaction("transfer_in", amount, self.account_number)
                return True
            else:
                # å›æ»š
                self.deposit(amount)
        return False
    
    def _can_withdraw(self, amount: float) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å–æ¬¾"""
        return self._balance >= amount
    
    def _add_transaction(self, transaction_type: str, amount: float, target_account: str = None):
        """æ·»åŠ äº¤æ˜“è®°å½•"""
        from datetime import datetime
        transaction = {
            'type': transaction_type,
            'amount': amount,
            'timestamp': datetime.now().isoformat(),
            'target_account': target_account
        }
        self._transactions.append(transaction)
    
    def get_statement(self) -> Dict[str, Any]:
        """è·å–è´¦æˆ·å¯¹è´¦å•"""
        return {
            'account_number': self.account_number,
            'owner': self.owner,
            'balance': self.balance,
            'account_type': self.__class__.__name__,
            'transactions': self.transactions,
            'interest': self.calculate_interest()
        }

class SavingsAccount(Account):
    """å‚¨è“„è´¦æˆ·ï¼šç»§æ‰¿Account"""
    
    def __init__(self, account_number: str, owner: str, initial_balance: float = 0.0, interest_rate: float = 0.02):
        super().__init__(account_number, owner, initial_balance)
        self._interest_rate = interest_rate
    
    def calculate_interest(self) -> float:
        """è®¡ç®—åˆ©æ¯"""
        return self._balance * self._interest_rate
    
    def _can_withdraw(self, amount: float) -> bool:
        """å‚¨è“„è´¦æˆ·å–æ¬¾é™åˆ¶"""
        return self._balance >= amount and (self._balance - amount) >= 100  # ä¿æŒæœ€ä½ä½™é¢

class CheckingAccount(Account):
    """æ”¯ç¥¨è´¦æˆ·ï¼šç»§æ‰¿Account"""
    
    def __init__(self, account_number: str, owner: str, initial_balance: float = 0.0, overdraft_limit: float = 0.0):
        super().__init__(account_number, owner, initial_balance)
        self._overdraft_limit = overdraft_limit
    
    def calculate_interest(self) -> float:
        """æ”¯ç¥¨è´¦æˆ·æ— åˆ©æ¯"""
        return 0.0
    
    def _can_withdraw(self, amount: float) -> bool:
        """æ”¯ç¥¨è´¦æˆ·å¯ä»¥é€æ”¯"""
        return (self._balance + self._overdraft_limit) >= amount

class BusinessAccount(Account):
    """å•†ä¸šè´¦æˆ·ï¼šç»§æ‰¿Account"""
    
    def __init__(self, account_number: str, owner: str, initial_balance: float = 0.0, 
                 interest_rate: float = 0.015, monthly_fee: float = 10.0):
        super().__init__(account_number, owner, initial_balance)
        self._interest_rate = interest_rate
        self._monthly_fee = monthly_fee
    
    def calculate_interest(self) -> float:
        """è®¡ç®—åˆ©æ¯"""
        return self._balance * self._interest_rate
    
    def apply_monthly_fee(self):
        """åº”ç”¨æœˆè´¹"""
        if self._balance >= self._monthly_fee:
            self._balance -= self._monthly_fee
            self._add_transaction("monthly_fee", -self._monthly_fee)

class Bank:
    """é“¶è¡Œï¼šç®¡ç†å¤šä¸ªè´¦æˆ·"""
    
    def __init__(self, name: str):
        self._name = name
        self._accounts: Dict[str, Account] = {}
    
    def create_account(self, account_type: AccountType, account_number: str, owner: str, 
                      initial_balance: float = 0.0, **kwargs) -> Account:
        """åˆ›å»ºè´¦æˆ·ï¼šå·¥å‚æ–¹æ³•"""
        if account_type == AccountType.SAVINGS:
            account = SavingsAccount(account_number, owner, initial_balance, **kwargs)
        elif account_type == AccountType.CHECKING:
            account = CheckingAccount(account_number, owner, initial_balance, **kwargs)
        elif account_type == AccountType.BUSINESS:
            account = BusinessAccount(account_number, owner, initial_balance, **kwargs)
        else:
            raise ValueError(f"Unknown account type: {account_type}")
        
        self._accounts[account_number] = account
        return account
    
    def get_account(self, account_number: str) -> Optional[Account]:
        """è·å–è´¦æˆ·"""
        return self._accounts.get(account_number)
    
    def transfer(self, from_account: str, to_account: str, amount: float) -> bool:
        """é“¶è¡Œå†…è½¬è´¦"""
        source = self.get_account(from_account)
        target = self.get_account(to_account)
        
        if source and target:
            return source.transfer(target, amount)
        return False
    
    def get_total_assets(self) -> float:
        """è·å–æ€»èµ„äº§"""
        return sum(account.balance for account in self._accounts.values())
    
    def generate_reports(self) -> Dict[str, Any]:
        """ç”ŸæˆæŠ¥å‘Š"""
        return {
            'bank_name': self._name,
            'total_accounts': len(self._accounts),
            'total_assets': self.get_total_assets(),
            'accounts': [account.get_statement() for account in self._accounts.values()]
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_oop():
    """æ¼”ç¤ºé¢å‘å¯¹è±¡ç¼–ç¨‹"""
    # åˆ›å»ºé“¶è¡Œ
    bank = Bank("MyBank")
    
    # åˆ›å»ºä¸åŒç±»å‹çš„è´¦æˆ·
    savings = bank.create_account(AccountType.SAVINGS, "SAV001", "John Doe", 1000.0, interest_rate=0.025)
    checking = bank.create_account(AccountType.CHECKING, "CHK001", "Jane Smith", 500.0, overdraft_limit=200.0)
    business = bank.create_account(AccountType.BUSINESS, "BUS001", "Acme Corp", 5000.0, 
                                 interest_rate=0.015, monthly_fee=15.0)
    
    # æ‰§è¡Œæ“ä½œ
    savings.deposit(200.0)
    checking.withdraw(100.0)
    bank.transfer("SAV001", "CHK001", 300.0)
    
    # åº”ç”¨æœˆè´¹
    business.apply_monthly_fee()
    
    # ç”ŸæˆæŠ¥å‘Š
    report = bank.generate_reports()
    print(f"Bank: {report['bank_name']}")
    print(f"Total accounts: {report['total_accounts']}")
    print(f"Total assets: ${report['total_assets']:.2f}")
    
    # æ˜¾ç¤ºè´¦æˆ·è¯¦æƒ…
    for account in report['accounts']:
        print(f"\n{account['account_type']}: {account['account_number']}")
        print(f"Owner: {account['owner']}")
        print(f"Balance: ${account['balance']:.2f}")
        print(f"Interest: ${account['interest']:.2f}")
```

### 4. é€»è¾‘ç¼–ç¨‹ (Logic Programming)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
```math
é€»è¾‘ç¨‹åºP = (F, R, Q)
å…¶ä¸­ï¼š
- Fæ˜¯äº‹å®é›†åˆ
- Ræ˜¯è§„åˆ™é›†åˆ
- Qæ˜¯æŸ¥è¯¢é›†åˆ

è§„åˆ™å½¢å¼ï¼šH :- Bâ‚, Bâ‚‚, ..., Bâ‚™
å…¶ä¸­Hæ˜¯å¤´éƒ¨ï¼ŒBáµ¢æ˜¯ä½“éƒ¨æ¡ä»¶
```

**Pythonå®ç°**ï¼š

```python
from typing import List, Dict, Any, Set, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import re

class PredicateType(Enum):
    FACT = "fact"
    RULE = "rule"
    QUERY = "query"

@dataclass
class Predicate:
    """è°“è¯"""
    name: str
    arguments: List[str]
    type: PredicateType = PredicateType.FACT

@dataclass
class Rule:
    """è§„åˆ™ï¼šå¤´éƒ¨ :- ä½“éƒ¨"""
    head: Predicate
    body: List[Predicate]

class LogicEngine:
    """é€»è¾‘æ¨ç†å¼•æ“"""
    
    def __init__(self):
        self.facts: Set[Predicate] = set()
        self.rules: List[Rule] = []
        self.variables: Dict[str, Any] = {}
    
    def add_fact(self, predicate: Predicate):
        """æ·»åŠ äº‹å®"""
        if predicate.type == PredicateType.FACT:
            self.facts.add(predicate)
    
    def add_rule(self, rule: Rule):
        """æ·»åŠ è§„åˆ™"""
        self.rules.append(rule)
    
    def query(self, query: Predicate) -> List[Dict[str, Any]]:
        """æŸ¥è¯¢ï¼šè¿”å›æ‰€æœ‰å¯èƒ½çš„è§£"""
        solutions = []
        self._backtrack(query, {}, solutions)
        return solutions
    
    def _backtrack(self, goal: Predicate, bindings: Dict[str, Any], solutions: List[Dict[str, Any]]):
        """å›æº¯æœç´¢"""
        # æ£€æŸ¥äº‹å®
        for fact in self.facts:
            if self._unify(goal, fact, bindings):
                solutions.append(bindings.copy())
        
        # æ£€æŸ¥è§„åˆ™
        for rule in self.rules:
            if self._unify(goal, rule.head, bindings):
                new_bindings = bindings.copy()
                if self._prove_body(rule.body, new_bindings):
                    solutions.append(new_bindings)
    
    def _unify(self, goal: Predicate, fact: Predicate, bindings: Dict[str, Any]) -> bool:
        """ç»Ÿä¸€ï¼šåŒ¹é…è°“è¯"""
        if goal.name != fact.name or len(goal.arguments) != len(fact.arguments):
            return False
        
        for goal_arg, fact_arg in zip(goal.arguments, fact.arguments):
            if not self._unify_terms(goal_arg, fact_arg, bindings):
                return False
        
        return True
    
    def _unify_terms(self, term1: str, term2: str, bindings: Dict[str, Any]) -> bool:
        """ç»Ÿä¸€é¡¹"""
        # å¦‚æœterm1æ˜¯å˜é‡
        if self._is_variable(term1):
            if term1 in bindings:
                return bindings[term1] == term2
            else:
                bindings[term1] = term2
                return True
        
        # å¦‚æœterm2æ˜¯å˜é‡
        if self._is_variable(term2):
            if term2 in bindings:
                return bindings[term2] == term1
            else:
                bindings[term2] = term1
                return True
        
        # éƒ½æ˜¯å¸¸é‡
        return term1 == term2
    
    def _is_variable(self, term: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå˜é‡"""
        return term.startswith('?') or term.startswith('_')
    
    def _prove_body(self, body: List[Predicate], bindings: Dict[str, Any]) -> bool:
        """è¯æ˜ä½“éƒ¨"""
        if not body:
            return True
        
        goal = body[0]
        remaining_goals = body[1:]
        
        # å°è¯•è¯æ˜å½“å‰ç›®æ ‡
        for fact in self.facts:
            new_bindings = bindings.copy()
            if self._unify(goal, fact, new_bindings):
                if self._prove_body(remaining_goals, new_bindings):
                    bindings.update(new_bindings)
                    return True
        
        # å°è¯•åº”ç”¨è§„åˆ™
        for rule in self.rules:
            new_bindings = bindings.copy()
            if self._unify(goal, rule.head, new_bindings):
                if self._prove_body(rule.body + remaining_goals, new_bindings):
                    bindings.update(new_bindings)
                    return True
        
        return False

class BankingLogicEngine(LogicEngine):
    """é“¶è¡Œé€»è¾‘æ¨ç†å¼•æ“"""
    
    def __init__(self):
        super().__init__()
        self._setup_banking_knowledge_base()
    
    def _setup_banking_knowledge_base(self):
        """è®¾ç½®é“¶è¡ŒçŸ¥è¯†åº“"""
        # æ·»åŠ äº‹å®
        self.add_fact(Predicate("account", ["john", "savings", "1000"]))
        self.add_fact(Predicate("account", ["jane", "checking", "500"]))
        self.add_fact(Predicate("account", ["bob", "savings", "2000"]))
        
        self.add_fact(Predicate("customer", ["john", "premium"]))
        self.add_fact(Predicate("customer", ["jane", "standard"]))
        self.add_fact(Predicate("customer", ["bob", "premium"]))
        
        self.add_fact(Predicate("interest_rate", ["savings", "0.02"]))
        self.add_fact(Predicate("interest_rate", ["checking", "0.01"]))
        
        # æ·»åŠ è§„åˆ™
        # è§„åˆ™1ï¼šå¦‚æœå®¢æˆ·æ˜¯premiumä¸”è´¦æˆ·ä½™é¢å¤§äº1000ï¼Œåˆ™æœ‰èµ„æ ¼è·å¾—é«˜åˆ©ç‡
        rule1 = Rule(
            head=Predicate("high_interest_eligible", ["?customer"]),
            body=[
                Predicate("customer", ["?customer", "premium"]),
                Predicate("account", ["?customer", "?type", "?balance"]),
                Predicate("greater_than", ["?balance", "1000"])
            ]
        )
        self.add_rule(rule1)
        
        # è§„åˆ™2ï¼šå¦‚æœè´¦æˆ·æ˜¯savingsç±»å‹ï¼Œåˆ™è®¡ç®—åˆ©æ¯
        rule2 = Rule(
            head=Predicate("interest", ["?customer", "?amount"]),
            body=[
                Predicate("account", ["?customer", "savings", "?balance"]),
                Predicate("interest_rate", ["savings", "?rate"]),
                Predicate("multiply", ["?balance", "?rate", "?amount"])
            ]
        )
        self.add_rule(rule2)
    
    def query_customer_accounts(self, customer: str) -> List[Dict[str, Any]]:
        """æŸ¥è¯¢å®¢æˆ·è´¦æˆ·"""
        query = Predicate("account", [customer, "?type", "?balance"])
        return self.query(query)
    
    def query_high_interest_eligible(self) -> List[Dict[str, Any]]:
        """æŸ¥è¯¢é«˜åˆ©ç‡èµ„æ ¼å®¢æˆ·"""
        query = Predicate("high_interest_eligible", ["?customer"])
        return self.query(query)
    
    def query_interest_calculation(self, customer: str) -> List[Dict[str, Any]]:
        """æŸ¥è¯¢åˆ©æ¯è®¡ç®—"""
        query = Predicate("interest", [customer, "?amount"])
        return self.query(query)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_logic():
    """æ¼”ç¤ºé€»è¾‘ç¼–ç¨‹"""
    engine = BankingLogicEngine()
    
    # æŸ¥è¯¢å®¢æˆ·è´¦æˆ·
    john_accounts = engine.query_customer_accounts("john")
    print(f"John's accounts: {john_accounts}")
    
    # æŸ¥è¯¢é«˜åˆ©ç‡èµ„æ ¼å®¢æˆ·
    eligible_customers = engine.query_high_interest_eligible()
    print(f"High interest eligible customers: {eligible_customers}")
    
    # æŸ¥è¯¢åˆ©æ¯è®¡ç®—
    john_interest = engine.query_interest_calculation("john")
    print(f"John's interest: {john_interest}")
```

### 5. å¹¶å‘ç¼–ç¨‹ (Concurrent Programming)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
```math
å¹¶å‘ç³»ç»ŸC = (P, S, R)
å…¶ä¸­ï¼š
- Pæ˜¯è¿›ç¨‹é›†åˆ
- Sæ˜¯å…±äº«çŠ¶æ€
- Ræ˜¯åŒæ­¥å…³ç³»

è¿›ç¨‹P = (Q, Î£, Î´, qâ‚€)
å…¶ä¸­ï¼š
- Qæ˜¯çŠ¶æ€é›†åˆ
- Î£æ˜¯äº‹ä»¶é›†åˆ
- Î´æ˜¯è½¬ç§»å‡½æ•°
- qâ‚€æ˜¯åˆå§‹çŠ¶æ€
```

**Pythonå®ç°**ï¼š

```python
import threading
import asyncio
import queue
import time
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

class TransactionStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class Transaction:
    """äº¤æ˜“"""
    id: str
    from_account: str
    to_account: str
    amount: float
    status: TransactionStatus = TransactionStatus.PENDING
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()

class ThreadSafeBank:
    """çº¿ç¨‹å®‰å…¨çš„é“¶è¡Œ"""
    
    def __init__(self):
        self._accounts: Dict[str, float] = {}
        self._lock = threading.RLock()  # å¯é‡å…¥é”
        self._transaction_queue = queue.Queue()
        self._transaction_history: List[Transaction] = []
        self._history_lock = threading.Lock()
    
    def create_account(self, account_number: str, initial_balance: float = 0.0):
        """åˆ›å»ºè´¦æˆ·ï¼šçº¿ç¨‹å®‰å…¨"""
        with self._lock:
            if account_number not in self._accounts:
                self._accounts[account_number] = initial_balance
                return True
            return False
    
    def get_balance(self, account_number: str) -> float:
        """è·å–ä½™é¢ï¼šçº¿ç¨‹å®‰å…¨"""
        with self._lock:
            return self._accounts.get(account_number, 0.0)
    
    def deposit(self, account_number: str, amount: float) -> bool:
        """å­˜æ¬¾ï¼šçº¿ç¨‹å®‰å…¨"""
        with self._lock:
            if account_number in self._accounts and amount > 0:
                self._accounts[account_number] += amount
                return True
            return False
    
    def withdraw(self, account_number: str, amount: float) -> bool:
        """å–æ¬¾ï¼šçº¿ç¨‹å®‰å…¨"""
        with self._lock:
            if (account_number in self._accounts and 
                amount > 0 and 
                self._accounts[account_number] >= amount):
                self._accounts[account_number] -= amount
                return True
            return False
    
    def transfer(self, from_account: str, to_account: str, amount: float) -> bool:
        """è½¬è´¦ï¼šçº¿ç¨‹å®‰å…¨"""
        with self._lock:
            if (from_account in self._accounts and 
                to_account in self._accounts and
                amount > 0 and
                self._accounts[from_account] >= amount):
                
                self._accounts[from_account] -= amount
                self._accounts[to_account] += amount
                return True
            return False
    
    def add_transaction(self, transaction: Transaction):
        """æ·»åŠ äº¤æ˜“è®°å½•ï¼šçº¿ç¨‹å®‰å…¨"""
        with self._history_lock:
            self._transaction_history.append(transaction)
    
    def get_transaction_history(self) -> List[Transaction]:
        """è·å–äº¤æ˜“å†å²ï¼šçº¿ç¨‹å®‰å…¨"""
        with self._history_lock:
            return self._transaction_history.copy()

class AsyncBank:
    """å¼‚æ­¥é“¶è¡Œ"""
    
    def __init__(self):
        self._accounts: Dict[str, float] = {}
        self._lock = asyncio.Lock()
        self._transaction_history: List[Transaction] = []
    
    async def create_account(self, account_number: str, initial_balance: float = 0.0) -> bool:
        """å¼‚æ­¥åˆ›å»ºè´¦æˆ·"""
        async with self._lock:
            if account_number not in self._accounts:
                self._accounts[account_number] = initial_balance
                return True
            return False
    
    async def get_balance(self, account_number: str) -> float:
        """å¼‚æ­¥è·å–ä½™é¢"""
        async with self._lock:
            return self._accounts.get(account_number, 0.0)
    
    async def deposit(self, account_number: str, amount: float) -> bool:
        """å¼‚æ­¥å­˜æ¬¾"""
        async with self._lock:
            if account_number in self._accounts and amount > 0:
                self._accounts[account_number] += amount
                return True
            return False
    
    async def withdraw(self, account_number: str, amount: float) -> bool:
        """å¼‚æ­¥å–æ¬¾"""
        async with self._lock:
            if (account_number in self._accounts and 
                amount > 0 and 
                self._accounts[account_number] >= amount):
                self._accounts[account_number] -= amount
                return True
            return False
    
    async def transfer(self, from_account: str, to_account: str, amount: float) -> bool:
        """å¼‚æ­¥è½¬è´¦"""
        async with self._lock:
            if (from_account in self._accounts and 
                to_account in self._accounts and
                amount > 0 and
                self._accounts[from_account] >= amount):
                
                self._accounts[from_account] -= amount
                self._accounts[to_account] += amount
                return True
            return False

class TransactionProcessor:
    """äº¤æ˜“å¤„ç†å™¨ï¼šå¹¶å‘å¤„ç†"""
    
    def __init__(self, bank: ThreadSafeBank, max_workers: int = 4):
        self.bank = bank
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    def process_transaction(self, transaction: Transaction) -> bool:
        """å¤„ç†å•ä¸ªäº¤æ˜“"""
        transaction.status = TransactionStatus.PROCESSING
        
        try:
            success = self.bank.transfer(
                transaction.from_account,
                transaction.to_account,
                transaction.amount
            )
            
            if success:
                transaction.status = TransactionStatus.COMPLETED
            else:
                transaction.status = TransactionStatus.FAILED
            
            self.bank.add_transaction(transaction)
            return success
            
        except Exception as e:
            transaction.status = TransactionStatus.FAILED
            self.bank.add_transaction(transaction)
            return False
    
    def process_transactions_concurrently(self, transactions: List[Transaction]) -> List[bool]:
        """å¹¶å‘å¤„ç†å¤šä¸ªäº¤æ˜“"""
        futures = [
            self.executor.submit(self.process_transaction, transaction)
            for transaction in transactions
        ]
        
        results = []
        for future in futures:
            try:
                result = future.result(timeout=10)  # 10ç§’è¶…æ—¶
                results.append(result)
            except Exception as e:
                results.append(False)
        
        return results

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_concurrent():
    """æ¼”ç¤ºå¹¶å‘ç¼–ç¨‹"""
    # çº¿ç¨‹å®‰å…¨é“¶è¡Œ
    bank = ThreadSafeBank()
    
    # åˆ›å»ºè´¦æˆ·
    bank.create_account("ACC001", 1000.0)
    bank.create_account("ACC002", 500.0)
    bank.create_account("ACC003", 2000.0)
    
    # åˆ›å»ºäº¤æ˜“å¤„ç†å™¨
    processor = TransactionProcessor(bank, max_workers=3)
    
    # åˆ›å»ºå¤šä¸ªäº¤æ˜“
    transactions = [
        Transaction("TX001", "ACC001", "ACC002", 100.0),
        Transaction("TX002", "ACC002", "ACC003", 50.0),
        Transaction("TX003", "ACC003", "ACC001", 200.0),
        Transaction("TX004", "ACC001", "ACC002", 150.0),
        Transaction("TX005", "ACC002", "ACC003", 75.0),
    ]
    
    # å¹¶å‘å¤„ç†äº¤æ˜“
    results = processor.process_transactions_concurrently(transactions)
    
    print("Transaction results:", results)
    print("Final balances:")
    print(f"ACC001: ${bank.get_balance('ACC001'):.2f}")
    print(f"ACC002: ${bank.get_balance('ACC002'):.2f}")
    print(f"ACC003: ${bank.get_balance('ACC003'):.2f}")
    
    # å¼‚æ­¥é“¶è¡Œç¤ºä¾‹
    async def async_demo():
        async_bank = AsyncBank()
        
        # åˆ›å»ºè´¦æˆ·
        await async_bank.create_account("ASYNC001", 1000.0)
        await async_bank.create_account("ASYNC002", 500.0)
        
        # å¹¶å‘å¼‚æ­¥æ“ä½œ
        tasks = [
            async_bank.deposit("ASYNC001", 100.0),
            async_bank.withdraw("ASYNC002", 50.0),
            async_bank.transfer("ASYNC001", "ASYNC002", 75.0),
        ]
        
        results = await asyncio.gather(*tasks)
        print("Async operation results:", results)
        
        # è·å–æœ€ç»ˆä½™é¢
        balance1 = await async_bank.get_balance("ASYNC001")
        balance2 = await async_bank.get_balance("ASYNC002")
        print(f"Async ACC001: ${balance1:.2f}")
        print(f"Async ACC002: ${balance2:.2f}")
    
    # è¿è¡Œå¼‚æ­¥ç¤ºä¾‹
    asyncio.run(async_demo())
```

## ğŸ“Š ç¼–ç¨‹èŒƒå¼å¯¹æ¯”çŸ©é˜µ

| èŒƒå¼ | æ ¸å¿ƒæ¦‚å¿µ | çŠ¶æ€ç®¡ç† | æ§åˆ¶æµ | æ•°æ®æµ | é€‚ç”¨åœºæ™¯ |
|------|----------|----------|--------|--------|----------|
| å‘½ä»¤å¼ | æŒ‡ä»¤åºåˆ— | å¯å˜çŠ¶æ€ | é¡ºåºæ‰§è¡Œ | æ˜¾å¼ä¼ é€’ | ç³»ç»Ÿç¼–ç¨‹ã€ç®—æ³•å®ç° |
| å‡½æ•°å¼ | çº¯å‡½æ•° | ä¸å¯å˜çŠ¶æ€ | å‡½æ•°è°ƒç”¨ | å‡½æ•°å‚æ•° | æ•°æ®å¤„ç†ã€å¹¶å‘ç¼–ç¨‹ |
| é¢å‘å¯¹è±¡ | å¯¹è±¡äº¤äº’ | å°è£…çŠ¶æ€ | æ¶ˆæ¯ä¼ é€’ | å¯¹è±¡å¼•ç”¨ | å¤§å‹ç³»ç»Ÿã€ä¸šåŠ¡å»ºæ¨¡ |
| é€»è¾‘å¼ | è°“è¯é€»è¾‘ | é€»è¾‘çŠ¶æ€ | æ¨¡å¼åŒ¹é… | é€»è¾‘å˜é‡ | ä¸“å®¶ç³»ç»Ÿã€è§„åˆ™å¼•æ“ |
| å¹¶å‘å¼ | è¿›ç¨‹é€šä¿¡ | å…±äº«çŠ¶æ€ | å¹¶å‘æ‰§è¡Œ | æ¶ˆæ¯ä¼ é€’ | é«˜å¹¶å‘ã€åˆ†å¸ƒå¼ç³»ç»Ÿ |

## ğŸ¯ æ€»ç»“

ç¼–ç¨‹èŒƒå¼æ˜¯è½¯ä»¶å¼€å‘çš„æ ¹æœ¬æ–¹æ³•è®ºï¼Œæ¯ç§èŒƒå¼éƒ½æœ‰å…¶ç‹¬ç‰¹çš„ä¼˜åŠ¿ï¼š

1. **å‘½ä»¤å¼ç¼–ç¨‹**ï¼šç›´è§‚ã€é«˜æ•ˆï¼Œé€‚åˆåº•å±‚ç³»ç»Ÿç¼–ç¨‹
2. **å‡½æ•°å¼ç¼–ç¨‹**ï¼šçº¯å‡½æ•°ã€ä¸å¯å˜æ€§ï¼Œé€‚åˆæ•°æ®å¤„ç†å’Œå¹¶å‘
3. **é¢å‘å¯¹è±¡ç¼–ç¨‹**ï¼šå°è£…ã€ç»§æ‰¿ã€å¤šæ€ï¼Œé€‚åˆå¤§å‹ç³»ç»Ÿå¼€å‘
4. **é€»è¾‘ç¼–ç¨‹**ï¼šå£°æ˜å¼ã€è§„åˆ™é©±åŠ¨ï¼Œé€‚åˆä¸“å®¶ç³»ç»Ÿå’ŒAI
5. **å¹¶å‘ç¼–ç¨‹**ï¼šå¹¶è¡Œæ‰§è¡Œã€èµ„æºå…±äº«ï¼Œé€‚åˆé«˜å¹¶å‘åº”ç”¨

ç°ä»£è½¯ä»¶å¼€å‘é€šå¸¸ç»“åˆå¤šç§èŒƒå¼ï¼Œå‘æŒ¥å„è‡ªçš„ä¼˜åŠ¿ï¼Œæ„å»ºæ›´åŠ å¥å£®å’Œé«˜æ•ˆçš„è½¯ä»¶ç³»ç»Ÿã€‚

---

**ç›¸å…³é“¾æ¥**ï¼š
- [00.01.01 ç¼–ç¨‹æœ¬è´¨](00.01.01-ç¼–ç¨‹æœ¬è´¨.md)
- [00.01.02 è®¾è®¡åŸåˆ™](00.01.02-è®¾è®¡åŸåˆ™.md)
- [01.02.01 å‘½é¢˜é€»è¾‘](../../01-å½¢å¼ç§‘å­¦/01.02-é€»è¾‘å­¦/01.02.01-å‘½é¢˜é€»è¾‘.md)
- [02.01.01 è‡ªåŠ¨æœºç†è®º](../../02-ç†è®ºåŸºç¡€/02.01-è®¡ç®—ç†è®º/02.01.01-è‡ªåŠ¨æœºç†è®º.md) 