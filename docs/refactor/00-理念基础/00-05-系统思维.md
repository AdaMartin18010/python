# 00-05-ç³»ç»Ÿæ€ç»´

> æœ¬æ–‡æ¡£é˜è¿°ç³»ç»Ÿæ€ç»´æ–¹æ³•ï¼ŒåŒ…æ‹¬ç³»ç»Ÿè®ºã€æ•´ä½“æ€§ã€æ¶Œç°æ€§ã€åé¦ˆæœºåˆ¶ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºè½¯ä»¶å·¥ç¨‹æä¾›ç³»ç»Ÿç†è®ºåŸºç¡€ã€‚

## ğŸ“‹ ç›®å½•

- [æ¦‚å¿µä¸å®šä¹‰](#æ¦‚å¿µä¸å®šä¹‰)
- [æ•°å­¦è¡¨è¾¾ä¸å½¢å¼åŒ–](#æ•°å­¦è¡¨è¾¾ä¸å½¢å¼åŒ–)
- [Pythonä»£ç ç¤ºä¾‹](#pythonä»£ç ç¤ºä¾‹)
- [å›¾è¡¨ä¸å¤šè¡¨å¾](#å›¾è¡¨ä¸å¤šè¡¨å¾)
- [è¡Œä¸šåº”ç”¨ä¸æ¡ˆä¾‹](#è¡Œä¸šåº”ç”¨ä¸æ¡ˆä¾‹)
- [æœ¬åœ°è·³è½¬ä¸ç´¢å¼•](#æœ¬åœ°è·³è½¬ä¸ç´¢å¼•)

## ğŸ¯ æ¦‚å¿µä¸å®šä¹‰

### 1.1 ç³»ç»Ÿæ€ç»´æ¦‚è¿°

**ç³»ç»Ÿæ€ç»´**æ˜¯ä¸€ç§å°†é—®é¢˜è§†ä¸ºç›¸äº’å…³è”çš„æ•´ä½“æ¥æ€è€ƒçš„æ–¹æ³•ï¼Œå¼ºè°ƒç³»ç»Ÿçš„æ•´ä½“æ€§ã€æ¶Œç°æ€§å’ŒåŠ¨æ€æ€§ã€‚

**å®šä¹‰1.1**: ç³»ç»Ÿæ€ç»´å¯å½¢å¼åŒ–ä¸ºå››å…ƒç»„ $\mathcal{S} = (W, E, F, D)$ï¼Œå…¶ä¸­ï¼š

- $W$ è¡¨ç¤ºæ•´ä½“æ€§ï¼ˆWholenessï¼‰
- $E$ è¡¨ç¤ºæ¶Œç°æ€§ï¼ˆEmergenceï¼‰
- $F$ è¡¨ç¤ºåé¦ˆæœºåˆ¶ï¼ˆFeedbackï¼‰
- $D$ è¡¨ç¤ºåŠ¨æ€æ€§ï¼ˆDynamicsï¼‰

### 1.2 æ•´ä½“æ€§

**æ•´ä½“æ€§**æ˜¯ç³»ç»Ÿçš„åŸºæœ¬ç‰¹å¾ï¼ŒæŒ‡ç³»ç»Ÿçš„æ•´ä½“åŠŸèƒ½å¤§äºå„éƒ¨åˆ†åŠŸèƒ½ä¹‹å’Œã€‚

**å®šä¹‰1.2**: æ•´ä½“æ€§å¯è¡¨ç¤ºä¸º $\mathcal{W} = (P, R, I, H)$ï¼Œå…¶ä¸­ï¼š

- $P$ è¡¨ç¤ºéƒ¨åˆ†é›†åˆï¼ˆPartsï¼‰
- $R$ è¡¨ç¤ºå…³ç³»é›†åˆï¼ˆRelationsï¼‰
- $I$ è¡¨ç¤ºäº¤äº’é›†åˆï¼ˆInteractionsï¼‰
- $H$ è¡¨ç¤ºæ•´ä½“åŠŸèƒ½ï¼ˆHolistic Functionï¼‰

### 1.3 æ¶Œç°æ€§

**æ¶Œç°æ€§**æ˜¯ç³»ç»Ÿåœ¨æ•´ä½“å±‚æ¬¡ä¸Šå‡ºç°çš„æ–°æ€§è´¨ï¼Œè¿™äº›æ€§è´¨åœ¨ä¸ªä½“å±‚æ¬¡ä¸Šä¸å­˜åœ¨ã€‚

**å®šä¹‰1.3**: æ¶Œç°æ€§å¯è¡¨ç¤ºä¸º $\mathcal{E} = (L, P, N, C)$ï¼Œå…¶ä¸­ï¼š

- $L$ è¡¨ç¤ºå±‚æ¬¡é›†åˆï¼ˆLevelsï¼‰
- $P$ è¡¨ç¤ºæ¶Œç°æ€§è´¨ï¼ˆPropertiesï¼‰
- $N$ è¡¨ç¤ºæ–°æ€§è´¨ï¼ˆNovel Propertiesï¼‰
- $C$ è¡¨ç¤ºçº¦æŸæ¡ä»¶ï¼ˆConstraintsï¼‰

### 1.4 åé¦ˆæœºåˆ¶

**åé¦ˆæœºåˆ¶**æ˜¯ç³»ç»Ÿå†…éƒ¨çš„ä¿¡æ¯å¾ªç¯ï¼Œç”¨äºè°ƒèŠ‚ç³»ç»Ÿè¡Œä¸ºã€‚

**å®šä¹‰1.4**: åé¦ˆæœºåˆ¶å¯è¡¨ç¤ºä¸º $\mathcal{F} = (I, O, C, L)$ï¼Œå…¶ä¸­ï¼š

- $I$ è¡¨ç¤ºè¾“å…¥ï¼ˆInputï¼‰
- $O$ è¡¨ç¤ºè¾“å‡ºï¼ˆOutputï¼‰
- $C$ è¡¨ç¤ºæ§åˆ¶ï¼ˆControlï¼‰
- $L$ è¡¨ç¤ºå¾ªç¯ï¼ˆLoopï¼‰

## ğŸ”¢ æ•°å­¦è¡¨è¾¾ä¸å½¢å¼åŒ–

### 2.1 ç³»ç»Ÿæ€ç»´çš„å½¢å¼åŒ–æ¡†æ¶

**å®šç†2.1**: ç³»ç»Ÿæ€ç»´çš„å®Œå¤‡æ€§å®šç†

å¯¹äºä»»æ„ç³»ç»Ÿ $S$ï¼Œå­˜åœ¨ç³»ç»Ÿæ€ç»´æ¨¡å‹ $\mathcal{S} = (W, E, F, D)$ ä½¿å¾—ï¼š

$$S \models \mathcal{S} \iff (W \models S) \land (E \models S) \land (F \models S) \land (D \models S)$$

**è¯æ˜**:

1. å¿…è¦æ€§ï¼šå¦‚æœ $S \models \mathcal{S}$ï¼Œåˆ™æ•´ä½“æ€§ã€æ¶Œç°æ€§ã€åé¦ˆæœºåˆ¶ã€åŠ¨æ€æ€§éƒ½å¿…é¡»æ”¯æŒç³»ç»Ÿ $S$
2. å……åˆ†æ€§ï¼šå¦‚æœå››ä¸ªç»´åº¦éƒ½æ”¯æŒç³»ç»Ÿ $S$ï¼Œåˆ™ç³»ç»Ÿæ€ç»´ $\mathcal{S}$ å¿…ç„¶æ”¯æŒ $S$

### 2.2 æ•´ä½“æ€§çš„å½¢å¼åŒ–

**å®šä¹‰2.1**: æ•´ä½“æ€§å¯å½¢å¼åŒ–ä¸ºï¼š

$$\text{Wholeness}(S) = \sum_{i=1}^n P_i + \sum_{i,j} R_{ij} + E(S)$$

å…¶ä¸­ï¼š

- $P_i$ è¡¨ç¤ºç¬¬ $i$ ä¸ªéƒ¨åˆ†çš„åŠŸèƒ½
- $R_{ij}$ è¡¨ç¤ºéƒ¨åˆ† $i$ å’Œ $j$ ä¹‹é—´çš„äº¤äº’
- $E(S)$ è¡¨ç¤ºç³»ç»Ÿçš„æ¶Œç°åŠŸèƒ½

### 2.3 æ¶Œç°æ€§çš„å½¢å¼åŒ–

**å®šä¹‰2.3**: æ¶Œç°æ€§å¯è¡¨ç¤ºä¸ºï¼š

$$\text{Emergence}(L_1, L_2) = \{p \in P(L_2) \mid p \notin \bigcup_{l \in L_1} P(l)\}$$

å…¶ä¸­ï¼š

- $L_1$ è¡¨ç¤ºä½å±‚æ¬¡é›†åˆ
- $L_2$ è¡¨ç¤ºé«˜å±‚æ¬¡
- $P(l)$ è¡¨ç¤ºå±‚æ¬¡ $l$ çš„æ€§è´¨é›†åˆ

## ğŸ Pythonä»£ç ç¤ºä¾‹

### 3.1 ç³»ç»Ÿæ€ç»´æ¡†æ¶å®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Callable, Tuple
from dataclasses import dataclass
from enum import Enum
import networkx as nx
import matplotlib.pyplot as plt

class SystemType(Enum):
    """ç³»ç»Ÿç±»å‹"""
    LINEAR = "linear"
    NONLINEAR = "nonlinear"
    COMPLEX = "complex"
    ADAPTIVE = "adaptive"

class FeedbackType(Enum):
    """åé¦ˆç±»å‹"""
    POSITIVE = "positive"
    NEGATIVE = "negative"
    BALANCED = "balanced"

@dataclass
class SystemComponent:
    """ç³»ç»Ÿç»„ä»¶"""
    id: str
    name: str
    function: str
    properties: Dict[str, Any]
    connections: List[str]

@dataclass
class EmergentProperty:
    """æ¶Œç°æ€§è´¨"""
    name: str
    description: str
    level: str
    conditions: List[str]

class Wholeness:
    """æ•´ä½“æ€§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.components: Dict[str, SystemComponent] = {}
        self.relationships: Dict[str, List[Tuple[str, str, str]]] = {}
        self.interactions: Dict[str, Callable] = {}
        self.holistic_functions: List[Callable] = []
    
    def add_component(self, component: SystemComponent) -> None:
        """æ·»åŠ ç»„ä»¶"""
        self.components[component.id] = component
    
    def add_relationship(self, from_component: str, to_component: str, relationship_type: str) -> None:
        """æ·»åŠ å…³ç³»"""
        if from_component not in self.relationships:
            self.relationships[from_component] = []
        self.relationships[from_component].append((from_component, to_component, relationship_type))
    
    def add_interaction(self, component_id: str, interaction_func: Callable) -> None:
        """æ·»åŠ äº¤äº’"""
        self.interactions[component_id] = interaction_func
    
    def add_holistic_function(self, func: Callable) -> None:
        """æ·»åŠ æ•´ä½“åŠŸèƒ½"""
        self.holistic_functions.append(func)
    
    def calculate_wholeness(self) -> float:
        """è®¡ç®—æ•´ä½“æ€§"""
        # è®¡ç®—å„éƒ¨åˆ†åŠŸèƒ½ä¹‹å’Œ
        parts_function = sum(len(comp.properties) for comp in self.components.values())
        
        # è®¡ç®—å…³ç³»æ•°é‡
        relationships_count = sum(len(rels) for rels in self.relationships.values())
        
        # è®¡ç®—æ¶Œç°åŠŸèƒ½
        emergent_function = len(self.holistic_functions)
        
        return parts_function + relationships_count + emergent_function
    
    def get_system_graph(self) -> nx.DiGraph:
        """è·å–ç³»ç»Ÿå›¾"""
        G = nx.DiGraph()
        
        # æ·»åŠ èŠ‚ç‚¹
        for component_id, component in self.components.items():
            G.add_node(component_id, name=component.name)
        
        # æ·»åŠ è¾¹
        for from_comp, relationships in self.relationships.items():
            for from_rel, to_rel, rel_type in relationships:
                G.add_edge(from_rel, to_rel, type=rel_type)
        
        return G

class Emergence:
    """æ¶Œç°æ€§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.levels: Dict[str, Dict[str, Any]] = {}
        self.properties: Dict[str, EmergentProperty] = {}
        self.novel_properties: List[str] = []
        self.constraints: List[Callable] = []
    
    def add_level(self, level_name: str, level_properties: Dict[str, Any]) -> None:
        """æ·»åŠ å±‚æ¬¡"""
        self.levels[level_name] = level_properties
    
    def add_emergent_property(self, property_obj: EmergentProperty) -> None:
        """æ·»åŠ æ¶Œç°æ€§è´¨"""
        self.properties[property_obj.name] = property_obj
        if property_obj.name not in self.novel_properties:
            self.novel_properties.append(property_obj.name)
    
    def add_constraint(self, constraint: Callable) -> None:
        """æ·»åŠ çº¦æŸ"""
        self.constraints.append(constraint)
    
    def check_emergence(self, lower_level: str, higher_level: str) -> List[str]:
        """æ£€æŸ¥æ¶Œç°æ€§"""
        if lower_level not in self.levels or higher_level not in self.levels:
            return []
        
        lower_properties = set(self.levels[lower_level].keys())
        higher_properties = set(self.levels[higher_level].keys())
        
        # æ‰¾å‡ºåœ¨é«˜å±‚æ¬¡å­˜åœ¨ä½†ä½å±‚æ¬¡ä¸å­˜åœ¨çš„æ€§è´¨
        emergent_properties = higher_properties - lower_properties
        
        return list(emergent_properties)
    
    def apply_constraints(self, data: Any) -> bool:
        """åº”ç”¨çº¦æŸ"""
        return all(constraint(data) for constraint in self.constraints)

class Feedback:
    """åé¦ˆæœºåˆ¶ç³»ç»Ÿ"""
    
    def __init__(self):
        self.inputs: Dict[str, Any] = {}
        self.outputs: Dict[str, Any] = {}
        self.controls: Dict[str, Callable] = {}
        self.loops: List[Tuple[str, str, str]] = []
    
    def add_input(self, name: str, value: Any) -> None:
        """æ·»åŠ è¾“å…¥"""
        self.inputs[name] = value
    
    def add_output(self, name: str, value: Any) -> None:
        """æ·»åŠ è¾“å‡º"""
        self.outputs[name] = value
    
    def add_control(self, name: str, control_func: Callable) -> None:
        """æ·»åŠ æ§åˆ¶"""
        self.controls[name] = control_func
    
    def add_feedback_loop(self, input_name: str, output_name: str, feedback_type: FeedbackType) -> None:
        """æ·»åŠ åé¦ˆå¾ªç¯"""
        self.loops.append((input_name, output_name, feedback_type.value))
    
    def process_feedback(self, input_name: str) -> Any:
        """å¤„ç†åé¦ˆ"""
        if input_name in self.inputs and input_name in self.controls:
            input_value = self.inputs[input_name]
            control_func = self.controls[input_name]
            return control_func(input_value)
        return None
    
    def get_feedback_type(self, input_name: str, output_name: str) -> FeedbackType:
        """è·å–åé¦ˆç±»å‹"""
        for loop_input, loop_output, feedback_type in self.loops:
            if loop_input == input_name and loop_output == output_name:
                return FeedbackType(feedback_type)
        return FeedbackType.BALANCED

class Dynamics:
    """åŠ¨æ€æ€§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.states: Dict[str, Any] = {}
        self.transitions: Dict[str, Callable] = {}
        self.time_series: List[Dict[str, Any]] = []
        self.equilibrium_points: List[Dict[str, Any]] = []
    
    def add_state(self, name: str, value: Any) -> None:
        """æ·»åŠ çŠ¶æ€"""
        self.states[name] = value
    
    def add_transition(self, name: str, transition_func: Callable) -> None:
        """æ·»åŠ çŠ¶æ€è½¬æ¢"""
        self.transitions[name] = transition_func
    
    def evolve_system(self, time_steps: int) -> List[Dict[str, Any]]:
        """ç³»ç»Ÿæ¼”åŒ–"""
        evolution = []
        
        for step in range(time_steps):
            current_state = self.states.copy()
            evolution.append(current_state.copy())
            
            # åº”ç”¨çŠ¶æ€è½¬æ¢
            for name, transition_func in self.transitions.items():
                if name in self.states:
                    self.states[name] = transition_func(self.states[name])
        
        self.time_series = evolution
        return evolution
    
    def find_equilibrium(self, tolerance: float = 0.01) -> List[Dict[str, Any]]:
        """å¯»æ‰¾å¹³è¡¡ç‚¹"""
        if len(self.time_series) < 2:
            return []
        
        equilibrium_points = []
        
        for i in range(1, len(self.time_series)):
            current = self.time_series[i]
            previous = self.time_series[i-1]
            
            # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¹³è¡¡
            is_equilibrium = True
            for key in current:
                if abs(current[key] - previous[key]) > tolerance:
                    is_equilibrium = False
                    break
            
            if is_equilibrium:
                equilibrium_points.append(current)
        
        self.equilibrium_points = equilibrium_points
        return equilibrium_points

class SystemThinking:
    """ç³»ç»Ÿæ€ç»´ä¸»ç±»"""
    
    def __init__(self):
        self.wholeness = Wholeness()
        self.emergence = Emergence()
        self.feedback = Feedback()
        self.dynamics = Dynamics()
        self.system_type = SystemType.COMPLEX
    
    def analyze_system(self, system_description: str) -> Dict[str, Any]:
        """åˆ†æç³»ç»Ÿ"""
        # 1. æ•´ä½“æ€§åˆ†æ
        wholeness_score = self.wholeness.calculate_wholeness()
        
        # 2. æ¶Œç°æ€§åˆ†æ
        emergence_properties = self.emergence.novel_properties
        
        # 3. åé¦ˆæœºåˆ¶åˆ†æ
        feedback_loops = len(self.feedback.loops)
        
        # 4. åŠ¨æ€æ€§åˆ†æ
        evolution = self.dynamics.evolve_system(10)
        
        return {
            "wholeness_score": wholeness_score,
            "emergent_properties": emergence_properties,
            "feedback_loops": feedback_loops,
            "system_evolution": evolution,
            "system_type": self.system_type.value
        }
    
    def design_system(self, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """è®¾è®¡ç³»ç»Ÿ"""
        # åŸºäºéœ€æ±‚è®¾è®¡ç³»ç»Ÿç»„ä»¶
        components = []
        
        for req_name, req_desc in requirements.items():
            component = SystemComponent(
                id=f"comp_{len(components)}",
                name=req_name,
                function=req_desc,
                properties={"type": "functional"},
                connections=[]
            )
            components.append(component)
            self.wholeness.add_component(component)
        
        # å»ºç«‹ç»„ä»¶é—´å…³ç³»
        for i in range(len(components)):
            for j in range(i+1, len(components)):
                self.wholeness.add_relationship(
                    components[i].id,
                    components[j].id,
                    "dependency"
                )
        
        return {
            "components": len(components),
            "relationships": len(self.wholeness.relationships),
            "system_graph": self.wholeness.get_system_graph()
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_system_thinking():
    """æ¼”ç¤ºç³»ç»Ÿæ€ç»´çš„åº”ç”¨"""
    
    # åˆ›å»ºç³»ç»Ÿæ€ç»´å®ä¾‹
    st = SystemThinking()
    
    # è®¾è®¡ä¸€ä¸ªç®€å•çš„ç³»ç»Ÿ
    requirements = {
        "ç”¨æˆ·ç•Œé¢": "æä¾›ç”¨æˆ·äº¤äº’åŠŸèƒ½",
        "ä¸šåŠ¡é€»è¾‘": "å¤„ç†æ ¸å¿ƒä¸šåŠ¡è§„åˆ™",
        "æ•°æ®å­˜å‚¨": "ç®¡ç†æ•°æ®æŒä¹…åŒ–",
        "ç½‘ç»œé€šä¿¡": "å¤„ç†ç½‘ç»œè¯·æ±‚"
    }
    
    system_design = st.design_system(requirements)
    print("ç³»ç»Ÿè®¾è®¡ç»“æœ:", system_design)
    
    # åˆ†æç³»ç»Ÿ
    analysis = st.analyze_system("å¤æ‚è½¯ä»¶ç³»ç»Ÿ")
    print("ç³»ç»Ÿåˆ†æç»“æœ:", analysis)
    
    return st

if __name__ == "__main__":
    demonstrate_system_thinking()
```

### 3.2 ç³»ç»Ÿå»ºæ¨¡å®ç°

```python
class SystemModeling:
    """ç³»ç»Ÿå»ºæ¨¡"""
    
    def __init__(self):
        self.models = {}
        self.simulations = {}
    
    def create_linear_system(self, name: str, coefficients: List[float]) -> Dict[str, Any]:
        """åˆ›å»ºçº¿æ€§ç³»ç»Ÿ"""
        def linear_function(x: float) -> float:
            return sum(coef * (x ** i) for i, coef in enumerate(coefficients))
        
        model = {
            "type": "linear",
            "function": linear_function,
            "coefficients": coefficients,
            "order": len(coefficients) - 1
        }
        
        self.models[name] = model
        return model
    
    def create_nonlinear_system(self, name: str, function: Callable) -> Dict[str, Any]:
        """åˆ›å»ºéçº¿æ€§ç³»ç»Ÿ"""
        model = {
            "type": "nonlinear",
            "function": function,
            "description": "éçº¿æ€§ç³»ç»Ÿ"
        }
        
        self.models[name] = model
        return model
    
    def simulate_system(self, model_name: str, initial_conditions: List[float], time_steps: int) -> List[float]:
        """æ¨¡æ‹Ÿç³»ç»Ÿ"""
        if model_name not in self.models:
            raise ValueError(f"Model {model_name} not found")
        
        model = self.models[model_name]
        simulation = []
        
        if model["type"] == "linear":
            x = initial_conditions[0]
            for _ in range(time_steps):
                x = model["function"](x)
                simulation.append(x)
        else:
            # éçº¿æ€§ç³»ç»Ÿæ¨¡æ‹Ÿ
            state = initial_conditions
            for _ in range(time_steps):
                state = model["function"](state)
                simulation.append(state)
        
        self.simulations[model_name] = simulation
        return simulation
    
    def analyze_stability(self, model_name: str) -> Dict[str, Any]:
        """åˆ†æç³»ç»Ÿç¨³å®šæ€§"""
        if model_name not in self.simulations:
            raise ValueError(f"Simulation for {model_name} not found")
        
        simulation = self.simulations[model_name]
        
        # ç®€åŒ–çš„ç¨³å®šæ€§åˆ†æ
        if len(simulation) < 2:
            return {"stability": "unknown"}
        
        # æ£€æŸ¥æ˜¯å¦æ”¶æ•›
        final_values = simulation[-10:] if len(simulation) >= 10 else simulation
        variance = sum((x - final_values[0]) ** 2 for x in final_values) / len(final_values)
        
        if variance < 0.01:
            stability = "stable"
        elif variance < 1.0:
            stability = "marginally_stable"
        else:
            stability = "unstable"
        
        return {
            "stability": stability,
            "variance": variance,
            "final_value": simulation[-1]
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_system_modeling():
    """æ¼”ç¤ºç³»ç»Ÿå»ºæ¨¡"""
    sm = SystemModeling()
    
    # åˆ›å»ºçº¿æ€§ç³»ç»Ÿ
    linear_model = sm.create_linear_system("simple_linear", [0.5, 1.0])
    print("çº¿æ€§ç³»ç»Ÿæ¨¡å‹:", linear_model)
    
    # æ¨¡æ‹Ÿçº¿æ€§ç³»ç»Ÿ
    simulation = sm.simulate_system("simple_linear", [1.0], 20)
    print("çº¿æ€§ç³»ç»Ÿæ¨¡æ‹Ÿç»“æœ:", simulation[:5], "...")
    
    # åˆ†æç¨³å®šæ€§
    stability = sm.analyze_stability("simple_linear")
    print("ç¨³å®šæ€§åˆ†æ:", stability)
    
    # åˆ›å»ºéçº¿æ€§ç³»ç»Ÿ
    def logistic_map(x):
        return 3.9 * x * (1 - x)
    
    nonlinear_model = sm.create_nonlinear_system("logistic", logistic_map)
    print("éçº¿æ€§ç³»ç»Ÿæ¨¡å‹:", nonlinear_model)
    
    # æ¨¡æ‹Ÿéçº¿æ€§ç³»ç»Ÿ
    nonlinear_sim = sm.simulate_system("logistic", [0.5], 20)
    print("éçº¿æ€§ç³»ç»Ÿæ¨¡æ‹Ÿç»“æœ:", nonlinear_sim[:5], "...")
    
    return sm
```

### 3.3 åé¦ˆæ§åˆ¶ç³»ç»Ÿå®ç°

```python
class FeedbackControlSystem:
    """åé¦ˆæ§åˆ¶ç³»ç»Ÿ"""
    
    def __init__(self):
        self.controllers = {}
        self.sensors = {}
        self.actuators = {}
        self.setpoints = {}
    
    def add_controller(self, name: str, controller_type: str, parameters: Dict[str, float]) -> None:
        """æ·»åŠ æ§åˆ¶å™¨"""
        self.controllers[name] = {
            "type": controller_type,
            "parameters": parameters
        }
    
    def add_sensor(self, name: str, sensor_func: Callable) -> None:
        """æ·»åŠ ä¼ æ„Ÿå™¨"""
        self.sensors[name] = sensor_func
    
    def add_actuator(self, name: str, actuator_func: Callable) -> None:
        """æ·»åŠ æ‰§è¡Œå™¨"""
        self.actuators[name] = actuator_func
    
    def set_setpoint(self, name: str, value: float) -> None:
        """è®¾ç½®è®¾å®šç‚¹"""
        self.setpoints[name] = value
    
    def pid_controller(self, error: float, prev_error: float, integral: float, dt: float, kp: float, ki: float, kd: float) -> Tuple[float, float]:
        """PIDæ§åˆ¶å™¨"""
        # æ¯”ä¾‹é¡¹
        proportional = kp * error
        
        # ç§¯åˆ†é¡¹
        integral += ki * error * dt
        
        # å¾®åˆ†é¡¹
        derivative = kd * (error - prev_error) / dt
        
        # æ€»è¾“å‡º
        output = proportional + integral + derivative
        
        return output, integral
    
    def control_loop(self, system_name: str, time_steps: int) -> List[Dict[str, float]]:
        """æ§åˆ¶å¾ªç¯"""
        if system_name not in self.controllers:
            raise ValueError(f"Controller {system_name} not found")
        
        controller = self.controllers[system_name]
        setpoint = self.setpoints.get(system_name, 0.0)
        
        # åˆå§‹åŒ–
        current_value = 0.0
        prev_error = 0.0
        integral = 0.0
        dt = 0.1
        
        # PIDå‚æ•°
        kp = controller["parameters"].get("kp", 1.0)
        ki = controller["parameters"].get("ki", 0.1)
        kd = controller["parameters"].get("kd", 0.01)
        
        control_history = []
        
        for step in range(time_steps):
            # è®¡ç®—è¯¯å·®
            error = setpoint - current_value
            
            # è®¡ç®—æ§åˆ¶è¾“å‡º
            control_output, integral = self.pid_controller(
                error, prev_error, integral, dt, kp, ki, kd
            )
            
            # æ›´æ–°ç³»ç»ŸçŠ¶æ€ï¼ˆç®€åŒ–çš„ç³»ç»Ÿæ¨¡å‹ï¼‰
            current_value += control_output * dt
            
            # è®°å½•å†å²
            control_history.append({
                "time": step * dt,
                "setpoint": setpoint,
                "current_value": current_value,
                "error": error,
                "control_output": control_output
            })
            
            prev_error = error
        
        return control_history

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_feedback_control():
    """æ¼”ç¤ºåé¦ˆæ§åˆ¶"""
    fcs = FeedbackControlSystem()
    
    # æ·»åŠ PIDæ§åˆ¶å™¨
    fcs.add_controller("temperature", "PID", {"kp": 2.0, "ki": 0.5, "kd": 0.1})
    
    # è®¾ç½®è®¾å®šç‚¹
    fcs.set_setpoint("temperature", 25.0)
    
    # è¿è¡Œæ§åˆ¶å¾ªç¯
    control_history = fcs.control_loop("temperature", 100)
    
    print("åé¦ˆæ§åˆ¶ç»“æœ:")
    for i, record in enumerate(control_history[::10]):  # æ¯10æ­¥æ˜¾ç¤ºä¸€æ¬¡
        print(f"  æ—¶é—´: {record['time']:.1f}s, è®¾å®šç‚¹: {record['setpoint']}, å½“å‰å€¼: {record['current_value']:.2f}, è¯¯å·®: {record['error']:.2f}")
    
    return fcs
```

## ğŸ“Š å›¾è¡¨ä¸å¤šè¡¨å¾

### 4.1 ç³»ç»Ÿæ€ç»´æ¡†æ¶å›¾

```mermaid
graph TD
    A[ç³»ç»Ÿæ€ç»´] --> B[æ•´ä½“æ€§]
    A --> C[æ¶Œç°æ€§]
    A --> D[åé¦ˆæœºåˆ¶]
    A --> E[åŠ¨æ€æ€§]
    
    B --> B1[éƒ¨åˆ†é›†åˆ]
    B --> B2[å…³ç³»é›†åˆ]
    B --> B3[äº¤äº’é›†åˆ]
    B --> B4[æ•´ä½“åŠŸèƒ½]
    
    C --> C1[å±‚æ¬¡ç»“æ„]
    C --> C2[æ¶Œç°æ€§è´¨]
    C --> C3[æ–°æ€§è´¨]
    C --> C4[çº¦æŸæ¡ä»¶]
    
    D --> D1[è¾“å…¥]
    D --> D2[è¾“å‡º]
    D --> D3[æ§åˆ¶]
    D --> D4[å¾ªç¯]
    
    E --> E1[çŠ¶æ€]
    E --> E2[è½¬æ¢]
    E --> E3[æ¼”åŒ–]
    E --> E4[å¹³è¡¡]
```

### 4.2 ç³»ç»Ÿåé¦ˆå¾ªç¯å›¾

```mermaid
flowchart LR
    A[è¾“å…¥] --> B[ç³»ç»Ÿ]
    B --> C[è¾“å‡º]
    C --> D[ä¼ æ„Ÿå™¨]
    D --> E[æ§åˆ¶å™¨]
    E --> F[æ‰§è¡Œå™¨]
    F --> A
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#fff3e0
    style D fill:#ffebee
    style E fill:#e8f5e8
    style F fill:#fff8e1
```

### 4.3 ç³»ç»Ÿæ€ç»´åº”ç”¨çŸ©é˜µ

| ç³»ç»Ÿç±»å‹ | æ•´ä½“æ€§ç‰¹å¾ | æ¶Œç°æ€§è´¨ | åé¦ˆç±»å‹ | åŠ¨æ€ç‰¹å¾ |
|---------|-----------|----------|----------|----------|
| çº¿æ€§ç³»ç»Ÿ | å¯åŠ æ€§ | æ—  | è´Ÿåé¦ˆ | ç¨³å®š |
| éçº¿æ€§ç³»ç»Ÿ | ä¸å¯åŠ æ€§ | æ··æ²Œ | æ­£åé¦ˆ | ä¸ç¨³å®š |
| å¤æ‚ç³»ç»Ÿ | è‡ªç»„ç»‡ | æ¶Œç° | å¤šé‡åé¦ˆ | è‡ªé€‚åº” |
| è‡ªé€‚åº”ç³»ç»Ÿ | å­¦ä¹ èƒ½åŠ› | è¿›åŒ– | æ™ºèƒ½åé¦ˆ | æ¼”åŒ– |

## ğŸ­ è¡Œä¸šåº”ç”¨ä¸æ¡ˆä¾‹

### 5.1 è½¯ä»¶æ¶æ„ä¸­çš„ç³»ç»Ÿæ€ç»´åº”ç”¨

**æ¡ˆä¾‹**: å¾®æœåŠ¡æ¶æ„è®¾è®¡

```python
class MicroservicesArchitecture:
    """å¾®æœåŠ¡æ¶æ„ä¸­çš„ç³»ç»Ÿæ€ç»´åº”ç”¨"""
    
    def __init__(self):
        self.system_thinking = SystemThinking()
        self.setup_microservices_system()
    
    def setup_microservices_system(self):
        """è®¾ç½®å¾®æœåŠ¡ç³»ç»Ÿ"""
        
        # æ·»åŠ å¾®æœåŠ¡ç»„ä»¶
        services = [
            SystemComponent("user_service", "ç”¨æˆ·æœåŠ¡", "ç”¨æˆ·ç®¡ç†", {"language": "Python"}, []),
            SystemComponent("order_service", "è®¢å•æœåŠ¡", "è®¢å•å¤„ç†", {"language": "Java"}, []),
            SystemComponent("payment_service", "æ”¯ä»˜æœåŠ¡", "æ”¯ä»˜å¤„ç†", {"language": "Go"}, []),
            SystemComponent("inventory_service", "åº“å­˜æœåŠ¡", "åº“å­˜ç®¡ç†", {"language": "Node.js"}, [])
        ]
        
        for service in services:
            self.system_thinking.wholeness.add_component(service)
        
        # å»ºç«‹æœåŠ¡é—´å…³ç³»
        relationships = [
            ("user_service", "order_service", "APIè°ƒç”¨"),
            ("order_service", "payment_service", "äº‹ä»¶é©±åŠ¨"),
            ("order_service", "inventory_service", "åŒæ­¥è°ƒç”¨"),
            ("payment_service", "user_service", "é€šçŸ¥")
        ]
        
        for from_service, to_service, rel_type in relationships:
            self.system_thinking.wholeness.add_relationship(from_service, to_service, rel_type)
    
    def analyze_architecture(self) -> Dict[str, Any]:
        """åˆ†ææ¶æ„"""
        # ä½¿ç”¨ç³»ç»Ÿæ€ç»´åˆ†æ
        analysis = self.system_thinking.analyze_system("å¾®æœåŠ¡æ¶æ„")
        
        # è®¡ç®—æ¶æ„æŒ‡æ ‡
        components = len(self.system_thinking.wholeness.components)
        relationships = sum(len(rels) for rels in self.system_thinking.wholeness.relationships.values())
        
        return {
            "architecture_type": "microservices",
            "components_count": components,
            "relationships_count": relationships,
            "wholeness_score": analysis["wholeness_score"],
            "system_complexity": "high"
        }

# ä½¿ç”¨ç¤ºä¾‹
microservices = MicroservicesArchitecture()
result = microservices.analyze_architecture()
print("å¾®æœåŠ¡æ¶æ„åˆ†æç»“æœ:", result)
```

### 5.2 ç”Ÿæ€ç³»ç»Ÿä¸­çš„ç³»ç»Ÿæ€ç»´åº”ç”¨

**æ¡ˆä¾‹**: åŸå¸‚äº¤é€šç³»ç»Ÿå»ºæ¨¡

```python
class UrbanTransportSystem:
    """åŸå¸‚äº¤é€šç³»ç»Ÿä¸­çš„ç³»ç»Ÿæ€ç»´åº”ç”¨"""
    
    def __init__(self):
        self.system_thinking = SystemThinking()
        self.setup_transport_system()
    
    def setup_transport_system(self):
        """è®¾ç½®äº¤é€šç³»ç»Ÿ"""
        
        # æ·»åŠ äº¤é€šç»„ä»¶
        components = [
            SystemComponent("roads", "é“è·¯ç½‘ç»œ", "è½¦è¾†é€šè¡Œ", {"capacity": 1000}, []),
            SystemComponent("vehicles", "è½¦è¾†", "è¿è¾“", {"speed": 50}, []),
            SystemComponent("traffic_lights", "äº¤é€šä¿¡å·", "æµé‡æ§åˆ¶", {"cycle": 60}, []),
            SystemComponent("public_transport", "å…¬å…±äº¤é€š", "ä¹˜å®¢è¿è¾“", {"capacity": 100}, [])
        ]
        
        for component in components:
            self.system_thinking.wholeness.add_component(component)
        
        # å»ºç«‹ç»„ä»¶å…³ç³»
        relationships = [
            ("roads", "vehicles", "æ‰¿è½½"),
            ("traffic_lights", "vehicles", "æ§åˆ¶"),
            ("public_transport", "roads", "ä½¿ç”¨"),
            ("vehicles", "traffic_lights", "å“åº”")
        ]
        
        for from_comp, to_comp, rel_type in relationships:
            self.system_thinking.wholeness.add_relationship(from_comp, to_comp, rel_type)
    
    def simulate_traffic_flow(self, time_hours: int) -> List[Dict[str, Any]]:
        """æ¨¡æ‹Ÿäº¤é€šæµé‡"""
        # ç®€åŒ–çš„äº¤é€šæµé‡æ¨¡æ‹Ÿ
        simulation = []
        
        for hour in range(time_hours):
            # æ¨¡æ‹Ÿä¸åŒæ—¶æ®µçš„äº¤é€šæµé‡
            if 7 <= hour <= 9 or 17 <= hour <= 19:  # é«˜å³°æ—¶æ®µ
                traffic_flow = 800
            else:  # éé«˜å³°æ—¶æ®µ
                traffic_flow = 300
            
            simulation.append({
                "hour": hour,
                "traffic_flow": traffic_flow,
                "congestion_level": "high" if traffic_flow > 700 else "low"
            })
        
        return simulation
    
    def optimize_traffic_system(self) -> Dict[str, Any]:
        """ä¼˜åŒ–äº¤é€šç³»ç»Ÿ"""
        # ä½¿ç”¨ç³»ç»Ÿæ€ç»´è¿›è¡Œä¼˜åŒ–
        analysis = self.system_thinking.analyze_system("åŸå¸‚äº¤é€šç³»ç»Ÿ")
        
        # æ¨¡æ‹Ÿäº¤é€šæµé‡
        traffic_simulation = self.simulate_traffic_flow(24)
        
        # è®¡ç®—ä¼˜åŒ–å»ºè®®
        peak_hours = [record for record in traffic_simulation if record["congestion_level"] == "high"]
        
        return {
            "system_analysis": analysis,
            "traffic_simulation": traffic_simulation,
            "optimization_suggestions": [
                "å¢åŠ å…¬å…±äº¤é€šé¢‘ç‡",
                "ä¼˜åŒ–äº¤é€šä¿¡å·é…æ—¶",
                "å»ºè®¾æ™ºèƒ½äº¤é€šç³»ç»Ÿ"
            ],
            "peak_hours_count": len(peak_hours)
        }

# ä½¿ç”¨ç¤ºä¾‹
transport_system = UrbanTransportSystem()
optimization_result = transport_system.optimize_traffic_system()
print("äº¤é€šç³»ç»Ÿä¼˜åŒ–ç»“æœ:", optimization_result)
```

## ğŸ”— æœ¬åœ°è·³è½¬ä¸ç´¢å¼•

### ç›¸å…³æ–‡æ¡£

- [00-01-å“²å­¦åŸºç¡€](./00-01-å“²å­¦åŸºç¡€.md) - è½¯ä»¶å·¥ç¨‹å“²å­¦åŸºç¡€
- [00-02-ç¼–ç¨‹å“²å­¦](./00-02-ç¼–ç¨‹å“²å­¦.md) - ç¼–ç¨‹è¯­è¨€å“²å­¦
- [00-03-å½¢å¼åŒ–æ€ç»´](./00-03-å½¢å¼åŒ–æ€ç»´.md) - å½¢å¼åŒ–æ€ç»´æ–¹æ³•
- [00-04-è®¡ç®—æ€ç»´](./00-04-è®¡ç®—æ€ç»´.md) - è®¡ç®—æ€ç»´åŸºç¡€
- [00-06-æŠ½è±¡ä¸å»ºæ¨¡](./00-06-æŠ½è±¡ä¸å»ºæ¨¡.md) - æŠ½è±¡ä¸å»ºæ¨¡æŠ€æœ¯
- [00-07-è®¾è®¡åŸåˆ™](./00-07-è®¾è®¡åŸåˆ™.md) - è½¯ä»¶è®¾è®¡åŸåˆ™

### ä¸Šå±‚ç›®å½•

- [è¿”å›ç†å¿µåŸºç¡€å±‚](./README.md)
- [è¿”å›é¡¹ç›®æ ¹ç›®å½•](../README.md)

### ä¸‹å±‚åº”ç”¨

- [05-æ¶æ„é¢†åŸŸ](../05-æ¶æ„é¢†åŸŸ/README.md) - ç³»ç»Ÿæ¶æ„è®¾è®¡
- [03-å…·ä½“ç§‘å­¦](../03-å…·ä½“ç§‘å­¦/README.md) - è½¯ä»¶æ¶æ„ç†è®º

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant  
**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ âœ…
