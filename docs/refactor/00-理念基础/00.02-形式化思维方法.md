# 00.02 å½¢å¼åŒ–æ€ç»´æ–¹æ³•

## ğŸ“– æ¦‚è¿°

å½¢å¼åŒ–æ€ç»´æ–¹æ³•æ˜¯ä¸€ç§åŸºäºæ•°å­¦é€»è¾‘å’Œç¬¦å·ç³»ç»Ÿçš„æ€ç»´æ–¹å¼ï¼Œé€šè¿‡ä¸¥æ ¼çš„ç¬¦å·è¡¨ç¤ºã€é€»è¾‘æ¨ç†å’Œå½¢å¼åŒ–è¯æ˜æ¥è§£å†³é—®é¢˜ã€‚å®ƒæ˜¯è®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹çš„ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å½¢å¼åŒ–è¯­è¨€

**å®šä¹‰**ï¼šå½¢å¼åŒ–è¯­è¨€æ˜¯ä¸€ä¸ªç¬¦å·ç³»ç»Ÿï¼Œå…·æœ‰æ˜ç¡®çš„è¯­æ³•å’Œè¯­ä¹‰è§„åˆ™ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
è®¾ $\Sigma$ ä¸ºå­—æ¯è¡¨ï¼Œåˆ™å½¢å¼åŒ–è¯­è¨€ $L$ å®šä¹‰ä¸ºï¼š
$$L \subseteq \Sigma^*$$

å…¶ä¸­ $\Sigma^*$ æ˜¯æ‰€æœ‰å¯èƒ½å­—ç¬¦ä¸²çš„é›†åˆã€‚

**Pythonå®ç°**ï¼š
```python
from typing import Set, List, Tuple
from abc import ABC, abstractmethod

class FormalLanguage(ABC):
    """å½¢å¼åŒ–è¯­è¨€æŠ½è±¡åŸºç±»"""
    
    def __init__(self, alphabet: Set[str]):
        self.alphabet = alphabet
    
    @abstractmethod
    def is_valid(self, string: str) -> bool:
        """åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦å±äºè¯¥è¯­è¨€"""
        pass
    
    @abstractmethod
    def generate_strings(self, length: int) -> List[str]:
        """ç”ŸæˆæŒ‡å®šé•¿åº¦çš„æœ‰æ•ˆå­—ç¬¦ä¸²"""
        pass

class RegularLanguage(FormalLanguage):
    """æ­£åˆ™è¯­è¨€å®ç°"""
    
    def __init__(self, alphabet: Set[str], pattern: str):
        super().__init__(alphabet)
        self.pattern = pattern
        import re
        self.regex = re.compile(pattern)
    
    def is_valid(self, string: str) -> bool:
        """æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼"""
        return bool(self.regex.fullmatch(string))
    
    def generate_strings(self, length: int) -> List[str]:
        """ç”ŸæˆåŒ¹é…æ¨¡å¼çš„å­—ç¬¦ä¸²ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # è¿™é‡Œä½¿ç”¨ç®€åŒ–å®ç°ï¼Œå®é™…çš„æ­£åˆ™å­—ç¬¦ä¸²ç”Ÿæˆæ›´å¤æ‚
        if length == 0:
            return [""] if self.is_valid("") else []
        
        result = []
        for char in self.alphabet:
            for sub_string in self.generate_strings(length - 1):
                candidate = char + sub_string
                if self.is_valid(candidate):
                    result.append(candidate)
        return result

# ç¤ºä¾‹ï¼šå®šä¹‰äºŒè¿›åˆ¶æ•°å­—è¯­è¨€
binary_alphabet = {'0', '1'}
binary_language = RegularLanguage(binary_alphabet, r'^[01]+$')

# æµ‹è¯•
test_strings = ['101', '010', 'abc', '1010']
for s in test_strings:
    print(f"'{s}' æ˜¯æœ‰æ•ˆçš„äºŒè¿›åˆ¶æ•°å­—: {binary_language.is_valid(s)}")

# ç”Ÿæˆä¸€äº›æœ‰æ•ˆå­—ç¬¦ä¸²
valid_strings = binary_language.generate_strings(3)
print(f"é•¿åº¦ä¸º3çš„æœ‰æ•ˆäºŒè¿›åˆ¶å­—ç¬¦ä¸²: {valid_strings}")
```

### 2. é€»è¾‘æ¨ç†

**å®šä¹‰**ï¼šé€»è¾‘æ¨ç†æ˜¯ä»å·²çŸ¥å‰ææ¨å¯¼å‡ºç»“è®ºçš„è¿‡ç¨‹ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**ï¼š
å¯¹äºå‰æé›†åˆ $\Gamma$ å’Œç»“è®º $\phi$ï¼Œæ¨ç†è§„åˆ™è¡¨ç¤ºä¸ºï¼š
$$\frac{\Gamma}{\phi}$$

**Pythonå®ç°**ï¼š
```python
from typing import List, Set, Tuple, Any
from dataclasses import dataclass
from enum import Enum

class LogicalOperator(Enum):
    AND = "âˆ§"
    OR = "âˆ¨"
    NOT = "Â¬"
    IMPLIES = "â†’"
    EQUIVALENT = "â†”"

@dataclass
class Proposition:
    """å‘½é¢˜ç±»"""
    symbol: str
    value: bool = None
    
    def __str__(self):
        return self.symbol

@dataclass
class LogicalExpression:
    """é€»è¾‘è¡¨è¾¾å¼"""
    operator: LogicalOperator
    operands: List[Any]  # å¯ä»¥æ˜¯Propositionæˆ–LogicalExpression
    
    def evaluate(self, interpretation: dict) -> bool:
        """åœ¨ç»™å®šè§£é‡Šä¸‹æ±‚å€¼"""
        if self.operator == LogicalOperator.AND:
            return all(op.evaluate(interpretation) if hasattr(op, 'evaluate') 
                      else interpretation.get(op.symbol, False) 
                      for op in self.operands)
        elif self.operator == LogicalOperator.OR:
            return any(op.evaluate(interpretation) if hasattr(op, 'evaluate') 
                      else interpretation.get(op.symbol, False) 
                      for op in self.operands)
        elif self.operator == LogicalOperator.NOT:
            return not (self.operands[0].evaluate(interpretation) if hasattr(self.operands[0], 'evaluate')
                       else interpretation.get(self.operands[0].symbol, False))
        elif self.operator == LogicalOperator.IMPLIES:
            antecedent = self.operands[0].evaluate(interpretation) if hasattr(self.operands[0], 'evaluate')
                        else interpretation.get(self.operands[0].symbol, False)
            consequent = self.operands[1].evaluate(interpretation) if hasattr(self.operands[1], 'evaluate')
                        else interpretation.get(self.operands[1].symbol, False)
            return not antecedent or consequent
        return False

class LogicalInference:
    """é€»è¾‘æ¨ç†ç³»ç»Ÿ"""
    
    @staticmethod
    def modus_ponens(premise1: LogicalExpression, premise2: LogicalExpression) -> LogicalExpression:
        """å‡è¨€æ¨ç†ï¼šå¦‚æœ pâ†’q ä¸” pï¼Œåˆ™ q"""
        if (premise1.operator == LogicalOperator.IMPLIES and 
            premise2 == premise1.operands[0]):
            return premise1.operands[1]
        raise ValueError("ä¸æ»¡è¶³å‡è¨€æ¨ç†çš„å‰ææ¡ä»¶")
    
    @staticmethod
    def modus_tollens(premise1: LogicalExpression, premise2: LogicalExpression) -> LogicalExpression:
        """æ‹’å–å¼ï¼šå¦‚æœ pâ†’q ä¸” Â¬qï¼Œåˆ™ Â¬p"""
        if (premise1.operator == LogicalOperator.IMPLIES and 
            premise2.operator == LogicalOperator.NOT and
            premise2.operands[0] == premise1.operands[1]):
            return LogicalExpression(LogicalOperator.NOT, [premise1.operands[0]])
        raise ValueError("ä¸æ»¡è¶³æ‹’å–å¼çš„å‰ææ¡ä»¶")

# ç¤ºä¾‹ï¼šé€»è¾‘æ¨ç†
p = Proposition("p")
q = Proposition("q")

# æ„é€  pâ†’q
implies_pq = LogicalExpression(LogicalOperator.IMPLIES, [p, q])

# æµ‹è¯•æ¨ç†
interpretation = {"p": True, "q": True}
result = implies_pq.evaluate(interpretation)
print(f"å½“ p=True, q=True æ—¶ï¼Œpâ†’q = {result}")

# å‡è¨€æ¨ç†ç¤ºä¾‹
not_q = LogicalExpression(LogicalOperator.NOT, [q])
try:
    conclusion = LogicalInference.modus_tollens(implies_pq, not_q)
    print(f"é€šè¿‡æ‹’å–å¼æ¨ç†å¾—åˆ°: {conclusion}")
except ValueError as e:
    print(f"æ¨ç†å¤±è´¥: {e}")
```

### 3. å½¢å¼åŒ–è¯æ˜

**å®šä¹‰**ï¼šå½¢å¼åŒ–è¯æ˜æ˜¯é€šè¿‡ä¸¥æ ¼çš„é€»è¾‘è§„åˆ™ä»å…¬ç†æ¨å¯¼å‡ºå®šç†çš„è¿‡ç¨‹ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
è¯æ˜åºåˆ— $\pi = \langle \phi_1, \phi_2, ..., \phi_n \rangle$ æ»¡è¶³ï¼š
$$\forall i \in \{1, 2, ..., n\}: \Gamma \vdash \phi_i$$

**Pythonå®ç°**ï¼š
```python
from typing import List, Set, Tuple
from dataclasses import dataclass

@dataclass
class ProofStep:
    """è¯æ˜æ­¥éª¤"""
    step_number: int
    formula: str
    rule: str
    premises: List[int]  # å¼•ç”¨å‰é¢çš„æ­¥éª¤ç¼–å·

class FormalProof:
    """å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ"""
    
    def __init__(self):
        self.steps: List[ProofStep] = []
        self.assumptions: Set[str] = set()
    
    def add_assumption(self, formula: str) -> int:
        """æ·»åŠ å‡è®¾"""
        step_num = len(self.steps) + 1
        step = ProofStep(step_num, formula, "å‡è®¾", [])
        self.steps.append(step)
        self.assumptions.add(formula)
        return step_num
    
    def add_step(self, formula: str, rule: str, premises: List[int]) -> int:
        """æ·»åŠ è¯æ˜æ­¥éª¤"""
        step_num = len(self.steps) + 1
        step = ProofStep(step_num, formula, rule, premises)
        self.steps.append(step)
        return step_num
    
    def is_valid(self) -> bool:
        """æ£€æŸ¥è¯æ˜æ˜¯å¦æœ‰æ•ˆ"""
        for step in self.steps:
            if not self._validate_step(step):
                return False
        return True
    
    def _validate_step(self, step: ProofStep) -> bool:
        """éªŒè¯å•ä¸ªæ­¥éª¤"""
        if step.rule == "å‡è®¾":
            return True
        
        # æ£€æŸ¥å‰ææ˜¯å¦å­˜åœ¨
        for premise_num in step.premises:
            if premise_num < 1 or premise_num > len(self.steps):
                return False
        
        # è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„è§„åˆ™éªŒè¯
        return True
    
    def display(self):
        """æ˜¾ç¤ºè¯æ˜"""
        print("å½¢å¼åŒ–è¯æ˜:")
        print("-" * 50)
        for step in self.steps:
            premises_str = ", ".join(str(p) for p in step.premises) if step.premises else "æ— "
            print(f"{step.step_number}. {step.formula} [{step.rule}] å‰æ: {premises_str}")

# ç¤ºä¾‹ï¼šæ„é€ ä¸€ä¸ªç®€å•è¯æ˜
proof = FormalProof()

# è¯æ˜: å¦‚æœ pâ†’q ä¸” pï¼Œåˆ™ q
step1 = proof.add_assumption("pâ†’q")
step2 = proof.add_assumption("p")
step3 = proof.add_step("q", "å‡è¨€æ¨ç†", [step1, step2])

print("è¯æ˜æœ‰æ•ˆæ€§:", proof.is_valid())
proof.display()
```

### 4. æŠ½è±¡åŒ–æ–¹æ³•

**å®šä¹‰**ï¼šæŠ½è±¡åŒ–æ˜¯ä»å…·ä½“å®ä¾‹ä¸­æå–å…±åŒç‰¹å¾ï¼Œå½¢æˆä¸€èˆ¬æ¦‚å¿µçš„è¿‡ç¨‹ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
è®¾ $C$ ä¸ºå…·ä½“å®ä¾‹é›†åˆï¼ŒæŠ½è±¡åŒ–å‡½æ•° $A: C \rightarrow \mathcal{P}(C)$ æ»¡è¶³ï¼š
$$\forall c \in C: c \in A(c)$$

**Pythonå®ç°**ï¼š
```python
from typing import TypeVar, Generic, List, Dict, Any
from abc import ABC, abstractmethod

T = TypeVar('T')

class Abstraction(ABC, Generic[T]):
    """æŠ½è±¡åŒ–åŸºç±»"""
    
    @abstractmethod
    def abstract(self, concrete_instances: List[T]) -> Any:
        """ä»å…·ä½“å®ä¾‹ä¸­æŠ½è±¡å‡ºä¸€èˆ¬æ¦‚å¿µ"""
        pass
    
    @abstractmethod
    def concretize(self, abstract_concept: Any) -> List[T]:
        """å°†æŠ½è±¡æ¦‚å¿µå…·ä½“åŒ–"""
        pass

class PatternAbstraction(Abstraction[T]):
    """æ¨¡å¼æŠ½è±¡åŒ–"""
    
    def abstract(self, concrete_instances: List[T]) -> Dict[str, Any]:
        """æå–å…±åŒæ¨¡å¼"""
        if not concrete_instances:
            return {}
        
        # åˆ†æå®ä¾‹çš„å…±åŒç‰¹å¾
        common_features = {}
        
        # å¯¹äºæ•°å­—åˆ—è¡¨ï¼Œæå–ç»Ÿè®¡ç‰¹å¾
        if all(isinstance(x, (int, float)) for x in concrete_instances):
            common_features['type'] = 'numeric'
            common_features['min'] = min(concrete_instances)
            common_features['max'] = max(concrete_instances)
            common_features['mean'] = sum(concrete_instances) / len(concrete_instances)
        
        # å¯¹äºå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæå–å…±åŒå‰ç¼€å’Œåç¼€
        elif all(isinstance(x, str) for x in concrete_instances):
            common_features['type'] = 'string'
            if concrete_instances:
                common_features['common_prefix'] = self._find_common_prefix(concrete_instances)
                common_features['common_suffix'] = self._find_common_suffix(concrete_instances)
        
        return common_features
    
    def _find_common_prefix(self, strings: List[str]) -> str:
        """æ‰¾åˆ°å…±åŒå‰ç¼€"""
        if not strings:
            return ""
        
        prefix = strings[0]
        for s in strings[1:]:
            while not s.startswith(prefix):
                prefix = prefix[:-1]
                if not prefix:
                    return ""
        return prefix
    
    def _find_common_suffix(self, strings: List[str]) -> str:
        """æ‰¾åˆ°å…±åŒåç¼€"""
        reversed_strings = [s[::-1] for s in strings]
        common_prefix = self._find_common_prefix(reversed_strings)
        return common_prefix[::-1]
    
    def concretize(self, abstract_concept: Dict[str, Any]) -> List[T]:
        """æ ¹æ®æŠ½è±¡æ¦‚å¿µç”Ÿæˆå…·ä½“å®ä¾‹"""
        if abstract_concept.get('type') == 'numeric':
            # ç”Ÿæˆç¬¦åˆç»Ÿè®¡ç‰¹å¾çš„æ•°å­—
            min_val = abstract_concept['min']
            max_val = abstract_concept['max']
            mean_val = abstract_concept['mean']
            
            # ç”Ÿæˆä¸€äº›ç¤ºä¾‹å€¼
            return [min_val, max_val, mean_val, (min_val + max_val) / 2]
        
        elif abstract_concept.get('type') == 'string':
            # ç”Ÿæˆç¬¦åˆæ¨¡å¼çš„å­—ç¬¦ä¸²
            prefix = abstract_concept.get('common_prefix', '')
            suffix = abstract_concept.get('common_suffix', '')
            
            return [
                prefix + "example1" + suffix,
                prefix + "example2" + suffix,
                prefix + "test" + suffix
            ]
        
        return []

# ç¤ºä¾‹ï¼šæ¨¡å¼æŠ½è±¡åŒ–
abstraction = PatternAbstraction()

# æ•°å­—æ¨¡å¼æŠ½è±¡
numbers = [1, 3, 5, 7, 9]
numeric_pattern = abstraction.abstract(numbers)
print(f"æ•°å­—æ¨¡å¼: {numeric_pattern}")

# å­—ç¬¦ä¸²æ¨¡å¼æŠ½è±¡
strings = ["user_001", "user_002", "user_003"]
string_pattern = abstraction.abstract(strings)
print(f"å­—ç¬¦ä¸²æ¨¡å¼: {string_pattern}")

# å…·ä½“åŒ–
concrete_numbers = abstraction.concretize(numeric_pattern)
concrete_strings = abstraction.concretize(string_pattern)
print(f"å…·ä½“åŒ–æ•°å­—: {concrete_numbers}")
print(f"å…·ä½“åŒ–å­—ç¬¦ä¸²: {concrete_strings}")
```

## ğŸ”¬ å½¢å¼åŒ–æ–¹æ³•

### 1. å½’çº³æ³•

**æ•°å­¦å½’çº³æ³•**ï¼š
å¯¹äºæ€§è´¨ $P(n)$ï¼Œå¦‚æœï¼š
1. $P(0)$ æˆç«‹ï¼ˆåŸºç¡€æƒ…å†µï¼‰
2. $\forall k \geq 0: P(k) \rightarrow P(k+1)$ï¼ˆå½’çº³æ­¥éª¤ï¼‰

åˆ™ $\forall n \geq 0: P(n)$ æˆç«‹ã€‚

**Pythonå®ç°**ï¼š
```python
from typing import Callable
from functools import wraps

def mathematical_induction(property_func: Callable[[int], bool], max_n: int = 100) -> bool:
    """æ•°å­¦å½’çº³æ³•éªŒè¯"""
    
    # éªŒè¯åŸºç¡€æƒ…å†µ
    if not property_func(0):
        print("åŸºç¡€æƒ…å†µ P(0) ä¸æˆç«‹")
        return False
    
    # éªŒè¯å½’çº³æ­¥éª¤
    for k in range(max_n):
        if property_func(k) and not property_func(k + 1):
            print(f"å½’çº³æ­¥éª¤åœ¨ k={k} æ—¶å¤±è´¥")
            return False
    
    print("æ•°å­¦å½’çº³æ³•éªŒè¯é€šè¿‡")
    return True

# ç¤ºä¾‹ï¼šéªŒè¯æ±‚å’Œå…¬å¼
def verify_sum_formula(n: int) -> bool:
    """éªŒè¯ 1 + 2 + ... + n = n(n+1)/2"""
    actual_sum = sum(range(1, n + 1))
    expected_sum = n * (n + 1) // 2
    return actual_sum == expected_sum

# ä½¿ç”¨æ•°å­¦å½’çº³æ³•éªŒè¯
result = mathematical_induction(verify_sum_formula, max_n=10)
print(f"æ±‚å’Œå…¬å¼éªŒè¯ç»“æœ: {result}")
```

### 2. åè¯æ³•

**å®šä¹‰**ï¼šåè¯æ³•æ˜¯é€šè¿‡å‡è®¾ç»“è®ºä¸æˆç«‹ï¼Œæ¨å¯¼å‡ºçŸ›ç›¾æ¥è¯æ˜åŸç»“è®ºçš„æ–¹æ³•ã€‚

**Pythonå®ç°**ï¼š
```python
from typing import Callable, Any

class ProofByContradiction:
    """åè¯æ³•è¯æ˜ç³»ç»Ÿ"""
    
    @staticmethod
    def prove(statement: str, contradiction_checker: Callable[[Any], bool]) -> bool:
        """ä½¿ç”¨åè¯æ³•è¯æ˜"""
        print(f"è¯æ˜: {statement}")
        print("ä½¿ç”¨åè¯æ³•...")
        
        # å‡è®¾ç»“è®ºä¸æˆç«‹
        print("å‡è®¾ç»“è®ºä¸æˆç«‹...")
        
        # å¯»æ‰¾çŸ›ç›¾
        contradiction_found = contradiction_checker(None)
        
        if contradiction_found:
            print("å‘ç°çŸ›ç›¾ï¼åŸå‡è®¾é”™è¯¯ã€‚")
            print(f"å› æ­¤ï¼Œ{statement} æˆç«‹ã€‚")
            return True
        else:
            print("æœªå‘ç°çŸ›ç›¾ï¼Œåè¯æ³•å¤±è´¥ã€‚")
            return False

# ç¤ºä¾‹ï¼šè¯æ˜æ— ç†æ•°çš„å­˜åœ¨
def prove_irrational_sqrt2():
    """è¯æ˜ âˆš2 æ˜¯æ— ç†æ•°"""
    
    def contradiction_checker(assumption):
        # å‡è®¾ âˆš2 æ˜¯æœ‰ç†æ•°ï¼Œå³ âˆš2 = p/qï¼Œå…¶ä¸­ p, q äº’è´¨
        # åˆ™ 2 = pÂ²/qÂ²ï¼Œå³ 2qÂ² = pÂ²
        # è¿™æ„å‘³ç€ pÂ² æ˜¯å¶æ•°ï¼Œæ‰€ä»¥ p æ˜¯å¶æ•°
        # è®¾ p = 2kï¼Œåˆ™ 2qÂ² = (2k)Â² = 4kÂ²ï¼Œå³ qÂ² = 2kÂ²
        # è¿™æ„å‘³ç€ qÂ² ä¹Ÿæ˜¯å¶æ•°ï¼Œæ‰€ä»¥ q æ˜¯å¶æ•°
        # è¿™ä¸ p, q äº’è´¨çš„å‡è®¾çŸ›ç›¾
        return True  # å‘ç°çŸ›ç›¾
    
    return ProofByContradiction.prove("âˆš2 æ˜¯æ— ç†æ•°", contradiction_checker)

# æ‰§è¡Œè¯æ˜
prove_irrational_sqrt2()
```

## ğŸ“Š å½¢å¼åŒ–éªŒè¯

### 1. æ¨¡å‹æ£€æŸ¥

**å®šä¹‰**ï¼šæ¨¡å‹æ£€æŸ¥æ˜¯é€šè¿‡ç©·ä¸¾æœç´¢éªŒè¯ç³»ç»Ÿæ˜¯å¦æ»¡è¶³è§„èŒƒçš„æ–¹æ³•ã€‚

**Pythonå®ç°**ï¼š
```python
from typing import Dict, Set, List, Tuple
from dataclasses import dataclass
from enum import Enum

class State(Enum):
    INITIAL = "initial"
    PROCESSING = "processing"
    FINAL = "final"
    ERROR = "error"

@dataclass
class Transition:
    """çŠ¶æ€è½¬æ¢"""
    from_state: State
    to_state: State
    condition: str

class ModelChecker:
    """æ¨¡å‹æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.states: Set[State] = set()
        self.transitions: List[Transition] = []
        self.initial_state: State = None
        self.properties: List[str] = []
    
    def add_state(self, state: State):
        """æ·»åŠ çŠ¶æ€"""
        self.states.add(state)
    
    def add_transition(self, transition: Transition):
        """æ·»åŠ è½¬æ¢"""
        self.transitions.append(transition)
    
    def set_initial_state(self, state: State):
        """è®¾ç½®åˆå§‹çŠ¶æ€"""
        self.initial_state = state
    
    def add_property(self, property_desc: str):
        """æ·»åŠ è¦éªŒè¯çš„å±æ€§"""
        self.properties.append(property_desc)
    
    def check_property(self, property_desc: str) -> bool:
        """æ£€æŸ¥å±æ€§æ˜¯å¦æ»¡è¶³"""
        if "å¯è¾¾æ€§" in property_desc:
            return self._check_reachability()
        elif "å®‰å…¨æ€§" in property_desc:
            return self._check_safety()
        elif "æ´»æ€§" in property_desc:
            return self._check_liveness()
        return False
    
    def _check_reachability(self) -> bool:
        """æ£€æŸ¥å¯è¾¾æ€§"""
        reachable_states = {self.initial_state}
        changed = True
        
        while changed:
            changed = False
            for transition in self.transitions:
                if transition.from_state in reachable_states:
                    if transition.to_state not in reachable_states:
                        reachable_states.add(transition.to_state)
                        changed = True
        
        return len(reachable_states) == len(self.states)
    
    def _check_safety(self) -> bool:
        """æ£€æŸ¥å®‰å…¨æ€§ï¼ˆä¸è¿›å…¥é”™è¯¯çŠ¶æ€ï¼‰"""
        reachable_states = {self.initial_state}
        changed = True
        
        while changed:
            changed = False
            for transition in self.transitions:
                if transition.from_state in reachable_states:
                    if transition.to_state not in reachable_states:
                        reachable_states.add(transition.to_state)
                        changed = True
        
        return State.ERROR not in reachable_states
    
    def _check_liveness(self) -> bool:
        """æ£€æŸ¥æ´»æ€§ï¼ˆæœ€ç»ˆå¯è¾¾ç›®æ ‡çŠ¶æ€ï¼‰"""
        # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨åˆ°ç›®æ ‡çŠ¶æ€çš„è·¯å¾„
        return True

# ç¤ºä¾‹ï¼šéªŒè¯ç®€å•çŠ¶æ€æœº
checker = ModelChecker()

# æ·»åŠ çŠ¶æ€
checker.add_state(State.INITIAL)
checker.add_state(State.PROCESSING)
checker.add_state(State.FINAL)
checker.add_state(State.ERROR)

# æ·»åŠ è½¬æ¢
checker.add_transition(Transition(State.INITIAL, State.PROCESSING, "start"))
checker.add_transition(Transition(State.PROCESSING, State.FINAL, "complete"))
checker.add_transition(Transition(State.PROCESSING, State.ERROR, "fail"))

# è®¾ç½®åˆå§‹çŠ¶æ€
checker.set_initial_state(State.INITIAL)

# éªŒè¯å±æ€§
safety_result = checker.check_property("å®‰å…¨æ€§")
reachability_result = checker.check_property("å¯è¾¾æ€§")

print(f"å®‰å…¨æ€§æ£€æŸ¥: {safety_result}")
print(f"å¯è¾¾æ€§æ£€æŸ¥: {reachability_result}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.01 è®¡ç®—å“²å­¦åŸºç¡€](./00.01-è®¡ç®—å“²å­¦åŸºç¡€.md)
- [00.03 ç§‘å­¦æ–¹æ³•è®º](./00.03-ç§‘å­¦æ–¹æ³•è®º.md)
- [01.02 é€»è¾‘å­¦](../01-å½¢å¼ç§‘å­¦/01.02-é€»è¾‘å­¦.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Huth, M., & Ryan, M. (2004). Logic in computer science: modelling and reasoning about systems. Cambridge University Press.
2. Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model checking. MIT press.
3. Abrial, J. R. (2010). Modeling in Event-B: system and software engineering. Cambridge University Press.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0.0 