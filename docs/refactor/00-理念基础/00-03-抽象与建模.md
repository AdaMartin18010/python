# 00-03 抽象与建模

## 目录

- [00-03 抽象与建模](#00-03-抽象与建模)
  - [目录](#目录)
  - [1. 概念定义](#1-概念定义)
    - [1.1 抽象](#11-抽象)
    - [1.2 建模](#12-建模)
    - [1.3 抽象与建模的关系](#13-抽象与建模的关系)
  - [2. 抽象理论](#2-抽象理论)
    - [2.1 抽象原理](#21-抽象原理)
    - [2.2 抽象层次](#22-抽象层次)
  - [3. 建模方法](#3-建模方法)
    - [3.1 建模过程](#31-建模过程)
    - [3.2 建模原则](#32-建模原则)
  - [4. 形式化表示](#4-形式化表示)
    - [4.1 抽象代数](#41-抽象代数)
    - [4.2 范畴论](#42-范畴论)
  - [5. 抽象层次](#5-抽象层次)
    - [5.1 软件抽象层次](#51-软件抽象层次)
    - [5.2 数据抽象层次](#52-数据抽象层次)
  - [6. 建模语言](#6-建模语言)
    - [6.1 UML (统一建模语言)](#61-uml-统一建模语言)
    - [6.2 领域特定语言 (DSL)](#62-领域特定语言-dsl)
  - [7. 实践应用](#7-实践应用)
    - [7.1 软件架构建模](#71-软件架构建模)
    - [7.2 数据建模](#72-数据建模)
  - [8. 案例分析](#8-案例分析)
    - [8.1 电商系统建模](#81-电商系统建模)
  - [9. 总结](#9-总结)
    - [9.1 核心观点](#91-核心观点)
    - [9.2 实践意义](#92-实践意义)
    - [9.3 发展前景](#93-发展前景)

---

## 1. 概念定义

### 1.1 抽象

**定义 1.1** (抽象)
抽象是从具体事物中提取共同特征，忽略个体差异，形成一般概念的过程。

**形式化定义**:
设 $O$ 为对象集合，$F$ 为特征集合，$A$ 为抽象函数，则抽象可以定义为：

$$A: O \times F \rightarrow C$$

其中：

- $O = \{o_1, o_2, ..., o_n\}$ 表示具体对象集合
- $F = \{f_1, f_2, ..., f_m\}$ 表示特征集合
- $C = \{c_1, c_2, ..., c_k\}$ 表示抽象概念集合

**数学表示**:
$$\text{Abstraction}(O, F) = \{c \in C | \forall o \in O, \exists f \in F: f(o) \in c\}$$

### 1.2 建模

**定义 1.2** (建模)
建模是创建系统的简化表示，用于理解、分析和预测系统行为的过程。

**形式化定义**:
设 $S$ 为系统，$M$ 为模型，$R$ 为关系集合，则建模可以定义为：

$$M = \langle \text{Elements}, \text{Relations}, \text{Constraints}, \text{Behavior} \rangle$$

其中：

- $\text{Elements}$ 是模型元素集合
- $\text{Relations}$ 是元素间关系集合
- $\text{Constraints}$ 是约束条件集合
- $\text{Behavior}$ 是行为描述

### 1.3 抽象与建模的关系

**定理 1.1** (抽象建模关系)
抽象是建模的基础，建模是抽象的应用。

**证明**:

1. 建模需要抽象来识别系统的本质特征
2. 抽象通过建模得到具体表达
3. 建模过程包含多个抽象层次

---

## 2. 抽象理论

### 2.1 抽象原理

**原理 2.1** (选择性抽象)
抽象是有选择性的，只保留与目标相关的特征。

**数学表示**:
设 $F_{all}$ 为所有特征集合，$F_{relevant}$ 为相关特征集合，则选择性抽象可以表示为：

$$A_{selective}(O) = \{f(o) | f \in F_{relevant}, o \in O\}$$

**Python实现**:

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Set, Callable
from dataclasses import dataclass
from enum import Enum
import numpy as np

class FeatureType(Enum):
    """特征类型"""
    ESSENTIAL = "essential"
    IMPORTANT = "important"
    OPTIONAL = "optional"
    IRRELEVANT = "irrelevant"

@dataclass
class Feature:
    """特征定义"""
    name: str
    type: FeatureType
    weight: float
    extractor: Callable[[Any], Any]

@dataclass
class AbstractConcept:
    """抽象概念"""
    name: str
    features: Dict[str, Any]
    confidence: float
    instances: List[Any]

class AbstractionEngine:
    """抽象引擎"""
    
    def __init__(self):
        self.features: Dict[str, Feature] = {}
        self.concepts: Dict[str, AbstractConcept] = {}
        self.abstraction_rules: List[Callable] = []
    
    def register_feature(self, feature: Feature):
        """注册特征"""
        self.features[feature.name] = feature
    
    def add_abstraction_rule(self, rule: Callable):
        """添加抽象规则"""
        self.abstraction_rules.append(rule)
    
    def abstract_objects(self, objects: List[Any], target_features: Set[str]) -> List[AbstractConcept]:
        """抽象对象"""
        concepts = []
        
        # 按特征分组对象
        feature_groups = self._group_by_features(objects, target_features)
        
        # 为每个组创建抽象概念
        for feature_values, group_objects in feature_groups.items():
            concept = self._create_concept(feature_values, group_objects)
            concepts.append(concept)
        
        # 应用抽象规则
        for rule in self.abstraction_rules:
            concepts = rule(concepts)
        
        return concepts
    
    def _group_by_features(self, objects: List[Any], target_features: Set[str]) -> Dict[tuple, List[Any]]:
        """按特征分组对象"""
        groups = {}
        
        for obj in objects:
            feature_values = []
            for feature_name in target_features:
                if feature_name in self.features:
                    feature = self.features[feature_name]
                    value = feature.extractor(obj)
                    feature_values.append(value)
            
            key = tuple(feature_values)
            if key not in groups:
                groups[key] = []
            groups[key].append(obj)
        
        return groups
    
    def _create_concept(self, feature_values: tuple, objects: List[Any]) -> AbstractConcept:
        """创建抽象概念"""
        features = {}
        for i, feature_name in enumerate(self.features.keys()):
            if i < len(feature_values):
                features[feature_name] = feature_values[i]
        
        # 计算置信度
        confidence = self._calculate_confidence(objects, features)
        
        return AbstractConcept(
            name=f"Concept_{len(self.concepts)}",
            features=features,
            confidence=confidence,
            instances=objects
        )
    
    def _calculate_confidence(self, objects: List[Any], features: Dict[str, Any]) -> float:
        """计算抽象置信度"""
        if not objects:
            return 0.0
        
        # 基于对象数量和特征一致性计算置信度
        consistency_score = self._calculate_feature_consistency(objects, features)
        size_score = min(len(objects) / 10.0, 1.0)  # 归一化
        
        return (consistency_score + size_score) / 2.0
    
    def _calculate_feature_consistency(self, objects: List[Any], features: Dict[str, Any]) -> float:
        """计算特征一致性"""
        if not objects:
            return 0.0
        
        consistency_scores = []
        for feature_name, expected_value in features.items():
            if feature_name in self.features:
                feature = self.features[feature_name]
                actual_values = [feature.extractor(obj) for obj in objects]
                
                # 计算实际值与期望值的一致性
                matches = sum(1 for val in actual_values if val == expected_value)
                consistency = matches / len(actual_values)
                consistency_scores.append(consistency)
        
        return np.mean(consistency_scores) if consistency_scores else 0.0

class HierarchicalAbstraction:
    """层次化抽象"""
    
    def __init__(self, abstraction_engine: AbstractionEngine):
        self.engine = abstraction_engine
        self.abstraction_levels: List[List[AbstractConcept]] = []
    
    def create_hierarchy(self, objects: List[Any], max_levels: int = 3) -> List[List[AbstractConcept]]:
        """创建层次化抽象"""
        self.abstraction_levels = []
        current_objects = objects
        
        for level in range(max_levels):
            # 选择当前层次的特征
            target_features = self._select_features_for_level(level, max_levels)
            
            # 创建抽象
            concepts = self.engine.abstract_objects(current_objects, target_features)
            self.abstraction_levels.append(concepts)
            
            # 为下一层次准备对象
            if level < max_levels - 1:
                current_objects = [concept for concept in concepts]
        
        return self.abstraction_levels
    
    def _select_features_for_level(self, level: int, max_levels: int) -> Set[str]:
        """为层次选择特征"""
        all_features = set(self.engine.features.keys())
        feature_count = len(all_features)
        
        # 根据层次选择特征数量
        features_per_level = max(1, feature_count // max_levels)
        selected_count = min(features_per_level * (level + 1), feature_count)
        
        # 按重要性选择特征
        sorted_features = sorted(
            self.engine.features.items(),
            key=lambda x: x[1].weight,
            reverse=True
        )
        
        return {name for name, _ in sorted_features[:selected_count]}

# 使用示例
def demonstrate_abstraction():
    """演示抽象过程"""
    # 创建抽象引擎
    engine = AbstractionEngine()
    
    # 注册特征
    engine.register_feature(Feature(
        name="size",
        type=FeatureType.ESSENTIAL,
        weight=1.0,
        extractor=lambda obj: getattr(obj, 'size', 0)
    ))
    
    engine.register_feature(Feature(
        name="color",
        type=FeatureType.IMPORTANT,
        weight=0.8,
        extractor=lambda obj: getattr(obj, 'color', 'unknown')
    ))
    
    engine.register_feature(Feature(
        name="shape",
        type=FeatureType.OPTIONAL,
        weight=0.6,
        extractor=lambda obj: getattr(obj, 'shape', 'unknown')
    ))
    
    # 创建测试对象
    class TestObject:
        def __init__(self, size, color, shape):
            self.size = size
            self.color = color
            self.shape = shape
    
    objects = [
        TestObject(10, 'red', 'circle'),
        TestObject(10, 'red', 'square'),
        TestObject(15, 'blue', 'circle'),
        TestObject(15, 'blue', 'triangle'),
        TestObject(20, 'green', 'circle')
    ]
    
    # 执行抽象
    target_features = {'size', 'color'}
    concepts = engine.abstract_objects(objects, target_features)
    
    print("抽象结果:")
    for concept in concepts:
        print(f"概念: {concept.name}")
        print(f"特征: {concept.features}")
        print(f"置信度: {concept.confidence:.3f}")
        print(f"实例数量: {len(concept.instances)}")
        print()
    
    # 层次化抽象
    hierarchical = HierarchicalAbstraction(engine)
    levels = hierarchical.create_hierarchy(objects, max_levels=2)
    
    print("层次化抽象结果:")
    for i, level_concepts in enumerate(levels):
        print(f"层次 {i+1}: {len(level_concepts)} 个概念")

if __name__ == "__main__":
    demonstrate_abstraction()
```

### 2.2 抽象层次

**定义 2.1** (抽象层次)
抽象层次是抽象过程中不同级别的概念表示。

**数学表示**:
设 $L_i$ 为第 $i$ 层抽象，$A_i$ 为第 $i$ 层抽象函数，则层次关系可以表示为：

$$L_{i+1} = A_i(L_i)$$

**层次特征**:

1. **具体层**: 包含所有细节
2. **逻辑层**: 包含主要逻辑关系
3. **概念层**: 包含核心概念
4. **元层**: 包含抽象规则

---

## 3. 建模方法

### 3.1 建模过程

**定义 3.1** (建模过程)
建模过程包括以下步骤：

1. **问题理解**: 理解建模目标
2. **系统分析**: 分析系统结构
3. **抽象选择**: 选择合适的抽象层次
4. **模型构建**: 构建模型
5. **验证验证**: 验证模型正确性
6. **模型使用**: 使用模型进行分析

**数学表示**:
$$\text{Modeling} = \text{Understand} \circ \text{Analyze} \circ \text{Abstract} \circ \text{Build} \circ \text{Validate} \circ \text{Use}$$

### 3.2 建模原则

**原则 3.1** (简化原则)
模型应该比原系统简单，但保留关键特征。

**原则 3.2** (准确性原则)
模型应该准确反映系统的关键行为。

**原则 3.3** (实用性原则)
模型应该能够支持实际应用。

**Python实现**:

```python
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import json

class ModelType(Enum):
    """模型类型"""
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"
    FUNCTIONAL = "functional"
    DATA = "data"

@dataclass
class ModelElement:
    """模型元素"""
    id: str
    name: str
    type: str
    properties: Dict[str, Any]
    relationships: List[str]

@dataclass
class Model:
    """模型定义"""
    name: str
    type: ModelType
    elements: List[ModelElement]
    constraints: List[str]
    behavior: Optional[Callable] = None

class ModelingFramework:
    """建模框架"""
    
    def __init__(self):
        self.models: Dict[str, Model] = {}
        self.modeling_patterns: Dict[str, Callable] = {}
        self.validation_rules: List[Callable] = []
    
    def create_model(self, name: str, model_type: ModelType) -> Model:
        """创建模型"""
        model = Model(
            name=name,
            type=model_type,
            elements=[],
            constraints=[]
        )
        self.models[name] = model
        return model
    
    def add_element(self, model_name: str, element: ModelElement):
        """添加模型元素"""
        if model_name in self.models:
            self.models[model_name].elements.append(element)
    
    def add_constraint(self, model_name: str, constraint: str):
        """添加约束"""
        if model_name in self.models:
            self.models[model_name].constraints.append(constraint)
    
    def validate_model(self, model_name: str) -> Dict[str, Any]:
        """验证模型"""
        if model_name not in self.models:
            return {"valid": False, "errors": ["Model not found"]}
        
        model = self.models[model_name]
        validation_results = {
            "valid": True,
            "errors": [],
            "warnings": [],
            "metrics": {}
        }
        
        # 应用验证规则
        for rule in self.validation_rules:
            result = rule(model)
            if not result["valid"]:
                validation_results["valid"] = False
                validation_results["errors"].extend(result["errors"])
            if result.get("warnings"):
                validation_results["warnings"].extend(result["warnings"])
            if result.get("metrics"):
                validation_results["metrics"].update(result["metrics"])
        
        return validation_results
    
    def register_validation_rule(self, rule: Callable):
        """注册验证规则"""
        self.validation_rules.append(rule)
    
    def export_model(self, model_name: str, format: str = "json") -> str:
        """导出模型"""
        if model_name not in self.models:
            raise ValueError(f"Model {model_name} not found")
        
        model = self.models[model_name]
        
        if format == "json":
            return self._export_to_json(model)
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    def _export_to_json(self, model: Model) -> str:
        """导出为JSON格式"""
        model_dict = {
            "name": model.name,
            "type": model.type.value,
            "elements": [
                {
                    "id": elem.id,
                    "name": elem.name,
                    "type": elem.type,
                    "properties": elem.properties,
                    "relationships": elem.relationships
                }
                for elem in model.elements
            ],
            "constraints": model.constraints
        }
        return json.dumps(model_dict, indent=2)

# 验证规则示例
def validate_model_completeness(model: Model) -> Dict[str, Any]:
    """验证模型完整性"""
    errors = []
    warnings = []
    metrics = {}
    
    # 检查元素数量
    if len(model.elements) == 0:
        errors.append("Model has no elements")
    
    # 检查元素ID唯一性
    element_ids = [elem.id for elem in model.elements]
    if len(element_ids) != len(set(element_ids)):
        errors.append("Duplicate element IDs found")
    
    # 检查关系完整性
    all_ids = set(element_ids)
    for element in model.elements:
        for rel_id in element.relationships:
            if rel_id not in all_ids:
                warnings.append(f"Relationship {rel_id} references non-existent element")
    
    metrics["element_count"] = len(model.elements)
    metrics["constraint_count"] = len(model.constraints)
    
    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings,
        "metrics": metrics
    }

# 使用示例
def demonstrate_modeling():
    """演示建模过程"""
    framework = ModelingFramework()
    
    # 注册验证规则
    framework.register_validation_rule(validate_model_completeness)
    
    # 创建系统架构模型
    system_model = framework.create_model("SystemArchitecture", ModelType.STRUCTURAL)
    
    # 添加模型元素
    framework.add_element("SystemArchitecture", ModelElement(
        id="web_server",
        name="Web Server",
        type="component",
        properties={"technology": "Python", "port": 8000},
        relationships=["database", "cache"]
    ))
    
    framework.add_element("SystemArchitecture", ModelElement(
        id="database",
        name="Database",
        type="component",
        properties={"type": "PostgreSQL", "version": "13"},
        relationships=["web_server"]
    ))
    
    framework.add_element("SystemArchitecture", ModelElement(
        id="cache",
        name="Cache",
        type="component",
        properties={"type": "Redis", "ttl": 3600},
        relationships=["web_server"]
    ))
    
    # 添加约束
    framework.add_constraint("SystemArchitecture", "All components must be connected")
    framework.add_constraint("SystemArchitecture", "Database must be persistent")
    
    # 验证模型
    validation = framework.validate_model("SystemArchitecture")
    print("模型验证结果:")
    print(f"有效: {validation['valid']}")
    print(f"错误: {validation['errors']}")
    print(f"警告: {validation['warnings']}")
    print(f"指标: {validation['metrics']}")
    
    # 导出模型
    model_json = framework.export_model("SystemArchitecture")
    print(f"\n模型JSON:\n{model_json}")

if __name__ == "__main__":
    demonstrate_modeling()
```

---

## 4. 形式化表示

### 4.1 抽象代数

**定义 4.1** (抽象代数)
抽象代数是研究代数结构及其性质的数学分支。

**基本结构**:

1. **群** (Group): $(G, \cdot)$ 满足结合律、单位元、逆元
2. **环** (Ring): $(R, +, \cdot)$ 满足加法群、乘法半群、分配律
3. **域** (Field): $(F, +, \cdot)$ 满足加法群、乘法群、分配律

### 4.2 范畴论

**定义 4.2** (范畴)
范畴是由对象和态射组成的数学结构。

**数学表示**:
$$\mathcal{C} = \langle \text{Ob}(\mathcal{C}), \text{Mor}(\mathcal{C}), \circ, \text{id} \rangle$$

其中：

- $\text{Ob}(\mathcal{C})$ 是对象集合
- $\text{Mor}(\mathcal{C})$ 是态射集合
- $\circ$ 是态射复合
- $\text{id}$ 是恒等态射

---

## 5. 抽象层次

### 5.1 软件抽象层次

**层次 5.1** (应用层)
用户界面和业务逻辑。

**层次 5.2** (服务层)
业务服务和API接口。

**层次 5.3** (领域层)
核心业务逻辑和领域模型。

**层次 5.4** (基础设施层)
技术实现和外部依赖。

### 5.2 数据抽象层次

**层次 5.5** (概念层)
实体关系模型。

**层次 5.6** (逻辑层)
关系模型和规范化。

**层次 5.7** (物理层)
存储结构和索引。

---

## 6. 建模语言

### 6.1 UML (统一建模语言)

**UML图类型**:

1. **类图**: 表示类结构和关系
2. **序列图**: 表示对象交互
3. **状态图**: 表示状态转换
4. **活动图**: 表示业务流程

### 6.2 领域特定语言 (DSL)

**DSL特征**:

1. **专用性**: 针对特定领域
2. **简洁性**: 语法简洁明了
3. **表达性**: 能够表达领域概念

**Python实现**:

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
import re

class DSLParser(ABC):
    """DSL解析器抽象"""
    
    @abstractmethod
    def parse(self, text: str) -> Any:
        """解析DSL文本"""
        pass

class EntityDSL:
    """实体DSL"""
    
    def __init__(self):
        self.entities: Dict[str, Dict] = {}
        self.relationships: List[Dict] = []
    
    def define_entity(self, name: str, attributes: List[str]):
        """定义实体"""
        self.entities[name] = {
            "name": name,
            "attributes": attributes,
            "methods": []
        }
    
    def add_method(self, entity_name: str, method_name: str, parameters: List[str]):
        """添加方法"""
        if entity_name in self.entities:
            self.entities[entity_name]["methods"].append({
                "name": method_name,
                "parameters": parameters
            })
    
    def define_relationship(self, from_entity: str, to_entity: str, relationship_type: str):
        """定义关系"""
        self.relationships.append({
            "from": from_entity,
            "to": to_entity,
            "type": relationship_type
        })
    
    def generate_code(self) -> str:
        """生成Python代码"""
        code_lines = []
        
        # 生成实体类
        for entity_name, entity_data in self.entities.items():
            code_lines.append(f"class {entity_name}:")
            code_lines.append('    """' + entity_name + ' entity"""')
            code_lines.append("")
            
            # 构造函数
            if entity_data["attributes"]:
                params = ", ".join(entity_data["attributes"])
                code_lines.append(f"    def __init__(self, {params}):")
                for attr in entity_data["attributes"]:
                    code_lines.append(f"        self.{attr} = {attr}")
            else:
                code_lines.append("    def __init__(self):")
                code_lines.append("        pass")
            
            code_lines.append("")
            
            # 方法
            for method in entity_data["methods"]:
                params = ", ".join(method["parameters"])
                code_lines.append(f"    def {method['name']}(self, {params}):")
                code_lines.append("        # TODO: Implement method")
                code_lines.append("        pass")
                code_lines.append("")
        
        return "\n".join(code_lines)

class DSLInterpreter:
    """DSL解释器"""
    
    def __init__(self):
        self.dsl = EntityDSL()
        self.commands = {
            "entity": self._parse_entity,
            "method": self._parse_method,
            "relationship": self._parse_relationship
        }
    
    def interpret(self, dsl_text: str) -> str:
        """解释DSL文本"""
        lines = dsl_text.strip().split('\n')
        
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#'):
                self._parse_line(line)
        
        return self.dsl.generate_code()
    
    def _parse_line(self, line: str):
        """解析单行DSL"""
        parts = line.split()
        if not parts:
            return
        
        command = parts[0].lower()
        if command in self.commands:
            self.commands[command](parts[1:])
    
    def _parse_entity(self, parts: List[str]):
        """解析实体定义"""
        if len(parts) < 2:
            return
        
        entity_name = parts[0]
        attributes = parts[1:]
        self.dsl.define_entity(entity_name, attributes)
    
    def _parse_method(self, parts: List[str]):
        """解析方法定义"""
        if len(parts) < 3:
            return
        
        entity_name = parts[0]
        method_name = parts[1]
        parameters = parts[2:]
        self.dsl.add_method(entity_name, method_name, parameters)
    
    def _parse_relationship(self, parts: List[str]):
        """解析关系定义"""
        if len(parts) != 3:
            return
        
        from_entity, relationship_type, to_entity = parts
        self.dsl.define_relationship(from_entity, to_entity, relationship_type)

# 使用示例
def demonstrate_dsl():
    """演示DSL建模"""
    dsl_text = """
    # 定义用户实体
    entity User id name email password
    method User authenticate password
    method User update_profile name email
    
    # 定义订单实体
    entity Order id user_id total_amount status
    method Order calculate_total items
    method Order update_status new_status
    
    # 定义关系
    relationship User has_many Order
    relationship Order belongs_to User
    """
    
    interpreter = DSLInterpreter()
    generated_code = interpreter.interpret(dsl_text)
    
    print("生成的Python代码:")
    print(generated_code)

if __name__ == "__main__":
    demonstrate_dsl()
```

---

## 7. 实践应用

### 7.1 软件架构建模

**应用 7.1** (分层架构)
使用抽象层次建模软件架构。

**应用 7.2** (微服务架构)
使用服务边界建模系统组件。

**应用 7.3** (事件驱动架构)
使用事件流建模系统行为。

### 7.2 数据建模

**应用 7.4** (概念建模)
使用实体关系图建模数据概念。

**应用 7.5** (逻辑建模)
使用关系模型建模数据结构。

**应用 7.6** (物理建模)
使用存储结构建模数据实现。

---

## 8. 案例分析

### 8.1 电商系统建模

**案例背景**: 设计电商系统的抽象模型

**建模过程**:

1. **概念层**: 用户、商品、订单、支付
2. **逻辑层**: 实体关系和数据流
3. **物理层**: 数据库设计和API接口

**Python实现**:

```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

class OrderStatus(Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

class PaymentStatus(Enum):
    PENDING = "pending"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"

@dataclass
class User:
    """用户实体"""
    id: str
    name: str
    email: str
    phone: Optional[str] = None
    address: Optional[str] = None
    
    def update_profile(self, name: str = None, email: str = None, phone: str = None):
        """更新用户资料"""
        if name:
            self.name = name
        if email:
            self.email = email
        if phone:
            self.phone = phone

@dataclass
class Product:
    """商品实体"""
    id: str
    name: str
    price: float
    description: str
    category: str
    stock: int
    
    def update_stock(self, quantity: int):
        """更新库存"""
        self.stock += quantity
        if self.stock < 0:
            self.stock = 0
    
    def is_available(self) -> bool:
        """检查是否可用"""
        return self.stock > 0

@dataclass
class OrderItem:
    """订单项"""
    product_id: str
    quantity: int
    unit_price: float
    
    @property
    def total_price(self) -> float:
        """计算总价"""
        return self.quantity * self.unit_price

@dataclass
class Order:
    """订单实体"""
    id: str
    user_id: str
    items: List[OrderItem]
    status: OrderStatus
    created_at: datetime
    updated_at: datetime
    
    @property
    def total_amount(self) -> float:
        """计算订单总金额"""
        return sum(item.total_price for item in self.items)
    
    def update_status(self, new_status: OrderStatus):
        """更新订单状态"""
        self.status = new_status
        self.updated_at = datetime.now()
    
    def add_item(self, item: OrderItem):
        """添加订单项"""
        self.items.append(item)
        self.updated_at = datetime.now()

@dataclass
class Payment:
    """支付实体"""
    id: str
    order_id: str
    amount: float
    method: str
    status: PaymentStatus
    created_at: datetime
    
    def process_payment(self) -> bool:
        """处理支付"""
        # 模拟支付处理
        if self.amount > 0:
            self.status = PaymentStatus.COMPLETED
            return True
        else:
            self.status = PaymentStatus.FAILED
            return False

class ECommerceSystem:
    """电商系统"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.products: Dict[str, Product] = {}
        self.orders: Dict[str, Order] = {}
        self.payments: Dict[str, Payment] = {}
    
    def register_user(self, name: str, email: str, phone: str = None) -> User:
        """注册用户"""
        user_id = f"user_{len(self.users) + 1}"
        user = User(id=user_id, name=name, email=email, phone=phone)
        self.users[user_id] = user
        return user
    
    def add_product(self, name: str, price: float, description: str, category: str, stock: int) -> Product:
        """添加商品"""
        product_id = f"product_{len(self.products) + 1}"
        product = Product(
            id=product_id,
            name=name,
            price=price,
            description=description,
            category=category,
            stock=stock
        )
        self.products[product_id] = product
        return product
    
    def create_order(self, user_id: str, items: List[Dict[str, Any]]) -> Order:
        """创建订单"""
        order_id = f"order_{len(self.orders) + 1}"
        
        # 创建订单项
        order_items = []
        for item_data in items:
            product_id = item_data["product_id"]
            quantity = item_data["quantity"]
            
            if product_id in self.products:
                product = self.products[product_id]
                if product.is_available() and product.stock >= quantity:
                    order_item = OrderItem(
                        product_id=product_id,
                        quantity=quantity,
                        unit_price=product.price
                    )
                    order_items.append(order_item)
                    product.update_stock(-quantity)
        
        if not order_items:
            raise ValueError("No valid items in order")
        
        order = Order(
            id=order_id,
            user_id=user_id,
            items=order_items,
            status=OrderStatus.PENDING,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        self.orders[order_id] = order
        return order
    
    def process_payment(self, order_id: str, payment_method: str) -> Payment:
        """处理支付"""
        if order_id not in self.orders:
            raise ValueError("Order not found")
        
        order = self.orders[order_id]
        payment_id = f"payment_{len(self.payments) + 1}"
        
        payment = Payment(
            id=payment_id,
            order_id=order_id,
            amount=order.total_amount,
            method=payment_method,
            status=PaymentStatus.PENDING,
            created_at=datetime.now()
        )
        
        if payment.process_payment():
            order.update_status(OrderStatus.CONFIRMED)
        
        self.payments[payment_id] = payment
        return payment
    
    def get_user_orders(self, user_id: str) -> List[Order]:
        """获取用户订单"""
        return [order for order in self.orders.values() if order.user_id == user_id]
    
    def get_system_statistics(self) -> Dict[str, Any]:
        """获取系统统计"""
        return {
            "total_users": len(self.users),
            "total_products": len(self.products),
            "total_orders": len(self.orders),
            "total_payments": len(self.payments),
            "total_revenue": sum(payment.amount for payment in self.payments.values() 
                               if payment.status == PaymentStatus.COMPLETED)
        }

# 使用示例
def demonstrate_ecommerce_modeling():
    """演示电商系统建模"""
    system = ECommerceSystem()
    
    # 注册用户
    user = system.register_user("John Doe", "john@example.com", "123-456-7890")
    print(f"注册用户: {user.name}")
    
    # 添加商品
    product1 = system.add_product("Laptop", 999.99, "High-performance laptop", "Electronics", 10)
    product2 = system.add_product("Mouse", 29.99, "Wireless mouse", "Electronics", 50)
    print(f"添加商品: {product1.name}, {product2.name}")
    
    # 创建订单
    order = system.create_order(user.id, [
        {"product_id": product1.id, "quantity": 1},
        {"product_id": product2.id, "quantity": 2}
    ])
    print(f"创建订单: {order.id}, 总金额: ${order.total_amount:.2f}")
    
    # 处理支付
    payment = system.process_payment(order.id, "credit_card")
    print(f"支付状态: {payment.status.value}")
    
    # 获取统计信息
    stats = system.get_system_statistics()
    print(f"系统统计: {stats}")

if __name__ == "__main__":
    demonstrate_ecommerce_modeling()
```

---

## 9. 总结

### 9.1 核心观点

1. **抽象**是从具体事物中提取共同特征的过程
2. **建模**是创建系统简化表示的过程
3. **抽象与建模**相互支持，共同构成软件工程的基础
4. **层次化抽象**是处理复杂系统的有效方法

### 9.2 实践意义

1. **简化复杂性**: 通过抽象简化复杂系统
2. **提高理解**: 通过建模提高系统理解
3. **支持设计**: 为软件设计提供理论基础
4. **促进沟通**: 通过模型促进团队沟通

### 9.3 发展前景

1. **智能化建模**: 结合AI技术的自动建模
2. **可视化抽象**: 通过可视化工具辅助抽象
3. **领域特定建模**: 针对特定领域的建模语言
4. **模型驱动开发**: 基于模型的软件开发

---

**参考文献**:

1. Abrial, J. R. (1996). The B-Book: Assigning Programs to Meanings
2. Harel, D. (1987). Statecharts: A Visual Formalism for Complex Systems
3. Rumbaugh, J., et al. (1991). Object-Oriented Modeling and Design
4. Fowler, M. (2003). UML Distilled: A Brief Guide to the Standard Object Modeling Language

**相关链接**:

- [00-01-软件工程哲学](./00-01-软件工程哲学.md)
- [00-02-计算思维](./00-02-计算思维.md)
- [01-01-数学基础](../01-形式科学/01-01-数学基础.md)
- [05-01-软件架构基础](../05-架构领域/05-01-软件架构基础.md)
