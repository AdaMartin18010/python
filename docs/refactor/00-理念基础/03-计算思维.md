# 00.3 è®¡ç®—æ€ç»´

## ğŸ“‹ æ¦‚è¿°

è®¡ç®—æ€ç»´æ˜¯è§£å†³å¤æ‚é—®é¢˜çš„ç³»ç»Ÿæ€§æ€ç»´æ–¹æ³•ï¼Œæ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„æ ¸å¿ƒåŸºç¡€ã€‚æœ¬ç« èŠ‚ä»å½¢å¼åŒ–è§’åº¦åˆ†æè®¡ç®—æ€ç»´çš„æœ¬è´¨ã€æ–¹æ³•å’Œåº”ç”¨ï¼Œå»ºç«‹å®Œæ•´çš„è®¡ç®—æ€ç»´ç†è®ºä½“ç³»ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¡ç®—æ€ç»´çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 è®¡ç®—æ€ç»´åŸºç¡€å®šä¹‰

**å®šä¹‰ 1.1.1** è®¡ç®—æ€ç»´ $\mathcal{CT}$ æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š

$$\mathcal{CT} = (D, P, A, E, V)$$

å…¶ä¸­ï¼š
- $D$ æ˜¯åˆ†è§£ (Decomposition)
- $P$ æ˜¯æ¨¡å¼è¯†åˆ« (Pattern Recognition)
- $A$ æ˜¯æŠ½è±¡ (Abstraction)
- $E$ æ˜¯ç®—æ³•è®¾è®¡ (Algorithm Design)
- $V$ æ˜¯éªŒè¯ (Verification)

**å®šä¹‰ 1.1.2** è®¡ç®—æ€ç»´è¿‡ç¨‹ $\mathcal{CTP}$ å®šä¹‰ä¸ºï¼š

$$\mathcal{CTP}: \mathcal{P} \rightarrow \mathcal{S}$$

å…¶ä¸­ $\mathcal{P}$ æ˜¯é—®é¢˜ç©ºé—´ï¼Œ$\mathcal{S}$ æ˜¯è§£å†³æ–¹æ¡ˆç©ºé—´ã€‚

#### 1.2 è®¡ç®—æ€ç»´èƒ½åŠ›æ¨¡å‹

**å®šä¹‰ 1.2.1** è®¡ç®—æ€ç»´èƒ½åŠ›å‡½æ•° $CT: \mathcal{P} \times \mathcal{K} \rightarrow \mathcal{S}$ï¼š

$$CT(p, k) = V(E(A(P(D(p)))), k)$$

å…¶ä¸­ $k$ æ˜¯çŸ¥è¯†åº“ã€‚

**Python å®ç°**ï¼š

```python
from typing import Any, List, Dict, Callable, TypeVar, Generic
from dataclasses import dataclass
from abc import ABC, abstractmethod
import time

P = TypeVar('P')  # Problem
S = TypeVar('S')  # Solution
K = TypeVar('K')  # Knowledge

@dataclass
class Problem:
    """é—®é¢˜å®šä¹‰"""
    description: str
    constraints: List[str]
    objectives: List[str]
    complexity: float

@dataclass
class Solution:
    """è§£å†³æ–¹æ¡ˆ"""
    algorithm: str
    implementation: Callable
    complexity: str
    correctness: float

@dataclass
class Knowledge:
    """çŸ¥è¯†åº“"""
    patterns: Dict[str, Any]
    algorithms: Dict[str, Callable]
    heuristics: Dict[str, Callable]

class ComputationalThinking(Generic[P, S, K]):
    """è®¡ç®—æ€ç»´æ¡†æ¶"""
    
    def __init__(self, knowledge: K):
        self.knowledge = knowledge
        self.decomposition_strategies = []
        self.pattern_recognition_methods = []
        self.abstraction_techniques = []
        self.algorithm_design_methods = []
        self.verification_methods = []
    
    def solve(self, problem: P) -> S:
        """è§£å†³é—®é¢˜çš„å®Œæ•´è®¡ç®—æ€ç»´è¿‡ç¨‹"""
        start_time = time.time()
        
        # 1. åˆ†è§£ (Decomposition)
        subproblems = self.decompose(problem)
        print(f"åˆ†è§£ç»“æœ: {len(subproblems)} ä¸ªå­é—®é¢˜")
        
        # 2. æ¨¡å¼è¯†åˆ« (Pattern Recognition)
        patterns = self.recognize_patterns(subproblems)
        print(f"è¯†åˆ«æ¨¡å¼: {len(patterns)} ä¸ªæ¨¡å¼")
        
        # 3. æŠ½è±¡ (Abstraction)
        abstract_model = self.abstract(patterns)
        print(f"æŠ½è±¡æ¨¡å‹: {type(abstract_model).__name__}")
        
        # 4. ç®—æ³•è®¾è®¡ (Algorithm Design)
        algorithm = self.design_algorithm(abstract_model)
        print(f"ç®—æ³•è®¾è®¡: {algorithm}")
        
        # 5. éªŒè¯ (Verification)
        solution = self.verify(algorithm, problem)
        
        end_time = time.time()
        print(f"è§£å†³æ—¶é—´: {end_time - start_time:.2f} ç§’")
        
        return solution
    
    def decompose(self, problem: P) -> List[P]:
        """åˆ†è§£é—®é¢˜"""
        strategies = self.get_decomposition_strategies(problem)
        best_strategy = self.select_best_strategy(strategies, problem)
        return best_strategy(problem)
    
    def recognize_patterns(self, subproblems: List[P]) -> List[str]:
        """è¯†åˆ«æ¨¡å¼"""
        patterns = []
        for subproblem in subproblems:
            pattern = self.find_best_pattern(subproblem)
            patterns.append(pattern)
        return patterns
    
    def abstract(self, patterns: List[str]) -> Any:
        """æŠ½è±¡å»ºæ¨¡"""
        # æ ¹æ®æ¨¡å¼åˆ›å»ºæŠ½è±¡æ¨¡å‹
        model = self.create_abstract_model(patterns)
        return model
    
    def design_algorithm(self, abstract_model: Any) -> str:
        """è®¾è®¡ç®—æ³•"""
        # æ ¹æ®æŠ½è±¡æ¨¡å‹è®¾è®¡ç®—æ³•
        algorithm = self.select_algorithm(abstract_model)
        return algorithm
    
    def verify(self, algorithm: str, original_problem: P) -> S:
        """éªŒè¯è§£å†³æ–¹æ¡ˆ"""
        # éªŒè¯ç®—æ³•çš„æ­£ç¡®æ€§å’Œæ•ˆç‡
        solution = self.create_solution(algorithm, original_problem)
        self.validate_solution(solution, original_problem)
        return solution
    
    def get_decomposition_strategies(self, problem: P) -> List[Callable]:
        """è·å–åˆ†è§£ç­–ç•¥"""
        return [
            self.divide_by_functionality,
            self.divide_by_data,
            self.divide_by_complexity,
            self.divide_by_dependency
        ]
    
    def select_best_strategy(self, strategies: List[Callable], problem: P) -> Callable:
        """é€‰æ‹©æœ€ä½³ç­–ç•¥"""
        # æ ¹æ®é—®é¢˜ç‰¹å¾é€‰æ‹©æœ€ä½³åˆ†è§£ç­–ç•¥
        return strategies[0]  # ç®€åŒ–å®ç°
    
    def divide_by_functionality(self, problem: P) -> List[P]:
        """æŒ‰åŠŸèƒ½åˆ†è§£"""
        # å®ç°æŒ‰åŠŸèƒ½åˆ†è§£çš„é€»è¾‘
        return [problem]  # ç®€åŒ–å®ç°
    
    def divide_by_data(self, problem: P) -> List[P]:
        """æŒ‰æ•°æ®åˆ†è§£"""
        # å®ç°æŒ‰æ•°æ®åˆ†è§£çš„é€»è¾‘
        return [problem]  # ç®€åŒ–å®ç°
    
    def divide_by_complexity(self, problem: P) -> List[P]:
        """æŒ‰å¤æ‚åº¦åˆ†è§£"""
        # å®ç°æŒ‰å¤æ‚åº¦åˆ†è§£çš„é€»è¾‘
        return [problem]  # ç®€åŒ–å®ç°
    
    def divide_by_dependency(self, problem: P) -> List[P]:
        """æŒ‰ä¾èµ–å…³ç³»åˆ†è§£"""
        # å®ç°æŒ‰ä¾èµ–å…³ç³»åˆ†è§£çš„é€»è¾‘
        return [problem]  # ç®€åŒ–å®ç°
    
    def find_best_pattern(self, subproblem: P) -> str:
        """æ‰¾åˆ°æœ€ä½³æ¨¡å¼"""
        # å®ç°æ¨¡å¼åŒ¹é…é€»è¾‘
        return "generic_pattern"
    
    def create_abstract_model(self, patterns: List[str]) -> Any:
        """åˆ›å»ºæŠ½è±¡æ¨¡å‹"""
        # æ ¹æ®æ¨¡å¼åˆ›å»ºæŠ½è±¡æ¨¡å‹
        return {"patterns": patterns, "model_type": "abstract"}
    
    def select_algorithm(self, abstract_model: Any) -> str:
        """é€‰æ‹©ç®—æ³•"""
        # æ ¹æ®æŠ½è±¡æ¨¡å‹é€‰æ‹©ç®—æ³•
        return "generic_algorithm"
    
    def create_solution(self, algorithm: str, problem: P) -> S:
        """åˆ›å»ºè§£å†³æ–¹æ¡ˆ"""
        # æ ¹æ®ç®—æ³•åˆ›å»ºè§£å†³æ–¹æ¡ˆ
        return Solution(
            algorithm=algorithm,
            implementation=lambda x: x,
            complexity="O(n)",
            correctness=0.9
        )
    
    def validate_solution(self, solution: S, problem: P):
        """éªŒè¯è§£å†³æ–¹æ¡ˆ"""
        # éªŒè¯è§£å†³æ–¹æ¡ˆçš„æ­£ç¡®æ€§
        if solution.correctness < 0.8:
            raise ValueError("è§£å†³æ–¹æ¡ˆæ­£ç¡®æ€§ä¸è¶³")

# å…·ä½“å®ç°ç¤ºä¾‹
class SoftwareDesignThinking(ComputationalThinking[Problem, Solution, Knowledge]):
    """è½¯ä»¶è®¾è®¡è®¡ç®—æ€ç»´"""
    
    def decompose(self, problem: Problem) -> List[Problem]:
        """è½¯ä»¶è®¾è®¡é—®é¢˜åˆ†è§£"""
        if "ç³»ç»Ÿ" in problem.description:
            return self.decompose_system(problem)
        elif "ç®—æ³•" in problem.description:
            return self.decompose_algorithm(problem)
        else:
            return self.decompose_general(problem)
    
    def decompose_system(self, problem: Problem) -> List[Problem]:
        """åˆ†è§£ç³»ç»Ÿè®¾è®¡é—®é¢˜"""
        subproblems = []
        
        # æŒ‰å±‚æ¬¡åˆ†è§£
        layers = ["è¡¨ç¤ºå±‚", "ä¸šåŠ¡å±‚", "æ•°æ®å±‚"]
        for layer in layers:
            subproblem = Problem(
                description=f"{problem.description} - {layer}",
                constraints=problem.constraints,
                objectives=problem.objectives,
                complexity=problem.complexity / len(layers)
            )
            subproblems.append(subproblem)
        
        return subproblems
    
    def decompose_algorithm(self, problem: Problem) -> List[Problem]:
        """åˆ†è§£ç®—æ³•è®¾è®¡é—®é¢˜"""
        subproblems = []
        
        # æŒ‰æ­¥éª¤åˆ†è§£
        steps = ["è¾“å…¥å¤„ç†", "æ ¸å¿ƒè®¡ç®—", "è¾“å‡ºå¤„ç†"]
        for step in steps:
            subproblem = Problem(
                description=f"{problem.description} - {step}",
                constraints=problem.constraints,
                objectives=problem.objectives,
                complexity=problem.complexity / len(steps)
            )
            subproblems.append(subproblem)
        
        return subproblems
    
    def decompose_general(self, problem: Problem) -> List[Problem]:
        """é€šç”¨åˆ†è§£æ–¹æ³•"""
        return [problem]

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.1 è®¤çŸ¥ç§‘å­¦ä¸æ€ç»´æ¨¡å¼](./01-è®¤çŸ¥ç§‘å­¦ä¸æ€ç»´æ¨¡å¼.md)
- [00.2 è½¯ä»¶å·¥ç¨‹å“²å­¦](./02-è½¯ä»¶å·¥ç¨‹å“²å­¦.md)
- [01.1 æ•°å­¦åŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-æ•°å­¦åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Wing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35.
2. Denning, P. J. (2009). The profession of IT: Beyond computational thinking. Communications of the ACM, 52(6), 28-30.
3. Aho, A. V. (2012). Computation and computational thinking. The Computer Journal, 55(7), 832-835.

---

**ä¸‹ä¸€èŠ‚**: [01.1 æ•°å­¦åŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-æ•°å­¦åŸºç¡€.md) 