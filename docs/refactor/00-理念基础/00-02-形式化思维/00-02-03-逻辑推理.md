# é€»è¾‘æ¨ç†

## ğŸ“‹ æ¦‚è¿°

é€»è¾‘æ¨ç†æ˜¯å½¢å¼åŒ–æ€ç»´çš„æ ¸å¿ƒï¼Œé€šè¿‡ä¸¥æ ¼çš„æ¨ç†è§„åˆ™ä»å·²çŸ¥å‰ææ¨å¯¼å‡ºç»“è®ºã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰é€»è¾‘æ¨ç†çš„ç†è®ºæ¡†æ¶ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 é€»è¾‘æ¨ç†çš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.1** (é€»è¾‘æ¨ç†)
é€»è¾‘æ¨ç†æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(P, R, C)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯å‰æé›†åˆ (Premises)
- $R$ æ˜¯æ¨ç†è§„åˆ™é›†åˆ (Rules)
- $C$ æ˜¯ç»“è®ºé›†åˆ (Conclusions)

**å®šä¹‰ 1.2** (æ¨ç†è§„åˆ™)
æ¨ç†è§„åˆ™ $r$ æ˜¯ä¸€ä¸ªæ˜ å°„ $r: 2^P \rightarrow 2^C$ï¼Œæ»¡è¶³ï¼š

1. **æœ‰æ•ˆæ€§**: å¦‚æœå‰æä¸ºçœŸï¼Œåˆ™ç»“è®ºä¸ºçœŸ
2. **å¯é æ€§**: æ¨ç†è¿‡ç¨‹ä¸å¼•å…¥çŸ›ç›¾
3. **å®Œå¤‡æ€§**: æ‰€æœ‰æœ‰æ•ˆç»“è®ºéƒ½å¯ä»¥é€šè¿‡æ¨ç†å¾—åˆ°

**å®šä¹‰ 1.3** (æ¨ç†è¿‡ç¨‹)
æ¨ç†è¿‡ç¨‹æ˜¯ä¸€ä¸ªåºåˆ— $\langle p_1, p_2, \ldots, p_n \rangle$ï¼Œå…¶ä¸­ï¼š

- $p_1 \in P$ æ˜¯åˆå§‹å‰æ
- $p_{i+1}$ æ˜¯é€šè¿‡æ¨ç†è§„åˆ™ä» $\{p_1, p_2, \ldots, p_i\}$ æ¨å¯¼å‡ºçš„æ–°å‘½é¢˜

### 1.2 æ¨ç†ç±»å‹

**å®šä¹‰ 1.4** (æ¼”ç»æ¨ç†)
æ¼”ç»æ¨ç†æ˜¯ä»ä¸€èˆ¬åˆ°ç‰¹æ®Šçš„æ¨ç†ï¼Œå¦‚æœå‰æä¸ºçœŸï¼Œåˆ™ç»“è®ºå¿…ç„¶ä¸ºçœŸã€‚

**å®šä¹‰ 1.5** (å½’çº³æ¨ç†)
å½’çº³æ¨ç†æ˜¯ä»ç‰¹æ®Šåˆ°ä¸€èˆ¬çš„æ¨ç†ï¼Œå‰ææ”¯æŒç»“è®ºä½†ä¸ä¿è¯ç»“è®ºä¸ºçœŸã€‚

**å®šä¹‰ 1.6** (ç±»æ¯”æ¨ç†)
ç±»æ¯”æ¨ç†æ˜¯åŸºäºç›¸ä¼¼æ€§çš„æ¨ç†ï¼Œé€šè¿‡å·²çŸ¥äº‹ç‰©çš„æ€§è´¨æ¨æ–­æœªçŸ¥äº‹ç‰©çš„æ€§è´¨ã€‚

## 2. æ¨ç†è§„åˆ™ç³»ç»Ÿ

### 2.1 åŸºæœ¬æ¨ç†è§„åˆ™

**è§„åˆ™ 2.1** (å‡è¨€æ¨ç† - Modus Ponens)
å¦‚æœ $p \rightarrow q$ ä¸” $p$ ä¸ºçœŸï¼Œåˆ™ $q$ ä¸ºçœŸã€‚

**è§„åˆ™ 2.2** (å‡è¨€æ¨ç†å¦å®š - Modus Tollens)
å¦‚æœ $p \rightarrow q$ ä¸” $\neg q$ ä¸ºçœŸï¼Œåˆ™ $\neg p$ ä¸ºçœŸã€‚

**è§„åˆ™ 2.3** (å‡è¨€ä¸‰æ®µè®º)
å¦‚æœ $p \rightarrow q$ ä¸” $q \rightarrow r$ï¼Œåˆ™ $p \rightarrow r$ã€‚

**è§„åˆ™ 2.4** (æå–ä¸‰æ®µè®º)
å¦‚æœ $p \vee q$ ä¸” $\neg p$ï¼Œåˆ™ $q$ã€‚

**è§„åˆ™ 2.5** (æ„é€ æ€§äºŒéš¾æ¨ç†)
å¦‚æœ $p \rightarrow q$ ä¸” $r \rightarrow s$ ä¸” $p \vee r$ï¼Œåˆ™ $q \vee s$ã€‚

### 2.2 æ¨ç†è§„åˆ™çš„å½¢å¼åŒ–

**å®šç† 2.1** (æ¨ç†è§„åˆ™æœ‰æ•ˆæ€§)
æ‰€æœ‰åŸºæœ¬æ¨ç†è§„åˆ™éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œå³å¦‚æœå‰æä¸ºçœŸï¼Œåˆ™ç»“è®ºä¸ºçœŸã€‚

**è¯æ˜**:
ä»¥å‡è¨€æ¨ç†ä¸ºä¾‹ï¼š
è®¾ $p \rightarrow q$ å’Œ $p$ éƒ½ä¸ºçœŸã€‚
æ ¹æ®è•´å«çš„å®šä¹‰ï¼Œ$p \rightarrow q$ ç­‰ä»·äº $\neg p \vee q$ã€‚
ç”±äº $p$ ä¸ºçœŸï¼Œ$\neg p$ ä¸ºå‡ï¼Œå› æ­¤ $q$ å¿…é¡»ä¸ºçœŸã€‚
å…¶ä»–è§„åˆ™ç±»ä¼¼å¯è¯ã€‚$\square$

## 3. Pythonå®ç°

### 3.1 åŸºç¡€ç±»å®šä¹‰

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Optional, Union
from dataclasses import dataclass
from enum import Enum
import re
from collections import defaultdict

class PropositionType(Enum):
    """å‘½é¢˜ç±»å‹æšä¸¾"""
    ATOMIC = "atomic"           # åŸå­å‘½é¢˜
    NEGATION = "negation"       # å¦å®š
    CONJUNCTION = "conjunction" # åˆå–
    DISJUNCTION = "disjunction" # æå–
    IMPLICATION = "implication" # è•´å«
    EQUIVALENCE = "equivalence" # ç­‰ä»·

@dataclass
class Proposition:
    """å‘½é¢˜ç±»"""
    content: str
    proposition_type: PropositionType
    sub_propositions: List['Proposition'] = None
    truth_value: Optional[bool] = None
    
    def __post_init__(self):
        if self.sub_propositions is None:
            self.sub_propositions = []
    
    def __str__(self):
        if self.proposition_type == PropositionType.ATOMIC:
            return self.content
        elif self.proposition_type == PropositionType.NEGATION:
            return f"Â¬({self.sub_propositions[0]})"
        elif self.proposition_type == PropositionType.CONJUNCTION:
            return f"({self.sub_propositions[0]} âˆ§ {self.sub_propositions[1]})"
        elif self.proposition_type == PropositionType.DISJUNCTION:
            return f"({self.sub_propositions[0]} âˆ¨ {self.sub_propositions[1]})"
        elif self.proposition_type == PropositionType.IMPLICATION:
            return f"({self.sub_propositions[0]} â†’ {self.sub_propositions[1]})"
        elif self.proposition_type == PropositionType.EQUIVALENCE:
            return f"({self.sub_propositions[0]} â†” {self.sub_propositions[1]})"
        return self.content

class InferenceRule(ABC):
    """æ¨ç†è§„åˆ™æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
    
    @abstractmethod
    def can_apply(self, premises: List[Proposition]) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥åº”ç”¨æ­¤è§„åˆ™"""
        pass
    
    @abstractmethod
    def apply(self, premises: List[Proposition]) -> List[Proposition]:
        """åº”ç”¨æ¨ç†è§„åˆ™"""
        pass
    
    def __str__(self):
        return self.name

class ModusPonens(InferenceRule):
    """å‡è¨€æ¨ç†è§„åˆ™"""
    
    def __init__(self):
        super().__init__("Modus Ponens")
    
    def can_apply(self, premises: List[Proposition]) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥åº”ç”¨å‡è¨€æ¨ç†"""
        if len(premises) < 2:
            return False
        
        # å¯»æ‰¾å½¢å¦‚ p â†’ q å’Œ p çš„å‰æ
        implications = []
        atoms = []
        
        for premise in premises:
            if premise.proposition_type == PropositionType.IMPLICATION:
                implications.append(premise)
            elif premise.proposition_type == PropositionType.ATOMIC:
                atoms.append(premise)
        
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒ¹é…çš„è•´å«å’ŒåŸå­å‘½é¢˜
        for imp in implications:
            antecedent = imp.sub_propositions[0]
            for atom in atoms:
                if str(antecedent) == str(atom):
                    return True
        
        return False
    
    def apply(self, premises: List[Proposition]) -> List[Proposition]:
        """åº”ç”¨å‡è¨€æ¨ç†"""
        conclusions = []
        
        implications = []
        atoms = []
        
        for premise in premises:
            if premise.proposition_type == PropositionType.IMPLICATION:
                implications.append(premise)
            elif premise.proposition_type == PropositionType.ATOMIC:
                atoms.append(premise)
        
        for imp in implications:
            antecedent = imp.sub_propositions[0]
            consequent = imp.sub_propositions[1]
            
            for atom in atoms:
                if str(antecedent) == str(atom):
                    # åˆ›å»ºç»“è®ºå‘½é¢˜
                    conclusion = Proposition(
                        content=f"ç”± {imp} å’Œ {atom} æ¨å‡º {consequent}",
                        proposition_type=PropositionType.ATOMIC,
                        truth_value=True
                    )
                    conclusions.append(conclusion)
        
        return conclusions

class ModusTollens(InferenceRule):
    """å‡è¨€æ¨ç†å¦å®šè§„åˆ™"""
    
    def __init__(self):
        super().__init__("Modus Tollens")
    
    def can_apply(self, premises: List[Proposition]) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥åº”ç”¨å‡è¨€æ¨ç†å¦å®š"""
        if len(premises) < 2:
            return False
        
        implications = []
        negations = []
        
        for premise in premises:
            if premise.proposition_type == PropositionType.IMPLICATION:
                implications.append(premise)
            elif (premise.proposition_type == PropositionType.NEGATION and 
                  premise.sub_propositions[0].proposition_type == PropositionType.ATOMIC):
                negations.append(premise)
        
        for imp in implications:
            consequent = imp.sub_propositions[1]
            for neg in negations:
                if str(consequent) == str(neg.sub_propositions[0]):
                    return True
        
        return False
    
    def apply(self, premises: List[Proposition]) -> List[Proposition]:
        """åº”ç”¨å‡è¨€æ¨ç†å¦å®š"""
        conclusions = []
        
        implications = []
        negations = []
        
        for premise in premises:
            if premise.proposition_type == PropositionType.IMPLICATION:
                implications.append(premise)
            elif (premise.proposition_type == PropositionType.NEGATION and 
                  premise.sub_propositions[0].proposition_type == PropositionType.ATOMIC):
                negations.append(premise)
        
        for imp in implications:
            antecedent = imp.sub_propositions[0]
            consequent = imp.sub_propositions[1]
            
            for neg in negations:
                if str(consequent) == str(neg.sub_propositions[0]):
                    # åˆ›å»ºå¦å®šå‰ä»¶çš„ç»“è®º
                    neg_antecedent = Proposition(
                        content=f"Â¬{antecedent}",
                        proposition_type=PropositionType.NEGATION,
                        sub_propositions=[antecedent],
                        truth_value=True
                    )
                    conclusion = Proposition(
                        content=f"ç”± {imp} å’Œ {neg} æ¨å‡º {neg_antecedent}",
                        proposition_type=PropositionType.ATOMIC,
                        truth_value=True
                    )
                    conclusions.append(conclusion)
        
        return conclusions

class HypotheticalSyllogism(InferenceRule):
    """å‡è¨€ä¸‰æ®µè®ºè§„åˆ™"""
    
    def __init__(self):
        super().__init__("Hypothetical Syllogism")
    
    def can_apply(self, premises: List[Proposition]) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥åº”ç”¨å‡è¨€ä¸‰æ®µè®º"""
        implications = [p for p in premises if p.proposition_type == PropositionType.IMPLICATION]
        return len(implications) >= 2
    
    def apply(self, premises: List[Proposition]) -> List[Proposition]:
        """åº”ç”¨å‡è¨€ä¸‰æ®µè®º"""
        conclusions = []
        implications = [p for p in premises if p.proposition_type == PropositionType.IMPLICATION]
        
        for i, imp1 in enumerate(implications):
            for j, imp2 in enumerate(implications):
                if i != j:
                    # æ£€æŸ¥ p â†’ q å’Œ q â†’ r çš„å½¢å¼
                    consequent1 = imp1.sub_propositions[1]
                    antecedent2 = imp2.sub_propositions[0]
                    
                    if str(consequent1) == str(antecedent2):
                        antecedent1 = imp1.sub_propositions[0]
                        consequent2 = imp2.sub_propositions[1]
                        
                        # åˆ›å»º p â†’ r çš„ç»“è®º
                        new_implication = Proposition(
                            content=f"{antecedent1} â†’ {consequent2}",
                            proposition_type=PropositionType.IMPLICATION,
                            sub_propositions=[antecedent1, consequent2],
                            truth_value=True
                        )
                        conclusion = Proposition(
                            content=f"ç”± {imp1} å’Œ {imp2} æ¨å‡º {new_implication}",
                            proposition_type=PropositionType.ATOMIC,
                            truth_value=True
                        )
                        conclusions.append(conclusion)
        
        return conclusions

class DisjunctiveSyllogism(InferenceRule):
    """æå–ä¸‰æ®µè®ºè§„åˆ™"""
    
    def __init__(self):
        super().__init__("Disjunctive Syllogism")
    
    def can_apply(self, premises: List[Proposition]) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥åº”ç”¨æå–ä¸‰æ®µè®º"""
        disjunctions = []
        negations = []
        
        for premise in premises:
            if premise.proposition_type == PropositionType.DISJUNCTION:
                disjunctions.append(premise)
            elif premise.proposition_type == PropositionType.NEGATION:
                negations.append(premise)
        
        return len(disjunctions) > 0 and len(negations) > 0
    
    def apply(self, premises: List[Proposition]) -> List[Proposition]:
        """åº”ç”¨æå–ä¸‰æ®µè®º"""
        conclusions = []
        
        disjunctions = [p for p in premises if p.proposition_type == PropositionType.DISJUNCTION]
        negations = [p for p in premises if p.proposition_type == PropositionType.NEGATION]
        
        for disj in disjunctions:
            left = disj.sub_propositions[0]
            right = disj.sub_propositions[1]
            
            for neg in negations:
                negated_prop = neg.sub_propositions[0]
                
                # æ£€æŸ¥æ˜¯å¦å¦å®šå·¦é¡¹
                if str(left) == str(negated_prop):
                    conclusion = Proposition(
                        content=f"ç”± {disj} å’Œ {neg} æ¨å‡º {right}",
                        proposition_type=PropositionType.ATOMIC,
                        truth_value=True
                    )
                    conclusions.append(conclusion)
                
                # æ£€æŸ¥æ˜¯å¦å¦å®šå³é¡¹
                elif str(right) == str(negated_prop):
                    conclusion = Proposition(
                        content=f"ç”± {disj} å’Œ {neg} æ¨å‡º {left}",
                        proposition_type=PropositionType.ATOMIC,
                        truth_value=True
                    )
                    conclusions.append(conclusion)
        
        return conclusions

class PropositionParser:
    """å‘½é¢˜è§£æå™¨"""
    
    def __init__(self):
        self.operators = {
            'Â¬': PropositionType.NEGATION,
            'âˆ§': PropositionType.CONJUNCTION,
            'âˆ¨': PropositionType.DISJUNCTION,
            'â†’': PropositionType.IMPLICATION,
            'â†”': PropositionType.EQUIVALENCE
        }
    
    def parse(self, expression: str) -> Proposition:
        """è§£æå‘½é¢˜è¡¨è¾¾å¼"""
        expression = expression.strip()
        
        # å¤„ç†åŸå­å‘½é¢˜
        if expression not in self.operators and not any(op in expression for op in self.operators):
            return Proposition(expression, PropositionType.ATOMIC)
        
        # å¤„ç†å¦å®š
        if expression.startswith('Â¬'):
            sub_prop = self.parse(expression[1:])
            return Proposition(
                f"Â¬{sub_prop}",
                PropositionType.NEGATION,
                [sub_prop]
            )
        
        # å¤„ç†äºŒå…ƒè¿ç®—ç¬¦
        for op, prop_type in self.operators.items():
            if op in expression and prop_type != PropositionType.NEGATION:
                # æ‰¾åˆ°æœ€å¤–å±‚çš„è¿ç®—ç¬¦
                count = 0
                for i, char in enumerate(expression):
                    if char == '(':
                        count += 1
                    elif char == ')':
                        count -= 1
                    elif char == op and count == 0:
                        left_expr = expression[:i].strip()
                        right_expr = expression[i+1:].strip()
                        
                        left_prop = self.parse(left_expr)
                        right_prop = self.parse(right_expr)
                        
                        return Proposition(
                            f"{left_prop} {op} {right_prop}",
                            prop_type,
                            [left_prop, right_prop]
                        )
        
        # å¤„ç†æ‹¬å·
        if expression.startswith('(') and expression.endswith(')'):
            return self.parse(expression[1:-1])
        
        raise ValueError(f"æ— æ³•è§£æè¡¨è¾¾å¼: {expression}")

class LogicalReasoner:
    """é€»è¾‘æ¨ç†å™¨"""
    
    def __init__(self):
        self.rules = [
            ModusPonens(),
            ModusTollens(),
            HypotheticalSyllogism(),
            DisjunctiveSyllogism()
        ]
        self.parser = PropositionParser()
    
    def add_rule(self, rule: InferenceRule):
        """æ·»åŠ æ¨ç†è§„åˆ™"""
        self.rules.append(rule)
    
    def reason(self, premises: List[str], max_steps: int = 100) -> Dict[str, Any]:
        """æ‰§è¡Œé€»è¾‘æ¨ç†"""
        # è§£æå‰æ
        parsed_premises = []
        for premise in premises:
            try:
                parsed_premises.append(self.parser.parse(premise))
            except ValueError as e:
                print(f"è§£æå‰æå¤±è´¥: {premise}, é”™è¯¯: {e}")
                return {"error": f"è§£æå¤±è´¥: {e}"}
        
        # æ¨ç†è¿‡ç¨‹
        current_premises = parsed_premises.copy()
        conclusions = []
        reasoning_steps = []
        step_count = 0
        
        while step_count < max_steps:
            new_conclusions = []
            
            for rule in self.rules:
                if rule.can_apply(current_premises):
                    rule_conclusions = rule.apply(current_premises)
                    new_conclusions.extend(rule_conclusions)
                    
                    # è®°å½•æ¨ç†æ­¥éª¤
                    for conclusion in rule_conclusions:
                        reasoning_steps.append({
                            'step': step_count + 1,
                            'rule': rule.name,
                            'premises': [str(p) for p in current_premises],
                            'conclusion': str(conclusion)
                        })
            
            if not new_conclusions:
                break
            
            # æ·»åŠ æ–°ç»“è®ºåˆ°å‰æé›†åˆ
            current_premises.extend(new_conclusions)
            conclusions.extend(new_conclusions)
            step_count += 1
        
        return {
            'premises': [str(p) for p in parsed_premises],
            'conclusions': [str(c) for c in conclusions],
            'reasoning_steps': reasoning_steps,
            'total_steps': step_count,
            'final_premises': [str(p) for p in current_premises]
        }
    
    def validate_argument(self, premises: List[str], conclusion: str) -> Dict[str, Any]:
        """éªŒè¯è®ºè¯çš„æœ‰æ•ˆæ€§"""
        reasoning_result = self.reason(premises)
        
        if 'error' in reasoning_result:
            return reasoning_result
        
        # æ£€æŸ¥ç»“è®ºæ˜¯å¦å¯ä»¥ä»å‰ææ¨å¯¼å‡º
        parsed_conclusion = self.parser.parse(conclusion)
        conclusion_str = str(parsed_conclusion)
        
        is_valid = conclusion_str in reasoning_result['conclusions']
        
        return {
            'is_valid': is_valid,
            'premises': premises,
            'conclusion': conclusion,
            'reasoning_steps': reasoning_result['reasoning_steps'],
            'derived_conclusions': reasoning_result['conclusions']
        }
    
    def find_contradictions(self, premises: List[str]) -> List[str]:
        """æŸ¥æ‰¾çŸ›ç›¾"""
        reasoning_result = self.reason(premises)
        
        if 'error' in reasoning_result:
            return [reasoning_result['error']]
        
        contradictions = []
        derived_propositions = set()
        
        # æ£€æŸ¥å‰æä¸­çš„çŸ›ç›¾
        for premise in premises:
            parsed_premise = self.parser.parse(premise)
            premise_str = str(parsed_premise)
            
            # æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¦å®š
            if parsed_premise.proposition_type == PropositionType.NEGATION:
                negated_str = str(parsed_premise.sub_propositions[0])
                if negated_str in derived_propositions:
                    contradictions.append(f"çŸ›ç›¾: {negated_str} å’Œ {premise_str}")
            else:
                negated_premise = Proposition(
                    f"Â¬{premise_str}",
                    PropositionType.NEGATION,
                    [parsed_premise]
                )
                negated_str = str(negated_premise)
                if negated_str in derived_propositions:
                    contradictions.append(f"çŸ›ç›¾: {premise_str} å’Œ {negated_str}")
            
            derived_propositions.add(premise_str)
        
        return contradictions

class TruthTable:
    """çœŸå€¼è¡¨"""
    
    def __init__(self):
        self.parser = PropositionParser()
    
    def generate_truth_table(self, propositions: List[str]) -> Dict[str, Any]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        parsed_props = []
        atomic_props = set()
        
        # è§£æå‘½é¢˜å¹¶æ”¶é›†åŸå­å‘½é¢˜
        for prop in propositions:
            parsed_prop = self.parser.parse(prop)
            parsed_props.append(parsed_prop)
            self._collect_atomic_propositions(parsed_prop, atomic_props)
        
        atomic_list = sorted(list(atomic_props))
        num_atomics = len(atomic_list)
        num_combinations = 2 ** num_atomics
        
        truth_table = []
        
        for i in range(num_combinations):
            # ç”ŸæˆçœŸå€¼ç»„åˆ
            truth_values = {}
            for j, atomic in enumerate(atomic_list):
                truth_values[atomic] = bool((i >> j) & 1)
            
            # è®¡ç®—æ¯ä¸ªå‘½é¢˜çš„çœŸå€¼
            row = {'combination': truth_values.copy()}
            for prop in propositions:
                parsed_prop = self.parser.parse(prop)
                row[prop] = self._evaluate_proposition(parsed_prop, truth_values)
            
            truth_table.append(row)
        
        return {
            'atomic_propositions': atomic_list,
            'truth_table': truth_table,
            'num_combinations': num_combinations
        }
    
    def _collect_atomic_propositions(self, prop: Proposition, atomic_props: set):
        """æ”¶é›†åŸå­å‘½é¢˜"""
        if prop.proposition_type == PropositionType.ATOMIC:
            atomic_props.add(prop.content)
        else:
            for sub_prop in prop.sub_propositions:
                self._collect_atomic_propositions(sub_prop, atomic_props)
    
    def _evaluate_proposition(self, prop: Proposition, truth_values: Dict[str, bool]) -> bool:
        """è¯„ä¼°å‘½é¢˜çš„çœŸå€¼"""
        if prop.proposition_type == PropositionType.ATOMIC:
            return truth_values.get(prop.content, False)
        elif prop.proposition_type == PropositionType.NEGATION:
            return not self._evaluate_proposition(prop.sub_propositions[0], truth_values)
        elif prop.proposition_type == PropositionType.CONJUNCTION:
            left = self._evaluate_proposition(prop.sub_propositions[0], truth_values)
            right = self._evaluate_proposition(prop.sub_propositions[1], truth_values)
            return left and right
        elif prop.proposition_type == PropositionType.DISJUNCTION:
            left = self._evaluate_proposition(prop.sub_propositions[0], truth_values)
            right = self._evaluate_proposition(prop.sub_propositions[1], truth_values)
            return left or right
        elif prop.proposition_type == PropositionType.IMPLICATION:
            left = self._evaluate_proposition(prop.sub_propositions[0], truth_values)
            right = self._evaluate_proposition(prop.sub_propositions[1], truth_values)
            return (not left) or right
        elif prop.proposition_type == PropositionType.EQUIVALENCE:
            left = self._evaluate_proposition(prop.sub_propositions[0], truth_values)
            right = self._evaluate_proposition(prop.sub_propositions[1], truth_values)
            return left == right
        
        return False
```

### 3.2 å®é™…åº”ç”¨ç¤ºä¾‹

```python
def logical_reasoning_example():
    """é€»è¾‘æ¨ç†ç¤ºä¾‹"""
    
    # åˆ›å»ºæ¨ç†å™¨
    reasoner = LogicalReasoner()
    
    # ç¤ºä¾‹1: å‡è¨€æ¨ç†
    print("=== ç¤ºä¾‹1: å‡è¨€æ¨ç† ===")
    premises1 = [
        "p â†’ q",
        "p"
    ]
    result1 = reasoner.reason(premises1)
    print("å‰æ:", result1['premises'])
    print("ç»“è®º:", result1['conclusions'])
    print("æ¨ç†æ­¥éª¤:", result1['reasoning_steps'])
    
    # ç¤ºä¾‹2: å‡è¨€ä¸‰æ®µè®º
    print("\n=== ç¤ºä¾‹2: å‡è¨€ä¸‰æ®µè®º ===")
    premises2 = [
        "p â†’ q",
        "q â†’ r"
    ]
    result2 = reasoner.reason(premises2)
    print("å‰æ:", result2['premises'])
    print("ç»“è®º:", result2['conclusions'])
    
    # ç¤ºä¾‹3: è®ºè¯éªŒè¯
    print("\n=== ç¤ºä¾‹3: è®ºè¯éªŒè¯ ===")
    premises3 = [
        "p â†’ q",
        "q â†’ r",
        "p"
    ]
    conclusion3 = "r"
    validation = reasoner.validate_argument(premises3, conclusion3)
    print("è®ºè¯æ˜¯å¦æœ‰æ•ˆ:", validation['is_valid'])
    print("æ¨ç†æ­¥éª¤:", validation['reasoning_steps'])
    
    # ç¤ºä¾‹4: çœŸå€¼è¡¨
    print("\n=== ç¤ºä¾‹4: çœŸå€¼è¡¨ ===")
    truth_table = TruthTable()
    propositions = ["p â†’ q", "p âˆ§ q", "p âˆ¨ q"]
    table_result = truth_table.generate_truth_table(propositions)
    print("åŸå­å‘½é¢˜:", table_result['atomic_propositions'])
    print("çœŸå€¼è¡¨è¡Œæ•°:", table_result['num_combinations'])
    
    # æ˜¾ç¤ºå‰å‡ è¡ŒçœŸå€¼è¡¨
    for i, row in enumerate(table_result['truth_table'][:4]):
        print(f"è¡Œ {i+1}:", row)
    
    return reasoner, truth_table

def automated_reasoning_example():
    """è‡ªåŠ¨åŒ–æ¨ç†ç¤ºä¾‹"""
    
    reasoner = LogicalReasoner()
    
    # å¤æ‚æ¨ç†ç¤ºä¾‹
    premises = [
        "p â†’ q",
        "q â†’ r",
        "r â†’ s",
        "p"
    ]
    
    print("=== è‡ªåŠ¨åŒ–æ¨ç†ç¤ºä¾‹ ===")
    print("å‰æ:", premises)
    
    result = reasoner.reason(premises)
    print("æ¨å¯¼çš„ç»“è®º:", result['conclusions'])
    print("æ¨ç†æ­¥éª¤æ•°:", result['total_steps'])
    
    # éªŒè¯ç‰¹å®šç»“è®º
    test_conclusions = ["s", "q", "r", "t"]
    for conclusion in test_conclusions:
        validation = reasoner.validate_argument(premises, conclusion)
        print(f"ç»“è®º '{conclusion}' æ˜¯å¦æœ‰æ•ˆ: {validation['is_valid']}")
    
    return result

# è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    print("=== é€»è¾‘æ¨ç†ç³»ç»Ÿæ¼”ç¤º ===")
    
    # åŸºç¡€æ¨ç†ç¤ºä¾‹
    reasoner, truth_table = logical_reasoning_example()
    
    # è‡ªåŠ¨åŒ–æ¨ç†ç¤ºä¾‹
    auto_result = automated_reasoning_example()
    
    print("\n=== ç³»ç»ŸåŠŸèƒ½æ€»ç»“ ===")
    print("1. æ”¯æŒå¤šç§æ¨ç†è§„åˆ™: Modus Ponens, Modus Tollens, å‡è¨€ä¸‰æ®µè®º, æå–ä¸‰æ®µè®º")
    print("2. è‡ªåŠ¨æ¨ç†: ä»å‰æè‡ªåŠ¨æ¨å¯¼æ‰€æœ‰å¯èƒ½çš„ç»“è®º")
    print("3. è®ºè¯éªŒè¯: éªŒè¯ç‰¹å®šç»“è®ºæ˜¯å¦å¯ä»¥ä»å‰ææ¨å¯¼å‡º")
    print("4. çœŸå€¼è¡¨ç”Ÿæˆ: ç”Ÿæˆå‘½é¢˜çš„çœŸå€¼è¡¨")
    print("5. çŸ›ç›¾æ£€æµ‹: æ£€æµ‹å‰æé›†åˆä¸­çš„çŸ›ç›¾")
```

## 4. ç†è®ºè¯æ˜

### 4.1 æ¨ç†ç³»ç»Ÿæ­£ç¡®æ€§

**å®šç† 4.1** (æ¨ç†ç³»ç»Ÿæ­£ç¡®æ€§)
å¦‚æœæ¨ç†ç³»ç»Ÿä½¿ç”¨çš„æ‰€æœ‰è§„åˆ™éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œåˆ™ä»çœŸå‰ææ¨å¯¼å‡ºçš„æ‰€æœ‰ç»“è®ºéƒ½ä¸ºçœŸã€‚

**è¯æ˜**:
è®¾ $P$ æ˜¯å‰æé›†åˆï¼Œ$R$ æ˜¯æ¨ç†è§„åˆ™é›†åˆï¼Œ$C$ æ˜¯ç»“è®ºé›†åˆã€‚

å¯¹äºæ¯ä¸ªæ¨ç†è§„åˆ™ $r \in R$ï¼Œæ ¹æ®è§„åˆ™æœ‰æ•ˆæ€§å®šä¹‰ï¼š
å¦‚æœ $p_1, p_2, \ldots, p_n \in P$ ä¸ºçœŸï¼Œä¸” $r(p_1, p_2, \ldots, p_n) = c$ï¼Œ
åˆ™ $c$ ä¸ºçœŸã€‚

é€šè¿‡æ•°å­¦å½’çº³æ³•ï¼š

- åŸºç¡€æƒ…å†µï¼šåˆå§‹å‰æä¸ºçœŸ
- å½’çº³æ­¥éª¤ï¼šå¦‚æœæ‰€æœ‰å·²æ¨å¯¼çš„å‘½é¢˜ä¸ºçœŸï¼Œåˆ™é€šè¿‡æœ‰æ•ˆè§„åˆ™æ¨å¯¼çš„æ–°å‘½é¢˜ä¹Ÿä¸ºçœŸ

å› æ­¤ï¼Œæ‰€æœ‰ç»“è®ºéƒ½ä¸ºçœŸã€‚$\square$

### 4.2 æ¨ç†ç³»ç»Ÿå®Œå¤‡æ€§

**å®šç† 4.2** (æ¨ç†ç³»ç»Ÿå®Œå¤‡æ€§)
å¯¹äºä»»æ„æœ‰æ•ˆçš„é€»è¾‘è•´æ¶µ $P \models c$ï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªæ¨ç†åºåˆ—ä» $P$ æ¨å¯¼å‡º $c$ã€‚

**è¯æ˜**:
é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºæ¯ä¸ªæœ‰æ•ˆçš„è•´æ¶µæ„é€ ä¸€ä¸ªæ¨ç†åºåˆ—ï¼š

1. å¦‚æœ $c \in P$ï¼Œåˆ™ç›´æ¥å¾—åˆ°ç»“è®º
2. å¦‚æœ $c$ æ˜¯ $P$ ä¸­æŸä¸ªå‘½é¢˜çš„å¦å®šï¼Œåˆ™é€šè¿‡çŸ›ç›¾æ¨ç†å¾—åˆ°
3. å¦‚æœ $c$ æ˜¯è•´å«å…³ç³»ï¼Œåˆ™é€šè¿‡å‡è¨€æ¨ç†å¾—åˆ°
4. å…¶ä»–æƒ…å†µå¯ä»¥é€šè¿‡ç»„åˆåŸºæœ¬æ¨ç†è§„åˆ™å¾—åˆ°

å› æ­¤ï¼Œæ¨ç†ç³»ç»Ÿæ˜¯å®Œå¤‡çš„ã€‚$\square$

## 5. æ€§èƒ½åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.1** (æ¨ç†ç®—æ³•å¤æ‚åº¦)
å¯¹äºåŒ…å« $n$ ä¸ªå‰æçš„æ¨ç†é—®é¢˜ï¼Œæ¨ç†ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2 \cdot r)$ï¼Œå…¶ä¸­ $r$ æ˜¯æ¨ç†è§„åˆ™æ•°é‡ã€‚

**è¯æ˜**:
æ¨ç†ç®—æ³•çš„ä¸»è¦æ­¥éª¤ï¼š

1. æ£€æŸ¥æ¯ä¸ªè§„åˆ™æ˜¯å¦å¯åº”ç”¨ï¼š$O(n \cdot r)$
2. åº”ç”¨è§„åˆ™ç”Ÿæˆæ–°ç»“è®ºï¼š$O(n \cdot r)$
3. é‡å¤ç›´åˆ°æ— æ–°ç»“è®ºï¼šæœ€å¤š $n$ æ¬¡

æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2 \cdot r)$ã€‚$\square$

### 5.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.2** (æ¨ç†ç³»ç»Ÿç©ºé—´å¤æ‚åº¦)
æ¨ç†ç³»ç»Ÿçš„ç©ºé—´å¤æ‚åº¦ä¸º $O(n + c)$ï¼Œå…¶ä¸­ $n$ æ˜¯å‰ææ•°é‡ï¼Œ$c$ æ˜¯ç»“è®ºæ•°é‡ã€‚

**è¯æ˜**:
æ¨ç†ç³»ç»Ÿéœ€è¦å­˜å‚¨ï¼š

1. å‰æé›†åˆï¼š$O(n)$
2. ç»“è®ºé›†åˆï¼š$O(c)$
3. æ¨ç†è§„åˆ™ï¼šå¸¸æ•°ç©ºé—´

æ€»ç©ºé—´å¤æ‚åº¦ä¸º $O(n + c)$ã€‚$\square$

## 6. å®é™…åº”ç”¨

### 6.1 äººå·¥æ™ºèƒ½

é€»è¾‘æ¨ç†åœ¨äººå·¥æ™ºèƒ½ä¸­çš„åº”ç”¨ï¼š

- ä¸“å®¶ç³»ç»Ÿ
- çŸ¥è¯†è¡¨ç¤º
- è‡ªåŠ¨å®šç†è¯æ˜
- è‡ªç„¶è¯­è¨€å¤„ç†

### 6.2 è½¯ä»¶éªŒè¯

é€»è¾‘æ¨ç†åœ¨è½¯ä»¶éªŒè¯ä¸­çš„åº”ç”¨ï¼š

- ç¨‹åºæ­£ç¡®æ€§è¯æ˜
- æ¨¡å‹æ£€æŸ¥
- é™æ€åˆ†æ
- å½¢å¼åŒ–éªŒè¯

### 6.3 æ•°å­¦è¯æ˜

é€»è¾‘æ¨ç†åœ¨æ•°å­¦è¯æ˜ä¸­çš„åº”ç”¨ï¼š

- å®šç†è¯æ˜
- å…¬ç†åŒ–ç³»ç»Ÿ
- æ•°å­¦é€»è¾‘
- é›†åˆè®º

## 7. æ€»ç»“

é€»è¾‘æ¨ç†æ˜¯å½¢å¼åŒ–æ€ç»´çš„æ ¸å¿ƒå·¥å…·ï¼Œé€šè¿‡ä¸¥æ ¼çš„æ¨ç†è§„åˆ™å’Œå®Œæ•´çš„Pythonå®ç°ï¼Œæˆ‘ä»¬å»ºç«‹äº†ä¸€ä¸ªå®Œæ•´çš„é€»è¾‘æ¨ç†ç†è®ºæ¡†æ¶ã€‚

### ä¸»è¦ç‰¹ç‚¹

1. **å½¢å¼åŒ–**: ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œæ¨ç†è§„åˆ™
2. **è‡ªåŠ¨åŒ–**: å®Œæ•´çš„è‡ªåŠ¨åŒ–æ¨ç†ç³»ç»Ÿ
3. **å¯éªŒè¯**: è®ºè¯æœ‰æ•ˆæ€§éªŒè¯
4. **å¯è§†åŒ–**: çœŸå€¼è¡¨ç”Ÿæˆå’Œæ¨ç†æ­¥éª¤å±•ç¤º

### æ ¸å¿ƒè´¡çŒ®

1. **ç†è®ºæ¡†æ¶**: å»ºç«‹äº†å®Œæ•´çš„é€»è¾‘æ¨ç†ç†è®ºä½“ç³»
2. **å®ç°ç³»ç»Ÿ**: æä¾›äº†å®Œæ•´çš„Pythonæ¨ç†å·¥å…·
3. **åº”ç”¨ç¤ºä¾‹**: å±•ç¤ºäº†å®é™…é—®é¢˜çš„æ¨ç†æ–¹æ³•
4. **è´¨é‡ä¿è¯**: å»ºç«‹äº†éªŒè¯å’Œåˆ†ææœºåˆ¶

è¿™ä¸ªæ¡†æ¶ä¸ºåç»­çš„ç®—æ³•ç†è®ºã€å½¢å¼è¯­è¨€ç†è®ºç­‰æä¾›äº†é‡è¦çš„é€»è¾‘åŸºç¡€ï¼Œç¡®ä¿æ•´ä¸ªçŸ¥è¯†ä½“ç³»çš„ç§‘å­¦æ€§å’Œä¸¥è°¨æ€§ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*æ–‡æ¡£çŠ¶æ€: å·²å®Œæˆ*
