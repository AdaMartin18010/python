# 00.03 ç§‘å­¦æ–¹æ³•è®º

## ğŸ“– æ¦‚è¿°

ç§‘å­¦æ–¹æ³•è®ºæ˜¯ç§‘å­¦ç ”ç©¶çš„åŸºæœ¬åŸç†å’Œæ–¹æ³•çš„ç³»ç»ŸåŒ–æ€»ç»“ï¼ŒåŒ…æ‹¬è§‚å¯Ÿã€å‡è®¾ã€å®éªŒã€éªŒè¯ç­‰ç¯èŠ‚ã€‚åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œç§‘å­¦æ–¹æ³•è®ºæŒ‡å¯¼æˆ‘ä»¬å¦‚ä½•æ„å»ºã€éªŒè¯å’Œä¼˜åŒ–ç®—æ³•ä¸ç³»ç»Ÿã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç§‘å­¦æ–¹æ³•çš„åŸºæœ¬æ­¥éª¤

**å®šä¹‰**ï¼šç§‘å­¦æ–¹æ³•æ˜¯ä¸€ä¸ªå¾ªç¯çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬ï¼š

1. **è§‚å¯Ÿ** (Observation)
2. **å‡è®¾** (Hypothesis)
3. **é¢„æµ‹** (Prediction)
4. **å®éªŒ** (Experiment)
5. **éªŒè¯** (Verification)
6. **ç†è®º** (Theory)

**Pythonå®ç°**ï¼š

```python
from typing import Any, Callable, List, Dict, Optional
from dataclasses import dataclass
from abc import ABC, abstractmethod
import time
import random

@dataclass
class Observation:
    """è§‚å¯Ÿç»“æœ"""
    data: Any
    timestamp: float
    context: Dict[str, Any]

@dataclass
class Hypothesis:
    """å‡è®¾"""
    statement: str
    confidence: float  # 0.0 åˆ° 1.0
    supporting_evidence: List[str]

@dataclass
class Experiment:
    """å®éªŒ"""
    hypothesis: Hypothesis
    method: str
    parameters: Dict[str, Any]
    results: List[Any]

@dataclass
class Theory:
    """ç†è®º"""
    name: str
    description: str
    hypotheses: List[Hypothesis]
    confidence: float

class ScientificMethod(ABC):
    """ç§‘å­¦æ–¹æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self):
        self.observations: List[Observation] = []
        self.hypotheses: List[Hypothesis] = []
        self.experiments: List[Experiment] = []
        self.theories: List[Theory] = []
    
    @abstractmethod
    def observe(self, data: Any, context: Dict[str, Any] = None) -> Observation:
        """è§‚å¯Ÿè¿‡ç¨‹"""
        pass
    
    @abstractmethod
    def formulate_hypothesis(self, observations: List[Observation]) -> Hypothesis:
        """å½¢æˆå‡è®¾"""
        pass
    
    @abstractmethod
    def design_experiment(self, hypothesis: Hypothesis) -> Experiment:
        """è®¾è®¡å®éªŒ"""
        pass
    
    @abstractmethod
    def conduct_experiment(self, experiment: Experiment) -> List[Any]:
        """æ‰§è¡Œå®éªŒ"""
        pass
    
    @abstractmethod
    def verify_hypothesis(self, hypothesis: Hypothesis, results: List[Any]) -> bool:
        """éªŒè¯å‡è®¾"""
        pass
    
    def scientific_cycle(self, initial_data: Any) -> Theory:
        """å®Œæ•´çš„ç§‘å­¦æ–¹æ³•å¾ªç¯"""
        # 1. è§‚å¯Ÿ
        observation = self.observe(initial_data)
        self.observations.append(observation)
        
        # 2. å½¢æˆå‡è®¾
        hypothesis = self.formulate_hypothesis([observation])
        self.hypotheses.append(hypothesis)
        
        # 3. è®¾è®¡å®éªŒ
        experiment = self.design_experiment(hypothesis)
        
        # 4. æ‰§è¡Œå®éªŒ
        results = self.conduct_experiment(experiment)
        experiment.results = results
        self.experiments.append(experiment)
        
        # 5. éªŒè¯å‡è®¾
        is_valid = self.verify_hypothesis(hypothesis, results)
        
        # 6. å½¢æˆç†è®º
        theory = Theory(
            name=f"Theory based on {hypothesis.statement}",
            description=f"Based on hypothesis: {hypothesis.statement}",
            hypotheses=[hypothesis],
            confidence=hypothesis.confidence if is_valid else 0.0
        )
        self.theories.append(theory)
        
        return theory

class AlgorithmAnalysisMethod(ScientificMethod):
    """ç®—æ³•åˆ†æçš„ç§‘å­¦æ–¹æ³•å®ç°"""
    
    def observe(self, data: Any, context: Dict[str, Any] = None) -> Observation:
        """è§‚å¯Ÿç®—æ³•æ€§èƒ½"""
        if context is None:
            context = {}
        
        # æµ‹é‡ç®—æ³•æ‰§è¡Œæ—¶é—´
        start_time = time.time()
        if callable(data):
            result = data()
        else:
            result = data
        end_time = time.time()
        
        execution_time = end_time - start_time
        
        return Observation(
            data=result,
            timestamp=time.time(),
            context={
                "execution_time": execution_time,
                "input_size": context.get("input_size", 0),
                **context
            }
        )
    
    def formulate_hypothesis(self, observations: List[Observation]) -> Hypothesis:
        """åŸºäºè§‚å¯Ÿå½¢æˆæ€§èƒ½å‡è®¾"""
        if not observations:
            return Hypothesis("No data available", 0.0, [])
        
        # åˆ†ææ‰§è¡Œæ—¶é—´æ¨¡å¼
        times = [obs.context.get("execution_time", 0) for obs in observations]
        input_sizes = [obs.context.get("input_size", 0) for obs in observations]
        
        if len(times) >= 2:
            # ç®€å•çš„æ—¶é—´å¤æ‚åº¦å‡è®¾
            if times[-1] > times[-2]:
                hypothesis = "ç®—æ³•æ—¶é—´å¤æ‚åº¦å¯èƒ½ä¸æ˜¯å¸¸æ•°"
                confidence = 0.7
            else:
                hypothesis = "ç®—æ³•æ—¶é—´å¤æ‚åº¦å¯èƒ½æ˜¯å¸¸æ•°"
                confidence = 0.6
        else:
            hypothesis = "éœ€è¦æ›´å¤šæ•°æ®æ¥å½¢æˆå‡è®¾"
            confidence = 0.3
        
        return Hypothesis(
            statement=hypothesis,
            confidence=confidence,
            supporting_evidence=[f"æ‰§è¡Œæ—¶é—´: {times}", f"è¾“å…¥å¤§å°: {input_sizes}"]
        )
    
    def design_experiment(self, hypothesis: Hypothesis) -> Experiment:
        """è®¾è®¡ç®—æ³•æ€§èƒ½å®éªŒ"""
        return Experiment(
            hypothesis=hypothesis,
            method="æ€§èƒ½æµ‹è¯•",
            parameters={
                "test_cases": 10,
                "input_range": (100, 10000),
                "iterations": 5
            },
            results=[]
        )
    
    def conduct_experiment(self, experiment: Experiment) -> List[Any]:
        """æ‰§è¡Œç®—æ³•æ€§èƒ½å®éªŒ"""
        results = []
        params = experiment.parameters
        
        for i in range(params["test_cases"]):
            input_size = random.randint(*params["input_range"])
            
            # åˆ›å»ºæµ‹è¯•æ•°æ®
            test_data = list(range(input_size))
            
            # æµ‹è¯•æ’åºç®—æ³•
            def test_algorithm():
                return sorted(test_data)
            
            # å¤šæ¬¡æµ‹è¯•å–å¹³å‡
            times = []
            for _ in range(params["iterations"]):
                observation = self.observe(test_algorithm, {"input_size": input_size})
                times.append(observation.context["execution_time"])
            
            avg_time = sum(times) / len(times)
            results.append({
                "input_size": input_size,
                "average_time": avg_time,
                "times": times
            })
        
        return results
    
    def verify_hypothesis(self, hypothesis: Hypothesis, results: List[Any]) -> bool:
        """éªŒè¯æ€§èƒ½å‡è®¾"""
        if not results:
            return False
        
        # åˆ†æç»“æœè¶‹åŠ¿
        input_sizes = [r["input_size"] for r in results]
        times = [r["average_time"] for r in results]
        
        # ç®€å•éªŒè¯ï¼šæ£€æŸ¥æ—¶é—´æ˜¯å¦éšè¾“å…¥å¤§å°å¢é•¿
        if len(times) >= 2:
            time_increasing = all(times[i] <= times[i+1] for i in range(len(times)-1))
            return time_increasing
        
        return False

# ç¤ºä¾‹ï¼šä½¿ç”¨ç§‘å­¦æ–¹æ³•åˆ†æç®—æ³•
method = AlgorithmAnalysisMethod()

# æµ‹è¯•å¿«é€Ÿæ’åºç®—æ³•
def quicksort_test():
    data = list(range(1000))
    random.shuffle(data)
    return sorted(data)

# æ‰§è¡Œç§‘å­¦æ–¹æ³•å¾ªç¯
theory = method.scientific_cycle(quicksort_test)

print(f"å½¢æˆçš„ç†è®º: {theory.name}")
print(f"ç†è®ºæè¿°: {theory.description}")
print(f"ç½®ä¿¡åº¦: {theory.confidence}")
```

### 2. å®éªŒè®¾è®¡

**å®šä¹‰**ï¼šå®éªŒè®¾è®¡æ˜¯ç§‘å­¦æ–¹æ³•ä¸­éªŒè¯å‡è®¾çš„å…³é”®ç¯èŠ‚ï¼Œéœ€è¦æ§åˆ¶å˜é‡ã€éšæœºåŒ–å’Œé‡å¤å®éªŒã€‚

**Pythonå®ç°**ï¼š

```python
from typing import List, Dict, Any, Tuple
import random
import statistics
from dataclasses import dataclass

@dataclass
class ExperimentalDesign:
    """å®éªŒè®¾è®¡"""
    name: str
    independent_variables: List[str]
    dependent_variables: List[str]
    control_variables: List[str]
    sample_size: int
    randomization: bool
    replication: int

class ExperimentController:
    """å®éªŒæ§åˆ¶å™¨"""
    
    def __init__(self, design: ExperimentalDesign):
        self.design = design
        self.results: List[Dict[str, Any]] = []
    
    def run_experiment(self, treatment_function: Callable, 
                      control_function: Callable = None) -> Dict[str, Any]:
        """è¿è¡Œå®éªŒ"""
        results = {
            "treatment": [],
            "control": [],
            "statistics": {}
        }
        
        # éšæœºåŒ–å®éªŒé¡ºåº
        experiment_order = list(range(self.design.sample_size))
        if self.design.randomization:
            random.shuffle(experiment_order)
        
        # æ‰§è¡Œå®éªŒ
        for i in experiment_order:
            # å¤„ç†ç»„
            treatment_result = treatment_function(i)
            results["treatment"].append(treatment_result)
            
            # å¯¹ç…§ç»„ï¼ˆå¦‚æœæä¾›ï¼‰
            if control_function:
                control_result = control_function(i)
                results["control"].append(control_result)
        
        # è®¡ç®—ç»Ÿè®¡é‡
        results["statistics"] = self._calculate_statistics(results)
        
        self.results.append(results)
        return results
    
    def _calculate_statistics(self, results: Dict[str, Any]) -> Dict[str, float]:
        """è®¡ç®—ç»Ÿè®¡é‡"""
        stats = {}
        
        if results["treatment"]:
            stats["treatment_mean"] = statistics.mean(results["treatment"])
            stats["treatment_std"] = statistics.stdev(results["treatment"]) if len(results["treatment"]) > 1 else 0
        
        if results["control"]:
            stats["control_mean"] = statistics.mean(results["control"])
            stats["control_std"] = statistics.stdev(results["control"]) if len(results["control"]) > 1 else 0
        
        if results["treatment"] and results["control"]:
            # è®¡ç®—æ•ˆåº”é‡
            pooled_std = statistics.stdev(results["treatment"] + results["control"])
            if pooled_std > 0:
                stats["effect_size"] = (stats["treatment_mean"] - stats["control_mean"]) / pooled_std
        
        return stats
    
    def analyze_results(self) -> Dict[str, Any]:
        """åˆ†æå®éªŒç»“æœ"""
        if not self.results:
            return {}
        
        analysis = {
            "total_experiments": len(self.results),
            "summary_statistics": {},
            "significance_test": {}
        }
        
        # æ±‡æ€»ç»Ÿè®¡
        all_treatment_results = []
        all_control_results = []
        
        for result in self.results:
            all_treatment_results.extend(result["treatment"])
            if result["control"]:
                all_control_results.extend(result["control"])
        
        if all_treatment_results:
            analysis["summary_statistics"]["treatment"] = {
                "mean": statistics.mean(all_treatment_results),
                "std": statistics.stdev(all_treatment_results) if len(all_treatment_results) > 1 else 0,
                "count": len(all_treatment_results)
            }
        
        if all_control_results:
            analysis["summary_statistics"]["control"] = {
                "mean": statistics.mean(all_control_results),
                "std": statistics.stdev(all_control_results) if len(all_control_results) > 1 else 0,
                "count": len(all_control_results)
            }
        
        return analysis

# ç¤ºä¾‹ï¼šç®—æ³•æ€§èƒ½å¯¹æ¯”å®éªŒ
def create_algorithm_experiment():
    """åˆ›å»ºç®—æ³•æ€§èƒ½å¯¹æ¯”å®éªŒ"""
    
    design = ExperimentalDesign(
        name="æ’åºç®—æ³•æ€§èƒ½å¯¹æ¯”",
        independent_variables=["ç®—æ³•ç±»å‹"],
        dependent_variables=["æ‰§è¡Œæ—¶é—´"],
        control_variables=["è¾“å…¥å¤§å°", "æ•°æ®åˆ†å¸ƒ"],
        sample_size=20,
        randomization=True,
        replication=3
    )
    
    controller = ExperimentController(design)
    
    # å®šä¹‰å®éªŒå‡½æ•°
    def quicksort_treatment(iteration):
        data = list(range(1000))
        random.shuffle(data)
        start_time = time.time()
        sorted(data)
        return time.time() - start_time
    
    def bubblesort_control(iteration):
        data = list(range(100))  # è¾ƒå°è§„æ¨¡é¿å…è¿‡é•¿ç­‰å¾…
        random.shuffle(data)
        start_time = time.time()
        # å†’æ³¡æ’åºå®ç°
        for i in range(len(data)):
            for j in range(0, len(data) - i - 1):
                if data[j] > data[j + 1]:
                    data[j], data[j + 1] = data[j + 1], data[j]
        return time.time() - start_time
    
    # è¿è¡Œå®éªŒ
    results = controller.run_experiment(quicksort_treatment, bubblesort_control)
    
    # åˆ†æç»“æœ
    analysis = controller.analyze_results()
    
    return results, analysis

# æ‰§è¡Œå®éªŒ
experiment_results, experiment_analysis = create_algorithm_experiment()

print("å®éªŒè®¾è®¡:", experiment_results.keys())
print("ç»Ÿè®¡åˆ†æ:", experiment_analysis["summary_statistics"])
```

### 3. ç»Ÿè®¡æ¨æ–­

**å®šä¹‰**ï¼šç»Ÿè®¡æ¨æ–­æ˜¯ä»æ ·æœ¬æ•°æ®æ¨æ–­æ€»ä½“ç‰¹å¾çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬å‚æ•°ä¼°è®¡å’Œå‡è®¾æ£€éªŒã€‚

**Pythonå®ç°**ï¼š

```python
import numpy as np
from scipy import stats
from typing import Tuple, List, Optional

class StatisticalInference:
    """ç»Ÿè®¡æ¨æ–­ç±»"""
    
    @staticmethod
    def confidence_interval(data: List[float], confidence: float = 0.95) -> Tuple[float, float]:
        """è®¡ç®—ç½®ä¿¡åŒºé—´"""
        if len(data) < 2:
            return (data[0], data[0]) if data else (0, 0)
        
        mean = np.mean(data)
        std_error = stats.sem(data)
        
        # è®¡ç®—ç½®ä¿¡åŒºé—´
        ci = stats.t.interval(confidence, len(data) - 1, loc=mean, scale=std_error)
        return ci
    
    @staticmethod
    def t_test(sample1: List[float], sample2: List[float], 
               alternative: str = 'two-sided') -> Tuple[float, float]:
        """tæ£€éªŒ"""
        t_stat, p_value = stats.ttest_ind(sample1, sample2, alternative=alternative)
        return t_stat, p_value
    
    @staticmethod
    def effect_size(sample1: List[float], sample2: List[float]) -> float:
        """è®¡ç®—æ•ˆåº”é‡ï¼ˆCohen's dï¼‰"""
        pooled_std = np.sqrt(((len(sample1) - 1) * np.var(sample1, ddof=1) + 
                             (len(sample2) - 1) * np.var(sample2, ddof=1)) / 
                            (len(sample1) + len(sample2) - 2))
        
        if pooled_std == 0:
            return 0
        
        cohens_d = (np.mean(sample1) - np.mean(sample2)) / pooled_std
        return cohens_d
    
    @staticmethod
    def power_analysis(sample_size: int, effect_size: float, 
                      alpha: float = 0.05) -> float:
        """åŠŸæ•ˆåˆ†æ"""
        # ç®€åŒ–çš„åŠŸæ•ˆè®¡ç®—
        from scipy.stats import norm
        
        z_alpha = norm.ppf(1 - alpha/2)
        z_beta = norm.ppf(0.8)  # 80% åŠŸæ•ˆ
        
        # è®¡ç®—æ‰€éœ€æ ·æœ¬é‡
        required_n = 2 * ((z_alpha + z_beta) / effect_size) ** 2
        
        # è®¡ç®—å½“å‰æ ·æœ¬é‡çš„åŠŸæ•ˆ
        if sample_size >= required_n:
            return 0.8
        else:
            return 0.5  # ç®€åŒ–ä¼°è®¡

class HypothesisTesting:
    """å‡è®¾æ£€éªŒ"""
    
    def __init__(self, alpha: float = 0.05):
        self.alpha = alpha
    
    def test_algorithm_performance(self, algorithm_a_results: List[float], 
                                 algorithm_b_results: List[float]) -> Dict[str, Any]:
        """æµ‹è¯•ç®—æ³•æ€§èƒ½å·®å¼‚"""
        
        # æè¿°æ€§ç»Ÿè®¡
        desc_stats = {
            "algorithm_a": {
                "mean": np.mean(algorithm_a_results),
                "std": np.std(algorithm_a_results),
                "n": len(algorithm_a_results)
            },
            "algorithm_b": {
                "mean": np.mean(algorithm_b_results),
                "std": np.std(algorithm_b_results),
                "n": len(algorithm_b_results)
            }
        }
        
        # tæ£€éªŒ
        t_stat, p_value = StatisticalInference.t_test(algorithm_a_results, algorithm_b_results)
        
        # æ•ˆåº”é‡
        effect_size = StatisticalInference.effect_size(algorithm_a_results, algorithm_b_results)
        
        # ç½®ä¿¡åŒºé—´
        ci_a = StatisticalInference.confidence_interval(algorithm_a_results)
        ci_b = StatisticalInference.confidence_interval(algorithm_b_results)
        
        # å†³ç­–
        significant = p_value < self.alpha
        
        return {
            "descriptive_statistics": desc_stats,
            "t_statistic": t_stat,
            "p_value": p_value,
            "effect_size": effect_size,
            "confidence_intervals": {
                "algorithm_a": ci_a,
                "algorithm_b": ci_b
            },
            "significant": significant,
            "conclusion": f"ç®—æ³•æ€§èƒ½å·®å¼‚{'æ˜¾è‘—' if significant else 'ä¸æ˜¾è‘—'} (p={p_value:.4f})"
        }

# ç¤ºä¾‹ï¼šç®—æ³•æ€§èƒ½ç»Ÿè®¡æ¨æ–­
def demonstrate_statistical_inference():
    """æ¼”ç¤ºç»Ÿè®¡æ¨æ–­"""
    
    # æ¨¡æ‹Ÿä¸¤ç§ç®—æ³•çš„æ€§èƒ½æ•°æ®
    np.random.seed(42)
    algorithm_a = np.random.normal(0.1, 0.02, 30)  # å¹³å‡0.1ç§’ï¼Œæ ‡å‡†å·®0.02
    algorithm_b = np.random.normal(0.15, 0.03, 30)  # å¹³å‡0.15ç§’ï¼Œæ ‡å‡†å·®0.03
    
    # åˆ›å»ºå‡è®¾æ£€éªŒå¯¹è±¡
    tester = HypothesisTesting(alpha=0.05)
    
    # æ‰§è¡Œå‡è®¾æ£€éªŒ
    results = tester.test_algorithm_performance(algorithm_a.tolist(), algorithm_b.tolist())
    
    # è¾“å‡ºç»“æœ
    print("ç®—æ³•æ€§èƒ½ç»Ÿè®¡æ¨æ–­ç»“æœ:")
    print("-" * 50)
    print(f"ç®—æ³•A: å¹³å‡={results['descriptive_statistics']['algorithm_a']['mean']:.4f}s")
    print(f"ç®—æ³•B: å¹³å‡={results['descriptive_statistics']['algorithm_b']['mean']:.4f}s")
    print(f"tç»Ÿè®¡é‡: {results['t_statistic']:.4f}")
    print(f"på€¼: {results['p_value']:.4f}")
    print(f"æ•ˆåº”é‡: {results['effect_size']:.4f}")
    print(f"ç»“è®º: {results['conclusion']}")
    
    return results

# æ‰§è¡Œç»Ÿè®¡æ¨æ–­æ¼”ç¤º
inference_results = demonstrate_statistical_inference()
```

### 4. å¯é‡å¤æ€§

**å®šä¹‰**ï¼šå¯é‡å¤æ€§æ˜¯ç§‘å­¦ç ”ç©¶çš„åŸºæœ¬è¦æ±‚ï¼Œç¡®ä¿å®éªŒç»“æœå¯ä»¥è¢«å…¶ä»–ç ”ç©¶è€…é‡ç°ã€‚

**Pythonå®ç°**ï¼š

```python
import json
import hashlib
from datetime import datetime
from typing import Dict, Any, Optional

class ReproducibleExperiment:
    """å¯é‡å¤å®éªŒç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.metadata = {
            "experiment_name": name,
            "timestamp": datetime.now().isoformat(),
            "python_version": "3.8+",
            "dependencies": {},
            "random_seed": None
        }
        self.parameters = {}
        self.results = {}
        self.code_snapshot = ""
    
    def set_parameters(self, **kwargs):
        """è®¾ç½®å®éªŒå‚æ•°"""
        self.parameters.update(kwargs)
    
    def set_random_seed(self, seed: int):
        """è®¾ç½®éšæœºç§å­"""
        import random
        import numpy as np
        
        random.seed(seed)
        np.random.seed(seed)
        self.metadata["random_seed"] = seed
    
    def capture_code_snapshot(self, function: Callable) -> str:
        """æ•è·ä»£ç å¿«ç…§"""
        import inspect
        return inspect.getsource(function)
    
    def run_experiment(self, experiment_function: Callable, 
                      function_name: str = "experiment") -> Dict[str, Any]:
        """è¿è¡Œå¯é‡å¤å®éªŒ"""
        
        # æ•è·ä»£ç å¿«ç…§
        self.code_snapshot = self.capture_code_snapshot(experiment_function)
        
        # è¿è¡Œå®éªŒ
        start_time = datetime.now()
        results = experiment_function(**self.parameters)
        end_time = datetime.now()
        
        # è®°å½•ç»“æœ
        self.results = {
            "function_name": function_name,
            "execution_time": (end_time - start_time).total_seconds(),
            "results": results,
            "parameters": self.parameters.copy()
        }
        
        return self.results
    
    def save_experiment(self, filename: str):
        """ä¿å­˜å®éªŒåˆ°æ–‡ä»¶"""
        experiment_data = {
            "metadata": self.metadata,
            "parameters": self.parameters,
            "results": self.results,
            "code_snapshot": self.code_snapshot
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(experiment_data, f, indent=2, ensure_ascii=False)
    
    def load_experiment(self, filename: str):
        """ä»æ–‡ä»¶åŠ è½½å®éªŒ"""
        with open(filename, 'r', encoding='utf-8') as f:
            experiment_data = json.load(f)
        
        self.metadata = experiment_data["metadata"]
        self.parameters = experiment_data["parameters"]
        self.results = experiment_data["results"]
        self.code_snapshot = experiment_data["code_snapshot"]
    
    def verify_reproducibility(self, other_experiment: 'ReproducibleExperiment') -> bool:
        """éªŒè¯å®éªŒå¯é‡å¤æ€§"""
        # æ£€æŸ¥å‚æ•°æ˜¯å¦ç›¸åŒ
        if self.parameters != other_experiment.parameters:
            return False
        
        # æ£€æŸ¥ä»£ç æ˜¯å¦ç›¸åŒ
        if self.code_snapshot != other_experiment.code_snapshot:
            return False
        
        # æ£€æŸ¥ç»“æœæ˜¯å¦ç›¸ä¼¼ï¼ˆå…è®¸å°çš„æ•°å€¼è¯¯å·®ï¼‰
        if "results" in self.results and "results" in other_experiment.results:
            return self._compare_results(self.results["results"], 
                                       other_experiment.results["results"])
        
        return True
    
    def _compare_results(self, results1: Any, results2: Any, tolerance: float = 1e-6) -> bool:
        """æ¯”è¾ƒç»“æœæ˜¯å¦ç›¸ä¼¼"""
        if isinstance(results1, (int, float)) and isinstance(results2, (int, float)):
            return abs(results1 - results2) < tolerance
        elif isinstance(results1, list) and isinstance(results2, list):
            if len(results1) != len(results2):
                return False
            return all(self._compare_results(r1, r2, tolerance) for r1, r2 in zip(results1, results2))
        else:
            return results1 == results2

# ç¤ºä¾‹ï¼šå¯é‡å¤å®éªŒ
def create_reproducible_experiment():
    """åˆ›å»ºå¯é‡å¤å®éªŒç¤ºä¾‹"""
    
    # å®šä¹‰å®éªŒå‡½æ•°
    def sorting_experiment(array_size: int = 1000, algorithm: str = "quicksort"):
        """æ’åºç®—æ³•å®éªŒ"""
        import random
        
        # ç”Ÿæˆæµ‹è¯•æ•°æ®
        data = list(range(array_size))
        random.shuffle(data)
        
        # æ‰§è¡Œæ’åº
        start_time = time.time()
        if algorithm == "quicksort":
            result = sorted(data)
        elif algorithm == "bubblesort":
            # ç®€åŒ–ç‰ˆå†’æ³¡æ’åº
            result = data.copy()
            for i in range(len(result)):
                for j in range(0, len(result) - i - 1):
                    if result[j] > result[j + 1]:
                        result[j], result[j + 1] = result[j + 1], result[j]
        else:
            result = data
        
        execution_time = time.time() - start_time
        
        return {
            "algorithm": algorithm,
            "array_size": array_size,
            "execution_time": execution_time,
            "result_checksum": hashlib.md5(str(result).encode()).hexdigest()
        }
    
    # åˆ›å»ºå®éªŒ
    experiment = ReproducibleExperiment("æ’åºç®—æ³•æ€§èƒ½å¯¹æ¯”")
    experiment.set_parameters(array_size=1000, algorithm="quicksort")
    experiment.set_random_seed(42)
    
    # è¿è¡Œå®éªŒ
    results = experiment.run_experiment(sorting_experiment, "sorting_experiment")
    
    # ä¿å­˜å®éªŒ
    experiment.save_experiment("sorting_experiment.json")
    
    print("å®éªŒå®Œæˆï¼Œç»“æœå·²ä¿å­˜")
    print(f"æ‰§è¡Œæ—¶é—´: {results['execution_time']:.4f}ç§’")
    
    return experiment

# æ‰§è¡Œå¯é‡å¤å®éªŒ
reproducible_exp = create_reproducible_experiment()
```

## ğŸ”¬ æ–¹æ³•è®ºåº”ç”¨

### 1. ç®—æ³•åˆ†æ

**å®šä¹‰**ï¼šä½¿ç”¨ç§‘å­¦æ–¹æ³•åˆ†æç®—æ³•çš„æ­£ç¡®æ€§ã€æ•ˆç‡å’Œå¤æ‚åº¦ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Callable, List, Dict, Any
import time
import matplotlib.pyplot as plt

class AlgorithmAnalyzer:
    """ç®—æ³•åˆ†æå™¨"""
    
    def __init__(self):
        self.analysis_results = {}
    
    def analyze_complexity(self, algorithm: Callable, 
                          input_generator: Callable,
                          input_sizes: List[int]) -> Dict[str, Any]:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        
        results = {
            "input_sizes": input_sizes,
            "execution_times": [],
            "space_usage": [],
            "complexity_estimate": ""
        }
        
        for size in input_sizes:
            # ç”Ÿæˆè¾“å…¥
            input_data = input_generator(size)
            
            # æµ‹é‡æ—¶é—´
            start_time = time.time()
            algorithm(input_data)
            end_time = time.time()
            
            execution_time = end_time - start_time
            results["execution_times"].append(execution_time)
        
        # ä¼°è®¡å¤æ‚åº¦
        results["complexity_estimate"] = self._estimate_complexity(
            input_sizes, results["execution_times"]
        )
        
        return results
    
    def _estimate_complexity(self, sizes: List[int], times: List[float]) -> str:
        """ä¼°è®¡æ—¶é—´å¤æ‚åº¦"""
        if len(sizes) < 2:
            return "æ•°æ®ä¸è¶³"
        
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            time_ratio = times[i] / times[i-1]
            growth_rates.append(time_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # åˆ¤æ–­å¤æ‚åº¦ç±»å‹
        if avg_growth < 1.5:
            return "O(1) - å¸¸æ•°æ—¶é—´"
        elif avg_growth < 2.5:
            return "O(log n) - å¯¹æ•°æ—¶é—´"
        elif avg_growth < 3.5:
            return "O(n) - çº¿æ€§æ—¶é—´"
        elif avg_growth < 6:
            return "O(n log n) - çº¿æ€§å¯¹æ•°æ—¶é—´"
        elif avg_growth < 15:
            return "O(nÂ²) - å¹³æ–¹æ—¶é—´"
        else:
            return "O(nÂ³) æˆ–æ›´é«˜ - ç«‹æ–¹æˆ–æ›´é«˜æ—¶é—´"
    
    def compare_algorithms(self, algorithms: Dict[str, Callable],
                          input_generator: Callable,
                          input_sizes: List[int]) -> Dict[str, Any]:
        """æ¯”è¾ƒå¤šä¸ªç®—æ³•"""
        
        comparison = {}
        
        for name, algorithm in algorithms.items():
            comparison[name] = self.analyze_complexity(algorithm, input_generator, input_sizes)
        
        return comparison
    
    def visualize_results(self, results: Dict[str, Any]):
        """å¯è§†åŒ–åˆ†æç»“æœ"""
        plt.figure(figsize=(12, 8))
        
        for name, data in results.items():
            plt.plot(data["input_sizes"], data["execution_times"], 
                    marker='o', label=f"{name} ({data['complexity_estimate']})")
        
        plt.xlabel('è¾“å…¥å¤§å°')
        plt.ylabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
        plt.title('ç®—æ³•æ€§èƒ½æ¯”è¾ƒ')
        plt.legend()
        plt.grid(True)
        plt.show()

# ç¤ºä¾‹ï¼šç®—æ³•åˆ†æ
def demonstrate_algorithm_analysis():
    """æ¼”ç¤ºç®—æ³•åˆ†æ"""
    
    # å®šä¹‰è¾“å…¥ç”Ÿæˆå™¨
    def generate_random_list(size: int) -> List[int]:
        import random
        return [random.randint(1, 1000) for _ in range(size)]
    
    # å®šä¹‰ç®—æ³•
    def linear_search(arr: List[int]) -> int:
        target = arr[0] if arr else -1
        for i, val in enumerate(arr):
            if val == target:
                return i
        return -1
    
    def binary_search(arr: List[int]) -> int:
        arr = sorted(arr)
        target = arr[0] if arr else -1
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
    
    # åˆ›å»ºåˆ†æå™¨
    analyzer = AlgorithmAnalyzer()
    
    # å®šä¹‰ç®—æ³•
    algorithms = {
        "çº¿æ€§æœç´¢": linear_search,
        "äºŒåˆ†æœç´¢": binary_search
    }
    
    # åˆ†æå¤æ‚åº¦
    input_sizes = [100, 500, 1000, 5000, 10000]
    results = analyzer.compare_algorithms(algorithms, generate_random_list, input_sizes)
    
    # è¾“å‡ºç»“æœ
    for name, data in results.items():
        print(f"{name}: {data['complexity_estimate']}")
    
    return results

# æ‰§è¡Œç®—æ³•åˆ†æ
analysis_results = demonstrate_algorithm_analysis()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.01 è®¡ç®—å“²å­¦åŸºç¡€](./00.01-è®¡ç®—å“²å­¦åŸºç¡€.md)
- [00.02 å½¢å¼åŒ–æ€ç»´æ–¹æ³•](./00.02-å½¢å¼åŒ–æ€ç»´æ–¹æ³•.md)
- [02.02 ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02.02-ç®—æ³•ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Popper, K. (1959). The logic of scientific discovery. Routledge.
2. Kuhn, T. S. (1962). The structure of scientific revolutions. University of Chicago Press.
3. Fisher, R. A. (1925). Statistical methods for research workers. Oliver and Boyd.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0.0
