# 00. ç¼–ç¨‹è¯­è¨€å“²å­¦

## ğŸ“‹ æ¦‚è¿°

ç¼–ç¨‹è¯­è¨€å“²å­¦ç ”ç©¶ç¼–ç¨‹è¯­è¨€çš„æœ¬è´¨ã€è®¾è®¡åŸåˆ™å’Œè®¤çŸ¥åŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å“²å­¦è§’åº¦æ¢è®¨ç¼–ç¨‹è¯­è¨€çš„ç†è®ºåŸºç¡€ï¼Œä¸ºåç»­çš„å½¢å¼åŒ–åˆ†æå¥ å®šåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç¼–ç¨‹è¯­è¨€çš„æœ¬è´¨

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1.1** (ç¼–ç¨‹è¯­è¨€)
ç¼–ç¨‹è¯­è¨€æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{L} = (S, \Sigma, R, I)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯è¯­æ³•é›†åˆ (Syntax)
- $\Sigma$ æ˜¯è¯­ä¹‰é›†åˆ (Semantics)
- $R$ æ˜¯æ¨ç†è§„åˆ™é›†åˆ (Rules)
- $I$ æ˜¯è§£é‡Šå™¨é›†åˆ (Interpreters)

**å®šä¹‰ 1.1.2** (è¯­è¨€è¡¨è¾¾èƒ½åŠ›)
è¯­è¨€ $L_1$ çš„è¡¨è¾¾èƒ½åŠ›å¼ºäºè¯­è¨€ $L_2$ï¼Œè®°ä½œ $L_1 \succ L_2$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall p \in L_2, \exists p' \in L_1 : \text{Sem}(p) = \text{Sem}(p')$$

å…¶ä¸­ $\text{Sem}(p)$ è¡¨ç¤ºç¨‹åº $p$ çš„è¯­ä¹‰ã€‚

#### 1.2 Pythonå®ç°

```python
from typing import TypeVar, Generic, Dict, Any, List, Callable, Set
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import re

T = TypeVar('T')

class LanguageType(Enum):
    """ç¼–ç¨‹è¯­è¨€ç±»å‹"""
    IMPERATIVE = "imperative"
    FUNCTIONAL = "functional"
    LOGIC = "logic"
    OBJECT_ORIENTED = "object_oriented"
    DECLARATIVE = "declarative"

@dataclass
class SyntaxRule:
    """è¯­æ³•è§„åˆ™"""
    name: str
    pattern: str
    precedence: int
    associativity: str  # 'left', 'right', 'none'

@dataclass
class SemanticRule:
    """è¯­ä¹‰è§„åˆ™"""
    name: str
    input_types: List[str]
    output_type: str
    behavior: Callable[..., Any]

class ProgrammingLanguage:
    """ç¼–ç¨‹è¯­è¨€æŠ½è±¡ç±»"""
    
    def __init__(self, name: str, language_type: LanguageType):
        self.name = name
        self.language_type = language_type
        self.syntax_rules: List[SyntaxRule] = []
        self.semantic_rules: List[SemanticRule] = []
        self.inference_rules: List[Callable] = []
        self.interpreters: List[Callable] = []
    
    def add_syntax_rule(self, rule: SyntaxRule) -> None:
        """æ·»åŠ è¯­æ³•è§„åˆ™"""
        self.syntax_rules.append(rule)
    
    def add_semantic_rule(self, rule: SemanticRule) -> None:
        """æ·»åŠ è¯­ä¹‰è§„åˆ™"""
        self.semantic_rules.append(rule)
    
    def parse(self, code: str) -> Any:
        """è§£æä»£ç """
        # åŸºç¡€è§£æå®ç°
        tokens = self._tokenize(code)
        ast = self._build_ast(tokens)
        return ast
    
    def _tokenize(self, code: str) -> List[str]:
        """è¯æ³•åˆ†æ"""
        # ç®€åŒ–çš„è¯æ³•åˆ†æ
        return re.findall(r'\w+|[^\w\s]', code)
    
    def _build_ast(self, tokens: List[str]) -> Dict[str, Any]:
        """æ„å»ºæŠ½è±¡è¯­æ³•æ ‘"""
        # ç®€åŒ–çš„ASTæ„å»º
        return {"type": "program", "tokens": tokens}
    
    def execute(self, ast: Any) -> Any:
        """æ‰§è¡ŒAST"""
        # åŸºç¡€æ‰§è¡Œå®ç°
        return {"result": "executed", "ast": ast}
    
    def expressiveness(self, other: 'ProgrammingLanguage') -> str:
        """æ¯”è¾ƒè¡¨è¾¾èƒ½åŠ›"""
        # ç®€åŒ–çš„è¡¨è¾¾èƒ½åŠ›æ¯”è¾ƒ
        if len(self.semantic_rules) > len(other.semantic_rules):
            return f"{self.name} > {other.name}"
        elif len(self.semantic_rules) < len(other.semantic_rules):
            return f"{self.name} < {other.name}"
        else:
            return f"{self.name} = {other.name}"

# ç¤ºä¾‹ï¼šPythonè¯­è¨€å®šä¹‰
python_language = ProgrammingLanguage("Python", LanguageType.OBJECT_ORIENTED)

# æ·»åŠ è¯­æ³•è§„åˆ™
python_language.add_syntax_rule(SyntaxRule(
    name="function_definition",
    pattern=r"def\s+\w+\s*\([^)]*\)\s*:",
    precedence=1,
    associativity="none"
))

# æ·»åŠ è¯­ä¹‰è§„åˆ™
python_language.add_semantic_rule(SemanticRule(
    name="function_call",
    input_types=["function", "arguments"],
    output_type="value",
    behavior=lambda func, args: func(*args)
))
```

### 2. è¯­è¨€è®¾è®¡åŸåˆ™

#### 2.1 æ­£äº¤æ€§åŸåˆ™

**å®šä¹‰ 2.1.1** (æ­£äº¤æ€§)
è¯­è¨€ç‰¹æ€§ $f_1, f_2$ æ˜¯æ­£äº¤çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall c_1, c_2 \in \text{Context}, f_1(c_1) \cap f_2(c_2) = \emptyset$$

**Pythonå®ç°**ï¼š

```python
class OrthogonalityPrinciple:
    """æ­£äº¤æ€§åŸåˆ™"""
    
    def __init__(self):
        self.features: Set[str] = set()
        self.interactions: Dict[str, Set[str]] = {}
    
    def add_feature(self, feature: str) -> None:
        """æ·»åŠ è¯­è¨€ç‰¹æ€§"""
        self.features.add(feature)
        self.interactions[feature] = set()
    
    def add_interaction(self, feature1: str, feature2: str) -> None:
        """æ·»åŠ ç‰¹æ€§äº¤äº’"""
        if feature1 in self.interactions:
            self.interactions[feature1].add(feature2)
        if feature2 in self.interactions:
            self.interactions[feature2].add(feature1)
    
    def is_orthogonal(self, feature1: str, feature2: str) -> bool:
        """æ£€æŸ¥ç‰¹æ€§æ˜¯å¦æ­£äº¤"""
        return feature2 not in self.interactions.get(feature1, set())
    
    def calculate_orthogonality_score(self) -> float:
        """è®¡ç®—æ­£äº¤æ€§å¾—åˆ†"""
        total_pairs = len(self.features) * (len(self.features) - 1) // 2
        if total_pairs == 0:
            return 1.0
        
        orthogonal_pairs = 0
        for f1 in self.features:
            for f2 in self.features:
                if f1 != f2 and self.is_orthogonal(f1, f2):
                    orthogonal_pairs += 1
        
        return orthogonal_pairs / (2 * total_pairs)

# ç¤ºä¾‹ï¼šPythonç‰¹æ€§æ­£äº¤æ€§åˆ†æ
python_orthogonality = OrthogonalityPrinciple()

# æ·»åŠ Pythonç‰¹æ€§
python_orthogonality.add_feature("functions")
python_orthogonality.add_feature("classes")
python_orthogonality.add_feature("modules")
python_orthogonality.add_feature("decorators")

# æ·»åŠ äº¤äº’å…³ç³»
python_orthogonality.add_interaction("functions", "decorators")
python_orthogonality.add_interaction("classes", "decorators")

print(f"Pythonæ­£äº¤æ€§å¾—åˆ†: {python_orthogonality.calculate_orthogonality_score():.2f}")
```

#### 2.2 ä¸€è‡´æ€§åŸåˆ™

**å®šä¹‰ 2.2.1** (ä¸€è‡´æ€§)
è¯­è¨€çš„ä¸€è‡´æ€§å®šä¹‰ä¸ºï¼š
$$\text{Consistency}(L) = 1 - \frac{\sum_{i,j} \text{Distance}(f_i, f_j)}{n(n-1)/2}$$

å…¶ä¸­ $f_i, f_j$ æ˜¯è¯­è¨€ç‰¹æ€§ï¼Œ$\text{Distance}$ æ˜¯ç‰¹æ€§é—´çš„è·ç¦»åº¦é‡ã€‚

**Pythonå®ç°**ï¼š

```python
class ConsistencyPrinciple:
    """ä¸€è‡´æ€§åŸåˆ™"""
    
    def __init__(self):
        self.features: List[str] = []
        self.patterns: Dict[str, str] = {}
    
    def add_feature(self, feature: str, pattern: str) -> None:
        """æ·»åŠ ç‰¹æ€§å’Œæ¨¡å¼"""
        self.features.append(feature)
        self.patterns[feature] = pattern
    
    def calculate_distance(self, feature1: str, feature2: str) -> float:
        """è®¡ç®—ç‰¹æ€§é—´è·ç¦»"""
        pattern1 = self.patterns.get(feature1, "")
        pattern2 = self.patterns.get(feature2, "")
        
        # ä½¿ç”¨ç¼–è¾‘è·ç¦»ä½œä¸ºç›¸ä¼¼æ€§åº¦é‡
        return self._edit_distance(pattern1, pattern2)
    
    def _edit_distance(self, s1: str, s2: str) -> float:
        """è®¡ç®—ç¼–è¾‘è·ç¦»"""
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        
        return dp[m][n] / max(m, n, 1)
    
    def calculate_consistency_score(self) -> float:
        """è®¡ç®—ä¸€è‡´æ€§å¾—åˆ†"""
        if len(self.features) < 2:
            return 1.0
        
        total_distance = 0
        pair_count = 0
        
        for i in range(len(self.features)):
            for j in range(i + 1, len(self.features)):
                distance = self.calculate_distance(self.features[i], self.features[j])
                total_distance += distance
                pair_count += 1
        
        if pair_count == 0:
            return 1.0
        
        average_distance = total_distance / pair_count
        return max(0.0, 1.0 - average_distance)

# ç¤ºä¾‹ï¼šPythonä¸€è‡´æ€§åˆ†æ
python_consistency = ConsistencyPrinciple()

# æ·»åŠ Pythonç‰¹æ€§å’Œæ¨¡å¼
python_consistency.add_feature("function_def", "def name(args):")
python_consistency.add_feature("class_def", "class Name:")
python_consistency.add_feature("if_statement", "if condition:")
python_consistency.add_feature("for_loop", "for item in items:")

print(f"Pythonä¸€è‡´æ€§å¾—åˆ†: {python_consistency.calculate_consistency_score():.2f}")
```

### 3. è®¤çŸ¥æ¨¡å‹

#### 3.1 å¿ƒæ™ºæ¨¡å‹

**å®šä¹‰ 3.1.1** (å¿ƒæ™ºæ¨¡å‹)
ç¼–ç¨‹è¯­è¨€çš„å¿ƒæ™ºæ¨¡å‹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{M} = (C, R, I)$ï¼Œå…¶ä¸­ï¼š

- $C$ æ˜¯æ¦‚å¿µé›†åˆ (Concepts)
- $R$ æ˜¯å…³ç³»é›†åˆ (Relations)
- $I$ æ˜¯æ¨ç†è§„åˆ™é›†åˆ (Inference Rules)

**Pythonå®ç°**ï¼š

```python
class MentalModel:
    """å¿ƒæ™ºæ¨¡å‹"""
    
    def __init__(self, language_name: str):
        self.language_name = language_name
        self.concepts: Dict[str, str] = {}
        self.relations: List[tuple] = []
        self.inference_rules: List[Callable] = []
    
    def add_concept(self, name: str, description: str) -> None:
        """æ·»åŠ æ¦‚å¿µ"""
        self.concepts[name] = description
    
    def add_relation(self, concept1: str, relation: str, concept2: str) -> None:
        """æ·»åŠ å…³ç³»"""
        self.relations.append((concept1, relation, concept2))
    
    def add_inference_rule(self, rule: Callable) -> None:
        """æ·»åŠ æ¨ç†è§„åˆ™"""
        self.inference_rules.append(rule)
    
    def get_related_concepts(self, concept: str) -> List[str]:
        """è·å–ç›¸å…³æ¦‚å¿µ"""
        related = []
        for c1, rel, c2 in self.relations:
            if c1 == concept:
                related.append(c2)
            elif c2 == concept:
                related.append(c1)
        return related
    
    def infer(self, context: Dict[str, Any]) -> List[str]:
        """æ¨ç†"""
        results = []
        for rule in self.inference_rules:
            try:
                result = rule(context)
                if result:
                    results.append(result)
            except Exception:
                continue
        return results

# ç¤ºä¾‹ï¼šPythonå¿ƒæ™ºæ¨¡å‹
python_mental_model = MentalModel("Python")

# æ·»åŠ æ¦‚å¿µ
python_mental_model.add_concept("object", "ä¸€åˆ‡çš†å¯¹è±¡")
python_mental_model.add_concept("function", "å¯è°ƒç”¨çš„å¯¹è±¡")
python_mental_model.add_concept("class", "å¯¹è±¡çš„æ¨¡æ¿")
python_mental_model.add_concept("module", "ä»£ç ç»„ç»‡å•ä½")

# æ·»åŠ å…³ç³»
python_mental_model.add_relation("object", "is_instance_of", "class")
python_mental_model.add_relation("function", "is_a", "object")
python_mental_model.add_relation("class", "is_a", "object")
python_mental_model.add_relation("module", "contains", "function")

# æ·»åŠ æ¨ç†è§„åˆ™
def object_inference(context: Dict[str, Any]) -> str:
    """å¯¹è±¡æ¨ç†è§„åˆ™"""
    if "value" in context:
        return f"{context['value']} æ˜¯ä¸€ä¸ªå¯¹è±¡"
    return ""

python_mental_model.add_inference_rule(object_inference)

# ä½¿ç”¨å¿ƒæ™ºæ¨¡å‹
context = {"value": 42}
inferences = python_mental_model.infer(context)
print(f"æ¨ç†ç»“æœ: {inferences}")
```

### 4. æŠ½è±¡å±‚æ¬¡

#### 4.1 æŠ½è±¡å±‚æ¬¡ç†è®º

**å®šä¹‰ 4.1.1** (æŠ½è±¡å±‚æ¬¡)
æŠ½è±¡å±‚æ¬¡æ˜¯ä¸€ä¸ªååºé›† $(L, \preceq)$ï¼Œå…¶ä¸­ï¼š

- $L$ æ˜¯å±‚æ¬¡é›†åˆ
- $\preceq$ æ˜¯æŠ½è±¡å…³ç³»ï¼Œ$l_1 \preceq l_2$ è¡¨ç¤º $l_1$ æ¯” $l_2$ æ›´æŠ½è±¡

**Pythonå®ç°**ï¼š

```python
from typing import Optional, List, Dict, Any
from enum import Enum

class AbstractionLevel(Enum):
    """æŠ½è±¡å±‚æ¬¡æšä¸¾"""
    CONCRETE = 0
    ABSTRACT = 1
    VERY_ABSTRACT = 2

@dataclass
class AbstractionLayer:
    """æŠ½è±¡å±‚æ¬¡"""
    name: str
    level: AbstractionLevel
    concepts: List[str]
    parent: Optional['AbstractionLayer'] = None
    children: List['AbstractionLayer'] = None
    
    def __post_init__(self):
        if self.children is None:
            self.children = []

class HierarchicalAbstraction:
    """å±‚æ¬¡åŒ–æŠ½è±¡ç³»ç»Ÿ"""
    
    def __init__(self):
        self.layers: Dict[str, AbstractionLayer] = {}
        self.root: Optional[AbstractionLayer] = None
    
    def add_layer(self, layer: AbstractionLayer) -> None:
        """æ·»åŠ å±‚æ¬¡"""
        self.layers[layer.name] = layer
        if layer.level == AbstractionLevel.CONCRETE:
            self.root = layer
    
    def add_child(self, parent_name: str, child: AbstractionLayer) -> None:
        """æ·»åŠ å­å±‚æ¬¡"""
        if parent_name in self.layers:
            parent = self.layers[parent_name]
            child.parent = parent
            parent.children.append(child)
            self.layers[child.name] = child
    
    def abstract_concept(self, concept: str, target_level: AbstractionLevel) -> str:
        """æ¦‚å¿µæŠ½è±¡åŒ–"""
        # ç®€åŒ–çš„æŠ½è±¡åŒ–è¿‡ç¨‹
        abstractions = {
            "int": "number",
            "float": "number", 
            "str": "text",
            "list": "collection",
            "dict": "mapping",
            "function": "procedure"
        }
        
        if target_level == AbstractionLevel.ABSTRACT:
            return abstractions.get(concept, concept)
        elif target_level == AbstractionLevel.VERY_ABSTRACT:
            return "entity"
        else:
            return concept
    
    def get_abstraction_path(self, concept: str) -> List[str]:
        """è·å–æŠ½è±¡è·¯å¾„"""
        path = [concept]
        
        # æŠ½è±¡åŒ–è·¯å¾„
        abstract = self.abstract_concept(concept, AbstractionLevel.ABSTRACT)
        if abstract != concept:
            path.append(abstract)
        
        very_abstract = self.abstract_concept(concept, AbstractionLevel.VERY_ABSTRACT)
        if very_abstract != abstract:
            path.append(very_abstract)
        
        return path

# ç¤ºä¾‹ï¼šç¼–ç¨‹è¯­è¨€æŠ½è±¡å±‚æ¬¡
programming_abstraction = HierarchicalAbstraction()

# å…·ä½“å±‚æ¬¡
concrete = AbstractionLayer(
    name="Concrete",
    level=AbstractionLevel.CONCRETE,
    concepts=["int", "string", "list", "function"]
)

# æŠ½è±¡å±‚æ¬¡
abstract = AbstractionLayer(
    name="Abstract", 
    level=AbstractionLevel.ABSTRACT,
    concepts=["number", "text", "collection", "procedure"]
)

# éå¸¸æŠ½è±¡å±‚æ¬¡
very_abstract = AbstractionLayer(
    name="VeryAbstract",
    level=AbstractionLevel.VERY_ABSTRACT,
    concepts=["entity", "relationship", "behavior"]
)

programming_abstraction.add_layer(concrete)
programming_abstraction.add_child("Concrete", abstract)
programming_abstraction.add_child("Abstract", very_abstract)

# æ¼”ç¤ºæŠ½è±¡åŒ–
concept = "int"
abstracted = programming_abstraction.abstract_concept(concept, AbstractionLevel.ABSTRACT)
very_abstracted = programming_abstraction.abstract_concept(concept, AbstractionLevel.VERY_ABSTRACT)

print(f"åŸå§‹æ¦‚å¿µ: {concept}")
print(f"æŠ½è±¡åŒ–: {abstracted}")
print(f"é«˜åº¦æŠ½è±¡åŒ–: {very_abstracted}")
```

## ğŸ“š ç†è®ºè¯æ˜

### 1. è¯­è¨€è¡¨è¾¾èƒ½åŠ›å®šç†

**å®šç† 1.1** (å›¾çµå®Œå¤‡æ€§)
å¦‚æœè¯­è¨€ $L$ èƒ½å¤Ÿæ¨¡æ‹Ÿå›¾çµæœºï¼Œåˆ™ $L$ æ˜¯å›¾çµå®Œå¤‡çš„ã€‚

**è¯æ˜**ï¼š
è®¾ $M$ æ˜¯ä»»æ„å›¾çµæœºï¼Œ$L$ æ˜¯ç›®æ ‡è¯­è¨€ã€‚

1. æ„é€ å›¾çµæœºçš„çŠ¶æ€è¡¨ç¤º
2. å®ç°çŠ¶æ€è½¬ç§»å‡½æ•°
3. æ¨¡æ‹Ÿç£å¸¦æ“ä½œ
4. å› æ­¤ $L$ å¯ä»¥æ¨¡æ‹Ÿä»»æ„å›¾çµæœº

### 2. æŠ½è±¡å±‚æ¬¡å®šç†

**å®šç† 2.1** (æŠ½è±¡å±‚æ¬¡å­˜åœ¨æ€§)
å¯¹äºä»»æ„ç¼–ç¨‹è¯­è¨€ï¼Œå­˜åœ¨å”¯ä¸€çš„æŠ½è±¡å±‚æ¬¡ç»“æ„ã€‚

**è¯æ˜**ï¼š

1. æ„é€ å…·ä½“å±‚æ¬¡ï¼ˆæœºå™¨ç çº§åˆ«ï¼‰
2. é€’å½’æ„é€ æŠ½è±¡å±‚æ¬¡
3. è¯æ˜å±‚æ¬¡é—´çš„ååºå…³ç³»
4. å› æ­¤æŠ½è±¡å±‚æ¬¡ç»“æ„å­˜åœ¨ä¸”å”¯ä¸€

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [å½¢å¼åŒ–æ€ç»´æ–¹æ³•](../01-å½¢å¼åŒ–æ€ç»´/00-å½¢å¼åŒ–æ€ç»´åŸºç¡€.md)
- [è®¡ç®—æ€ç»´åŸºç¡€](../02-è®¡ç®—æ€ç»´/00-è®¡ç®—æ€ç»´åŸºç¡€.md)
- [æ•°å­¦åŸºç¡€](../../01-å½¢å¼ç§‘å­¦/01-æ•°å­¦åŸºç¡€/00-æ•°å­¦åŸºç¡€.md)

## ğŸ“– å‚è€ƒæ–‡çŒ®

1. Abelson, H., & Sussman, G. J. (1996). Structure and Interpretation of Computer Programs
2. Pierce, B. C. (2002). Types and Programming Languages
3. Scott, M. L. (2015). Programming Language Pragmatics
4. Van Roy, P., & Haridi, S. (2004). Concepts, Techniques, and Models of Computer Programming

---

*ç¼–ç¨‹è¯­è¨€å“²å­¦ä¸ºç†è§£ç¼–ç¨‹è¯­è¨€çš„æœ¬è´¨å’Œè®¾è®¡åŸåˆ™æä¾›äº†ç†è®ºåŸºç¡€ï¼Œæ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„é‡è¦åŸºç¡€ã€‚*
