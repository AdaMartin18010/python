# 00-03-è®¡ç®—æ€ç»´

## ğŸ“‹ æ¦‚è¿°

è®¡ç®—æ€ç»´æ˜¯ä¸€ç§è§£å†³é—®é¢˜çš„æ€ç»´æ–¹å¼ï¼Œå®ƒè¿ç”¨è®¡ç®—æœºç§‘å­¦çš„åŸºæœ¬æ¦‚å¿µæ¥åˆ†æå’Œè§£å†³å¤æ‚é—®é¢˜ã€‚è®¡ç®—æ€ç»´åŒ…æ‹¬æŠ½è±¡ã€åˆ†è§£ã€æ¨¡å¼è¯†åˆ«ã€ç®—æ³•è®¾è®¡ç­‰æ ¸å¿ƒæŠ€èƒ½ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é—®é¢˜åˆ†è§£ (Problem Decomposition)

**æ¦‚å¿µå®šä¹‰**: å°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºæ›´å°ã€æ›´æ˜“å¤„ç†çš„å­é—®é¢˜çš„è¿‡ç¨‹ã€‚

**æ•°å­¦å½¢å¼**:
é—®é¢˜åˆ†è§£å¯ä»¥å½¢å¼åŒ–ä¸ºï¼š

$$P = \{p_1, p_2, ..., p_n\}$$

å…¶ä¸­ï¼š

- $P$ æ˜¯åŸå§‹é—®é¢˜
- $p_i$ æ˜¯å­é—®é¢˜
- æ»¡è¶³ï¼š$Solution(P) = Combine(Solution(p_1), Solution(p_2), ..., Solution(p_n))$

**Pythonå®ç°**:

```python
from typing import List, Dict, Any, Callable, TypeVar, Generic
from dataclasses import dataclass
from abc import ABC, abstractmethod
import math

T = TypeVar('T')
R = TypeVar('R')

@dataclass
class SubProblem:
    """å­é—®é¢˜å®šä¹‰"""
    id: str
    description: str
    complexity: float
    dependencies: List[str]
    solution: Any = None

@dataclass
class Problem:
    """é—®é¢˜å®šä¹‰"""
    id: str
    description: str
    complexity: float
    sub_problems: List[SubProblem]
    decomposition_strategy: str

class ProblemDecomposer:
    """é—®é¢˜åˆ†è§£å™¨"""
    
    def __init__(self):
        self.decomposition_strategies = {
            'functional': self._functional_decomposition,
            'data': self._data_decomposition,
            'temporal': self._temporal_decomposition,
            'spatial': self._spatial_decomposition,
            'hierarchical': self._hierarchical_decomposition
        }
    
    def decompose(self, problem_description: str, complexity: float, 
                  strategy: str = 'functional') -> Problem:
        """åˆ†è§£é—®é¢˜"""
        if strategy not in self.decomposition_strategies:
            raise ValueError(f"æœªçŸ¥çš„åˆ†è§£ç­–ç•¥: {strategy}")
        
        decomposer = self.decomposition_strategies[strategy]
        sub_problems = decomposer(problem_description, complexity)
        
        return Problem(
            id=f"problem_{len(sub_problems)}",
            description=problem_description,
            complexity=complexity,
            sub_problems=sub_problems,
            decomposition_strategy=strategy
        )
    
    def _functional_decomposition(self, description: str, complexity: float) -> List[SubProblem]:
        """åŠŸèƒ½åˆ†è§£"""
        sub_problems = []
        
        # åŸºäºåŠŸèƒ½æ¨¡å—åˆ†è§£
        functions = self._extract_functions(description)
        sub_complexity = complexity / len(functions)
        
        for i, func in enumerate(functions):
            sub_problems.append(SubProblem(
                id=f"func_{i+1}",
                description=f"å®ç°{func}åŠŸèƒ½",
                complexity=sub_complexity,
                dependencies=[]
            ))
        
        return sub_problems
    
    def _data_decomposition(self, description: str, complexity: float) -> List[SubProblem]:
        """æ•°æ®åˆ†è§£"""
        sub_problems = []
        
        # åŸºäºæ•°æ®æµåˆ†è§£
        data_components = self._extract_data_components(description)
        sub_complexity = complexity / len(data_components)
        
        for i, component in enumerate(data_components):
            sub_problems.append(SubProblem(
                id=f"data_{i+1}",
                description=f"å¤„ç†{component}æ•°æ®",
                complexity=sub_complexity,
                dependencies=[f"data_{j+1}" for j in range(i)]
            ))
        
        return sub_problems
    
    def _temporal_decomposition(self, description: str, complexity: float) -> List[SubProblem]:
        """æ—¶é—´åˆ†è§£"""
        sub_problems = []
        
        # åŸºäºæ—¶é—´é˜¶æ®µåˆ†è§£
        phases = self._extract_phases(description)
        sub_complexity = complexity / len(phases)
        
        for i, phase in enumerate(phases):
            sub_problems.append(SubProblem(
                id=f"phase_{i+1}",
                description=f"æ‰§è¡Œ{phase}é˜¶æ®µ",
                complexity=sub_complexity,
                dependencies=[f"phase_{j+1}" for j in range(i)]
            ))
        
        return sub_problems
    
    def _spatial_decomposition(self, description: str, complexity: float) -> List[SubProblem]:
        """ç©ºé—´åˆ†è§£"""
        sub_problems = []
        
        # åŸºäºç©ºé—´åŒºåŸŸåˆ†è§£
        regions = self._extract_regions(description)
        sub_complexity = complexity / len(regions)
        
        for i, region in enumerate(regions):
            sub_problems.append(SubProblem(
                id=f"region_{i+1}",
                description=f"å¤„ç†{region}åŒºåŸŸ",
                complexity=sub_complexity,
                dependencies=[]
            ))
        
        return sub_problems
    
    def _hierarchical_decomposition(self, description: str, complexity: float) -> List[SubProblem]:
        """å±‚æ¬¡åˆ†è§£"""
        sub_problems = []
        
        # åŸºäºæŠ½è±¡å±‚æ¬¡åˆ†è§£
        levels = self._extract_abstraction_levels(description)
        sub_complexity = complexity / len(levels)
        
        for i, level in enumerate(levels):
            sub_problems.append(SubProblem(
                id=f"level_{i+1}",
                description=f"å®ç°{level}å±‚æ¬¡",
                complexity=sub_complexity,
                dependencies=[f"level_{j+1}" for j in range(i)]
            ))
        
        return sub_problems
    
    def _extract_functions(self, description: str) -> List[str]:
        """æå–åŠŸèƒ½æ¨¡å—"""
        # ç®€åŒ–çš„åŠŸèƒ½æå–
        function_keywords = ['å¤„ç†', 'è®¡ç®—', 'åˆ†æ', 'ç”Ÿæˆ', 'éªŒè¯', 'è½¬æ¢', 'å­˜å‚¨']
        functions = []
        
        for keyword in function_keywords:
            if keyword in description:
                functions.append(keyword)
        
        return functions if functions else ['ä¸»è¦åŠŸèƒ½']
    
    def _extract_data_components(self, description: str) -> List[str]:
        """æå–æ•°æ®ç»„ä»¶"""
        # ç®€åŒ–çš„æ•°æ®ç»„ä»¶æå–
        data_keywords = ['è¾“å…¥', 'è¾“å‡º', 'ä¸­é—´ç»“æœ', 'é…ç½®', 'çŠ¶æ€']
        components = []
        
        for keyword in data_keywords:
            if keyword in description:
                components.append(keyword)
        
        return components if components else ['æ•°æ®']
    
    def _extract_phases(self, description: str) -> List[str]:
        """æå–æ—¶é—´é˜¶æ®µ"""
        # ç®€åŒ–çš„é˜¶æ®µæå–
        phase_keywords = ['åˆå§‹åŒ–', 'å¤„ç†', 'éªŒè¯', 'è¾“å‡º', 'æ¸…ç†']
        phases = []
        
        for keyword in phase_keywords:
            if keyword in description:
                phases.append(keyword)
        
        return phases if phases else ['é˜¶æ®µ1', 'é˜¶æ®µ2']
    
    def _extract_regions(self, description: str) -> List[str]:
        """æå–ç©ºé—´åŒºåŸŸ"""
        # ç®€åŒ–çš„åŒºåŸŸæå–
        return ['åŒºåŸŸ1', 'åŒºåŸŸ2', 'åŒºåŸŸ3']
    
    def _extract_abstraction_levels(self, description: str) -> List[str]:
        """æå–æŠ½è±¡å±‚æ¬¡"""
        # ç®€åŒ–çš„æŠ½è±¡å±‚æ¬¡æå–
        return ['é«˜å±‚', 'ä¸­å±‚', 'ä½å±‚']

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_problem_decomposition():
    """æ¼”ç¤ºé—®é¢˜åˆ†è§£"""
    decomposer = ProblemDecomposer()
    
    # å¤æ‚é—®é¢˜æè¿°
    complex_problem = "è®¾è®¡ä¸€ä¸ªåœ¨çº¿è´­ç‰©ç³»ç»Ÿï¼Œéœ€è¦å¤„ç†ç”¨æˆ·æ³¨å†Œã€å•†å“ç®¡ç†ã€è®¢å•å¤„ç†å’Œæ”¯ä»˜åŠŸèƒ½"
    
    print("=== é—®é¢˜åˆ†è§£æ¼”ç¤º ===")
    print(f"åŸå§‹é—®é¢˜: {complex_problem}")
    print(f"å¤æ‚åº¦: 8.5")
    
    # ä¸åŒç­–ç•¥çš„åˆ†è§£
    strategies = ['functional', 'data', 'temporal', 'spatial', 'hierarchical']
    
    for strategy in strategies:
        print(f"\n--- {strategy.upper()} åˆ†è§£ ---")
        problem = decomposer.decompose(complex_problem, 8.5, strategy)
        
        print(f"åˆ†è§£ç­–ç•¥: {problem.decomposition_strategy}")
        print(f"å­é—®é¢˜æ•°é‡: {len(problem.sub_problems)}")
        
        for sub_problem in problem.sub_problems:
            print(f"  {sub_problem.id}: {sub_problem.description} (å¤æ‚åº¦: {sub_problem.complexity:.1f})")
```

### 2. æ¨¡å¼è¯†åˆ« (Pattern Recognition)

**æ¦‚å¿µå®šä¹‰**: è¯†åˆ«é—®é¢˜ä¸­é‡å¤å‡ºç°çš„ç»“æ„å’Œæ¨¡å¼ï¼Œä»¥ä¾¿å¤ç”¨è§£å†³æ–¹æ¡ˆã€‚

**æ•°å­¦å½¢å¼**:
æ¨¡å¼è¯†åˆ«å¯ä»¥å½¢å¼åŒ–ä¸ºï¼š

$$Pattern(S) = \{p_1, p_2, ..., p_n\}$$

å…¶ä¸­ï¼š

- $S$ æ˜¯é—®é¢˜é›†åˆ
- $p_i$ æ˜¯è¯†åˆ«å‡ºçš„æ¨¡å¼
- æ»¡è¶³ï¼š$Similarity(s_i, s_j) > \theta \Rightarrow SamePattern(s_i, s_j)$

**Pythonå®ç°**:

```python
from typing import List, Dict, Set, Tuple, Any
from dataclasses import dataclass
from collections import defaultdict
import re
from difflib import SequenceMatcher

@dataclass
class Pattern:
    """æ¨¡å¼å®šä¹‰"""
    name: str
    structure: str
    frequency: int
    examples: List[str]
    solution_template: str

class PatternRecognizer:
    """æ¨¡å¼è¯†åˆ«å™¨"""
    
    def __init__(self):
        self.patterns: Dict[str, Pattern] = {}
        self.similarity_threshold = 0.7
        self.pattern_templates = {
            'sorting': self._detect_sorting_pattern,
            'searching': self._detect_searching_pattern,
            'iteration': self._detect_iteration_pattern,
            'recursion': self._detect_recursion_pattern,
            'dynamic_programming': self._detect_dp_pattern,
            'graph_traversal': self._detect_graph_pattern,
            'divide_conquer': self._detect_divide_conquer_pattern
        }
    
    def recognize_patterns(self, problems: List[str]) -> List[Pattern]:
        """è¯†åˆ«é—®é¢˜ä¸­çš„æ¨¡å¼"""
        recognized_patterns = []
        
        # å¯¹æ¯ä¸ªé—®é¢˜åº”ç”¨æ¨¡å¼æ£€æµ‹
        for problem in problems:
            for pattern_name, detector in self.pattern_templates.items():
                if detector(problem):
                    pattern = self._create_pattern(pattern_name, problem)
                    recognized_patterns.append(pattern)
        
        # åˆå¹¶ç›¸ä¼¼æ¨¡å¼
        merged_patterns = self._merge_similar_patterns(recognized_patterns)
        
        return merged_patterns
    
    def _detect_sorting_pattern(self, problem: str) -> bool:
        """æ£€æµ‹æ’åºæ¨¡å¼"""
        sorting_keywords = ['æ’åº', 'sort', 'order', 'arrange', 'organize']
        return any(keyword in problem.lower() for keyword in sorting_keywords)
    
    def _detect_searching_pattern(self, problem: str) -> bool:
        """æ£€æµ‹æœç´¢æ¨¡å¼"""
        search_keywords = ['æœç´¢', 'search', 'find', 'locate', 'discover']
        return any(keyword in problem.lower() for keyword in search_keywords)
    
    def _detect_iteration_pattern(self, problem: str) -> bool:
        """æ£€æµ‹è¿­ä»£æ¨¡å¼"""
        iteration_keywords = ['å¾ªç¯', 'loop', 'iterate', 'repeat', 'traverse']
        return any(keyword in problem.lower() for keyword in iteration_keywords)
    
    def _detect_recursion_pattern(self, problem: str) -> bool:
        """æ£€æµ‹é€’å½’æ¨¡å¼"""
        recursion_keywords = ['é€’å½’', 'recursion', 'recursive', 'self-calling']
        return any(keyword in problem.lower() for keyword in recursion_keywords)
    
    def _detect_dp_pattern(self, problem: str) -> bool:
        """æ£€æµ‹åŠ¨æ€è§„åˆ’æ¨¡å¼"""
        dp_keywords = ['æœ€ä¼˜', 'optimal', 'maximum', 'minimum', 'best', 'worst']
        return any(keyword in problem.lower() for keyword in dp_keywords)
    
    def _detect_graph_pattern(self, problem: str) -> bool:
        """æ£€æµ‹å›¾è®ºæ¨¡å¼"""
        graph_keywords = ['å›¾', 'graph', 'network', 'path', 'route', 'connection']
        return any(keyword in problem.lower() for keyword in graph_keywords)
    
    def _detect_divide_conquer_pattern(self, problem: str) -> bool:
        """æ£€æµ‹åˆ†æ²»æ¨¡å¼"""
        dc_keywords = ['åˆ†æ²»', 'divide', 'conquer', 'split', 'merge', 'combine']
        return any(keyword in problem.lower() for keyword in dc_keywords)
    
    def _create_pattern(self, pattern_name: str, example: str) -> Pattern:
        """åˆ›å»ºæ¨¡å¼å¯¹è±¡"""
        return Pattern(
            name=pattern_name,
            structure=self._extract_structure(example),
            frequency=1,
            examples=[example],
            solution_template=self._get_solution_template(pattern_name)
        )
    
    def _extract_structure(self, problem: str) -> str:
        """æå–é—®é¢˜ç»“æ„"""
        # ç®€åŒ–çš„ç»“æ„æå–
        words = problem.lower().split()
        structure_words = []
        
        for word in words:
            if len(word) > 3:  # è¿‡æ»¤çŸ­è¯
                structure_words.append(word)
        
        return ' '.join(structure_words[:5])  # å–å‰5ä¸ªè¯ä½œä¸ºç»“æ„
    
    def _get_solution_template(self, pattern_name: str) -> str:
        """è·å–è§£å†³æ–¹æ¡ˆæ¨¡æ¿"""
        templates = {
            'sorting': 'ä½¿ç”¨æ’åºç®—æ³•ï¼ˆå¦‚å¿«é€Ÿæ’åºã€å½’å¹¶æ’åºï¼‰',
            'searching': 'ä½¿ç”¨æœç´¢ç®—æ³•ï¼ˆå¦‚äºŒåˆ†æœç´¢ã€æ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰',
            'iteration': 'ä½¿ç”¨å¾ªç¯ç»“æ„å¤„ç†æ•°æ®',
            'recursion': 'ä½¿ç”¨é€’å½’å‡½æ•°è§£å†³é—®é¢˜',
            'dynamic_programming': 'ä½¿ç”¨åŠ¨æ€è§„åˆ’ä¼˜åŒ–é‡å å­é—®é¢˜',
            'graph_traversal': 'ä½¿ç”¨å›¾éå†ç®—æ³•ï¼ˆBFS/DFSï¼‰',
            'divide_conquer': 'å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œç„¶ååˆå¹¶ç»“æœ'
        }
        return templates.get(pattern_name, 'é€šç”¨è§£å†³æ–¹æ¡ˆ')
    
    def _merge_similar_patterns(self, patterns: List[Pattern]) -> List[Pattern]:
        """åˆå¹¶ç›¸ä¼¼æ¨¡å¼"""
        merged = []
        pattern_groups = defaultdict(list)
        
        # æŒ‰æ¨¡å¼åç§°åˆ†ç»„
        for pattern in patterns:
            pattern_groups[pattern.name].append(pattern)
        
        # åˆå¹¶æ¯ç»„ä¸­çš„æ¨¡å¼
        for pattern_name, group in pattern_groups.items():
            if len(group) == 1:
                merged.append(group[0])
            else:
                # åˆå¹¶å¤šä¸ªç›¸åŒç±»å‹çš„æ¨¡å¼
                merged_pattern = self._merge_pattern_group(group)
                merged.append(merged_pattern)
        
        return merged
    
    def _merge_pattern_group(self, group: List[Pattern]) -> Pattern:
        """åˆå¹¶æ¨¡å¼ç»„"""
        # åˆå¹¶é¢‘ç‡
        total_frequency = sum(p.frequency for p in group)
        
        # åˆå¹¶ç¤ºä¾‹
        all_examples = []
        for pattern in group:
            all_examples.extend(pattern.examples)
        
        # ä½¿ç”¨ç¬¬ä¸€ä¸ªæ¨¡å¼ä½œä¸ºåŸºç¡€
        base_pattern = group[0]
        
        return Pattern(
            name=base_pattern.name,
            structure=base_pattern.structure,
            frequency=total_frequency,
            examples=all_examples,
            solution_template=base_pattern.solution_template
        )
    
    def calculate_similarity(self, pattern1: Pattern, pattern2: Pattern) -> float:
        """è®¡ç®—æ¨¡å¼ç›¸ä¼¼åº¦"""
        # ç»“æ„ç›¸ä¼¼åº¦
        structure_similarity = SequenceMatcher(
            None, pattern1.structure, pattern2.structure
        ).ratio()
        
        # åç§°ç›¸ä¼¼åº¦
        name_similarity = 1.0 if pattern1.name == pattern2.name else 0.0
        
        # ç»¼åˆç›¸ä¼¼åº¦
        return (structure_similarity + name_similarity) / 2

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_pattern_recognition():
    """æ¼”ç¤ºæ¨¡å¼è¯†åˆ«"""
    recognizer = PatternRecognizer()
    
    # é—®é¢˜é›†åˆ
    problems = [
        "å¯¹æ•°ç»„è¿›è¡Œå¿«é€Ÿæ’åº",
        "åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´ ",
        "éå†äºŒå‰æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹",
        "è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—",
        "å¯»æ‰¾å›¾ä¸­çš„æœ€çŸ­è·¯å¾„",
        "å°†å¤§æ•°ç»„åˆ†æˆå°æ•°ç»„åˆ†åˆ«å¤„ç†",
        "å¯¹é“¾è¡¨è¿›è¡Œæ’åº",
        "åœ¨å›¾ä¸­æœç´¢è¿é€šåˆ†é‡"
    ]
    
    print("=== æ¨¡å¼è¯†åˆ«æ¼”ç¤º ===")
    print("é—®é¢˜é›†åˆ:")
    for i, problem in enumerate(problems, 1):
        print(f"  {i}. {problem}")
    
    # è¯†åˆ«æ¨¡å¼
    patterns = recognizer.recognize_patterns(problems)
    
    print(f"\nè¯†åˆ«å‡ºçš„æ¨¡å¼ ({len(patterns)} ä¸ª):")
    for pattern in patterns:
        print(f"\næ¨¡å¼: {pattern.name}")
        print(f"é¢‘ç‡: {pattern.frequency}")
        print(f"ç»“æ„: {pattern.structure}")
        print(f"è§£å†³æ–¹æ¡ˆ: {pattern.solution_template}")
        print(f"ç¤ºä¾‹: {pattern.examples[:2]}")  # æ˜¾ç¤ºå‰2ä¸ªç¤ºä¾‹
```

### 3. ç®—æ³•æ€ç»´ (Algorithmic Thinking)

**æ¦‚å¿µå®šä¹‰**: è®¾è®¡ã€åˆ†æå’Œä¼˜åŒ–ç®—æ³•çš„æ€ç»´æ–¹å¼ï¼ŒåŒ…æ‹¬ç®—æ³•è®¾è®¡ã€å¤æ‚åº¦åˆ†æå’Œæ€§èƒ½ä¼˜åŒ–ã€‚

**æ•°å­¦å½¢å¼**:
ç®—æ³•å¤æ‚åº¦å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$T(n) = O(f(n))$$

å…¶ä¸­ï¼š

- $T(n)$ æ˜¯ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦
- $f(n)$ æ˜¯è¾“å…¥è§„æ¨¡ $n$ çš„å‡½æ•°
- $O$ è¡¨ç¤ºå¤§Oç¬¦å·

**Pythonå®ç°**:

```python
from typing import List, Dict, Any, Callable, Tuple
from dataclasses import dataclass
from enum import Enum
import time
import random
import matplotlib.pyplot as plt
import numpy as np

class ComplexityClass(Enum):
    """å¤æ‚åº¦ç±»åˆ«"""
    CONSTANT = "O(1)"
    LOGARITHMIC = "O(log n)"
    LINEAR = "O(n)"
    LINE_LOG = "O(n log n)"
    QUADRATIC = "O(nÂ²)"
    CUBIC = "O(nÂ³)"
    EXPONENTIAL = "O(2â¿)"
    FACTORIAL = "O(n!)"

@dataclass
class AlgorithmAnalysis:
    """ç®—æ³•åˆ†æç»“æœ"""
    algorithm_name: str
    complexity_class: ComplexityClass
    best_case: str
    worst_case: str
    average_case: str
    space_complexity: str
    stability: bool
    in_place: bool

class AlgorithmicThinking:
    """ç®—æ³•æ€ç»´å®ç°"""
    
    def __init__(self):
        self.algorithms: Dict[str, Callable] = {}
        self.analysis_results: Dict[str, AlgorithmAnalysis] = {}
        self.performance_data: Dict[str, List[Tuple[int, float]]] = {}
    
    def register_algorithm(self, name: str, algorithm: Callable, 
                          analysis: AlgorithmAnalysis) -> None:
        """æ³¨å†Œç®—æ³•"""
        self.algorithms[name] = algorithm
        self.analysis_results[name] = analysis
    
    def analyze_performance(self, algorithm_name: str, 
                           input_sizes: List[int], 
                           iterations: int = 5) -> None:
        """åˆ†æç®—æ³•æ€§èƒ½"""
        if algorithm_name not in self.algorithms:
            raise ValueError(f"ç®—æ³• {algorithm_name} æœªæ³¨å†Œ")
        
        algorithm = self.algorithms[algorithm_name]
        performance_data = []
        
        for size in input_sizes:
            times = []
            for _ in range(iterations):
                # ç”Ÿæˆæµ‹è¯•æ•°æ®
                test_data = self._generate_test_data(size)
                
                # æµ‹é‡æ‰§è¡Œæ—¶é—´
                start_time = time.time()
                algorithm(test_data)
                end_time = time.time()
                
                times.append(end_time - start_time)
            
            # è®¡ç®—å¹³å‡æ—¶é—´
            avg_time = sum(times) / len(times)
            performance_data.append((size, avg_time))
        
        self.performance_data[algorithm_name] = performance_data
    
    def compare_algorithms(self, algorithm_names: List[str], 
                          input_sizes: List[int]) -> Dict[str, Any]:
        """æ¯”è¾ƒå¤šä¸ªç®—æ³•"""
        comparison_results = {
            'input_sizes': input_sizes,
            'algorithms': {},
            'complexity_analysis': {},
            'performance_ranking': []
        }
        
        # åˆ†ææ¯ä¸ªç®—æ³•
        for name in algorithm_names:
            if name in self.algorithms:
                self.analyze_performance(name, input_sizes)
                
                comparison_results['algorithms'][name] = {
                    'performance': self.performance_data[name],
                    'analysis': self.analysis_results[name]
                }
        
        # æ€§èƒ½æ’å
        total_times = {}
        for name, data in comparison_results['algorithms'].items():
            total_time = sum(time for _, time in data['performance'])
            total_times[name] = total_time
        
        comparison_results['performance_ranking'] = sorted(
            total_times.items(), key=lambda x: x[1]
        )
        
        return comparison_results
    
    def visualize_comparison(self, comparison_results: Dict[str, Any]) -> None:
        """å¯è§†åŒ–ç®—æ³•æ¯”è¾ƒ"""
        plt.figure(figsize=(12, 8))
        
        # æ€§èƒ½å¯¹æ¯”å›¾
        plt.subplot(2, 2, 1)
        for name, data in comparison_results['algorithms'].items():
            sizes, times = zip(*data['performance'])
            plt.plot(sizes, times, marker='o', label=name)
        
        plt.xlabel('è¾“å…¥è§„æ¨¡')
        plt.ylabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
        plt.title('ç®—æ³•æ€§èƒ½å¯¹æ¯”')
        plt.legend()
        plt.grid(True)
        
        # å¤æ‚åº¦åˆ†æ
        plt.subplot(2, 2, 2)
        algorithm_names = list(comparison_results['algorithms'].keys())
        complexity_classes = [
            comparison_results['algorithms'][name]['analysis'].complexity_class.value
            for name in algorithm_names
        ]
        
        plt.bar(algorithm_names, [1] * len(algorithm_names))
        plt.title('ç®—æ³•å¤æ‚åº¦ç±»åˆ«')
        plt.xticks(rotation=45)
        
        # æ·»åŠ å¤æ‚åº¦æ ‡ç­¾
        for i, (name, complexity) in enumerate(zip(algorithm_names, complexity_classes)):
            plt.text(i, 0.5, complexity, ha='center', va='center')
        
        # æ€§èƒ½æ’å
        plt.subplot(2, 2, 3)
        names, times = zip(*comparison_results['performance_ranking'])
        plt.bar(names, times)
        plt.title('æ€»æ‰§è¡Œæ—¶é—´æ’å')
        plt.xticks(rotation=45)
        plt.ylabel('æ€»æ—¶é—´ (ç§’)')
        
        plt.tight_layout()
        plt.show()
    
    def _generate_test_data(self, size: int) -> List[int]:
        """ç”Ÿæˆæµ‹è¯•æ•°æ®"""
        return [random.randint(1, 1000) for _ in range(size)]

# ç¤ºä¾‹ç®—æ³•å®ç°
def bubble_sort(arr: List[int]) -> List[int]:
    """å†’æ³¡æ’åº"""
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def quick_sort(arr: List[int]) -> List[int]:
    """å¿«é€Ÿæ’åº"""
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

def merge_sort(arr: List[int]) -> List[int]:
    """å½’å¹¶æ’åº"""
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left: List[int], right: List[int]) -> List[int]:
    """åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_algorithmic_thinking():
    """æ¼”ç¤ºç®—æ³•æ€ç»´"""
    at = AlgorithmicThinking()
    
    # æ³¨å†Œç®—æ³•
    at.register_algorithm("å†’æ³¡æ’åº", bubble_sort, AlgorithmAnalysis(
        algorithm_name="å†’æ³¡æ’åº",
        complexity_class=ComplexityClass.QUADRATIC,
        best_case="O(n)",
        worst_case="O(nÂ²)",
        average_case="O(nÂ²)",
        space_complexity="O(1)",
        stability=True,
        in_place=True
    ))
    
    at.register_algorithm("å¿«é€Ÿæ’åº", quick_sort, AlgorithmAnalysis(
        algorithm_name="å¿«é€Ÿæ’åº",
        complexity_class=ComplexityClass.LINE_LOG,
        best_case="O(n log n)",
        worst_case="O(nÂ²)",
        average_case="O(n log n)",
        space_complexity="O(log n)",
        stability=False,
        in_place=False
    ))
    
    at.register_algorithm("å½’å¹¶æ’åº", merge_sort, AlgorithmAnalysis(
        algorithm_name="å½’å¹¶æ’åº",
        complexity_class=ComplexityClass.LINE_LOG,
        best_case="O(n log n)",
        worst_case="O(n log n)",
        average_case="O(n log n)",
        space_complexity="O(n)",
        stability=True,
        in_place=False
    ))
    
    # æ¯”è¾ƒç®—æ³•
    input_sizes = [100, 500, 1000, 2000]
    comparison_results = at.compare_algorithms(
        ["å†’æ³¡æ’åº", "å¿«é€Ÿæ’åº", "å½’å¹¶æ’åº"], 
        input_sizes
    )
    
    print("=== ç®—æ³•æ€ç»´æ¼”ç¤º ===")
    print("ç®—æ³•æ¯”è¾ƒç»“æœ:")
    
    for name, data in comparison_results['algorithms'].items():
        analysis = data['analysis']
        print(f"\n{name}:")
        print(f"  å¤æ‚åº¦ç±»åˆ«: {analysis.complexity_class.value}")
        print(f"  æœ€å¥½æƒ…å†µ: {analysis.best_case}")
        print(f"  æœ€åæƒ…å†µ: {analysis.worst_case}")
        print(f"  å¹³å‡æƒ…å†µ: {analysis.average_case}")
        print(f"  ç©ºé—´å¤æ‚åº¦: {analysis.space_complexity}")
        print(f"  ç¨³å®šæ€§: {analysis.stability}")
        print(f"  åŸåœ°æ’åº: {analysis.in_place}")
    
    print(f"\næ€§èƒ½æ’å:")
    for i, (name, time) in enumerate(comparison_results['performance_ranking'], 1):
        print(f"  {i}. {name}: {time:.4f} ç§’")
    
    # å¯è§†åŒ–æ¯”è¾ƒ
    try:
        at.visualize_comparison(comparison_results)
    except ImportError:
        print("\næ³¨æ„: éœ€è¦å®‰è£… matplotlib æ¥æ˜¾ç¤ºå›¾è¡¨")

if __name__ == "__main__":
    demonstrate_algorithmic_thinking()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00-01-ç¼–ç¨‹å“²å­¦](./00-01-ç¼–ç¨‹å“²å­¦.md)
- [00-02-å½¢å¼åŒ–æ€ç»´](./00-02-å½¢å¼åŒ–æ€ç»´.md)
- [02-01-ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Wing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35.
2. Denning, P. J. (2009). The profession of IT: Beyond computational thinking. Communications of the ACM, 52(6), 28-30.
3. Aho, A. V., Hopcroft, J. E., & Ullman, J. D. (1974). The design and analysis of computer algorithms.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
