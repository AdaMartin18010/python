# è½¯ä»¶å·¥ç¨‹ç†å¿µ

## ğŸ“‹ æ¦‚è¿°

è½¯ä»¶å·¥ç¨‹ç†å¿µæ˜¯è½¯ä»¶å·¥ç¨‹çŸ¥è¯†ä½“ç³»çš„æ ¸å¿ƒæ€æƒ³åŸºç¡€ï¼Œæ¢è®¨è½¯ä»¶å¼€å‘çš„æœ¬è´¨ã€åŸåˆ™å’Œæ–¹æ³•è®ºã€‚æœ¬æ–‡æ¡£ä»å“²å­¦å’Œå·¥ç¨‹å­¦è§’åº¦åˆ†æè½¯ä»¶å·¥ç¨‹çš„æ ¸å¿ƒç†å¿µï¼Œå»ºç«‹å½¢å¼åŒ–çš„ç†è®ºæ¡†æ¶ã€‚

## 1. æ¦‚å¿µè§£é‡Š

### 1.1 è½¯ä»¶å·¥ç¨‹çš„å®šä¹‰

è½¯ä»¶å·¥ç¨‹æ˜¯ä¸€é—¨åº”ç”¨è®¡ç®—æœºç§‘å­¦ç†è®ºå’ŒæŠ€æœ¯ä»¥åŠå·¥ç¨‹ç®¡ç†åŸåˆ™å’Œæ–¹æ³•ï¼ŒæŒ‰é¢„ç®—å’Œè¿›åº¦ï¼Œå®ç°æ»¡è¶³ç”¨æˆ·è¦æ±‚çš„è½¯ä»¶äº§å“çš„å¼€å‘ã€è¿è¡Œå’Œç»´æŠ¤çš„å·¥ç¨‹æˆ–è¿›è¡Œç ”ç©¶çš„å­¦ç§‘ã€‚

### 1.2 è½¯ä»¶å·¥ç¨‹çš„æ ¸å¿ƒç†å¿µ

1. **ç³»ç»Ÿæ€§**: å°†è½¯ä»¶å¼€å‘è§†ä¸ºç³»ç»Ÿå·¥ç¨‹
2. **å·¥ç¨‹åŒ–**: åº”ç”¨å·¥ç¨‹åŸåˆ™å’Œæ–¹æ³•
3. **è´¨é‡å¯¼å‘**: ä»¥è½¯ä»¶è´¨é‡ä¸ºæ ¸å¿ƒç›®æ ‡
4. **è¿‡ç¨‹ç®¡ç†**: é‡è§†å¼€å‘è¿‡ç¨‹çš„ç®¡ç†å’Œæ§åˆ¶
5. **æŒç»­æ”¹è¿›**: ä¸æ–­ä¼˜åŒ–å’Œæ”¹è¿›å¼€å‘æ–¹æ³•

## 2. æ•°å­¦å½¢å¼åŒ–å®šä¹‰

### 2.1 è½¯ä»¶å·¥ç¨‹çš„å½¢å¼åŒ–æ¨¡å‹

**å®šä¹‰ 2.1** (è½¯ä»¶å·¥ç¨‹ç³»ç»Ÿ)
è½¯ä»¶å·¥ç¨‹ç³»ç»Ÿ $SE$ æ˜¯ä¸€ä¸ªå…­å…ƒç»„ $(P, M, T, Q, R, C)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯é¡¹ç›®é›†åˆ
- $M$ æ˜¯æ–¹æ³•è®ºé›†åˆ
- $T$ æ˜¯æŠ€æœ¯é›†åˆ
- $Q$ æ˜¯è´¨é‡åº¦é‡å‡½æ•°
- $R$ æ˜¯èµ„æºçº¦æŸ
- $C$ æ˜¯æˆæœ¬å‡½æ•°

**å®šä¹‰ 2.2** (è½¯ä»¶é¡¹ç›®)
è½¯ä»¶é¡¹ç›® $p \in P$ æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $(R, S, T, B, C)$ï¼Œå…¶ä¸­ï¼š

- $R$ æ˜¯éœ€æ±‚é›†åˆ
- $S$ æ˜¯è§„æ ¼è¯´æ˜
- $T$ æ˜¯æ—¶é—´çº¦æŸ
- $B$ æ˜¯é¢„ç®—çº¦æŸ
- $C$ æ˜¯çº¦æŸæ¡ä»¶é›†åˆ

**å®šä¹‰ 2.3** (è½¯ä»¶è´¨é‡)
è½¯ä»¶è´¨é‡ $Q: \text{Software} \rightarrow [0,1]$ æ˜¯ä¸€ä¸ªæ˜ å°„å‡½æ•°ï¼Œå®šä¹‰ä¸ºï¼š

$$Q(s) = \sum_{i=1}^{n} w_i \cdot q_i(s)$$

å…¶ä¸­ï¼š
- $s$ æ˜¯è½¯ä»¶äº§å“
- $w_i$ æ˜¯è´¨é‡ç»´åº¦çš„æƒé‡
- $q_i$ æ˜¯ç¬¬ $i$ ä¸ªè´¨é‡ç»´åº¦çš„åº¦é‡å‡½æ•°

### 2.2 è½¯ä»¶å·¥ç¨‹åŸåˆ™çš„å½¢å¼åŒ–æè¿°

**å®šä¹‰ 2.4** (è½¯ä»¶å·¥ç¨‹åŸåˆ™)
è½¯ä»¶å·¥ç¨‹åŸåˆ™ $PR$ æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(G, C, A)$ï¼Œå…¶ä¸­ï¼š

- $G$ æ˜¯ç›®æ ‡é›†åˆ
- $C$ æ˜¯çº¦æŸé›†åˆ
- $A$ æ˜¯è¡ŒåŠ¨é›†åˆ

**å®šä¹‰ 2.5** (è½¯ä»¶ç”Ÿå‘½å‘¨æœŸ)
è½¯ä»¶ç”Ÿå‘½å‘¨æœŸ $LC$ æ˜¯ä¸€ä¸ªæœ‰å‘å›¾ $(V, E)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯é˜¶æ®µé›†åˆ
- $E$ æ˜¯é˜¶æ®µé—´çš„å…³ç³»é›†åˆ

## 3. Pythonå®ç°

### 3.1 è½¯ä»¶å·¥ç¨‹åŸºç¡€ç±»

```python
from abc import ABC, abstractmethod
from typing import Set, Dict, List, Any, Callable, Tuple
from dataclasses import dataclass, field
from enum import Enum
import time
import math
from datetime import datetime, timedelta

class ProjectStatus(Enum):
    """é¡¹ç›®çŠ¶æ€æšä¸¾"""
    PLANNING = "planning"
    ANALYSIS = "analysis"
    DESIGN = "design"
    IMPLEMENTATION = "implementation"
    TESTING = "testing"
    DEPLOYMENT = "deployment"
    MAINTENANCE = "maintenance"
    COMPLETED = "completed"

class QualityDimension(Enum):
    """è´¨é‡ç»´åº¦æšä¸¾"""
    FUNCTIONALITY = "functionality"
    RELIABILITY = "reliability"
    USABILITY = "usability"
    EFFICIENCY = "efficiency"
    MAINTAINABILITY = "maintainability"
    PORTABILITY = "portability"
    SECURITY = "security"
    PERFORMANCE = "performance"

@dataclass
class Requirement:
    """éœ€æ±‚ç±»"""
    id: str
    description: str
    priority: int
    complexity: float
    dependencies: List[str] = field(default_factory=list)
    status: str = "pending"

@dataclass
class Resource:
    """èµ„æºç±»"""
    name: str
    type: str
    capacity: float
    cost_per_unit: float
    availability: float = 1.0

@dataclass
class Constraint:
    """çº¦æŸç±»"""
    name: str
    type: str
    value: Any
    description: str

class SoftwareProject:
    """è½¯ä»¶é¡¹ç›®ç±»"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.requirements: List[Requirement] = []
        self.resources: List[Resource] = []
        self.constraints: List[Constraint] = []
        self.status = ProjectStatus.PLANNING
        self.start_date = None
        self.end_date = None
        self.budget = 0.0
        self.actual_cost = 0.0
        self.team_members: List[str] = []
        self.risks: List[str] = []
        self.metrics: Dict[str, float] = {}
    
    def add_requirement(self, requirement: Requirement) -> None:
        """æ·»åŠ éœ€æ±‚"""
        self.requirements.append(requirement)
    
    def add_resource(self, resource: Resource) -> None:
        """æ·»åŠ èµ„æº"""
        self.resources.append(resource)
    
    def add_constraint(self, constraint: Constraint) -> None:
        """æ·»åŠ çº¦æŸ"""
        self.constraints.append(constraint)
    
    def calculate_complexity(self) -> float:
        """è®¡ç®—é¡¹ç›®å¤æ‚åº¦"""
        if not self.requirements:
            return 0.0
        
        total_complexity = sum(req.complexity for req in self.requirements)
        dependency_complexity = self._calculate_dependency_complexity()
        
        return total_complexity + dependency_complexity
    
    def _calculate_dependency_complexity(self) -> float:
        """è®¡ç®—ä¾èµ–å¤æ‚åº¦"""
        dependency_count = 0
        for req in self.requirements:
            dependency_count += len(req.dependencies)
        
        return dependency_count * 0.1  # æ¯ä¸ªä¾èµ–å¢åŠ 0.1çš„å¤æ‚åº¦
    
    def estimate_effort(self) -> float:
        """ä¼°ç®—å·¥ä½œé‡"""
        complexity = self.calculate_complexity()
        # ä½¿ç”¨COCOMOæ¨¡å‹ç®€åŒ–ç‰ˆæœ¬
        return 2.4 * (complexity ** 1.05)
    
    def estimate_duration(self, team_size: int) -> float:
        """ä¼°ç®—é¡¹ç›®æŒç»­æ—¶é—´"""
        effort = self.estimate_effort()
        if team_size <= 0:
            return float('inf')
        return effort / team_size
    
    def calculate_cost(self) -> float:
        """è®¡ç®—é¡¹ç›®æˆæœ¬"""
        total_cost = 0.0
        for resource in self.resources:
            total_cost += resource.cost_per_unit * resource.capacity
        return total_cost

class QualityMetric:
    """è´¨é‡åº¦é‡ç±»"""
    
    def __init__(self):
        self.dimensions: Dict[QualityDimension, Callable] = {}
        self.weights: Dict[QualityDimension, float] = {}
        self._initialize_default_metrics()
    
    def _initialize_default_metrics(self) -> None:
        """åˆå§‹åŒ–é»˜è®¤è´¨é‡åº¦é‡"""
        # åŠŸèƒ½æ€§åº¦é‡
        self.dimensions[QualityDimension.FUNCTIONALITY] = self._measure_functionality
        self.weights[QualityDimension.FUNCTIONALITY] = 0.25
        
        # å¯é æ€§åº¦é‡
        self.dimensions[QualityDimension.RELIABILITY] = self._measure_reliability
        self.weights[QualityDimension.RELIABILITY] = 0.20
        
        # å¯ç”¨æ€§åº¦é‡
        self.dimensions[QualityDimension.USABILITY] = self._measure_usability
        self.weights[QualityDimension.USABILITY] = 0.15
        
        # æ•ˆç‡åº¦é‡
        self.dimensions[QualityDimension.EFFICIENCY] = self._measure_efficiency
        self.weights[QualityDimension.EFFICIENCY] = 0.15
        
        # å¯ç»´æŠ¤æ€§åº¦é‡
        self.dimensions[QualityDimension.MAINTAINABILITY] = self._measure_maintainability
        self.weights[QualityDimension.MAINTAINABILITY] = 0.15
        
        # å¯ç§»æ¤æ€§åº¦é‡
        self.dimensions[QualityDimension.PORTABILITY] = self._measure_portability
        self.weights[QualityDimension.PORTABILITY] = 0.10
    
    def _measure_functionality(self, software: Dict[str, Any]) -> float:
        """åº¦é‡åŠŸèƒ½æ€§"""
        requirements_met = software.get('requirements_met', 0)
        total_requirements = software.get('total_requirements', 1)
        return requirements_met / total_requirements
    
    def _measure_reliability(self, software: Dict[str, Any]) -> float:
        """åº¦é‡å¯é æ€§"""
        failures = software.get('failures', 0)
        total_operations = software.get('total_operations', 1)
        return max(0, 1 - failures / total_operations)
    
    def _measure_usability(self, software: Dict[str, Any]) -> float:
        """åº¦é‡å¯ç”¨æ€§"""
        user_satisfaction = software.get('user_satisfaction', 0.5)
        learning_time = software.get('learning_time', 1.0)
        # å­¦ä¹ æ—¶é—´è¶ŠçŸ­ï¼Œå¯ç”¨æ€§è¶Šé«˜
        time_factor = max(0, 1 - learning_time / 10.0)
        return (user_satisfaction + time_factor) / 2
    
    def _measure_efficiency(self, software: Dict[str, Any]) -> float:
        """åº¦é‡æ•ˆç‡"""
        response_time = software.get('response_time', 1.0)
        throughput = software.get('throughput', 1.0)
        # å“åº”æ—¶é—´è¶ŠçŸ­ï¼Œååé‡è¶Šé«˜ï¼Œæ•ˆç‡è¶Šé«˜
        time_factor = max(0, 1 - response_time / 10.0)
        throughput_factor = min(1, throughput / 1000.0)
        return (time_factor + throughput_factor) / 2
    
    def _measure_maintainability(self, software: Dict[str, Any]) -> float:
        """åº¦é‡å¯ç»´æŠ¤æ€§"""
        code_complexity = software.get('code_complexity', 1.0)
        documentation_quality = software.get('documentation_quality', 0.5)
        # ä»£ç å¤æ‚åº¦è¶Šä½ï¼Œæ–‡æ¡£è´¨é‡è¶Šé«˜ï¼Œå¯ç»´æŠ¤æ€§è¶Šé«˜
        complexity_factor = max(0, 1 - code_complexity / 10.0)
        return (complexity_factor + documentation_quality) / 2
    
    def _measure_portability(self, software: Dict[str, Any]) -> float:
        """åº¦é‡å¯ç§»æ¤æ€§"""
        platform_independence = software.get('platform_independence', 0.5)
        dependency_count = software.get('dependency_count', 0)
        # å¹³å°ç‹¬ç«‹æ€§è¶Šé«˜ï¼Œä¾èµ–è¶Šå°‘ï¼Œå¯ç§»æ¤æ€§è¶Šé«˜
        dependency_factor = max(0, 1 - dependency_count / 100.0)
        return (platform_independence + dependency_factor) / 2
    
    def calculate_overall_quality(self, software: Dict[str, Any]) -> float:
        """è®¡ç®—æ•´ä½“è´¨é‡åˆ†æ•°"""
        total_score = 0.0
        total_weight = 0.0
        
        for dimension, weight in self.weights.items():
            if dimension in self.dimensions:
                score = self.dimensions[dimension](software)
                total_score += score * weight
                total_weight += weight
        
        return total_score / total_weight if total_weight > 0 else 0.0

class SoftwareEngineeringMethodology:
    """è½¯ä»¶å·¥ç¨‹æ–¹æ³•è®ºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.phases: List[str] = []
        self.activities: Dict[str, List[str]] = {}
        self.artifacts: Dict[str, List[str]] = {}
        self.roles: List[str] = []
        self.principles: List[str] = []
    
    def add_phase(self, phase: str) -> None:
        """æ·»åŠ é˜¶æ®µ"""
        self.phases.append(phase)
    
    def add_activity(self, phase: str, activity: str) -> None:
        """æ·»åŠ æ´»åŠ¨"""
        if phase not in self.activities:
            self.activities[phase] = []
        self.activities[phase].append(activity)
    
    def add_artifact(self, phase: str, artifact: str) -> None:
        """æ·»åŠ åˆ¶å“"""
        if phase not in self.artifacts:
            self.artifacts[phase] = []
        self.artifacts[phase].append(artifact)
    
    def add_role(self, role: str) -> None:
        """æ·»åŠ è§’è‰²"""
        self.roles.append(role)
    
    def add_principle(self, principle: str) -> None:
        """æ·»åŠ åŸåˆ™"""
        self.principles.append(principle)

class AgileMethodology(SoftwareEngineeringMethodology):
    """æ•æ·æ–¹æ³•è®ºç±»"""
    
    def __init__(self):
        super().__init__("Agile")
        self._setup_agile_methodology()
    
    def _setup_agile_methodology(self) -> None:
        """è®¾ç½®æ•æ·æ–¹æ³•è®º"""
        # æ·»åŠ é˜¶æ®µ
        self.add_phase("Sprint Planning")
        self.add_phase("Sprint Execution")
        self.add_phase("Sprint Review")
        self.add_phase("Sprint Retrospective")
        
        # æ·»åŠ æ´»åŠ¨
        self.add_activity("Sprint Planning", "Backlog Refinement")
        self.add_activity("Sprint Planning", "Sprint Goal Definition")
        self.add_activity("Sprint Planning", "Task Breakdown")
        self.add_activity("Sprint Execution", "Daily Standup")
        self.add_activity("Sprint Execution", "Development")
        self.add_activity("Sprint Execution", "Testing")
        self.add_activity("Sprint Review", "Demo")
        self.add_activity("Sprint Review", "Feedback Collection")
        self.add_activity("Sprint Retrospective", "Process Improvement")
        
        # æ·»åŠ åˆ¶å“
        self.add_artifact("Sprint Planning", "Sprint Backlog")
        self.add_artifact("Sprint Planning", "Sprint Goal")
        self.add_artifact("Sprint Execution", "Working Software")
        self.add_artifact("Sprint Review", "Demo Results")
        self.add_artifact("Sprint Retrospective", "Improvement Actions")
        
        # æ·»åŠ è§’è‰²
        self.add_role("Product Owner")
        self.add_role("Scrum Master")
        self.add_role("Development Team")
        
        # æ·»åŠ åŸåˆ™
        self.add_principle("Individuals and interactions over processes and tools")
        self.add_principle("Working software over comprehensive documentation")
        self.add_principle("Customer collaboration over contract negotiation")
        self.add_principle("Responding to change over following a plan")

class WaterfallMethodology(SoftwareEngineeringMethodology):
    """ç€‘å¸ƒæ–¹æ³•è®ºç±»"""
    
    def __init__(self):
        super().__init__("Waterfall")
        self._setup_waterfall_methodology()
    
    def _setup_waterfall_methodology(self) -> None:
        """è®¾ç½®ç€‘å¸ƒæ–¹æ³•è®º"""
        # æ·»åŠ é˜¶æ®µ
        self.add_phase("Requirements Analysis")
        self.add_phase("System Design")
        self.add_phase("Implementation")
        self.add_phase("Testing")
        self.add_phase("Deployment")
        self.add_phase("Maintenance")
        
        # æ·»åŠ æ´»åŠ¨
        self.add_activity("Requirements Analysis", "Requirements Gathering")
        self.add_activity("Requirements Analysis", "Requirements Specification")
        self.add_activity("System Design", "Architecture Design")
        self.add_activity("System Design", "Detailed Design")
        self.add_activity("Implementation", "Coding")
        self.add_activity("Implementation", "Unit Testing")
        self.add_activity("Testing", "Integration Testing")
        self.add_activity("Testing", "System Testing")
        self.add_activity("Deployment", "Installation")
        self.add_activity("Deployment", "Configuration")
        self.add_activity("Maintenance", "Bug Fixing")
        self.add_activity("Maintenance", "Enhancement")
        
        # æ·»åŠ åˆ¶å“
        self.add_artifact("Requirements Analysis", "Requirements Document")
        self.add_artifact("System Design", "Design Document")
        self.add_artifact("Implementation", "Source Code")
        self.add_artifact("Testing", "Test Results")
        self.add_artifact("Deployment", "Deployment Guide")
        self.add_artifact("Maintenance", "Maintenance Log")
        
        # æ·»åŠ è§’è‰²
        self.add_role("Project Manager")
        self.add_role("Business Analyst")
        self.add_role("System Architect")
        self.add_role("Developer")
        self.add_role("Tester")
        self.add_role("DevOps Engineer")
        
        # æ·»åŠ åŸåˆ™
        self.add_principle("Sequential development phases")
        self.add_principle("Comprehensive documentation")
        self.add_principle("Formal reviews and approvals")
        self.add_principle("Change control procedures")

class SoftwareEngineeringPrinciples:
    """è½¯ä»¶å·¥ç¨‹åŸåˆ™ç±»"""
    
    def __init__(self):
        self.principles: Dict[str, str] = {
            "separation_of_concerns": "å…³æ³¨ç‚¹åˆ†ç¦»ï¼šå°†ä¸åŒçš„é—®é¢˜åˆ†å¼€å¤„ç†",
            "abstraction": "æŠ½è±¡ï¼šéšè—å¤æ‚æ€§ï¼Œçªå‡ºæœ¬è´¨",
            "modularity": "æ¨¡å—åŒ–ï¼šå°†ç³»ç»Ÿåˆ†è§£ä¸ºç‹¬ç«‹æ¨¡å—",
            "encapsulation": "å°è£…ï¼šéšè—å†…éƒ¨å®ç°ç»†èŠ‚",
            "information_hiding": "ä¿¡æ¯éšè—ï¼šé™åˆ¶å¯¹å†…éƒ¨ä¿¡æ¯çš„è®¿é—®",
            "coupling": "è€¦åˆï¼šæ¨¡å—é—´çš„ä¾èµ–å…³ç³»",
            "cohesion": "å†…èšï¼šæ¨¡å—å†…éƒ¨å…ƒç´ çš„å…³è”ç¨‹åº¦",
            "reusability": "å¯é‡ç”¨æ€§ï¼šç»„ä»¶å¯åœ¨ä¸åŒåœºæ™¯ä¸­ä½¿ç”¨",
            "testability": "å¯æµ‹è¯•æ€§ï¼šè½¯ä»¶æ˜“äºæµ‹è¯•",
            "maintainability": "å¯ç»´æŠ¤æ€§ï¼šè½¯ä»¶æ˜“äºä¿®æ”¹å’Œç»´æŠ¤",
            "scalability": "å¯æ‰©å±•æ€§ï¼šè½¯ä»¶æ˜“äºæ‰©å±•åŠŸèƒ½",
            "performance": "æ€§èƒ½ï¼šè½¯ä»¶è¿è¡Œæ•ˆç‡",
            "security": "å®‰å…¨æ€§ï¼šè½¯ä»¶çš„å®‰å…¨é˜²æŠ¤èƒ½åŠ›",
            "usability": "å¯ç”¨æ€§ï¼šè½¯ä»¶æ˜“äºä½¿ç”¨"
        }
    
    def evaluate_project(self, project: SoftwareProject) -> Dict[str, float]:
        """è¯„ä¼°é¡¹ç›®å¯¹åŸåˆ™çš„ç¬¦åˆç¨‹åº¦"""
        scores = {}
        
        # è¯„ä¼°å„ç§åŸåˆ™
        scores['modularity'] = self._evaluate_modularity(project)
        scores['abstraction'] = self._evaluate_abstraction(project)
        scores['encapsulation'] = self._evaluate_encapsulation(project)
        scores['coupling'] = self._evaluate_coupling(project)
        scores['cohesion'] = self._evaluate_cohesion(project)
        scores['reusability'] = self._evaluate_reusability(project)
        scores['testability'] = self._evaluate_testability(project)
        scores['maintainability'] = self._evaluate_maintainability(project)
        
        return scores
    
    def _evaluate_modularity(self, project: SoftwareProject) -> float:
        """è¯„ä¼°æ¨¡å—åŒ–ç¨‹åº¦"""
        # åŸºäºéœ€æ±‚æ•°é‡å’Œå¤æ‚åº¦
        req_count = len(project.requirements)
        complexity = project.calculate_complexity()
        
        # éœ€æ±‚æ•°é‡é€‚ä¸­ï¼Œå¤æ‚åº¦åˆç†æ—¶æ¨¡å—åŒ–ç¨‹åº¦é«˜
        if 5 <= req_count <= 20 and complexity <= 10:
            return 0.9
        elif req_count > 20 or complexity > 10:
            return 0.6
        else:
            return 0.7
    
    def _evaluate_abstraction(self, project: SoftwareProject) -> float:
        """è¯„ä¼°æŠ½è±¡ç¨‹åº¦"""
        # åŸºäºé¡¹ç›®æè¿°å’Œéœ€æ±‚çš„æŠ½è±¡å±‚æ¬¡
        return 0.8  # ç®€åŒ–è¯„ä¼°
    
    def _evaluate_encapsulation(self, project: SoftwareProject) -> float:
        """è¯„ä¼°å°è£…ç¨‹åº¦"""
        # åŸºäºé¡¹ç›®ç»“æ„å’Œç»„ç»‡
        return 0.7  # ç®€åŒ–è¯„ä¼°
    
    def _evaluate_coupling(self, project: SoftwareProject) -> float:
        """è¯„ä¼°è€¦åˆç¨‹åº¦"""
        # åŸºäºéœ€æ±‚ä¾èµ–å…³ç³»
        total_dependencies = sum(len(req.dependencies) for req in project.requirements)
        req_count = len(project.requirements)
        
        if req_count == 0:
            return 1.0
        
        avg_dependencies = total_dependencies / req_count
        # å¹³å‡ä¾èµ–è¶Šå°‘ï¼Œè€¦åˆè¶Šä½
        return max(0, 1 - avg_dependencies / 5)
    
    def _evaluate_cohesion(self, project: SoftwareProject) -> float:
        """è¯„ä¼°å†…èšç¨‹åº¦"""
        # åŸºäºéœ€æ±‚çš„å…³è”æ€§
        return 0.8  # ç®€åŒ–è¯„ä¼°
    
    def _evaluate_reusability(self, project: SoftwareProject) -> float:
        """è¯„ä¼°å¯é‡ç”¨æ€§"""
        # åŸºäºé¡¹ç›®çš„é€šç”¨æ€§
        return 0.6  # ç®€åŒ–è¯„ä¼°
    
    def _evaluate_testability(self, project: SoftwareProject) -> float:
        """è¯„ä¼°å¯æµ‹è¯•æ€§"""
        # åŸºäºé¡¹ç›®çš„å¯æµ‹è¯•æ€§ç‰¹å¾
        return 0.7  # ç®€åŒ–è¯„ä¼°
    
    def _evaluate_maintainability(self, project: SoftwareProject) -> float:
        """è¯„ä¼°å¯ç»´æŠ¤æ€§"""
        # åŸºäºé¡¹ç›®çš„ç»´æŠ¤ç‰¹å¾
        complexity = project.calculate_complexity()
        # å¤æ‚åº¦è¶Šä½ï¼Œå¯ç»´æŠ¤æ€§è¶Šé«˜
        return max(0, 1 - complexity / 20)

class SoftwareEngineeringMetrics:
    """è½¯ä»¶å·¥ç¨‹åº¦é‡ç±»"""
    
    def __init__(self):
        self.metrics: Dict[str, Callable] = {}
        self._initialize_metrics()
    
    def _initialize_metrics(self) -> None:
        """åˆå§‹åŒ–åº¦é‡æŒ‡æ ‡"""
        self.metrics['lines_of_code'] = self._calculate_lines_of_code
        self.metrics['cyclomatic_complexity'] = self._calculate_cyclomatic_complexity
        self.metrics['code_coverage'] = self._calculate_code_coverage
        self.metrics['defect_density'] = self._calculate_defect_density
        self.metrics['maintainability_index'] = self._calculate_maintainability_index
    
    def _calculate_lines_of_code(self, project: SoftwareProject) -> int:
        """è®¡ç®—ä»£ç è¡Œæ•°"""
        # åŸºäºé¡¹ç›®å¤æ‚åº¦ä¼°ç®—
        complexity = project.calculate_complexity()
        return int(complexity * 100)
    
    def _calculate_cyclomatic_complexity(self, project: SoftwareProject) -> float:
        """è®¡ç®—åœˆå¤æ‚åº¦"""
        # åŸºäºéœ€æ±‚æ•°é‡å’Œä¾èµ–å…³ç³»
        req_count = len(project.requirements)
        total_dependencies = sum(len(req.dependencies) for req in project.requirements)
        return req_count + total_dependencies * 0.5
    
    def _calculate_code_coverage(self, project: SoftwareProject) -> float:
        """è®¡ç®—ä»£ç è¦†ç›–ç‡"""
        # åŸºäºæµ‹è¯•æ´»åŠ¨
        if "Testing" in [req.description for req in project.requirements]:
            return 0.85
        return 0.6
    
    def _calculate_defect_density(self, project: SoftwareProject) -> float:
        """è®¡ç®—ç¼ºé™·å¯†åº¦"""
        # åŸºäºé¡¹ç›®å¤æ‚åº¦å’Œè´¨é‡
        complexity = project.calculate_complexity()
        return complexity * 0.1
    
    def _calculate_maintainability_index(self, project: SoftwareProject) -> float:
        """è®¡ç®—å¯ç»´æŠ¤æ€§æŒ‡æ•°"""
        # åŸºäºå¤šä¸ªå› ç´ çš„ç»¼åˆè¯„ä¼°
        complexity = project.calculate_complexity()
        req_count = len(project.requirements)
        
        # å¤æ‚åº¦è¶Šä½ï¼Œéœ€æ±‚æ•°é‡é€‚ä¸­ï¼Œå¯ç»´æŠ¤æ€§è¶Šé«˜
        complexity_factor = max(0, 1 - complexity / 20)
        req_factor = 1.0 if 5 <= req_count <= 20 else 0.7
        
        return (complexity_factor + req_factor) / 2
    
    def calculate_all_metrics(self, project: SoftwareProject) -> Dict[str, float]:
        """è®¡ç®—æ‰€æœ‰åº¦é‡æŒ‡æ ‡"""
        results = {}
        for metric_name, metric_func in self.metrics.items():
            results[metric_name] = metric_func(project)
        return results
```

### 3.2 è½¯ä»¶å·¥ç¨‹ç†å¿µå®ç°

```python
class SoftwareEngineeringPhilosophy:
    """è½¯ä»¶å·¥ç¨‹å“²å­¦ç±»"""
    
    def __init__(self):
        self.philosophical_questions = [
            "è½¯ä»¶å·¥ç¨‹çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿ",
            "å¦‚ä½•å¹³è¡¡è´¨é‡ã€æˆæœ¬å’Œæ—¶é—´ï¼Ÿ",
            "è½¯ä»¶å·¥ç¨‹ä¸è‰ºæœ¯çš„å…³ç³»æ˜¯ä»€ä¹ˆï¼Ÿ",
            "è½¯ä»¶å·¥ç¨‹ä¸ç§‘å­¦çš„å…³ç³»æ˜¯ä»€ä¹ˆï¼Ÿ",
            "è½¯ä»¶å·¥ç¨‹çš„æœªæ¥å‘å±•æ–¹å‘æ˜¯ä»€ä¹ˆï¼Ÿ"
        ]
        self.philosophical_answers = {}
    
    def explore_essence(self) -> Dict[str, str]:
        """æ¢ç´¢è½¯ä»¶å·¥ç¨‹æœ¬è´¨"""
        essence = {
            "engineering_nature": "è½¯ä»¶å·¥ç¨‹æ˜¯åº”ç”¨å·¥ç¨‹åŸç†åˆ°è½¯ä»¶å¼€å‘ä¸­",
            "systematic_approach": "é‡‡ç”¨ç³»ç»ŸåŒ–çš„æ–¹æ³•è¿›è¡Œè½¯ä»¶å¼€å‘",
            "quality_focus": "ä»¥è½¯ä»¶è´¨é‡ä¸ºæ ¸å¿ƒç›®æ ‡",
            "process_orientation": "é‡è§†å¼€å‘è¿‡ç¨‹çš„ç®¡ç†å’Œæ§åˆ¶",
            "continuous_improvement": "æŒç»­æ”¹è¿›å¼€å‘æ–¹æ³•å’Œè¿‡ç¨‹"
        }
        return essence
    
    def analyze_tradeoffs(self, project: SoftwareProject) -> Dict[str, Dict[str, float]]:
        """åˆ†æè´¨é‡ã€æˆæœ¬ã€æ—¶é—´çš„æƒè¡¡"""
        tradeoffs = {}
        
        # è´¨é‡-æˆæœ¬æƒè¡¡
        quality_cost = {
            "high_quality_high_cost": 0.8,
            "high_quality_low_cost": 0.2,
            "low_quality_high_cost": 0.1,
            "low_quality_low_cost": 0.9
        }
        tradeoffs["quality_cost"] = quality_cost
        
        # è´¨é‡-æ—¶é—´æƒè¡¡
        quality_time = {
            "high_quality_long_time": 0.7,
            "high_quality_short_time": 0.3,
            "low_quality_long_time": 0.2,
            "low_quality_short_time": 0.8
        }
        tradeoffs["quality_time"] = quality_time
        
        # æˆæœ¬-æ—¶é—´æƒè¡¡
        cost_time = {
            "high_cost_short_time": 0.6,
            "high_cost_long_time": 0.4,
            "low_cost_short_time": 0.9,
            "low_cost_long_time": 0.1
        }
        tradeoffs["cost_time"] = cost_time
        
        return tradeoffs
    
    def compare_art_science(self) -> Dict[str, str]:
        """æ¯”è¾ƒè½¯ä»¶å·¥ç¨‹ä¸è‰ºæœ¯ã€ç§‘å­¦çš„å…³ç³»"""
        comparison = {
            "engineering_vs_art": "å·¥ç¨‹å¼ºè°ƒå¯é‡å¤æ€§å’Œå¯é¢„æµ‹æ€§ï¼Œè‰ºæœ¯å¼ºè°ƒåˆ›é€ æ€§å’Œç‹¬ç‰¹æ€§",
            "engineering_vs_science": "å·¥ç¨‹å…³æ³¨åº”ç”¨å’Œè§£å†³å®é™…é—®é¢˜ï¼Œç§‘å­¦å…³æ³¨å‘ç°å’Œç†è®º",
            "engineering_nature": "è½¯ä»¶å·¥ç¨‹æ˜¯å·¥ç¨‹å­¦ç§‘ï¼Œç»“åˆäº†ç§‘å­¦æ–¹æ³•å’Œè‰ºæœ¯åˆ›é€ ",
            "creative_aspects": "è½¯ä»¶å·¥ç¨‹éœ€è¦åˆ›é€ æ€§è®¾è®¡è§£å†³æ–¹æ¡ˆ",
            "systematic_aspects": "è½¯ä»¶å·¥ç¨‹éœ€è¦ç³»ç»ŸåŒ–çš„æ–¹æ³•å’Œè¿‡ç¨‹"
        }
        return comparison

class SoftwareEngineeringTrends:
    """è½¯ä»¶å·¥ç¨‹è¶‹åŠ¿ç±»"""
    
    def __init__(self):
        self.current_trends = [
            "DevOpså’ŒæŒç»­äº¤ä»˜",
            "å¾®æœåŠ¡æ¶æ„",
            "äº‘åŸç”Ÿå¼€å‘",
            "äººå·¥æ™ºèƒ½å’Œæœºå™¨å­¦ä¹ ",
            "ä½ä»£ç /æ— ä»£ç å¹³å°",
            "å®‰å…¨å·¦ç§»",
            "ç»¿è‰²è½¯ä»¶å·¥ç¨‹",
            "é‡å­è®¡ç®—è½¯ä»¶"
        ]
        self.future_directions = [
            "è‡ªåŠ¨åŒ–è½¯ä»¶å·¥ç¨‹",
            "æ™ºèƒ½åŒ–å¼€å‘å·¥å…·",
            "è‡ªé€‚åº”è½¯ä»¶ç³»ç»Ÿ",
            "é‡å­è½¯ä»¶å·¥ç¨‹",
            "ç”Ÿç‰©å¯å‘å¼è½¯ä»¶å·¥ç¨‹"
        ]
    
    def analyze_trend_impact(self, trend: str) -> Dict[str, float]:
        """åˆ†æè¶‹åŠ¿å¯¹è½¯ä»¶å·¥ç¨‹çš„å½±å“"""
        impacts = {
            "development_efficiency": 0.8,
            "software_quality": 0.7,
            "cost_reduction": 0.6,
            "time_to_market": 0.9,
            "maintenance_ease": 0.5,
            "learning_curve": 0.4
        }
        return impacts
    
    def predict_future_development(self) -> Dict[str, str]:
        """é¢„æµ‹æœªæ¥å‘å±•æ–¹å‘"""
        predictions = {
            "automation": "è½¯ä»¶å¼€å‘è¿‡ç¨‹å°†æ›´åŠ è‡ªåŠ¨åŒ–",
            "intelligence": "AIå°†åœ¨è½¯ä»¶å¼€å‘ä¸­å‘æŒ¥æ›´å¤§ä½œç”¨",
            "collaboration": "äººæœºåä½œå°†æˆä¸ºä¸»æµ",
            "sustainability": "ç»¿è‰²è½¯ä»¶å·¥ç¨‹å°†å—åˆ°é‡è§†",
            "quantum": "é‡å­è½¯ä»¶å·¥ç¨‹å°†å…´èµ·"
        }
        return predictions
```

## 4. ç†è®ºè¯æ˜

### 4.1 è½¯ä»¶å·¥ç¨‹åŸºæœ¬å®šç†

**å®šç† 4.1** (è½¯ä»¶å·¥ç¨‹æƒè¡¡å®šç†)
åœ¨è½¯ä»¶å·¥ç¨‹ä¸­ï¼Œè´¨é‡ã€æˆæœ¬ã€æ—¶é—´ä¸‰ä¸ªç›®æ ‡ä¸å¯èƒ½åŒæ—¶è¾¾åˆ°æœ€ä¼˜ã€‚

**è¯æ˜**:
ä½¿ç”¨åè¯æ³•ã€‚å‡è®¾å­˜åœ¨è½¯ä»¶å¼€å‘æ–¹æ¡ˆåŒæ—¶å®ç°ï¼š
- æœ€é«˜è´¨é‡ $Q_{max}$
- æœ€ä½æˆæœ¬ $C_{min}$
- æœ€çŸ­æ—¶é—´ $T_{min}$

æ ¹æ®è½¯ä»¶å·¥ç¨‹ç»éªŒï¼š
1. é«˜è´¨é‡éœ€è¦æ›´å¤šæµ‹è¯•å’ŒéªŒè¯ï¼Œå¢åŠ æˆæœ¬å’Œæ—¶é—´
2. ä½æˆæœ¬é€šå¸¸æ„å‘³ç€å‡å°‘èµ„æºæŠ•å…¥ï¼Œå½±å“è´¨é‡å’Œæ—¶é—´
3. çŸ­æ—¶é—´é€šå¸¸éœ€è¦å¢åŠ èµ„æºæŠ•å…¥ï¼Œå¢åŠ æˆæœ¬

å› æ­¤ï¼Œè¿™ä¸‰ä¸ªç›®æ ‡ä¹‹é—´å­˜åœ¨æ ¹æœ¬æ€§å†²çªï¼Œä¸å¯èƒ½åŒæ—¶è¾¾åˆ°æœ€ä¼˜ã€‚

**å®šç† 4.2** (è½¯ä»¶å¤æ‚åº¦å¢é•¿å®šç†)
éšç€è½¯ä»¶è§„æ¨¡çš„å¢åŠ ï¼Œè½¯ä»¶å¤æ‚åº¦å‘ˆéçº¿æ€§å¢é•¿ã€‚

**è¯æ˜**:
è®¾è½¯ä»¶è§„æ¨¡ä¸º $n$ï¼Œå¤æ‚åº¦ä¸º $C(n)$ã€‚

æ ¹æ®è½¯ä»¶å·¥ç¨‹ç»éªŒï¼Œå¤æ‚åº¦ä¸»è¦æ¥è‡ªï¼š
1. æ¨¡å—é—´äº¤äº’ï¼š$O(n^2)$
2. çŠ¶æ€ç©ºé—´ï¼š$O(2^n)$
3. è·¯å¾„æ•°é‡ï¼š$O(n!)$

å› æ­¤ï¼Œ$C(n) = O(n^2) + O(2^n) + O(n!)$ï¼Œå‘ˆéçº¿æ€§å¢é•¿ã€‚

### 4.2 è½¯ä»¶è´¨é‡åº¦é‡å®šç†

**å®šç† 4.3** (è´¨é‡åº¦é‡å®Œå¤‡æ€§)
ä¸å­˜åœ¨èƒ½å¤Ÿå®Œå…¨åº¦é‡è½¯ä»¶è´¨é‡çš„å•ä¸€æŒ‡æ ‡ã€‚

**è¯æ˜**:
è½¯ä»¶è´¨é‡åŒ…å«å¤šä¸ªç»´åº¦ï¼š
- åŠŸèƒ½æ€§ $F$
- å¯é æ€§ $R$
- å¯ç”¨æ€§ $U$
- æ•ˆç‡ $E$
- å¯ç»´æŠ¤æ€§ $M$
- å¯ç§»æ¤æ€§ $P$

è¿™äº›ç»´åº¦ä¹‹é—´å­˜åœ¨ç›¸äº’å½±å“å’Œå†²çªï¼Œæ— æ³•ç”¨å•ä¸€æŒ‡æ ‡å®Œå…¨è¡¨ç¤ºã€‚

## 5. å®é™…åº”ç”¨ç¤ºä¾‹

### 5.1 è½¯ä»¶å·¥ç¨‹é¡¹ç›®ç®¡ç†ç¤ºä¾‹

```python
def demonstrate_project_management():
    """æ¼”ç¤ºè½¯ä»¶å·¥ç¨‹é¡¹ç›®ç®¡ç†"""
    
    # åˆ›å»ºé¡¹ç›®
    project = SoftwareProject("ç”µå•†å¹³å°", "å¼€å‘ä¸€ä¸ªåœ¨çº¿ç”µå•†å¹³å°")
    
    # æ·»åŠ éœ€æ±‚
    requirements = [
        Requirement("REQ001", "ç”¨æˆ·æ³¨å†Œå’Œç™»å½•", 1, 2.0),
        Requirement("REQ002", "å•†å“æµè§ˆå’Œæœç´¢", 1, 3.0),
        Requirement("REQ003", "è´­ç‰©è½¦åŠŸèƒ½", 2, 2.5),
        Requirement("REQ004", "è®¢å•ç®¡ç†", 1, 4.0),
        Requirement("REQ005", "æ”¯ä»˜é›†æˆ", 1, 5.0),
        Requirement("REQ006", "ç”¨æˆ·è¯„ä»·", 3, 1.5),
        Requirement("REQ007", "åº“å­˜ç®¡ç†", 2, 3.5),
        Requirement("REQ008", "æ•°æ®åˆ†æ", 3, 4.5)
    ]
    
    for req in requirements:
        project.add_requirement(req)
    
    # æ·»åŠ èµ„æº
    resources = [
        Resource("å¼€å‘äººå‘˜", "human", 5, 1000.0),
        Resource("æµ‹è¯•äººå‘˜", "human", 2, 800.0),
        Resource("é¡¹ç›®ç»ç†", "human", 1, 1200.0),
        Resource("æœåŠ¡å™¨", "infrastructure", 10, 200.0),
        Resource("å¼€å‘å·¥å…·", "software", 1, 500.0)
    ]
    
    for resource in resources:
        project.add_resource(resource)
    
    # æ·»åŠ çº¦æŸ
    constraints = [
        Constraint("æ—¶é—´çº¦æŸ", "time", 6, "é¡¹ç›®å¿…é¡»åœ¨6ä¸ªæœˆå†…å®Œæˆ"),
        Constraint("é¢„ç®—çº¦æŸ", "budget", 100000, "é¡¹ç›®é¢„ç®—ä¸è¶…è¿‡10ä¸‡å…ƒ"),
        Constraint("è´¨é‡çº¦æŸ", "quality", 0.9, "è½¯ä»¶è´¨é‡å¿…é¡»è¾¾åˆ°90%ä»¥ä¸Š")
    ]
    
    for constraint in constraints:
        project.add_constraint(constraint)
    
    # åˆ†æé¡¹ç›®
    complexity = project.calculate_complexity()
    effort = project.estimate_effort()
    duration = project.estimate_duration(5)  # 5äººå›¢é˜Ÿ
    cost = project.calculate_cost()
    
    return {
        'project': project,
        'complexity': complexity,
        'effort': effort,
        'duration': duration,
        'cost': cost
    }

def demonstrate_quality_assessment():
    """æ¼”ç¤ºè´¨é‡è¯„ä¼°"""
    
    # åˆ›å»ºè´¨é‡åº¦é‡å™¨
    quality_metric = QualityMetric()
    
    # æ¨¡æ‹Ÿè½¯ä»¶è´¨é‡æ•°æ®
    software_data = {
        'requirements_met': 8,
        'total_requirements': 10,
        'failures': 5,
        'total_operations': 1000,
        'user_satisfaction': 0.85,
        'learning_time': 2.0,
        'response_time': 0.5,
        'throughput': 500,
        'code_complexity': 3.5,
        'documentation_quality': 0.8,
        'platform_independence': 0.9,
        'dependency_count': 15
    }
    
    # è®¡ç®—æ•´ä½“è´¨é‡
    overall_quality = quality_metric.calculate_overall_quality(software_data)
    
    # è®¡ç®—å„ç»´åº¦è´¨é‡
    dimension_scores = {}
    for dimension in QualityDimension:
        if dimension in quality_metric.dimensions:
            score = quality_metric.dimensions[dimension](software_data)
            dimension_scores[dimension.value] = score
    
    return {
        'overall_quality': overall_quality,
        'dimension_scores': dimension_scores,
        'software_data': software_data
    }

def demonstrate_methodology_comparison():
    """æ¼”ç¤ºæ–¹æ³•è®ºæ¯”è¾ƒ"""
    
    # åˆ›å»ºä¸åŒæ–¹æ³•è®º
    agile = AgileMethodology()
    waterfall = WaterfallMethodology()
    
    # æ¯”è¾ƒæ–¹æ³•è®ºç‰¹å¾
    comparison = {
        'agile_phases': len(agile.phases),
        'waterfall_phases': len(waterfall.phases),
        'agile_activities': sum(len(activities) for activities in agile.activities.values()),
        'waterfall_activities': sum(len(activities) for activities in waterfall.activities.values()),
        'agile_roles': len(agile.roles),
        'waterfall_roles': len(waterfall.roles),
        'agile_principles': len(agile.principles),
        'waterfall_principles': len(waterfall.principles)
    }
    
    return {
        'agile': agile,
        'waterfall': waterfall,
        'comparison': comparison
    }

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    print("=== è½¯ä»¶å·¥ç¨‹ç†å¿µæ¼”ç¤º ===")
    
    # é¡¹ç›®ç®¡ç†æ¼”ç¤º
    project_results = demonstrate_project_management()
    print("\n1. é¡¹ç›®ç®¡ç†åˆ†æ:")
    print(f"   é¡¹ç›®å¤æ‚åº¦: {project_results['complexity']:.2f}")
    print(f"   ä¼°ç®—å·¥ä½œé‡: {project_results['effort']:.2f} äººæœˆ")
    print(f"   ä¼°ç®—å·¥æœŸ: {project_results['duration']:.2f} æœˆ")
    print(f"   ä¼°ç®—æˆæœ¬: {project_results['cost']:.2f} å…ƒ")
    
    # è´¨é‡è¯„ä¼°æ¼”ç¤º
    quality_results = demonstrate_quality_assessment()
    print("\n2. è´¨é‡è¯„ä¼°ç»“æœ:")
    print(f"   æ•´ä½“è´¨é‡åˆ†æ•°: {quality_results['overall_quality']:.2f}")
    print("   å„ç»´åº¦è´¨é‡åˆ†æ•°:")
    for dimension, score in quality_results['dimension_scores'].items():
        print(f"     {dimension}: {score:.2f}")
    
    # æ–¹æ³•è®ºæ¯”è¾ƒæ¼”ç¤º
    methodology_results = demonstrate_methodology_comparison()
    print("\n3. æ–¹æ³•è®ºæ¯”è¾ƒ:")
    for metric, value in methodology_results['comparison'].items():
        print(f"   {metric}: {value}")
```

### 5.2 è½¯ä»¶å·¥ç¨‹åŸåˆ™åº”ç”¨ç¤ºä¾‹

```python
def demonstrate_engineering_principles():
    """æ¼”ç¤ºè½¯ä»¶å·¥ç¨‹åŸåˆ™åº”ç”¨"""
    
    # åˆ›å»ºé¡¹ç›®
    project = SoftwareProject("ä¼ä¸šç®¡ç†ç³»ç»Ÿ", "å¼€å‘ä¸€ä¸ªä¼ä¸šèµ„æºç®¡ç†ç³»ç»Ÿ")
    
    # æ·»åŠ éœ€æ±‚
    requirements = [
        Requirement("REQ001", "ç”¨æˆ·ç®¡ç†æ¨¡å—", 1, 2.0, []),
        Requirement("REQ002", "æƒé™ç®¡ç†æ¨¡å—", 1, 3.0, ["REQ001"]),
        Requirement("REQ003", "æ•°æ®ç®¡ç†æ¨¡å—", 1, 2.5, []),
        Requirement("REQ004", "æŠ¥è¡¨ç”Ÿæˆæ¨¡å—", 2, 2.0, ["REQ003"]),
        Requirement("REQ005", "ç³»ç»Ÿé…ç½®æ¨¡å—", 3, 1.5, []),
        Requirement("REQ006", "æ—¥å¿—ç®¡ç†æ¨¡å—", 3, 1.0, ["REQ001"])
    ]
    
    for req in requirements:
        project.add_requirement(req)
    
    # åˆ›å»ºåŸåˆ™è¯„ä¼°å™¨
    principles = SoftwareEngineeringPrinciples()
    scores = principles.evaluate_project(project)
    
    # åˆ›å»ºåº¦é‡å™¨
    metrics = SoftwareEngineeringMetrics()
    metric_results = metrics.calculate_all_metrics(project)
    
    return {
        'project': project,
        'principle_scores': scores,
        'metric_results': metric_results
    }

# è¿è¡ŒåŸåˆ™æ¼”ç¤º
principle_results = demonstrate_engineering_principles()

print("\n=== è½¯ä»¶å·¥ç¨‹åŸåˆ™è¯„ä¼° ===")
print("1. åŸåˆ™ç¬¦åˆåº¦è¯„ä¼°:")
for principle, score in principle_results['principle_scores'].items():
    print(f"   {principle}: {score:.2f}")

print("\n2. å·¥ç¨‹åº¦é‡ç»“æœ:")
for metric, value in principle_results['metric_results'].items():
    print(f"   {metric}: {value:.2f}")
```

## 6. æ€§èƒ½åˆ†æ

### 6.1 è½¯ä»¶å·¥ç¨‹å¤æ‚åº¦åˆ†æ

**æ—¶é—´å¤æ‚åº¦**:
- é¡¹ç›®å¤æ‚åº¦è®¡ç®—: $O(n^2)$ (nä¸ºéœ€æ±‚æ•°é‡)
- è´¨é‡è¯„ä¼°: $O(k)$ (kä¸ºè´¨é‡ç»´åº¦æ•°é‡)
- åŸåˆ™è¯„ä¼°: $O(p)$ (pä¸ºåŸåˆ™æ•°é‡)

**ç©ºé—´å¤æ‚åº¦**:
- é¡¹ç›®å­˜å‚¨: $O(n + r + c)$ (néœ€æ±‚ï¼Œrèµ„æºï¼Œcçº¦æŸ)
- è´¨é‡æ•°æ®: $O(k)$
- åº¦é‡ç»“æœ: $O(m)$ (mä¸ºåº¦é‡æŒ‡æ ‡æ•°é‡)

### 6.2 æ–¹æ³•è®ºæ•ˆç‡æ¯”è¾ƒ

| æ–¹æ³•è®º | å¼€å‘æ•ˆç‡ | è´¨é‡ä¿è¯ | é£é™©æ§åˆ¶ | é€‚åº”æ€§ | å­¦ä¹ æˆæœ¬ |
|--------|----------|----------|----------|--------|----------|
| ç€‘å¸ƒå¼ | ä¸­ç­‰ | é«˜ | ä¸­ç­‰ | ä½ | ä½ |
| æ•æ·å¼ | é«˜ | ä¸­ç­‰ | é«˜ | é«˜ | ä¸­ç­‰ |
| èºæ—‹å¼ | ä¸­ç­‰ | é«˜ | é«˜ | ä¸­ç­‰ | é«˜ |
| åŸå‹æ³• | é«˜ | ä¸­ç­‰ | ä¸­ç­‰ | é«˜ | ä¸­ç­‰ |

## 7. æ€»ç»“

è½¯ä»¶å·¥ç¨‹ç†å¿µæ˜¯è½¯ä»¶å·¥ç¨‹çŸ¥è¯†ä½“ç³»çš„æ ¸å¿ƒæ€æƒ³åŸºç¡€ï¼Œå®ƒä»å“²å­¦å’Œå·¥ç¨‹å­¦è§’åº¦æ¢è®¨è½¯ä»¶å¼€å‘çš„æœ¬è´¨ã€åŸåˆ™å’Œæ–¹æ³•è®ºã€‚

### 7.1 æ ¸å¿ƒè§‚ç‚¹

1. **è½¯ä»¶å·¥ç¨‹çš„æœ¬è´¨**: è½¯ä»¶å·¥ç¨‹æ˜¯åº”ç”¨å·¥ç¨‹åŸç†åˆ°è½¯ä»¶å¼€å‘ä¸­çš„ç³»ç»Ÿæ€§æ–¹æ³•ã€‚

2. **è´¨é‡å¯¼å‘**: è½¯ä»¶å·¥ç¨‹ä»¥è½¯ä»¶è´¨é‡ä¸ºæ ¸å¿ƒç›®æ ‡ï¼Œé€šè¿‡ç³»ç»ŸåŒ–çš„æ–¹æ³•ç¡®ä¿è½¯ä»¶è´¨é‡ã€‚

3. **æƒè¡¡ç®¡ç†**: åœ¨è´¨é‡ã€æˆæœ¬ã€æ—¶é—´ä¸‰ä¸ªç›®æ ‡ä¹‹é—´è¿›è¡Œæƒè¡¡ç®¡ç†æ˜¯è½¯ä»¶å·¥ç¨‹çš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚

4. **æŒç»­æ”¹è¿›**: è½¯ä»¶å·¥ç¨‹å¼ºè°ƒæŒç»­æ”¹è¿›å¼€å‘æ–¹æ³•å’Œè¿‡ç¨‹ã€‚

### 7.2 å®é™…æ„ä¹‰

1. **é¡¹ç›®ç®¡ç†æŒ‡å¯¼**: ä¸ºè½¯ä»¶é¡¹ç›®ç®¡ç†æä¾›ç†è®ºæŒ‡å¯¼
2. **è´¨é‡ä¿è¯**: å»ºç«‹è½¯ä»¶è´¨é‡ä¿è¯çš„ç†è®ºæ¡†æ¶
3. **æ–¹æ³•é€‰æ‹©**: ä¸ºé€‰æ‹©åˆé€‚çš„å¼€å‘æ–¹æ³•æä¾›ä¾æ®
4. **è¿‡ç¨‹æ”¹è¿›**: æŒ‡å¯¼è½¯ä»¶å¼€å‘è¿‡ç¨‹çš„æŒç»­æ”¹è¿›

### 7.3 æœªæ¥å‘å±•æ–¹å‘

1. **æ™ºèƒ½åŒ–**: ç»“åˆäººå·¥æ™ºèƒ½æŠ€æœ¯å®ç°æ™ºèƒ½åŒ–è½¯ä»¶å·¥ç¨‹
2. **è‡ªåŠ¨åŒ–**: æé«˜è½¯ä»¶å¼€å‘è¿‡ç¨‹çš„è‡ªåŠ¨åŒ–ç¨‹åº¦
3. **ç»¿è‰²åŒ–**: å‘å±•ç»¿è‰²è½¯ä»¶å·¥ç¨‹ï¼Œå‡å°‘ç¯å¢ƒå½±å“
4. **é‡å­åŒ–**: æ¢ç´¢é‡å­è½¯ä»¶å·¥ç¨‹çš„æ–°æ–¹å‘

---

*åˆ›å»ºæ—¶é—´: 2024-12-19*
*æœ€åæ›´æ–°: 2024-12-19*
*æ–‡æ¡£çŠ¶æ€: å®Œæˆ* 