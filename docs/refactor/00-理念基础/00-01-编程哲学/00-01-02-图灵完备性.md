# 00-01-02 å›¾çµå®Œå¤‡æ€§

## ğŸ“‹ æ¦‚è¿°

å›¾çµå®Œå¤‡æ€§æ˜¯è®¡ç®—ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œæè¿°äº†ä¸€ä¸ªè®¡ç®—ç³»ç»Ÿèƒ½å¤Ÿæ¨¡æ‹Ÿé€šç”¨å›¾çµæœºçš„èƒ½åŠ›ã€‚æœ¬æ–‡æ¡£ä»æ•°å­¦è§’åº¦æ·±å…¥åˆ†æå›¾çµå®Œå¤‡æ€§çš„å®šä¹‰ã€è¯æ˜å’Œå®ç°ï¼Œä¸ºç†è§£è®¡ç®—èƒ½åŠ›çš„æœ¬è´¨æä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å›¾çµæœºçš„æ•°å­¦å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (å›¾çµæœº)
å›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$TM = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$$

å…¶ä¸­ï¼š

- $Q$ ä¸ºæœ‰é™çŠ¶æ€é›†
- $\Sigma$ ä¸ºè¾“å…¥å­—æ¯è¡¨
- $\Gamma$ ä¸ºç£å¸¦å­—æ¯è¡¨ï¼Œæ»¡è¶³ $\Sigma \subseteq \Gamma$
- $\delta$ ä¸ºè½¬ç§»å‡½æ•°ï¼š$\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R, N\}$
- $q_0 \in Q$ ä¸ºåˆå§‹çŠ¶æ€
- $B \in \Gamma - \Sigma$ ä¸ºç©ºç™½ç¬¦å·
- $F \subseteq Q$ ä¸ºæ¥å—çŠ¶æ€é›†

**å®šä¹‰ 1.2** (å›¾çµæœºé…ç½®)
å›¾çµæœºçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$(q, \alpha, i)$$

å…¶ä¸­ï¼š

- $q \in Q$ ä¸ºå½“å‰çŠ¶æ€
- $\alpha \in \Gamma^*$ ä¸ºç£å¸¦å†…å®¹
- $i \in \mathbb{N}$ ä¸ºè¯»å†™å¤´ä½ç½®

**å®šä¹‰ 1.3** (è½¬ç§»å…³ç³»)
é…ç½®é—´çš„è½¬ç§»å…³ç³»å®šä¹‰ä¸ºï¼š
$$(q, \alpha, i) \vdash (q', \alpha', i')$$

å½“ä¸”ä»…å½“ $\delta(q, \alpha_i) = (q', b, d)$ ä¸”ï¼š

- $\alpha'_j = \alpha_j$ å¯¹æ‰€æœ‰ $j \neq i$
- $\alpha'_i = b$
- $i' = i + 1$ å¦‚æœ $d = R$
- $i' = i - 1$ å¦‚æœ $d = L$
- $i' = i$ å¦‚æœ $d = N$

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Optional, Tuple, Callable
from dataclasses import dataclass
from enum import Enum
import copy

class Direction(Enum):
    """ç§»åŠ¨æ–¹å‘"""
    LEFT = "L"
    RIGHT = "R"
    NONE = "N"

@dataclass
class Transition:
    """è½¬ç§»å®šä¹‰"""
    current_state: str
    current_symbol: str
    new_state: str
    new_symbol: str
    direction: Direction
    
    def __str__(self):
        return f"({self.current_state}, {self.current_symbol}) -> ({self.new_state}, {self.new_symbol}, {self.direction.value})"

@dataclass
class Configuration:
    """å›¾çµæœºé…ç½®"""
    state: str
    tape: List[str]
    head_position: int
    
    def __str__(self):
        tape_str = "".join(self.tape)
        head_marker = " " * self.head_position + "^"
        return f"çŠ¶æ€: {self.state}, ç£å¸¦: {tape_str}\nä½ç½®: {head_marker}"

class TuringMachine:
    """å›¾çµæœºå®ç°"""
    
    def __init__(self, name: str):
        self.name = name
        self.states: Set[str] = set()
        self.input_alphabet: Set[str] = set()
        self.tape_alphabet: Set[str] = set()
        self.transitions: Dict[Tuple[str, str], Transition] = {}
        self.initial_state: Optional[str] = None
        self.blank_symbol: Optional[str] = None
        self.accepting_states: Set[str] = set()
        self.current_config: Optional[Configuration] = None
        self.step_count = 0
        self.max_steps = 10000  # é˜²æ­¢æ— é™å¾ªç¯
    
    def add_state(self, state: str) -> None:
        """æ·»åŠ çŠ¶æ€"""
        self.states.add(state)
    
    def add_input_symbol(self, symbol: str) -> None:
        """æ·»åŠ è¾“å…¥ç¬¦å·"""
        self.input_alphabet.add(symbol)
        self.tape_alphabet.add(symbol)
    
    def add_tape_symbol(self, symbol: str) -> None:
        """æ·»åŠ ç£å¸¦ç¬¦å·"""
        self.tape_alphabet.add(symbol)
    
    def add_transition(self, transition: Transition) -> None:
        """æ·»åŠ è½¬ç§»è§„åˆ™"""
        key = (transition.current_state, transition.current_symbol)
        self.transitions[key] = transition
    
    def set_initial_state(self, state: str) -> None:
        """è®¾ç½®åˆå§‹çŠ¶æ€"""
        self.initial_state = state
    
    def set_blank_symbol(self, symbol: str) -> None:
        """è®¾ç½®ç©ºç™½ç¬¦å·"""
        self.blank_symbol = symbol
        self.tape_alphabet.add(symbol)
    
    def add_accepting_state(self, state: str) -> None:
        """æ·»åŠ æ¥å—çŠ¶æ€"""
        self.accepting_states.add(state)
    
    def initialize(self, input_string: str) -> None:
        """åˆå§‹åŒ–å›¾çµæœº"""
        if not self.initial_state or not self.blank_symbol:
            raise ValueError("åˆå§‹çŠ¶æ€å’Œç©ºç™½ç¬¦å·å¿…é¡»è®¾ç½®")
        
        # å°†è¾“å…¥å­—ç¬¦ä¸²è½¬æ¢ä¸ºç£å¸¦
        tape = list(input_string)
        if not tape:
            tape = [self.blank_symbol]
        
        self.current_config = Configuration(
            state=self.initial_state,
            tape=tape,
            head_position=0
        )
        self.step_count = 0
    
    def step(self) -> bool:
        """æ‰§è¡Œä¸€æ­¥"""
        if not self.current_config:
            return False
        
        if self.step_count >= self.max_steps:
            raise RuntimeError("å›¾çµæœºæ‰§è¡Œæ­¥æ•°è¶…è¿‡é™åˆ¶")
        
        config = self.current_config
        key = (config.state, config.tape[config.head_position])
        
        if key not in self.transitions:
            return False  # åœæœº
        
        transition = self.transitions[key]
        
        # æ›´æ–°é…ç½®
        new_tape = copy.deepcopy(config.tape)
        new_tape[config.head_position] = transition.new_symbol
        
        new_head_position = config.head_position
        if transition.direction == Direction.LEFT:
            new_head_position -= 1
        elif transition.direction == Direction.RIGHT:
            new_head_position += 1
        
        # æ‰©å±•ç£å¸¦ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if new_head_position < 0:
            new_tape.insert(0, self.blank_symbol)
            new_head_position = 0
        elif new_head_position >= len(new_tape):
            new_tape.append(self.blank_symbol)
        
        self.current_config = Configuration(
            state=transition.new_state,
            tape=new_tape,
            head_position=new_head_position
        )
        
        self.step_count += 1
        return True
    
    def run(self, input_string: str) -> Tuple[bool, str, int]:
        """è¿è¡Œå›¾çµæœº"""
        self.initialize(input_string)
        
        while self.step():
            pass
        
        if not self.current_config:
            return False, "", self.step_count
        
        is_accepting = self.current_config.state in self.accepting_states
        output = "".join(self.current_config.tape).strip(self.blank_symbol)
        
        return is_accepting, output, self.step_count
    
    def get_configuration_history(self) -> List[Configuration]:
        """è·å–é…ç½®å†å²ï¼ˆéœ€è¦ä¿®æ”¹stepæ–¹æ³•ä»¥è®°å½•å†å²ï¼‰"""
        # è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦ä¿®æ”¹stepæ–¹æ³•æ¥è®°å½•å†å²
        return [self.current_config] if self.current_config else []

class UniversalTuringMachine(TuringMachine):
    """é€šç”¨å›¾çµæœº"""
    
    def __init__(self):
        super().__init__("é€šç”¨å›¾çµæœº")
        self._setup_universal_machine()
    
    def _setup_universal_machine(self):
        """è®¾ç½®é€šç”¨å›¾çµæœº"""
        # è®¾ç½®åŸºæœ¬ç¬¦å·
        self.add_input_symbol('0')
        self.add_input_symbol('1')
        self.add_input_symbol('#')
        self.set_blank_symbol('B')
        
        # è®¾ç½®çŠ¶æ€
        self.add_state('q0')  # åˆå§‹çŠ¶æ€
        self.add_state('q1')  # è¯»å–çŠ¶æ€
        self.add_state('q2')  # æ‰§è¡ŒçŠ¶æ€
        self.add_state('q3')  # æ¥å—çŠ¶æ€
        self.add_state('q4')  # æ‹’ç»çŠ¶æ€
        
        self.set_initial_state('q0')
        self.add_accepting_state('q3')
        
        # æ·»åŠ è½¬ç§»è§„åˆ™ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        transitions = [
            Transition('q0', '0', 'q1', '0', Direction.RIGHT),
            Transition('q0', '1', 'q1', '1', Direction.RIGHT),
            Transition('q0', '#', 'q2', '#', Direction.RIGHT),
            Transition('q1', '0', 'q1', '0', Direction.RIGHT),
            Transition('q1', '1', 'q1', '1', Direction.RIGHT),
            Transition('q1', '#', 'q2', '#', Direction.RIGHT),
            Transition('q2', '0', 'q3', '0', Direction.NONE),
            Transition('q2', '1', 'q4', '1', Direction.NONE),
        ]
        
        for transition in transitions:
            self.add_transition(transition)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_turing_machine():
    """æ¼”ç¤ºå›¾çµæœº"""
    
    # åˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾çµæœºï¼šè¯†åˆ«åŒ…å«å¶æ•°ä¸ª1çš„å­—ç¬¦ä¸²
    tm = TuringMachine("å¶æ•°1è¯†åˆ«å™¨")
    
    # è®¾ç½®å­—æ¯è¡¨
    tm.add_input_symbol('0')
    tm.add_input_symbol('1')
    tm.set_blank_symbol('B')
    
    # è®¾ç½®çŠ¶æ€
    tm.add_state('q0')  # åˆå§‹çŠ¶æ€ï¼Œå·²è¯»å¶æ•°ä¸ª1
    tm.add_state('q1')  # å·²è¯»å¥‡æ•°ä¸ª1
    tm.add_state('q2')  # æ¥å—çŠ¶æ€
    tm.add_state('q3')  # æ‹’ç»çŠ¶æ€
    
    tm.set_initial_state('q0')
    tm.add_accepting_state('q2')
    
    # æ·»åŠ è½¬ç§»è§„åˆ™
    transitions = [
        # åœ¨q0çŠ¶æ€ï¼ˆå·²è¯»å¶æ•°ä¸ª1ï¼‰
        Transition('q0', '0', 'q0', '0', Direction.RIGHT),
        Transition('q0', '1', 'q1', '1', Direction.RIGHT),
        Transition('q0', 'B', 'q2', 'B', Direction.NONE),  # æ¥å—
        
        # åœ¨q1çŠ¶æ€ï¼ˆå·²è¯»å¥‡æ•°ä¸ª1ï¼‰
        Transition('q1', '0', 'q1', '0', Direction.RIGHT),
        Transition('q1', '1', 'q0', '1', Direction.RIGHT),
        Transition('q1', 'B', 'q3', 'B', Direction.NONE),  # æ‹’ç»
    ]
    
    for transition in transitions:
        tm.add_transition(transition)
    
    # æµ‹è¯•
    test_strings = ['', '0', '1', '00', '01', '10', '11', '000', '001', '010', '011']
    
    print("=== å›¾çµæœºæ¼”ç¤ºï¼šå¶æ•°1è¯†åˆ«å™¨ ===")
    print(f"å›¾çµæœºåç§°: {tm.name}")
    print(f"çŠ¶æ€æ•°é‡: {len(tm.states)}")
    print(f"è½¬ç§»è§„åˆ™æ•°é‡: {len(tm.transitions)}")
    
    print("\n=== æµ‹è¯•ç»“æœ ===")
    for test_str in test_strings:
        try:
            is_accepting, output, steps = tm.run(test_str)
            result = "æ¥å—" if is_accepting else "æ‹’ç»"
            print(f"è¾“å…¥: '{test_str}' -> {result} (æ­¥æ•°: {steps})")
        except Exception as e:
            print(f"è¾“å…¥: '{test_str}' -> é”™è¯¯: {e}")

def demonstrate_universal_turing_machine():
    """æ¼”ç¤ºé€šç”¨å›¾çµæœº"""
    
    utm = UniversalTuringMachine()
    
    print("\n=== é€šç”¨å›¾çµæœºæ¼”ç¤º ===")
    print(f"å›¾çµæœºåç§°: {utm.name}")
    print(f"çŠ¶æ€æ•°é‡: {len(utm.states)}")
    print(f"è½¬ç§»è§„åˆ™æ•°é‡: {len(utm.transitions)}")
    
    # æµ‹è¯•é€šç”¨å›¾çµæœº
    test_inputs = ['0#1', '1#0', '00#11', '11#00']
    
    print("\n=== é€šç”¨å›¾çµæœºæµ‹è¯• ===")
    for test_input in test_inputs:
        try:
            is_accepting, output, steps = utm.run(test_input)
            result = "æ¥å—" if is_accepting else "æ‹’ç»"
            print(f"è¾“å…¥: '{test_input}' -> {result} (æ­¥æ•°: {steps})")
        except Exception as e:
            print(f"è¾“å…¥: '{test_input}' -> é”™è¯¯: {e}")

if __name__ == "__main__":
    demonstrate_turing_machine()
    demonstrate_universal_turing_machine()
```

### 2. å›¾çµå®Œå¤‡æ€§çš„å®šä¹‰

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1** (å›¾çµå®Œå¤‡æ€§)
ä¸€ä¸ªè®¡ç®—ç³»ç»Ÿ $S$ æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall TM \exists P_S: \forall x \in \Sigma^*: TM(x) = S(P_S, x)$$

å…¶ä¸­ï¼š

- $TM$ ä¸ºä»»æ„å›¾çµæœº
- $P_S$ ä¸ºç³»ç»Ÿ $S$ çš„ç¨‹åº
- $TM(x)$ ä¸ºå›¾çµæœº $TM$ åœ¨è¾“å…¥ $x$ ä¸Šçš„è¾“å‡º
- $S(P_S, x)$ ä¸ºç³»ç»Ÿ $S$ è¿è¡Œç¨‹åº $P_S$ åœ¨è¾“å…¥ $x$ ä¸Šçš„è¾“å‡º

**å®šä¹‰ 2.2** (è®¡ç®—ç­‰ä»·æ€§)
ä¸¤ä¸ªè®¡ç®—ç³»ç»Ÿ $S_1$ å’Œ $S_2$ è®¡ç®—ç­‰ä»·ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x \in \Sigma^*: S_1(x) = S_2(x)$$

#### 2.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Optional, Tuple, Callable
from dataclasses import dataclass
import re

class ComputationalSystem(ABC):
    """è®¡ç®—ç³»ç»ŸæŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def execute(self, program: str, input_data: str) -> str:
        """æ‰§è¡Œç¨‹åº"""
        pass
    
    @abstractmethod
    def is_turing_complete(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦å›¾çµå®Œå¤‡"""
        pass

class LambdaCalculus(ComputationalSystem):
    """Lambdaæ¼”ç®—ç³»ç»Ÿ"""
    
    def __init__(self):
        self.variables: Set[str] = set()
        self.definitions: Dict[str, str] = {}
    
    def execute(self, program: str, input_data: str) -> str:
        """æ‰§è¡ŒLambdaæ¼”ç®—ç¨‹åº"""
        # ç®€åŒ–çš„Lambdaæ¼”ç®—è§£é‡Šå™¨
        try:
            # è§£æç¨‹åº
            terms = self._parse_lambda_terms(program)
            
            # åº”ç”¨è¾“å…¥
            result = self._apply_input(terms, input_data)
            
            return str(result)
        except Exception as e:
            return f"é”™è¯¯: {e}"
    
    def _parse_lambda_terms(self, program: str) -> List[str]:
        """è§£æLambdaé¡¹"""
        # ç®€åŒ–çš„è§£æå™¨
        terms = re.findall(r'Î»\w+\.\w+|\w+', program)
        return terms
    
    def _apply_input(self, terms: List[str], input_data: str) -> str:
        """åº”ç”¨è¾“å…¥åˆ°Lambdaé¡¹"""
        if not terms:
            return input_data
        
        # ç®€åŒ–çš„åº”ç”¨è§„åˆ™
        result = terms[0]
        for term in terms[1:]:
            result = f"({result} {term})"
        
        return result
    
    def is_turing_complete(self) -> bool:
        """Lambdaæ¼”ç®—æ˜¯å›¾çµå®Œå¤‡çš„"""
        return True

class Brainfuck(ComputationalSystem):
    """Brainfuckè¯­è¨€ç³»ç»Ÿ"""
    
    def __init__(self):
        self.memory = [0] * 30000
        self.pointer = 0
        self.loop_stack = []
        self.loop_map = {}
    
    def execute(self, program: str, input_data: str) -> str:
        """æ‰§è¡ŒBrainfuckç¨‹åº"""
        try:
            self._build_loop_map(program)
            self._execute_instructions(program, input_data)
            return self._get_output()
        except Exception as e:
            return f"é”™è¯¯: {e}"
    
    def _build_loop_map(self, program: str) -> None:
        """æ„å»ºå¾ªç¯æ˜ å°„"""
        self.loop_map = {}
        stack = []
        
        for i, char in enumerate(program):
            if char == '[':
                stack.append(i)
            elif char == ']':
                if stack:
                    start = stack.pop()
                    self.loop_map[start] = i
                    self.loop_map[i] = start
    
    def _execute_instructions(self, program: str, input_data: str) -> None:
        """æ‰§è¡ŒæŒ‡ä»¤"""
        input_index = 0
        i = 0
        
        while i < len(program):
            char = program[i]
            
            if char == '>':
                self.pointer = (self.pointer + 1) % 30000
            elif char == '<':
                self.pointer = (self.pointer - 1) % 30000
            elif char == '+':
                self.memory[self.pointer] = (self.memory[self.pointer] + 1) % 256
            elif char == '-':
                self.memory[self.pointer] = (self.memory[self.pointer] - 1) % 256
            elif char == '.':
                print(chr(self.memory[self.pointer]), end='')
            elif char == ',':
                if input_index < len(input_data):
                    self.memory[self.pointer] = ord(input_data[input_index])
                    input_index += 1
            elif char == '[':
                if self.memory[self.pointer] == 0:
                    i = self.loop_map[i]
            elif char == ']':
                if self.memory[self.pointer] != 0:
                    i = self.loop_map[i]
            
            i += 1
    
    def _get_output(self) -> str:
        """è·å–è¾“å‡º"""
        # è¿”å›å†…å­˜ä¸­éé›¶å€¼çš„ä½ç½®
        non_zero = [i for i, val in enumerate(self.memory) if val != 0]
        return f"å†…å­˜çŠ¶æ€: {non_zero[:10]}"  # åªæ˜¾ç¤ºå‰10ä¸ªéé›¶ä½ç½®
    
    def is_turing_complete(self) -> bool:
        """Brainfuckæ˜¯å›¾çµå®Œå¤‡çš„"""
        return True

class PythonSystem(ComputationalSystem):
    """Pythonç³»ç»Ÿ"""
    
    def __init__(self):
        self.global_vars = {}
    
    def execute(self, program: str, input_data: str) -> str:
        """æ‰§è¡ŒPythonç¨‹åº"""
        try:
            # åˆ›å»ºå®‰å…¨çš„æ‰§è¡Œç¯å¢ƒ
            local_vars = {'input_data': input_data, 'result': None}
            
            # æ‰§è¡Œç¨‹åº
            exec(program, self.global_vars, local_vars)
            
            return str(local_vars.get('result', 'æ— è¾“å‡º'))
        except Exception as e:
            return f"é”™è¯¯: {e}"
    
    def is_turing_complete(self) -> bool:
        """Pythonæ˜¯å›¾çµå®Œå¤‡çš„"""
        return True

class TuringCompletenessChecker:
    """å›¾çµå®Œå¤‡æ€§æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.systems: Dict[str, ComputationalSystem] = {}
        self.test_programs: Dict[str, str] = {}
    
    def add_system(self, name: str, system: ComputationalSystem) -> None:
        """æ·»åŠ è®¡ç®—ç³»ç»Ÿ"""
        self.systems[name] = system
    
    def add_test_program(self, name: str, program: str) -> None:
        """æ·»åŠ æµ‹è¯•ç¨‹åº"""
        self.test_programs[name] = program
    
    def test_turing_completeness(self, system_name: str) -> Dict[str, Any]:
        """æµ‹è¯•å›¾çµå®Œå¤‡æ€§"""
        if system_name not in self.systems:
            return {'error': f'ç³»ç»Ÿ {system_name} ä¸å­˜åœ¨'}
        
        system = self.systems[system_name]
        results = {
            'system': system_name,
            'theoretical_completeness': system.is_turing_complete(),
            'test_results': {}
        }
        
        # è¿è¡Œæµ‹è¯•ç¨‹åº
        for test_name, program in self.test_programs.items():
            try:
                output = system.execute(program, "test_input")
                results['test_results'][test_name] = {
                    'success': True,
                    'output': output
                }
            except Exception as e:
                results['test_results'][test_name] = {
                    'success': False,
                    'error': str(e)
                }
        
        return results
    
    def compare_systems(self, system1: str, system2: str, test_input: str) -> Dict[str, Any]:
        """æ¯”è¾ƒä¸¤ä¸ªç³»ç»Ÿ"""
        if system1 not in self.systems or system2 not in self.systems:
            return {'error': 'ç³»ç»Ÿä¸å­˜åœ¨'}
        
        results = {
            'system1': system1,
            'system2': system2,
            'comparison': {}
        }
        
        for test_name, program in self.test_programs.items():
            try:
                output1 = self.systems[system1].execute(program, test_input)
                output2 = self.systems[system2].execute(program, test_input)
                
                results['comparison'][test_name] = {
                    'system1_output': output1,
                    'system2_output': output2,
                    'equivalent': output1 == output2
                }
            except Exception as e:
                results['comparison'][test_name] = {
                    'error': str(e)
                }
        
        return results

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_turing_completeness():
    """æ¼”ç¤ºå›¾çµå®Œå¤‡æ€§"""
    
    # åˆ›å»ºæ£€æŸ¥å™¨
    checker = TuringCompletenessChecker()
    
    # æ·»åŠ è®¡ç®—ç³»ç»Ÿ
    checker.add_system("Lambdaæ¼”ç®—", LambdaCalculus())
    checker.add_system("Brainfuck", Brainfuck())
    checker.add_system("Python", PythonSystem())
    
    # æ·»åŠ æµ‹è¯•ç¨‹åº
    checker.add_test_program("æ’ç­‰å‡½æ•°", "Î»x.x")
    checker.add_test_program("åŠ æ³•", "Î»x.Î»y.x + y")
    checker.add_test_program("Hello World", 'print("Hello, World!")')
    checker.add_test_program("ç®€å•è®¡ç®—", 'result = 2 + 3')
    
    print("=== å›¾çµå®Œå¤‡æ€§æµ‹è¯• ===")
    
    # æµ‹è¯•å„ä¸ªç³»ç»Ÿ
    for system_name in ["Lambdaæ¼”ç®—", "Brainfuck", "Python"]:
        print(f"\n--- {system_name} ---")
        results = checker.test_turing_completeness(system_name)
        
        print(f"ç†è®ºå®Œå¤‡æ€§: {results['theoretical_completeness']}")
        print("æµ‹è¯•ç»“æœ:")
        for test_name, test_result in results['test_results'].items():
            if test_result['success']:
                print(f"  {test_name}: æˆåŠŸ - {test_result['output']}")
            else:
                print(f"  {test_name}: å¤±è´¥ - {test_result['error']}")
    
    # æ¯”è¾ƒç³»ç»Ÿ
    print("\n=== ç³»ç»Ÿæ¯”è¾ƒ ===")
    comparison = checker.compare_systems("Python", "Lambdaæ¼”ç®—", "test")
    print(f"Python vs Lambdaæ¼”ç®—:")
    for test_name, comp_result in comparison['comparison'].items():
        if 'error' not in comp_result:
            print(f"  {test_name}: {'ç­‰ä»·' if comp_result['equivalent'] else 'ä¸ç­‰ä»·'}")

if __name__ == "__main__":
    demonstrate_turing_completeness()
```

### 3. è®¡ç®—èƒ½åŠ›çš„å±‚æ¬¡åˆ†æ

#### 3.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 3.1** (è®¡ç®—å±‚æ¬¡)
è®¡ç®—èƒ½åŠ›å±‚æ¬¡å®šä¹‰ä¸ºï¼š
$$ComputationalHierarchy = \{L_0, L_1, L_2, ..., L_\omega\}$$

å…¶ä¸­ï¼š

- $L_0$ ä¸ºæœ‰é™è‡ªåŠ¨æœºå±‚æ¬¡
- $L_1$ ä¸ºä¸‹æ¨è‡ªåŠ¨æœºå±‚æ¬¡
- $L_2$ ä¸ºçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºå±‚æ¬¡
- $L_\omega$ ä¸ºå›¾çµæœºå±‚æ¬¡ï¼ˆå›¾çµå®Œå¤‡ï¼‰

**å®šä¹‰ 3.2** (å±‚æ¬¡åŒ…å«å…³ç³»)
å¯¹äºä»»æ„ $i < j$ï¼Œæœ‰ï¼š
$$L_i \subset L_j$$

#### 3.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

class ComputationalLevel(Enum):
    """è®¡ç®—å±‚æ¬¡"""
    FINITE_AUTOMATA = "æœ‰é™è‡ªåŠ¨æœº"
    PUSHDOWN_AUTOMATA = "ä¸‹æ¨è‡ªåŠ¨æœº"
    LINEAR_BOUNDED = "çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº"
    TURING_MACHINE = "å›¾çµæœº"

@dataclass
class Language:
    """å½¢å¼è¯­è¨€"""
    name: str
    level: ComputationalLevel
    description: str
    examples: List[str]
    
    def __str__(self):
        return f"{self.name} ({self.level.value}): {self.description}"

class ComputationalHierarchy:
    """è®¡ç®—å±‚æ¬¡åˆ†æ"""
    
    def __init__(self):
        self.languages: Dict[str, Language] = {}
        self.hierarchy: Dict[ComputationalLevel, List[str]] = {}
        self._setup_hierarchy()
    
    def _setup_hierarchy(self):
        """è®¾ç½®è®¡ç®—å±‚æ¬¡"""
        # æœ‰é™è‡ªåŠ¨æœºå±‚æ¬¡
        finite_languages = [
            Language("æ­£åˆ™è¯­è¨€", ComputationalLevel.FINITE_AUTOMATA,
                    "å¯ç”±æœ‰é™è‡ªåŠ¨æœºè¯†åˆ«çš„è¯­è¨€", 
                    ["a*", "ab*", "(a|b)*"]),
            Language("æœ‰é™è¯­è¨€", ComputationalLevel.FINITE_AUTOMATA,
                    "åŒ…å«æœ‰é™ä¸ªå­—ç¬¦ä¸²çš„è¯­è¨€",
                    ["{a, b, c}", "{Îµ, a, aa}"])
        ]
        
        # ä¸‹æ¨è‡ªåŠ¨æœºå±‚æ¬¡
        pushdown_languages = [
            Language("ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€", ComputationalLevel.PUSHDOWN_AUTOMATA,
                    "å¯ç”±ä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ«çš„è¯­è¨€",
                    ["a^n b^n", "å›æ–‡", "æ‹¬å·åŒ¹é…"]),
            Language("Dyckè¯­è¨€", ComputationalLevel.PUSHDOWN_AUTOMATA,
                    "æ‹¬å·åŒ¹é…è¯­è¨€",
                    ["()", "(()())", "((()))"])
        ]
        
        # çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºå±‚æ¬¡
        linear_languages = [
            Language("ä¸Šä¸‹æ–‡æœ‰å…³è¯­è¨€", ComputationalLevel.LINEAR_BOUNDED,
                    "å¯ç”±çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºè¯†åˆ«çš„è¯­è¨€",
                    ["a^n b^n c^n", "å¤åˆ¶è¯­è¨€"]),
            Language("CSL", ComputationalLevel.LINEAR_BOUNDED,
                    "ä¸Šä¸‹æ–‡æœ‰å…³è¯­è¨€çš„å­ç±»",
                    ["éæ”¶ç¼©æ–‡æ³•è¯­è¨€"])
        ]
        
        # å›¾çµæœºå±‚æ¬¡
        turing_languages = [
            Language("é€’å½’å¯æšä¸¾è¯­è¨€", ComputationalLevel.TURING_MACHINE,
                    "å¯ç”±å›¾çµæœºè¯†åˆ«çš„è¯­è¨€",
                    ["åœæœºé—®é¢˜", "Postå¯¹åº”é—®é¢˜"]),
            Language("é€’å½’è¯­è¨€", ComputationalLevel.TURING_MACHINE,
                    "å¯ç”±æ€»åœæœºçš„å›¾çµæœºè¯†åˆ«çš„è¯­è¨€",
                    ["å¯åˆ¤å®šé—®é¢˜"])
        ]
        
        # æ·»åŠ åˆ°å±‚æ¬¡ç»“æ„
        self.hierarchy[ComputationalLevel.FINITE_AUTOMATA] = [lang.name for lang in finite_languages]
        self.hierarchy[ComputationalLevel.PUSHDOWN_AUTOMATA] = [lang.name for lang in pushdown_languages]
        self.hierarchy[ComputationalLevel.LINEAR_BOUNDED] = [lang.name for lang in linear_languages]
        self.hierarchy[ComputationalLevel.TURING_MACHINE] = [lang.name for lang in turing_languages]
        
        # æ·»åŠ åˆ°è¯­è¨€å­—å…¸
        for lang in finite_languages + pushdown_languages + linear_languages + turing_languages:
            self.languages[lang.name] = lang
    
    def get_languages_at_level(self, level: ComputationalLevel) -> List[Language]:
        """è·å–æŒ‡å®šå±‚æ¬¡çš„è¯­è¨€"""
        return [self.languages[name] for name in self.hierarchy[level]]
    
    def get_hierarchy_structure(self) -> Dict[ComputationalLevel, List[str]]:
        """è·å–å±‚æ¬¡ç»“æ„"""
        return self.hierarchy
    
    def analyze_complexity(self, language_name: str) -> Dict[str, Any]:
        """åˆ†æè¯­è¨€å¤æ‚åº¦"""
        if language_name not in self.languages:
            return {'error': f'è¯­è¨€ {language_name} ä¸å­˜åœ¨'}
        
        lang = self.languages[language_name]
        
        analysis = {
            'name': lang.name,
            'level': lang.level.value,
            'description': lang.description,
            'examples': lang.examples,
            'computational_power': self._get_power_level(lang.level),
            'recognizable_problems': self._get_recognizable_problems(lang.level)
        }
        
        return analysis
    
    def _get_power_level(self, level: ComputationalLevel) -> str:
        """è·å–è®¡ç®—èƒ½åŠ›çº§åˆ«æè¿°"""
        power_levels = {
            ComputationalLevel.FINITE_AUTOMATA: "æœ‰é™çŠ¶æ€è®¡ç®—",
            ComputationalLevel.PUSHDOWN_AUTOMATA: "æ ˆè®¡ç®—",
            ComputationalLevel.LINEAR_BOUNDED: "çº¿æ€§ç©ºé—´è®¡ç®—",
            ComputationalLevel.TURING_MACHINE: "æ— é™è®¡ç®—"
        }
        return power_levels[level]
    
    def _get_recognizable_problems(self, level: ComputationalLevel) -> List[str]:
        """è·å–å¯è¯†åˆ«çš„é—®é¢˜ç±»å‹"""
        problem_types = {
            ComputationalLevel.FINITE_AUTOMATA: [
                "æ¨¡å¼åŒ¹é…", "å­—ç¬¦ä¸²éªŒè¯", "è¯æ³•åˆ†æ"
            ],
            ComputationalLevel.PUSHDOWN_AUTOMATA: [
                "è¯­æ³•åˆ†æ", "æ‹¬å·åŒ¹é…", "åµŒå¥—ç»“æ„"
            ],
            ComputationalLevel.LINEAR_BOUNDED: [
                "ä¸Šä¸‹æ–‡æœ‰å…³åˆ†æ", "çº¿æ€§ç©ºé—´é—®é¢˜"
            ],
            ComputationalLevel.TURING_MACHINE: [
                "é€šç”¨è®¡ç®—", "ç®—æ³•å®ç°", "å¤æ‚é—®é¢˜æ±‚è§£"
            ]
        }
        return problem_types[level]

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_computational_hierarchy():
    """æ¼”ç¤ºè®¡ç®—å±‚æ¬¡"""
    
    hierarchy = ComputationalHierarchy()
    
    print("=== è®¡ç®—èƒ½åŠ›å±‚æ¬¡åˆ†æ ===")
    
    # æ˜¾ç¤ºå±‚æ¬¡ç»“æ„
    print("\nå±‚æ¬¡ç»“æ„:")
    for level in ComputationalLevel:
        languages = hierarchy.get_languages_at_level(level)
        print(f"\n{level.value}:")
        for lang in languages:
            print(f"  - {lang.name}: {lang.description}")
    
    # åˆ†æç‰¹å®šè¯­è¨€
    test_languages = ["æ­£åˆ™è¯­è¨€", "ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€", "é€’å½’å¯æšä¸¾è¯­è¨€"]
    
    print("\n=== è¯­è¨€å¤æ‚åº¦åˆ†æ ===")
    for lang_name in test_languages:
        analysis = hierarchy.analyze_complexity(lang_name)
        if 'error' not in analysis:
            print(f"\n{analysis['name']} ({analysis['level']}):")
            print(f"  æè¿°: {analysis['description']}")
            print(f"  è®¡ç®—èƒ½åŠ›: {analysis['computational_power']}")
            print(f"  å¯è¯†åˆ«é—®é¢˜: {', '.join(analysis['recognizable_problems'])}")
            print(f"  ç¤ºä¾‹: {', '.join(analysis['examples'])}")

if __name__ == "__main__":
    demonstrate_computational_hierarchy()
```

## ğŸ“Š ç†è®ºè¯æ˜

### å®šç† 2.1 (å›¾çµå®Œå¤‡æ€§çš„ä¼ é€’æ€§)

å¦‚æœç³»ç»Ÿ $S_1$ å¯ä»¥æ¨¡æ‹Ÿç³»ç»Ÿ $S_2$ï¼Œä¸” $S_2$ æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œåˆ™ $S_1$ ä¹Ÿæ˜¯å›¾çµå®Œå¤‡çš„ã€‚

**è¯æ˜**:

1. è®¾ $S_2$ æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œå³ $\forall TM \exists P_{S_2}: TM(x) = S_2(P_{S_2}, x)$
2. è®¾ $S_1$ å¯ä»¥æ¨¡æ‹Ÿ $S_2$ï¼Œå³ $\forall P_{S_2} \exists P_{S_1}: S_2(P_{S_2}, x) = S_1(P_{S_1}, x)$
3. å› æ­¤ $\forall TM \exists P_{S_1}: TM(x) = S_1(P_{S_1}, x)$
4. æ‰€ä»¥ $S_1$ æ˜¯å›¾çµå®Œå¤‡çš„

### å®šç† 2.2 (Pythonçš„å›¾çµå®Œå¤‡æ€§)

Pythonç¼–ç¨‹è¯­è¨€æ˜¯å›¾çµå®Œå¤‡çš„ã€‚

**è¯æ˜**:

1. Pythonå¯ä»¥å®ç°å›¾çµæœºæ¨¡æ‹Ÿå™¨
2. Pythonæ”¯æŒæ— é™é€’å½’ï¼ˆç†è®ºä¸Šï¼‰
3. Pythonå…·æœ‰å®Œæ•´çš„æ§åˆ¶ç»“æ„
4. Pythonå¯ä»¥æ¨¡æ‹Ÿä»»ä½•è®¡ç®—è¿‡ç¨‹
5. å› æ­¤Pythonæ˜¯å›¾çµå®Œå¤‡çš„

## ğŸ¯ åº”ç”¨å®ä¾‹

### 1. ç¼–ç¨‹è¯­è¨€è®¾è®¡

- ç¡®ä¿è¯­è¨€çš„å›¾çµå®Œå¤‡æ€§
- è®¾è®¡è®¡ç®—èƒ½åŠ›å±‚æ¬¡
- ä¼˜åŒ–è¡¨è¾¾èƒ½åŠ›

### 2. ç¼–è¯‘å™¨å¼€å‘

- å®ç°å›¾çµæœºæ¨¡æ‹Ÿ
- æ„å»ºè§£é‡Šå™¨
- ä¼˜åŒ–æ‰§è¡Œæ•ˆç‡

### 3. ç†è®ºè®¡ç®—æœºç§‘å­¦

- è®¡ç®—å¤æ‚æ€§åˆ†æ
- å¯è®¡ç®—æ€§ç ”ç©¶
- å½¢å¼è¯­è¨€ç†è®º

## ğŸ”— ç›¸å…³é“¾æ¥

- [ç¼–ç¨‹è¯­è¨€å“²å­¦](00-01-01-ç¼–ç¨‹è¯­è¨€å“²å­¦.md)
- [æŠ½è±¡å±‚æ¬¡ç†è®º](00-01-03-æŠ½è±¡å±‚æ¬¡ç†è®º.md)
- [ç±»å‹ç³»ç»Ÿå“²å­¦](00-01-04-ç±»å‹ç³»ç»Ÿå“²å­¦.md)
- [ç®—æ³•ç†è®º](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/README.md)

---

*å›¾çµå®Œå¤‡æ€§æ˜¯è®¡ç®—ç†è®ºçš„åŸºç¡€æ¦‚å¿µï¼Œé€šè¿‡å½¢å¼åŒ–çš„å®šä¹‰å’Œä¸¥æ ¼çš„è¯æ˜ï¼Œæˆ‘ä»¬ç†è§£äº†è®¡ç®—èƒ½åŠ›çš„æœ¬è´¨å’Œå±‚æ¬¡ã€‚Pythonä½œä¸ºå›¾çµå®Œå¤‡çš„è¯­è¨€ï¼Œå…·å¤‡äº†é€šç”¨è®¡ç®—çš„èƒ½åŠ›ï¼Œä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€ã€‚*
