# 03. 编程范式

## 概述

编程范式是编程思维的形式化框架，定义了不同的编程方法论和抽象模型。本文档从数学角度形式化各种编程范式，建立严格的理论基础，并提供Python实现示例。

## 1. 编程范式的数学基础

### 1.1 范式的形式化定义

**定义 1.1.1 (编程范式)** 编程范式是一个四元组：

$$\text{ProgrammingParadigm} = (C, M, P, R)$$

其中：

- $C$ 是计算模型 (Computation Model)
- $M$ 是内存模型 (Memory Model)
- $P$ 是程序结构 (Program Structure)
- $R$ 是执行规则 (Execution Rules)

**定义 1.1.2 (范式等价性)** 两个范式 $P_1$ 和 $P_2$ 等价当且仅当：

$$P_1 \equiv P_2 \Leftrightarrow \forall \text{程序} p: \text{Execute}(p, P_1) = \text{Execute}(p, P_2)$$

```python
from typing import TypeVar, Generic, Dict, List, Set, Callable, Any
from dataclasses import dataclass
from abc import ABC, abstractmethod
from enum import Enum

T = TypeVar('T')

class ComputationModel(Enum):
    IMPERATIVE = "imperative"
    FUNCTIONAL = "functional"
    LOGIC = "logic"
    CONCURRENT = "concurrent"

class MemoryModel(Enum):
    MUTABLE = "mutable"
    IMMUTABLE = "immutable"
    LINEAR = "linear"
    SHARED = "shared"

@dataclass
class ProgramStructure:
    """程序结构"""
    components: List[str]
    relationships: Dict[str, List[str]]
    hierarchy: Dict[str, str]
    
    def add_component(self, component: str, parent: str = None):
        """添加组件"""
        self.components.append(component)
        if parent:
            self.hierarchy[component] = parent

@dataclass
class ExecutionRule:
    """执行规则"""
    name: str
    condition: Callable[[Any], bool]
    action: Callable[[Any], Any]
    
    def apply(self, context: Any) -> Any:
        """应用规则"""
        if self.condition(context):
            return self.action(context)
        return context

class ProgrammingParadigm(ABC):
    """编程范式抽象基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.computation_model = self._get_computation_model()
        self.memory_model = self._get_memory_model()
        self.program_structure = ProgramStructure([], {}, {})
        self.execution_rules = []
        self._initialize_rules()
    
    @abstractmethod
    def _get_computation_model(self) -> ComputationModel:
        """获取计算模型"""
        pass
    
    @abstractmethod
    def _get_memory_model(self) -> MemoryModel:
        """获取内存模型"""
        pass
    
    @abstractmethod
    def _initialize_rules(self):
        """初始化执行规则"""
        pass
    
    def add_execution_rule(self, rule: ExecutionRule):
        """添加执行规则"""
        self.execution_rules.append(rule)
    
    def execute_program(self, program: str) -> Any:
        """执行程序"""
        context = {"program": program, "state": {}}
        
        for rule in self.execution_rules:
            context = rule.apply(context)
        
        return context["result"] if "result" in context else context
    
    def get_paradigm_info(self) -> Dict[str, Any]:
        """获取范式信息"""
        return {
            "name": self.name,
            "computation_model": self.computation_model.value,
            "memory_model": self.memory_model.value,
            "components": self.program_structure.components,
            "rules_count": len(self.execution_rules)
        }
```

### 1.2 范式空间的定义

**定义 1.2.1 (范式空间)** 范式空间是所有可能范式的集合：

$$\mathcal{P} = \{P_i | i \in \mathbb{N}, P_i \text{ 是一个编程范式}\}$$

**定义 1.2.2 (范式距离)** 两个范式 $P_1$ 和 $P_2$ 的距离定义为：

$$d(P_1, P_2) = \sum_{i=1}^{n} w_i \cdot |f_i(P_1) - f_i(P_2)|$$

其中 $f_i$ 是特征函数，$w_i$ 是权重。

```python
class ParadigmSpace:
    """范式空间"""
    
    def __init__(self):
        self.paradigms: List[ProgrammingParadigm] = []
        self.feature_weights = {
            "computation_model": 0.3,
            "memory_model": 0.3,
            "complexity": 0.2,
            "expressiveness": 0.2
        }
    
    def add_paradigm(self, paradigm: ProgrammingParadigm):
        """添加范式到空间"""
        self.paradigms.append(paradigm)
    
    def calculate_distance(self, paradigm1: ProgrammingParadigm, paradigm2: ProgrammingParadigm) -> float:
        """计算两个范式的距离"""
        distance = 0.0
        
        # 计算模型距离
        if paradigm1.computation_model != paradigm2.computation_model:
            distance += self.feature_weights["computation_model"]
        
        # 内存模型距离
        if paradigm1.memory_model != paradigm2.memory_model:
            distance += self.feature_weights["memory_model"]
        
        # 复杂度距离
        complexity_diff = abs(len(paradigm1.execution_rules) - len(paradigm2.execution_rules))
        distance += self.feature_weights["complexity"] * (complexity_diff / max(len(paradigm1.execution_rules), len(paradigm2.execution_rules), 1))
        
        # 表达能力距离
        expressiveness_diff = abs(len(paradigm1.program_structure.components) - len(paradigm2.program_structure.components))
        distance += self.feature_weights["expressiveness"] * (expressiveness_diff / max(len(paradigm1.program_structure.components), len(paradigm2.program_structure.components), 1))
        
        return distance
    
    def find_similar_paradigms(self, target_paradigm: ProgrammingParadigm, threshold: float = 0.5) -> List[ProgrammingParadigm]:
        """查找相似范式"""
        similar = []
        
        for paradigm in self.paradigms:
            if paradigm != target_paradigm:
                distance = self.calculate_distance(target_paradigm, paradigm)
                if distance <= threshold:
                    similar.append((paradigm, distance))
        
        return sorted(similar, key=lambda x: x[1])
```

## 2. 命令式编程范式

### 2.1 命令式范式的形式化

**定义 2.1.1 (命令式范式)** 命令式范式基于状态转换：

$$\text{ImperativeParadigm} = (S, \rightarrow, I, F)$$

其中：

- $S$ 是状态空间
- $\rightarrow$ 是状态转换关系
- $I$ 是初始状态
- $F$ 是最终状态集合

```python
class ImperativeParadigm(ProgrammingParadigm):
    """命令式编程范式"""
    
    def __init__(self):
        super().__init__("Imperative")
        self.state_space = {}
        self.initial_state = {}
        self.final_states = set()
    
    def _get_computation_model(self) -> ComputationModel:
        return ComputationModel.IMPERATIVE
    
    def _get_memory_model(self) -> MemoryModel:
        return MemoryModel.MUTABLE
    
    def _initialize_rules(self):
        """初始化命令式执行规则"""
        
        # 赋值规则
        assignment_rule = ExecutionRule(
            name="Assignment",
            condition=lambda ctx: "=" in ctx.get("program", ""),
            action=lambda ctx: self._apply_assignment(ctx)
        )
        self.add_execution_rule(assignment_rule)
        
        # 顺序执行规则
        sequence_rule = ExecutionRule(
            name="Sequence",
            condition=lambda ctx: ";" in ctx.get("program", ""),
            action=lambda ctx: self._apply_sequence(ctx)
        )
        self.add_execution_rule(sequence_rule)
        
        # 条件执行规则
        conditional_rule = ExecutionRule(
            name="Conditional",
            condition=lambda ctx: "if" in ctx.get("program", ""),
            action=lambda ctx: self._apply_conditional(ctx)
        )
        self.add_execution_rule(conditional_rule)
        
        # 循环规则
        loop_rule = ExecutionRule(
            name="Loop",
            condition=lambda ctx: "while" in ctx.get("program", ""),
            action=lambda ctx: self._apply_loop(ctx)
        )
        self.add_execution_rule(loop_rule)
    
    def _apply_assignment(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用赋值规则"""
        program = context["program"]
        state = context["state"]
        
        # 简化的赋值处理
        if "=" in program:
            var, value = program.split("=", 1)
            var = var.strip()
            value = value.strip()
            
            # 尝试解析值
            try:
                if value.isdigit():
                    state[var] = int(value)
                elif value.startswith('"') and value.endswith('"'):
                    state[var] = value[1:-1]
                else:
                    state[var] = value
            except:
                state[var] = value
        
        context["state"] = state
        return context
    
    def _apply_sequence(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用顺序执行规则"""
        program = context["program"]
        
        if ";" in program:
            statements = [stmt.strip() for stmt in program.split(";")]
            for statement in statements:
                if statement:
                    sub_context = {"program": statement, "state": context["state"]}
                    for rule in self.execution_rules:
                        sub_context = rule.apply(sub_context)
                    context["state"] = sub_context["state"]
        
        return context
    
    def _apply_conditional(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用条件执行规则"""
        program = context["program"]
        state = context["state"]
        
        if "if" in program:
            # 简化的条件处理
            condition = True  # 假设条件为真
            if condition:
                # 执行then分支
                pass
        
        return context
    
    def _apply_loop(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用循环规则"""
        program = context["program"]
        
        if "while" in program:
            # 简化的循环处理
            max_iterations = 1000  # 防止无限循环
            iteration = 0
            
            while iteration < max_iterations:
                # 检查循环条件
                condition = True  # 假设条件为真
                if not condition:
                    break
                
                # 执行循环体
                iteration += 1
        
        return context

class ImperativeProgramAnalyzer:
    """命令式程序分析器"""
    
    def __init__(self):
        self.paradigm = ImperativeParadigm()
    
    def analyze_program(self, program: str) -> Dict[str, Any]:
        """分析命令式程序"""
        result = self.paradigm.execute_program(program)
        
        return {
            "final_state": result.get("state", {}),
            "execution_trace": self._generate_execution_trace(program),
            "complexity_analysis": self._analyze_complexity(program),
            "state_changes": self._track_state_changes(program)
        }
    
    def _generate_execution_trace(self, program: str) -> List[str]:
        """生成执行轨迹"""
        trace = []
        statements = program.split(";")
        
        for i, statement in enumerate(statements):
            if statement.strip():
                trace.append(f"Step {i+1}: {statement.strip()}")
        
        return trace
    
    def _analyze_complexity(self, program: str) -> Dict[str, str]:
        """分析复杂度"""
        time_complexity = "O(1)"
        space_complexity = "O(1)"
        
        if "while" in program:
            time_complexity = "O(n)"
        if "for" in program:
            time_complexity = "O(n)"
        
        return {
            "time": time_complexity,
            "space": space_complexity
        }
    
    def _track_state_changes(self, program: str) -> List[Dict[str, Any]]:
        """跟踪状态变化"""
        changes = []
        state = {}
        
        statements = program.split(";")
        for statement in statements:
            if "=" in statement:
                var, value = statement.split("=", 1)
                var = var.strip()
                old_value = state.get(var, None)
                state[var] = value.strip()
                
                changes.append({
                    "variable": var,
                    "old_value": old_value,
                    "new_value": state[var],
                    "statement": statement.strip()
                })
        
        return changes
```

### 2.2 命令式范式的Python实现

```python
class ImperativeCalculator:
    """命令式计算器"""
    
    def __init__(self):
        self.variables = {}
        self.instructions = []
    
    def assign(self, variable: str, value: Any):
        """赋值操作"""
        self.variables[variable] = value
        self.instructions.append(f"{variable} = {value}")
    
    def add(self, var1: str, var2: str, result: str):
        """加法操作"""
        if var1 in self.variables and var2 in self.variables:
            self.variables[result] = self.variables[var1] + self.variables[var2]
            self.instructions.append(f"{result} = {var1} + {var2}")
    
    def multiply(self, var1: str, var2: str, result: str):
        """乘法操作"""
        if var1 in self.variables and var2 in self.variables:
            self.variables[result] = self.variables[var1] * self.variables[var2]
            self.instructions.append(f"{result} = {var1} * {var2}")
    
    def conditional(self, condition: Callable[[], bool], true_action: Callable, false_action: Callable = None):
        """条件执行"""
        if condition():
            true_action()
            self.instructions.append("if condition: execute true_action")
        elif false_action:
            false_action()
            self.instructions.append("else: execute false_action")
    
    def loop(self, condition: Callable[[], bool], body: Callable):
        """循环执行"""
        while condition():
            body()
            self.instructions.append("loop iteration")
    
    def get_state(self) -> Dict[str, Any]:
        """获取当前状态"""
        return self.variables.copy()
    
    def get_execution_trace(self) -> List[str]:
        """获取执行轨迹"""
        return self.instructions.copy()

# 使用示例
if __name__ == "__main__":
    # 创建命令式计算器
    calc = ImperativeCalculator()
    
    # 执行命令式程序
    calc.assign("x", 5)
    calc.assign("y", 3)
    calc.add("x", "y", "sum")
    calc.multiply("x", "y", "product")
    
    # 条件执行
    calc.conditional(
        lambda: calc.variables["sum"] > 5,
        lambda: calc.assign("result", "large"),
        lambda: calc.assign("result", "small")
    )
    
    # 循环执行
    counter = 0
    calc.loop(
        lambda: counter < 3,
        lambda: calc.assign(f"item_{counter}", counter)
    )
    
    print("最终状态:", calc.get_state())
    print("执行轨迹:", calc.get_execution_trace())
```

## 3. 函数式编程范式

### 3.1 函数式范式的形式化

**定义 3.1.1 (函数式范式)** 函数式范式基于数学函数：

$$\text{FunctionalParadigm} = (F, \circ, I, E)$$

其中：

- $F$ 是函数集合
- $\circ$ 是函数组合操作
- $I$ 是恒等函数
- $E$ 是求值函数

```python
from typing import Callable, TypeVar, Generic

A = TypeVar('A')
B = TypeVar('B')
C = TypeVar('C')

class FunctionalParadigm(ProgrammingParadigm):
    """函数式编程范式"""
    
    def __init__(self):
        super().__init__("Functional")
        self.functions = {}
        self.compositions = []
    
    def _get_computation_model(self) -> ComputationModel:
        return ComputationModel.FUNCTIONAL
    
    def _get_memory_model(self) -> MemoryModel:
        return MemoryModel.IMMUTABLE
    
    def _initialize_rules(self):
        """初始化函数式执行规则"""
        
        # 函数应用规则
        application_rule = ExecutionRule(
            name="FunctionApplication",
            condition=lambda ctx: "(" in ctx.get("program", ""),
            action=lambda ctx: self._apply_function(ctx)
        )
        self.add_execution_rule(application_rule)
        
        # 函数组合规则
        composition_rule = ExecutionRule(
            name="FunctionComposition",
            condition=lambda ctx: "∘" in ctx.get("program", ""),
            action=lambda ctx: self._apply_composition(ctx)
        )
        self.add_execution_rule(composition_rule)
        
        # 高阶函数规则
        higher_order_rule = ExecutionRule(
            name="HigherOrderFunction",
            condition=lambda ctx: "map" in ctx.get("program", "") or "filter" in ctx.get("program", ""),
            action=lambda ctx: self._apply_higher_order(ctx)
        )
        self.add_execution_rule(higher_order_rule)
    
    def _apply_function(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用函数"""
        program = context["program"]
        
        if "(" in program:
            # 简化的函数应用
            func_name = program.split("(")[0].strip()
            args = program.split("(")[1].split(")")[0].strip()
            
            if func_name in self.functions:
                result = self.functions[func_name](args)
                context["result"] = result
        
        return context
    
    def _apply_composition(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用函数组合"""
        program = context["program"]
        
        if "∘" in program:
            functions = program.split("∘")
            # 简化的组合处理
            context["result"] = "composed_function"
        
        return context
    
    def _apply_higher_order(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用高阶函数"""
        program = context["program"]
        
        if "map" in program:
            context["result"] = "mapped_result"
        elif "filter" in program:
            context["result"] = "filtered_result"
        
        return context

class FunctionalProgram:
    """函数式程序"""
    
    def __init__(self):
        self.functions = {}
        self.data = []
    
    def define_function(self, name: str, func: Callable):
        """定义函数"""
        self.functions[name] = func
    
    def compose(self, f: Callable[[B], C], g: Callable[[A], B]]) -> Callable[[A], C]:
        """函数组合"""
        return lambda x: f(g(x))
    
    def map_function(self, func: Callable, data: List[Any]) -> List[Any]:
        """映射函数"""
        return [func(item) for item in data]
    
    def filter_function(self, predicate: Callable, data: List[Any]) -> List[Any]:
        """过滤函数"""
        return [item for item in data if predicate(item)]
    
    def reduce_function(self, func: Callable, data: List[Any], initial: Any = None) -> Any:
        """归约函数"""
        if not data:
            return initial
        
        if initial is None:
            result = data[0]
            data = data[1:]
        else:
            result = initial
        
        for item in data:
            result = func(result, item)
        
        return result
    
    def curry(self, func: Callable, *args) -> Callable:
        """柯里化函数"""
        if len(args) >= func.__code__.co_argcount:
            return func(*args)
        else:
            return lambda *more_args: self.curry(func, *(args + more_args))

class FunctionalCalculator:
    """函数式计算器"""
    
    def __init__(self):
        self.program = FunctionalProgram()
        self._setup_basic_functions()
    
    def _setup_basic_functions(self):
        """设置基本函数"""
        self.program.define_function("add", lambda x, y: x + y)
        self.program.define_function("multiply", lambda x, y: x * y)
        self.program.define_function("square", lambda x: x * x)
        self.program.define_function("is_even", lambda x: x % 2 == 0)
    
    def calculate_sum_of_squares(self, numbers: List[int]) -> int:
        """计算平方和"""
        # 使用函数组合：map(square) -> reduce(add)
        squared = self.program.map_function(self.program.functions["square"], numbers)
        return self.program.reduce_function(self.program.functions["add"], squared, 0)
    
    def filter_even_squares(self, numbers: List[int]) -> List[int]:
        """过滤偶数平方"""
        # 使用函数组合：filter(is_even) -> map(square)
        even_numbers = self.program.filter_function(self.program.functions["is_even"], numbers)
        return self.program.map_function(self.program.functions["square"], even_numbers)
    
    def create_pipeline(self, *functions) -> Callable:
        """创建函数管道"""
        if len(functions) == 1:
            return functions[0]
        else:
            return self.program.compose(functions[-1], self.create_pipeline(*functions[:-1]))

# 使用示例
if __name__ == "__main__":
    # 创建函数式计算器
    calc = FunctionalCalculator()
    
    # 测试函数式操作
    numbers = [1, 2, 3, 4, 5, 6]
    
    # 计算平方和
    sum_of_squares = calc.calculate_sum_of_squares(numbers)
    print(f"平方和: {sum_of_squares}")
    
    # 过滤偶数平方
    even_squares = calc.filter_even_squares(numbers)
    print(f"偶数平方: {even_squares}")
    
    # 创建函数管道
    pipeline = calc.create_pipeline(
        lambda x: x * 2,
        lambda x: x + 1,
        lambda x: x ** 2
    )
    
    result = pipeline(5)
    print(f"管道结果: {result}")
```

## 4. 面向对象编程范式

### 4.1 面向对象范式的形式化

**定义 4.1.1 (面向对象范式)** 面向对象范式基于对象和消息传递：

$$\text{ObjectOrientedParadigm} = (O, M, I, H)$$

其中：

- $O$ 是对象集合
- $M$ 是消息集合
- $I$ 是继承关系
- $H$ 是层次结构

```python
class ObjectOrientedParadigm(ProgrammingParadigm):
    """面向对象编程范式"""
    
    def __init__(self):
        super().__init__("ObjectOriented")
        self.objects = {}
        self.classes = {}
        self.inheritance = {}
    
    def _get_computation_model(self) -> ComputationModel:
        return ComputationModel.IMPERATIVE  # OOP通常基于命令式
    
    def _get_memory_model(self) -> MemoryModel:
        return MemoryModel.MUTABLE
    
    def _initialize_rules(self):
        """初始化面向对象执行规则"""
        
        # 对象创建规则
        instantiation_rule = ExecutionRule(
            name="ObjectInstantiation",
            condition=lambda ctx: "new" in ctx.get("program", ""),
            action=lambda ctx: self._apply_instantiation(ctx)
        )
        self.add_execution_rule(instantiation_rule)
        
        # 消息传递规则
        message_rule = ExecutionRule(
            name="MessagePassing",
            condition=lambda ctx: "." in ctx.get("program", ""),
            action=lambda ctx: self._apply_message_passing(ctx)
        )
        self.add_execution_rule(message_rule)
        
        # 继承规则
        inheritance_rule = ExecutionRule(
            name="Inheritance",
            condition=lambda ctx: "extends" in ctx.get("program", ""),
            action=lambda ctx: self._apply_inheritance(ctx)
        )
        self.add_execution_rule(inheritance_rule)
    
    def _apply_instantiation(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用对象实例化"""
        program = context["program"]
        
        if "new" in program:
            # 简化的实例化处理
            class_name = program.split("new")[1].split("(")[0].strip()
            context["result"] = f"new_instance_of_{class_name}"
        
        return context
    
    def _apply_message_passing(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用消息传递"""
        program = context["program"]
        
        if "." in program:
            # 简化的消息传递处理
            object_name, message = program.split(".", 1)
            context["result"] = f"message_{message}_sent_to_{object_name}"
        
        return context
    
    def _apply_inheritance(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """应用继承"""
        program = context["program"]
        
        if "extends" in program:
            # 简化的继承处理
            child_class, parent_class = program.split("extends")
            context["result"] = f"{child_class.strip()}_inherits_from_{parent_class.strip()}"
        
        return context

class Class:
    """类定义"""
    
    def __init__(self, name: str, parent: str = None):
        self.name = name
        self.parent = parent
        self.attributes = {}
        self.methods = {}
        self.instances = []
    
    def add_attribute(self, name: str, value: Any):
        """添加属性"""
        self.attributes[name] = value
    
    def add_method(self, name: str, method: Callable):
        """添加方法"""
        self.methods[name] = method
    
    def create_instance(self, instance_id: str) -> 'Object':
        """创建实例"""
        instance = Object(instance_id, self)
        self.instances.append(instance)
        return instance

class Object:
    """对象实例"""
    
    def __init__(self, instance_id: str, class_def: Class):
        self.instance_id = instance_id
        self.class_def = class_def
        self.attributes = class_def.attributes.copy()
        self.methods = class_def.methods.copy()
    
    def get_attribute(self, name: str) -> Any:
        """获取属性"""
        return self.attributes.get(name)
    
    def set_attribute(self, name: str, value: Any):
        """设置属性"""
        self.attributes[name] = value
    
    def call_method(self, name: str, *args, **kwargs) -> Any:
        """调用方法"""
        if name in self.methods:
            return self.methods[name](self, *args, **kwargs)
        else:
            raise AttributeError(f"Method '{name}' not found")
    
    def __str__(self) -> str:
        return f"{self.class_def.name}({self.instance_id})"

class ObjectOrientedSystem:
    """面向对象系统"""
    
    def __init__(self):
        self.classes = {}
        self.objects = {}
        self.inheritance = {}
    
    def define_class(self, name: str, parent: str = None) -> Class:
        """定义类"""
        class_def = Class(name, parent)
        self.classes[name] = class_def
        
        if parent:
            self.inheritance[name] = parent
        
        return class_def
    
    def create_object(self, class_name: str, instance_id: str) -> Object:
        """创建对象"""
        if class_name not in self.classes:
            raise ValueError(f"Class '{class_name}' not found")
        
        class_def = self.classes[class_name]
        instance = class_def.create_instance(instance_id)
        self.objects[instance_id] = instance
        
        return instance
    
    def send_message(self, object_id: str, method_name: str, *args, **kwargs) -> Any:
        """发送消息"""
        if object_id not in self.objects:
            raise ValueError(f"Object '{object_id}' not found")
        
        obj = self.objects[object_id]
        return obj.call_method(method_name, *args, **kwargs)
    
    def get_inheritance_chain(self, class_name: str) -> List[str]:
        """获取继承链"""
        chain = [class_name]
        current = class_name
        
        while current in self.inheritance:
            parent = self.inheritance[current]
            chain.append(parent)
            current = parent
        
        return chain

# 使用示例
if __name__ == "__main__":
    # 创建面向对象系统
    oo_system = ObjectOrientedSystem()
    
    # 定义类
    animal_class = oo_system.define_class("Animal")
    animal_class.add_attribute("name", "")
    animal_class.add_attribute("age", 0)
    
    def speak(self, message):
        return f"{self.get_attribute('name')} says: {message}"
    
    animal_class.add_method("speak", speak)
    
    # 定义子类
    dog_class = oo_system.define_class("Dog", "Animal")
    dog_class.add_attribute("breed", "")
    
    def bark(self):
        return self.call_method("speak", "Woof!")
    
    dog_class.add_method("bark", bark)
    
    # 创建对象
    dog = oo_system.create_object("Dog", "buddy")
    dog.set_attribute("name", "Buddy")
    dog.set_attribute("age", 3)
    dog.set_attribute("breed", "Golden Retriever")
    
    # 发送消息
    result = oo_system.send_message("buddy", "bark")
    print(result)
    
    # 查看继承链
    inheritance_chain = oo_system.get_inheritance_chain("Dog")
    print(f"继承链: {' -> '.join(inheritance_chain)}")
```

## 5. 范式比较与分析

### 5.1 范式等价性证明

**定理 5.1.1 (图灵等价性)** 所有主要编程范式都是图灵等价的：

$$\forall P_1, P_2 \in \{\text{Imperative}, \text{Functional}, \text{ObjectOriented}\}: P_1 \equiv_T P_2$$

**证明**：

1. 命令式范式可以直接模拟图灵机
2. 函数式范式可以通过λ演算实现图灵完备性
3. 面向对象范式可以模拟命令式范式
4. 因此所有范式都是图灵等价的

```python
class ParadigmComparison:
    """范式比较器"""
    
    def __init__(self):
        self.paradigms = {
            "imperative": ImperativeParadigm(),
            "functional": FunctionalParadigm(),
            "object_oriented": ObjectOrientedParadigm()
        }
    
    def compare_paradigms(self, criteria: List[str]) -> Dict[str, Dict[str, Any]]:
        """比较范式"""
        comparison = {}
        
        for paradigm_name, paradigm in self.paradigms.items():
            comparison[paradigm_name] = {}
            
            for criterion in criteria:
                comparison[paradigm_name][criterion] = self._evaluate_criterion(paradigm, criterion)
        
        return comparison
    
    def _evaluate_criterion(self, paradigm: ProgrammingParadigm, criterion: str) -> Any:
        """评估特定标准"""
        if criterion == "expressiveness":
            return self._evaluate_expressiveness(paradigm)
        elif criterion == "performance":
            return self._evaluate_performance(paradigm)
        elif criterion == "maintainability":
            return self._evaluate_maintainability(paradigm)
        elif criterion == "learnability":
            return self._evaluate_learnability(paradigm)
        else:
            return "Unknown criterion"
    
    def _evaluate_expressiveness(self, paradigm: ProgrammingParadigm) -> str:
        """评估表达能力"""
        if paradigm.computation_model == ComputationModel.FUNCTIONAL:
            return "High"
        elif paradigm.computation_model == ComputationModel.IMPERATIVE:
            return "Medium"
        else:
            return "Medium"
    
    def _evaluate_performance(self, paradigm: ProgrammingParadigm) -> str:
        """评估性能"""
        if paradigm.memory_model == MemoryModel.MUTABLE:
            return "High"
        else:
            return "Medium"
    
    def _evaluate_maintainability(self, paradigm: ProgrammingParadigm) -> str:
        """评估可维护性"""
        if paradigm.name == "ObjectOriented":
            return "High"
        elif paradigm.name == "Functional":
            return "High"
        else:
            return "Medium"
    
    def _evaluate_learnability(self, paradigm: ProgrammingParadigm) -> str:
        """评估可学习性"""
        if paradigm.name == "Imperative":
            return "High"
        elif paradigm.name == "ObjectOriented":
            return "Medium"
        else:
            return "Low"

# 使用示例
if __name__ == "__main__":
    # 创建范式比较器
    comparator = ParadigmComparison()
    
    # 比较范式
    criteria = ["expressiveness", "performance", "maintainability", "learnability"]
    comparison = comparator.compare_paradigms(criteria)
    
    print("范式比较结果:")
    for paradigm_name, results in comparison.items():
        print(f"\n{paradigm_name.upper()}:")
        for criterion, result in results.items():
            print(f"  {criterion}: {result}")
```

---

**相关文档**：

- [01-编程哲学](./01-编程哲学.md)
- [02-设计理念](./02-设计理念.md)
- [01-数学基础](../01-形式科学/01-数学基础.md)
