# 00.03 计算思维

## 📋 概述

计算思维是解决复杂问题的系统性方法，通过抽象、分解、模式识别和算法设计来理解和解决问题。本文档从形式化角度定义计算思维的核心概念，并提供Python实现。

## 🎯 核心概念

### 1. 计算思维的定义

**形式化定义**：
计算思维是一个映射 $CT: P \rightarrow S$，其中：

- $P$ 是问题空间
- $S$ 是解决方案空间
- $CT$ 满足：$CT(p) = \text{Decompose}(p) \circ \text{Abstract}(p) \circ \text{Pattern}(p) \circ \text{Algorithm}(p)$

**Python实现**：

```python
from typing import TypeVar, List, Any, Callable, Dict
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

P = TypeVar('P')  # 问题类型
S = TypeVar('S')  # 解决方案类型

class ThinkingStep(Enum):
    DECOMPOSE = "decompose"
    ABSTRACT = "abstract"
    PATTERN = "pattern"
    ALGORITHM = "algorithm"

@dataclass
class Problem:
    """问题定义"""
    description: str
    complexity: int
    constraints: List[str]
    data: Any

@dataclass
class Solution:
    """解决方案定义"""
    description: str
    steps: List[str]
    algorithm: Callable
    complexity: str

class ComputationalThinking:
    """计算思维框架"""
    
    def __init__(self):
        self.decomposition_strategies: Dict[str, Callable] = {}
        self.abstraction_methods: Dict[str, Callable] = {}
        self.pattern_recognition: Dict[str, Callable] = {}
        self.algorithm_design: Dict[str, Callable] = {}
    
    def add_decomposition_strategy(self, name: str, strategy: Callable):
        """添加分解策略"""
        self.decomposition_strategies[name] = strategy
    
    def add_abstraction_method(self, name: str, method: Callable):
        """添加抽象方法"""
        self.abstraction_methods[name] = method
    
    def add_pattern_recognition(self, name: str, recognizer: Callable):
        """添加模式识别"""
        self.pattern_recognition[name] = recognizer
    
    def add_algorithm_design(self, name: str, designer: Callable):
        """添加算法设计"""
        self.algorithm_design[name] = designer
    
    def solve_problem(self, problem: Problem) -> Solution:
        """使用计算思维解决问题"""
        # 1. 分解
        subproblems = self.decompose(problem)
        
        # 2. 抽象
        abstractions = self.abstract(problem, subproblems)
        
        # 3. 模式识别
        patterns = self.recognize_patterns(problem, abstractions)
        
        # 4. 算法设计
        algorithm = self.design_algorithm(problem, patterns)
        
        return Solution(
            description=f"Solution for {problem.description}",
            steps=[f"Decomposed into {len(subproblems)} subproblems",
                   f"Created {len(abstractions)} abstractions",
                   f"Identified {len(patterns)} patterns",
                   "Designed algorithm"],
            algorithm=algorithm,
            complexity="O(n log n)"  # 示例复杂度
        )
    
    def decompose(self, problem: Problem) -> List[Problem]:
        """分解问题"""
        subproblems = []
        
        for strategy_name, strategy in self.decomposition_strategies.items():
            try:
                result = strategy(problem)
                if isinstance(result, list):
                    subproblems.extend(result)
                else:
                    subproblems.append(result)
            except Exception:
                continue
        
        return subproblems
    
    def abstract(self, original_problem: Problem, subproblems: List[Problem]) -> List[Any]:
        """抽象化"""
        abstractions = []
        
        for method_name, method in self.abstraction_methods.items():
            try:
                abstraction = method(original_problem, subproblems)
                abstractions.append(abstraction)
            except Exception:
                continue
        
        return abstractions
    
    def recognize_patterns(self, problem: Problem, abstractions: List[Any]) -> List[str]:
        """识别模式"""
        patterns = []
        
        for recognizer_name, recognizer in self.pattern_recognition.items():
            try:
                pattern = recognizer(problem, abstractions)
                if pattern:
                    patterns.append(pattern)
            except Exception:
                continue
        
        return patterns
    
    def design_algorithm(self, problem: Problem, patterns: List[str]) -> Callable:
        """设计算法"""
        # 根据识别的模式选择或设计算法
        if "sorting" in patterns:
            return self.algorithm_design.get("sorting", lambda x: sorted(x))
        elif "searching" in patterns:
            return self.algorithm_design.get("searching", lambda x: x)
        else:
            return self.algorithm_design.get("default", lambda x: x)

# 示例：排序问题的计算思维解决
def create_sorting_computational_thinking():
    """创建排序问题的计算思维框架"""
    ct = ComputationalThinking()
    
    # 分解策略：将大数组分解为小数组
    def array_decomposition(problem: Problem) -> List[Problem]:
        if isinstance(problem.data, list) and len(problem.data) > 1:
            mid = len(problem.data) // 2
            left_data = problem.data[:mid]
            right_data = problem.data[mid:]
            
            return [
                Problem(f"Sort left half", problem.complexity // 2, 
                       problem.constraints, left_data),
                Problem(f"Sort right half", problem.complexity // 2, 
                       problem.constraints, right_data)
            ]
        return [problem]
    
    # 抽象方法：将排序抽象为比较操作
    def sorting_abstraction(original_problem: Problem, subproblems: List[Problem]) -> str:
        return "comparison_based_sorting"
    
    # 模式识别：识别分治模式
    def divide_conquer_pattern(problem: Problem, abstractions: List[Any]) -> str:
        if len(abstractions) > 1:
            return "divide_and_conquer"
        return "simple_sorting"
    
    # 算法设计：归并排序
    def merge_sort_algorithm(data: List) -> List:
        if len(data) <= 1:
            return data
        
        mid = len(data) // 2
        left = merge_sort_algorithm(data[:mid])
        right = merge_sort_algorithm(data[mid:])
        
        return merge(left, right)
    
    def merge(left: List, right: List) -> List:
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    # 添加策略和方法
    ct.add_decomposition_strategy("array_split", array_decomposition)
    ct.add_abstraction_method("sorting_abstraction", sorting_abstraction)
    ct.add_pattern_recognition("divide_conquer", divide_conquer_pattern)
    ct.add_algorithm_design("sorting", merge_sort_algorithm)
    
    return ct

# 使用示例
sorting_ct = create_sorting_computational_thinking()
sorting_problem = Problem(
    description="Sort array [3, 1, 4, 1, 5, 9, 2, 6]",
    complexity=8,
    constraints=["Must be stable", "In-place preferred"],
    data=[3, 1, 4, 1, 5, 9, 2, 6]
)

solution = sorting_ct.solve_problem(sorting_problem)
print(f"Problem: {solution.description}")
print(f"Steps: {solution.steps}")
print(f"Result: {solution.algorithm(sorting_problem.data)}")
```

### 2. 问题分解

#### 2.1 分治策略

**数学定义**：
分治策略将问题 $P$ 分解为子问题：$P = P_1 \cup P_2 \cup \cdots \cup P_n$，其中：

- $P_i \cap P_j = \emptyset$ （子问题互不重叠）
- $\sum_{i=1}^n |P_i| = |P|$ （子问题大小之和等于原问题）

**Python实现**：

```python
from typing import List, Any, Callable, Tuple
from dataclasses import dataclass

@dataclass
class SubProblem:
    """子问题定义"""
    name: str
    data: Any
    size: int
    parent: str

class DivideAndConquer:
    """分治策略实现"""
    
    def __init__(self):
        self.divide_strategies: Dict[str, Callable] = {}
        self.conquer_strategies: Dict[str, Callable] = {}
        self.combine_strategies: Dict[str, Callable] = {}
    
    def add_divide_strategy(self, name: str, strategy: Callable):
        """添加分解策略"""
        self.divide_strategies[name] = strategy
    
    def add_conquer_strategy(self, name: str, strategy: Callable):
        """添加解决策略"""
        self.conquer_strategies[name] = strategy
    
    def add_combine_strategy(self, name: str, strategy: Callable):
        """添加合并策略"""
        self.combine_strategies[name] = strategy
    
    def solve(self, problem: Any, strategy_name: str) -> Any:
        """使用分治策略解决问题"""
        if strategy_name not in self.divide_strategies:
            raise ValueError(f"Strategy '{strategy_name}' not found")
        
        # 分解
        subproblems = self.divide_strategies[strategy_name](problem)
        
        # 解决子问题
        solutions = []
        for subproblem in subproblems:
            if self.is_base_case(subproblem):
                solution = self.conquer_strategies.get(strategy_name, 
                                                     lambda x: x)(subproblem)
            else:
                solution = self.solve(subproblem, strategy_name)
            solutions.append(solution)
        
        # 合并结果
        if len(solutions) > 1:
            return self.combine_strategies.get(strategy_name, 
                                             lambda x: x[0] if x else None)(solutions)
        else:
            return solutions[0] if solutions else None
    
    def is_base_case(self, problem: Any) -> bool:
        """判断是否为基本情况"""
        if isinstance(problem, list):
            return len(problem) <= 1
        elif isinstance(problem, (int, float)):
            return True
        else:
            return False

# 示例：快速排序的分治实现
def create_quicksort_divide_conquer():
    """创建快速排序的分治实现"""
    dc = DivideAndConquer()
    
    def quicksort_divide(data: List) -> List[List]:
        """快速排序的分解策略"""
        if len(data) <= 1:
            return [data]
        
        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        
        return [left, middle, right]
    
    def quicksort_conquer(data: List) -> List:
        """快速排序的解决策略"""
        return data
    
    def quicksort_combine(solutions: List[List]) -> List:
        """快速排序的合并策略"""
        result = []
        for solution in solutions:
            result.extend(solution)
        return result
    
    dc.add_divide_strategy("quicksort", quicksort_divide)
    dc.add_conquer_strategy("quicksort", quicksort_conquer)
    dc.add_combine_strategy("quicksort", quicksort_combine)
    
    return dc

# 使用示例
quicksort_dc = create_quicksort_divide_conquer()
test_data = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_data = quicksort_dc.solve(test_data, "quicksort")
print(f"Original: {test_data}")
print(f"Sorted: {sorted_data}")
```

#### 2.2 动态规划

**数学定义**：
动态规划基于最优子结构：$OPT(i) = \max_{j \in S_i} \{OPT(j) + f(i,j)\}$，其中：

- $OPT(i)$ 是问题 $i$ 的最优解
- $S_i$ 是问题 $i$ 的子问题集合
- $f(i,j)$ 是从子问题 $j$ 到问题 $i$ 的转移函数

**Python实现**：

```python
from typing import Dict, List, Any, Callable, Optional
from functools import lru_cache

class DynamicProgramming:
    """动态规划框架"""
    
    def __init__(self):
        self.memo: Dict[str, Any] = {}
        self.subproblems: Dict[str, List[str]] = {}
        self.transition_functions: Dict[str, Callable] = {}
    
    def add_subproblem_relation(self, problem: str, subproblems: List[str]):
        """添加子问题关系"""
        self.subproblems[problem] = subproblems
    
    def add_transition_function(self, problem: str, func: Callable):
        """添加转移函数"""
        self.transition_functions[problem] = func
    
    def solve(self, problem: str, data: Any) -> Any:
        """解决动态规划问题"""
        key = f"{problem}_{hash(str(data))}"
        
        if key in self.memo:
            return self.memo[key]
        
        if problem not in self.subproblems:
            # 基本情况
            result = data
        else:
            # 递归情况
            subproblem_results = []
            for subproblem in self.subproblems[problem]:
                sub_result = self.solve(subproblem, data)
                subproblem_results.append(sub_result)
            
            if problem in self.transition_functions:
                result = self.transition_functions[problem](data, subproblem_results)
            else:
                result = subproblem_results[0] if subproblem_results else None
        
        self.memo[key] = result
        return result
    
    def clear_memo(self):
        """清除记忆化缓存"""
        self.memo.clear()

# 示例：斐波那契数列的动态规划
def create_fibonacci_dp():
    """创建斐波那契数列的动态规划"""
    dp = DynamicProgramming()
    
    def fibonacci_transition(n: int, sub_results: List[int]) -> int:
        """斐波那契转移函数"""
        if len(sub_results) >= 2:
            return sub_results[-2] + sub_results[-1]
        elif len(sub_results) == 1:
            return sub_results[0]
        else:
            return n
    
    # 定义子问题关系
    for i in range(2, 10):
        dp.add_subproblem_relation(f"fib_{i}", [f"fib_{i-1}", f"fib_{i-2}"])
    
    dp.add_transition_function("fib_2", fibonacci_transition)
    dp.add_transition_function("fib_3", fibonacci_transition)
    dp.add_transition_function("fib_4", fibonacci_transition)
    dp.add_transition_function("fib_5", fibonacci_transition)
    
    return dp

# 使用示例
fib_dp = create_fibonacci_dp()
fib_5 = fib_dp.solve("fib_5", 5)
print(f"Fibonacci(5) = {fib_5}")

# 使用装饰器的简化版本
@lru_cache(maxsize=None)
def fibonacci(n: int) -> int:
    """使用记忆化的斐波那契函数"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(f"Fibonacci(10) = {fibonacci(10)}")
```

### 3. 模式识别

#### 3.1 算法模式

**数学定义**：
算法模式是一个函数 $M: I \rightarrow P$，其中：

- $I$ 是输入实例集合
- $P$ 是模式集合
- $M$ 将输入映射到相应的算法模式

**Python实现**：

```python
from typing import Dict, List, Any, Callable, TypeVar
from dataclasses import dataclass
from enum import Enum

class AlgorithmPattern(Enum):
    SORTING = "sorting"
    SEARCHING = "searching"
    GRAPH_TRAVERSAL = "graph_traversal"
    DYNAMIC_PROGRAMMING = "dynamic_programming"
    GREEDY = "greedy"
    DIVIDE_AND_CONQUER = "divide_and_conquer"

@dataclass
class PatternMatch:
    """模式匹配结果"""
    pattern: AlgorithmPattern
    confidence: float
    parameters: Dict[str, Any]

class AlgorithmPatternRecognizer:
    """算法模式识别器"""
    
    def __init__(self):
        self.pattern_detectors: Dict[AlgorithmPattern, Callable] = {}
        self.feature_extractors: Dict[str, Callable] = {}
    
    def add_pattern_detector(self, pattern: AlgorithmPattern, detector: Callable):
        """添加模式检测器"""
        self.pattern_detectors[pattern] = detector
    
    def add_feature_extractor(self, name: str, extractor: Callable):
        """添加特征提取器"""
        self.feature_extractors[name] = extractor
    
    def extract_features(self, data: Any) -> Dict[str, Any]:
        """提取特征"""
        features = {}
        
        for name, extractor in self.feature_extractors.items():
            try:
                features[name] = extractor(data)
            except Exception:
                features[name] = None
        
        return features
    
    def recognize_pattern(self, data: Any) -> List[PatternMatch]:
        """识别算法模式"""
        features = self.extract_features(data)
        matches = []
        
        for pattern, detector in self.pattern_detectors.items():
            try:
                confidence, parameters = detector(features)
                if confidence > 0.5:  # 置信度阈值
                    matches.append(PatternMatch(pattern, confidence, parameters))
            except Exception:
                continue
        
        # 按置信度排序
        matches.sort(key=lambda x: x.confidence, reverse=True)
        return matches

# 示例：排序模式识别
def create_sorting_pattern_recognizer():
    """创建排序模式识别器"""
    recognizer = AlgorithmPatternRecognizer()
    
    def extract_array_features(data: Any) -> Dict[str, Any]:
        """提取数组特征"""
        if not isinstance(data, list):
            return {}
        
        return {
            "length": len(data),
            "is_numeric": all(isinstance(x, (int, float)) for x in data),
            "has_duplicates": len(set(data)) != len(data),
            "is_sorted": data == sorted(data),
            "range": max(data) - min(data) if data else 0
        }
    
    def detect_sorting_pattern(features: Dict[str, Any]) -> Tuple[float, Dict[str, Any]]:
        """检测排序模式"""
        if not features:
            return 0.0, {}
        
        confidence = 0.0
        parameters = {}
        
        # 基于特征计算置信度
        if features.get("length", 0) > 1:
            confidence += 0.3
        
        if features.get("is_numeric", False):
            confidence += 0.2
        
        if not features.get("is_sorted", True):
            confidence += 0.5
        
        # 选择排序算法
        if features.get("length", 0) < 50:
            parameters["algorithm"] = "insertion_sort"
        elif features.get("has_duplicates", False):
            parameters["algorithm"] = "merge_sort"
        else:
            parameters["algorithm"] = "quicksort"
        
        return confidence, parameters
    
    recognizer.add_feature_extractor("array_features", extract_array_features)
    recognizer.add_pattern_detector(AlgorithmPattern.SORTING, detect_sorting_pattern)
    
    return recognizer

# 使用示例
sorting_recognizer = create_sorting_pattern_recognizer()

test_cases = [
    [3, 1, 4, 1, 5, 9, 2, 6],  # 未排序数组
    [1, 2, 3, 4, 5],           # 已排序数组
    [5, 4, 3, 2, 1],           # 逆序数组
    [1],                       # 单元素数组
    []                         # 空数组
]

for i, test_case in enumerate(test_cases):
    matches = sorting_recognizer.recognize_pattern(test_case)
    print(f"Test case {i+1}: {test_case}")
    for match in matches:
        print(f"  Pattern: {match.pattern.value}, "
              f"Confidence: {match.confidence:.2f}, "
              f"Algorithm: {match.parameters.get('algorithm', 'unknown')}")
    print()
```

#### 3.2 数据结构模式

**数学定义**：
数据结构模式是一个映射 $DS: T \rightarrow S$，其中：

- $T$ 是数据类型集合
- $S$ 是数据结构集合
- $DS$ 将数据类型映射到合适的数据结构

**Python实现**：

```python
from typing import Dict, List, Any, Type, Callable
from dataclasses import dataclass
from enum import Enum

class DataStructureType(Enum):
    ARRAY = "array"
    LINKED_LIST = "linked_list"
    STACK = "stack"
    QUEUE = "queue"
    HASH_TABLE = "hash_table"
    TREE = "tree"
    GRAPH = "graph"
    HEAP = "heap"

@dataclass
class DataStructureRecommendation:
    """数据结构推荐"""
    structure: DataStructureType
    reason: str
    efficiency: Dict[str, str]
    implementation: str

class DataStructurePatternRecognizer:
    """数据结构模式识别器"""
    
    def __init__(self):
        self.type_patterns: Dict[str, List[DataStructureType]] = {}
        self.operation_patterns: Dict[str, List[DataStructureType]] = {}
        self.efficiency_requirements: Dict[str, Dict[str, str]] = {}
    
    def add_type_pattern(self, data_type: str, structures: List[DataStructureType]):
        """添加类型模式"""
        self.type_patterns[data_type] = structures
    
    def add_operation_pattern(self, operation: str, structures: List[DataStructureType]):
        """添加操作模式"""
        self.operation_patterns[operation] = structures
    
    def add_efficiency_requirement(self, structure: DataStructureType, 
                                 operations: Dict[str, str]):
        """添加效率要求"""
        self.efficiency_requirements[structure.value] = operations
    
    def recommend_structure(self, data_type: str, operations: List[str]) -> List[DataStructureRecommendation]:
        """推荐数据结构"""
        recommendations = []
        
        # 基于类型推荐
        type_candidates = self.type_patterns.get(data_type, [])
        
        # 基于操作推荐
        operation_candidates = []
        for operation in operations:
            operation_candidates.extend(self.operation_patterns.get(operation, []))
        
        # 合并候选
        all_candidates = set(type_candidates + operation_candidates)
        
        for candidate in all_candidates:
            efficiency = self.efficiency_requirements.get(candidate.value, {})
            recommendation = DataStructureRecommendation(
                structure=candidate,
                reason=f"Supports {data_type} data and {', '.join(operations)} operations",
                efficiency=efficiency,
                implementation=f"Python {candidate.value.replace('_', ' ')}"
            )
            recommendations.append(recommendation)
        
        return recommendations

# 示例：数据结构推荐系统
def create_data_structure_recommender():
    """创建数据结构推荐系统"""
    recommender = DataStructurePatternRecognizer()
    
    # 类型模式
    recommender.add_type_pattern("integer", [
        DataStructureType.ARRAY,
        DataStructureType.LINKED_LIST,
        DataStructureType.HASH_TABLE
    ])
    
    recommender.add_type_pattern("string", [
        DataStructureType.ARRAY,
        DataStructureType.HASH_TABLE
    ])
    
    recommender.add_type_pattern("object", [
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE,
        DataStructureType.GRAPH
    ])
    
    # 操作模式
    recommender.add_operation_pattern("insert", [
        DataStructureType.ARRAY,
        DataStructureType.LINKED_LIST,
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE
    ])
    
    recommender.add_operation_pattern("search", [
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE,
        DataStructureType.GRAPH
    ])
    
    recommender.add_operation_pattern("delete", [
        DataStructureType.ARRAY,
        DataStructureType.LINKED_LIST,
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE
    ])
    
    # 效率要求
    recommender.add_efficiency_requirement(DataStructureType.ARRAY, {
        "access": "O(1)",
        "search": "O(n)",
        "insert": "O(n)",
        "delete": "O(n)"
    })
    
    recommender.add_efficiency_requirement(DataStructureType.HASH_TABLE, {
        "access": "O(1)",
        "search": "O(1)",
        "insert": "O(1)",
        "delete": "O(1)"
    })
    
    recommender.add_efficiency_requirement(DataStructureType.TREE, {
        "access": "O(log n)",
        "search": "O(log n)",
        "insert": "O(log n)",
        "delete": "O(log n)"
    })
    
    return recommender

# 使用示例
ds_recommender = create_data_structure_recommender()

# 推荐场景1：需要频繁搜索的整数集合
recommendations1 = ds_recommender.recommend_structure("integer", ["search", "insert"])
print("Scenario 1: Frequent search on integers")
for rec in recommendations1:
    print(f"  {rec.structure.value}: {rec.reason}")
    print(f"    Efficiency: {rec.efficiency}")

# 推荐场景2：需要快速插入删除的对象集合
recommendations2 = ds_recommender.recommend_structure("object", ["insert", "delete"])
print("\nScenario 2: Fast insert/delete on objects")
for rec in recommendations2:
    print(f"  {rec.structure.value}: {rec.reason}")
    print(f"    Efficiency: {rec.efficiency}")
```

### 4. 算法设计

#### 4.1 贪心算法

**数学定义**：
贪心算法基于局部最优选择：$G(i) = \arg\max_{j \in C_i} f(j)$，其中：

- $G(i)$ 是第 $i$ 步的贪心选择
- $C_i$ 是第 $i$ 步的候选集合
- $f(j)$ 是候选 $j$ 的价值函数

**Python实现**：

```python
from typing import List, Any, Callable, TypeVar
from dataclasses import dataclass
from abc import ABC, abstractmethod

T = TypeVar('T')

@dataclass
class GreedyChoice:
    """贪心选择"""
    value: Any
    score: float
    position: int

class GreedyAlgorithm(ABC):
    """贪心算法基类"""
    
    @abstractmethod
    def get_candidates(self, state: Any) -> List[Any]:
        """获取候选集合"""
        pass
    
    @abstractmethod
    def evaluate_candidate(self, candidate: Any, state: Any) -> float:
        """评估候选"""
        pass
    
    @abstractmethod
    def apply_choice(self, choice: Any, state: Any) -> Any:
        """应用选择"""
        pass
    
    @abstractmethod
    def is_goal_reached(self, state: Any) -> bool:
        """检查是否达到目标"""
        pass
    
    def solve(self, initial_state: Any) -> List[GreedyChoice]:
        """执行贪心算法"""
        state = initial_state
        choices = []
        step = 0
        
        while not self.is_goal_reached(state):
            candidates = self.get_candidates(state)
            
            if not candidates:
                break
            
            # 选择最优候选
            best_candidate = None
            best_score = float('-inf')
            
            for candidate in candidates:
                score = self.evaluate_candidate(candidate, state)
                if score > best_score:
                    best_score = score
                    best_candidate = candidate
            
            if best_candidate is not None:
                choice = GreedyChoice(best_candidate, best_score, step)
                choices.append(choice)
                state = self.apply_choice(best_candidate, state)
                step += 1
            else:
                break
        
        return choices

# 示例：活动选择问题的贪心算法
class ActivitySelection(GreedyAlgorithm):
    """活动选择贪心算法"""
    
    def __init__(self):
        self.activities = []
    
    def set_activities(self, activities: List[tuple[int, int]]):
        """设置活动列表 (开始时间, 结束时间)"""
        self.activities = sorted(activities, key=lambda x: x[1])  # 按结束时间排序
    
    def get_candidates(self, state: List[tuple[int, int]]) -> List[tuple[int, int]]:
        """获取候选活动"""
        if not state:
            return [self.activities[0]] if self.activities else []
        
        last_end_time = state[-1][1]
        candidates = []
        
        for activity in self.activities:
            if activity[0] >= last_end_time:
                candidates.append(activity)
        
        return candidates
    
    def evaluate_candidate(self, candidate: tuple[int, int], state: List[tuple[int, int]]) -> float:
        """评估候选活动（选择结束时间最早的）"""
        return -candidate[1]  # 负值，因为我们要最小化结束时间
    
    def apply_choice(self, choice: tuple[int, int], state: List[tuple[int, int]]) -> List[tuple[int, int]]:
        """应用选择"""
        new_state = state.copy()
        new_state.append(choice)
        return new_state
    
    def is_goal_reached(self, state: List[tuple[int, int]]) -> bool:
        """检查是否达到目标"""
        return len(state) == len(self.activities)

# 使用示例
activity_selection = ActivitySelection()
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)]
activity_selection.set_activities(activities)

choices = activity_selection.solve([])
print("Activity Selection Results:")
for choice in choices:
    print(f"  Step {choice.position}: Activity {choice.value} (score: {choice.score})")

print(f"\nSelected activities: {[choice.value for choice in choices]}")
```

#### 4.2 回溯算法

**数学定义**：
回溯算法基于状态空间搜索：$B(s) = \bigcup_{a \in A(s)} B(\text{apply}(s, a))$，其中：

- $s$ 是当前状态
- $A(s)$ 是状态 $s$ 的可用动作集合
- $\text{apply}(s, a)$ 是应用动作 $a$ 到状态 $s$ 的结果

**Python实现**：

```python
from typing import List, Any, Callable, Optional
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class BacktrackState:
    """回溯状态"""
    data: Any
    depth: int
    path: List[Any]

class BacktrackAlgorithm(ABC):
    """回溯算法基类"""
    
    @abstractmethod
    def get_actions(self, state: BacktrackState) -> List[Any]:
        """获取可用动作"""
        pass
    
    @abstractmethod
    def apply_action(self, state: BacktrackState, action: Any) -> BacktrackState:
        """应用动作"""
        pass
    
    @abstractmethod
    def is_valid(self, state: BacktrackState) -> bool:
        """检查状态是否有效"""
        pass
    
    @abstractmethod
    def is_goal(self, state: BacktrackState) -> bool:
        """检查是否达到目标"""
        pass
    
    def solve(self, initial_data: Any) -> List[BacktrackState]:
        """执行回溯算法"""
        initial_state = BacktrackState(initial_data, 0, [])
        solutions = []
        
        def backtrack(state: BacktrackState):
            if not self.is_valid(state):
                return
            
            if self.is_goal(state):
                solutions.append(state)
                return
            
            actions = self.get_actions(state)
            for action in actions:
                new_state = self.apply_action(state, action)
                backtrack(new_state)
        
        backtrack(initial_state)
        return solutions

# 示例：N皇后问题的回溯算法
class NQueensBacktrack(BacktrackAlgorithm):
    """N皇后回溯算法"""
    
    def __init__(self, n: int):
        self.n = n
    
    def get_actions(self, state: BacktrackState) -> List[int]:
        """获取可用动作（列位置）"""
        board = state.data
        row = state.depth
        
        if row >= self.n:
            return []
        
        available_cols = []
        for col in range(self.n):
            if self.is_safe(board, row, col):
                available_cols.append(col)
        
        return available_cols
    
    def apply_action(self, state: BacktrackState, action: int) -> BacktrackState:
        """应用动作"""
        board = [row[:] for row in state.data]
        board[state.depth][action] = 1
        
        new_path = state.path.copy()
        new_path.append(action)
        
        return BacktrackState(board, state.depth + 1, new_path)
    
    def is_valid(self, state: BacktrackState) -> bool:
        """检查状态是否有效"""
        return state.depth <= self.n
    
    def is_goal(self, state: BacktrackState) -> bool:
        """检查是否达到目标"""
        return state.depth == self.n
    
    def is_safe(self, board: List[List[int]], row: int, col: int) -> bool:
        """检查位置是否安全"""
        # 检查列
        for i in range(row):
            if board[i][col] == 1:
                return False
        
        # 检查左上对角线
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):
            if board[i][j] == 1:
                return False
        
        # 检查右上对角线
        for i, j in zip(range(row-1, -1, -1), range(col+1, self.n)):
            if board[i][j] == 1:
                return False
        
        return True

# 使用示例
def solve_n_queens(n: int):
    """解决N皇后问题"""
    # 初始化空棋盘
    board = [[0 for _ in range(n)] for _ in range(n)]
    
    backtrack = NQueensBacktrack(n)
    solutions = backtrack.solve(board)
    
    print(f"Found {len(solutions)} solutions for {n}-queens problem:")
    for i, solution in enumerate(solutions[:3]):  # 只显示前3个解
        print(f"\nSolution {i+1}:")
        for row in solution.data:
            print("  " + " ".join("Q" if cell == 1 else "." for cell in row))
    
    return solutions

# 运行示例
n_queens_solutions = solve_n_queens(4)
```

## 📊 计算思维总结

### 核心特征

1. **抽象化**：将复杂问题简化为可管理的组件
2. **分解**：将大问题分解为小问题
3. **模式识别**：识别问题中的常见模式
4. **算法设计**：设计有效的解决方案

### 数学形式化

计算思维可以用以下数学结构表示：

$$ComputationalThinking = (Decomposition, Abstraction, PatternRecognition, AlgorithmDesign)$$

其中：

- $Decomposition = \{DivideAndConquer, DynamicProgramming, \ldots\}$
- $Abstraction = \{DataAbstraction, ProcessAbstraction, \ldots\}$
- $PatternRecognition = \{AlgorithmPatterns, DataStructurePatterns, \ldots\}$
- $AlgorithmDesign = \{Greedy, Backtrack, \ldots\}$

### Python实现验证

```python
class ComputationalThinkingValidator:
    """计算思维验证器"""
    
    def __init__(self):
        self.components = {
            'decomposition': self._validate_decomposition,
            'abstraction': self._validate_abstraction,
            'pattern_recognition': self._validate_pattern_recognition,
            'algorithm_design': self._validate_algorithm_design
        }
    
    def validate_computational_thinking(self, approach: str) -> bool:
        """验证计算思维方法"""
        if approach in self.components:
            return self.components[approach]()
        return False
    
    def _validate_decomposition(self) -> bool:
        """验证分解能力"""
        # 测试分治算法
        dc = DivideAndConquer()
        dc.add_divide_strategy("test", lambda x: [x//2, x//2])
        dc.add_conquer_strategy("test", lambda x: x)
        dc.add_combine_strategy("test", lambda x: sum(x))
        
        result = dc.solve(10, "test")
        return result == 10
    
    def _validate_abstraction(self) -> bool:
        """验证抽象能力"""
        # 测试特征提取
        recognizer = AlgorithmPatternRecognizer()
        recognizer.add_feature_extractor("test", lambda x: {"length": len(x) if isinstance(x, list) else 0})
        
        features = recognizer.extract_features([1, 2, 3])
        return features.get("length") == 3
    
    def _validate_pattern_recognition(self) -> bool:
        """验证模式识别"""
        # 测试排序模式识别
        sorting_recognizer = create_sorting_pattern_recognizer()
        matches = sorting_recognizer.recognize_pattern([3, 1, 2])
        
        return len(matches) > 0 and matches[0].pattern == AlgorithmPattern.SORTING
    
    def _validate_algorithm_design(self) -> bool:
        """验证算法设计"""
        # 测试贪心算法
        activity_selection = ActivitySelection()
        activity_selection.set_activities([(1, 4), (3, 5), (0, 6)])
        
        choices = activity_selection.solve([])
        return len(choices) > 0

# 使用示例
validator = ComputationalThinkingValidator()

for component in ['decomposition', 'abstraction', 'pattern_recognition', 'algorithm_design']:
    is_valid = validator.validate_computational_thinking(component)
    print(f"{component.replace('_', ' ').title()}: {'VALID' if is_valid else 'INVALID'}")
```

## 🔗 相关链接

- [00.01 编程哲学](./00.01-编程哲学.md)
- [00.02 形式化思维方法](./00.02-形式化思维方法.md)
- [01.01 集合论基础](../01-形式科学/01.01-集合论基础.md)

---

*计算思维是解决复杂问题的系统性方法，通过分解、抽象、模式识别和算法设计，我们可以有效地理解和解决各种计算问题。*
