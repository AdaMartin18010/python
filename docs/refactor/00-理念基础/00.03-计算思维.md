# 00.03 è®¡ç®—æ€ç»´

## ğŸ“‹ æ¦‚è¿°

è®¡ç®—æ€ç»´æ˜¯è§£å†³å¤æ‚é—®é¢˜çš„ç³»ç»Ÿæ€§æ–¹æ³•ï¼Œé€šè¿‡æŠ½è±¡ã€åˆ†è§£ã€æ¨¡å¼è¯†åˆ«å’Œç®—æ³•è®¾è®¡æ¥ç†è§£å’Œè§£å†³é—®é¢˜ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰è®¡ç®—æ€ç»´çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¡ç®—æ€ç»´çš„å®šä¹‰

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¡ç®—æ€ç»´æ˜¯ä¸€ä¸ªæ˜ å°„ $CT: P \rightarrow S$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯é—®é¢˜ç©ºé—´
- $S$ æ˜¯è§£å†³æ–¹æ¡ˆç©ºé—´
- $CT$ æ»¡è¶³ï¼š$CT(p) = \text{Decompose}(p) \circ \text{Abstract}(p) \circ \text{Pattern}(p) \circ \text{Algorithm}(p)$

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, List, Any, Callable, Dict
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

P = TypeVar('P')  # é—®é¢˜ç±»å‹
S = TypeVar('S')  # è§£å†³æ–¹æ¡ˆç±»å‹

class ThinkingStep(Enum):
    DECOMPOSE = "decompose"
    ABSTRACT = "abstract"
    PATTERN = "pattern"
    ALGORITHM = "algorithm"

@dataclass
class Problem:
    """é—®é¢˜å®šä¹‰"""
    description: str
    complexity: int
    constraints: List[str]
    data: Any

@dataclass
class Solution:
    """è§£å†³æ–¹æ¡ˆå®šä¹‰"""
    description: str
    steps: List[str]
    algorithm: Callable
    complexity: str

class ComputationalThinking:
    """è®¡ç®—æ€ç»´æ¡†æ¶"""
    
    def __init__(self):
        self.decomposition_strategies: Dict[str, Callable] = {}
        self.abstraction_methods: Dict[str, Callable] = {}
        self.pattern_recognition: Dict[str, Callable] = {}
        self.algorithm_design: Dict[str, Callable] = {}
    
    def add_decomposition_strategy(self, name: str, strategy: Callable):
        """æ·»åŠ åˆ†è§£ç­–ç•¥"""
        self.decomposition_strategies[name] = strategy
    
    def add_abstraction_method(self, name: str, method: Callable):
        """æ·»åŠ æŠ½è±¡æ–¹æ³•"""
        self.abstraction_methods[name] = method
    
    def add_pattern_recognition(self, name: str, recognizer: Callable):
        """æ·»åŠ æ¨¡å¼è¯†åˆ«"""
        self.pattern_recognition[name] = recognizer
    
    def add_algorithm_design(self, name: str, designer: Callable):
        """æ·»åŠ ç®—æ³•è®¾è®¡"""
        self.algorithm_design[name] = designer
    
    def solve_problem(self, problem: Problem) -> Solution:
        """ä½¿ç”¨è®¡ç®—æ€ç»´è§£å†³é—®é¢˜"""
        # 1. åˆ†è§£
        subproblems = self.decompose(problem)
        
        # 2. æŠ½è±¡
        abstractions = self.abstract(problem, subproblems)
        
        # 3. æ¨¡å¼è¯†åˆ«
        patterns = self.recognize_patterns(problem, abstractions)
        
        # 4. ç®—æ³•è®¾è®¡
        algorithm = self.design_algorithm(problem, patterns)
        
        return Solution(
            description=f"Solution for {problem.description}",
            steps=[f"Decomposed into {len(subproblems)} subproblems",
                   f"Created {len(abstractions)} abstractions",
                   f"Identified {len(patterns)} patterns",
                   "Designed algorithm"],
            algorithm=algorithm,
            complexity="O(n log n)"  # ç¤ºä¾‹å¤æ‚åº¦
        )
    
    def decompose(self, problem: Problem) -> List[Problem]:
        """åˆ†è§£é—®é¢˜"""
        subproblems = []
        
        for strategy_name, strategy in self.decomposition_strategies.items():
            try:
                result = strategy(problem)
                if isinstance(result, list):
                    subproblems.extend(result)
                else:
                    subproblems.append(result)
            except Exception:
                continue
        
        return subproblems
    
    def abstract(self, original_problem: Problem, subproblems: List[Problem]) -> List[Any]:
        """æŠ½è±¡åŒ–"""
        abstractions = []
        
        for method_name, method in self.abstraction_methods.items():
            try:
                abstraction = method(original_problem, subproblems)
                abstractions.append(abstraction)
            except Exception:
                continue
        
        return abstractions
    
    def recognize_patterns(self, problem: Problem, abstractions: List[Any]) -> List[str]:
        """è¯†åˆ«æ¨¡å¼"""
        patterns = []
        
        for recognizer_name, recognizer in self.pattern_recognition.items():
            try:
                pattern = recognizer(problem, abstractions)
                if pattern:
                    patterns.append(pattern)
            except Exception:
                continue
        
        return patterns
    
    def design_algorithm(self, problem: Problem, patterns: List[str]) -> Callable:
        """è®¾è®¡ç®—æ³•"""
        # æ ¹æ®è¯†åˆ«çš„æ¨¡å¼é€‰æ‹©æˆ–è®¾è®¡ç®—æ³•
        if "sorting" in patterns:
            return self.algorithm_design.get("sorting", lambda x: sorted(x))
        elif "searching" in patterns:
            return self.algorithm_design.get("searching", lambda x: x)
        else:
            return self.algorithm_design.get("default", lambda x: x)

# ç¤ºä¾‹ï¼šæ’åºé—®é¢˜çš„è®¡ç®—æ€ç»´è§£å†³
def create_sorting_computational_thinking():
    """åˆ›å»ºæ’åºé—®é¢˜çš„è®¡ç®—æ€ç»´æ¡†æ¶"""
    ct = ComputationalThinking()
    
    # åˆ†è§£ç­–ç•¥ï¼šå°†å¤§æ•°ç»„åˆ†è§£ä¸ºå°æ•°ç»„
    def array_decomposition(problem: Problem) -> List[Problem]:
        if isinstance(problem.data, list) and len(problem.data) > 1:
            mid = len(problem.data) // 2
            left_data = problem.data[:mid]
            right_data = problem.data[mid:]
            
            return [
                Problem(f"Sort left half", problem.complexity // 2, 
                       problem.constraints, left_data),
                Problem(f"Sort right half", problem.complexity // 2, 
                       problem.constraints, right_data)
            ]
        return [problem]
    
    # æŠ½è±¡æ–¹æ³•ï¼šå°†æ’åºæŠ½è±¡ä¸ºæ¯”è¾ƒæ“ä½œ
    def sorting_abstraction(original_problem: Problem, subproblems: List[Problem]) -> str:
        return "comparison_based_sorting"
    
    # æ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«åˆ†æ²»æ¨¡å¼
    def divide_conquer_pattern(problem: Problem, abstractions: List[Any]) -> str:
        if len(abstractions) > 1:
            return "divide_and_conquer"
        return "simple_sorting"
    
    # ç®—æ³•è®¾è®¡ï¼šå½’å¹¶æ’åº
    def merge_sort_algorithm(data: List) -> List:
        if len(data) <= 1:
            return data
        
        mid = len(data) // 2
        left = merge_sort_algorithm(data[:mid])
        right = merge_sort_algorithm(data[mid:])
        
        return merge(left, right)
    
    def merge(left: List, right: List) -> List:
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    # æ·»åŠ ç­–ç•¥å’Œæ–¹æ³•
    ct.add_decomposition_strategy("array_split", array_decomposition)
    ct.add_abstraction_method("sorting_abstraction", sorting_abstraction)
    ct.add_pattern_recognition("divide_conquer", divide_conquer_pattern)
    ct.add_algorithm_design("sorting", merge_sort_algorithm)
    
    return ct

# ä½¿ç”¨ç¤ºä¾‹
sorting_ct = create_sorting_computational_thinking()
sorting_problem = Problem(
    description="Sort array [3, 1, 4, 1, 5, 9, 2, 6]",
    complexity=8,
    constraints=["Must be stable", "In-place preferred"],
    data=[3, 1, 4, 1, 5, 9, 2, 6]
)

solution = sorting_ct.solve_problem(sorting_problem)
print(f"Problem: {solution.description}")
print(f"Steps: {solution.steps}")
print(f"Result: {solution.algorithm(sorting_problem.data)}")
```

### 2. é—®é¢˜åˆ†è§£

#### 2.1 åˆ†æ²»ç­–ç•¥

**æ•°å­¦å®šä¹‰**ï¼š
åˆ†æ²»ç­–ç•¥å°†é—®é¢˜ $P$ åˆ†è§£ä¸ºå­é—®é¢˜ï¼š$P = P_1 \cup P_2 \cup \cdots \cup P_n$ï¼Œå…¶ä¸­ï¼š

- $P_i \cap P_j = \emptyset$ ï¼ˆå­é—®é¢˜äº’ä¸é‡å ï¼‰
- $\sum_{i=1}^n |P_i| = |P|$ ï¼ˆå­é—®é¢˜å¤§å°ä¹‹å’Œç­‰äºåŸé—®é¢˜ï¼‰

**Pythonå®ç°**ï¼š

```python
from typing import List, Any, Callable, Tuple
from dataclasses import dataclass

@dataclass
class SubProblem:
    """å­é—®é¢˜å®šä¹‰"""
    name: str
    data: Any
    size: int
    parent: str

class DivideAndConquer:
    """åˆ†æ²»ç­–ç•¥å®ç°"""
    
    def __init__(self):
        self.divide_strategies: Dict[str, Callable] = {}
        self.conquer_strategies: Dict[str, Callable] = {}
        self.combine_strategies: Dict[str, Callable] = {}
    
    def add_divide_strategy(self, name: str, strategy: Callable):
        """æ·»åŠ åˆ†è§£ç­–ç•¥"""
        self.divide_strategies[name] = strategy
    
    def add_conquer_strategy(self, name: str, strategy: Callable):
        """æ·»åŠ è§£å†³ç­–ç•¥"""
        self.conquer_strategies[name] = strategy
    
    def add_combine_strategy(self, name: str, strategy: Callable):
        """æ·»åŠ åˆå¹¶ç­–ç•¥"""
        self.combine_strategies[name] = strategy
    
    def solve(self, problem: Any, strategy_name: str) -> Any:
        """ä½¿ç”¨åˆ†æ²»ç­–ç•¥è§£å†³é—®é¢˜"""
        if strategy_name not in self.divide_strategies:
            raise ValueError(f"Strategy '{strategy_name}' not found")
        
        # åˆ†è§£
        subproblems = self.divide_strategies[strategy_name](problem)
        
        # è§£å†³å­é—®é¢˜
        solutions = []
        for subproblem in subproblems:
            if self.is_base_case(subproblem):
                solution = self.conquer_strategies.get(strategy_name, 
                                                     lambda x: x)(subproblem)
            else:
                solution = self.solve(subproblem, strategy_name)
            solutions.append(solution)
        
        # åˆå¹¶ç»“æœ
        if len(solutions) > 1:
            return self.combine_strategies.get(strategy_name, 
                                             lambda x: x[0] if x else None)(solutions)
        else:
            return solutions[0] if solutions else None
    
    def is_base_case(self, problem: Any) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºåŸºæœ¬æƒ…å†µ"""
        if isinstance(problem, list):
            return len(problem) <= 1
        elif isinstance(problem, (int, float)):
            return True
        else:
            return False

# ç¤ºä¾‹ï¼šå¿«é€Ÿæ’åºçš„åˆ†æ²»å®ç°
def create_quicksort_divide_conquer():
    """åˆ›å»ºå¿«é€Ÿæ’åºçš„åˆ†æ²»å®ç°"""
    dc = DivideAndConquer()
    
    def quicksort_divide(data: List) -> List[List]:
        """å¿«é€Ÿæ’åºçš„åˆ†è§£ç­–ç•¥"""
        if len(data) <= 1:
            return [data]
        
        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        
        return [left, middle, right]
    
    def quicksort_conquer(data: List) -> List:
        """å¿«é€Ÿæ’åºçš„è§£å†³ç­–ç•¥"""
        return data
    
    def quicksort_combine(solutions: List[List]) -> List:
        """å¿«é€Ÿæ’åºçš„åˆå¹¶ç­–ç•¥"""
        result = []
        for solution in solutions:
            result.extend(solution)
        return result
    
    dc.add_divide_strategy("quicksort", quicksort_divide)
    dc.add_conquer_strategy("quicksort", quicksort_conquer)
    dc.add_combine_strategy("quicksort", quicksort_combine)
    
    return dc

# ä½¿ç”¨ç¤ºä¾‹
quicksort_dc = create_quicksort_divide_conquer()
test_data = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_data = quicksort_dc.solve(test_data, "quicksort")
print(f"Original: {test_data}")
print(f"Sorted: {sorted_data}")
```

#### 2.2 åŠ¨æ€è§„åˆ’

**æ•°å­¦å®šä¹‰**ï¼š
åŠ¨æ€è§„åˆ’åŸºäºæœ€ä¼˜å­ç»“æ„ï¼š$OPT(i) = \max_{j \in S_i} \{OPT(j) + f(i,j)\}$ï¼Œå…¶ä¸­ï¼š

- $OPT(i)$ æ˜¯é—®é¢˜ $i$ çš„æœ€ä¼˜è§£
- $S_i$ æ˜¯é—®é¢˜ $i$ çš„å­é—®é¢˜é›†åˆ
- $f(i,j)$ æ˜¯ä»å­é—®é¢˜ $j$ åˆ°é—®é¢˜ $i$ çš„è½¬ç§»å‡½æ•°

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Any, Callable, Optional
from functools import lru_cache

class DynamicProgramming:
    """åŠ¨æ€è§„åˆ’æ¡†æ¶"""
    
    def __init__(self):
        self.memo: Dict[str, Any] = {}
        self.subproblems: Dict[str, List[str]] = {}
        self.transition_functions: Dict[str, Callable] = {}
    
    def add_subproblem_relation(self, problem: str, subproblems: List[str]):
        """æ·»åŠ å­é—®é¢˜å…³ç³»"""
        self.subproblems[problem] = subproblems
    
    def add_transition_function(self, problem: str, func: Callable):
        """æ·»åŠ è½¬ç§»å‡½æ•°"""
        self.transition_functions[problem] = func
    
    def solve(self, problem: str, data: Any) -> Any:
        """è§£å†³åŠ¨æ€è§„åˆ’é—®é¢˜"""
        key = f"{problem}_{hash(str(data))}"
        
        if key in self.memo:
            return self.memo[key]
        
        if problem not in self.subproblems:
            # åŸºæœ¬æƒ…å†µ
            result = data
        else:
            # é€’å½’æƒ…å†µ
            subproblem_results = []
            for subproblem in self.subproblems[problem]:
                sub_result = self.solve(subproblem, data)
                subproblem_results.append(sub_result)
            
            if problem in self.transition_functions:
                result = self.transition_functions[problem](data, subproblem_results)
            else:
                result = subproblem_results[0] if subproblem_results else None
        
        self.memo[key] = result
        return result
    
    def clear_memo(self):
        """æ¸…é™¤è®°å¿†åŒ–ç¼“å­˜"""
        self.memo.clear()

# ç¤ºä¾‹ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—çš„åŠ¨æ€è§„åˆ’
def create_fibonacci_dp():
    """åˆ›å»ºæ–æ³¢é‚£å¥‘æ•°åˆ—çš„åŠ¨æ€è§„åˆ’"""
    dp = DynamicProgramming()
    
    def fibonacci_transition(n: int, sub_results: List[int]) -> int:
        """æ–æ³¢é‚£å¥‘è½¬ç§»å‡½æ•°"""
        if len(sub_results) >= 2:
            return sub_results[-2] + sub_results[-1]
        elif len(sub_results) == 1:
            return sub_results[0]
        else:
            return n
    
    # å®šä¹‰å­é—®é¢˜å…³ç³»
    for i in range(2, 10):
        dp.add_subproblem_relation(f"fib_{i}", [f"fib_{i-1}", f"fib_{i-2}"])
    
    dp.add_transition_function("fib_2", fibonacci_transition)
    dp.add_transition_function("fib_3", fibonacci_transition)
    dp.add_transition_function("fib_4", fibonacci_transition)
    dp.add_transition_function("fib_5", fibonacci_transition)
    
    return dp

# ä½¿ç”¨ç¤ºä¾‹
fib_dp = create_fibonacci_dp()
fib_5 = fib_dp.solve("fib_5", 5)
print(f"Fibonacci(5) = {fib_5}")

# ä½¿ç”¨è£…é¥°å™¨çš„ç®€åŒ–ç‰ˆæœ¬
@lru_cache(maxsize=None)
def fibonacci(n: int) -> int:
    """ä½¿ç”¨è®°å¿†åŒ–çš„æ–æ³¢é‚£å¥‘å‡½æ•°"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(f"Fibonacci(10) = {fibonacci(10)}")
```

### 3. æ¨¡å¼è¯†åˆ«

#### 3.1 ç®—æ³•æ¨¡å¼

**æ•°å­¦å®šä¹‰**ï¼š
ç®—æ³•æ¨¡å¼æ˜¯ä¸€ä¸ªå‡½æ•° $M: I \rightarrow P$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯è¾“å…¥å®ä¾‹é›†åˆ
- $P$ æ˜¯æ¨¡å¼é›†åˆ
- $M$ å°†è¾“å…¥æ˜ å°„åˆ°ç›¸åº”çš„ç®—æ³•æ¨¡å¼

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Any, Callable, TypeVar
from dataclasses import dataclass
from enum import Enum

class AlgorithmPattern(Enum):
    SORTING = "sorting"
    SEARCHING = "searching"
    GRAPH_TRAVERSAL = "graph_traversal"
    DYNAMIC_PROGRAMMING = "dynamic_programming"
    GREEDY = "greedy"
    DIVIDE_AND_CONQUER = "divide_and_conquer"

@dataclass
class PatternMatch:
    """æ¨¡å¼åŒ¹é…ç»“æœ"""
    pattern: AlgorithmPattern
    confidence: float
    parameters: Dict[str, Any]

class AlgorithmPatternRecognizer:
    """ç®—æ³•æ¨¡å¼è¯†åˆ«å™¨"""
    
    def __init__(self):
        self.pattern_detectors: Dict[AlgorithmPattern, Callable] = {}
        self.feature_extractors: Dict[str, Callable] = {}
    
    def add_pattern_detector(self, pattern: AlgorithmPattern, detector: Callable):
        """æ·»åŠ æ¨¡å¼æ£€æµ‹å™¨"""
        self.pattern_detectors[pattern] = detector
    
    def add_feature_extractor(self, name: str, extractor: Callable):
        """æ·»åŠ ç‰¹å¾æå–å™¨"""
        self.feature_extractors[name] = extractor
    
    def extract_features(self, data: Any) -> Dict[str, Any]:
        """æå–ç‰¹å¾"""
        features = {}
        
        for name, extractor in self.feature_extractors.items():
            try:
                features[name] = extractor(data)
            except Exception:
                features[name] = None
        
        return features
    
    def recognize_pattern(self, data: Any) -> List[PatternMatch]:
        """è¯†åˆ«ç®—æ³•æ¨¡å¼"""
        features = self.extract_features(data)
        matches = []
        
        for pattern, detector in self.pattern_detectors.items():
            try:
                confidence, parameters = detector(features)
                if confidence > 0.5:  # ç½®ä¿¡åº¦é˜ˆå€¼
                    matches.append(PatternMatch(pattern, confidence, parameters))
            except Exception:
                continue
        
        # æŒ‰ç½®ä¿¡åº¦æ’åº
        matches.sort(key=lambda x: x.confidence, reverse=True)
        return matches

# ç¤ºä¾‹ï¼šæ’åºæ¨¡å¼è¯†åˆ«
def create_sorting_pattern_recognizer():
    """åˆ›å»ºæ’åºæ¨¡å¼è¯†åˆ«å™¨"""
    recognizer = AlgorithmPatternRecognizer()
    
    def extract_array_features(data: Any) -> Dict[str, Any]:
        """æå–æ•°ç»„ç‰¹å¾"""
        if not isinstance(data, list):
            return {}
        
        return {
            "length": len(data),
            "is_numeric": all(isinstance(x, (int, float)) for x in data),
            "has_duplicates": len(set(data)) != len(data),
            "is_sorted": data == sorted(data),
            "range": max(data) - min(data) if data else 0
        }
    
    def detect_sorting_pattern(features: Dict[str, Any]) -> Tuple[float, Dict[str, Any]]:
        """æ£€æµ‹æ’åºæ¨¡å¼"""
        if not features:
            return 0.0, {}
        
        confidence = 0.0
        parameters = {}
        
        # åŸºäºç‰¹å¾è®¡ç®—ç½®ä¿¡åº¦
        if features.get("length", 0) > 1:
            confidence += 0.3
        
        if features.get("is_numeric", False):
            confidence += 0.2
        
        if not features.get("is_sorted", True):
            confidence += 0.5
        
        # é€‰æ‹©æ’åºç®—æ³•
        if features.get("length", 0) < 50:
            parameters["algorithm"] = "insertion_sort"
        elif features.get("has_duplicates", False):
            parameters["algorithm"] = "merge_sort"
        else:
            parameters["algorithm"] = "quicksort"
        
        return confidence, parameters
    
    recognizer.add_feature_extractor("array_features", extract_array_features)
    recognizer.add_pattern_detector(AlgorithmPattern.SORTING, detect_sorting_pattern)
    
    return recognizer

# ä½¿ç”¨ç¤ºä¾‹
sorting_recognizer = create_sorting_pattern_recognizer()

test_cases = [
    [3, 1, 4, 1, 5, 9, 2, 6],  # æœªæ’åºæ•°ç»„
    [1, 2, 3, 4, 5],           # å·²æ’åºæ•°ç»„
    [5, 4, 3, 2, 1],           # é€†åºæ•°ç»„
    [1],                       # å•å…ƒç´ æ•°ç»„
    []                         # ç©ºæ•°ç»„
]

for i, test_case in enumerate(test_cases):
    matches = sorting_recognizer.recognize_pattern(test_case)
    print(f"Test case {i+1}: {test_case}")
    for match in matches:
        print(f"  Pattern: {match.pattern.value}, "
              f"Confidence: {match.confidence:.2f}, "
              f"Algorithm: {match.parameters.get('algorithm', 'unknown')}")
    print()
```

#### 3.2 æ•°æ®ç»“æ„æ¨¡å¼

**æ•°å­¦å®šä¹‰**ï¼š
æ•°æ®ç»“æ„æ¨¡å¼æ˜¯ä¸€ä¸ªæ˜ å°„ $DS: T \rightarrow S$ï¼Œå…¶ä¸­ï¼š

- $T$ æ˜¯æ•°æ®ç±»å‹é›†åˆ
- $S$ æ˜¯æ•°æ®ç»“æ„é›†åˆ
- $DS$ å°†æ•°æ®ç±»å‹æ˜ å°„åˆ°åˆé€‚çš„æ•°æ®ç»“æ„

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Any, Type, Callable
from dataclasses import dataclass
from enum import Enum

class DataStructureType(Enum):
    ARRAY = "array"
    LINKED_LIST = "linked_list"
    STACK = "stack"
    QUEUE = "queue"
    HASH_TABLE = "hash_table"
    TREE = "tree"
    GRAPH = "graph"
    HEAP = "heap"

@dataclass
class DataStructureRecommendation:
    """æ•°æ®ç»“æ„æ¨è"""
    structure: DataStructureType
    reason: str
    efficiency: Dict[str, str]
    implementation: str

class DataStructurePatternRecognizer:
    """æ•°æ®ç»“æ„æ¨¡å¼è¯†åˆ«å™¨"""
    
    def __init__(self):
        self.type_patterns: Dict[str, List[DataStructureType]] = {}
        self.operation_patterns: Dict[str, List[DataStructureType]] = {}
        self.efficiency_requirements: Dict[str, Dict[str, str]] = {}
    
    def add_type_pattern(self, data_type: str, structures: List[DataStructureType]):
        """æ·»åŠ ç±»å‹æ¨¡å¼"""
        self.type_patterns[data_type] = structures
    
    def add_operation_pattern(self, operation: str, structures: List[DataStructureType]):
        """æ·»åŠ æ“ä½œæ¨¡å¼"""
        self.operation_patterns[operation] = structures
    
    def add_efficiency_requirement(self, structure: DataStructureType, 
                                 operations: Dict[str, str]):
        """æ·»åŠ æ•ˆç‡è¦æ±‚"""
        self.efficiency_requirements[structure.value] = operations
    
    def recommend_structure(self, data_type: str, operations: List[str]) -> List[DataStructureRecommendation]:
        """æ¨èæ•°æ®ç»“æ„"""
        recommendations = []
        
        # åŸºäºç±»å‹æ¨è
        type_candidates = self.type_patterns.get(data_type, [])
        
        # åŸºäºæ“ä½œæ¨è
        operation_candidates = []
        for operation in operations:
            operation_candidates.extend(self.operation_patterns.get(operation, []))
        
        # åˆå¹¶å€™é€‰
        all_candidates = set(type_candidates + operation_candidates)
        
        for candidate in all_candidates:
            efficiency = self.efficiency_requirements.get(candidate.value, {})
            recommendation = DataStructureRecommendation(
                structure=candidate,
                reason=f"Supports {data_type} data and {', '.join(operations)} operations",
                efficiency=efficiency,
                implementation=f"Python {candidate.value.replace('_', ' ')}"
            )
            recommendations.append(recommendation)
        
        return recommendations

# ç¤ºä¾‹ï¼šæ•°æ®ç»“æ„æ¨èç³»ç»Ÿ
def create_data_structure_recommender():
    """åˆ›å»ºæ•°æ®ç»“æ„æ¨èç³»ç»Ÿ"""
    recommender = DataStructurePatternRecognizer()
    
    # ç±»å‹æ¨¡å¼
    recommender.add_type_pattern("integer", [
        DataStructureType.ARRAY,
        DataStructureType.LINKED_LIST,
        DataStructureType.HASH_TABLE
    ])
    
    recommender.add_type_pattern("string", [
        DataStructureType.ARRAY,
        DataStructureType.HASH_TABLE
    ])
    
    recommender.add_type_pattern("object", [
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE,
        DataStructureType.GRAPH
    ])
    
    # æ“ä½œæ¨¡å¼
    recommender.add_operation_pattern("insert", [
        DataStructureType.ARRAY,
        DataStructureType.LINKED_LIST,
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE
    ])
    
    recommender.add_operation_pattern("search", [
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE,
        DataStructureType.GRAPH
    ])
    
    recommender.add_operation_pattern("delete", [
        DataStructureType.ARRAY,
        DataStructureType.LINKED_LIST,
        DataStructureType.HASH_TABLE,
        DataStructureType.TREE
    ])
    
    # æ•ˆç‡è¦æ±‚
    recommender.add_efficiency_requirement(DataStructureType.ARRAY, {
        "access": "O(1)",
        "search": "O(n)",
        "insert": "O(n)",
        "delete": "O(n)"
    })
    
    recommender.add_efficiency_requirement(DataStructureType.HASH_TABLE, {
        "access": "O(1)",
        "search": "O(1)",
        "insert": "O(1)",
        "delete": "O(1)"
    })
    
    recommender.add_efficiency_requirement(DataStructureType.TREE, {
        "access": "O(log n)",
        "search": "O(log n)",
        "insert": "O(log n)",
        "delete": "O(log n)"
    })
    
    return recommender

# ä½¿ç”¨ç¤ºä¾‹
ds_recommender = create_data_structure_recommender()

# æ¨èåœºæ™¯1ï¼šéœ€è¦é¢‘ç¹æœç´¢çš„æ•´æ•°é›†åˆ
recommendations1 = ds_recommender.recommend_structure("integer", ["search", "insert"])
print("Scenario 1: Frequent search on integers")
for rec in recommendations1:
    print(f"  {rec.structure.value}: {rec.reason}")
    print(f"    Efficiency: {rec.efficiency}")

# æ¨èåœºæ™¯2ï¼šéœ€è¦å¿«é€Ÿæ’å…¥åˆ é™¤çš„å¯¹è±¡é›†åˆ
recommendations2 = ds_recommender.recommend_structure("object", ["insert", "delete"])
print("\nScenario 2: Fast insert/delete on objects")
for rec in recommendations2:
    print(f"  {rec.structure.value}: {rec.reason}")
    print(f"    Efficiency: {rec.efficiency}")
```

### 4. ç®—æ³•è®¾è®¡

#### 4.1 è´ªå¿ƒç®—æ³•

**æ•°å­¦å®šä¹‰**ï¼š
è´ªå¿ƒç®—æ³•åŸºäºå±€éƒ¨æœ€ä¼˜é€‰æ‹©ï¼š$G(i) = \arg\max_{j \in C_i} f(j)$ï¼Œå…¶ä¸­ï¼š

- $G(i)$ æ˜¯ç¬¬ $i$ æ­¥çš„è´ªå¿ƒé€‰æ‹©
- $C_i$ æ˜¯ç¬¬ $i$ æ­¥çš„å€™é€‰é›†åˆ
- $f(j)$ æ˜¯å€™é€‰ $j$ çš„ä»·å€¼å‡½æ•°

**Pythonå®ç°**ï¼š

```python
from typing import List, Any, Callable, TypeVar
from dataclasses import dataclass
from abc import ABC, abstractmethod

T = TypeVar('T')

@dataclass
class GreedyChoice:
    """è´ªå¿ƒé€‰æ‹©"""
    value: Any
    score: float
    position: int

class GreedyAlgorithm(ABC):
    """è´ªå¿ƒç®—æ³•åŸºç±»"""
    
    @abstractmethod
    def get_candidates(self, state: Any) -> List[Any]:
        """è·å–å€™é€‰é›†åˆ"""
        pass
    
    @abstractmethod
    def evaluate_candidate(self, candidate: Any, state: Any) -> float:
        """è¯„ä¼°å€™é€‰"""
        pass
    
    @abstractmethod
    def apply_choice(self, choice: Any, state: Any) -> Any:
        """åº”ç”¨é€‰æ‹©"""
        pass
    
    @abstractmethod
    def is_goal_reached(self, state: Any) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡"""
        pass
    
    def solve(self, initial_state: Any) -> List[GreedyChoice]:
        """æ‰§è¡Œè´ªå¿ƒç®—æ³•"""
        state = initial_state
        choices = []
        step = 0
        
        while not self.is_goal_reached(state):
            candidates = self.get_candidates(state)
            
            if not candidates:
                break
            
            # é€‰æ‹©æœ€ä¼˜å€™é€‰
            best_candidate = None
            best_score = float('-inf')
            
            for candidate in candidates:
                score = self.evaluate_candidate(candidate, state)
                if score > best_score:
                    best_score = score
                    best_candidate = candidate
            
            if best_candidate is not None:
                choice = GreedyChoice(best_candidate, best_score, step)
                choices.append(choice)
                state = self.apply_choice(best_candidate, state)
                step += 1
            else:
                break
        
        return choices

# ç¤ºä¾‹ï¼šæ´»åŠ¨é€‰æ‹©é—®é¢˜çš„è´ªå¿ƒç®—æ³•
class ActivitySelection(GreedyAlgorithm):
    """æ´»åŠ¨é€‰æ‹©è´ªå¿ƒç®—æ³•"""
    
    def __init__(self):
        self.activities = []
    
    def set_activities(self, activities: List[tuple[int, int]]):
        """è®¾ç½®æ´»åŠ¨åˆ—è¡¨ (å¼€å§‹æ—¶é—´, ç»“æŸæ—¶é—´)"""
        self.activities = sorted(activities, key=lambda x: x[1])  # æŒ‰ç»“æŸæ—¶é—´æ’åº
    
    def get_candidates(self, state: List[tuple[int, int]]) -> List[tuple[int, int]]:
        """è·å–å€™é€‰æ´»åŠ¨"""
        if not state:
            return [self.activities[0]] if self.activities else []
        
        last_end_time = state[-1][1]
        candidates = []
        
        for activity in self.activities:
            if activity[0] >= last_end_time:
                candidates.append(activity)
        
        return candidates
    
    def evaluate_candidate(self, candidate: tuple[int, int], state: List[tuple[int, int]]) -> float:
        """è¯„ä¼°å€™é€‰æ´»åŠ¨ï¼ˆé€‰æ‹©ç»“æŸæ—¶é—´æœ€æ—©çš„ï¼‰"""
        return -candidate[1]  # è´Ÿå€¼ï¼Œå› ä¸ºæˆ‘ä»¬è¦æœ€å°åŒ–ç»“æŸæ—¶é—´
    
    def apply_choice(self, choice: tuple[int, int], state: List[tuple[int, int]]) -> List[tuple[int, int]]:
        """åº”ç”¨é€‰æ‹©"""
        new_state = state.copy()
        new_state.append(choice)
        return new_state
    
    def is_goal_reached(self, state: List[tuple[int, int]]) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡"""
        return len(state) == len(self.activities)

# ä½¿ç”¨ç¤ºä¾‹
activity_selection = ActivitySelection()
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)]
activity_selection.set_activities(activities)

choices = activity_selection.solve([])
print("Activity Selection Results:")
for choice in choices:
    print(f"  Step {choice.position}: Activity {choice.value} (score: {choice.score})")

print(f"\nSelected activities: {[choice.value for choice in choices]}")
```

#### 4.2 å›æº¯ç®—æ³•

**æ•°å­¦å®šä¹‰**ï¼š
å›æº¯ç®—æ³•åŸºäºçŠ¶æ€ç©ºé—´æœç´¢ï¼š$B(s) = \bigcup_{a \in A(s)} B(\text{apply}(s, a))$ï¼Œå…¶ä¸­ï¼š

- $s$ æ˜¯å½“å‰çŠ¶æ€
- $A(s)$ æ˜¯çŠ¶æ€ $s$ çš„å¯ç”¨åŠ¨ä½œé›†åˆ
- $\text{apply}(s, a)$ æ˜¯åº”ç”¨åŠ¨ä½œ $a$ åˆ°çŠ¶æ€ $s$ çš„ç»“æœ

**Pythonå®ç°**ï¼š

```python
from typing import List, Any, Callable, Optional
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class BacktrackState:
    """å›æº¯çŠ¶æ€"""
    data: Any
    depth: int
    path: List[Any]

class BacktrackAlgorithm(ABC):
    """å›æº¯ç®—æ³•åŸºç±»"""
    
    @abstractmethod
    def get_actions(self, state: BacktrackState) -> List[Any]:
        """è·å–å¯ç”¨åŠ¨ä½œ"""
        pass
    
    @abstractmethod
    def apply_action(self, state: BacktrackState, action: Any) -> BacktrackState:
        """åº”ç”¨åŠ¨ä½œ"""
        pass
    
    @abstractmethod
    def is_valid(self, state: BacktrackState) -> bool:
        """æ£€æŸ¥çŠ¶æ€æ˜¯å¦æœ‰æ•ˆ"""
        pass
    
    @abstractmethod
    def is_goal(self, state: BacktrackState) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡"""
        pass
    
    def solve(self, initial_data: Any) -> List[BacktrackState]:
        """æ‰§è¡Œå›æº¯ç®—æ³•"""
        initial_state = BacktrackState(initial_data, 0, [])
        solutions = []
        
        def backtrack(state: BacktrackState):
            if not self.is_valid(state):
                return
            
            if self.is_goal(state):
                solutions.append(state)
                return
            
            actions = self.get_actions(state)
            for action in actions:
                new_state = self.apply_action(state, action)
                backtrack(new_state)
        
        backtrack(initial_state)
        return solutions

# ç¤ºä¾‹ï¼šNçš‡åé—®é¢˜çš„å›æº¯ç®—æ³•
class NQueensBacktrack(BacktrackAlgorithm):
    """Nçš‡åå›æº¯ç®—æ³•"""
    
    def __init__(self, n: int):
        self.n = n
    
    def get_actions(self, state: BacktrackState) -> List[int]:
        """è·å–å¯ç”¨åŠ¨ä½œï¼ˆåˆ—ä½ç½®ï¼‰"""
        board = state.data
        row = state.depth
        
        if row >= self.n:
            return []
        
        available_cols = []
        for col in range(self.n):
            if self.is_safe(board, row, col):
                available_cols.append(col)
        
        return available_cols
    
    def apply_action(self, state: BacktrackState, action: int) -> BacktrackState:
        """åº”ç”¨åŠ¨ä½œ"""
        board = [row[:] for row in state.data]
        board[state.depth][action] = 1
        
        new_path = state.path.copy()
        new_path.append(action)
        
        return BacktrackState(board, state.depth + 1, new_path)
    
    def is_valid(self, state: BacktrackState) -> bool:
        """æ£€æŸ¥çŠ¶æ€æ˜¯å¦æœ‰æ•ˆ"""
        return state.depth <= self.n
    
    def is_goal(self, state: BacktrackState) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡"""
        return state.depth == self.n
    
    def is_safe(self, board: List[List[int]], row: int, col: int) -> bool:
        """æ£€æŸ¥ä½ç½®æ˜¯å¦å®‰å…¨"""
        # æ£€æŸ¥åˆ—
        for i in range(row):
            if board[i][col] == 1:
                return False
        
        # æ£€æŸ¥å·¦ä¸Šå¯¹è§’çº¿
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):
            if board[i][j] == 1:
                return False
        
        # æ£€æŸ¥å³ä¸Šå¯¹è§’çº¿
        for i, j in zip(range(row-1, -1, -1), range(col+1, self.n)):
            if board[i][j] == 1:
                return False
        
        return True

# ä½¿ç”¨ç¤ºä¾‹
def solve_n_queens(n: int):
    """è§£å†³Nçš‡åé—®é¢˜"""
    # åˆå§‹åŒ–ç©ºæ£‹ç›˜
    board = [[0 for _ in range(n)] for _ in range(n)]
    
    backtrack = NQueensBacktrack(n)
    solutions = backtrack.solve(board)
    
    print(f"Found {len(solutions)} solutions for {n}-queens problem:")
    for i, solution in enumerate(solutions[:3]):  # åªæ˜¾ç¤ºå‰3ä¸ªè§£
        print(f"\nSolution {i+1}:")
        for row in solution.data:
            print("  " + " ".join("Q" if cell == 1 else "." for cell in row))
    
    return solutions

# è¿è¡Œç¤ºä¾‹
n_queens_solutions = solve_n_queens(4)
```

## ğŸ“Š è®¡ç®—æ€ç»´æ€»ç»“

### æ ¸å¿ƒç‰¹å¾

1. **æŠ½è±¡åŒ–**ï¼šå°†å¤æ‚é—®é¢˜ç®€åŒ–ä¸ºå¯ç®¡ç†çš„ç»„ä»¶
2. **åˆ†è§£**ï¼šå°†å¤§é—®é¢˜åˆ†è§£ä¸ºå°é—®é¢˜
3. **æ¨¡å¼è¯†åˆ«**ï¼šè¯†åˆ«é—®é¢˜ä¸­çš„å¸¸è§æ¨¡å¼
4. **ç®—æ³•è®¾è®¡**ï¼šè®¾è®¡æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆ

### æ•°å­¦å½¢å¼åŒ–

è®¡ç®—æ€ç»´å¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦ç»“æ„è¡¨ç¤ºï¼š

$$ComputationalThinking = (Decomposition, Abstraction, PatternRecognition, AlgorithmDesign)$$

å…¶ä¸­ï¼š

- $Decomposition = \{DivideAndConquer, DynamicProgramming, \ldots\}$
- $Abstraction = \{DataAbstraction, ProcessAbstraction, \ldots\}$
- $PatternRecognition = \{AlgorithmPatterns, DataStructurePatterns, \ldots\}$
- $AlgorithmDesign = \{Greedy, Backtrack, \ldots\}$

### Pythonå®ç°éªŒè¯

```python
class ComputationalThinkingValidator:
    """è®¡ç®—æ€ç»´éªŒè¯å™¨"""
    
    def __init__(self):
        self.components = {
            'decomposition': self._validate_decomposition,
            'abstraction': self._validate_abstraction,
            'pattern_recognition': self._validate_pattern_recognition,
            'algorithm_design': self._validate_algorithm_design
        }
    
    def validate_computational_thinking(self, approach: str) -> bool:
        """éªŒè¯è®¡ç®—æ€ç»´æ–¹æ³•"""
        if approach in self.components:
            return self.components[approach]()
        return False
    
    def _validate_decomposition(self) -> bool:
        """éªŒè¯åˆ†è§£èƒ½åŠ›"""
        # æµ‹è¯•åˆ†æ²»ç®—æ³•
        dc = DivideAndConquer()
        dc.add_divide_strategy("test", lambda x: [x//2, x//2])
        dc.add_conquer_strategy("test", lambda x: x)
        dc.add_combine_strategy("test", lambda x: sum(x))
        
        result = dc.solve(10, "test")
        return result == 10
    
    def _validate_abstraction(self) -> bool:
        """éªŒè¯æŠ½è±¡èƒ½åŠ›"""
        # æµ‹è¯•ç‰¹å¾æå–
        recognizer = AlgorithmPatternRecognizer()
        recognizer.add_feature_extractor("test", lambda x: {"length": len(x) if isinstance(x, list) else 0})
        
        features = recognizer.extract_features([1, 2, 3])
        return features.get("length") == 3
    
    def _validate_pattern_recognition(self) -> bool:
        """éªŒè¯æ¨¡å¼è¯†åˆ«"""
        # æµ‹è¯•æ’åºæ¨¡å¼è¯†åˆ«
        sorting_recognizer = create_sorting_pattern_recognizer()
        matches = sorting_recognizer.recognize_pattern([3, 1, 2])
        
        return len(matches) > 0 and matches[0].pattern == AlgorithmPattern.SORTING
    
    def _validate_algorithm_design(self) -> bool:
        """éªŒè¯ç®—æ³•è®¾è®¡"""
        # æµ‹è¯•è´ªå¿ƒç®—æ³•
        activity_selection = ActivitySelection()
        activity_selection.set_activities([(1, 4), (3, 5), (0, 6)])
        
        choices = activity_selection.solve([])
        return len(choices) > 0

# ä½¿ç”¨ç¤ºä¾‹
validator = ComputationalThinkingValidator()

for component in ['decomposition', 'abstraction', 'pattern_recognition', 'algorithm_design']:
    is_valid = validator.validate_computational_thinking(component)
    print(f"{component.replace('_', ' ').title()}: {'VALID' if is_valid else 'INVALID'}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.01 ç¼–ç¨‹å“²å­¦](./00.01-ç¼–ç¨‹å“²å­¦.md)
- [00.02 å½¢å¼åŒ–æ€ç»´æ–¹æ³•](./00.02-å½¢å¼åŒ–æ€ç»´æ–¹æ³•.md)
- [01.01 é›†åˆè®ºåŸºç¡€](../01-å½¢å¼ç§‘å­¦/01.01-é›†åˆè®ºåŸºç¡€.md)

---

*è®¡ç®—æ€ç»´æ˜¯è§£å†³å¤æ‚é—®é¢˜çš„ç³»ç»Ÿæ€§æ–¹æ³•ï¼Œé€šè¿‡åˆ†è§£ã€æŠ½è±¡ã€æ¨¡å¼è¯†åˆ«å’Œç®—æ³•è®¾è®¡ï¼Œæˆ‘ä»¬å¯ä»¥æœ‰æ•ˆåœ°ç†è§£å’Œè§£å†³å„ç§è®¡ç®—é—®é¢˜ã€‚*
