# åŠ¨æ€è§„åˆ’ç®—æ³•

## ğŸ“‹ æ¦‚è¿°

åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç§é€šè¿‡å°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜æ¥è§£å†³ä¼˜åŒ–é—®é¢˜çš„ç®—æ³•è®¾è®¡æ–¹æ³•ã€‚å®ƒé€šè¿‡å­˜å‚¨å­é—®é¢˜çš„è§£æ¥é¿å…é‡å¤è®¡ç®—ï¼Œä»è€Œæ˜¾è‘—æé«˜ç®—æ³•æ•ˆç‡ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 åŠ¨æ€è§„åˆ’é—®é¢˜å®šä¹‰

**å®šä¹‰ 1.1** (åŠ¨æ€è§„åˆ’é—®é¢˜)
åŠ¨æ€è§„åˆ’é—®é¢˜æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{P} = (S, A, T, R, V)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€ç©ºé—´
- $A$ æ˜¯åŠ¨ä½œç©ºé—´
- $T: S \times A \rightarrow S$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $R: S \times A \rightarrow \mathbb{R}$ æ˜¯å¥–åŠ±å‡½æ•°
- $V: S \rightarrow \mathbb{R}$ æ˜¯ä»·å€¼å‡½æ•°

### 1.2 æœ€ä¼˜å­ç»“æ„

**å®šä¹‰ 1.2** (æœ€ä¼˜å­ç»“æ„)
é—®é¢˜å…·æœ‰æœ€ä¼˜å­ç»“æ„ï¼Œå¦‚æœé—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å…¶å­é—®é¢˜çš„æœ€ä¼˜è§£ã€‚

**å®šç† 1.1** (åŠ¨æ€è§„åˆ’æ­£ç¡®æ€§)
å¦‚æœé—®é¢˜å…·æœ‰æœ€ä¼˜å­ç»“æ„å’Œé‡å å­é—®é¢˜ï¼Œåˆ™åŠ¨æ€è§„åˆ’ç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚

**è¯æ˜**:

1. æœ€ä¼˜å­ç»“æ„ç¡®ä¿å±€éƒ¨æœ€ä¼˜å¯¼è‡´å…¨å±€æœ€ä¼˜
2. é‡å å­é—®é¢˜å…è®¸é€šè¿‡è®°å¿†åŒ–é¿å…é‡å¤è®¡ç®—
3. å› æ­¤åŠ¨æ€è§„åˆ’èƒ½å¤Ÿæ­£ç¡®æ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£

### 1.3 çŠ¶æ€è½¬ç§»æ–¹ç¨‹

**å®šä¹‰ 1.3** (çŠ¶æ€è½¬ç§»æ–¹ç¨‹)
çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯æè¿°çŠ¶æ€å€¼ä¹‹é—´å…³ç³»çš„æ•°å­¦è¡¨è¾¾å¼ï¼š

$$V(s) = \max_{a \in A} \{R(s, a) + \gamma V(T(s, a))\}$$

å…¶ä¸­ $\gamma$ æ˜¯æŠ˜æ‰£å› å­ã€‚

## 2. Pythonå®ç°

### 2.1 åŸºç¡€åŠ¨æ€è§„åˆ’æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any, Tuple, Callable
from enum import Enum
import time
import sys
from collections import defaultdict
import numpy as np

class DPSolution:
    """åŠ¨æ€è§„åˆ’è§£"""
    
    def __init__(self, value: float, path: List[Any] = None):
        self.value = value
        self.path = path or []
        
    def __str__(self):
        return f"Value: {self.value}, Path: {self.path}"

class DynamicProgramming:
    """åŠ¨æ€è§„åˆ’åŸºç±»"""
    
    def __init__(self):
        self.memo: Dict[Any, DPSolution] = {}
        self.calls = 0
        
    def solve(self, problem: Any) -> DPSolution:
        """è§£å†³é—®é¢˜"""
        self.calls = 0
        self.memo.clear()
        return self._solve_recursive(problem)
        
    @abstractmethod
    def _solve_recursive(self, problem: Any) -> DPSolution:
        """é€’å½’è§£å†³å­é—®é¢˜"""
        pass
        
    def get_statistics(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            "total_calls": self.calls,
            "memoized_calls": len(self.memo),
            "cache_hit_rate": len(self.memo) / self.calls if self.calls > 0 else 0
        }

class FibonacciDP(DynamicProgramming):
    """æ–æ³¢é‚£å¥‘æ•°åˆ—åŠ¨æ€è§„åˆ’"""
    
    def _solve_recursive(self, n: int) -> DPSolution:
        """é€’å½’è®¡ç®—æ–æ³¢é‚£å¥‘æ•°"""
        self.calls += 1
        
        # åŸºç¡€æƒ…å†µ
        if n <= 1:
            return DPSolution(n)
            
        # æ£€æŸ¥è®°å¿†åŒ–
        if n in self.memo:
            return self.memo[n]
            
        # é€’å½’è®¡ç®—
        fib_n_1 = self._solve_recursive(n - 1)
        fib_n_2 = self._solve_recursive(n - 2)
        
        result = DPSolution(fib_n_1.value + fib_n_2.value)
        self.memo[n] = result
        
        return result

class LongestCommonSubsequenceDP(DynamicProgramming):
    """æœ€é•¿å…¬å…±å­åºåˆ—åŠ¨æ€è§„åˆ’"""
    
    def _solve_recursive(self, problem: Tuple[str, str]) -> DPSolution:
        """é€’å½’è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—"""
        self.calls += 1
        s1, s2 = problem
        
        # åŸºç¡€æƒ…å†µ
        if not s1 or not s2:
            return DPSolution(0, [])
            
        # æ£€æŸ¥è®°å¿†åŒ–
        if problem in self.memo:
            return self.memo[problem]
            
        # é€’å½’è®¡ç®—
        if s1[-1] == s2[-1]:
            # å­—ç¬¦åŒ¹é…
            sub_solution = self._solve_recursive((s1[:-1], s2[:-1]))
            result = DPSolution(
                sub_solution.value + 1,
                sub_solution.path + [s1[-1]]
            )
        else:
            # å­—ç¬¦ä¸åŒ¹é…ï¼Œå–æœ€å¤§å€¼
            sol1 = self._solve_recursive((s1[:-1], s2))
            sol2 = self._solve_recursive((s1, s2[:-1]))
            
            if sol1.value >= sol2.value:
                result = sol1
            else:
                result = sol2
                
        self.memo[problem] = result
        return result

class KnapsackDP(DynamicProgramming):
    """0-1èƒŒåŒ…é—®é¢˜åŠ¨æ€è§„åˆ’"""
    
    def _solve_recursive(self, problem: Tuple[int, List[int], List[int], int]) -> DPSolution:
        """é€’å½’è§£å†³èƒŒåŒ…é—®é¢˜"""
        self.calls += 1
        n, weights, values, capacity = problem
        
        # åŸºç¡€æƒ…å†µ
        if n == 0 or capacity == 0:
            return DPSolution(0, [])
            
        # æ£€æŸ¥è®°å¿†åŒ–
        if problem in self.memo:
            return self.memo[problem]
            
        # é€’å½’è®¡ç®—
        if weights[n-1] <= capacity:
            # å¯ä»¥é€‰æ‹©å½“å‰ç‰©å“
            include_solution = self._solve_recursive(
                (n-1, weights, values, capacity - weights[n-1])
            )
            include_value = include_solution.value + values[n-1]
            
            exclude_solution = self._solve_recursive(
                (n-1, weights, values, capacity)
            )
            
            if include_value > exclude_solution.value:
                result = DPSolution(
                    include_value,
                    include_solution.path + [n-1]
                )
            else:
                result = exclude_solution
        else:
            # ä¸èƒ½é€‰æ‹©å½“å‰ç‰©å“
            result = self._solve_recursive((n-1, weights, values, capacity))
            
        self.memo[problem] = result
        return result

class EditDistanceDP(DynamicProgramming):
    """ç¼–è¾‘è·ç¦»åŠ¨æ€è§„åˆ’"""
    
    def _solve_recursive(self, problem: Tuple[str, str]) -> DPSolution:
        """é€’å½’è®¡ç®—ç¼–è¾‘è·ç¦»"""
        self.calls += 1
        s1, s2 = problem
        
        # åŸºç¡€æƒ…å†µ
        if not s1:
            return DPSolution(len(s2), ["insert"] * len(s2))
        if not s2:
            return DPSolution(len(s1), ["delete"] * len(s1))
            
        # æ£€æŸ¥è®°å¿†åŒ–
        if problem in self.memo:
            return self.memo[problem]
            
        # é€’å½’è®¡ç®—
        if s1[-1] == s2[-1]:
            # å­—ç¬¦ç›¸åŒï¼Œä¸éœ€è¦æ“ä½œ
            sub_solution = self._solve_recursive((s1[:-1], s2[:-1]))
            result = DPSolution(sub_solution.value, sub_solution.path + ["match"])
        else:
            # å­—ç¬¦ä¸åŒï¼Œéœ€è¦æ“ä½œ
            delete_solution = self._solve_recursive((s1[:-1], s2))
            insert_solution = self._solve_recursive((s1, s2[:-1]))
            replace_solution = self._solve_recursive((s1[:-1], s2[:-1]))
            
            min_cost = min(
                delete_solution.value + 1,
                insert_solution.value + 1,
                replace_solution.value + 1
            )
            
            if min_cost == delete_solution.value + 1:
                result = DPSolution(min_cost, delete_solution.path + ["delete"])
            elif min_cost == insert_solution.value + 1:
                result = DPSolution(min_cost, insert_solution.path + ["insert"])
            else:
                result = DPSolution(min_cost, replace_solution.path + ["replace"])
                
        self.memo[problem] = result
        return result
```

### 2.2 çŸ©é˜µé“¾ä¹˜æ³•

```python
class MatrixChainMultiplicationDP(DynamicProgramming):
    """çŸ©é˜µé“¾ä¹˜æ³•åŠ¨æ€è§„åˆ’"""
    
    def _solve_recursive(self, problem: Tuple[List[Tuple[int, int]], int, int]) -> DPSolution:
        """é€’å½’è®¡ç®—çŸ©é˜µé“¾ä¹˜æ³•"""
        self.calls += 1
        dimensions, i, j = problem
        
        # åŸºç¡€æƒ…å†µ
        if i == j:
            return DPSolution(0, [i])
            
        # æ£€æŸ¥è®°å¿†åŒ–
        if problem in self.memo:
            return self.memo[problem]
            
        # é€’å½’è®¡ç®—
        min_cost = float('inf')
        best_k = i
        
        for k in range(i, j):
            left_cost = self._solve_recursive((dimensions, i, k))
            right_cost = self._solve_recursive((dimensions, k+1, j))
            
            # è®¡ç®—å½“å‰åˆ†å‰²çš„æˆæœ¬
            current_cost = (
                left_cost.value + 
                right_cost.value + 
                dimensions[i][0] * dimensions[k][1] * dimensions[j][1]
            )
            
            if current_cost < min_cost:
                min_cost = current_cost
                best_k = k
                
        # æ„å»ºæœ€ä¼˜è§£è·¯å¾„
        left_solution = self._solve_recursive((dimensions, i, best_k))
        right_solution = self._solve_recursive((dimensions, best_k+1, j))
        
        result = DPSolution(min_cost, [i, j, best_k])
        self.memo[problem] = result
        
        return result
        
    def get_optimal_parenthesization(self, dimensions: List[Tuple[int, int]]) -> str:
        """è·å–æœ€ä¼˜æ‹¬å·åŒ–"""
        solution = self.solve((dimensions, 0, len(dimensions)-1))
        return self._build_parenthesization(dimensions, 0, len(dimensions)-1, solution)
        
    def _build_parenthesization(self, dimensions: List[Tuple[int, int]], i: int, j: int, solution: DPSolution) -> str:
        """æ„å»ºæ‹¬å·åŒ–å­—ç¬¦ä¸²"""
        if i == j:
            return f"A{i+1}"
            
        k = solution.path[2] if len(solution.path) > 2 else i
        
        left = self._build_parenthesization(dimensions, i, k, solution)
        right = self._build_parenthesization(dimensions, k+1, j, solution)
        
        return f"({left} Ã— {right})"
```

### 2.3 æœ€é•¿é€’å¢å­åºåˆ—

```python
class LongestIncreasingSubsequenceDP(DynamicProgramming):
    """æœ€é•¿é€’å¢å­åºåˆ—åŠ¨æ€è§„åˆ’"""
    
    def _solve_recursive(self, problem: Tuple[List[int], int, Optional[int]]) -> DPSolution:
        """é€’å½’è®¡ç®—æœ€é•¿é€’å¢å­åºåˆ—"""
        self.calls += 1
        sequence, index, prev_value = problem
        
        # åŸºç¡€æƒ…å†µ
        if index >= len(sequence):
            return DPSolution(0, [])
            
        # æ£€æŸ¥è®°å¿†åŒ–
        if problem in self.memo:
            return self.memo[problem]
            
        # é€’å½’è®¡ç®—
        current_value = sequence[index]
        
        # ä¸åŒ…å«å½“å‰å…ƒç´ 
        exclude_solution = self._solve_recursive((sequence, index + 1, prev_value))
        
        # åŒ…å«å½“å‰å…ƒç´ ï¼ˆå¦‚æœå¯èƒ½ï¼‰
        include_solution = None
        if prev_value is None or current_value > prev_value:
            sub_solution = self._solve_recursive((sequence, index + 1, current_value))
            include_solution = DPSolution(
                sub_solution.value + 1,
                [current_value] + sub_solution.path
            )
            
        # é€‰æ‹©æœ€ä¼˜è§£
        if include_solution and include_solution.value > exclude_solution.value:
            result = include_solution
        else:
            result = exclude_solution
            
        self.memo[problem] = result
        return result
        
    def solve_optimized(self, sequence: List[int]) -> DPSolution:
        """ä¼˜åŒ–çš„LISè§£æ³•"""
        if not sequence:
            return DPSolution(0, [])
            
        # ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–
        n = len(sequence)
        dp = [1] * n
        parent = [-1] * n
        
        for i in range(1, n):
            for j in range(i):
                if sequence[i] > sequence[j] and dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    parent[i] = j
                    
        # æ‰¾åˆ°æœ€é•¿åºåˆ—çš„ç»“æŸä½ç½®
        max_length = max(dp)
        end_index = dp.index(max_length)
        
        # é‡å»ºè·¯å¾„
        path = []
        current = end_index
        while current != -1:
            path.append(sequence[current])
            current = parent[current]
            
        return DPSolution(max_length, path[::-1])
```

### 2.4 ç¡¬å¸æ‰¾é›¶é—®é¢˜

```python
class CoinChangeDP(DynamicProgramming):
    """ç¡¬å¸æ‰¾é›¶åŠ¨æ€è§„åˆ’"""
    
    def _solve_recursive(self, problem: Tuple[List[int], int]) -> DPSolution:
        """é€’å½’è§£å†³ç¡¬å¸æ‰¾é›¶é—®é¢˜"""
        self.calls += 1
        coins, amount = problem
        
        # åŸºç¡€æƒ…å†µ
        if amount == 0:
            return DPSolution(0, [])
        if amount < 0:
            return DPSolution(float('inf'), [])
        if not coins:
            return DPSolution(float('inf'), [])
            
        # æ£€æŸ¥è®°å¿†åŒ–
        if problem in self.memo:
            return self.memo[problem]
            
        # é€’å½’è®¡ç®—
        min_coins = float('inf')
        best_combination = []
        
        for i, coin in enumerate(coins):
            if coin <= amount:
                sub_solution = self._solve_recursive((coins, amount - coin))
                
                if sub_solution.value != float('inf'):
                    total_coins = sub_solution.value + 1
                    if total_coins < min_coins:
                        min_coins = total_coins
                        best_combination = [coin] + sub_solution.path
                        
        result = DPSolution(min_coins, best_combination)
        self.memo[problem] = result
        return result
        
    def solve_unlimited_coins(self, coins: List[int], amount: int) -> DPSolution:
        """è§£å†³æ— é™ç¡¬å¸é—®é¢˜"""
        # ä½¿ç”¨è‡ªåº•å‘ä¸Šçš„æ–¹æ³•
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        parent = [-1] * (amount + 1)
        
        for i in range(1, amount + 1):
            for coin in coins:
                if coin <= i and dp[i - coin] + 1 < dp[i]:
                    dp[i] = dp[i - coin] + 1
                    parent[i] = coin
                    
        if dp[amount] == float('inf'):
            return DPSolution(float('inf'), [])
            
        # é‡å»ºè·¯å¾„
        path = []
        current = amount
        while current > 0:
            coin = parent[current]
            path.append(coin)
            current -= coin
            
        return DPSolution(dp[amount], path)
```

## 3. ç†è®ºè¯æ˜

### 3.1 åŠ¨æ€è§„åˆ’æœ€ä¼˜æ€§

**å®šç† 3.1** (åŠ¨æ€è§„åˆ’æœ€ä¼˜æ€§)
å¯¹äºå…·æœ‰æœ€ä¼˜å­ç»“æ„çš„é—®é¢˜ï¼ŒåŠ¨æ€è§„åˆ’ç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚

**è¯æ˜**:

1. æœ€ä¼˜å­ç»“æ„ç¡®ä¿å±€éƒ¨æœ€ä¼˜å¯¼è‡´å…¨å±€æœ€ä¼˜
2. è®°å¿†åŒ–é¿å…é‡å¤è®¡ç®—
3. è‡ªåº•å‘ä¸Šæˆ–è‡ªé¡¶å‘ä¸‹çš„æ–¹æ³•ç¡®ä¿æ‰€æœ‰å­é—®é¢˜éƒ½è¢«è§£å†³
4. å› æ­¤èƒ½å¤Ÿæ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£

### 3.2 æ—¶é—´å¤æ‚åº¦åˆ†æ

**å®šç† 3.2** (åŠ¨æ€è§„åˆ’æ—¶é—´å¤æ‚åº¦)
å¯¹äºçŠ¶æ€ç©ºé—´å¤§å°ä¸º $n$ çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

**è¯æ˜**:

1. æ¯ä¸ªçŠ¶æ€åªè®¡ç®—ä¸€æ¬¡
2. çŠ¶æ€è½¬ç§»æ—¶é—´ä¸ºå¸¸æ•°
3. æ€»æ—¶é—´å¤æ‚åº¦ä¸ºçŠ¶æ€æ•°é‡ä¹˜ä»¥è½¬ç§»æ—¶é—´
4. å› æ­¤ä¸º $O(n)$

## 4. æ€§èƒ½åˆ†æ

### 4.1 æ—¶é—´å¤æ‚åº¦

- æ–æ³¢é‚£å¥‘: $O(n)$ (ç›¸æ¯”é€’å½’çš„ $O(2^n)$)
- æœ€é•¿å…¬å…±å­åºåˆ—: $O(mn)$ (m, nä¸ºå­—ç¬¦ä¸²é•¿åº¦)
- èƒŒåŒ…é—®é¢˜: $O(nW)$ (nä¸ºç‰©å“æ•°ï¼ŒWä¸ºå®¹é‡)
- ç¼–è¾‘è·ç¦»: $O(mn)$

### 4.2 ç©ºé—´å¤æ‚åº¦

- è®°å¿†åŒ–: $O(n)$ (nä¸ºçŠ¶æ€æ•°)
- è‡ªåº•å‘ä¸Š: $O(n)$
- è·¯å¾„é‡å»º: $O(n)$

### 4.3 ä¼˜åŒ–æŠ€æœ¯

- è®°å¿†åŒ–æœç´¢
- çŠ¶æ€å‹ç¼©
- æ»šåŠ¨æ•°ç»„
- å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–

## 5. å®é™…åº”ç”¨

### 5.1 æ–‡æœ¬ç›¸ä¼¼åº¦è®¡ç®—

```python
class TextSimilarity:
    """æ–‡æœ¬ç›¸ä¼¼åº¦è®¡ç®—"""
    
    def __init__(self):
        self.lcs_dp = LongestCommonSubsequenceDP()
        self.edit_dp = EditDistanceDP()
        
    def calculate_similarity(self, text1: str, text2: str) -> float:
        """è®¡ç®—æ–‡æœ¬ç›¸ä¼¼åº¦"""
        # ä½¿ç”¨æœ€é•¿å…¬å…±å­åºåˆ—
        lcs_solution = self.lcs_dp.solve((text1, text2))
        lcs_length = lcs_solution.value
        
        # ä½¿ç”¨ç¼–è¾‘è·ç¦»
        edit_solution = self.edit_dp.solve((text1, text2))
        edit_distance = edit_solution.value
        
        # è®¡ç®—ç›¸ä¼¼åº¦
        max_length = max(len(text1), len(text2))
        lcs_similarity = lcs_length / max_length
        edit_similarity = 1 - (edit_distance / max_length)
        
        return (lcs_similarity + edit_similarity) / 2
        
    def find_common_patterns(self, texts: List[str]) -> List[str]:
        """æŸ¥æ‰¾å…±åŒæ¨¡å¼"""
        if not texts:
            return []
            
        # è®¡ç®—æ‰€æœ‰æ–‡æœ¬å¯¹çš„æœ€é•¿å…¬å…±å­åºåˆ—
        patterns = []
        for i in range(len(texts)):
            for j in range(i + 1, len(texts)):
                solution = self.lcs_dp.solve((texts[i], texts[j]))
                if solution.value > 0:
                    patterns.append(''.join(solution.path))
                    
        return list(set(patterns))
```

### 5.2 æŠ•èµ„ç»„åˆä¼˜åŒ–

```python
class PortfolioOptimization:
    """æŠ•èµ„ç»„åˆä¼˜åŒ–"""
    
    def __init__(self):
        self.knapsack_dp = KnapsackDP()
        
    def optimize_portfolio(self, investments: List[Dict[str, Any]], budget: float) -> List[int]:
        """ä¼˜åŒ–æŠ•èµ„ç»„åˆ"""
        # æå–æƒé‡å’Œä»·å€¼
        weights = [inv['weight'] for inv in investments]
        values = [inv['expected_return'] for inv in investments]
        
        # è½¬æ¢ä¸ºæ•´æ•°ï¼ˆä¹˜ä»¥1000é¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼‰
        weights = [int(w * 1000) for w in weights]
        budget = int(budget * 1000)
        
        # ä½¿ç”¨èƒŒåŒ…ç®—æ³•
        solution = self.knapsack_dp.solve((len(investments), weights, values, budget))
        
        return solution.path
        
    def calculate_risk_adjusted_return(self, portfolio: List[int], investments: List[Dict[str, Any]]) -> float:
        """è®¡ç®—é£é™©è°ƒæ•´åæ”¶ç›Š"""
        total_return = 0
        total_risk = 0
        
        for i in portfolio:
            total_return += investments[i]['expected_return']
            total_risk += investments[i]['risk']
            
        if total_risk == 0:
            return total_return
            
        return total_return / total_risk
```

### 5.3 è·¯å¾„è§„åˆ’

```python
class PathPlanning:
    """è·¯å¾„è§„åˆ’"""
    
    def __init__(self):
        self.memo = {}
        
    def find_shortest_path(self, grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:
        """å¯»æ‰¾æœ€çŸ­è·¯å¾„"""
        def dp(i: int, j: int) -> Tuple[float, List[Tuple[int, int]]]:
            if (i, j) == end:
                return 0, [end]
                
            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1:
                return float('inf'), []
                
            if (i, j) in self.memo:
                return self.memo[(i, j)]
                
            # å››ä¸ªæ–¹å‘
            directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
            min_cost = float('inf')
            best_path = []
            
            for di, dj in directions:
                ni, nj = i + di, j + dj
                cost, path = dp(ni, nj)
                
                if cost + 1 < min_cost:
                    min_cost = cost + 1
                    best_path = [(i, j)] + path
                    
            self.memo[(i, j)] = (min_cost, best_path)
            return min_cost, best_path
            
        cost, path = dp(start[0], start[1])
        return path if cost != float('inf') else []
```

## 6. æ€»ç»“

åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç§å¼ºå¤§çš„ç®—æ³•è®¾è®¡æ–¹æ³•ï¼Œé€šè¿‡å°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜å¹¶é¿å…é‡å¤è®¡ç®—ï¼Œèƒ½å¤Ÿé«˜æ•ˆè§£å†³è®¸å¤šä¼˜åŒ–é—®é¢˜ã€‚

### å…³é”®è¦ç‚¹

1. **æœ€ä¼˜å­ç»“æ„**: é—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«å­é—®é¢˜çš„æœ€ä¼˜è§£
2. **é‡å å­é—®é¢˜**: å­é—®é¢˜è¢«é‡å¤è®¡ç®—
3. **è®°å¿†åŒ–**: å­˜å‚¨å­é—®é¢˜çš„è§£é¿å…é‡å¤è®¡ç®—
4. **çŠ¶æ€è½¬ç§»**: å®šä¹‰çŠ¶æ€ä¹‹é—´çš„è½¬ç§»å…³ç³»

### åº”ç”¨åœºæ™¯

- æ–‡æœ¬å¤„ç†å’Œè‡ªç„¶è¯­è¨€å¤„ç†
- æŠ•èµ„ç»„åˆä¼˜åŒ–
- è·¯å¾„è§„åˆ’å’Œå¯¼èˆª
- ç”Ÿç‰©ä¿¡æ¯å­¦
- æ¸¸æˆAI

---

**ç›¸å…³æ–‡æ¡£**:

- [æ’åºç®—æ³•](./06-01-01-æ’åºç®—æ³•.md)
- [æœç´¢ç®—æ³•](./06-01-02-æœç´¢ç®—æ³•.md)
- [å›¾ç®—æ³•](./06-01-03-å›¾ç®—æ³•.md)
