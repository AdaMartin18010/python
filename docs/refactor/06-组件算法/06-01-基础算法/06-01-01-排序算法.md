# æ’åºç®—æ³•

## ğŸ“š æ¦‚è¿°

æ’åºç®—æ³•æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€åŸºç¡€å’Œæœ€é‡è¦çš„ç®—æ³•ä¹‹ä¸€ï¼Œç ”ç©¶å¦‚ä½•å°†æ•°æ®åºåˆ—æŒ‰ç…§ç‰¹å®šè§„åˆ™é‡æ–°æ’åˆ—ã€‚æœ¬æ–‡æ¡£ä»ç»„ä»¶ç®—æ³•çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»æ’åºç®—æ³•çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æ’åºé—®é¢˜çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 æ’åºçš„æ•°å­¦å®šä¹‰

ç»™å®šä¸€ä¸ªåºåˆ— $S = [s_1, s_2, \ldots, s_n]$ å’Œæ¯”è¾ƒå‡½æ•° $f: S \times S \rightarrow \{-1, 0, 1\}$ï¼Œæ’åºé—®é¢˜æ˜¯æ‰¾åˆ°ä¸€ä¸ªæ’åˆ— $\pi$ ä½¿å¾—ï¼š

$$f(s_{\pi(i)}, s_{\pi(i+1)}) \leq 0, \quad \forall i \in \{1, 2, \ldots, n-1\}$$

å…¶ä¸­ $f(a, b) = -1$ è¡¨ç¤º $a < b$ï¼Œ$f(a, b) = 0$ è¡¨ç¤º $a = b$ï¼Œ$f(a, b) = 1$ è¡¨ç¤º $a > b$ã€‚

#### 1.2 æ’åºç®—æ³•çš„Pythonå®ç°

```python
from typing import List, Callable, Any, Tuple, Optional
from abc import ABC, abstractmethod
import random
import time
from dataclasses import dataclass
from enum import Enum

class SortOrder(Enum):
    """æ’åºé¡ºåº"""
    ASCENDING = "ascending"
    DESCENDING = "descending"

@dataclass
class SortResult:
    """æ’åºç»“æœ"""
    sorted_array: List[Any]
    comparisons: int
    swaps: int
    execution_time: float
    is_stable: bool

class SortingAlgorithm(ABC):
    """æŠ½è±¡æ’åºç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.comparisons = 0
        self.swaps = 0
    
    @abstractmethod
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        """æ’åºæ–¹æ³•"""
        pass
    
    def sort_with_metrics(self, arr: List[Any],
                         key: Optional[Callable[[Any], Any]] = None,
                         reverse: bool = False) -> SortResult:
        """å¸¦æŒ‡æ ‡çš„æ’åº"""
        start_time = time.time()
        
        self.comparisons = 0
        self.swaps = 0
        
        sorted_arr = self.sort(arr.copy(), key, reverse)
        
        end_time = time.time()
        
        return SortResult(
            sorted_array=sorted_arr,
            comparisons=self.comparisons,
            swaps=self.swaps,
            execution_time=end_time - start_time,
            is_stable=self._is_stable()
        )
    
    def compare(self, a: Any, b: Any, key: Optional[Callable[[Any], Any]] = None) -> int:
        """æ¯”è¾ƒä¸¤ä¸ªå…ƒç´ """
        self.comparisons += 1
        
        if key:
            a_val = key(a)
            b_val = key(b)
        else:
            a_val = a
            b_val = b
        
        if a_val < b_val:
            return -1
        elif a_val > b_val:
            return 1
        else:
            return 0
    
    def swap(self, arr: List[Any], i: int, j: int):
        """äº¤æ¢æ•°ç»„ä¸­çš„ä¸¤ä¸ªå…ƒç´ """
        if i != j:
            arr[i], arr[j] = arr[j], arr[i]
            self.swaps += 1
    
    @abstractmethod
    def _is_stable(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç¨³å®šæ’åº"""
        pass

class BubbleSort(SortingAlgorithm):
    """å†’æ³¡æ’åº"""
    
    def __init__(self):
        super().__init__("Bubble Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        n = len(arr)
        
        for i in range(n):
            swapped = False
            for j in range(0, n - i - 1):
                comparison = self.compare(arr[j], arr[j + 1], key)
                if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                    self.swap(arr, j, j + 1)
                    swapped = True
            
            if not swapped:
                break
        
        return arr
    
    def _is_stable(self) -> bool:
        return True

class SelectionSort(SortingAlgorithm):
    """é€‰æ‹©æ’åº"""
    
    def __init__(self):
        super().__init__("Selection Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        n = len(arr)
        
        for i in range(n):
            min_idx = i
            for j in range(i + 1, n):
                comparison = self.compare(arr[j], arr[min_idx], key)
                if (comparison < 0 and not reverse) or (comparison > 0 and reverse):
                    min_idx = j
            
            if min_idx != i:
                self.swap(arr, i, min_idx)
        
        return arr
    
    def _is_stable(self) -> bool:
        return False

class InsertionSort(SortingAlgorithm):
    """æ’å…¥æ’åº"""
    
    def __init__(self):
        super().__init__("Insertion Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        for i in range(1, len(arr)):
            key_val = arr[i]
            j = i - 1
            
            while j >= 0:
                comparison = self.compare(arr[j], key_val, key)
                if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                    arr[j + 1] = arr[j]
                    j -= 1
                else:
                    break
            
            arr[j + 1] = key_val
        
        return arr
    
    def _is_stable(self) -> bool:
        return True

# ä½¿ç”¨ç¤ºä¾‹
bubble_sort = BubbleSort()
selection_sort = SelectionSort()
insertion_sort = InsertionSort()

test_array = [64, 34, 25, 12, 22, 11, 90]

bubble_result = bubble_sort.sort_with_metrics(test_array)
selection_result = selection_sort.sort_with_metrics(test_array)
insertion_result = insertion_sort.sort_with_metrics(test_array)

print(f"å†’æ³¡æ’åº: {bubble_result.sorted_array}")
print(f"æ¯”è¾ƒæ¬¡æ•°: {bubble_result.comparisons}, äº¤æ¢æ¬¡æ•°: {bubble_result.swaps}")
print(f"é€‰æ‹©æ’åº: {selection_result.sorted_array}")
print(f"æ¯”è¾ƒæ¬¡æ•°: {selection_result.comparisons}, äº¤æ¢æ¬¡æ•°: {selection_result.swaps}")
print(f"æ’å…¥æ’åº: {insertion_result.sorted_array}")
print(f"æ¯”è¾ƒæ¬¡æ•°: {insertion_result.comparisons}, äº¤æ¢æ¬¡æ•°: {insertion_result.swaps}")
```

### 2. é«˜çº§æ’åºç®—æ³•

#### 2.1 å½’å¹¶æ’åº

```python
class MergeSort(SortingAlgorithm):
    """å½’å¹¶æ’åº"""
    
    def __init__(self):
        super().__init__("Merge Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = self.sort(arr[:mid], key, reverse)
        right = self.sort(arr[mid:], key, reverse)
        
        return self._merge(left, right, key, reverse)
    
    def _merge(self, left: List[Any], right: List[Any],
               key: Optional[Callable[[Any], Any]] = None,
               reverse: bool = False) -> List[Any]:
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            comparison = self.compare(left[i], right[j], key)
            if (comparison <= 0 and not reverse) or (comparison >= 0 and reverse):
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    def _is_stable(self) -> bool:
        return True

class QuickSort(SortingAlgorithm):
    """å¿«é€Ÿæ’åº"""
    
    def __init__(self):
        super().__init__("Quick Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        if len(arr) <= 1:
            return arr
        
        pivot = self._choose_pivot(arr)
        left, middle, right = self._partition(arr, pivot, key, reverse)
        
        return (self.sort(left, key, reverse) + 
                middle + 
                self.sort(right, key, reverse))
    
    def _choose_pivot(self, arr: List[Any]) -> Any:
        """é€‰æ‹©è½´å¿ƒå…ƒç´ """
        # ä¸‰æ•°å–ä¸­æ³•
        n = len(arr)
        if n <= 2:
            return arr[0]
        
        first, mid, last = arr[0], arr[n // 2], arr[n - 1]
        
        if first <= mid <= last or last <= mid <= first:
            return mid
        elif mid <= first <= last or last <= first <= mid:
            return first
        else:
            return last
    
    def _partition(self, arr: List[Any], pivot: Any,
                   key: Optional[Callable[[Any], Any]] = None,
                   reverse: bool = False) -> Tuple[List[Any], List[Any], List[Any]]:
        """åˆ†åŒº"""
        left, middle, right = [], [], []
        
        for element in arr:
            comparison = self.compare(element, pivot, key)
            if comparison < 0 and not reverse or comparison > 0 and reverse:
                left.append(element)
            elif comparison == 0:
                middle.append(element)
            else:
                right.append(element)
        
        return left, middle, right
    
    def _is_stable(self) -> bool:
        return False

class HeapSort(SortingAlgorithm):
    """å †æ’åº"""
    
    def __init__(self):
        super().__init__("Heap Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        n = len(arr)
        
        # æ„å»ºæœ€å¤§å †
        for i in range(n // 2 - 1, -1, -1):
            self._heapify(arr, n, i, key, reverse)
        
        # é€ä¸ªæå–å…ƒç´ 
        for i in range(n - 1, 0, -1):
            self.swap(arr, 0, i)
            self._heapify(arr, i, 0, key, reverse)
        
        return arr
    
    def _heapify(self, arr: List[Any], n: int, i: int,
                 key: Optional[Callable[[Any], Any]] = None,
                 reverse: bool = False):
        """å †åŒ–"""
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n:
            comparison = self.compare(arr[left], arr[largest], key)
            if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                largest = left
        
        if right < n:
            comparison = self.compare(arr[right], arr[largest], key)
            if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                largest = right
        
        if largest != i:
            self.swap(arr, i, largest)
            self._heapify(arr, n, largest, key, reverse)
    
    def _is_stable(self) -> bool:
        return False

# ä½¿ç”¨ç¤ºä¾‹
merge_sort = MergeSort()
quick_sort = QuickSort()
heap_sort = HeapSort()

test_array = [64, 34, 25, 12, 22, 11, 90]

merge_result = merge_sort.sort_with_metrics(test_array)
quick_result = quick_sort.sort_with_metrics(test_array)
heap_result = heap_sort.sort_with_metrics(test_array)

print(f"å½’å¹¶æ’åº: {merge_result.sorted_array}")
print(f"æ‰§è¡Œæ—¶é—´: {merge_result.execution_time:.6f}s")
print(f"å¿«é€Ÿæ’åº: {quick_result.sorted_array}")
print(f"æ‰§è¡Œæ—¶é—´: {quick_result.execution_time:.6f}s")
print(f"å †æ’åº: {heap_result.sorted_array}")
print(f"æ‰§è¡Œæ—¶é—´: {heap_result.execution_time:.6f}s")
```

### 3. çº¿æ€§æ—¶é—´æ’åºç®—æ³•

#### 3.1 è®¡æ•°æ’åº

```python
class CountingSort(SortingAlgorithm):
    """è®¡æ•°æ’åº"""
    
    def __init__(self):
        super().__init__("Counting Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        if not arr:
            return arr
        
        # ç¡®å®šé”®å€¼èŒƒå›´
        if key:
            key_values = [key(x) for x in arr]
        else:
            key_values = arr
        
        min_val = min(key_values)
        max_val = max(key_values)
        range_size = max_val - min_val + 1
        
        # è®¡æ•°
        count = [0] * range_size
        for val in key_values:
            count[val - min_val] += 1
        
        # è®¡ç®—ä½ç½®
        for i in range(1, range_size):
            count[i] += count[i - 1]
        
        # æ„å»ºç»“æœ
        result = [None] * len(arr)
        for i in range(len(arr) - 1, -1, -1):
            val = key_values[i]
            pos = count[val - min_val] - 1
            result[pos] = arr[i]
            count[val - min_val] -= 1
        
        if reverse:
            result.reverse()
        
        return result
    
    def _is_stable(self) -> bool:
        return True

class RadixSort(SortingAlgorithm):
    """åŸºæ•°æ’åº"""
    
    def __init__(self):
        super().__init__("Radix Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        if not arr:
            return arr
        
        # ç¡®å®šæœ€å¤§ä½æ•°
        if key:
            max_val = max(key(x) for x in arr)
        else:
            max_val = max(arr)
        
        max_digits = len(str(abs(max_val)))
        
        # æŒ‰ä½æ’åº
        result = arr.copy()
        for digit in range(max_digits):
            result = self._counting_sort_by_digit(result, digit, key)
        
        if reverse:
            result.reverse()
        
        return result
    
    def _counting_sort_by_digit(self, arr: List[Any], digit: int,
                               key: Optional[Callable[[Any], Any]] = None) -> List[Any]:
        """æŒ‰æŒ‡å®šä½æ•°è¿›è¡Œè®¡æ•°æ’åº"""
        count = [0] * 10
        result = [None] * len(arr)
        
        # è®¡æ•°
        for element in arr:
            val = key(element) if key else element
            digit_val = (val // (10 ** digit)) % 10
            count[digit_val] += 1
        
        # è®¡ç®—ä½ç½®
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # æ„å»ºç»“æœ
        for i in range(len(arr) - 1, -1, -1):
            val = key(arr[i]) if key else arr[i]
            digit_val = (val // (10 ** digit)) % 10
            pos = count[digit_val] - 1
            result[pos] = arr[i]
            count[digit_val] -= 1
        
        return result
    
    def _is_stable(self) -> bool:
        return True

class BucketSort(SortingAlgorithm):
    """æ¡¶æ’åº"""
    
    def __init__(self):
        super().__init__("Bucket Sort")
    
    def sort(self, arr: List[Any], 
             key: Optional[Callable[[Any], Any]] = None,
             reverse: bool = False) -> List[Any]:
        if not arr:
            return arr
        
        # ç¡®å®šèŒƒå›´
        if key:
            key_values = [key(x) for x in arr]
        else:
            key_values = arr
        
        min_val = min(key_values)
        max_val = max(key_values)
        
        # åˆ›å»ºæ¡¶
        bucket_count = len(arr)
        buckets = [[] for _ in range(bucket_count)]
        
        # åˆ†é…å…ƒç´ åˆ°æ¡¶
        for element in arr:
            val = key(element) if key else element
            bucket_index = int((val - min_val) / (max_val - min_val) * (bucket_count - 1))
            buckets[bucket_index].append(element)
        
        # å¯¹æ¯ä¸ªæ¡¶æ’åº
        insertion_sort = InsertionSort()
        result = []
        for bucket in buckets:
            if bucket:
                sorted_bucket = insertion_sort.sort(bucket, key)
                result.extend(sorted_bucket)
        
        if reverse:
            result.reverse()
        
        return result
    
    def _is_stable(self) -> bool:
        return True

# ä½¿ç”¨ç¤ºä¾‹
counting_sort = CountingSort()
radix_sort = RadixSort()
bucket_sort = BucketSort()

# æ•´æ•°æ•°ç»„
int_array = [170, 45, 75, 90, 802, 24, 2, 66]

counting_result = counting_sort.sort_with_metrics(int_array)
radix_result = radix_sort.sort_with_metrics(int_array)
bucket_result = bucket_sort.sort_with_metrics(int_array)

print(f"è®¡æ•°æ’åº: {counting_result.sorted_array}")
print(f"åŸºæ•°æ’åº: {radix_result.sorted_array}")
print(f"æ¡¶æ’åº: {bucket_result.sorted_array}")
```

### 4. æ’åºç®—æ³•åˆ†æ

#### 4.1 å¤æ‚åº¦åˆ†æ

```python
class SortingAnalyzer:
    """æ’åºç®—æ³•åˆ†æå™¨"""
    
    def __init__(self):
        self.algorithms = {}
    
    def register_algorithm(self, algorithm: SortingAlgorithm):
        """æ³¨å†Œç®—æ³•"""
        self.algorithms[algorithm.name] = algorithm
    
    def benchmark_algorithms(self, test_cases: List[List[Any]]) -> Dict[str, Dict[str, float]]:
        """åŸºå‡†æµ‹è¯•"""
        results = {}
        
        for name, algorithm in self.algorithms.items():
            results[name] = {
                'total_time': 0.0,
                'total_comparisons': 0,
                'total_swaps': 0,
                'average_time': 0.0,
                'average_comparisons': 0.0,
                'average_swaps': 0.0
            }
            
            for test_case in test_cases:
                result = algorithm.sort_with_metrics(test_case)
                results[name]['total_time'] += result.execution_time
                results[name]['total_comparisons'] += result.comparisons
                results[name]['total_swaps'] += result.swaps
            
            n = len(test_cases)
            results[name]['average_time'] = results[name]['total_time'] / n
            results[name]['average_comparisons'] = results[name]['total_comparisons'] / n
            results[name]['average_swaps'] = results[name]['total_swaps'] / n
        
        return results
    
    def analyze_complexity(self, algorithm_name: str, 
                          input_sizes: List[int]) -> Dict[str, List[float]]:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        algorithm = self.algorithms[algorithm_name]
        
        execution_times = []
        comparison_counts = []
        swap_counts = []
        
        for size in input_sizes:
            # ç”Ÿæˆéšæœºæµ‹è¯•æ•°æ®
            test_data = [random.randint(1, 1000) for _ in range(size)]
            
            result = algorithm.sort_with_metrics(test_data)
            execution_times.append(result.execution_time)
            comparison_counts.append(result.comparisons)
            swap_counts.append(result.swaps)
        
        return {
            'input_sizes': input_sizes,
            'execution_times': execution_times,
            'comparison_counts': comparison_counts,
            'swap_counts': swap_counts
        }
    
    def estimate_complexity(self, input_sizes: List[int], 
                           operation_counts: List[int]) -> str:
        """ä¼°è®¡ç®—æ³•å¤æ‚åº¦"""
        if len(input_sizes) < 2:
            return "Insufficient data"
        
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(input_sizes)):
            size_ratio = input_sizes[i] / input_sizes[i-1]
            count_ratio = operation_counts[i] / operation_counts[i-1]
            growth_rates.append(count_ratio / size_ratio)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        if avg_growth < 1.1:
            return "O(1)"
        elif avg_growth < 1.5:
            return "O(log n)"
        elif avg_growth < 2.5:
            return "O(n)"
        elif avg_growth < 4:
            return "O(n log n)"
        elif avg_growth < 8:
            return "O(nÂ²)"
        else:
            return "O(n^k) where k > 2"

# ä½¿ç”¨ç¤ºä¾‹
analyzer = SortingAnalyzer()

# æ³¨å†Œç®—æ³•
analyzer.register_algorithm(BubbleSort())
analyzer.register_algorithm(InsertionSort())
analyzer.register_algorithm(MergeSort())
analyzer.register_algorithm(QuickSort())
analyzer.register_algorithm(HeapSort())

# ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
test_cases = [
    [random.randint(1, 100) for _ in range(100)] for _ in range(10)
]

# åŸºå‡†æµ‹è¯•
benchmark_results = analyzer.benchmark_algorithms(test_cases)

print("ç®—æ³•åŸºå‡†æµ‹è¯•ç»“æœ:")
for name, metrics in benchmark_results.items():
    print(f"{name}:")
    print(f"  å¹³å‡æ‰§è¡Œæ—¶é—´: {metrics['average_time']:.6f}s")
    print(f"  å¹³å‡æ¯”è¾ƒæ¬¡æ•°: {metrics['average_comparisons']:.0f}")
    print(f"  å¹³å‡äº¤æ¢æ¬¡æ•°: {metrics['average_swaps']:.0f}")

# å¤æ‚åº¦åˆ†æ
input_sizes = [100, 500, 1000, 2000, 5000]
complexity_results = analyzer.analyze_complexity("Quick Sort", input_sizes)

estimated_complexity = analyzer.estimate_complexity(
    complexity_results['input_sizes'],
    complexity_results['comparison_counts']
)
print(f"å¿«é€Ÿæ’åºä¼°è®¡å¤æ‚åº¦: {estimated_complexity}")
```

#### 4.2 ç¨³å®šæ€§åˆ†æ

```python
class StabilityAnalyzer:
    """ç¨³å®šæ€§åˆ†æå™¨"""
    
    def __init__(self):
        self.algorithms = {}
    
    def register_algorithm(self, algorithm: SortingAlgorithm):
        """æ³¨å†Œç®—æ³•"""
        self.algorithms[algorithm.name] = algorithm
    
    def test_stability(self, algorithm_name: str) -> bool:
        """æµ‹è¯•ç®—æ³•ç¨³å®šæ€§"""
        algorithm = self.algorithms[algorithm_name]
        
        # åˆ›å»ºåŒ…å«é‡å¤é”®çš„æµ‹è¯•æ•°æ®
        test_data = [
            (1, 'a'), (2, 'b'), (1, 'c'), (3, 'd'), (2, 'e')
        ]
        
        # æŒ‰ç¬¬ä¸€ä¸ªå…ƒç´ æ’åº
        sorted_data = algorithm.sort(test_data, key=lambda x: x[0])
        
        # æ£€æŸ¥ç¨³å®šæ€§
        for i in range(len(sorted_data) - 1):
            if sorted_data[i][0] == sorted_data[i + 1][0]:
                # æ£€æŸ¥åŸå§‹é¡ºåºæ˜¯å¦ä¿æŒ
                original_pos1 = test_data.index(sorted_data[i])
                original_pos2 = test_data.index(sorted_data[i + 1])
                if original_pos1 > original_pos2:
                    return False
        
        return True
    
    def compare_stability(self) -> Dict[str, bool]:
        """æ¯”è¾ƒæ‰€æœ‰ç®—æ³•çš„ç¨³å®šæ€§"""
        stability_results = {}
        
        for name in self.algorithms:
            stability_results[name] = self.test_stability(name)
        
        return stability_results

# ä½¿ç”¨ç¤ºä¾‹
stability_analyzer = StabilityAnalyzer()

# æ³¨å†Œç®—æ³•
stability_analyzer.register_algorithm(BubbleSort())
stability_analyzer.register_algorithm(InsertionSort())
stability_analyzer.register_algorithm(MergeSort())
stability_analyzer.register_algorithm(QuickSort())
stability_analyzer.register_algorithm(HeapSort())

# æµ‹è¯•ç¨³å®šæ€§
stability_results = stability_analyzer.compare_stability()

print("ç®—æ³•ç¨³å®šæ€§æµ‹è¯•ç»“æœ:")
for name, is_stable in stability_results.items():
    print(f"{name}: {'ç¨³å®š' if is_stable else 'ä¸ç¨³å®š'}")
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. å½’å¹¶æ’åºå¤æ‚åº¦å®šç†

**å®šç†**: å½’å¹¶æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ã€‚

**è¯æ˜**: å½’å¹¶æ’åºçš„é€’å½’å…³ç³»ä¸º $T(n) = 2T(n/2) + O(n)$ã€‚æ ¹æ®ä¸»å®šç†ï¼Œ$a = 2$ï¼Œ$b = 2$ï¼Œ$f(n) = O(n)$ã€‚ç”±äº $f(n) = \Theta(n^{\log_2 2}) = \Theta(n)$ï¼Œæ‰€ä»¥ $T(n) = \Theta(n \log n)$ã€‚

### 2. å¿«é€Ÿæ’åºå¹³å‡å¤æ‚åº¦å®šç†

**å®šç†**: å¿«é€Ÿæ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ã€‚

**è¯æ˜**: è®¾ $T(n)$ ä¸ºå¿«é€Ÿæ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ã€‚å¯¹äºéšæœºé€‰æ‹©çš„è½´å¿ƒï¼ŒæœŸæœ›çš„åˆ†åŒºæ¯”ä¾‹ä¸º $1:1$ï¼Œå› æ­¤ï¼š

$$T(n) = T(n/2) + T(n/2) + O(n) = 2T(n/2) + O(n)$$

æ ¹æ®ä¸»å®šç†ï¼Œ$T(n) = O(n \log n)$ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. å¤§è§„æ¨¡æ•°æ®æ’åº

```python
class LargeDataSorter:
    """å¤§è§„æ¨¡æ•°æ®æ’åºå™¨"""
    
    def __init__(self, chunk_size: int = 10000):
        self.chunk_size = chunk_size
    
    def external_sort(self, input_file: str, output_file: str,
                     algorithm: SortingAlgorithm) -> None:
        """å¤–éƒ¨æ’åº"""
        # ç¬¬ä¸€æ­¥ï¼šåˆ†å—æ’åº
        temp_files = self._split_and_sort(input_file, algorithm)
        
        # ç¬¬äºŒæ­¥ï¼šå¤šè·¯å½’å¹¶
        self._merge_files(temp_files, output_file)
        
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        for temp_file in temp_files:
            import os
            os.remove(temp_file)
    
    def _split_and_sort(self, input_file: str, 
                        algorithm: SortingAlgorithm) -> List[str]:
        """åˆ†å‰²å¹¶æ’åº"""
        temp_files = []
        chunk_num = 0
        
        with open(input_file, 'r') as f:
            while True:
                chunk = []
                for _ in range(self.chunk_size):
                    line = f.readline()
                    if not line:
                        break
                    chunk.append(int(line.strip()))
                
                if not chunk:
                    break
                
                # æ’åºå½“å‰å—
                sorted_chunk = algorithm.sort(chunk)
                
                # å†™å…¥ä¸´æ—¶æ–‡ä»¶
                temp_file = f"temp_{chunk_num}.txt"
                with open(temp_file, 'w') as tf:
                    for num in sorted_chunk:
                        tf.write(f"{num}\n")
                
                temp_files.append(temp_file)
                chunk_num += 1
        
        return temp_files
    
    def _merge_files(self, temp_files: List[str], output_file: str):
        """å¤šè·¯å½’å¹¶"""
        import heapq
        
        # æ‰“å¼€æ‰€æœ‰ä¸´æ—¶æ–‡ä»¶
        file_handles = []
        heap = []
        
        for i, temp_file in enumerate(temp_files):
            fh = open(temp_file, 'r')
            file_handles.append(fh)
            
            # è¯»å–ç¬¬ä¸€ä¸ªæ•°å­—
            line = fh.readline()
            if line:
                heapq.heappush(heap, (int(line.strip()), i))
        
        # å½’å¹¶å†™å…¥è¾“å‡ºæ–‡ä»¶
        with open(output_file, 'w') as out_f:
            while heap:
                num, file_index = heapq.heappop(heap)
                out_f.write(f"{num}\n")
                
                # è¯»å–ä¸‹ä¸€ä¸ªæ•°å­—
                line = file_handles[file_index].readline()
                if line:
                    heapq.heappush(heap, (int(line.strip()), file_index))
        
        # å…³é—­æ–‡ä»¶å¥æŸ„
        for fh in file_handles:
            fh.close()

# ä½¿ç”¨ç¤ºä¾‹
# ç”Ÿæˆæµ‹è¯•æ–‡ä»¶
def generate_test_file(filename: str, size: int):
    with open(filename, 'w') as f:
        for _ in range(size):
            f.write(f"{random.randint(1, 1000000)}\n")

# ç”Ÿæˆæµ‹è¯•æ•°æ®
generate_test_file("large_data.txt", 100000)

# æ‰§è¡Œå¤–éƒ¨æ’åº
large_sorter = LargeDataSorter(chunk_size=1000)
large_sorter.external_sort("large_data.txt", "sorted_data.txt", MergeSort())

print("å¤§è§„æ¨¡æ•°æ®æ’åºå®Œæˆ")
```

### 2. è‡ªå®šä¹‰å¯¹è±¡æ’åº

```python
@dataclass
class Student:
    """å­¦ç”Ÿç±»"""
    name: str
    age: int
    grade: float
    id: int

class CustomObjectSorter:
    """è‡ªå®šä¹‰å¯¹è±¡æ’åºå™¨"""
    
    def __init__(self):
        self.algorithms = {
            'bubble': BubbleSort(),
            'insertion': InsertionSort(),
            'merge': MergeSort(),
            'quick': QuickSort()
        }
    
    def sort_students(self, students: List[Student], 
                     sort_by: str = 'grade',
                     reverse: bool = False) -> List[Student]:
        """æ’åºå­¦ç”Ÿåˆ—è¡¨"""
        algorithm = self.algorithms['merge']  # ä½¿ç”¨å½’å¹¶æ’åºä¿è¯ç¨³å®šæ€§
        
        if sort_by == 'name':
            key_func = lambda s: s.name
        elif sort_by == 'age':
            key_func = lambda s: s.age
        elif sort_by == 'grade':
            key_func = lambda s: s.grade
        elif sort_by == 'id':
            key_func = lambda s: s.id
        else:
            raise ValueError(f"Unknown sort field: {sort_by}")
        
        return algorithm.sort(students, key=key_func, reverse=reverse)
    
    def multi_field_sort(self, students: List[Student]) -> List[Student]:
        """å¤šå­—æ®µæ’åº"""
        # å…ˆæŒ‰å¹´çº§æ’åºï¼Œå†æŒ‰å¹´é¾„æ’åº
        algorithm = self.algorithms['merge']
        
        # ä½¿ç”¨å¤åˆé”®
        def composite_key(student: Student) -> Tuple[float, int]:
            return (student.grade, student.age)
        
        return algorithm.sort(students, key=composite_key, reverse=True)

# ä½¿ç”¨ç¤ºä¾‹
students = [
    Student("Alice", 20, 85.5, 1001),
    Student("Bob", 19, 92.0, 1002),
    Student("Charlie", 21, 78.5, 1003),
    Student("David", 20, 85.5, 1004),
    Student("Eve", 19, 88.0, 1005)
]

sorter = CustomObjectSorter()

# æŒ‰æˆç»©æ’åº
sorted_by_grade = sorter.sort_students(students, 'grade', reverse=True)
print("æŒ‰æˆç»©æ’åº:")
for student in sorted_by_grade:
    print(f"{student.name}: {student.grade}")

# å¤šå­—æ®µæ’åº
multi_sorted = sorter.multi_field_sort(students)
print("\nå¤šå­—æ®µæ’åº (æˆç»©é™åºï¼Œå¹´é¾„å‡åº):")
for student in multi_sorted:
    print(f"{student.name}: æˆç»©={student.grade}, å¹´é¾„={student.age}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [åŸºç¡€ç®—æ³•æ¦‚è¿°](../README.md)
- [æœç´¢ç®—æ³•](06-01-02-æœç´¢ç®—æ³•.md)
- [å›¾ç®—æ³•](06-01-03-å›¾ç®—æ³•.md)
- [ç†è®ºåŸºç¡€](../02-ç†è®ºåŸºç¡€/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Knuth, D. E. (1998). The Art of Computer Programming, Volume 3: Sorting and Searching. Addison-Wesley.
2. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms. MIT Press.
3. Sedgewick, R. (2002). Algorithms in C++. Addison-Wesley.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
