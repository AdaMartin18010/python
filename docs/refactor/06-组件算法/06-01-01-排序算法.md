# æ’åºç®—æ³•

## ğŸ“‹ æ¦‚è¿°

æ’åºç®—æ³•æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€åŸºç¡€å’Œé‡è¦çš„ç®—æ³•ä¹‹ä¸€ï¼Œç”¨äºå°†ä¸€ç»„æ•°æ®æŒ‰ç…§ç‰¹å®šé¡ºåºé‡æ–°æ’åˆ—ã€‚æœ¬æ–‡æ¡£æä¾›æ’åºç®—æ³•çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œæ€§èƒ½åˆ†æã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æ’åºç®—æ³•å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**æ’åºé—®é¢˜**:
ç»™å®šä¸€ä¸ªåºåˆ— $A = [a_1, a_2, ..., a_n]$ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ’åˆ— $\pi$ ä½¿å¾—ï¼š
$$A[\pi(1)] \leq A[\pi(2)] \leq ... \leq A[\pi(n)]$$

**æ’åºç®—æ³•å››å…ƒç»„**:
$$\mathcal{SA} = (I, O, C, T)$$

å…¶ä¸­ï¼š

- $I = \{A | A \text{ æ˜¯æœ‰é™åºåˆ—}\}$ æ˜¯è¾“å…¥é›†åˆ
- $O = \{A' | A' \text{ æ˜¯æ’åºåçš„åºåˆ—}\}$ æ˜¯è¾“å‡ºé›†åˆ
- $C: I \rightarrow O$ æ˜¯æ’åºå‡½æ•°
- $T: I \rightarrow \mathbb{R}^+$ æ˜¯æ—¶é—´å¤æ‚åº¦å‡½æ•°

#### 1.2 ç®—æ³•åˆ†ç±»

**æ¯”è¾ƒæ’åº**:
$$\forall i, j: \text{compare}(A[i], A[j]) \text{ æ˜¯åŸºæœ¬æ“ä½œ}$$

**éæ¯”è¾ƒæ’åº**:
$$\text{åŸºäºæ•°æ®åˆ†å¸ƒç‰¹å¾è¿›è¡Œæ’åº}$$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Callable, Any, Tuple, Dict
import time
import random
import copy
import logging
from collections import defaultdict
import matplotlib.pyplot as plt
import numpy as np
from functools import wraps

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SortType(Enum):
    """æ’åºç±»å‹æšä¸¾"""
    ASCENDING = "ascending"
    DESCENDING = "descending"

class AlgorithmType(Enum):
    """ç®—æ³•ç±»å‹æšä¸¾"""
    COMPARISON = "comparison"
    NON_COMPARISON = "non_comparison"

@dataclass
class SortResult:
    """æ’åºç»“æœ"""
    sorted_array: List[Any]
    comparisons: int
    swaps: int
    time_taken: float
    algorithm_name: str
    array_size: int

def measure_performance(func):
    """æ€§èƒ½æµ‹é‡è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        if isinstance(result, SortResult):
            result.time_taken = end_time - start_time
        else:
            result = SortResult(
                sorted_array=result,
                comparisons=0,
                swaps=0,
                time_taken=end_time - start_time,
                algorithm_name=func.__name__,
                array_size=len(args[0]) if args else 0
            )
        
        return result
    return wrapper

class SortingAlgorithm(ABC):
    """æ’åºç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, algorithm_type: AlgorithmType):
        self.name = name
        self.algorithm_type = algorithm_type
        self.comparisons = 0
        self.swaps = 0
    
    @abstractmethod
    def sort(self, arr: List[Any], reverse: bool = False) -> SortResult:
        """æ’åºæ–¹æ³•"""
        pass
    
    def reset_metrics(self):
        """é‡ç½®æ€§èƒ½æŒ‡æ ‡"""
        self.comparisons = 0
        self.swaps = 0
    
    def compare(self, a: Any, b: Any) -> int:
        """æ¯”è¾ƒæ“ä½œ"""
        self.comparisons += 1
        if a < b:
            return -1
        elif a > b:
            return 1
        else:
            return 0
    
    def swap(self, arr: List[Any], i: int, j: int):
        """äº¤æ¢æ“ä½œ"""
        if i != j:
            arr[i], arr[j] = arr[j], arr[i]
            self.swaps += 1

class BubbleSort(SortingAlgorithm):
    """å†’æ³¡æ’åº"""
    
    def __init__(self):
        super().__init__("Bubble Sort", AlgorithmType.COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[Any], reverse: bool = False) -> SortResult:
        """å†’æ³¡æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        for i in range(n):
            swapped = False
            for j in range(0, n - i - 1):
                comparison = self.compare(arr_copy[j], arr_copy[j + 1])
                if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                    self.swap(arr_copy, j, j + 1)
                    swapped = True
            
            if not swapped:
                break
        
        return SortResult(
            sorted_array=arr_copy,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )

class SelectionSort(SortingAlgorithm):
    """é€‰æ‹©æ’åº"""
    
    def __init__(self):
        super().__init__("Selection Sort", AlgorithmType.COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[Any], reverse: bool = False) -> SortResult:
        """é€‰æ‹©æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        for i in range(n):
            min_idx = i
            for j in range(i + 1, n):
                comparison = self.compare(arr_copy[j], arr_copy[min_idx])
                if (comparison < 0 and not reverse) or (comparison > 0 and reverse):
                    min_idx = j
            
            if min_idx != i:
                self.swap(arr_copy, i, min_idx)
        
        return SortResult(
            sorted_array=arr_copy,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )

class InsertionSort(SortingAlgorithm):
    """æ’å…¥æ’åº"""
    
    def __init__(self):
        super().__init__("Insertion Sort", AlgorithmType.COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[Any], reverse: bool = False) -> SortResult:
        """æ’å…¥æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        for i in range(1, n):
            key = arr_copy[i]
            j = i - 1
            
            while j >= 0:
                comparison = self.compare(arr_copy[j], key)
                if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                    arr_copy[j + 1] = arr_copy[j]
                    j -= 1
                else:
                    break
            
            arr_copy[j + 1] = key
        
        return SortResult(
            sorted_array=arr_copy,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )

class MergeSort(SortingAlgorithm):
    """å½’å¹¶æ’åº"""
    
    def __init__(self):
        super().__init__("Merge Sort", AlgorithmType.COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[Any], reverse: bool = False) -> SortResult:
        """å½’å¹¶æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        sorted_arr = self._merge_sort(arr_copy, reverse)
        
        return SortResult(
            sorted_array=sorted_arr,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )
    
    def _merge_sort(self, arr: List[Any], reverse: bool) -> List[Any]:
        """é€’å½’å½’å¹¶æ’åº"""
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = self._merge_sort(arr[:mid], reverse)
        right = self._merge_sort(arr[mid:], reverse)
        
        return self._merge(left, right, reverse)
    
    def _merge(self, left: List[Any], right: List[Any], reverse: bool) -> List[Any]:
        """åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            comparison = self.compare(left[i], right[j])
            if (comparison <= 0 and not reverse) or (comparison >= 0 and reverse):
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result

class QuickSort(SortingAlgorithm):
    """å¿«é€Ÿæ’åº"""
    
    def __init__(self):
        super().__init__("Quick Sort", AlgorithmType.COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[Any], reverse: bool = False) -> SortResult:
        """å¿«é€Ÿæ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        self._quick_sort(arr_copy, 0, n - 1, reverse)
        
        return SortResult(
            sorted_array=arr_copy,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )
    
    def _quick_sort(self, arr: List[Any], low: int, high: int, reverse: bool):
        """é€’å½’å¿«é€Ÿæ’åº"""
        if low < high:
            pi = self._partition(arr, low, high, reverse)
            self._quick_sort(arr, low, pi - 1, reverse)
            self._quick_sort(arr, pi + 1, high, reverse)
    
    def _partition(self, arr: List[Any], low: int, high: int, reverse: bool) -> int:
        """åˆ†åŒºæ“ä½œ"""
        pivot = arr[high]
        i = low - 1
        
        for j in range(low, high):
            comparison = self.compare(arr[j], pivot)
            if (comparison <= 0 and not reverse) or (comparison >= 0 and reverse):
                i += 1
                self.swap(arr, i, j)
        
        self.swap(arr, i + 1, high)
        return i + 1

class HeapSort(SortingAlgorithm):
    """å †æ’åº"""
    
    def __init__(self):
        super().__init__("Heap Sort", AlgorithmType.COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[Any], reverse: bool = False) -> SortResult:
        """å †æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        # æ„å»ºæœ€å¤§å †
        for i in range(n // 2 - 1, -1, -1):
            self._heapify(arr_copy, n, i, reverse)
        
        # é€ä¸ªæå–å…ƒç´ 
        for i in range(n - 1, 0, -1):
            self.swap(arr_copy, 0, i)
            self._heapify(arr_copy, i, 0, reverse)
        
        return SortResult(
            sorted_array=arr_copy,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )
    
    def _heapify(self, arr: List[Any], n: int, i: int, reverse: bool):
        """å †åŒ–æ“ä½œ"""
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n:
            comparison = self.compare(arr[left], arr[largest])
            if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                largest = left
        
        if right < n:
            comparison = self.compare(arr[right], arr[largest])
            if (comparison > 0 and not reverse) or (comparison < 0 and reverse):
                largest = right
        
        if largest != i:
            self.swap(arr, i, largest)
            self._heapify(arr, n, largest, reverse)

class CountingSort(SortingAlgorithm):
    """è®¡æ•°æ’åº"""
    
    def __init__(self):
        super().__init__("Counting Sort", AlgorithmType.NON_COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[int], reverse: bool = False) -> SortResult:
        """è®¡æ•°æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        if n == 0:
            return SortResult(
                sorted_array=arr_copy,
                comparisons=self.comparisons,
                swaps=self.swaps,
                time_taken=0,
                algorithm_name=self.name,
                array_size=n
            )
        
        # æ‰¾åˆ°æœ€å¤§å€¼å’Œæœ€å°å€¼
        max_val = max(arr_copy)
        min_val = min(arr_copy)
        range_val = max_val - min_val + 1
        
        # åˆ›å»ºè®¡æ•°æ•°ç»„
        count = [0] * range_val
        output = [0] * n
        
        # è®¡æ•°
        for num in arr_copy:
            count[num - min_val] += 1
        
        # è®¡ç®—ç´¯ç§¯è®¡æ•°
        for i in range(1, range_val):
            count[i] += count[i - 1]
        
        # æ„å»ºè¾“å‡ºæ•°ç»„
        for i in range(n - 1, -1, -1):
            output[count[arr_copy[i] - min_val] - 1] = arr_copy[i]
            count[arr_copy[i] - min_val] -= 1
        
        if reverse:
            output = output[::-1]
        
        return SortResult(
            sorted_array=output,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )

class RadixSort(SortingAlgorithm):
    """åŸºæ•°æ’åº"""
    
    def __init__(self):
        super().__init__("Radix Sort", AlgorithmType.NON_COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[int], reverse: bool = False) -> SortResult:
        """åŸºæ•°æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        if n == 0:
            return SortResult(
                sorted_array=arr_copy,
                comparisons=self.comparisons,
                swaps=self.swaps,
                time_taken=0,
                algorithm_name=self.name,
                array_size=n
            )
        
        # æ‰¾åˆ°æœ€å¤§å€¼
        max_val = max(arr_copy)
        
        # æŒ‰ä½æ’åº
        exp = 1
        while max_val // exp > 0:
            arr_copy = self._counting_sort_by_digit(arr_copy, exp)
            exp *= 10
        
        if reverse:
            arr_copy = arr_copy[::-1]
        
        return SortResult(
            sorted_array=arr_copy,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )
    
    def _counting_sort_by_digit(self, arr: List[int], exp: int) -> List[int]:
        """æŒ‰ä½è®¡æ•°æ’åº"""
        n = len(arr)
        output = [0] * n
        count = [0] * 10
        
        # è®¡æ•°
        for num in arr:
            digit = (num // exp) % 10
            count[digit] += 1
        
        # è®¡ç®—ç´¯ç§¯è®¡æ•°
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        # æ„å»ºè¾“å‡ºæ•°ç»„
        for i in range(n - 1, -1, -1):
            digit = (arr[i] // exp) % 10
            output[count[digit] - 1] = arr[i]
            count[digit] -= 1
        
        return output

class BucketSort(SortingAlgorithm):
    """æ¡¶æ’åº"""
    
    def __init__(self):
        super().__init__("Bucket Sort", AlgorithmType.NON_COMPARISON)
    
    @measure_performance
    def sort(self, arr: List[float], reverse: bool = False) -> SortResult:
        """æ¡¶æ’åºå®ç°"""
        self.reset_metrics()
        arr_copy = copy.deepcopy(arr)
        n = len(arr_copy)
        
        if n == 0:
            return SortResult(
                sorted_array=arr_copy,
                comparisons=self.comparisons,
                swaps=self.swaps,
                time_taken=0,
                algorithm_name=self.name,
                array_size=n
            )
        
        # åˆ›å»ºæ¡¶
        bucket_count = n
        buckets = [[] for _ in range(bucket_count)]
        
        # åˆ†é…å…ƒç´ åˆ°æ¡¶
        min_val = min(arr_copy)
        max_val = max(arr_copy)
        bucket_range = (max_val - min_val) / bucket_count if max_val != min_val else 1
        
        for num in arr_copy:
            bucket_index = min(int((num - min_val) / bucket_range), bucket_count - 1)
            buckets[bucket_index].append(num)
        
        # å¯¹æ¯ä¸ªæ¡¶æ’åº
        sorted_arr = []
        for bucket in buckets:
            bucket.sort(reverse=reverse)
            sorted_arr.extend(bucket)
        
        return SortResult(
            sorted_array=sorted_arr,
            comparisons=self.comparisons,
            swaps=self.swaps,
            time_taken=0,
            algorithm_name=self.name,
            array_size=n
        )

class SortingAlgorithmBenchmark:
    """æ’åºç®—æ³•åŸºå‡†æµ‹è¯•"""
    
    def __init__(self):
        self.algorithms = {
            "Bubble Sort": BubbleSort(),
            "Selection Sort": SelectionSort(),
            "Insertion Sort": InsertionSort(),
            "Merge Sort": MergeSort(),
            "Quick Sort": QuickSort(),
            "Heap Sort": HeapSort(),
            "Counting Sort": CountingSort(),
            "Radix Sort": RadixSort(),
            "Bucket Sort": BucketSort()
        }
    
    def generate_test_data(self, size: int, data_type: str = "random") -> List[Any]:
        """ç”Ÿæˆæµ‹è¯•æ•°æ®"""
        if data_type == "random":
            return [random.randint(1, 1000) for _ in range(size)]
        elif data_type == "sorted":
            return list(range(1, size + 1))
        elif data_type == "reverse_sorted":
            return list(range(size, 0, -1))
        elif data_type == "nearly_sorted":
            arr = list(range(1, size + 1))
            # éšæœºäº¤æ¢ä¸€äº›å…ƒç´ 
            for _ in range(size // 10):
                i = random.randint(0, size - 1)
                j = random.randint(0, size - 1)
                arr[i], arr[j] = arr[j], arr[i]
            return arr
        elif data_type == "duplicates":
            return [random.randint(1, 10) for _ in range(size)]
        else:
            raise ValueError(f"Unknown data type: {data_type}")
    
    def benchmark(self, sizes: List[int], data_type: str = "random") -> Dict[str, List[SortResult]]:
        """è¿è¡ŒåŸºå‡†æµ‹è¯•"""
        results = defaultdict(list)
        
        for size in sizes:
            print(f"Testing with size: {size}")
            test_data = self.generate_test_data(size, data_type)
            
            for name, algorithm in self.algorithms.items():
                try:
                    # æ ¹æ®ç®—æ³•ç±»å‹é€‰æ‹©åˆé€‚çš„æ•°æ®
                    if name in ["Counting Sort", "Radix Sort"]:
                        # è¿™äº›ç®—æ³•éœ€è¦æ•´æ•°
                        data = [int(x) for x in test_data]
                    elif name == "Bucket Sort":
                        # æ¡¶æ’åºéœ€è¦æµ®ç‚¹æ•°
                        data = [float(x) for x in test_data]
                    else:
                        data = test_data
                    
                    result = algorithm.sort(data)
                    results[name].append(result)
                    print(f"  {name}: {result.time_taken:.6f}s, {result.comparisons} comparisons")
                except Exception as e:
                    print(f"  {name}: Error - {e}")
        
        return results
    
    def plot_performance(self, results: Dict[str, List[SortResult]], metric: str = "time"):
        """ç»˜åˆ¶æ€§èƒ½å›¾è¡¨"""
        plt.figure(figsize=(12, 8))
        
        for name, result_list in results.items():
            if not result_list:
                continue
            
            sizes = [r.array_size for r in result_list]
            if metric == "time":
                values = [r.time_taken for r in result_list]
                ylabel = "Time (seconds)"
            elif metric == "comparisons":
                values = [r.comparisons for r in result_list]
                ylabel = "Number of Comparisons"
            elif metric == "swaps":
                values = [r.swaps for r in result_list]
                ylabel = "Number of Swaps"
            else:
                raise ValueError(f"Unknown metric: {metric}")
            
            plt.plot(sizes, values, marker='o', label=name)
        
        plt.xlabel("Array Size")
        plt.ylabel(ylabel)
        plt.title(f"Sorting Algorithm Performance - {metric.title()}")
        plt.legend()
        plt.grid(True)
        plt.xscale('log')
        if metric == "time":
            plt.yscale('log')
        plt.tight_layout()
        plt.savefig(f"sorting_performance_{metric}.png", dpi=300, bbox_inches='tight')
        plt.show()
    
    def generate_report(self, results: Dict[str, List[SortResult]]) -> Dict[str, Any]:
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        report = {
            "summary": {},
            "algorithms": {}
        }
        
        total_tests = 0
        total_time = 0
        
        for name, result_list in results.items():
            if not result_list:
                continue
            
            algorithm_report = {
                "total_tests": len(result_list),
                "average_time": sum(r.time_taken for r in result_list) / len(result_list),
                "average_comparisons": sum(r.comparisons for r in result_list) / len(result_list),
                "average_swaps": sum(r.swaps for r in result_list) / len(result_list),
                "best_time": min(r.time_taken for r in result_list),
                "worst_time": max(r.time_taken for r in result_list),
                "results": [
                    {
                        "size": r.array_size,
                        "time": r.time_taken,
                        "comparisons": r.comparisons,
                        "swaps": r.swaps
                    }
                    for r in result_list
                ]
            }
            
            report["algorithms"][name] = algorithm_report
            total_tests += len(result_list)
            total_time += sum(r.time_taken for r in result_list)
        
        report["summary"] = {
            "total_algorithms": len(results),
            "total_tests": total_tests,
            "total_time": total_time,
            "average_time_per_test": total_time / total_tests if total_tests > 0 else 0
        }
        
        return report
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
def demonstrate_sorting_algorithms():
    """æ¼”ç¤ºæ’åºç®—æ³•"""
    print("=== Sorting Algorithms Demo ===")
    
    # åˆ›å»ºæµ‹è¯•æ•°æ®
    test_data = [64, 34, 25, 12, 22, 11, 90, 88, 76, 54, 32, 21, 19, 8, 5, 3, 1]
    print(f"Original array: {test_data}")
    
    # åˆ›å»ºç®—æ³•å®ä¾‹
    algorithms = {
        "Bubble Sort": BubbleSort(),
        "Selection Sort": SelectionSort(),
        "Insertion Sort": InsertionSort(),
        "Merge Sort": MergeSort(),
        "Quick Sort": QuickSort(),
        "Heap Sort": HeapSort()
    }
    
    # æµ‹è¯•æ¯ä¸ªç®—æ³•
    for name, algorithm in algorithms.items():
        print(f"\n{name}:")
        result = algorithm.sort(test_data)
        print(f"  Sorted: {result.sorted_array}")
        print(f"  Time: {result.time_taken:.6f}s")
        print(f"  Comparisons: {result.comparisons}")
        print(f"  Swaps: {result.swaps}")
    
    # åŸºå‡†æµ‹è¯•
    print("\n=== Performance Benchmark ===")
    benchmark = SortingAlgorithmBenchmark()
    
    # æµ‹è¯•ä¸åŒå¤§å°çš„æ•°ç»„
    sizes = [10, 100, 1000]
    results = benchmark.benchmark(sizes, "random")
    
    # ç»˜åˆ¶æ€§èƒ½å›¾è¡¨
    benchmark.plot_performance(results, "time")
    benchmark.plot_performance(results, "comparisons")
    
    # ç”ŸæˆæŠ¥å‘Š
    report = benchmark.generate_report(results)
    print(f"\nBenchmark Report:")
    print(f"Total algorithms tested: {report['summary']['total_algorithms']}")
    print(f"Total tests: {report['summary']['total_tests']}")
    print(f"Total time: {report['summary']['total_time']:.6f}s")
    
    # æ˜¾ç¤ºæ¯ä¸ªç®—æ³•çš„å¹³å‡æ€§èƒ½
    print("\nAlgorithm Performance Summary:")
    for name, algo_report in report["algorithms"].items():
        print(f"{name}:")
        print(f"  Average time: {algo_report['average_time']:.6f}s")
        print(f"  Average comparisons: {algo_report['average_comparisons']:.0f}")
        print(f"  Average swaps: {algo_report['average_swaps']:.0f}")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    demonstrate_sorting_algorithms()
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**æ¯”è¾ƒæ’åºç®—æ³•**:

- å†’æ³¡æ’åº: $O(n^2)$
- é€‰æ‹©æ’åº: $O(n^2)$
- æ’å…¥æ’åº: $O(n^2)$ (æœ€åæƒ…å†µ), $O(n)$ (æœ€å¥½æƒ…å†µ)
- å½’å¹¶æ’åº: $O(n \log n)$
- å¿«é€Ÿæ’åº: $O(n \log n)$ (å¹³å‡), $O(n^2)$ (æœ€å)
- å †æ’åº: $O(n \log n)$

**éæ¯”è¾ƒæ’åºç®—æ³•**:

- è®¡æ•°æ’åº: $O(n + k)$ å…¶ä¸­ $k$ æ˜¯æ•°æ®èŒƒå›´
- åŸºæ•°æ’åº: $O(d(n + k))$ å…¶ä¸­ $d$ æ˜¯ä½æ•°
- æ¡¶æ’åº: $O(n + k)$ å…¶ä¸­ $k$ æ˜¯æ¡¶æ•°é‡

#### 4.2 ç©ºé—´å¤æ‚åº¦

**åŸåœ°æ’åº**: $O(1)$

- å†’æ³¡æ’åºã€é€‰æ‹©æ’åºã€æ’å…¥æ’åºã€å †æ’åº

**éåŸåœ°æ’åº**: $O(n)$

- å½’å¹¶æ’åºã€å¿«é€Ÿæ’åºã€è®¡æ•°æ’åºã€åŸºæ•°æ’åºã€æ¡¶æ’åº

### 5. ç¨³å®šæ€§åˆ†æ

**ç¨³å®šæ’åºç®—æ³•**:

- å†’æ³¡æ’åº
- æ’å…¥æ’åº
- å½’å¹¶æ’åº
- è®¡æ•°æ’åº
- åŸºæ•°æ’åº
- æ¡¶æ’åº

**ä¸ç¨³å®šæ’åºç®—æ³•**:

- é€‰æ‹©æ’åº
- å¿«é€Ÿæ’åº
- å †æ’åº

### 6. é€‚ç”¨åœºæ™¯

#### 6.1 å°è§„æ¨¡æ•°æ® (n < 50)

- **æ’å…¥æ’åº**: ç®€å•é«˜æ•ˆï¼Œé€‚åˆå°æ•°ç»„
- **é€‰æ‹©æ’åº**: äº¤æ¢æ¬¡æ•°å°‘

#### 6.2 ä¸­ç­‰è§„æ¨¡æ•°æ® (50 â‰¤ n < 1000)

- **å¿«é€Ÿæ’åº**: å¹³å‡æ€§èƒ½æœ€å¥½
- **å½’å¹¶æ’åº**: ç¨³å®šä¸”å¯é¢„æµ‹

#### 6.3 å¤§è§„æ¨¡æ•°æ® (n â‰¥ 1000)

- **å †æ’åº**: åŸåœ°æ’åºï¼Œç©ºé—´æ•ˆç‡é«˜
- **å½’å¹¶æ’åº**: ç¨³å®šä¸”å¯å¹¶è¡ŒåŒ–

#### 6.4 ç‰¹æ®Šæ•°æ®

- **è®¡æ•°æ’åº**: æ•´æ•°ä¸”èŒƒå›´è¾ƒå°
- **åŸºæ•°æ’åº**: æ•´æ•°æˆ–å­—ç¬¦ä¸²
- **æ¡¶æ’åº**: å‡åŒ€åˆ†å¸ƒçš„æ•°æ®

## ğŸ”— ç›¸å…³é“¾æ¥

- [æœç´¢ç®—æ³•](./06-01-02-æœç´¢ç®—æ³•.md)
- [å›¾ç®—æ³•](./06-01-03-å›¾ç®—æ³•.md)
- [ç®—æ³•ç†è®º](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., et al. (2009). "Introduction to Algorithms". MIT Press.
2. Knuth, D. E. (1998). "The Art of Computer Programming, Volume 3: Sorting and Searching". Addison-Wesley.
3. Sedgewick, R., & Wayne, K. (2011). "Algorithms". Addison-Wesley.

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant
