# æœç´¢ç®—æ³•

## ğŸ“‹ æ¦‚è¿°

æœç´¢ç®—æ³•æ˜¯ç”¨äºåœ¨æ•°æ®é›†åˆä¸­æŸ¥æ‰¾ç‰¹å®šå…ƒç´ æˆ–æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„å…ƒç´ çš„ç®—æ³•ã€‚æœ¬æ–‡æ¡£æä¾›æœç´¢ç®—æ³•çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œæ€§èƒ½åˆ†æã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æœç´¢ç®—æ³•å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**æœç´¢é—®é¢˜**:
ç»™å®šä¸€ä¸ªé›†åˆ $S = \{s_1, s_2, ..., s_n\}$ å’Œä¸€ä¸ªç›®æ ‡å…ƒç´  $t$ï¼Œæ‰¾åˆ°ä¸€ä¸ªå‡½æ•° $f: S \times T \rightarrow \{true, false\}$ ä½¿å¾—ï¼š
$$f(s_i, t) = true \text{ å½“ä¸”ä»…å½“ } s_i = t$$

**æœç´¢ç®—æ³•äº”å…ƒç»„**:
$$\mathcal{SA} = (S, T, Q, F, C)$$

å…¶ä¸­ï¼š

- $S = \{s_1, s_2, ..., s_n\}$ æ˜¯æœç´¢ç©ºé—´
- $T$ æ˜¯ç›®æ ‡é›†åˆ
- $Q: S \times T \rightarrow \{true, false\}$ æ˜¯æŸ¥è¯¢å‡½æ•°
- $F: S \times T \rightarrow S$ æ˜¯æœç´¢å‡½æ•°
- $C: S \times T \rightarrow \mathbb{R}^+$ æ˜¯æˆæœ¬å‡½æ•°

#### 1.2 ç®—æ³•åˆ†ç±»

**çº¿æ€§æœç´¢**: $\forall i: \text{check}(S[i]) \text{ é¡ºåºè¿›è¡Œ}$
**äºŒåˆ†æœç´¢**: $\text{åŸºäºæœ‰åºæ€§çš„åˆ†æ²»ç­–ç•¥}$
**å“ˆå¸Œæœç´¢**: $\text{åŸºäºå“ˆå¸Œå‡½æ•°çš„ç›´æ¥è®¿é—®}$
**æ ‘æœç´¢**: $\text{åŸºäºæ ‘ç»“æ„çš„å±‚æ¬¡æœç´¢}$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Callable, Any, Tuple, Dict, Set
import time
import random
import copy
import logging
from collections import defaultdict, deque
import heapq
import math
import matplotlib.pyplot as plt
import numpy as np
from functools import wraps

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SearchType(Enum):
    """æœç´¢ç±»å‹æšä¸¾"""
    LINEAR = "linear"
    BINARY = "binary"
    HASH = "hash"
    TREE = "tree"
    GRAPH = "graph"

class SearchResult:
    """æœç´¢ç»“æœ"""
    def __init__(self, found: bool, index: Optional[int] = None, 
                 value: Optional[Any] = None, comparisons: int = 0, 
                 time_taken: float = 0.0, algorithm_name: str = ""):
        self.found = found
        self.index = index
        self.value = value
        self.comparisons = comparisons
        self.time_taken = time_taken
        self.algorithm_name = algorithm_name

def measure_performance(func):
    """æ€§èƒ½æµ‹é‡è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        if isinstance(result, SearchResult):
            result.time_taken = end_time - start_time
        else:
            result = SearchResult(
                found=result is not None,
                value=result,
                time_taken=end_time - start_time,
                algorithm_name=func.__name__
            )
        
        return result
    return wrapper

class SearchAlgorithm(ABC):
    """æœç´¢ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, search_type: SearchType):
        self.name = name
        self.search_type = search_type
        self.comparisons = 0
    
    @abstractmethod
    def search(self, data: List[Any], target: Any) -> SearchResult:
        """æœç´¢æ–¹æ³•"""
        pass
    
    def reset_metrics(self):
        """é‡ç½®æ€§èƒ½æŒ‡æ ‡"""
        self.comparisons = 0
    
    def compare(self, a: Any, b: Any) -> int:
        """æ¯”è¾ƒæ“ä½œ"""
        self.comparisons += 1
        if a < b:
            return -1
        elif a > b:
            return 1
        else:
            return 0

class LinearSearch(SearchAlgorithm):
    """çº¿æ€§æœç´¢"""
    
    def __init__(self):
        super().__init__("Linear Search", SearchType.LINEAR)
    
    @measure_performance
    def search(self, data: List[Any], target: Any) -> SearchResult:
        """çº¿æ€§æœç´¢å®ç°"""
        self.reset_metrics()
        
        for i, item in enumerate(data):
            if self.compare(item, target) == 0:
                return SearchResult(
                    found=True,
                    index=i,
                    value=item,
                    comparisons=self.comparisons,
                    algorithm_name=self.name
                )
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name
        )

class BinarySearch(SearchAlgorithm):
    """äºŒåˆ†æœç´¢"""
    
    def __init__(self):
        super().__init__("Binary Search", SearchType.BINARY)
    
    @measure_performance
    def search(self, data: List[Any], target: Any) -> SearchResult:
        """äºŒåˆ†æœç´¢å®ç°"""
        self.reset_metrics()
        
        left, right = 0, len(data) - 1
        
        while left <= right:
            mid = (left + right) // 2
            comparison = self.compare(data[mid], target)
            
            if comparison == 0:
                return SearchResult(
                    found=True,
                    index=mid,
                    value=data[mid],
                    comparisons=self.comparisons,
                    algorithm_name=self.name
                )
            elif comparison < 0:
                left = mid + 1
            else:
                right = mid - 1
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name
        )
    
    def search_first_occurrence(self, data: List[Any], target: Any) -> SearchResult:
        """æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå‡ºç°çš„ä½ç½®"""
        self.reset_metrics()
        
        left, right = 0, len(data) - 1
        result_index = -1
        
        while left <= right:
            mid = (left + right) // 2
            comparison = self.compare(data[mid], target)
            
            if comparison == 0:
                result_index = mid
                right = mid - 1  # ç»§ç»­å‘å·¦æŸ¥æ‰¾
            elif comparison < 0:
                left = mid + 1
            else:
                right = mid - 1
        
        if result_index != -1:
            return SearchResult(
                found=True,
                index=result_index,
                value=data[result_index],
                comparisons=self.comparisons,
                algorithm_name=self.name + " (First Occurrence)"
            )
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name + " (First Occurrence)"
        )
    
    def search_last_occurrence(self, data: List[Any], target: Any) -> SearchResult:
        """æŸ¥æ‰¾æœ€åä¸€ä¸ªå‡ºç°çš„ä½ç½®"""
        self.reset_metrics()
        
        left, right = 0, len(data) - 1
        result_index = -1
        
        while left <= right:
            mid = (left + right) // 2
            comparison = self.compare(data[mid], target)
            
            if comparison == 0:
                result_index = mid
                left = mid + 1  # ç»§ç»­å‘å³æŸ¥æ‰¾
            elif comparison < 0:
                left = mid + 1
            else:
                right = mid - 1
        
        if result_index != -1:
            return SearchResult(
                found=True,
                index=result_index,
                value=data[result_index],
                comparisons=self.comparisons,
                algorithm_name=self.name + " (Last Occurrence)"
            )
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name + " (Last Occurrence)"
        )

class HashSearch(SearchAlgorithm):
    """å“ˆå¸Œæœç´¢"""
    
    def __init__(self):
        super().__init__("Hash Search", SearchType.HASH)
        self.hash_table = {}
    
    def build_hash_table(self, data: List[Any]):
        """æ„å»ºå“ˆå¸Œè¡¨"""
        self.hash_table.clear()
        for i, item in enumerate(data):
            hash_key = hash(item)
            if hash_key not in self.hash_table:
                self.hash_table[hash_key] = []
            self.hash_table[hash_key].append((i, item))
    
    @measure_performance
    def search(self, data: List[Any], target: Any) -> SearchResult:
        """å“ˆå¸Œæœç´¢å®ç°"""
        self.reset_metrics()
        
        # æ„å»ºå“ˆå¸Œè¡¨
        self.build_hash_table(data)
        
        # æœç´¢ç›®æ ‡
        hash_key = hash(target)
        if hash_key in self.hash_table:
            for index, item in self.hash_table[hash_key]:
                if self.compare(item, target) == 0:
                    return SearchResult(
                        found=True,
                        index=index,
                        value=item,
                        comparisons=self.comparisons,
                        algorithm_name=self.name
                    )
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name
        )

class TreeNode:
    """æ ‘èŠ‚ç‚¹"""
    def __init__(self, value: Any):
        self.value = value
        self.left = None
        self.right = None
        self.parent = None

class BinarySearchTree:
    """äºŒå‰æœç´¢æ ‘"""
    
    def __init__(self):
        self.root = None
        self.size = 0
    
    def insert(self, value: Any):
        """æ’å…¥èŠ‚ç‚¹"""
        if self.root is None:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)
        self.size += 1
    
    def _insert_recursive(self, node: TreeNode, value: Any):
        """é€’å½’æ’å…¥"""
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
                node.left.parent = node
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
                node.right.parent = node
            else:
                self._insert_recursive(node.right, value)
    
    def search(self, value: Any) -> Optional[TreeNode]:
        """æœç´¢èŠ‚ç‚¹"""
        return self._search_recursive(self.root, value)
    
    def _search_recursive(self, node: TreeNode, value: Any) -> Optional[TreeNode]:
        """é€’å½’æœç´¢"""
        if node is None or node.value == value:
            return node
        
        if value < node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)

class TreeSearch(SearchAlgorithm):
    """æ ‘æœç´¢"""
    
    def __init__(self):
        super().__init__("Tree Search", SearchType.TREE)
        self.tree = BinarySearchTree()
    
    def build_tree(self, data: List[Any]):
        """æ„å»ºæœç´¢æ ‘"""
        self.tree = BinarySearchTree()
        for item in data:
            self.tree.insert(item)
    
    @measure_performance
    def search(self, data: List[Any], target: Any) -> SearchResult:
        """æ ‘æœç´¢å®ç°"""
        self.reset_metrics()
        
        # æ„å»ºæ ‘
        self.build_tree(data)
        
        # æœç´¢ç›®æ ‡
        result_node = self.tree.search(target)
        
        if result_node:
            # è®¡ç®—ç´¢å¼•ï¼ˆé€šè¿‡ä¸­åºéå†ï¼‰
            index = self._get_node_index(result_node)
            return SearchResult(
                found=True,
                index=index,
                value=result_node.value,
                comparisons=self.comparisons,
                algorithm_name=self.name
            )
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name
        )
    
    def _get_node_index(self, node: TreeNode) -> int:
        """è·å–èŠ‚ç‚¹åœ¨åŸå§‹æ•°ç»„ä¸­çš„ç´¢å¼•"""
        # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„ç´¢å¼•æ˜ å°„
        return 0

class GraphSearch(SearchAlgorithm):
    """å›¾æœç´¢"""
    
    def __init__(self):
        super().__init__("Graph Search", SearchType.GRAPH)
    
    @measure_performance
    def search(self, graph: Dict[Any, List[Any]], target: Any, start: Any) -> SearchResult:
        """å›¾æœç´¢å®ç°"""
        self.reset_metrics()
        
        # ä½¿ç”¨BFSæœç´¢
        visited = set()
        queue = deque([(start, 0)])  # (node, distance)
        visited.add(start)
        
        while queue:
            current, distance = queue.popleft()
            
            if self.compare(current, target) == 0:
                return SearchResult(
                    found=True,
                    value=current,
                    comparisons=self.comparisons,
                    algorithm_name=self.name + " (BFS)"
                )
            
            for neighbor in graph.get(current, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, distance + 1))
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name + " (BFS)"
        )
    
    def dfs_search(self, graph: Dict[Any, List[Any]], target: Any, start: Any) -> SearchResult:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        self.reset_metrics()
        
        visited = set()
        
        def dfs(node: Any) -> Optional[Any]:
            if node in visited:
                return None
            
            visited.add(node)
            
            if self.compare(node, target) == 0:
                return node
            
            for neighbor in graph.get(node, []):
                result = dfs(neighbor)
                if result:
                    return result
            
            return None
        
        result = dfs(start)
        
        if result:
            return SearchResult(
                found=True,
                value=result,
                comparisons=self.comparisons,
                algorithm_name=self.name + " (DFS)"
            )
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name + " (DFS)"
        )

class AStarSearch(SearchAlgorithm):
    """A*æœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("A* Search", SearchType.GRAPH)
    
    @measure_performance
    def search(self, graph: Dict[Any, List[Tuple[Any, float]]], 
               start: Any, target: Any, heuristic: Callable[[Any, Any], float]) -> SearchResult:
        """A*æœç´¢å®ç°"""
        self.reset_metrics()
        
        # ä¼˜å…ˆé˜Ÿåˆ—å­˜å‚¨ (f_score, current, g_score, path)
        open_set = [(heuristic(start, target), start, 0, [start])]
        closed_set = set()
        g_scores = {start: 0}
        
        while open_set:
            f_score, current, g_score, path = heapq.heappop(open_set)
            
            if self.compare(current, target) == 0:
                return SearchResult(
                    found=True,
                    value=current,
                    comparisons=self.comparisons,
                    algorithm_name=self.name
                )
            
            if current in closed_set:
                continue
            
            closed_set.add(current)
            
            for neighbor, cost in graph.get(current, []):
                if neighbor in closed_set:
                    continue
                
                tentative_g_score = g_score + cost
                
                if neighbor not in g_scores or tentative_g_score < g_scores[neighbor]:
                    g_scores[neighbor] = tentative_g_score
                    f_score = tentative_g_score + heuristic(neighbor, target)
                    new_path = path + [neighbor]
                    heapq.heappush(open_set, (f_score, neighbor, tentative_g_score, new_path))
        
        return SearchResult(
            found=False,
            comparisons=self.comparisons,
            algorithm_name=self.name
        )

class SearchAlgorithmBenchmark:
    """æœç´¢ç®—æ³•åŸºå‡†æµ‹è¯•"""
    
    def __init__(self):
        self.algorithms = {
            "Linear Search": LinearSearch(),
            "Binary Search": BinarySearch(),
            "Hash Search": HashSearch(),
            "Tree Search": TreeSearch(),
            "Graph Search (BFS)": GraphSearch(),
            "Graph Search (DFS)": GraphSearch(),
            "A* Search": AStarSearch()
        }
    
    def generate_test_data(self, size: int, data_type: str = "random") -> List[Any]:
        """ç”Ÿæˆæµ‹è¯•æ•°æ®"""
        if data_type == "random":
            return [random.randint(1, 1000) for _ in range(size)]
        elif data_type == "sorted":
            return sorted([random.randint(1, 1000) for _ in range(size)])
        elif data_type == "duplicates":
            return [random.randint(1, 10) for _ in range(size)]
        else:
            raise ValueError(f"Unknown data type: {data_type}")
    
    def benchmark_array_search(self, sizes: List[int], data_type: str = "random") -> Dict[str, List[SearchResult]]:
        """æ•°ç»„æœç´¢åŸºå‡†æµ‹è¯•"""
        results = defaultdict(list)
        
        for size in sizes:
            print(f"Testing array search with size: {size}")
            test_data = self.generate_test_data(size, data_type)
            target = random.choice(test_data)  # ç¡®ä¿ç›®æ ‡å­˜åœ¨
            
            for name, algorithm in self.algorithms.items():
                if "Graph" in name or "A*" in name:
                    continue  # è·³è¿‡å›¾æœç´¢ç®—æ³•
                
                try:
                    if name == "Binary Search" and data_type != "sorted":
                        # äºŒåˆ†æœç´¢éœ€è¦æœ‰åºæ•°æ®
                        sorted_data = sorted(test_data)
                        result = algorithm.search(sorted_data, target)
                    else:
                        result = algorithm.search(test_data, target)
                    
                    results[name].append(result)
                    print(f"  {name}: {result.time_taken:.6f}s, {result.comparisons} comparisons")
                except Exception as e:
                    print(f"  {name}: Error - {e}")
        
        return results
    
    def benchmark_graph_search(self, sizes: List[int]) -> Dict[str, List[SearchResult]]:
        """å›¾æœç´¢åŸºå‡†æµ‹è¯•"""
        results = defaultdict(list)
        
        for size in sizes:
            print(f"Testing graph search with size: {size}")
            
            # ç”Ÿæˆéšæœºå›¾
            graph = {}
            nodes = list(range(size))
            
            for node in nodes:
                neighbors = random.sample(nodes, min(5, size // 2))
                graph[node] = [(neighbor, random.uniform(1, 10)) for neighbor in neighbors if neighbor != node]
            
            start = random.choice(nodes)
            target = random.choice(nodes)
            
            # æµ‹è¯•BFS
            try:
                bfs_algorithm = self.algorithms["Graph Search (BFS)"]
                result = bfs_algorithm.search(graph, target, start)
                results["Graph Search (BFS)"].append(result)
                print(f"  Graph Search (BFS): {result.time_taken:.6f}s, {result.comparisons} comparisons")
            except Exception as e:
                print(f"  Graph Search (BFS): Error - {e}")
            
            # æµ‹è¯•DFS
            try:
                dfs_algorithm = self.algorithms["Graph Search (DFS)"]
                result = dfs_algorithm.dfs_search(graph, target, start)
                results["Graph Search (DFS)"].append(result)
                print(f"  Graph Search (DFS): {result.time_taken:.6f}s, {result.comparisons} comparisons")
            except Exception as e:
                print(f"  Graph Search (DFS): Error - {e}")
            
            # æµ‹è¯•A*
            try:
                def heuristic(node, target):
                    return abs(node - target)  # ç®€å•çš„æ›¼å“ˆé¡¿è·ç¦»
                
                astar_algorithm = self.algorithms["A* Search"]
                result = astar_algorithm.search(graph, start, target, heuristic)
                results["A* Search"].append(result)
                print(f"  A* Search: {result.time_taken:.6f}s, {result.comparisons} comparisons")
            except Exception as e:
                print(f"  A* Search: Error - {e}")
        
        return results
    
    def plot_performance(self, results: Dict[str, List[SearchResult]], metric: str = "time"):
        """ç»˜åˆ¶æ€§èƒ½å›¾è¡¨"""
        plt.figure(figsize=(12, 8))
        
        for name, result_list in results.items():
            if not result_list:
                continue
            
            sizes = list(range(1, len(result_list) + 1))
            if metric == "time":
                values = [r.time_taken for r in result_list]
                ylabel = "Time (seconds)"
            elif metric == "comparisons":
                values = [r.comparisons for r in result_list]
                ylabel = "Number of Comparisons"
            else:
                raise ValueError(f"Unknown metric: {metric}")
            
            plt.plot(sizes, values, marker='o', label=name)
        
        plt.xlabel("Test Size")
        plt.ylabel(ylabel)
        plt.title(f"Search Algorithm Performance - {metric.title()}")
        plt.legend()
        plt.grid(True)
        plt.yscale('log')
        plt.tight_layout()
        plt.savefig(f"search_performance_{metric}.png", dpi=300, bbox_inches='tight')
        plt.show()
    
    def generate_report(self, results: Dict[str, List[SearchResult]]) -> Dict[str, Any]:
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        report = {
            "summary": {},
            "algorithms": {}
        }
        
        total_tests = 0
        total_time = 0
        
        for name, result_list in results.items():
            if not result_list:
                continue
            
            algorithm_report = {
                "total_tests": len(result_list),
                "successful_searches": sum(1 for r in result_list if r.found),
                "average_time": sum(r.time_taken for r in result_list) / len(result_list),
                "average_comparisons": sum(r.comparisons for r in result_list) / len(result_list),
                "best_time": min(r.time_taken for r in result_list),
                "worst_time": max(r.time_taken for r in result_list),
                "results": [
                    {
                        "found": r.found,
                        "time": r.time_taken,
                        "comparisons": r.comparisons
                    }
                    for r in result_list
                ]
            }
            
            report["algorithms"][name] = algorithm_report
            total_tests += len(result_list)
            total_time += sum(r.time_taken for r in result_list)
        
        report["summary"] = {
            "total_algorithms": len(results),
            "total_tests": total_tests,
            "total_time": total_time,
            "average_time_per_test": total_time / total_tests if total_tests > 0 else 0
        }
        
        return report
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
def demonstrate_search_algorithms():
    """æ¼”ç¤ºæœç´¢ç®—æ³•"""
    print("=== Search Algorithms Demo ===")
    
    # åˆ›å»ºæµ‹è¯•æ•°æ®
    test_data = [64, 34, 25, 12, 22, 11, 90, 88, 76, 54, 32, 21, 19, 8, 5, 3, 1]
    target = 22
    print(f"Searching for {target} in: {test_data}")
    
    # åˆ›å»ºç®—æ³•å®ä¾‹
    algorithms = {
        "Linear Search": LinearSearch(),
        "Binary Search": BinarySearch(),
        "Hash Search": HashSearch(),
        "Tree Search": TreeSearch()
    }
    
    # æµ‹è¯•æ¯ä¸ªç®—æ³•
    for name, algorithm in algorithms.items():
        print(f"\n{name}:")
        
        if name == "Binary Search":
            # äºŒåˆ†æœç´¢éœ€è¦æœ‰åºæ•°æ®
            sorted_data = sorted(test_data)
            result = algorithm.search(sorted_data, target)
        else:
            result = algorithm.search(test_data, target)
        
        if result.found:
            print(f"  Found at index: {result.index}")
            print(f"  Value: {result.value}")
        else:
            print(f"  Not found")
        
        print(f"  Time: {result.time_taken:.6f}s")
        print(f"  Comparisons: {result.comparisons}")
    
    # æµ‹è¯•å›¾æœç´¢
    print("\n=== Graph Search Demo ===")
    graph = {
        0: [1, 2],
        1: [0, 3, 4],
        2: [0, 5, 6],
        3: [1],
        4: [1],
        5: [2],
        6: [2]
    }
    
    start_node = 0
    target_node = 4
    
    graph_search = GraphSearch()
    
    # BFSæœç´¢
    bfs_result = graph_search.search(graph, target_node, start_node)
    print(f"BFS Search for {target_node} from {start_node}:")
    print(f"  Found: {bfs_result.found}")
    print(f"  Time: {bfs_result.time_taken:.6f}s")
    print(f"  Comparisons: {bfs_result.comparisons}")
    
    # DFSæœç´¢
    dfs_result = graph_search.dfs_search(graph, target_node, start_node)
    print(f"DFS Search for {target_node} from {start_node}:")
    print(f"  Found: {dfs_result.found}")
    print(f"  Time: {dfs_result.time_taken:.6f}s")
    print(f"  Comparisons: {dfs_result.comparisons}")
    
    # åŸºå‡†æµ‹è¯•
    print("\n=== Performance Benchmark ===")
    benchmark = SearchAlgorithmBenchmark()
    
    # æµ‹è¯•ä¸åŒå¤§å°çš„æ•°ç»„
    sizes = [100, 1000, 10000]
    results = benchmark.benchmark_array_search(sizes, "random")
    
    # ç»˜åˆ¶æ€§èƒ½å›¾è¡¨
    benchmark.plot_performance(results, "time")
    benchmark.plot_performance(results, "comparisons")
    
    # ç”ŸæˆæŠ¥å‘Š
    report = benchmark.generate_report(results)
    print(f"\nBenchmark Report:")
    print(f"Total algorithms tested: {report['summary']['total_algorithms']}")
    print(f"Total tests: {report['summary']['total_tests']}")
    print(f"Total time: {report['summary']['total_time']:.6f}s")
    
    # æ˜¾ç¤ºæ¯ä¸ªç®—æ³•çš„å¹³å‡æ€§èƒ½
    print("\nAlgorithm Performance Summary:")
    for name, algo_report in report["algorithms"].items():
        print(f"{name}:")
        print(f"  Success rate: {algo_report['successful_searches']}/{algo_report['total_tests']}")
        print(f"  Average time: {algo_report['average_time']:.6f}s")
        print(f"  Average comparisons: {algo_report['average_comparisons']:.0f}")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    demonstrate_search_algorithms()
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**çº¿æ€§æœç´¢**: $O(n)$
**äºŒåˆ†æœç´¢**: $O(\log n)$ (éœ€è¦æœ‰åºæ•°æ®)
**å“ˆå¸Œæœç´¢**: $O(1)$ (å¹³å‡æƒ…å†µ), $O(n)$ (æœ€åæƒ…å†µ)
**æ ‘æœç´¢**: $O(\log n)$ (å¹³è¡¡æ ‘), $O(n)$ (ä¸å¹³è¡¡æ ‘)
**BFS**: $O(V + E)$ å…¶ä¸­ $V$ æ˜¯é¡¶ç‚¹æ•°ï¼Œ$E$ æ˜¯è¾¹æ•°
**DFS**: $O(V + E)$
**A*æœç´¢**: $O(b^d)$ å…¶ä¸­ $b$ æ˜¯åˆ†æ”¯å› å­ï¼Œ$d$ æ˜¯æ·±åº¦

#### 4.2 ç©ºé—´å¤æ‚åº¦

**çº¿æ€§æœç´¢**: $O(1)$
**äºŒåˆ†æœç´¢**: $O(1)$ (è¿­ä»£), $O(\log n)$ (é€’å½’)
**å“ˆå¸Œæœç´¢**: $O(n)$
**æ ‘æœç´¢**: $O(n)$
**BFS**: $O(V)$
**DFS**: $O(V)$ (æœ€åæƒ…å†µ)
**A*æœç´¢**: $O(V)$

### 5. é€‚ç”¨åœºæ™¯

#### 5.1 å°è§„æ¨¡æ•°æ® (n < 100)

- **çº¿æ€§æœç´¢**: ç®€å•ç›´æ¥ï¼Œé€‚åˆå°æ•°ç»„
- **å“ˆå¸Œæœç´¢**: å¿«é€ŸæŸ¥æ‰¾ï¼Œé€‚åˆé¢‘ç¹æœç´¢

#### 5.2 ä¸­ç­‰è§„æ¨¡æ•°æ® (100 â‰¤ n < 10000)

- **äºŒåˆ†æœç´¢**: é«˜æ•ˆæŸ¥æ‰¾ï¼Œéœ€è¦æœ‰åºæ•°æ®
- **æ ‘æœç´¢**: åŠ¨æ€æ•°æ®ï¼Œæ”¯æŒæ’å…¥å’Œåˆ é™¤

#### 5.3 å¤§è§„æ¨¡æ•°æ® (n â‰¥ 10000)

- **å“ˆå¸Œæœç´¢**: æœ€ä½³å¹³å‡æ€§èƒ½
- **æ ‘æœç´¢**: å¹³è¡¡æ ‘ç»“æ„

#### 5.4 å›¾æ•°æ®

- **BFS**: æœ€çŸ­è·¯å¾„ï¼Œå±‚æ¬¡éå†
- **DFS**: æ·±åº¦ä¼˜å…ˆï¼Œå›æº¯ç®—æ³•
- **A*æœç´¢**: å¯å‘å¼æœç´¢ï¼Œè·¯å¾„è§„åˆ’

### 6. ç®—æ³•ç‰¹æ€§

#### 6.1 ç¨³å®šæ€§

- **çº¿æ€§æœç´¢**: ç¨³å®šï¼Œè¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…
- **äºŒåˆ†æœç´¢**: ä¸ç¨³å®šï¼Œå¯èƒ½è¿”å›ä»»æ„åŒ¹é…
- **å“ˆå¸Œæœç´¢**: ä¸ç¨³å®š
- **æ ‘æœç´¢**: ä¸ç¨³å®š

#### 6.2 å†…å­˜ä½¿ç”¨

- **çº¿æ€§æœç´¢**: æœ€å°‘å†…å­˜
- **å“ˆå¸Œæœç´¢**: æœ€å¤šå†…å­˜
- **æ ‘æœç´¢**: ä¸­ç­‰å†…å­˜

## ğŸ”— ç›¸å…³é“¾æ¥

- [æ’åºç®—æ³•](./06-01-01-æ’åºç®—æ³•.md)
- [å›¾ç®—æ³•](./06-01-03-å›¾ç®—æ³•.md)
- [ç®—æ³•ç†è®º](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., et al. (2009). "Introduction to Algorithms". MIT Press.
2. Knuth, D. E. (1998). "The Art of Computer Programming, Volume 3: Sorting and Searching". Addison-Wesley.
3. Russell, S., & Norvig, P. (2010). "Artificial Intelligence: A Modern Approach". Prentice Hall.

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant
