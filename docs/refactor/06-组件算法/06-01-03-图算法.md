# å›¾ç®—æ³•

## ğŸ“‹ æ¦‚è¿°

å›¾ç®—æ³•æ˜¯è§£å†³å›¾è®ºé—®é¢˜çš„ç®—æ³•é›†åˆï¼ŒåŒ…æ‹¬å›¾çš„éå†ã€æœ€çŸ­è·¯å¾„ã€æœ€å°ç”Ÿæˆæ ‘ã€ç½‘ç»œæµç­‰ã€‚æœ¬æ–‡æ¡£æä¾›å›¾ç®—æ³•çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å›¾ç®—æ³•å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å›¾äº”å…ƒç»„**:
$$G = (V, E, W, D, T)$$

å…¶ä¸­ï¼š
- $V = \{v_1, v_2, ..., v_n\}$ æ˜¯é¡¶ç‚¹é›†åˆ
- $E = \{e_1, e_2, ..., e_m\}$ æ˜¯è¾¹é›†åˆ
- $W: E \rightarrow \mathbb{R}$ æ˜¯æƒé‡å‡½æ•°
- $D: V \times V \rightarrow \{true, false\}$ æ˜¯å¯è¾¾æ€§å‡½æ•°
- $T: V \rightarrow \{tree, back, forward, cross\}$ æ˜¯è¾¹ç±»å‹å‡½æ•°

#### 1.2 ç®—æ³•åˆ†ç±»

**éå†ç®—æ³•**: $\text{visit}(v) \text{ è®¿é—®é¡¶ç‚¹ } v$
**è·¯å¾„ç®—æ³•**: $\text{find\_path}(s, t) \text{ å¯»æ‰¾ä» } s \text{ åˆ° } t \text{ çš„è·¯å¾„}$
**è¿é€šæ€§ç®—æ³•**: $\text{connected}(G) \text{ åˆ¤æ–­å›¾çš„è¿é€šæ€§}$
**åŒ¹é…ç®—æ³•**: $\text{matching}(G) \text{ å¯»æ‰¾æœ€å¤§åŒ¹é…}$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Set, Optional, Any, Tuple, Callable
from collections import defaultdict, deque
import time
import uuid
import asyncio
import json
import logging
import threading
from concurrent.futures import ThreadPoolExecutor
import heapq
import math
import random
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EdgeType(Enum):
    """è¾¹ç±»å‹æšä¸¾"""
    TREE = "tree"
    BACK = "back"
    FORWARD = "forward"
    CROSS = "cross"

class GraphType(Enum):
    """å›¾ç±»å‹æšä¸¾"""
    UNDIRECTED = "undirected"
    DIRECTED = "directed"
    WEIGHTED = "weighted"
    UNWEIGHTED = "unweighted"

@dataclass
class Vertex:
    """é¡¶ç‚¹"""
    id: str
    data: Any = None
    visited: bool = False
    distance: float = float('inf')
    predecessor: Optional[str] = None
    discovery_time: int = 0
    finish_time: int = 0
    color: str = "white"  # white, gray, black
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Edge:
    """è¾¹"""
    source: str
    target: str
    weight: float = 1.0
    edge_type: EdgeType = EdgeType.TREE
    
    def __post_init__(self):
        if self.weight < 0:
            raise ValueError("Edge weight cannot be negative")

class Graph:
    """å›¾æ•°æ®ç»“æ„"""
    
    def __init__(self, graph_type: GraphType = GraphType.UNDIRECTED):
        self.graph_type = graph_type
        self.vertices: Dict[str, Vertex] = {}
        self.edges: Dict[str, Edge] = {}
        self.adjacency_list: Dict[str, List[str]] = defaultdict(list)
        self.adjacency_matrix: Optional[np.ndarray] = None
        self.edge_weights: Dict[Tuple[str, str], float] = {}
    
    def add_vertex(self, vertex_id: str, data: Any = None) -> Vertex:
        """æ·»åŠ é¡¶ç‚¹"""
        if vertex_id not in self.vertices:
            vertex = Vertex(id=vertex_id, data=data)
            self.vertices[vertex_id] = vertex
        return self.vertices[vertex_id]
    
    def add_edge(self, source: str, target: str, weight: float = 1.0) -> Edge:
        """æ·»åŠ è¾¹"""
        # ç¡®ä¿é¡¶ç‚¹å­˜åœ¨
        if source not in self.vertices:
            self.add_vertex(source)
        if target not in self.vertices:
            self.add_vertex(target)
        
        # åˆ›å»ºè¾¹
        edge_id = f"{source}->{target}"
        edge = Edge(source=source, target=target, weight=weight)
        self.edges[edge_id] = edge
        
        # æ›´æ–°é‚»æ¥è¡¨
        self.adjacency_list[source].append(target)
        if self.graph_type == GraphType.UNDIRECTED:
            self.adjacency_list[target].append(source)
        
        # æ›´æ–°æƒé‡
        self.edge_weights[(source, target)] = weight
        if self.graph_type == GraphType.UNDIRECTED:
            self.edge_weights[(target, source)] = weight
        
        return edge
    
    def remove_vertex(self, vertex_id: str):
        """ç§»é™¤é¡¶ç‚¹"""
        if vertex_id in self.vertices:
            # ç§»é™¤ç›¸å…³è¾¹
            edges_to_remove = []
            for edge_id, edge in self.edges.items():
                if edge.source == vertex_id or edge.target == vertex_id:
                    edges_to_remove.append(edge_id)
            
            for edge_id in edges_to_remove:
                del self.edges[edge_id]
            
            # ä»é‚»æ¥è¡¨ä¸­ç§»é™¤
            if vertex_id in self.adjacency_list:
                del self.adjacency_list[vertex_id]
            
            # ä»å…¶ä»–é¡¶ç‚¹çš„é‚»æ¥è¡¨ä¸­ç§»é™¤
            for adj_list in self.adjacency_list.values():
                if vertex_id in adj_list:
                    adj_list.remove(vertex_id)
            
            # ç§»é™¤é¡¶ç‚¹
            del self.vertices[vertex_id]
    
    def remove_edge(self, source: str, target: str):
        """ç§»é™¤è¾¹"""
        edge_id = f"{source}->{target}"
        if edge_id in self.edges:
            del self.edges[edge_id]
            
            # ä»é‚»æ¥è¡¨ä¸­ç§»é™¤
            if source in self.adjacency_list and target in self.adjacency_list[source]:
                self.adjacency_list[source].remove(target)
            
            if self.graph_type == GraphType.UNDIRECTED:
                if target in self.adjacency_list and source in self.adjacency_list[target]:
                    self.adjacency_list[target].remove(source)
            
            # ç§»é™¤æƒé‡
            if (source, target) in self.edge_weights:
                del self.edge_weights[(source, target)]
            if self.graph_type == GraphType.UNDIRECTED and (target, source) in self.edge_weights:
                del self.edge_weights[(target, source)]
    
    def get_neighbors(self, vertex_id: str) -> List[str]:
        """è·å–é‚»å±…"""
        return self.adjacency_list.get(vertex_id, [])
    
    def get_edge_weight(self, source: str, target: str) -> float:
        """è·å–è¾¹æƒé‡"""
        return self.edge_weights.get((source, target), float('inf'))
    
    def build_adjacency_matrix(self):
        """æ„å»ºé‚»æ¥çŸ©é˜µ"""
        vertex_ids = list(self.vertices.keys())
        n = len(vertex_ids)
        self.adjacency_matrix = np.full((n, n), float('inf'))
        
        # è®¾ç½®å¯¹è§’çº¿ä¸º0
        np.fill_diagonal(self.adjacency_matrix, 0)
        
        # è®¾ç½®è¾¹æƒé‡
        for i, source in enumerate(vertex_ids):
            for j, target in enumerate(vertex_ids):
                if (source, target) in self.edge_weights:
                    self.adjacency_matrix[i][j] = self.edge_weights[(source, target)]
    
    def get_vertex_count(self) -> int:
        """è·å–é¡¶ç‚¹æ•°é‡"""
        return len(self.vertices)
    
    def get_edge_count(self) -> int:
        """è·å–è¾¹æ•°é‡"""
        return len(self.edges)
    
    def is_connected(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦è¿é€š"""
        if not self.vertices:
            return True
        
        # ä½¿ç”¨DFSæ£€æŸ¥è¿é€šæ€§
        start_vertex = next(iter(self.vertices.keys()))
        visited = set()
        self._dfs_connected(start_vertex, visited)
        
        return len(visited) == len(self.vertices)
    
    def _dfs_connected(self, vertex_id: str, visited: Set[str]):
        """DFSæ£€æŸ¥è¿é€šæ€§"""
        visited.add(vertex_id)
        for neighbor in self.get_neighbors(vertex_id):
            if neighbor not in visited:
                self._dfs_connected(neighbor, visited)

class GraphAlgorithm(ABC):
    """å›¾ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, graph: Graph):
        self.graph = graph
        self.visited: Set[str] = set()
        self.time = 0
    
    @abstractmethod
    def execute(self, start_vertex: str = None) -> Any:
        """æ‰§è¡Œç®—æ³•"""
        pass
    
    def reset(self):
        """é‡ç½®çŠ¶æ€"""
        self.visited.clear()
        self.time = 0
        for vertex in self.graph.vertices.values():
            vertex.visited = False
            vertex.distance = float('inf')
            vertex.predecessor = None
            vertex.discovery_time = 0
            vertex.finish_time = 0
            vertex.color = "white"

class BreadthFirstSearch(GraphAlgorithm):
    """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡ŒBFS"""
        self.reset()
        
        if start_vertex is None:
            start_vertex = next(iter(self.graph.vertices.keys()))
        
        if start_vertex not in self.graph.vertices:
            return {"error": "Start vertex not found"}
        
        # åˆå§‹åŒ–èµ·å§‹é¡¶ç‚¹
        self.graph.vertices[start_vertex].distance = 0
        self.graph.vertices[start_vertex].color = "gray"
        
        # BFSé˜Ÿåˆ—
        queue = deque([start_vertex])
        self.visited.add(start_vertex)
        
        traversal_order = []
        
        while queue:
            current_vertex = queue.popleft()
            traversal_order.append(current_vertex)
            
            # å¤„ç†æ‰€æœ‰é‚»å±…
            for neighbor in self.graph.get_neighbors(current_vertex):
                if neighbor not in self.visited:
                    neighbor_vertex = self.graph.vertices[neighbor]
                    neighbor_vertex.color = "gray"
                    neighbor_vertex.distance = self.graph.vertices[current_vertex].distance + 1
                    neighbor_vertex.predecessor = current_vertex
                    
                    queue.append(neighbor)
                    self.visited.add(neighbor)
            
            # æ ‡è®°ä¸ºå·²è®¿é—®
            self.graph.vertices[current_vertex].color = "black"
        
        return {
            "traversal_order": traversal_order,
            "distances": {v_id: v.distance for v_id, v in self.graph.vertices.items()},
            "predecessors": {v_id: v.predecessor for v_id, v in self.graph.vertices.items()},
            "visited_count": len(self.visited)
        }

class DepthFirstSearch(GraphAlgorithm):
    """æ·±åº¦ä¼˜å…ˆæœç´¢"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡ŒDFS"""
        self.reset()
        
        if start_vertex is None:
            start_vertex = next(iter(self.graph.vertices.keys()))
        
        if start_vertex not in self.graph.vertices:
            return {"error": "Start vertex not found"}
        
        traversal_order = []
        discovery_times = {}
        finish_times = {}
        
        # å¯¹æ¯ä¸ªæœªè®¿é—®çš„é¡¶ç‚¹æ‰§è¡ŒDFS
        for vertex_id in self.graph.vertices:
            if vertex_id not in self.visited:
                self._dfs_visit(vertex_id, traversal_order, discovery_times, finish_times)
        
        return {
            "traversal_order": traversal_order,
            "discovery_times": discovery_times,
            "finish_times": finish_times,
            "visited_count": len(self.visited)
        }
    
    def _dfs_visit(self, vertex_id: str, traversal_order: List[str], 
                   discovery_times: Dict[str, int], finish_times: Dict[str, int]):
        """DFSè®¿é—®é¡¶ç‚¹"""
        self.visited.add(vertex_id)
        self.time += 1
        discovery_times[vertex_id] = self.time
        
        vertex = self.graph.vertices[vertex_id]
        vertex.color = "gray"
        traversal_order.append(vertex_id)
        
        # é€’å½’è®¿é—®æ‰€æœ‰é‚»å±…
        for neighbor in self.graph.get_neighbors(vertex_id):
            if neighbor not in self.visited:
                neighbor_vertex = self.graph.vertices[neighbor]
                neighbor_vertex.predecessor = vertex_id
                self._dfs_visit(neighbor, traversal_order, discovery_times, finish_times)
        
        vertex.color = "black"
        self.time += 1
        finish_times[vertex_id] = self.time

class DijkstraAlgorithm(GraphAlgorithm):
    """Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡ŒDijkstraç®—æ³•"""
        self.reset()
        
        if start_vertex is None:
            start_vertex = next(iter(self.graph.vertices.keys()))
        
        if start_vertex not in self.graph.vertices:
            return {"error": "Start vertex not found"}
        
        # åˆå§‹åŒ–
        self.graph.vertices[start_vertex].distance = 0
        
        # ä¼˜å…ˆé˜Ÿåˆ— (è·ç¦», é¡¶ç‚¹ID)
        pq = [(0, start_vertex)]
        visited = set()
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_vertex in visited:
                continue
            
            visited.add(current_vertex)
            
            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor in self.graph.get_neighbors(current_vertex):
                if neighbor in visited:
                    continue
                
                edge_weight = self.graph.get_edge_weight(current_vertex, neighbor)
                distance = current_distance + edge_weight
                
                neighbor_vertex = self.graph.vertices[neighbor]
                if distance < neighbor_vertex.distance:
                    neighbor_vertex.distance = distance
                    neighbor_vertex.predecessor = current_vertex
                    heapq.heappush(pq, (distance, neighbor))
        
        return {
            "distances": {v_id: v.distance for v_id, v in self.graph.vertices.items()},
            "predecessors": {v_id: v.predecessor for v_id, v in self.graph.vertices.items()},
            "visited_count": len(visited)
        }
    
    def get_shortest_path(self, start_vertex: str, end_vertex: str) -> List[str]:
        """è·å–æœ€çŸ­è·¯å¾„"""
        result = self.execute(start_vertex)
        
        if "error" in result:
            return []
        
        path = []
        current = end_vertex
        
        while current is not None:
            path.append(current)
            current = result["predecessors"][current]
        
        path.reverse()
        return path if path[0] == start_vertex else []

class BellmanFordAlgorithm(GraphAlgorithm):
    """Bellman-Fordç®—æ³•"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡ŒBellman-Fordç®—æ³•"""
        self.reset()
        
        if start_vertex is None:
            start_vertex = next(iter(self.graph.vertices.keys()))
        
        if start_vertex not in self.graph.vertices:
            return {"error": "Start vertex not found"}
        
        # åˆå§‹åŒ–
        self.graph.vertices[start_vertex].distance = 0
        
        # æ¾å¼›æ“ä½œ
        vertex_count = self.graph.get_vertex_count()
        for _ in range(vertex_count - 1):
            for edge in self.graph.edges.values():
                source_vertex = self.graph.vertices[edge.source]
                target_vertex = self.graph.vertices[edge.target]
                
                if source_vertex.distance + edge.weight < target_vertex.distance:
                    target_vertex.distance = source_vertex.distance + edge.weight
                    target_vertex.predecessor = edge.source
        
        # æ£€æŸ¥è´Ÿç¯
        has_negative_cycle = False
        for edge in self.graph.edges.values():
            source_vertex = self.graph.vertices[edge.source]
            target_vertex = self.graph.vertices[edge.target]
            
            if source_vertex.distance + edge.weight < target_vertex.distance:
                has_negative_cycle = True
                break
        
        return {
            "distances": {v_id: v.distance for v_id, v in self.graph.vertices.items()},
            "predecessors": {v_id: v.predecessor for v_id, v in self.graph.vertices.items()},
            "has_negative_cycle": has_negative_cycle
        }

class FloydWarshallAlgorithm(GraphAlgorithm):
    """Floyd-Warshallç®—æ³•"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡ŒFloyd-Warshallç®—æ³•"""
        # æ„å»ºé‚»æ¥çŸ©é˜µ
        self.graph.build_adjacency_matrix()
        
        if self.graph.adjacency_matrix is None:
            return {"error": "Failed to build adjacency matrix"}
        
        n = len(self.graph.vertices)
        vertex_ids = list(self.graph.vertices.keys())
        
        # åˆå§‹åŒ–è·ç¦»çŸ©é˜µå’Œå‰é©±çŸ©é˜µ
        distances = self.graph.adjacency_matrix.copy()
        predecessors = np.full((n, n), -1, dtype=int)
        
        # è®¾ç½®å‰é©±çŸ©é˜µ
        for i in range(n):
            for j in range(n):
                if i != j and distances[i][j] != float('inf'):
                    predecessors[i][j] = i
        
        # Floyd-Warshallç®—æ³•
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if distances[i][k] + distances[k][j] < distances[i][j]:
                        distances[i][j] = distances[i][k] + distances[k][j]
                        predecessors[i][j] = predecessors[k][j]
        
        return {
            "distances": distances,
            "predecessors": predecessors,
            "vertex_ids": vertex_ids
        }
    
    def get_shortest_path(self, start_vertex: str, end_vertex: str) -> List[str]:
        """è·å–æœ€çŸ­è·¯å¾„"""
        result = self.execute()
        
        if "error" in result:
            return []
        
        vertex_ids = result["vertex_ids"]
        predecessors = result["predecessors"]
        
        start_idx = vertex_ids.index(start_vertex)
        end_idx = vertex_ids.index(end_vertex)
        
        if predecessors[start_idx][end_idx] == -1:
            return []  # æ²¡æœ‰è·¯å¾„
        
        path = [end_vertex]
        current_idx = end_idx
        
        while current_idx != start_idx:
            current_idx = predecessors[start_idx][current_idx]
            path.append(vertex_ids[current_idx])
        
        path.reverse()
        return path

class KruskalAlgorithm(GraphAlgorithm):
    """Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡ŒKruskalç®—æ³•"""
        # åªé€‚ç”¨äºæ— å‘å›¾
        if self.graph.graph_type == GraphType.DIRECTED:
            return {"error": "Kruskal algorithm only works for undirected graphs"}
        
        # åˆå§‹åŒ–å¹¶æŸ¥é›†
        parent = {vertex_id: vertex_id for vertex_id in self.graph.vertices}
        rank = {vertex_id: 0 for vertex_id in self.graph.vertices}
        
        def find(vertex_id: str) -> str:
            """æŸ¥æ‰¾æ ¹èŠ‚ç‚¹"""
            if parent[vertex_id] != vertex_id:
                parent[vertex_id] = find(parent[vertex_id])
            return parent[vertex_id]
        
        def union(vertex1: str, vertex2: str):
            """åˆå¹¶ä¸¤ä¸ªé›†åˆ"""
            root1 = find(vertex1)
            root2 = find(vertex2)
            
            if root1 != root2:
                if rank[root1] < rank[root2]:
                    parent[root1] = root2
                elif rank[root1] > rank[root2]:
                    parent[root2] = root1
                else:
                    parent[root2] = root1
                    rank[root1] += 1
        
        # æŒ‰æƒé‡æ’åºè¾¹
        sorted_edges = sorted(self.graph.edges.values(), key=lambda e: e.weight)
        
        mst_edges = []
        total_weight = 0
        
        for edge in sorted_edges:
            if find(edge.source) != find(edge.target):
                union(edge.source, edge.target)
                mst_edges.append(edge)
                total_weight += edge.weight
        
        return {
            "mst_edges": [(e.source, e.target, e.weight) for e in mst_edges],
            "total_weight": total_weight,
            "edge_count": len(mst_edges)
        }

class PrimAlgorithm(GraphAlgorithm):
    """Primæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡ŒPrimç®—æ³•"""
        # åªé€‚ç”¨äºæ— å‘å›¾
        if self.graph.graph_type == GraphType.DIRECTED:
            return {"error": "Prim algorithm only works for undirected graphs"}
        
        if start_vertex is None:
            start_vertex = next(iter(self.graph.vertices.keys()))
        
        if start_vertex not in self.graph.vertices:
            return {"error": "Start vertex not found"}
        
        # åˆå§‹åŒ–
        visited = set()
        mst_edges = []
        total_weight = 0
        
        # ä¼˜å…ˆé˜Ÿåˆ— (æƒé‡, æºé¡¶ç‚¹, ç›®æ ‡é¡¶ç‚¹)
        pq = [(0, start_vertex, start_vertex)]
        
        while pq and len(visited) < len(self.graph.vertices):
            weight, source, target = heapq.heappop(pq)
            
            if target in visited:
                continue
            
            visited.add(target)
            
            if source != target:
                mst_edges.append((source, target, weight))
                total_weight += weight
            
            # æ·»åŠ æ–°é‚»å±…åˆ°ä¼˜å…ˆé˜Ÿåˆ—
            for neighbor in self.graph.get_neighbors(target):
                if neighbor not in visited:
                    edge_weight = self.graph.get_edge_weight(target, neighbor)
                    heapq.heappush(pq, (edge_weight, target, neighbor))
        
        return {
            "mst_edges": mst_edges,
            "total_weight": total_weight,
            "edge_count": len(mst_edges)
        }

class TopologicalSort(GraphAlgorithm):
    """æ‹“æ‰‘æ’åº"""
    
    def execute(self, start_vertex: str = None) -> Dict[str, Any]:
        """æ‰§è¡Œæ‹“æ‰‘æ’åº"""
        # åªé€‚ç”¨äºæœ‰å‘å›¾
        if self.graph.graph_type == GraphType.UNDIRECTED:
            return {"error": "Topological sort only works for directed graphs"}
        
        # è®¡ç®—å…¥åº¦
        in_degree = {vertex_id: 0 for vertex_id in self.graph.vertices}
        for edge in self.graph.edges.values():
            in_degree[edge.target] += 1
        
        # é˜Ÿåˆ—ï¼ˆå…¥åº¦ä¸º0çš„é¡¶ç‚¹ï¼‰
        queue = deque([v_id for v_id, degree in in_degree.items() if degree == 0])
        topological_order = []
        
        while queue:
            current_vertex = queue.popleft()
            topological_order.append(current_vertex)
            
            # å‡å°‘é‚»å±…çš„å…¥åº¦
            for neighbor in self.graph.get_neighbors(current_vertex):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰ç¯
        has_cycle = len(topological_order) != len(self.graph.vertices)
        
        return {
            "topological_order": topological_order,
            "has_cycle": has_cycle,
            "sorted_count": len(topological_order)
        }

class GraphAlgorithmBenchmark:
    """å›¾ç®—æ³•åŸºå‡†æµ‹è¯•"""
    
    def __init__(self):
        self.algorithms = {
            "BFS": BreadthFirstSearch,
            "DFS": DepthFirstSearch,
            "Dijkstra": DijkstraAlgorithm,
            "Bellman-Ford": BellmanFordAlgorithm,
            "Floyd-Warshall": FloydWarshallAlgorithm,
            "Kruskal": KruskalAlgorithm,
            "Prim": PrimAlgorithm,
            "Topological Sort": TopologicalSort
        }
    
    def generate_test_graph(self, vertex_count: int, edge_probability: float = 0.3, 
                           graph_type: GraphType = GraphType.UNDIRECTED) -> Graph:
        """ç”Ÿæˆæµ‹è¯•å›¾"""
        graph = Graph(graph_type)
        
        # æ·»åŠ é¡¶ç‚¹
        for i in range(vertex_count):
            graph.add_vertex(f"v{i}")
        
        # æ·»åŠ è¾¹
        vertex_ids = list(graph.vertices.keys())
        for i in range(vertex_count):
            for j in range(i + 1, vertex_count):
                if random.random() < edge_probability:
                    weight = random.uniform(1, 10)
                    graph.add_edge(vertex_ids[i], vertex_ids[j], weight)
        
        return graph
    
    def benchmark(self, vertex_counts: List[int], edge_probability: float = 0.3) -> Dict[str, List[Dict]]:
        """è¿è¡ŒåŸºå‡†æµ‹è¯•"""
        results = defaultdict(list)
        
        for vertex_count in vertex_counts:
            print(f"Testing with {vertex_count} vertices...")
            
            # ç”Ÿæˆæµ‹è¯•å›¾
            graph = self.generate_test_graph(vertex_count, edge_probability)
            
            for name, algorithm_class in self.algorithms.items():
                try:
                    # è·³è¿‡ä¸å…¼å®¹çš„ç®—æ³•
                    if name == "Topological Sort" and graph.graph_type == GraphType.UNDIRECTED:
                        continue
                    if name in ["Kruskal", "Prim"] and graph.graph_type == GraphType.DIRECTED:
                        continue
                    
                    start_time = time.time()
                    algorithm = algorithm_class(graph)
                    result = algorithm.execute()
                    end_time = time.time()
                    
                    results[name].append({
                        "vertex_count": vertex_count,
                        "edge_count": graph.get_edge_count(),
                        "execution_time": end_time - start_time,
                        "result": result
                    })
                    
                    print(f"  {name}: {end_time - start_time:.6f}s")
                except Exception as e:
                    print(f"  {name}: Error - {e}")
        
        return results
    
    def plot_performance(self, results: Dict[str, List[Dict]], metric: str = "time"):
        """ç»˜åˆ¶æ€§èƒ½å›¾è¡¨"""
        plt.figure(figsize=(12, 8))
        
        for name, result_list in results.items():
            if not result_list:
                continue
            
            vertex_counts = [r["vertex_count"] for r in result_list]
            if metric == "time":
                values = [r["execution_time"] for r in result_list]
                ylabel = "Execution Time (seconds)"
            elif metric == "edges":
                values = [r["edge_count"] for r in result_list]
                ylabel = "Edge Count"
            else:
                raise ValueError(f"Unknown metric: {metric}")
            
            plt.plot(vertex_counts, values, marker='o', label=name)
        
        plt.xlabel("Vertex Count")
        plt.ylabel(ylabel)
        plt.title(f"Graph Algorithm Performance - {metric.title()}")
        plt.legend()
        plt.grid(True)
        plt.xscale('log')
        if metric == "time":
            plt.yscale('log')
        plt.tight_layout()
        plt.savefig(f"graph_algorithm_performance_{metric}.png", dpi=300, bbox_inches='tight')
        plt.show()
    
    def generate_report(self, results: Dict[str, List[Dict]]) -> Dict[str, Any]:
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        report = {
            "summary": {},
            "algorithms": {}
        }
        
        total_tests = 0
        total_time = 0
        
        for name, result_list in results.items():
            if not result_list:
                continue
            
            algorithm_report = {
                "total_tests": len(result_list),
                "average_time": sum(r["execution_time"] for r in result_list) / len(result_list),
                "average_vertex_count": sum(r["vertex_count"] for r in result_list) / len(result_list),
                "average_edge_count": sum(r["edge_count"] for r in result_list) / len(result_list),
                "best_time": min(r["execution_time"] for r in result_list),
                "worst_time": max(r["execution_time"] for r in result_list),
                "results": [
                    {
                        "vertex_count": r["vertex_count"],
                        "edge_count": r["edge_count"],
                        "execution_time": r["execution_time"]
                    }
                    for r in result_list
                ]
            }
            
            report["algorithms"][name] = algorithm_report
            total_tests += len(result_list)
            total_time += sum(r["execution_time"] for r in result_list)
        
        report["summary"] = {
            "total_algorithms": len(results),
            "total_tests": total_tests,
            "total_time": total_time,
            "average_time_per_test": total_time / total_tests if total_tests > 0 else 0
        }
        
        return report
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
def demonstrate_graph_algorithms():
    """æ¼”ç¤ºå›¾ç®—æ³•"""
    print("=== Graph Algorithms Demo ===")
    
    # åˆ›å»ºæµ‹è¯•å›¾
    graph = Graph(GraphType.UNDIRECTED)
    
    # æ·»åŠ é¡¶ç‚¹
    vertices = ["A", "B", "C", "D", "E", "F"]
    for vertex in vertices:
        graph.add_vertex(vertex)
    
    # æ·»åŠ è¾¹
    edges = [
        ("A", "B", 4), ("A", "C", 2), ("B", "C", 1),
        ("B", "D", 5), ("C", "D", 8), ("C", "E", 10),
        ("D", "E", 2), ("D", "F", 6), ("E", "F", 3)
    ]
    
    for source, target, weight in edges:
        graph.add_edge(source, target, weight)
    
    print(f"Graph created with {graph.get_vertex_count()} vertices and {graph.get_edge_count()} edges")
    
    # æµ‹è¯•BFS
    print("\n--- Breadth First Search ---")
    bfs = BreadthFirstSearch(graph)
    bfs_result = bfs.execute("A")
    print(f"BFS traversal order: {bfs_result['traversal_order']}")
    print(f"Distances: {bfs_result['distances']}")
    
    # æµ‹è¯•DFS
    print("\n--- Depth First Search ---")
    dfs = DepthFirstSearch(graph)
    dfs_result = dfs.execute("A")
    print(f"DFS traversal order: {dfs_result['traversal_order']}")
    print(f"Discovery times: {dfs_result['discovery_times']}")
    
    # æµ‹è¯•Dijkstra
    print("\n--- Dijkstra Shortest Path ---")
    dijkstra = DijkstraAlgorithm(graph)
    dijkstra_result = dijkstra.execute("A")
    print(f"Shortest distances: {dijkstra_result['distances']}")
    
    # è·å–æœ€çŸ­è·¯å¾„
    shortest_path = dijkstra.get_shortest_path("A", "F")
    print(f"Shortest path from A to F: {' -> '.join(shortest_path)}")
    
    # æµ‹è¯•Kruskal
    print("\n--- Kruskal Minimum Spanning Tree ---")
    kruskal = KruskalAlgorithm(graph)
    kruskal_result = kruskal.execute()
    print(f"MST edges: {kruskal_result['mst_edges']}")
    print(f"Total weight: {kruskal_result['total_weight']}")
    
    # æµ‹è¯•Prim
    print("\n--- Prim Minimum Spanning Tree ---")
    prim = PrimAlgorithm(graph)
    prim_result = prim.execute("A")
    print(f"MST edges: {prim_result['mst_edges']}")
    print(f"Total weight: {prim_result['total_weight']}")
    
    # åˆ›å»ºæœ‰å‘å›¾è¿›è¡Œæ‹“æ‰‘æ’åº
    print("\n--- Topological Sort (Directed Graph) ---")
    directed_graph = Graph(GraphType.DIRECTED)
    
    # æ·»åŠ é¡¶ç‚¹
    for vertex in ["A", "B", "C", "D", "E"]:
        directed_graph.add_vertex(vertex)
    
    # æ·»åŠ æœ‰å‘è¾¹
    directed_edges = [
        ("A", "B"), ("A", "C"), ("B", "D"), ("C", "D"), ("D", "E")
    ]
    
    for source, target in directed_edges:
        directed_graph.add_edge(source, target)
    
    topological = TopologicalSort(directed_graph)
    topo_result = topological.execute()
    print(f"Topological order: {topo_result['topological_order']}")
    print(f"Has cycle: {topo_result['has_cycle']}")
    
    # åŸºå‡†æµ‹è¯•
    print("\n=== Performance Benchmark ===")
    benchmark = GraphAlgorithmBenchmark()
    
    # æµ‹è¯•ä¸åŒå¤§å°çš„å›¾
    vertex_counts = [10, 50, 100]
    results = benchmark.benchmark(vertex_counts, edge_probability=0.3)
    
    # ç»˜åˆ¶æ€§èƒ½å›¾è¡¨
    benchmark.plot_performance(results, "time")
    
    # ç”ŸæˆæŠ¥å‘Š
    report = benchmark.generate_report(results)
    print(f"\nBenchmark Report:")
    print(f"Total algorithms tested: {report['summary']['total_algorithms']}")
    print(f"Total tests: {report['summary']['total_tests']}")
    print(f"Total time: {report['summary']['total_time']:.6f}s")
    
    # æ˜¾ç¤ºæ¯ä¸ªç®—æ³•çš„å¹³å‡æ€§èƒ½
    print("\nAlgorithm Performance Summary:")
    for name, algo_report in report["algorithms"].items():
        print(f"{name}:")
        print(f"  Average time: {algo_report['average_time']:.6f}s")
        print(f"  Average vertices: {algo_report['average_vertex_count']:.0f}")
        print(f"  Average edges: {algo_report['average_edge_count']:.0f}")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    demonstrate_graph_algorithms()
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**éå†ç®—æ³•**:
- BFS: $O(V + E)$
- DFS: $O(V + E)$

**æœ€çŸ­è·¯å¾„ç®—æ³•**:
- Dijkstra: $O((V + E) \log V)$ (ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—)
- Bellman-Ford: $O(VE)$
- Floyd-Warshall: $O(V^3)$

**æœ€å°ç”Ÿæˆæ ‘ç®—æ³•**:
- Kruskal: $O(E \log E)$
- Prim: $O((V + E) \log V)$

**æ‹“æ‰‘æ’åº**: $O(V + E)$

#### 4.2 ç©ºé—´å¤æ‚åº¦

**éå†ç®—æ³•**: $O(V)$
**æœ€çŸ­è·¯å¾„ç®—æ³•**: $O(V)$
**æœ€å°ç”Ÿæˆæ ‘ç®—æ³•**: $O(V)$
**Floyd-Warshall**: $O(V^2)$

### 5. ç®—æ³•ç‰¹æ€§

#### 5.1 é€‚ç”¨åœºæ™¯

**BFS**: æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰ã€å±‚æ¬¡éå†
**DFS**: æ·±åº¦ä¼˜å…ˆæœç´¢ã€æ‹“æ‰‘æ’åºã€è¿é€šåˆ†é‡
**Dijkstra**: å•æºæœ€çŸ­è·¯å¾„ï¼ˆæ— è´Ÿæƒï¼‰
**Bellman-Ford**: å•æºæœ€çŸ­è·¯å¾„ï¼ˆæœ‰è´Ÿæƒï¼‰
**Floyd-Warshall**: å…¨æºæœ€çŸ­è·¯å¾„
**Kruskal**: æœ€å°ç”Ÿæˆæ ‘
**Prim**: æœ€å°ç”Ÿæˆæ ‘
**æ‹“æ‰‘æ’åº**: æœ‰å‘æ— ç¯å›¾çš„æ’åº

#### 5.2 ç®—æ³•é€‰æ‹©

**å°è§„æ¨¡å›¾**: æ‰€æœ‰ç®—æ³•éƒ½é€‚ç”¨
**ä¸­ç­‰è§„æ¨¡å›¾**: é¿å…Floyd-Warshall
**å¤§è§„æ¨¡å›¾**: ä¼˜å…ˆé€‰æ‹©çº¿æ€§æˆ–æ¥è¿‘çº¿æ€§çš„ç®—æ³•

## ğŸ”— ç›¸å…³é“¾æ¥

- [æ’åºç®—æ³•](./06-01-01-æ’åºç®—æ³•.md)
- [æœç´¢ç®—æ³•](./06-01-02-æœç´¢ç®—æ³•.md)
- [åŠ¨æ€è§„åˆ’](./06-01-04-åŠ¨æ€è§„åˆ’.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., et al. (2009). "Introduction to Algorithms". MIT Press.
2. Sedgewick, R., & Wayne, K. (2011). "Algorithms". Addison-Wesley.
3. Tarjan, R. E. (1983). "Data Structures and Network Algorithms". SIAM.

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant 