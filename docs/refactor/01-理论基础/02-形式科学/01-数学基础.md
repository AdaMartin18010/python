# 数学基础

## 1. 概念定义

### 1.1 数学在软件工程中的作用

数学为软件工程提供了严格的逻辑基础、形式化方法和分析工具。从算法复杂度到程序正确性证明，数学贯穿软件开发的各个层面。

**形式化定义**：
设 $\mathcal{M}$ 为数学方法集合，$\mathcal{S}$ 为软件问题集合，则数学在软件工程中的作用可定义为：

$$\mathcal{A}: \mathcal{M} \times \mathcal{S} \to \mathcal{R}$$

其中 $\mathcal{R}$ 为结果集合，$\mathcal{A}(m, s)$ 表示使用数学方法 $m$ 解决软件问题 $s$ 的结果。

### 1.2 数学分支与软件工程

**Python实现**：

```python
from typing import Dict, List, Any, Set, Callable
from dataclasses import dataclass
from enum import Enum
import math
import numpy as np

class MathBranch(Enum):
    """数学分支"""
    SET_THEORY = "set_theory"
    LOGIC = "logic"
    ALGEBRA = "algebra"
    CALCULUS = "calculus"
    PROBABILITY = "probability"
    GRAPH_THEORY = "graph_theory"
    NUMBER_THEORY = "number_theory"

@dataclass
class MathematicalMethod:
    """数学方法"""
    name: str
    branch: MathBranch
    description: str
    applications: List[str]
    complexity: float  # 0-1
    
    def get_applicability(self, problem_type: str) -> float:
        """获取适用性"""
        return 1.0 if problem_type in self.applications else 0.0

class MathFoundation:
    """数学基础"""
    
    def __init__(self):
        self.methods: Dict[MathBranch, List[MathematicalMethod]] = {
            branch: [] for branch in MathBranch
        }
        self._initialize_methods()
    
    def _initialize_methods(self):
        """初始化数学方法"""
        # 集合论方法
        self.methods[MathBranch.SET_THEORY].extend([
            MathematicalMethod(
                "集合运算", MathBranch.SET_THEORY,
                "集合的交、并、差、补运算",
                ["数据结构", "数据库查询", "算法设计"],
                0.3
            ),
            MathematicalMethod(
                "关系理论", MathBranch.SET_THEORY,
                "二元关系、等价关系、偏序关系",
                ["数据库设计", "类型系统", "形式化规范"],
                0.6
            )
        ])
        
        # 逻辑方法
        self.methods[MathBranch.LOGIC].extend([
            MathematicalMethod(
                "命题逻辑", MathBranch.LOGIC,
                "命题、逻辑运算、真值表",
                ["程序逻辑", "条件判断", "布尔运算"],
                0.4
            ),
            MathematicalMethod(
                "谓词逻辑", MathBranch.LOGIC,
                "量词、谓词、形式化证明",
                ["程序验证", "定理证明", "形式化方法"],
                0.8
            )
        ])
        
        # 代数方法
        self.methods[MathBranch.ALGEBRA].extend([
            MathematicalMethod(
                "群论", MathBranch.ALGEBRA,
                "群、环、域的基本理论",
                ["密码学", "编码理论", "抽象代数"],
                0.7
            ),
            MathematicalMethod(
                "线性代数", MathBranch.ALGEBRA,
                "向量、矩阵、线性变换",
                ["机器学习", "图形学", "数值计算"],
                0.6
            )
        ])
    
    def get_methods_for_problem(self, problem_type: str) -> List[MathematicalMethod]:
        """获取适用于特定问题的数学方法"""
        applicable_methods = []
        for branch_methods in self.methods.values():
            for method in branch_methods:
                if method.get_applicability(problem_type) > 0:
                    applicable_methods.append(method)
        return applicable_methods
    
    def analyze_problem(self, problem: Dict[str, Any]) -> Dict[str, Any]:
        """分析问题的数学需求"""
        problem_type = problem.get('type', 'general')
        applicable_methods = self.get_methods_for_problem(problem_type)
        
        return {
            'problem_type': problem_type,
            'applicable_methods': applicable_methods,
            'complexity_score': sum(m.complexity for m in applicable_methods) / len(applicable_methods) if applicable_methods else 0.0,
            'recommended_branch': max(
                MathBranch,
                key=lambda b: len([m for m in applicable_methods if m.branch == b])
            )
        }

# 示例：数学基础应用
def demonstrate_math_foundation():
    """演示数学基础"""
    foundation = MathFoundation()
    
    # 分析不同类型的问题
    problems = [
        {'type': '数据结构', 'description': '设计高效的数据结构'},
        {'type': '算法设计', 'description': '设计优化算法'},
        {'type': '程序验证', 'description': '证明程序正确性'},
        {'type': '机器学习', 'description': '实现机器学习算法'}
    ]
    
    for problem in problems:
        analysis = foundation.analyze_problem(problem)
        print(f"\nProblem: {problem['description']}")
        print(f"Type: {analysis['problem_type']}")
        print(f"Complexity Score: {analysis['complexity_score']:.3f}")
        print(f"Recommended Branch: {analysis['recommended_branch'].value}")
        print(f"Applicable Methods: {len(analysis['applicable_methods'])}")
    
    return foundation

if __name__ == "__main__":
    foundation = demonstrate_math_foundation()
```

## 2. 数论基础

### 2.1 基本数论概念

数论为密码学、算法设计和数值计算提供基础：

**Python实现**：

```python
from typing import List, Tuple, Optional
import math

class NumberTheory:
    """数论基础"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """最大公约数"""
        while b:
            a, b = b, a % b
        return a
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """最小公倍数"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """判断是否为素数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def prime_factors(n: int) -> List[int]:
        """质因数分解"""
        factors = []
        d = 2
        while n > 1:
            while n % d == 0:
                factors.append(d)
                n //= d
            d += 1
            if d * d > n:
                if n > 1:
                    factors.append(n)
                break
        return factors
    
    @staticmethod
    def euler_totient(n: int) -> int:
        """欧拉函数"""
        result = n
        for i in range(2, int(math.sqrt(n)) + 1):
            if n % i == 0:
                while n % i == 0:
                    n //= i
                result -= result // i
        if n > 1:
            result -= result // n
        return result
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """扩展欧几里得算法"""
        if a == 0:
            return b, 0, 1
        gcd, x1, y1 = NumberTheory.extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y
    
    @staticmethod
    def mod_inverse(a: int, m: int) -> Optional[int]:
        """模逆元"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            return None
        return (x % m + m) % m

# 示例：数论应用
def demonstrate_number_theory():
    """演示数论应用"""
    nt = NumberTheory()
    
    # 基本运算
    a, b = 48, 18
    print(f"GCD({a}, {b}) = {nt.gcd(a, b)}")
    print(f"LCM({a}, {b}) = {nt.lcm(a, b)}")
    
    # 素数判断
    numbers = [2, 3, 4, 17, 25, 29]
    for n in numbers:
        print(f"{n} is prime: {nt.is_prime(n)}")
    
    # 质因数分解
    n = 84
    factors = nt.prime_factors(n)
    print(f"Prime factors of {n}: {factors}")
    
    # 欧拉函数
    phi = nt.euler_totient(12)
    print(f"φ(12) = {phi}")
    
    # 模逆元
    a, m = 7, 11
    inv = nt.mod_inverse(a, m)
    print(f"Modular inverse of {a} mod {m}: {inv}")
    
    return nt

if __name__ == "__main__":
    nt = demonstrate_number_theory()
```

## 3. 代数基础

### 3.1 线性代数

线性代数在机器学习、图形学和数值计算中广泛应用：

**Python实现**：

```python
import numpy as np
from typing import List, Tuple, Optional

class LinearAlgebra:
    """线性代数基础"""
    
    @staticmethod
    def matrix_rank(matrix: np.ndarray) -> int:
        """矩阵秩"""
        return np.linalg.matrix_rank(matrix)
    
    @staticmethod
    def determinant(matrix: np.ndarray) -> float:
        """行列式"""
        return np.linalg.det(matrix)
    
    @staticmethod
    def eigenvalues(matrix: np.ndarray) -> np.ndarray:
        """特征值"""
        return np.linalg.eigvals(matrix)
    
    @staticmethod
    def eigenvectors(matrix: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """特征值和特征向量"""
        return np.linalg.eig(matrix)
    
    @staticmethod
    def svd(matrix: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """奇异值分解"""
        return np.linalg.svd(matrix)
    
    @staticmethod
    def solve_linear_system(A: np.ndarray, b: np.ndarray) -> np.ndarray:
        """解线性方程组"""
        return np.linalg.solve(A, b)
    
    @staticmethod
    def least_squares(A: np.ndarray, b: np.ndarray) -> np.ndarray:
        """最小二乘解"""
        return np.linalg.lstsq(A, b, rcond=None)[0]

class VectorSpace:
    """向量空间"""
    
    def __init__(self, dimension: int):
        self.dimension = dimension
    
    def is_linear_independent(self, vectors: List[np.ndarray]) -> bool:
        """判断向量是否线性无关"""
        if len(vectors) == 0:
            return True
        
        # 构建矩阵
        matrix = np.column_stack(vectors)
        rank = LinearAlgebra.matrix_rank(matrix)
        return rank == len(vectors)
    
    def span(self, vectors: List[np.ndarray]) -> np.ndarray:
        """生成子空间"""
        if not vectors:
            return np.zeros((self.dimension, 0))
        
        matrix = np.column_stack(vectors)
        # 使用SVD找到基
        U, S, Vt = LinearAlgebra.svd(matrix)
        # 保留非零奇异值对应的列
        rank = np.sum(S > 1e-10)
        return U[:, :rank]
    
    def projection(self, vector: np.ndarray, subspace: np.ndarray) -> np.ndarray:
        """向量在子空间上的投影"""
        # 投影公式: P = A(A^T A)^(-1) A^T
        A = subspace
        P = A @ np.linalg.inv(A.T @ A) @ A.T
        return P @ vector

# 示例：线性代数应用
def demonstrate_linear_algebra():
    """演示线性代数应用"""
    la = LinearAlgebra()
    
    # 创建矩阵
    A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    b = np.array([1, 2, 3])
    
    print(f"Matrix A:\n{A}")
    print(f"Vector b: {b}")
    
    # 基本运算
    print(f"Rank: {la.matrix_rank(A)}")
    print(f"Determinant: {la.determinant(A):.3f}")
    
    # 特征值
    eigenvals = la.eigenvalues(A)
    print(f"Eigenvalues: {eigenvals}")
    
    # 奇异值分解
    U, S, Vt = la.svd(A)
    print(f"Singular values: {S}")
    
    # 向量空间
    vs = VectorSpace(3)
    vectors = [np.array([1, 0, 0]), np.array([0, 1, 0]), np.array([1, 1, 0])]
    
    print(f"Linear independent: {vs.is_linear_independent(vectors)}")
    
    # 投影
    vector = np.array([1, 1, 1])
    subspace = np.column_stack([np.array([1, 0, 0]), np.array([0, 1, 0])])
    projection = vs.projection(vector, subspace)
    print(f"Projection: {projection}")
    
    return la, vs

if __name__ == "__main__":
    la, vs = demonstrate_linear_algebra()
```

## 4. 概率论基础

### 4.1 基本概率概念

概率论为随机算法、机器学习和统计分析提供基础：

**Python实现**：

```python
import random
from typing import List, Dict, Any, Callable
from collections import Counter
import matplotlib.pyplot as plt

class ProbabilityTheory:
    """概率论基础"""
    
    @staticmethod
    def probability(event_count: int, total_count: int) -> float:
        """计算概率"""
        return event_count / total_count if total_count > 0 else 0.0
    
    @staticmethod
    def conditional_probability(p_a_and_b: float, p_b: float) -> float:
        """条件概率 P(A|B) = P(A∩B) / P(B)"""
        return p_a_and_b / p_b if p_b > 0 else 0.0
    
    @staticmethod
    def bayes_theorem(p_a: float, p_b_given_a: float, p_b: float) -> float:
        """贝叶斯定理 P(A|B) = P(B|A) * P(A) / P(B)"""
        return p_b_given_a * p_a / p_b if p_b > 0 else 0.0
    
    @staticmethod
    def expected_value(values: List[float], probabilities: List[float]) -> float:
        """期望值"""
        if len(values) != len(probabilities):
            raise ValueError("Values and probabilities must have same length")
        return sum(v * p for v, p in zip(values, probabilities))
    
    @staticmethod
    def variance(values: List[float], probabilities: List[float]) -> float:
        """方差"""
        mean = ProbabilityTheory.expected_value(values, probabilities)
        return sum(p * (v - mean) ** 2 for v, p in zip(values, probabilities))
    
    @staticmethod
    def standard_deviation(values: List[float], probabilities: List[float]) -> float:
        """标准差"""
        return ProbabilityTheory.variance(values, probabilities) ** 0.5

class RandomVariable:
    """随机变量"""
    
    def __init__(self, values: List[float], probabilities: List[float]):
        self.values = values
        self.probabilities = probabilities
        self._validate()
    
    def _validate(self):
        """验证概率分布"""
        if len(self.values) != len(self.probabilities):
            raise ValueError("Values and probabilities must have same length")
        if not (0.99 <= sum(self.probabilities) <= 1.01):
            raise ValueError("Probabilities must sum to 1")
        if any(p < 0 for p in self.probabilities):
            raise ValueError("Probabilities must be non-negative")
    
    def sample(self, n: int) -> List[float]:
        """采样"""
        return random.choices(self.values, weights=self.probabilities, k=n)
    
    def expected_value(self) -> float:
        """期望值"""
        return ProbabilityTheory.expected_value(self.values, self.probabilities)
    
    def variance(self) -> float:
        """方差"""
        return ProbabilityTheory.variance(self.values, self.probabilities)
    
    def standard_deviation(self) -> float:
        """标准差"""
        return ProbabilityTheory.standard_deviation(self.values, self.probabilities)

class MonteCarloSimulation:
    """蒙特卡洛模拟"""
    
    def __init__(self, random_variable: RandomVariable):
        self.rv = random_variable
    
    def estimate_probability(self, event_condition: Callable[[float], bool], n_samples: int) -> float:
        """估计事件概率"""
        samples = self.rv.sample(n_samples)
        event_count = sum(1 for s in samples if event_condition(s))
        return event_count / n_samples
    
    def estimate_integral(self, function: Callable[[float], float], n_samples: int) -> float:
        """估计积分"""
        samples = self.rv.sample(n_samples)
        function_values = [function(s) for s in samples]
        return sum(function_values) / n_samples

# 示例：概率论应用
def demonstrate_probability_theory():
    """演示概率论应用"""
    pt = ProbabilityTheory()
    
    # 基本概率
    event_count, total_count = 3, 10
    prob = pt.probability(event_count, total_count)
    print(f"P(event) = {prob:.3f}")
    
    # 条件概率
    p_a_and_b, p_b = 0.2, 0.5
    cond_prob = pt.conditional_probability(p_a_and_b, p_b)
    print(f"P(A|B) = {cond_prob:.3f}")
    
    # 贝叶斯定理
    p_a, p_b_given_a, p_b = 0.3, 0.8, 0.4
    bayes_prob = pt.bayes_theorem(p_a, p_b_given_a, p_b)
    print(f"P(A|B) = {bayes_prob:.3f}")
    
    # 随机变量
    values = [1, 2, 3, 4, 5, 6]
    probabilities = [1/6] * 6  # 均匀分布
    rv = RandomVariable(values, probabilities)
    
    print(f"Expected value: {rv.expected_value():.3f}")
    print(f"Variance: {rv.variance():.3f}")
    print(f"Standard deviation: {rv.standard_deviation():.3f}")
    
    # 蒙特卡洛模拟
    mc = MonteCarloSimulation(rv)
    
    # 估计概率
    def is_even(x):
        return x % 2 == 0
    
    prob_even = mc.estimate_probability(is_even, 10000)
    print(f"Estimated P(even): {prob_even:.3f}")
    
    # 估计积分
    def square_function(x):
        return x ** 2
    
    integral_estimate = mc.estimate_integral(square_function, 10000)
    print(f"Estimated integral of x²: {integral_estimate:.3f}")
    
    return pt, rv, mc

if __name__ == "__main__":
    pt, rv, mc = demonstrate_probability_theory()
```

## 5. 总结

数学基础通过数学形式化和Python代码实现，为我们提供了：

1. **数论基础**：为密码学和算法设计提供数学工具
2. **线性代数**：为机器学习和数值计算提供基础
3. **概率论**：为随机算法和统计分析提供理论支持
4. **数学方法**：为软件工程问题提供形式化解决方案

这些数学基础为后续的软件工程理论提供了坚实的数学支撑，确保我们的软件设计和分析具有数学严谨性。

---

*参考文献*：

1. Knuth, D. E. (1997). The Art of Computer Programming
2. Cormen, T. H., et al. (2009). Introduction to Algorithms
3. Strang, G. (2016). Introduction to Linear Algebra
