# é¡¹ç›®è¿›åº¦ç®¡ç†

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®åŸºäº `/docs/model` ç›®å½•çš„åŸå§‹å†…å®¹ï¼Œé‡‡ç”¨æ•°å­¦å½¢å¼åŒ–æ–¹æ³•å’ŒPythonç¼–ç¨‹è¯­è¨€ï¼Œå¯¹è½¯ä»¶å·¥ç¨‹ã€è®¡ç®—ç§‘å­¦å’Œå½¢å¼ç§‘å­¦ç†è®ºè¿›è¡Œç³»ç»Ÿæ€§é‡æ„å’Œè§„èŒƒåŒ–ã€‚

## é¡¹ç›®ç›®æ ‡

1. **å½¢å¼åŒ–è§„èŒƒ**ï¼šå°†åŸå§‹å†…å®¹è½¬æ¢ä¸ºç¬¦åˆæ•°å­¦è§„èŒƒçš„Markdownæ–‡æ¡£
2. **Pythonå®ç°**ï¼šæä¾›æ‰€æœ‰æ¦‚å¿µå’Œç†è®ºçš„Pythonä»£ç ç¤ºä¾‹
3. **å±‚æ¬¡åŒ–åˆ†ç±»**ï¼šä»ç†å¿µå±‚åˆ°å…·ä½“å®è·µçš„å®Œæ•´çŸ¥è¯†ä½“ç³»
4. **å¤šè¡¨å¾æ–¹å¼**ï¼šç»“åˆå›¾è¡¨ã€æ•°å­¦ç¬¦å·ã€ä»£ç ç¤ºä¾‹ç­‰å¤šç§è¡¨è¾¾æ–¹å¼
5. **æœ¬åœ°è·³è½¬**ï¼šå»ºç«‹å®Œæ•´çš„æ–‡æ¡£é—´å¼•ç”¨å’Œè·³è½¬ä½“ç³»

## å½“å‰è¿›åº¦

### å·²å®Œæˆå†…å®¹

#### 00-ç†å¿µåŸºç¡€
- [x] README.md - ç†å¿µåŸºç¡€æ¦‚è¿°
- [x] 001-ç¼–ç¨‹å“²å­¦/0001-ç¼–ç¨‹æœ¬è´¨.md - ç¼–ç¨‹æœ¬è´¨çš„å“²å­¦æ€è€ƒ
- [ ] å…¶ä»–ç¼–ç¨‹å“²å­¦æ–‡æ¡£
- [ ] å½¢å¼åŒ–æ€ç»´æ–‡æ¡£
- [ ] è®¡ç®—æ€ç»´æ–‡æ¡£
- [ ] æŠ½è±¡æ€ç»´æ–‡æ¡£
- [ ] å·¥ç¨‹æ€ç»´æ–‡æ¡£

#### 01-å½¢å¼ç§‘å­¦
- [x] README.md - å½¢å¼ç§‘å­¦æ¦‚è¿°
- [x] 001-é›†åˆè®º/0001-é›†åˆåŸºç¡€.md - é›†åˆè®ºåŸºç¡€
- [ ] å…¶ä»–é›†åˆè®ºæ–‡æ¡£
- [ ] é€»è¾‘å­¦æ–‡æ¡£
- [ ] å›¾è®ºæ–‡æ¡£
- [ ] ä»£æ•°ç»“æ„æ–‡æ¡£
- [ ] è®¡ç®—ç†è®ºæ–‡æ¡£
- [ ] å½¢å¼åŒ–æ–¹æ³•æ–‡æ¡£
- [ ] ç±»å‹è®ºæ–‡æ¡£
- [ ] èŒƒç•´è®ºæ–‡æ¡£

#### 02-ç†è®ºåŸºç¡€
- [ ] ç®—æ³•ç†è®ºæ–‡æ¡£
- [ ] æ•°æ®ç»“æ„ç†è®ºæ–‡æ¡£
- [ ] ç¼–ç¨‹è¯­è¨€ç†è®ºæ–‡æ¡£
- [ ] è½¯ä»¶å·¥ç¨‹ç†è®ºæ–‡æ¡£
- [ ] ç³»ç»Ÿæ¶æ„ç†è®ºæ–‡æ¡£

#### 03-å…·ä½“ç§‘å­¦
- [ ] è®¾è®¡æ¨¡å¼ç§‘å­¦æ–‡æ¡£
- [ ] å¹¶å‘ç¼–ç¨‹ç§‘å­¦æ–‡æ¡£
- [ ] åˆ†å¸ƒå¼ç³»ç»Ÿç§‘å­¦æ–‡æ¡£
- [ ] æ•°æ®åº“ç§‘å­¦æ–‡æ¡£
- [ ] ç½‘ç»œé€šä¿¡ç§‘å­¦æ–‡æ¡£

#### 04-è¡Œä¸šé¢†åŸŸ
- [ ] é‡‘èç§‘æŠ€æ–‡æ¡£
- [ ] äººå·¥æ™ºèƒ½æ–‡æ¡£
- [ ] ç‰©è”ç½‘æ–‡æ¡£
- [ ] æ¸¸æˆå¼€å‘æ–‡æ¡£
- [ ] åŒºå—é“¾æ–‡æ¡£
- [ ] äº‘è®¡ç®—æ–‡æ¡£
- [ ] å¤§æ•°æ®æ–‡æ¡£
- [ ] ç½‘ç»œå®‰å…¨æ–‡æ¡£
- [ ] åŒ»ç–—å¥åº·æ–‡æ¡£
- [ ] æ•™è‚²ç§‘æŠ€æ–‡æ¡£
- [ ] æ±½è½¦å·¥ä¸šæ–‡æ¡£
- [ ] ç”µå­å•†åŠ¡æ–‡æ¡£

#### 05-æ¶æ„é¢†åŸŸ
- [ ] å¾®æœåŠ¡æ¶æ„æ–‡æ¡£
- [ ] äº‹ä»¶é©±åŠ¨æ¶æ„æ–‡æ¡£
- [ ] é¢†åŸŸé©±åŠ¨è®¾è®¡æ–‡æ¡£
- [ ] å“åº”å¼æ¶æ„æ–‡æ¡£
- [ ] äº‘åŸç”Ÿæ¶æ„æ–‡æ¡£

#### 06-ç»„ä»¶ç®—æ³•
- [ ] æ•°æ®ç»“æ„å®ç°æ–‡æ¡£
- [ ] ç®—æ³•å®ç°æ–‡æ¡£
- [ ] è®¾è®¡æ¨¡å¼å®ç°æ–‡æ¡£
- [ ] å¹¶å‘æ¨¡å¼å®ç°æ–‡æ¡£
- [ ] åˆ†å¸ƒå¼æ¨¡å¼å®ç°æ–‡æ¡£

#### 07-å®è·µåº”ç”¨
- [ ] é¡¹ç›®æ¨¡æ¿æ–‡æ¡£
- [ ] æœ€ä½³å®è·µæ–‡æ¡£
- [ ] æ€§èƒ½ä¼˜åŒ–æ–‡æ¡£
- [ ] æµ‹è¯•ç­–ç•¥æ–‡æ¡£
- [ ] éƒ¨ç½²è¿ç»´æ–‡æ¡£

#### 08-é¡¹ç›®è¿›åº¦
- [x] README.md - é¡¹ç›®è¿›åº¦æ¦‚è¿°
- [ ] é‡æ„è¿›åº¦æ–‡æ¡£
- [ ] ä¸Šä¸‹æ–‡ç®¡ç†æ–‡æ¡£
- [ ] æŒç»­æ”¹è¿›æ–‡æ¡£

### è¿›è¡Œä¸­å†…å®¹

1. **ç†å¿µåŸºç¡€å±‚**ï¼šæ­£åœ¨å®Œå–„ç¼–ç¨‹å“²å­¦çš„å„ä¸ªå­ä¸»é¢˜
2. **å½¢å¼ç§‘å­¦å±‚**ï¼šæ­£åœ¨æ‰©å±•é›†åˆè®ºçš„å…¶ä»–å†…å®¹
3. **æ–‡æ¡£ç»“æ„**ï¼šæ­£åœ¨å»ºç«‹å®Œæ•´çš„å¯¼èˆªå’Œå¼•ç”¨ä½“ç³»

### å¾…å®Œæˆå†…å®¹

1. **ç†è®ºåŸºç¡€å±‚**ï¼šç®—æ³•ç†è®ºã€æ•°æ®ç»“æ„ç†è®ºç­‰
2. **å…·ä½“ç§‘å­¦å±‚**ï¼šè®¾è®¡æ¨¡å¼ç§‘å­¦ã€å¹¶å‘ç¼–ç¨‹ç§‘å­¦ç­‰
3. **è¡Œä¸šé¢†åŸŸå±‚**ï¼šå„è¡Œä¸šåº”ç”¨é¢†åŸŸ
4. **æ¶æ„é¢†åŸŸå±‚**ï¼šå„ç§æ¶æ„æ¨¡å¼
5. **ç»„ä»¶ç®—æ³•å±‚**ï¼šå…·ä½“å®ç°
6. **å®è·µåº”ç”¨å±‚**ï¼šå®é™…åº”ç”¨æ¡ˆä¾‹

## è´¨é‡æ£€æŸ¥

### å·²å®Œæˆæ£€æŸ¥

- [x] æ–‡æ¡£ç»“æ„è§„èŒƒåŒ–
- [x] æ•°å­¦å…¬å¼æ ¼å¼ç»Ÿä¸€
- [x] Pythonä»£ç è¯­æ³•æ­£ç¡®
- [x] å¼•ç”¨é“¾æ¥æœ‰æ•ˆ
- [x] å†…å®¹ä¸€è‡´æ€§æ£€æŸ¥

### å¾…æ£€æŸ¥é¡¹ç›®

- [ ] æ‰€æœ‰æ–‡æ¡£çš„å®Œæ•´æ€§
- [ ] æ•°å­¦è¯æ˜çš„æ­£ç¡®æ€§
- [ ] ä»£ç å®ç°çš„æ­£ç¡®æ€§
- [ ] ç¤ºä¾‹çš„å®ç”¨æ€§
- [ ] æ–‡æ¡£çš„å¯è¯»æ€§

## æŠ€æœ¯è§„èŒƒ

### æ–‡æ¡£æ ¼å¼

- **æ–‡ä»¶å‘½å**ï¼šä½¿ç”¨å››ä½æ•°ç¼–å·ï¼Œå¦‚ `0001-ä¸»é¢˜.md`
- **ç›®å½•ç»“æ„**ï¼šä½¿ç”¨ä¸‰ä½æ•°ç¼–å·ï¼Œå¦‚ `001-ä¸»é¢˜/`
- **æ•°å­¦å…¬å¼**ï¼šä½¿ç”¨LaTeXæ ¼å¼
- **ä»£ç ç¤ºä¾‹**ï¼šä½¿ç”¨Python 3.12+è¯­æ³•
- **å›¾è¡¨**ï¼šä½¿ç”¨Mermaidæˆ–PlantUML

### å†…å®¹è§„èŒƒ

- **æ¦‚å¿µå®šä¹‰**ï¼šä½¿ç”¨ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰
- **å®šç†è¯æ˜**ï¼šåŒ…å«å®Œæ•´çš„é€»è¾‘æ¨ç†
- **ä»£ç å®ç°**ï¼šæä¾›å¯è¿è¡Œçš„ç¤ºä¾‹
- **åº”ç”¨ç¤ºä¾‹**ï¼šå±•ç¤ºå®é™…åº”ç”¨åœºæ™¯

### å¼•ç”¨è§„èŒƒ

- **å†…éƒ¨å¼•ç”¨**ï¼šä½¿ç”¨ç›¸å¯¹è·¯å¾„
- **å¤–éƒ¨å¼•ç”¨**ï¼šä½¿ç”¨æ ‡å‡†å­¦æœ¯æ ¼å¼
- **äº¤å‰å¼•ç”¨**ï¼šå»ºç«‹å®Œæ•´çš„å¼•ç”¨ç½‘ç»œ

## æŒç»­æ”¹è¿›

### åé¦ˆæ”¶é›†

- ç”¨æˆ·ä½¿ç”¨åé¦ˆ
- å†…å®¹å‡†ç¡®æ€§æ£€æŸ¥
- å®ç”¨æ€§è¯„ä¼°
- å¯è¯»æ€§æ”¹è¿›å»ºè®®

### è´¨é‡è¯„ä¼°

- æ•°å­¦ä¸¥è°¨æ€§è¯„ä¼°
- ä»£ç æ­£ç¡®æ€§éªŒè¯
- æ–‡æ¡£å®Œæ•´æ€§æ£€æŸ¥
- ä¸€è‡´æ€§éªŒè¯

### å†…å®¹æ›´æ–°

- æ ¹æ®æœ€æ–°æŠ€æœ¯å‘å±•æ›´æ–°å†…å®¹
- æ ¹æ®ç”¨æˆ·åé¦ˆæ”¹è¿›æ–‡æ¡£
- æ ¹æ®å®é™…åº”ç”¨ç»éªŒè¡¥å……æ¡ˆä¾‹
- æ ¹æ®å­¦æœ¯è¿›å±•æ›´æ–°ç†è®º

### ç‰ˆæœ¬ç®¡ç†

- ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬å·
- è®°å½•è¯¦ç»†çš„å˜æ›´æ—¥å¿—
- ç»´æŠ¤ç‰ˆæœ¬å…¼å®¹æ€§
- æä¾›å‡çº§æŒ‡å—

## åä½œç®¡ç†

### ä»»åŠ¡åˆ†é…

- æŒ‰å±‚æ¬¡åˆ†é…ä»»åŠ¡
- æŒ‰ä¸»é¢˜åˆ†é…ä»»åŠ¡
- æŒ‰ä¼˜å…ˆçº§åˆ†é…ä»»åŠ¡
- æŒ‰æŠ€èƒ½åˆ†é…ä»»åŠ¡

### è¿›åº¦è·Ÿè¸ª

- å®šæœŸè¿›åº¦æ£€æŸ¥
- é‡Œç¨‹ç¢‘ç®¡ç†
- é£é™©è¯†åˆ«å’Œåº”å¯¹
- è´¨é‡ä¿è¯

### æ²Ÿé€šåè°ƒ

- å®šæœŸä¼šè®®
- è¿›åº¦æ±‡æŠ¥
- é—®é¢˜è®¨è®º
- å†³ç­–è®°å½•

## ä¸‹ä¸€æ­¥è®¡åˆ’

### çŸ­æœŸç›®æ ‡ï¼ˆ1-2å‘¨ï¼‰

1. å®Œæˆç†å¿µåŸºç¡€å±‚çš„æ‰€æœ‰æ–‡æ¡£
2. å®Œæˆå½¢å¼ç§‘å­¦å±‚çš„åŸºç¡€å†…å®¹
3. å»ºç«‹å®Œæ•´çš„å¯¼èˆªä½“ç³»

### ä¸­æœŸç›®æ ‡ï¼ˆ1-2æœˆï¼‰

1. å®Œæˆç†è®ºåŸºç¡€å±‚
2. å®Œæˆå…·ä½“ç§‘å­¦å±‚
3. å¼€å§‹è¡Œä¸šé¢†åŸŸå±‚

### é•¿æœŸç›®æ ‡ï¼ˆ3-6æœˆï¼‰

1. å®Œæˆæ‰€æœ‰å±‚æ¬¡çš„æ–‡æ¡£
2. å»ºç«‹å®Œæ•´çš„çŸ¥è¯†ä½“ç³»
3. æä¾›å®ç”¨çš„åº”ç”¨æ¡ˆä¾‹

---

*æœ¬é¡¹ç›®è‡´åŠ›äºä¸ºè½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦æä¾›ä¸¥è°¨ã€å®Œæ•´ã€å®ç”¨çš„å­¦ä¹ èµ„æºã€‚*

# 08-é¡¹ç›®è¿›åº¦

## æ¦‚è¿°

é¡¹ç›®è¿›åº¦å±‚æ˜¯çŸ¥è¯†åº“çš„ç®¡ç†å±‚ï¼ŒåŒ…å«é¡¹ç›®è¿›åº¦è·Ÿè¸ªã€ä¸Šä¸‹æ–‡ç®¡ç†ã€ä»»åŠ¡åˆ†é…ã€é‡Œç¨‹ç¢‘ç®¡ç†ç­‰å†…å®¹ã€‚è¿™ä¸€å±‚ç¡®ä¿çŸ¥è¯†åº“çš„æŒç»­æ›´æ–°å’Œé¡¹ç›®çš„æœ‰æ•ˆç®¡ç†ã€‚

## ç›®å½•ç»“æ„

```
08-é¡¹ç›®è¿›åº¦/
â”œâ”€â”€ 001-é¡¹ç›®æ¦‚è§ˆ/           # é¡¹ç›®æ•´ä½“æƒ…å†µã€ç›®æ ‡ã€èŒƒå›´
â”œâ”€â”€ 002-è¿›åº¦è·Ÿè¸ª/           # å½“å‰è¿›åº¦ã€é‡Œç¨‹ç¢‘ã€æ—¶é—´çº¿
â”œâ”€â”€ 003-ä»»åŠ¡ç®¡ç†/           # ä»»åŠ¡åˆ†é…ã€çŠ¶æ€è·Ÿè¸ªã€ä¼˜å…ˆçº§
â”œâ”€â”€ 004-ä¸Šä¸‹æ–‡ç®¡ç†/         # ä¸­æ–­æ¢å¤ã€çŠ¶æ€ä¿å­˜ã€ä¸Šä¸‹æ–‡ä¼ é€’
â”œâ”€â”€ 005-è´¨é‡æ£€æŸ¥/           # æ–‡æ¡£è´¨é‡ã€ä¸€è‡´æ€§æ£€æŸ¥ã€å®Œæ•´æ€§éªŒè¯
â”œâ”€â”€ 006-ç‰ˆæœ¬æ§åˆ¶/           # ç‰ˆæœ¬ç®¡ç†ã€å˜æ›´è®°å½•ã€å›æ»šæœºåˆ¶
â”œâ”€â”€ 007-å›¢é˜Ÿåä½œ/           # åä½œæµç¨‹ã€æ²Ÿé€šæœºåˆ¶ã€çŸ¥è¯†åˆ†äº«
â””â”€â”€ 008-æŒç»­æ”¹è¿›/           # åé¦ˆæ”¶é›†ã€æ”¹è¿›å»ºè®®ã€ä¼˜åŒ–è®¡åˆ’
```

## æ ¸å¿ƒå†…å®¹

### 1. é¡¹ç›®æ¦‚è§ˆ

```python
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import json

class ProjectStatus(Enum):
    PLANNING = "planning"
    IN_PROGRESS = "in_progress"
    REVIEW = "review"
    COMPLETED = "completed"
    ON_HOLD = "on_hold"
    CANCELLED = "cancelled"

class Priority(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class ProjectMilestone:
    """é¡¹ç›®é‡Œç¨‹ç¢‘"""
    name: str
    description: str
    target_date: datetime
    actual_date: Optional[datetime] = None
    status: ProjectStatus = ProjectStatus.PLANNING
    deliverables: List[str] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)
    
    def is_completed(self) -> bool:
        """æ˜¯å¦å·²å®Œæˆ"""
        return self.status == ProjectStatus.COMPLETED
    
    def is_overdue(self) -> bool:
        """æ˜¯å¦é€¾æœŸ"""
        if self.actual_date is None:
            return datetime.now() > self.target_date
        return self.actual_date > self.target_date
    
    def get_progress(self) -> float:
        """è·å–è¿›åº¦"""
        if self.status == ProjectStatus.COMPLETED:
            return 1.0
        elif self.status == ProjectStatus.IN_PROGRESS:
            return 0.5
        elif self.status == ProjectStatus.REVIEW:
            return 0.8
        else:
            return 0.0

@dataclass
class ProjectTask:
    """é¡¹ç›®ä»»åŠ¡"""
    id: str
    title: str
    description: str
    assignee: str
    priority: Priority
    status: ProjectStatus
    estimated_hours: float
    actual_hours: float = 0.0
    start_date: Optional[datetime] = None
    due_date: Optional[datetime] = None
    completed_date: Optional[datetime] = None
    dependencies: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    
    def get_progress(self) -> float:
        """è·å–ä»»åŠ¡è¿›åº¦"""
        if self.status == ProjectStatus.COMPLETED:
            return 1.0
        elif self.status == ProjectStatus.IN_PROGRESS:
            return min(1.0, self.actual_hours / self.estimated_hours)
        else:
            return 0.0
    
    def is_overdue(self) -> bool:
        """æ˜¯å¦é€¾æœŸ"""
        if self.due_date is None:
            return False
        return datetime.now() > self.due_date and self.status != ProjectStatus.COMPLETED
    
    def get_remaining_hours(self) -> float:
        """è·å–å‰©ä½™å·¥æ—¶"""
        return max(0.0, self.estimated_hours - self.actual_hours)

@dataclass
class ProjectContext:
    """é¡¹ç›®ä¸Šä¸‹æ–‡"""
    project_id: str
    current_task: Optional[str] = None
    current_milestone: Optional[str] = None
    last_updated: datetime = field(default_factory=datetime.now)
    notes: str = ""
    next_actions: List[str] = field(default_factory=list)
    blockers: List[str] = field(default_factory=list)
    
    def to_json(self) -> str:
        """è½¬æ¢ä¸ºJSON"""
        return json.dumps({
            "project_id": self.project_id,
            "current_task": self.current_task,
            "current_milestone": self.current_milestone,
            "last_updated": self.last_updated.isoformat(),
            "notes": self.notes,
            "next_actions": self.next_actions,
            "blockers": self.blockers
        }, indent=2)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'ProjectContext':
        """ä»JSONåˆ›å»º"""
        data = json.loads(json_str)
        return cls(
            project_id=data["project_id"],
            current_task=data.get("current_task"),
            current_milestone=data.get("current_milestone"),
            last_updated=datetime.fromisoformat(data["last_updated"]),
            notes=data.get("notes", ""),
            next_actions=data.get("next_actions", []),
            blockers=data.get("blockers", [])
        )

class Project:
    """é¡¹ç›®"""
    
    def __init__(self, name: str, description: str, start_date: datetime, end_date: datetime):
        self.name = name
        self.description = description
        self.start_date = start_date
        self.end_date = end_date
        self.status = ProjectStatus.PLANNING
        self.milestones: List[ProjectMilestone] = []
        self.tasks: List[ProjectTask] = []
        self.context = ProjectContext(f"project_{name.lower().replace(' ', '_')}")
        self.metrics: Dict[str, Any] = {}
    
    def add_milestone(self, milestone: ProjectMilestone):
        """æ·»åŠ é‡Œç¨‹ç¢‘"""
        self.milestones.append(milestone)
    
    def add_task(self, task: ProjectTask):
        """æ·»åŠ ä»»åŠ¡"""
        self.tasks.append(task)
    
    def get_overall_progress(self) -> float:
        """è·å–æ•´ä½“è¿›åº¦"""
        if not self.tasks:
            return 0.0
        
        total_progress = sum(task.get_progress() for task in self.tasks)
        return total_progress / len(self.tasks)
    
    def get_completed_tasks(self) -> List[ProjectTask]:
        """è·å–å·²å®Œæˆä»»åŠ¡"""
        return [task for task in self.tasks if task.status == ProjectStatus.COMPLETED]
    
    def get_overdue_tasks(self) -> List[ProjectTask]:
        """è·å–é€¾æœŸä»»åŠ¡"""
        return [task for task in self.tasks if task.is_overdue()]
    
    def get_critical_tasks(self) -> List[ProjectTask]:
        """è·å–å…³é”®ä»»åŠ¡"""
        return [task for task in self.tasks if task.priority == Priority.CRITICAL]
    
    def update_metrics(self):
        """æ›´æ–°é¡¹ç›®æŒ‡æ ‡"""
        total_tasks = len(self.tasks)
        completed_tasks = len(self.get_completed_tasks())
        overdue_tasks = len(self.get_overdue_tasks())
        critical_tasks = len(self.get_critical_tasks())
        
        self.metrics = {
            "total_tasks": total_tasks,
            "completed_tasks": completed_tasks,
            "overdue_tasks": overdue_tasks,
            "critical_tasks": critical_tasks,
            "completion_rate": completed_tasks / total_tasks if total_tasks > 0 else 0,
            "overdue_rate": overdue_tasks / total_tasks if total_tasks > 0 else 0,
            "overall_progress": self.get_overall_progress()
        }
    
    def generate_status_report(self) -> str:
        """ç”ŸæˆçŠ¶æ€æŠ¥å‘Š"""
        self.update_metrics()
        
        report = f"# {self.name} é¡¹ç›®çŠ¶æ€æŠ¥å‘Š\n\n"
        report += f"**é¡¹ç›®çŠ¶æ€**: {self.status.value}\n"
        report += f"**æ•´ä½“è¿›åº¦**: {self.metrics['overall_progress']:.1%}\n"
        report += f"**å®Œæˆç‡**: {self.metrics['completion_rate']:.1%}\n\n"
        
        report += "## ä»»åŠ¡æ¦‚è§ˆ\n"
        report += f"- æ€»ä»»åŠ¡æ•°: {self.metrics['total_tasks']}\n"
        report += f"- å·²å®Œæˆ: {self.metrics['completed_tasks']}\n"
        report += f"- é€¾æœŸä»»åŠ¡: {self.metrics['overdue_tasks']}\n"
        report += f"- å…³é”®ä»»åŠ¡: {self.metrics['critical_tasks']}\n\n"
        
        if self.get_overdue_tasks():
            report += "## é€¾æœŸä»»åŠ¡\n"
            for task in self.get_overdue_tasks():
                report += f"- {task.title} (é€¾æœŸ {task.due_date})\n"
            report += "\n"
        
        if self.get_critical_tasks():
            report += "## å…³é”®ä»»åŠ¡\n"
            for task in self.get_critical_tasks():
                report += f"- {task.title} (è¿›åº¦: {task.get_progress():.1%})\n"
            report += "\n"
        
        return report
```

### 2. è¿›åº¦è·Ÿè¸ª

```python
from typing import Dict, List, Any, Optional
import matplotlib.pyplot as plt
import numpy as np

class ProgressTracker:
    """è¿›åº¦è·Ÿè¸ªå™¨"""
    
    def __init__(self, project: Project):
        self.project = project
        self.history: List[Dict[str, Any]] = []
    
    def record_progress(self):
        """è®°å½•è¿›åº¦"""
        self.project.update_metrics()
        
        record = {
            "timestamp": datetime.now(),
            "overall_progress": self.project.metrics["overall_progress"],
            "completion_rate": self.project.metrics["completion_rate"],
            "overdue_rate": self.project.metrics["overdue_rate"],
            "total_tasks": self.project.metrics["total_tasks"],
            "completed_tasks": self.project.metrics["completed_tasks"]
        }
        
        self.history.append(record)
    
    def get_progress_trend(self) -> Dict[str, List[float]]:
        """è·å–è¿›åº¦è¶‹åŠ¿"""
        if not self.history:
            return {}
        
        timestamps = [record["timestamp"] for record in self.history]
        progress = [record["overall_progress"] for record in self.history]
        completion = [record["completion_rate"] for record in self.history]
        
        return {
            "timestamps": timestamps,
            "progress": progress,
            "completion": completion
        }
    
    def predict_completion_date(self) -> Optional[datetime]:
        """é¢„æµ‹å®Œæˆæ—¥æœŸ"""
        if len(self.history) < 2:
            return None
        
        # è®¡ç®—è¿›åº¦å˜åŒ–ç‡
        recent_records = self.history[-5:]  # æœ€è¿‘5æ¬¡è®°å½•
        if len(recent_records) < 2:
            return None
        
        progress_changes = []
        time_changes = []
        
        for i in range(1, len(recent_records)):
            progress_diff = recent_records[i]["overall_progress"] - recent_records[i-1]["overall_progress"]
            time_diff = (recent_records[i]["timestamp"] - recent_records[i-1]["timestamp"]).total_seconds() / 3600  # å°æ—¶
            
            if time_diff > 0:
                progress_changes.append(progress_diff)
                time_changes.append(time_diff)
        
        if not progress_changes:
            return None
        
        # è®¡ç®—å¹³å‡è¿›åº¦å˜åŒ–ç‡
        avg_progress_rate = sum(progress_changes) / sum(time_changes)  # æ¯å°æ—¶è¿›åº¦å˜åŒ–
        
        if avg_progress_rate <= 0:
            return None
        
        # è®¡ç®—å‰©ä½™æ—¶é—´
        current_progress = self.project.metrics["overall_progress"]
        remaining_progress = 1.0 - current_progress
        remaining_hours = remaining_progress / avg_progress_rate
        
        return datetime.now() + timedelta(hours=remaining_hours)
    
    def generate_burndown_chart(self) -> str:
        """ç”Ÿæˆç‡ƒå°½å›¾"""
        if not self.history:
            return "æ— å†å²æ•°æ®"
        
        # å‡†å¤‡æ•°æ®
        dates = [record["timestamp"].date() for record in self.history]
        completed_tasks = [record["completed_tasks"] for record in self.history]
        total_tasks = self.project.metrics["total_tasks"]
        
        # ç†æƒ³ç‡ƒå°½çº¿
        ideal_burndown = []
        if len(dates) > 1:
            date_range = (dates[-1] - dates[0]).days
            for i in range(len(dates)):
                ideal_progress = (dates[i] - dates[0]).days / date_range if date_range > 0 else 0
                ideal_burndown.append(total_tasks * ideal_progress)
        
        # ç”Ÿæˆå›¾è¡¨
        plt.figure(figsize=(10, 6))
        plt.plot(dates, completed_tasks, 'b-o', label='å®é™…å®Œæˆ')
        if ideal_burndown:
            plt.plot(dates, ideal_burndown, 'r--', label='ç†æƒ³ç‡ƒå°½')
        plt.xlabel('æ—¥æœŸ')
        plt.ylabel('å®Œæˆä»»åŠ¡æ•°')
        plt.title('é¡¹ç›®ç‡ƒå°½å›¾')
        plt.legend()
        plt.grid(True)
        plt.xticks(rotation=45)
        plt.tight_layout()
        
        # ä¿å­˜å›¾è¡¨
        chart_path = f"burndown_chart_{self.project.name.replace(' ', '_')}.png"
        plt.savefig(chart_path)
        plt.close()
        
        return chart_path

class MilestoneTracker:
    """é‡Œç¨‹ç¢‘è·Ÿè¸ªå™¨"""
    
    def __init__(self, project: Project):
        self.project = project
    
    def get_milestone_progress(self) -> Dict[str, float]:
        """è·å–é‡Œç¨‹ç¢‘è¿›åº¦"""
        progress = {}
        for milestone in self.project.milestones:
            progress[milestone.name] = milestone.get_progress()
        return progress
    
    def get_overdue_milestones(self) -> List[ProjectMilestone]:
        """è·å–é€¾æœŸé‡Œç¨‹ç¢‘"""
        return [milestone for milestone in self.project.milestones if milestone.is_overdue()]
    
    def get_upcoming_milestones(self, days: int = 7) -> List[ProjectMilestone]:
        """è·å–å³å°†åˆ°æ¥çš„é‡Œç¨‹ç¢‘"""
        upcoming = []
        target_date = datetime.now() + timedelta(days=days)
        
        for milestone in self.project.milestones:
            if (milestone.status != ProjectStatus.COMPLETED and 
                milestone.target_date <= target_date):
                upcoming.append(milestone)
        
        return sorted(upcoming, key=lambda x: x.target_date)
    
    def generate_milestone_report(self) -> str:
        """ç”Ÿæˆé‡Œç¨‹ç¢‘æŠ¥å‘Š"""
        report = "# é‡Œç¨‹ç¢‘çŠ¶æ€æŠ¥å‘Š\n\n"
        
        # æ•´ä½“è¿›åº¦
        progress = self.get_milestone_progress()
        avg_progress = sum(progress.values()) / len(progress) if progress else 0
        report += f"**å¹³å‡è¿›åº¦**: {avg_progress:.1%}\n\n"
        
        # é€¾æœŸé‡Œç¨‹ç¢‘
        overdue = self.get_overdue_milestones()
        if overdue:
            report += "## é€¾æœŸé‡Œç¨‹ç¢‘\n"
            for milestone in overdue:
                report += f"- {milestone.name} (é€¾æœŸ {milestone.target_date.strftime('%Y-%m-%d')})\n"
            report += "\n"
        
        # å³å°†åˆ°æ¥çš„é‡Œç¨‹ç¢‘
        upcoming = self.get_upcoming_milestones()
        if upcoming:
            report += "## å³å°†åˆ°æ¥çš„é‡Œç¨‹ç¢‘\n"
            for milestone in upcoming:
                report += f"- {milestone.name} ({milestone.target_date.strftime('%Y-%m-%d')})\n"
            report += "\n"
        
        # æ‰€æœ‰é‡Œç¨‹ç¢‘çŠ¶æ€
        report += "## æ‰€æœ‰é‡Œç¨‹ç¢‘\n"
        for milestone in self.project.milestones:
            status_icon = "âœ…" if milestone.is_completed() else "â³" if milestone.is_overdue() else "ğŸ”„"
            report += f"{status_icon} {milestone.name}: {milestone.get_progress():.1%}\n"
        
        return report
```

### 3. ä¸Šä¸‹æ–‡ç®¡ç†

```python
from typing import Dict, List, Any, Optional
import pickle
import os

class ContextManager:
    """ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    
    def __init__(self, project: Project):
        self.project = project
        self.context_file = f"context_{project.name.replace(' ', '_')}.pkl"
        self.checkpoint_file = f"checkpoint_{project.name.replace(' ', '_')}.pkl"
    
    def save_context(self):
        """ä¿å­˜ä¸Šä¸‹æ–‡"""
        context_data = {
            "project_context": self.project.context,
            "current_tasks": [task for task in self.project.tasks if task.status == ProjectStatus.IN_PROGRESS],
            "next_actions": self.project.context.next_actions,
            "blockers": self.project.context.blockers,
            "notes": self.project.context.notes,
            "timestamp": datetime.now()
        }
        
        with open(self.context_file, 'wb') as f:
            pickle.dump(context_data, f)
    
    def load_context(self) -> bool:
        """åŠ è½½ä¸Šä¸‹æ–‡"""
        if not os.path.exists(self.context_file):
            return False
        
        try:
            with open(self.context_file, 'rb') as f:
                context_data = pickle.load(f)
            
            self.project.context = context_data["project_context"]
            self.project.context.next_actions = context_data.get("next_actions", [])
            self.project.context.blockers = context_data.get("blockers", [])
            self.project.context.notes = context_data.get("notes", "")
            
            return True
        except Exception as e:
            print(f"åŠ è½½ä¸Šä¸‹æ–‡å¤±è´¥: {e}")
            return False
    
    def create_checkpoint(self):
        """åˆ›å»ºæ£€æŸ¥ç‚¹"""
        checkpoint_data = {
            "project_state": {
                "name": self.project.name,
                "status": self.project.status,
                "milestones": self.project.milestones,
                "tasks": self.project.tasks,
                "metrics": self.project.metrics
            },
            "timestamp": datetime.now()
        }
        
        with open(self.checkpoint_file, 'wb') as f:
            pickle.dump(checkpoint_data, f)
    
    def restore_checkpoint(self) -> bool:
        """æ¢å¤æ£€æŸ¥ç‚¹"""
        if not os.path.exists(self.checkpoint_file):
            return False
        
        try:
            with open(self.checkpoint_file, 'rb') as f:
                checkpoint_data = pickle.load(f)
            
            project_state = checkpoint_data["project_state"]
            self.project.status = project_state["status"]
            self.project.milestones = project_state["milestones"]
            self.project.tasks = project_state["tasks"]
            self.project.metrics = project_state["metrics"]
            
            return True
        except Exception as e:
            print(f"æ¢å¤æ£€æŸ¥ç‚¹å¤±è´¥: {e}")
            return False
    
    def get_context_summary(self) -> str:
        """è·å–ä¸Šä¸‹æ–‡æ‘˜è¦"""
        summary = f"# é¡¹ç›®ä¸Šä¸‹æ–‡æ‘˜è¦\n\n"
        summary += f"**é¡¹ç›®**: {self.project.name}\n"
        summary += f"**å½“å‰ä»»åŠ¡**: {self.project.context.current_task or 'æ— '}\n"
        summary += f"**å½“å‰é‡Œç¨‹ç¢‘**: {self.project.context.current_milestone or 'æ— '}\n"
        summary += f"**æœ€åæ›´æ–°**: {self.project.context.last_updated.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        if self.project.context.next_actions:
            summary += "## ä¸‹ä¸€æ­¥è¡ŒåŠ¨\n"
            for action in self.project.context.next_actions:
                summary += f"- {action}\n"
            summary += "\n"
        
        if self.project.context.blockers:
            summary += "## é˜»å¡é¡¹\n"
            for blocker in self.project.context.blockers:
                summary += f"- {blocker}\n"
            summary += "\n"
        
        if self.project.context.notes:
            summary += "## å¤‡æ³¨\n"
            summary += self.project.context.notes + "\n\n"
        
        return summary
    
    def update_context(self, current_task: Optional[str] = None, 
                      current_milestone: Optional[str] = None,
                      notes: Optional[str] = None,
                      next_actions: Optional[List[str]] = None,
                      blockers: Optional[List[str]] = None):
        """æ›´æ–°ä¸Šä¸‹æ–‡"""
        if current_task is not None:
            self.project.context.current_task = current_task
        if current_milestone is not None:
            self.project.context.current_milestone = current_milestone
        if notes is not None:
            self.project.context.notes = notes
        if next_actions is not None:
            self.project.context.next_actions = next_actions
        if blockers is not None:
            self.project.context.blockers = blockers
        
        self.project.context.last_updated = datetime.now()
        self.save_context()
```

## æ•°å­¦åŸºç¡€

### é¡¹ç›®è¿›åº¦æŒ‡æ ‡

```math
\text{å®Œæˆç‡}: C = \frac{\text{å·²å®Œæˆä»»åŠ¡æ•°}}{\text{æ€»ä»»åŠ¡æ•°}} \times 100\%

\text{è¿›åº¦åå·®}: D = \frac{\text{å®é™…è¿›åº¦} - \text{è®¡åˆ’è¿›åº¦}}{\text{è®¡åˆ’è¿›åº¦}} \times 100\%

\text{è¿›åº¦ç»©æ•ˆæŒ‡æ•°}: SPI = \frac{\text{è®¡åˆ’ä»·å€¼}}{\text{å®é™…ä»·å€¼}}

\text{æˆæœ¬ç»©æ•ˆæŒ‡æ•°}: CPI = \frac{\text{è®¡åˆ’æˆæœ¬}}{\text{å®é™…æˆæœ¬}}
```

### é¢„æµ‹æ¨¡å‹

```math
\text{çº¿æ€§é¢„æµ‹}: P(t) = P_0 + r \cdot t

\text{å…¶ä¸­ï¼š}
\begin{align}
P(t) &= \text{æ—¶é—´tçš„é¢„æµ‹è¿›åº¦} \\
P_0 &= \text{åˆå§‹è¿›åº¦} \\
r &= \text{è¿›åº¦å˜åŒ–ç‡} \\
t &= \text{æ—¶é—´}
\end{align}

\text{æŒ‡æ•°é¢„æµ‹}: P(t) = P_0 \cdot e^{r \cdot t}

\text{å¯¹æ•°é¢„æµ‹}: P(t) = P_{max} \cdot \frac{\ln(1 + r \cdot t)}{\ln(1 + r \cdot T)}
```

### é£é™©è¯„ä¼°

```math
\text{é£é™©æ¦‚ç‡}: P(R) = \frac{\text{é£é™©äº‹ä»¶å‘ç”Ÿæ¬¡æ•°}}{\text{æ€»è§‚å¯Ÿæ¬¡æ•°}}

\text{é£é™©å½±å“}: I(R) = \sum_{i=1}^{n} w_i \cdot s_i

\text{é£é™©å€¼}: RV = P(R) \times I(R)

\text{å…¶ä¸­ï¼š}
\begin{align}
w_i &= \text{å½±å“ç»´åº¦æƒé‡} \\
s_i &= \text{å½±å“ä¸¥é‡ç¨‹åº¦}
\end{align}
```

## åº”ç”¨ç¤ºä¾‹

### 1. é¡¹ç›®ç®¡ç†åº”ç”¨

```python
# åˆ›å»ºé¡¹ç›®
project = Project(
    name="çŸ¥è¯†åº“é‡æ„é¡¹ç›®",
    description="é‡æ„è½¯ä»¶å·¥ç¨‹çŸ¥è¯†åº“ï¼Œå»ºç«‹è§„èŒƒåŒ–çš„æ–‡æ¡£ä½“ç³»",
    start_date=datetime(2024, 1, 1),
    end_date=datetime(2024, 12, 31)
)

# æ·»åŠ é‡Œç¨‹ç¢‘
milestone1 = ProjectMilestone(
    name="æ¶æ„è®¾è®¡å®Œæˆ",
    description="å®ŒæˆçŸ¥è¯†åº“æ¶æ„è®¾è®¡å’Œç›®å½•ç»“æ„",
    target_date=datetime(2024, 3, 31),
    deliverables=["æ¶æ„æ–‡æ¡£", "ç›®å½•ç»“æ„", "è®¾è®¡åŸåˆ™"]
)

milestone2 = ProjectMilestone(
    name="æ ¸å¿ƒå†…å®¹å®Œæˆ",
    description="å®Œæˆæ ¸å¿ƒç†è®ºå†…å®¹ç¼–å†™",
    target_date=datetime(2024, 6, 30),
    deliverables=["ç†è®ºåŸºç¡€", "å½¢å¼ç§‘å­¦", "å…·ä½“ç§‘å­¦"]
)

project.add_milestone(milestone1)
project.add_milestone(milestone2)

# æ·»åŠ ä»»åŠ¡
task1 = ProjectTask(
    id="T001",
    title="è®¾è®¡çŸ¥è¯†åº“æ¶æ„",
    description="è®¾è®¡åˆ†å±‚æ¶æ„å’Œç›®å½•ç»“æ„",
    assignee="æ¶æ„å¸ˆ",
    priority=Priority.HIGH,
    status=ProjectStatus.IN_PROGRESS,
    estimated_hours=40,
    start_date=datetime(2024, 1, 15),
    due_date=datetime(2024, 2, 15)
)

task2 = ProjectTask(
    id="T002",
    title="ç¼–å†™ç†è®ºåŸºç¡€",
    description="ç¼–å†™è®¡ç®—ç†è®ºå’Œç®—æ³•ç†è®º",
    assignee="æŠ€æœ¯ä¸“å®¶",
    priority=Priority.HIGH,
    status=ProjectStatus.PLANNING,
    estimated_hours=80,
    start_date=datetime(2024, 2, 1),
    due_date=datetime(2024, 4, 30)
)

project.add_task(task1)
project.add_task(task2)

# ç”ŸæˆçŠ¶æ€æŠ¥å‘Š
report = project.generate_status_report()
print(report)
```

### 2. è¿›åº¦è·Ÿè¸ªåº”ç”¨

```python
# åˆ›å»ºè¿›åº¦è·Ÿè¸ªå™¨
tracker = ProgressTracker(project)

# è®°å½•è¿›åº¦
tracker.record_progress()

# è·å–è¿›åº¦è¶‹åŠ¿
trend = tracker.get_progress_trend()
print("è¿›åº¦è¶‹åŠ¿:", trend)

# é¢„æµ‹å®Œæˆæ—¥æœŸ
completion_date = tracker.predict_completion_date()
if completion_date:
    print(f"é¢„æµ‹å®Œæˆæ—¥æœŸ: {completion_date}")

# ç”Ÿæˆç‡ƒå°½å›¾
chart_path = tracker.generate_burndown_chart()
print(f"ç‡ƒå°½å›¾å·²ä¿å­˜: {chart_path}")

# é‡Œç¨‹ç¢‘è·Ÿè¸ª
milestone_tracker = MilestoneTracker(project)
milestone_report = milestone_tracker.generate_milestone_report()
print(milestone_report)
```

### 3. ä¸Šä¸‹æ–‡ç®¡ç†åº”ç”¨

```python
# åˆ›å»ºä¸Šä¸‹æ–‡ç®¡ç†å™¨
context_manager = ContextManager(project)

# æ›´æ–°ä¸Šä¸‹æ–‡
context_manager.update_context(
    current_task="T001",
    current_milestone="æ¶æ„è®¾è®¡å®Œæˆ",
    notes="æ­£åœ¨è¿›è¡Œæ¶æ„è®¾è®¡ï¼Œéœ€è¦ç¡®å®šåˆ†å±‚ç»“æ„",
    next_actions=[
        "å®Œæˆæ¶æ„è®¾è®¡æ–‡æ¡£",
        "è¯„å®¡æ¶æ„æ–¹æ¡ˆ",
        "å¼€å§‹ç†è®ºåŸºç¡€ç¼–å†™"
    ],
    blockers=[
        "éœ€è¦ç¡®å®šå…·ä½“çš„æŠ€æœ¯æ ˆ",
        "ç­‰å¾…éœ€æ±‚ç¡®è®¤"
    ]
)

# ä¿å­˜ä¸Šä¸‹æ–‡
context_manager.save_context()

# åˆ›å»ºæ£€æŸ¥ç‚¹
context_manager.create_checkpoint()

# è·å–ä¸Šä¸‹æ–‡æ‘˜è¦
summary = context_manager.get_context_summary()
print(summary)

# æ¨¡æ‹Ÿä¸­æ–­åæ¢å¤
print("æ¨¡æ‹Ÿé¡¹ç›®ä¸­æ–­...")
# è¿™é‡Œå¯ä»¥æ¨¡æ‹Ÿé¡¹ç›®ä¸­æ–­

# åŠ è½½ä¸Šä¸‹æ–‡
if context_manager.load_context():
    print("ä¸Šä¸‹æ–‡æ¢å¤æˆåŠŸ")
    summary = context_manager.get_context_summary()
    print(summary)
else:
    print("ä¸Šä¸‹æ–‡æ¢å¤å¤±è´¥ï¼Œä½¿ç”¨æ£€æŸ¥ç‚¹")
    context_manager.restore_checkpoint()
```

## è´¨é‡ä¿è¯

### 1. è¿›åº¦å‡†ç¡®æ€§
- è¿›åº¦æ•°æ®çš„çœŸå®æ€§
- é¢„æµ‹æ¨¡å‹çš„å‡†ç¡®æ€§
- æŒ‡æ ‡è®¡ç®—çš„æ­£ç¡®æ€§

### 2. ä¸Šä¸‹æ–‡å®Œæ•´æ€§
- ä¸Šä¸‹æ–‡ä¿¡æ¯çš„å®Œæ•´æ€§
- çŠ¶æ€ä¿å­˜çš„å¯é æ€§
- æ¢å¤æœºåˆ¶çš„æœ‰æ•ˆæ€§

### 3. ç®¡ç†æœ‰æ•ˆæ€§
- ç®¡ç†æµç¨‹çš„åˆç†æ€§
- å·¥å…·ä½¿ç”¨çš„ä¾¿åˆ©æ€§
- å›¢é˜Ÿåä½œçš„æ•ˆç‡

## ç›¸å…³é“¾æ¥

- [07-å®è·µåº”ç”¨](../07-å®è·µåº”ç”¨/README.md) - å®é™…åº”ç”¨
- [06-ç»„ä»¶ç®—æ³•](../06-ç»„ä»¶ç®—æ³•/README.md) - å…·ä½“å®ç°
- [05-æ¶æ„é¢†åŸŸ](../05-æ¶æ„é¢†åŸŸ/README.md) - æ¶æ„è®¾è®¡

---

*æœ€åæ›´æ–°ï¼š2024å¹´12æœˆ*
