# 08-01 项目规划与进度

## 概述

项目规划与进度管理是确保知识库重构项目成功完成的关键环节。本文档建立了完整的项目管理体系，包括任务分解、进度跟踪、质量控制和持续改进。

## 1. 项目基础理论

### 1.1 形式化定义

#### 1.1.1 项目定义

**定义 1.1.1** (项目)
项目是一个五元组：
$$P = (T, R, S, C, G)$$
其中：
- $T$ 为任务集合
- $R$ 为资源集合
- $S$ 为状态集合
- $C$ 为约束集合
- $G$ 为目标集合

**定义 1.1.2** (任务依赖关系)
任务依赖关系定义为：
$$D \subseteq T \times T$$
其中 $(t_i, t_j) \in D$ 表示任务 $t_i$ 必须在任务 $t_j$ 之前完成。

**定义 1.1.3** (项目进度)
项目进度定义为：
$$Progress(P) = \frac{\sum_{t \in T} w_t \cdot s_t}{\sum_{t \in T} w_t}$$
其中 $w_t$ 为任务权重，$s_t \in [0,1]$ 为任务完成度。

#### 1.1.2 Python实现

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import datetime
import json
import networkx as nx
import matplotlib.pyplot as plt

class TaskStatus(Enum):
    """任务状态"""
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    BLOCKED = "blocked"
    CANCELLED = "cancelled"

class TaskPriority(Enum):
    """任务优先级"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class Task:
    """任务实体"""
    id: str
    name: str
    description: str
    priority: TaskPriority
    estimated_hours: float
    actual_hours: float = 0.0
    status: TaskStatus = TaskStatus.NOT_STARTED
    dependencies: Set[str] = field(default_factory=set)
    assignee: Optional[str] = None
    created_at: datetime.datetime = field(default_factory=datetime.datetime.now)
    started_at: Optional[datetime.datetime] = None
    completed_at: Optional[datetime.datetime] = None
    progress: float = 0.0  # 0.0 to 1.0
    
    def __str__(self):
        return f"Task(id={self.id}, name={self.name}, status={self.status.value}, progress={self.progress:.1%})"
    
    def start(self) -> None:
        """开始任务"""
        if self.status == TaskStatus.NOT_STARTED:
            self.status = TaskStatus.IN_PROGRESS
            self.started_at = datetime.datetime.now()
    
    def complete(self) -> None:
        """完成任务"""
        if self.status == TaskStatus.IN_PROGRESS:
            self.status = TaskStatus.COMPLETED
            self.completed_at = datetime.datetime.now()
            self.progress = 1.0
    
    def update_progress(self, progress: float) -> None:
        """更新进度"""
        if 0.0 <= progress <= 1.0:
            self.progress = progress
            if progress == 1.0:
                self.complete()
            elif progress > 0.0 and self.status == TaskStatus.NOT_STARTED:
                self.start()

@dataclass
class Resource:
    """资源实体"""
    id: str
    name: str
    type: str  # human, tool, system
    capacity: float  # 可用容量
    allocated: float = 0.0  # 已分配容量
    skills: Set[str] = field(default_factory=set)
    
    def get_availability(self) -> float:
        """获取可用容量"""
        return self.capacity - self.allocated
    
    def allocate(self, amount: float) -> bool:
        """分配资源"""
        if amount <= self.get_availability():
            self.allocated += amount
            return True
        return False
    
    def release(self, amount: float) -> None:
        """释放资源"""
        self.allocated = max(0.0, self.allocated - amount)

class Project:
    """项目类"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.tasks: Dict[str, Task] = {}
        self.resources: Dict[str, Resource] = {}
        self.dependencies: nx.DiGraph = nx.DiGraph()
        self.created_at = datetime.datetime.now()
        self.deadline: Optional[datetime.datetime] = None
    
    def add_task(self, task: Task) -> None:
        """添加任务"""
        self.tasks[task.id] = task
        self.dependencies.add_node(task.id)
    
    def add_dependency(self, from_task_id: str, to_task_id: str) -> None:
        """添加任务依赖"""
        if from_task_id in self.tasks and to_task_id in self.tasks:
            self.dependencies.add_edge(from_task_id, to_task_id)
            self.tasks[to_task_id].dependencies.add(from_task_id)
    
    def add_resource(self, resource: Resource) -> None:
        """添加资源"""
        self.resources[resource.id] = resource
    
    def get_available_tasks(self) -> List[Task]:
        """获取可执行的任务"""
        available_tasks = []
        
        for task in self.tasks.values():
            if task.status == TaskStatus.NOT_STARTED:
                # 检查依赖是否完成
                dependencies_completed = all(
                    self.tasks[dep_id].status == TaskStatus.COMPLETED
                    for dep_id in task.dependencies
                )
                if dependencies_completed:
                    available_tasks.append(task)
        
        return available_tasks
    
    def get_project_progress(self) -> float:
        """获取项目整体进度"""
        if not self.tasks:
            return 0.0
        
        total_weight = sum(task.estimated_hours for task in self.tasks.values())
        if total_weight == 0:
            return 0.0
        
        weighted_progress = sum(
            task.estimated_hours * task.progress 
            for task in self.tasks.values()
        )
        
        return weighted_progress / total_weight
    
    def get_critical_path(self) -> List[str]:
        """获取关键路径"""
        try:
            # 使用NetworkX计算关键路径
            critical_path = nx.dag_longest_path(self.dependencies)
            return critical_path
        except nx.NetworkXError:
            return []
    
    def get_project_stats(self) -> Dict[str, Any]:
        """获取项目统计信息"""
        total_tasks = len(self.tasks)
        completed_tasks = sum(1 for task in self.tasks.values() 
                            if task.status == TaskStatus.COMPLETED)
        in_progress_tasks = sum(1 for task in self.tasks.values() 
                              if task.status == TaskStatus.IN_PROGRESS)
        blocked_tasks = sum(1 for task in self.tasks.values() 
                          if task.status == TaskStatus.BLOCKED)
        
        total_estimated_hours = sum(task.estimated_hours for task in self.tasks.values())
        total_actual_hours = sum(task.actual_hours for task in self.tasks.values())
        
        return {
            "total_tasks": total_tasks,
            "completed_tasks": completed_tasks,
            "in_progress_tasks": in_progress_tasks,
            "blocked_tasks": blocked_tasks,
            "completion_rate": completed_tasks / total_tasks if total_tasks > 0 else 0,
            "progress_rate": self.get_project_progress(),
            "total_estimated_hours": total_estimated_hours,
            "total_actual_hours": total_actual_hours,
            "efficiency": total_estimated_hours / total_actual_hours if total_actual_hours > 0 else 0
        }
```

## 2. 任务分解与规划

### 2.1 工作分解结构 (WBS)

#### 2.1.1 形式化定义

**定义 2.1.1** (工作分解结构)
WBS是一个层次化的任务分解：
$$WBS = (N, E, L)$$
其中：
- $N$ 为节点集合（任务包）
- $E$ 为边集合（父子关系）
- $L$ 为层次函数

**定义 2.1.2** (任务包)
任务包定义为：
$$WP = (ID, Name, Tasks, Resources, Duration)$$

#### 2.1.2 Python实现

```python
@dataclass
class WorkPackage:
    """工作包"""
    id: str
    name: str
    description: str
    level: int
    parent_id: Optional[str] = None
    tasks: List[str] = field(default_factory=list)
    resources: List[str] = field(default_factory=list)
    estimated_duration: float = 0.0
    actual_duration: float = 0.0
    
    def add_task(self, task_id: str) -> None:
        """添加任务"""
        if task_id not in self.tasks:
            self.tasks.append(task_id)
    
    def add_resource(self, resource_id: str) -> None:
        """添加资源"""
        if resource_id not in self.resources:
            self.resources.append(resource_id)

class WorkBreakdownStructure:
    """工作分解结构"""
    
    def __init__(self):
        self.work_packages: Dict[str, WorkPackage] = {}
        self.hierarchy: Dict[str, List[str]] = {}  # parent_id -> [child_ids]
    
    def add_work_package(self, wp: WorkPackage) -> None:
        """添加工作包"""
        self.work_packages[wp.id] = wp
        
        if wp.parent_id:
            if wp.parent_id not in self.hierarchy:
                self.hierarchy[wp.parent_id] = []
            self.hierarchy[wp.parent_id].append(wp.id)
    
    def get_children(self, parent_id: str) -> List[WorkPackage]:
        """获取子工作包"""
        child_ids = self.hierarchy.get(parent_id, [])
        return [self.work_packages[cid] for cid in child_ids]
    
    def get_ancestors(self, wp_id: str) -> List[WorkPackage]:
        """获取祖先工作包"""
        ancestors = []
        current = self.work_packages.get(wp_id)
        
        while current and current.parent_id:
            parent = self.work_packages.get(current.parent_id)
            if parent:
                ancestors.append(parent)
                current = parent
            else:
                break
        
        return ancestors
    
    def get_descendants(self, wp_id: str) -> List[WorkPackage]:
        """获取后代工作包"""
        descendants = []
        children = self.get_children(wp_id)
        
        for child in children:
            descendants.append(child)
            descendants.extend(self.get_descendants(child.id))
        
        return descendants
    
    def calculate_duration(self, wp_id: str) -> float:
        """计算工作包持续时间"""
        wp = self.work_packages.get(wp_id)
        if not wp:
            return 0.0
        
        # 计算子工作包的持续时间
        children_duration = sum(
            self.calculate_duration(child.id) 
            for child in self.get_children(wp_id)
        )
        
        # 返回最大值（并行工作包取最大值，串行工作包取和）
        return max(wp.estimated_duration, children_duration)
    
    def visualize(self) -> None:
        """可视化WBS"""
        G = nx.DiGraph()
        
        # 添加节点
        for wp in self.work_packages.values():
            G.add_node(wp.id, label=f"{wp.name}\n({wp.estimated_duration}h)")
        
        # 添加边
        for wp in self.work_packages.values():
            if wp.parent_id:
                G.add_edge(wp.parent_id, wp.id)
        
        # 绘制
        plt.figure(figsize=(15, 10))
        pos = nx.spring_layout(G, k=3, iterations=50)
        nx.draw(G, pos, with_labels=True, node_color='lightblue', 
                node_size=3000, font_size=8, font_weight='bold',
                arrows=True, edge_color='gray')
        
        # 添加标签
        labels = nx.get_node_attributes(G, 'label')
        nx.draw_networkx_labels(G, pos, labels)
        
        plt.title("工作分解结构 (WBS)")
        plt.show()

def create_knowledge_base_wbs() -> WorkBreakdownStructure:
    """创建知识库重构项目的WBS"""
    wbs = WorkBreakdownStructure()
    
    # 1. 项目启动
    wp1 = WorkPackage("1", "项目启动", "项目初始化和规划", 1)
    wp1.estimated_duration = 8.0
    wbs.add_work_package(wp1)
    
    # 1.1 需求分析
    wp1_1 = WorkPackage("1.1", "需求分析", "分析现有文档和需求", 2, "1")
    wp1_1.estimated_duration = 16.0
    wbs.add_work_package(wp1_1)
    
    # 1.2 架构设计
    wp1_2 = WorkPackage("1.2", "架构设计", "设计文档结构和组织方式", 2, "1")
    wp1_2.estimated_duration = 24.0
    wbs.add_work_package(wp1_2)
    
    # 2. 内容重构
    wp2 = WorkPackage("2", "内容重构", "重构现有文档内容", 1)
    wp2.estimated_duration = 0.0  # 由子工作包计算
    wbs.add_work_package(wp2)
    
    # 2.1 理念基础
    wp2_1 = WorkPackage("2.1", "理念基础", "重构哲学和认知论内容", 2, "2")
    wp2_1.estimated_duration = 20.0
    wbs.add_work_package(wp2_1)
    
    # 2.2 形式科学
    wp2_2 = WorkPackage("2.2", "形式科学", "重构数学和逻辑内容", 2, "2")
    wp2_2.estimated_duration = 40.0
    wbs.add_work_package(wp2_2)
    
    # 2.3 理论基础
    wp2_3 = WorkPackage("2.3", "理论基础", "重构计算机科学理论", 2, "2")
    wp2_3.estimated_duration = 32.0
    wbs.add_work_package(wp2_3)
    
    # 2.4 具体科学
    wp2_4 = WorkPackage("2.4", "具体科学", "重构软件工程内容", 2, "2")
    wp2_4.estimated_duration = 36.0
    wbs.add_work_package(wp2_4)
    
    # 2.5 行业领域
    wp2_5 = WorkPackage("2.5", "行业领域", "重构行业应用内容", 2, "2")
    wp2_5.estimated_duration = 48.0
    wbs.add_work_package(wp2_5)
    
    # 2.6 架构领域
    wp2_6 = WorkPackage("2.6", "架构领域", "重构系统架构内容", 2, "2")
    wp2_6.estimated_duration = 28.0
    wbs.add_work_package(wp2_6)
    
    # 2.7 组件算法
    wp2_7 = WorkPackage("2.7", "组件算法", "重构算法实现内容", 2, "2")
    wp2_7.estimated_duration = 44.0
    wbs.add_work_package(wp2_7)
    
    # 2.8 实践应用
    wp2_8 = WorkPackage("2.8", "实践应用", "重构实践指南内容", 2, "2")
    wp2_8.estimated_duration = 32.0
    wbs.add_work_package(wp2_8)
    
    # 3. 质量保证
    wp3 = WorkPackage("3", "质量保证", "质量检查和验证", 1)
    wp3.estimated_duration = 24.0
    wbs.add_work_package(wp3)
    
    # 4. 项目交付
    wp4 = WorkPackage("4", "项目交付", "最终交付和文档", 1)
    wp4.estimated_duration = 16.0
    wbs.add_work_package(wp4)
    
    return wbs
```

## 3. 进度跟踪与控制

### 3.1 进度跟踪系统

```python
class ProgressTracker:
    """进度跟踪器"""
    
    def __init__(self, project: Project):
        self.project = project
        self.history: List[Dict[str, Any]] = []
        self.milestones: Dict[str, datetime.datetime] = {}
    
    def record_progress(self) -> None:
        """记录当前进度"""
        snapshot = {
            "timestamp": datetime.datetime.now(),
            "project_progress": self.project.get_project_progress(),
            "task_stats": self.project.get_project_stats(),
            "completed_tasks": [
                task.id for task in self.project.tasks.values()
                if task.status == TaskStatus.COMPLETED
            ],
            "in_progress_tasks": [
                task.id for task in self.project.tasks.values()
                if task.status == TaskStatus.IN_PROGRESS
            ]
        }
        self.history.append(snapshot)
    
    def add_milestone(self, name: str, target_date: datetime.datetime) -> None:
        """添加里程碑"""
        self.milestones[name] = target_date
    
    def check_milestone_status(self) -> Dict[str, Dict[str, Any]]:
        """检查里程碑状态"""
        current_date = datetime.datetime.now()
        milestone_status = {}
        
        for name, target_date in self.milestones.items():
            is_achieved = current_date >= target_date
            days_remaining = (target_date - current_date).days if not is_achieved else 0
            
            milestone_status[name] = {
                "target_date": target_date,
                "is_achieved": is_achieved,
                "days_remaining": days_remaining,
                "project_progress": self.project.get_project_progress()
            }
        
        return milestone_status
    
    def get_progress_trend(self) -> Dict[str, List[float]]:
        """获取进度趋势"""
        timestamps = [snapshot["timestamp"] for snapshot in self.history]
        progress_values = [snapshot["project_progress"] for snapshot in self.history]
        
        return {
            "timestamps": timestamps,
            "progress": progress_values
        }
    
    def generate_progress_report(self) -> Dict[str, Any]:
        """生成进度报告"""
        if not self.history:
            return {"error": "没有历史数据"}
        
        latest = self.history[-1]
        earliest = self.history[0]
        
        # 计算进度变化
        progress_change = latest["project_progress"] - earliest["project_progress"]
        time_elapsed = (latest["timestamp"] - earliest["timestamp"]).days
        
        # 计算进度速度
        progress_per_day = progress_change / time_elapsed if time_elapsed > 0 else 0
        
        # 预测完成时间
        remaining_progress = 1.0 - latest["project_progress"]
        estimated_days_to_completion = remaining_progress / progress_per_day if progress_per_day > 0 else float('inf')
        
        return {
            "current_progress": latest["project_progress"],
            "progress_change": progress_change,
            "time_elapsed_days": time_elapsed,
            "progress_per_day": progress_per_day,
            "estimated_days_to_completion": estimated_days_to_completion,
            "milestone_status": self.check_milestone_status(),
            "recent_activity": self.history[-5:] if len(self.history) >= 5 else self.history
        }
    
    def visualize_progress(self) -> None:
        """可视化进度"""
        if len(self.history) < 2:
            print("需要更多历史数据来生成图表")
            return
        
        trend = self.get_progress_trend()
        timestamps = trend["timestamps"]
        progress = trend["progress"]
        
        plt.figure(figsize=(12, 8))
        
        # 进度曲线
        plt.subplot(2, 1, 1)
        plt.plot(timestamps, progress, 'b-', linewidth=2, marker='o')
        plt.title("项目进度趋势")
        plt.ylabel("完成度")
        plt.grid(True)
        
        # 里程碑
        for name, target_date in self.milestones.items():
            plt.axvline(x=target_date, color='r', linestyle='--', alpha=0.7, label=name)
        
        # 任务状态分布
        plt.subplot(2, 1, 2)
        latest_stats = self.history[-1]["task_stats"]
        status_counts = [
            latest_stats["completed_tasks"],
            latest_stats["in_progress_tasks"],
            latest_stats["blocked_tasks"],
            latest_stats["total_tasks"] - latest_stats["completed_tasks"] - 
            latest_stats["in_progress_tasks"] - latest_stats["blocked_tasks"]
        ]
        status_labels = ["已完成", "进行中", "阻塞", "未开始"]
        colors = ['green', 'blue', 'red', 'gray']
        
        plt.pie(status_counts, labels=status_labels, colors=colors, autopct='%1.1f%%')
        plt.title("任务状态分布")
        
        plt.tight_layout()
        plt.show()

class ProjectController:
    """项目控制器"""
    
    def __init__(self, project: Project, tracker: ProgressTracker):
        self.project = project
        self.tracker = tracker
        self.risk_register: List[Dict[str, Any]] = []
        self.issue_register: List[Dict[str, Any]] = []
    
    def identify_risks(self) -> List[Dict[str, Any]]:
        """识别项目风险"""
        risks = []
        
        # 进度风险
        if self.project.get_project_progress() < 0.3 and len(self.project.history) > 5:
            risks.append({
                "type": "进度风险",
                "description": "项目进度落后于计划",
                "severity": "high",
                "mitigation": "增加资源投入或调整计划"
            })
        
        # 资源风险
        for resource in self.project.resources.values():
            if resource.get_availability() < 0.1:
                risks.append({
                    "type": "资源风险",
                    "description": f"资源 {resource.name} 可用性不足",
                    "severity": "medium",
                    "mitigation": "重新分配资源或增加容量"
                })
        
        # 依赖风险
        for task in self.project.tasks.values():
            if task.status == TaskStatus.BLOCKED:
                risks.append({
                    "type": "依赖风险",
                    "description": f"任务 {task.name} 被阻塞",
                    "severity": "medium",
                    "mitigation": "解决依赖问题或调整任务顺序"
                })
        
        return risks
    
    def register_issue(self, issue: Dict[str, Any]) -> None:
        """注册问题"""
        issue["id"] = len(self.issue_register) + 1
        issue["created_at"] = datetime.datetime.now()
        issue["status"] = "open"
        self.issue_register.append(issue)
    
    def resolve_issue(self, issue_id: int, resolution: str) -> None:
        """解决问题"""
        for issue in self.issue_register:
            if issue["id"] == issue_id:
                issue["status"] = "resolved"
                issue["resolution"] = resolution
                issue["resolved_at"] = datetime.datetime.now()
                break
    
    def get_project_health(self) -> Dict[str, Any]:
        """获取项目健康状态"""
        risks = self.identifier_risks()
        open_issues = [issue for issue in self.issue_register if issue["status"] == "open"]
        
        # 计算健康分数
        health_score = 100
        
        # 进度影响
        progress = self.project.get_project_progress()
        if progress < 0.5:
            health_score -= 20
        elif progress < 0.7:
            health_score -= 10
        
        # 风险影响
        high_risks = [r for r in risks if r["severity"] == "high"]
        medium_risks = [r for r in risks if r["severity"] == "medium"]
        health_score -= len(high_risks) * 15
        health_score -= len(medium_risks) * 5
        
        # 问题影响
        health_score -= len(open_issues) * 3
        
        health_score = max(0, health_score)
        
        return {
            "health_score": health_score,
            "status": "healthy" if health_score >= 70 else "warning" if health_score >= 40 else "critical",
            "risks": risks,
            "open_issues": open_issues,
            "progress": progress
        }
```

## 4. 资源管理

### 4.1 资源分配与优化

```python
class ResourceManager:
    """资源管理器"""
    
    def __init__(self, project: Project):
        self.project = project
        self.assignments: Dict[str, List[str]] = {}  # resource_id -> [task_ids]
        self.utilization_history: List[Dict[str, float]] = []
    
    def assign_resource(self, resource_id: str, task_id: str, hours: float) -> bool:
        """分配资源到任务"""
        resource = self.project.resources.get(resource_id)
        task = self.project.tasks.get(task_id)
        
        if not resource or not task:
            return False
        
        # 检查资源可用性
        if resource.allocate(hours):
            # 记录分配
            if resource_id not in self.assignments:
                self.assignments[resource_id] = []
            self.assignments[resource_id].append(task_id)
            
            # 更新任务
            task.assignee = resource_id
            task.actual_hours += hours
            
            return True
        
        return False
    
    def release_resource(self, resource_id: str, task_id: str, hours: float) -> None:
        """释放资源"""
        resource = self.project.resources.get(resource_id)
        if resource:
            resource.release(hours)
            
            # 更新分配记录
            if resource_id in self.assignments and task_id in self.assignments[resource_id]:
                self.assignments[resource_id].remove(task_id)
    
    def get_resource_utilization(self) -> Dict[str, float]:
        """获取资源利用率"""
        utilization = {}
        
        for resource in self.project.resources.values():
            if resource.capacity > 0:
                utilization[resource.id] = resource.allocated / resource.capacity
            else:
                utilization[resource.id] = 0.0
        
        return utilization
    
    def optimize_resource_allocation(self) -> Dict[str, List[str]]:
        """优化资源分配"""
        # 简化的资源优化算法
        optimized_assignments = {}
        
        # 按优先级排序任务
        sorted_tasks = sorted(
            self.project.tasks.values(),
            key=lambda t: (t.priority.value, t.estimated_hours),
            reverse=True
        )
        
        # 按技能匹配分配资源
        for task in sorted_tasks:
            if task.status != TaskStatus.NOT_STARTED:
                continue
            
            best_resource = None
            best_match_score = 0
            
            for resource in self.project.resources.values():
                if resource.get_availability() >= task.estimated_hours:
                    # 计算技能匹配度
                    match_score = len(resource.skills.intersection(set([task.name])))
                    if match_score > best_match_score:
                        best_match_score = match_score
                        best_resource = resource
            
            if best_resource:
                self.assign_resource(best_resource.id, task.id, task.estimated_hours)
                if best_resource.id not in optimized_assignments:
                    optimized_assignments[best_resource.id] = []
                optimized_assignments[best_resource.id].append(task.id)
        
        return optimized_assignments
    
    def generate_resource_report(self) -> Dict[str, Any]:
        """生成资源报告"""
        utilization = self.get_resource_utilization()
        
        return {
            "resource_utilization": utilization,
            "average_utilization": sum(utilization.values()) / len(utilization) if utilization else 0,
            "overallocated_resources": [
                rid for rid, util in utilization.items() if util > 1.0
            ],
            "underutilized_resources": [
                rid for rid, util in utilization.items() if util < 0.3
            ],
            "assignments": self.assignments
        }
```

## 5. 质量保证

### 5.1 质量检查与验收

```python
class QualityAssurance:
    """质量保证"""
    
    def __init__(self, project: Project):
        self.project = project
        self.quality_criteria: Dict[str, callable] = {}
        self.quality_checks: List[Dict[str, Any]] = []
    
    def add_quality_criterion(self, name: str, criterion_func: callable) -> None:
        """添加质量标准"""
        self.quality_criteria[name] = criterion_func
    
    def check_task_quality(self, task_id: str) -> Dict[str, Any]:
        """检查任务质量"""
        task = self.project.tasks.get(task_id)
        if not task:
            return {"error": "任务不存在"}
        
        quality_results = {}
        
        for criterion_name, criterion_func in self.quality_criteria.items():
            try:
                result = criterion_func(task)
                quality_results[criterion_name] = result
            except Exception as e:
                quality_results[criterion_name] = {"passed": False, "error": str(e)}
        
        # 记录质量检查
        check_record = {
            "task_id": task_id,
            "timestamp": datetime.datetime.now(),
            "results": quality_results,
            "overall_passed": all(
                result.get("passed", False) for result in quality_results.values()
            )
        }
        self.quality_checks.append(check_record)
        
        return check_record
    
    def check_project_quality(self) -> Dict[str, Any]:
        """检查项目整体质量"""
        completed_tasks = [
            task for task in self.project.tasks.values()
            if task.status == TaskStatus.COMPLETED
        ]
        
        quality_scores = []
        failed_checks = []
        
        for task in completed_tasks:
            check_result = self.check_task_quality(task.id)
            if check_result.get("overall_passed", False):
                quality_scores.append(1.0)
            else:
                quality_scores.append(0.0)
                failed_checks.append(check_result)
        
        overall_quality = sum(quality_scores) / len(quality_scores) if quality_scores else 0.0
        
        return {
            "overall_quality": overall_quality,
            "quality_level": "excellent" if overall_quality >= 0.9 else 
                           "good" if overall_quality >= 0.7 else 
                           "acceptable" if overall_quality >= 0.5 else "poor",
            "completed_tasks": len(completed_tasks),
            "quality_checked_tasks": len(quality_scores),
            "failed_checks": failed_checks
        }

def setup_quality_criteria(qa: QualityAssurance) -> None:
    """设置质量标准"""
    
    def completeness_check(task: Task) -> Dict[str, Any]:
        """完整性检查"""
        return {
            "passed": task.progress >= 1.0 and task.status == TaskStatus.COMPLETED,
            "details": f"进度: {task.progress:.1%}, 状态: {task.status.value}"
        }
    
    def documentation_check(task: Task) -> Dict[str, Any]:
        """文档检查"""
        # 简化实现，实际需要检查具体文档
        has_documentation = len(task.description) > 10
        return {
            "passed": has_documentation,
            "details": f"文档长度: {len(task.description)} 字符"
        }
    
    def code_quality_check(task: Task) -> Dict[str, Any]:
        """代码质量检查"""
        # 简化实现，实际需要运行代码检查工具
        return {
            "passed": True,
            "details": "代码质量检查通过"
        }
    
    qa.add_quality_criterion("completeness", completeness_check)
    qa.add_quality_criterion("documentation", documentation_check)
    qa.add_quality_criterion("code_quality", code_quality_check)
```

## 6. 项目执行示例

```python
def execute_knowledge_base_project() -> Dict[str, Any]:
    """执行知识库重构项目"""
    
    # 创建项目
    project = Project("知识库重构", "重构docs/model目录下的所有内容")
    
    # 创建WBS
    wbs = create_knowledge_base_wbs()
    
    # 创建任务
    tasks = [
        Task("T1", "需求分析", "分析现有文档结构", TaskPriority.HIGH, 16.0),
        Task("T2", "架构设计", "设计新的文档架构", TaskPriority.HIGH, 24.0),
        Task("T3", "理念基础重构", "重构哲学基础内容", TaskPriority.MEDIUM, 20.0),
        Task("T4", "形式科学重构", "重构数学基础内容", TaskPriority.MEDIUM, 40.0),
        Task("T5", "理论基础重构", "重构计算机科学理论", TaskPriority.MEDIUM, 32.0),
        Task("T6", "具体科学重构", "重构软件工程内容", TaskPriority.MEDIUM, 36.0),
        Task("T7", "行业领域重构", "重构行业应用内容", TaskPriority.MEDIUM, 48.0),
        Task("T8", "架构领域重构", "重构系统架构内容", TaskPriority.MEDIUM, 28.0),
        Task("T9", "组件算法重构", "重构算法实现内容", TaskPriority.MEDIUM, 44.0),
        Task("T10", "实践应用重构", "重构实践指南内容", TaskPriority.MEDIUM, 32.0),
        Task("T11", "质量检查", "全面质量检查", TaskPriority.HIGH, 24.0),
        Task("T12", "项目交付", "最终交付", TaskPriority.HIGH, 16.0)
    ]
    
    for task in tasks:
        project.add_task(task)
    
    # 设置依赖关系
    dependencies = [
        ("T1", "T2"),  # 需求分析 -> 架构设计
        ("T2", "T3"),  # 架构设计 -> 理念基础重构
        ("T2", "T4"),  # 架构设计 -> 形式科学重构
        ("T2", "T5"),  # 架构设计 -> 理论基础重构
        ("T2", "T6"),  # 架构设计 -> 具体科学重构
        ("T2", "T7"),  # 架构设计 -> 行业领域重构
        ("T2", "T8"),  # 架构设计 -> 架构领域重构
        ("T2", "T9"),  # 架构设计 -> 组件算法重构
        ("T2", "T10"), # 架构设计 -> 实践应用重构
        ("T3", "T11"), # 理念基础重构 -> 质量检查
        ("T4", "T11"), # 形式科学重构 -> 质量检查
        ("T5", "T11"), # 理论基础重构 -> 质量检查
        ("T6", "T11"), # 具体科学重构 -> 质量检查
        ("T7", "T11"), # 行业领域重构 -> 质量检查
        ("T8", "T11"), # 架构领域重构 -> 质量检查
        ("T9", "T11"), # 组件算法重构 -> 质量检查
        ("T10", "T11"), # 实践应用重构 -> 质量检查
        ("T11", "T12")  # 质量检查 -> 项目交付
    ]
    
    for from_task, to_task in dependencies:
        project.add_dependency(from_task, to_task)
    
    # 创建资源
    resources = [
        Resource("R1", "项目经理", "human", 40.0, skills={"management", "planning"}),
        Resource("R2", "技术专家", "human", 40.0, skills={"python", "mathematics", "software_engineering"}),
        Resource("R3", "内容专家", "human", 40.0, skills={"documentation", "research"}),
        Resource("R4", "质量专家", "human", 40.0, skills={"testing", "quality_assurance"})
    ]
    
    for resource in resources:
        project.add_resource(resource)
    
    # 创建进度跟踪器
    tracker = ProgressTracker(project)
    
    # 创建项目控制器
    controller = ProjectController(project, tracker)
    
    # 创建质量保证
    qa = QualityAssurance(project)
    setup_quality_criteria(qa)
    
    # 创建资源管理器
    resource_manager = ResourceManager(project)
    
    # 模拟项目执行
    print("=== 项目启动 ===")
    print(f"项目名称: {project.name}")
    print(f"总任务数: {len(project.tasks)}")
    print(f"总资源数: {len(project.resources)}")
    
    # 开始执行任务
    available_tasks = project.get_available_tasks()
    print(f"可执行任务: {[t.name for t in available_tasks]}")
    
    # 分配资源并执行任务
    for task in available_tasks[:3]:  # 执行前3个任务
        task.start()
        task.update_progress(0.5)
        
        # 分配资源
        resource_manager.assign_resource("R2", task.id, task.estimated_hours / 2)
        
        # 记录进度
        tracker.record_progress()
    
    # 生成报告
    progress_report = tracker.generate_progress_report()
    project_health = controller.get_project_health()
    quality_report = qa.check_project_quality()
    resource_report = resource_manager.generate_resource_report()
    
    return {
        "project_stats": project.get_project_stats(),
        "progress_report": progress_report,
        "project_health": project_health,
        "quality_report": quality_report,
        "resource_report": resource_report
    }

# 执行项目示例
if __name__ == "__main__":
    project_results = execute_knowledge_base_project()
    
    print("\n=== 项目执行结果 ===")
    print(f"项目统计: {project_results['project_stats']}")
    print(f"项目健康: {project_results['project_health']}")
    print(f"质量报告: {project_results['quality_report']}")
```

## 7. 总结

本文档建立了完整的项目规划与进度管理体系：

### 7.1 核心组件

1. **项目基础**: 任务、资源、依赖关系管理
2. **工作分解**: 层次化的任务分解结构
3. **进度跟踪**: 实时进度监控和趋势分析
4. **资源管理**: 资源分配和优化
5. **质量保证**: 质量检查和验收标准

### 7.2 管理特点

- 形式化定义和数学建模
- 自动化进度跟踪
- 智能资源分配
- 实时质量监控
- 风险识别和控制

### 7.3 应用价值

- 提高项目管理效率
- 确保项目按时交付
- 优化资源利用
- 保证项目质量
- 支持决策制定

### 7.4 相关链接

- [08-02 任务分解与分配](08-02_任务分解与分配.md)
- [08-03 质量检查与验收](08-03_质量检查与验收.md)
- [08-04 文档更新日志](08-04_文档更新日志.md)

---

*项目规划与进度管理是确保知识库重构项目成功的关键，本文档提供了完整的理论框架和实践指导。* 