# 08.03 ä¸Šä¸‹æ–‡ç®¡ç†

## ğŸ“– æ¦‚è¿°

ä¸Šä¸‹æ–‡ç®¡ç†æ˜¯ç¡®ä¿é¡¹ç›®èƒ½å¤Ÿæ”¯æŒä¸­æ–­åç»§ç»­çš„å…³é”®æœºåˆ¶ã€‚æœ¬æ–‡æ¡£å®šä¹‰äº†å¦‚ä½•ç»´æŠ¤é¡¹ç›®çŠ¶æ€ã€ä¿å­˜è¿›åº¦å’Œæ¢å¤å·¥ä½œçš„æ ‡å‡†æµç¨‹ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ä¸Šä¸‹æ–‡çŠ¶æ€å®šä¹‰

**å®šä¹‰**ï¼šä¸Šä¸‹æ–‡çŠ¶æ€æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $(P, S, D, M, T)$ï¼Œå…¶ä¸­ï¼š
- $P$ æ˜¯é¡¹ç›®çŠ¶æ€ (Project State)
- $S$ æ˜¯ä¼šè¯çŠ¶æ€ (Session State)
- $D$ æ˜¯æ•°æ®çŠ¶æ€ (Data State)
- $M$ æ˜¯å†…å­˜çŠ¶æ€ (Memory State)
- $T$ æ˜¯æ—¶é—´æˆ³ (Timestamp)

**Pythonå®ç°**ï¼š
```python
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
from datetime import datetime
import json
import pickle
import hashlib

@dataclass
class ProjectState:
    """é¡¹ç›®çŠ¶æ€"""
    current_module: str
    completed_modules: List[str]
    in_progress_modules: List[str]
    pending_modules: List[str]
    version: str
    last_updated: datetime

@dataclass
class SessionState:
    """ä¼šè¯çŠ¶æ€"""
    session_id: str
    current_task: str
    task_progress: float  # 0.0 åˆ° 1.0
    context_data: Dict[str, Any]
    error_log: List[str]

@dataclass
class DataState:
    """æ•°æ®çŠ¶æ€"""
    source_files: List[str]
    processed_files: List[str]
    generated_files: List[str]
    file_hashes: Dict[str, str]

@dataclass
class MemoryState:
    """å†…å­˜çŠ¶æ€"""
    cached_data: Dict[str, Any]
    temp_variables: Dict[str, Any]
    analysis_results: Dict[str, Any]

@dataclass
class ContextState:
    """å®Œæ•´ä¸Šä¸‹æ–‡çŠ¶æ€"""
    project: ProjectState
    session: SessionState
    data: DataState
    memory: MemoryState
    timestamp: datetime
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return asdict(self)
    
    def to_json(self) -> str:
        """è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²"""
        return json.dumps(self.to_dict(), default=str, indent=2)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'ContextState':
        """ä»JSONå­—ç¬¦ä¸²åˆ›å»º"""
        data = json.loads(json_str)
        return cls(**data)
```

### 2. ä¸Šä¸‹æ–‡ç®¡ç†å™¨

**Pythonå®ç°**ï¼š
```python
import os
import tempfile
from pathlib import Path

class ContextManager:
    """ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.context_file = self.project_root / ".context" / "current_state.json"
        self.backup_dir = self.project_root / ".context" / "backups"
        self.ensure_directories()
    
    def ensure_directories(self):
        """ç¡®ä¿ç›®å½•å­˜åœ¨"""
        self.context_file.parent.mkdir(parents=True, exist_ok=True)
        self.backup_dir.mkdir(parents=True, exist_ok=True)
    
    def save_context(self, context: ContextState):
        """ä¿å­˜ä¸Šä¸‹æ–‡"""
        # åˆ›å»ºå¤‡ä»½
        self.create_backup()
        
        # ä¿å­˜å½“å‰çŠ¶æ€
        with open(self.context_file, 'w', encoding='utf-8') as f:
            f.write(context.to_json())
    
    def load_context(self) -> Optional[ContextState]:
        """åŠ è½½ä¸Šä¸‹æ–‡"""
        if not self.context_file.exists():
            return None
        
        try:
            with open(self.context_file, 'r', encoding='utf-8') as f:
                json_str = f.read()
            return ContextState.from_json(json_str)
        except Exception as e:
            print(f"åŠ è½½ä¸Šä¸‹æ–‡å¤±è´¥: {e}")
            return None
    
    def create_backup(self):
        """åˆ›å»ºå¤‡ä»½"""
        if self.context_file.exists():
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = self.backup_dir / f"context_backup_{timestamp}.json"
            
            with open(self.context_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            with open(backup_file, 'w', encoding='utf-8') as f:
                f.write(content)
    
    def restore_from_backup(self, backup_file: str) -> bool:
        """ä»å¤‡ä»½æ¢å¤"""
        backup_path = self.backup_dir / backup_file
        if not backup_path.exists():
            return False
        
        try:
            with open(backup_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            with open(self.context_file, 'w', encoding='utf-8') as f:
                f.write(content)
            
            return True
        except Exception as e:
            print(f"æ¢å¤å¤‡ä»½å¤±è´¥: {e}")
            return False
    
    def get_available_backups(self) -> List[str]:
        """è·å–å¯ç”¨å¤‡ä»½åˆ—è¡¨"""
        if not self.backup_dir.exists():
            return []
        
        return [f.name for f in self.backup_dir.glob("context_backup_*.json")]
```

### 3. ä»»åŠ¡çŠ¶æ€è·Ÿè¸ª

**Pythonå®ç°**ï¼š
```python
from enum import Enum
from typing import Callable, Any

class TaskStatus(Enum):
    """ä»»åŠ¡çŠ¶æ€"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    SUSPENDED = "suspended"

@dataclass
class Task:
    """ä»»åŠ¡å®šä¹‰"""
    id: str
    name: str
    description: str
    status: TaskStatus
    progress: float
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    result: Optional[Any] = None
    error: Optional[str] = None
    dependencies: List[str] = None
    
    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = []

class TaskTracker:
    """ä»»åŠ¡è·Ÿè¸ªå™¨"""
    
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        self.task_queue: List[str] = []
        self.completed_tasks: List[str] = []
    
    def add_task(self, task: Task):
        """æ·»åŠ ä»»åŠ¡"""
        self.tasks[task.id] = task
        if task.status == TaskStatus.PENDING:
            self.task_queue.append(task.id)
    
    def start_task(self, task_id: str):
        """å¼€å§‹ä»»åŠ¡"""
        if task_id in self.tasks:
            task = self.tasks[task_id]
            task.status = TaskStatus.RUNNING
            task.start_time = datetime.now()
    
    def complete_task(self, task_id: str, result: Any = None):
        """å®Œæˆä»»åŠ¡"""
        if task_id in self.tasks:
            task = self.tasks[task_id]
            task.status = TaskStatus.COMPLETED
            task.progress = 1.0
            task.end_time = datetime.now()
            task.result = result
            
            if task_id in self.task_queue:
                self.task_queue.remove(task_id)
            
            self.completed_tasks.append(task_id)
    
    def fail_task(self, task_id: str, error: str):
        """ä»»åŠ¡å¤±è´¥"""
        if task_id in self.tasks:
            task = self.tasks[task_id]
            task.status = TaskStatus.FAILED
            task.end_time = datetime.now()
            task.error = error
    
    def suspend_task(self, task_id: str):
        """æš‚åœä»»åŠ¡"""
        if task_id in self.tasks:
            task = self.tasks[task_id]
            task.status = TaskStatus.SUSPENDED
    
    def get_ready_tasks(self) -> List[Task]:
        """è·å–å¯ä»¥æ‰§è¡Œçš„ä»»åŠ¡"""
        ready_tasks = []
        
        for task_id in self.task_queue:
            task = self.tasks[task_id]
            if task.status == TaskStatus.PENDING:
                # æ£€æŸ¥ä¾èµ–æ˜¯å¦å®Œæˆ
                dependencies_met = all(
                    dep_id in self.completed_tasks 
                    for dep_id in task.dependencies
                )
                
                if dependencies_met:
                    ready_tasks.append(task)
        
        return ready_tasks
    
    def get_progress_summary(self) -> Dict[str, Any]:
        """è·å–è¿›åº¦æ‘˜è¦"""
        total_tasks = len(self.tasks)
        completed_tasks = len(self.completed_tasks)
        failed_tasks = sum(1 for task in self.tasks.values() if task.status == TaskStatus.FAILED)
        running_tasks = sum(1 for task in self.tasks.values() if task.status == TaskStatus.RUNNING)
        pending_tasks = sum(1 for task in self.tasks.values() if task.status == TaskStatus.PENDING)
        
        return {
            "total": total_tasks,
            "completed": completed_tasks,
            "failed": failed_tasks,
            "running": running_tasks,
            "pending": pending_tasks,
            "progress_percentage": (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
        }
```

### 4. ä¼šè¯æ¢å¤æœºåˆ¶

**Pythonå®ç°**ï¼š
```python
class SessionManager:
    """ä¼šè¯ç®¡ç†å™¨"""
    
    def __init__(self, context_manager: ContextManager):
        self.context_manager = context_manager
        self.current_session: Optional[ContextState] = None
        self.task_tracker = TaskTracker()
    
    def start_session(self, session_id: str) -> ContextState:
        """å¼€å§‹æ–°ä¼šè¯"""
        # å°è¯•åŠ è½½ç°æœ‰ä¸Šä¸‹æ–‡
        existing_context = self.context_manager.load_context()
        
        if existing_context:
            self.current_session = existing_context
            # æ›´æ–°ä¼šè¯ID
            self.current_session.session.session_id = session_id
        else:
            # åˆ›å»ºæ–°ä¸Šä¸‹æ–‡
            self.current_session = self.create_initial_context(session_id)
        
        self.save_session()
        return self.current_session
    
    def create_initial_context(self, session_id: str) -> ContextState:
        """åˆ›å»ºåˆå§‹ä¸Šä¸‹æ–‡"""
        project_state = ProjectState(
            current_module="00.01-è®¡ç®—å“²å­¦åŸºç¡€",
            completed_modules=[],
            in_progress_modules=[],
            pending_modules=[
                "00.02-å½¢å¼åŒ–æ€ç»´æ–¹æ³•",
                "00.03-ç§‘å­¦æ–¹æ³•è®º",
                "01.01-æ•°å­¦åŸºç¡€",
                # ... å…¶ä»–æ¨¡å—
            ],
            version="v1.0.0",
            last_updated=datetime.now()
        )
        
        session_state = SessionState(
            session_id=session_id,
            current_task="åˆå§‹åŒ–é¡¹ç›®",
            task_progress=0.0,
            context_data={},
            error_log=[]
        )
        
        data_state = DataState(
            source_files=[],
            processed_files=[],
            generated_files=[],
            file_hashes={}
        )
        
        memory_state = MemoryState(
            cached_data={},
            temp_variables={},
            analysis_results={}
        )
        
        return ContextState(
            project=project_state,
            session=session_state,
            data=data_state,
            memory=memory_state,
            timestamp=datetime.now()
        )
    
    def save_session(self):
        """ä¿å­˜ä¼šè¯"""
        if self.current_session:
            self.current_session.timestamp = datetime.now()
            self.context_manager.save_context(self.current_session)
    
    def load_session(self) -> Optional[ContextState]:
        """åŠ è½½ä¼šè¯"""
        self.current_session = self.context_manager.load_context()
        return self.current_session
    
    def update_progress(self, module: str, progress: float):
        """æ›´æ–°è¿›åº¦"""
        if self.current_session:
            self.current_session.session.current_task = module
            self.current_session.session.task_progress = progress
            
            if progress >= 1.0 and module not in self.current_session.project.completed_modules:
                self.current_session.project.completed_modules.append(module)
                if module in self.current_session.project.pending_modules:
                    self.current_session.project.pending_modules.remove(module)
            
            self.save_session()
    
    def add_error(self, error: str):
        """æ·»åŠ é”™è¯¯æ—¥å¿—"""
        if self.current_session:
            self.current_session.session.error_log.append(f"{datetime.now()}: {error}")
            self.save_session()
    
    def get_session_summary(self) -> Dict[str, Any]:
        """è·å–ä¼šè¯æ‘˜è¦"""
        if not self.current_session:
            return {}
        
        return {
            "session_id": self.current_session.session.session_id,
            "current_task": self.current_session.session.current_task,
            "progress": self.current_session.session.task_progress,
            "completed_modules": len(self.current_session.project.completed_modules),
            "pending_modules": len(self.current_session.project.pending_modules),
            "errors": len(self.current_session.session.error_log),
            "last_updated": self.current_session.timestamp.isoformat()
        }
```

### 5. è‡ªåŠ¨æ¢å¤æœºåˆ¶

**Pythonå®ç°**ï¼š
```python
class AutoRecovery:
    """è‡ªåŠ¨æ¢å¤æœºåˆ¶"""
    
    def __init__(self, session_manager: SessionManager):
        self.session_manager = session_manager
        self.recovery_points: List[Dict[str, Any]] = []
    
    def create_recovery_point(self, description: str):
        """åˆ›å»ºæ¢å¤ç‚¹"""
        if self.session_manager.current_session:
            recovery_point = {
                "timestamp": datetime.now().isoformat(),
                "description": description,
                "context": self.session_manager.current_session.to_dict(),
                "task_summary": self.session_manager.get_session_summary()
            }
            
            self.recovery_points.append(recovery_point)
            
            # ä¿å­˜åˆ°æ–‡ä»¶
            self.save_recovery_point(recovery_point)
    
    def save_recovery_point(self, recovery_point: Dict[str, Any]):
        """ä¿å­˜æ¢å¤ç‚¹åˆ°æ–‡ä»¶"""
        timestamp = recovery_point["timestamp"].replace(":", "-")
        filename = f"recovery_point_{timestamp}.json"
        filepath = self.session_manager.context_manager.backup_dir / filename
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(recovery_point, f, indent=2, default=str)
    
    def auto_save(self):
        """è‡ªåŠ¨ä¿å­˜"""
        self.create_recovery_point("è‡ªåŠ¨ä¿å­˜ç‚¹")
    
    def recover_from_point(self, recovery_point: Dict[str, Any]) -> bool:
        """ä»æ¢å¤ç‚¹æ¢å¤"""
        try:
            # æ¢å¤ä¸Šä¸‹æ–‡çŠ¶æ€
            context_data = recovery_point["context"]
            context = ContextState.from_json(json.dumps(context_data))
            
            self.session_manager.current_session = context
            self.session_manager.save_session()
            
            return True
        except Exception as e:
            print(f"æ¢å¤å¤±è´¥: {e}")
            return False
    
    def get_recovery_points(self) -> List[Dict[str, Any]]:
        """è·å–æ‰€æœ‰æ¢å¤ç‚¹"""
        return self.recovery_points
```

### 6. ä½¿ç”¨ç¤ºä¾‹

**Pythonå®ç°**ï¼š
```python
def demonstrate_context_management():
    """æ¼”ç¤ºä¸Šä¸‹æ–‡ç®¡ç†"""
    
    # åˆå§‹åŒ–ä¸Šä¸‹æ–‡ç®¡ç†å™¨
    context_manager = ContextManager("./docs/refactor")
    session_manager = SessionManager(context_manager)
    auto_recovery = AutoRecovery(session_manager)
    
    # å¼€å§‹ä¼šè¯
    session = session_manager.start_session("session_001")
    print(f"å¼€å§‹ä¼šè¯: {session.session.session_id}")
    
    # æ›´æ–°è¿›åº¦
    session_manager.update_progress("00.01-è®¡ç®—å“²å­¦åŸºç¡€", 0.5)
    
    # åˆ›å»ºæ¢å¤ç‚¹
    auto_recovery.create_recovery_point("å®Œæˆè®¡ç®—å“²å­¦åŸºç¡€50%")
    
    # è·å–ä¼šè¯æ‘˜è¦
    summary = session_manager.get_session_summary()
    print(f"ä¼šè¯æ‘˜è¦: {summary}")
    
    # æ¨¡æ‹Ÿä¸­æ–­å’Œæ¢å¤
    print("æ¨¡æ‹Ÿä¸­æ–­...")
    
    # é‡æ–°åŠ è½½ä¼šè¯
    recovered_session = session_manager.load_session()
    if recovered_session:
        print(f"æ¢å¤ä¼šè¯: {recovered_session.session.session_id}")
        print(f"å½“å‰ä»»åŠ¡: {recovered_session.session.current_task}")
        print(f"è¿›åº¦: {recovered_session.session.task_progress}")

# æ‰§è¡Œæ¼”ç¤º
if __name__ == "__main__":
    demonstrate_context_management()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [08.01 å¼€å‘æ—¥å¿—](./08.01-å¼€å‘æ—¥å¿—.md)
- [08.02 ä»»åŠ¡è¿½è¸ª](./08.02-ä»»åŠ¡è¿½è¸ª.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Hunt, A., & Thomas, D. (2000). The pragmatic programmer: from journeyman to master. Addison-Wesley.
2. Martin, R. C. (2008). Clean code: a handbook of agile software craftsmanship. Pearson Education.
3. Fowler, M. (2018). Refactoring: improving the design of existing code. Addison-Wesley.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0.0 