# 08-02 任务分解与分配

## 概述

任务分解与分配是项目管理的核心环节，本文档建立了完整的任务管理体系，包括持续性上下文提醒体系，确保项目可以中断后继续执行。

## 1. 持续性上下文提醒体系

### 1.1 形式化定义

#### 1.1.1 上下文状态

**定义 1.1.1** (上下文状态)
上下文状态是一个七元组：
$$CS = (P, T, R, S, H, N, M)$$
其中：
- $P$ 为项目状态
- $T$ 为任务状态
- $R$ 为资源状态
- $S$ 为会话状态
- $H$ 为历史记录
- $N$ 为下一步行动
- $M$ 为记忆状态

**定义 1.1.2** (上下文转换)
上下文转换函数定义为：
$$CT: CS \times A \rightarrow CS$$
其中 $A$ 为行动集合。

#### 1.1.2 Python实现

```python
from typing import Dict, List, Set, Any, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import datetime
import json
import pickle
import hashlib
import os

class ContextState(Enum):
    """上下文状态枚举"""
    ACTIVE = "active"
    PAUSED = "paused"
    COMPLETED = "completed"
    INTERRUPTED = "interrupted"

class ActionType(Enum):
    """行动类型"""
    START_TASK = "start_task"
    COMPLETE_TASK = "complete_task"
    PAUSE_TASK = "pause_task"
    RESUME_TASK = "resume_task"
    ADD_RESOURCE = "add_resource"
    REMOVE_RESOURCE = "remove_resource"
    UPDATE_PROGRESS = "update_progress"
    SAVE_CONTEXT = "save_context"
    LOAD_CONTEXT = "load_context"

@dataclass
class ContextMemory:
    """上下文记忆"""
    key: str
    value: Any
    importance: float  # 0.0 to 1.0
    created_at: datetime.datetime
    last_accessed: datetime.datetime
    access_count: int = 0
    
    def update_access(self):
        """更新访问信息"""
        self.last_accessed = datetime.datetime.now()
        self.access_count += 1

@dataclass
class ContextAction:
    """上下文行动"""
    action_type: ActionType
    timestamp: datetime.datetime
    parameters: Dict[str, Any]
    result: Optional[Any] = None
    
    def __str__(self):
        return f"{self.action_type.value} at {self.timestamp}"

class PersistentContextManager:
    """持续性上下文管理器"""
    
    def __init__(self, project_id: str, context_file: str = "context.json"):
        self.project_id = project_id
        self.context_file = context_file
        self.memory: Dict[str, ContextMemory] = {}
        self.action_history: List[ContextAction] = []
        self.current_state = ContextState.ACTIVE
        self.next_actions: List[Dict[str, Any]] = []
        self.reminders: List[Dict[str, Any]] = []
        
        # 加载现有上下文
        self.load_context()
    
    def save_context(self) -> None:
        """保存上下文到文件"""
        context_data = {
            "project_id": self.project_id,
            "current_state": self.current_state.value,
            "memory": {
                key: {
                    "value": memory.value,
                    "importance": memory.importance,
                    "created_at": memory.created_at.isoformat(),
                    "last_accessed": memory.last_accessed.isoformat(),
                    "access_count": memory.access_count
                }
                for key, memory in self.memory.items()
            },
            "action_history": [
                {
                    "action_type": action.action_type.value,
                    "timestamp": action.timestamp.isoformat(),
                    "parameters": action.parameters,
                    "result": action.result
                }
                for action in self.action_history[-100:]  # 只保存最近100个行动
            ],
            "next_actions": self.next_actions,
            "reminders": self.reminders,
            "last_saved": datetime.datetime.now().isoformat()
        }
        
        with open(self.context_file, 'w', encoding='utf-8') as f:
            json.dump(context_data, f, indent=2, ensure_ascii=False)
    
    def load_context(self) -> None:
        """从文件加载上下文"""
        if not os.path.exists(self.context_file):
            return
        
        try:
            with open(self.context_file, 'r', encoding='utf-8') as f:
                context_data = json.load(f)
            
            # 恢复记忆
            self.memory.clear()
            for key, memory_data in context_data.get("memory", {}).items():
                memory = ContextMemory(
                    key=key,
                    value=memory_data["value"],
                    importance=memory_data["importance"],
                    created_at=datetime.datetime.fromisoformat(memory_data["created_at"]),
                    last_accessed=datetime.datetime.fromisoformat(memory_data["last_accessed"])
                )
                memory.access_count = memory_data["access_count"]
                self.memory[key] = memory
            
            # 恢复行动历史
            self.action_history.clear()
            for action_data in context_data.get("action_history", []):
                action = ContextAction(
                    action_type=ActionType(action_data["action_type"]),
                    timestamp=datetime.datetime.fromisoformat(action_data["timestamp"]),
                    parameters=action_data["parameters"],
                    result=action_data.get("result")
                )
                self.action_history.append(action)
            
            # 恢复其他状态
            self.current_state = ContextState(context_data.get("current_state", "active"))
            self.next_actions = context_data.get("next_actions", [])
            self.reminders = context_data.get("reminders", [])
            
        except Exception as e:
            print(f"加载上下文失败: {e}")
    
    def add_memory(self, key: str, value: Any, importance: float = 0.5) -> None:
        """添加记忆"""
        memory = ContextMemory(
            key=key,
            value=value,
            importance=importance,
            created_at=datetime.datetime.now(),
            last_accessed=datetime.datetime.now()
        )
        self.memory[key] = memory
        self.save_context()
    
    def get_memory(self, key: str) -> Optional[Any]:
        """获取记忆"""
        memory = self.memory.get(key)
        if memory:
            memory.update_access()
            return memory.value
        return None
    
    def get_important_memories(self, limit: int = 10) -> List[ContextMemory]:
        """获取重要记忆"""
        sorted_memories = sorted(
            self.memory.values(),
            key=lambda m: (m.importance, m.access_count, m.last_accessed),
            reverse=True
        )
        return sorted_memories[:limit]
    
    def record_action(self, action_type: ActionType, parameters: Dict[str, Any], 
                     result: Any = None) -> None:
        """记录行动"""
        action = ContextAction(
            action_type=action_type,
            timestamp=datetime.datetime.now(),
            parameters=parameters,
            result=result
        )
        self.action_history.append(action)
        self.save_context()
    
    def add_next_action(self, action: Dict[str, Any]) -> None:
        """添加下一步行动"""
        self.next_actions.append(action)
        self.save_context()
    
    def get_next_actions(self) -> List[Dict[str, Any]]:
        """获取下一步行动"""
        return self.next_actions.copy()
    
    def complete_next_action(self, action_index: int) -> None:
        """完成下一步行动"""
        if 0 <= action_index < len(self.next_actions):
            completed_action = self.next_actions.pop(action_index)
            self.record_action(
                ActionType.COMPLETE_TASK,
                {"completed_action": completed_action}
            )
    
    def add_reminder(self, message: str, priority: str = "medium", 
                    due_date: Optional[datetime.datetime] = None) -> None:
        """添加提醒"""
        reminder = {
            "message": message,
            "priority": priority,
            "created_at": datetime.datetime.now().isoformat(),
            "due_date": due_date.isoformat() if due_date else None,
            "completed": False
        }
        self.reminders.append(reminder)
        self.save_context()
    
    def get_active_reminders(self) -> List[Dict[str, Any]]:
        """获取活跃提醒"""
        return [r for r in self.reminders if not r.get("completed", False)]
    
    def complete_reminder(self, reminder_index: int) -> None:
        """完成提醒"""
        if 0 <= reminder_index < len(self.reminders):
            self.reminders[reminder_index]["completed"] = True
            self.save_context()
    
    def generate_context_summary(self) -> Dict[str, Any]:
        """生成上下文摘要"""
        return {
            "project_id": self.project_id,
            "current_state": self.current_state.value,
            "memory_count": len(self.memory),
            "action_count": len(self.action_history),
            "next_actions_count": len(self.next_actions),
            "active_reminders_count": len(self.get_active_reminders()),
            "important_memories": [
                {
                    "key": m.key,
                    "importance": m.importance,
                    "access_count": m.access_count
                }
                for m in self.get_important_memories(5)
            ],
            "recent_actions": [
                {
                    "action_type": a.action_type.value,
                    "timestamp": a.timestamp.isoformat()
                }
                for a in self.action_history[-5:]
            ],
            "next_actions": self.next_actions[:3],
            "active_reminders": self.get_active_reminders()[:3]
        }
    
    def resume_context(self) -> Dict[str, Any]:
        """恢复上下文"""
        summary = self.generate_context_summary()
        
        # 自动保存上下文
        self.save_context()
        
        return {
            "message": "上下文已恢复",
            "summary": summary,
            "recommendations": self._generate_recommendations()
        }
    
    def _generate_recommendations(self) -> List[str]:
        """生成建议"""
        recommendations = []
        
        # 基于当前状态生成建议
        if self.current_state == ContextState.INTERRUPTED:
            recommendations.append("检测到中断状态，建议检查未完成的任务")
        
        if len(self.next_actions) > 5:
            recommendations.append("待办事项较多，建议优先处理高优先级任务")
        
        if len(self.get_active_reminders()) > 3:
            recommendations.append("有多个活跃提醒，建议及时处理")
        
        # 基于记忆生成建议
        important_memories = self.get_important_memories(3)
        for memory in important_memories:
            if memory.importance > 0.8:
                recommendations.append(f"重要记忆: {memory.key} - {memory.value}")
        
        return recommendations

class TaskDecompositionManager:
    """任务分解管理器"""
    
    def __init__(self, context_manager: PersistentContextManager):
        self.context_manager = context_manager
        self.decomposition_rules: Dict[str, callable] = {}
        self.allocation_strategies: Dict[str, callable] = {}
    
    def add_decomposition_rule(self, rule_name: str, rule_func: callable) -> None:
        """添加分解规则"""
        self.decomposition_rules[rule_name] = rule_func
    
    def add_allocation_strategy(self, strategy_name: str, strategy_func: callable) -> None:
        """添加分配策略"""
        self.allocation_strategies[strategy_name] = strategy_func
    
    def decompose_task(self, task: Dict[str, Any], rule_name: str = "default") -> List[Dict[str, Any]]:
        """分解任务"""
        rule_func = self.decomposition_rules.get(rule_name)
        if not rule_func:
            raise ValueError(f"分解规则 {rule_name} 不存在")
        
        subtasks = rule_func(task)
        
        # 记录分解行动
        self.context_manager.record_action(
            ActionType.START_TASK,
            {
                "task": task,
                "rule": rule_name,
                "subtasks_count": len(subtasks)
            }
        )
        
        # 添加记忆
        self.context_manager.add_memory(
            f"task_decomposition_{task.get('id', 'unknown')}",
            {
                "original_task": task,
                "subtasks": subtasks,
                "rule_used": rule_name
            },
            importance=0.7
        )
        
        return subtasks
    
    def allocate_tasks(self, tasks: List[Dict[str, Any]], 
                      resources: List[Dict[str, Any]], 
                      strategy_name: str = "default") -> Dict[str, List[str]]:
        """分配任务"""
        strategy_func = self.allocation_strategies.get(strategy_name)
        if not strategy_func:
            raise ValueError(f"分配策略 {strategy_name} 不存在")
        
        allocation = strategy_func(tasks, resources)
        
        # 记录分配行动
        self.context_manager.record_action(
            ActionType.ADD_RESOURCE,
            {
                "tasks_count": len(tasks),
                "resources_count": len(resources),
                "strategy": strategy_name,
                "allocation": allocation
            }
        )
        
        return allocation
    
    def get_decomposition_history(self) -> List[Dict[str, Any]]:
        """获取分解历史"""
        history = []
        for action in self.context_manager.action_history:
            if action.action_type in [ActionType.START_TASK, ActionType.COMPLETE_TASK]:
                history.append({
                    "action_type": action.action_type.value,
                    "timestamp": action.timestamp.isoformat(),
                    "parameters": action.parameters
                })
        return history

def setup_decomposition_rules(manager: TaskDecompositionManager) -> None:
    """设置分解规则"""
    
    def default_decomposition_rule(task: Dict[str, Any]) -> List[Dict[str, Any]]:
        """默认分解规则"""
        complexity = task.get("complexity", "medium")
        estimated_hours = task.get("estimated_hours", 8)
        
        if complexity == "simple" or estimated_hours <= 4:
            return [task]  # 不分解
        
        # 按复杂度分解
        subtask_count = max(2, min(5, estimated_hours // 4))
        subtasks = []
        
        for i in range(subtask_count):
            subtask = task.copy()
            subtask["id"] = f"{task.get('id', 'task')}_sub_{i+1}"
            subtask["name"] = f"{task.get('name', 'Task')} - 子任务 {i+1}"
            subtask["estimated_hours"] = estimated_hours / subtask_count
            subtask["parent_task"] = task.get("id")
            subtask["subtask_index"] = i + 1
            subtasks.append(subtask)
        
        return subtasks
    
    def knowledge_base_decomposition_rule(task: Dict[str, Any]) -> List[Dict[str, Any]]:
        """知识库特定分解规则"""
        task_type = task.get("type", "general")
        
        if task_type == "document_creation":
            return [
                {
                    "id": f"{task['id']}_research",
                    "name": f"{task['name']} - 研究阶段",
                    "description": "收集和整理相关资料",
                    "estimated_hours": task.get("estimated_hours", 8) * 0.3
                },
                {
                    "id": f"{task['id']}_writing",
                    "name": f"{task['name']} - 编写阶段",
                    "description": "编写文档内容",
                    "estimated_hours": task.get("estimated_hours", 8) * 0.4
                },
                {
                    "id": f"{task['id']}_review",
                    "name": f"{task['name']} - 审查阶段",
                    "description": "审查和修改文档",
                    "estimated_hours": task.get("estimated_hours", 8) * 0.3
                }
            ]
        
        return default_decomposition_rule(task)
    
    manager.add_decomposition_rule("default", default_decomposition_rule)
    manager.add_decomposition_rule("knowledge_base", knowledge_base_decomposition_rule)

def setup_allocation_strategies(manager: TaskDecompositionManager) -> None:
    """设置分配策略"""
    
    def default_allocation_strategy(tasks: List[Dict[str, Any]], 
                                  resources: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """默认分配策略"""
        allocation = {}
        
        # 简单轮询分配
        for i, task in enumerate(tasks):
            resource_index = i % len(resources)
            resource_id = resources[resource_index]["id"]
            
            if resource_id not in allocation:
                allocation[resource_id] = []
            allocation[resource_id].append(task["id"])
        
        return allocation
    
    def skill_based_allocation_strategy(tasks: List[Dict[str, Any]], 
                                      resources: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """基于技能的分配策略"""
        allocation = {resource["id"]: [] for resource in resources}
        
        for task in tasks:
            task_skills = set(task.get("required_skills", []))
            best_resource = None
            best_match_score = 0
            
            for resource in resources:
                resource_skills = set(resource.get("skills", []))
                match_score = len(task_skills.intersection(resource_skills))
                
                if match_score > best_match_score:
                    best_match_score = match_score
                    best_resource = resource
            
            if best_resource:
                allocation[best_resource["id"]].append(task["id"])
            else:
                # 如果没有匹配的资源，分配给第一个可用资源
                allocation[resources[0]["id"]].append(task["id"])
        
        return allocation
    
    manager.add_allocation_strategy("default", default_allocation_strategy)
    manager.add_allocation_strategy("skill_based", skill_based_allocation_strategy)

class ContinuousExecutionManager:
    """持续执行管理器"""
    
    def __init__(self, context_manager: PersistentContextManager, 
                 task_manager: TaskDecompositionManager):
        self.context_manager = context_manager
        self.task_manager = task_manager
        self.execution_state = "ready"
        self.current_task_index = 0
        self.task_queue: List[Dict[str, Any]] = []
    
    def start_execution(self, tasks: List[Dict[str, Any]]) -> Dict[str, Any]:
        """开始执行"""
        self.task_queue = tasks.copy()
        self.current_task_index = 0
        self.execution_state = "running"
        
        # 记录开始执行
        self.context_manager.record_action(
            ActionType.START_TASK,
            {"tasks_count": len(tasks), "execution_started": True}
        )
        
        return {
            "status": "started",
            "total_tasks": len(tasks),
            "current_task": 0
        }
    
    def execute_next_task(self) -> Dict[str, Any]:
        """执行下一个任务"""
        if self.current_task_index >= len(self.task_queue):
            self.execution_state = "completed"
            return {"status": "completed", "message": "所有任务已完成"}
        
        current_task = self.task_queue[self.current_task_index]
        
        # 记录任务开始
        self.context_manager.record_action(
            ActionType.START_TASK,
            {"task_id": current_task.get("id"), "task_name": current_task.get("name")}
        )
        
        # 模拟任务执行
        result = self._execute_task(current_task)
        
        # 记录任务完成
        self.context_manager.record_action(
            ActionType.COMPLETE_TASK,
            {
                "task_id": current_task.get("id"),
                "result": result,
                "execution_time": result.get("execution_time", 0)
            }
        )
        
        self.current_task_index += 1
        
        return {
            "status": "task_completed",
            "task_id": current_task.get("id"),
            "task_name": current_task.get("name"),
            "result": result,
            "progress": f"{self.current_task_index}/{len(self.task_queue)}"
        }
    
    def pause_execution(self) -> Dict[str, Any]:
        """暂停执行"""
        self.execution_state = "paused"
        
        # 保存当前状态
        self.context_manager.add_memory(
            "execution_state",
            {
                "state": "paused",
                "current_task_index": self.current_task_index,
                "task_queue": self.task_queue,
                "timestamp": datetime.datetime.now().isoformat()
            },
            importance=0.9
        )
        
        self.context_manager.save_context()
        
        return {
            "status": "paused",
            "current_task_index": self.current_task_index,
            "total_tasks": len(self.task_queue)
        }
    
    def resume_execution(self) -> Dict[str, Any]:
        """恢复执行"""
        # 加载保存的状态
        saved_state = self.context_manager.get_memory("execution_state")
        
        if saved_state:
            self.current_task_index = saved_state["current_task_index"]
            self.task_queue = saved_state["task_queue"]
        
        self.execution_state = "running"
        
        return {
            "status": "resumed",
            "current_task_index": self.current_task_index,
            "total_tasks": len(self.task_queue)
        }
    
    def _execute_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """执行单个任务"""
        # 模拟任务执行
        import time
        import random
        
        execution_time = random.uniform(0.1, 2.0)
        time.sleep(execution_time)
        
        return {
            "status": "completed",
            "execution_time": execution_time,
            "result": f"Task {task.get('id')} completed successfully"
        }
    
    def get_execution_status(self) -> Dict[str, Any]:
        """获取执行状态"""
        return {
            "execution_state": self.execution_state,
            "current_task_index": self.current_task_index,
            "total_tasks": len(self.task_queue),
            "progress": self.current_task_index / len(self.task_queue) if self.task_queue else 0,
            "remaining_tasks": len(self.task_queue) - self.current_task_index
        }

def demonstrate_continuous_execution():
    """演示持续执行"""
    
    # 创建上下文管理器
    context_manager = PersistentContextManager("knowledge_base_refactor")
    
    # 创建任务分解管理器
    task_manager = TaskDecompositionManager(context_manager)
    setup_decomposition_rules(task_manager)
    setup_allocation_strategies(task_manager)
    
    # 创建持续执行管理器
    execution_manager = ContinuousExecutionManager(context_manager, task_manager)
    
    # 定义示例任务
    tasks = [
        {
            "id": "T1",
            "name": "分析现有文档结构",
            "description": "分析docs/model目录下的所有文档",
            "type": "analysis",
            "complexity": "medium",
            "estimated_hours": 8,
            "required_skills": ["analysis", "documentation"]
        },
        {
            "id": "T2",
            "name": "设计新的文档架构",
            "description": "设计符合学术规范的文档架构",
            "type": "design",
            "complexity": "high",
            "estimated_hours": 16,
            "required_skills": ["architecture", "design"]
        },
        {
            "id": "T3",
            "name": "创建理念基础文档",
            "description": "创建哲学基础与认知论文档",
            "type": "document_creation",
            "complexity": "medium",
            "estimated_hours": 12,
            "required_skills": ["writing", "philosophy"]
        }
    ]
    
    print("=== 开始持续执行演示 ===")
    
    # 开始执行
    start_result = execution_manager.start_execution(tasks)
    print(f"开始执行: {start_result}")
    
    # 执行前两个任务
    for i in range(2):
        result = execution_manager.execute_next_task()
        print(f"执行任务 {i+1}: {result}")
    
    # 暂停执行
    pause_result = execution_manager.pause_execution()
    print(f"暂停执行: {pause_result}")
    
    # 显示上下文摘要
    summary = context_manager.generate_context_summary()
    print(f"上下文摘要: {summary}")
    
    # 恢复执行
    resume_result = execution_manager.resume_execution()
    print(f"恢复执行: {resume_result}")
    
    # 完成剩余任务
    while execution_manager.execution_state == "running":
        result = execution_manager.execute_next_task()
        print(f"继续执行: {result}")
        if result["status"] == "completed":
            break
    
    # 最终状态
    final_status = execution_manager.get_execution_status()
    print(f"最终状态: {final_status}")
    
    # 生成最终报告
    final_summary = context_manager.generate_context_summary()
    print(f"最终摘要: {final_summary}")
    
    return {
        "context_manager": context_manager,
        "task_manager": task_manager,
        "execution_manager": execution_manager,
        "final_summary": final_summary
    }

# 运行演示
if __name__ == "__main__":
    results = demonstrate_continuous_execution()
```

## 2. 总结

本文档建立了完整的任务分解与分配体系：

### 2.1 核心特性

1. **持续性上下文管理**: 自动保存和恢复执行状态
2. **智能任务分解**: 基于规则的任务分解策略
3. **灵活资源分配**: 多种分配策略支持
4. **中断恢复机制**: 支持任务中断后继续执行
5. **上下文记忆**: 重要信息的持久化存储

### 2.2 应用价值

- 支持长时间运行的项目
- 确保任务执行的连续性
- 提供智能的任务管理
- 支持多用户协作
- 保证项目状态的一致性

### 2.3 相关链接

- [08-01 项目规划与进度](08-01_项目规划与进度.md)
- [08-03 质量检查与验收](08-03_质量检查与验收.md)
- [08-04 文档更新日志](08-04_文档更新日志.md)

---

*持续性上下文提醒体系确保了项目可以安全地中断和恢复，为长期项目的成功执行提供了重要保障。* 