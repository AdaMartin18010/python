# 事件驱动架构（EDA）

## 6.5 事件驱动架构

### 概念与原理

事件驱动架构（Event-Driven Architecture, EDA）是一种以事件为核心的系统架构模式，系统各组件通过事件进行解耦和协作。事件是对系统状态变化的描述，事件驱动架构强调异步通信、松耦合和高扩展性。

#### 核心特征
1. **事件解耦**：生产者与消费者通过事件进行解耦
2. **异步通信**：事件异步传递，提高系统吞吐量
3. **可扩展性**：易于扩展新事件处理逻辑
4. **灵活性**：支持多种事件流和处理方式

### 事件建模与事件流

#### 1. 事件定义与建模
```python
from dataclasses import dataclass, field
from typing import Dict, Any
from datetime import datetime
import uuid

@dataclass
class Event:
    event_type: str
    data: Dict[str, Any]
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)

# 示例事件
user_created = Event(
    event_type="UserCreated",
    data={"user_id": "u123", "username": "alice"}
)
```

#### 2. 事件流与事件处理
```python
from typing import Callable, List

class EventBus:
    def __init__(self):
        self.subscribers: Dict[str, List[Callable[[Event], None]]] = {}
    
    def subscribe(self, event_type: str, handler: Callable[[Event], None]):
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)
    
    def publish(self, event: Event):
        handlers = self.subscribers.get(event.event_type, [])
        for handler in handlers:
            handler(event)

# 示例事件处理器

def handle_user_created(event: Event):
    print(f"处理用户创建事件: {event.data}")

def handle_user_deleted(event: Event):
    print(f"处理用户删除事件: {event.data}")

# 注册事件处理器
bus = EventBus()
bus.subscribe("UserCreated", handle_user_created)
bus.subscribe("UserDeleted", handle_user_deleted)

# 发布事件
bus.publish(user_created)
bus.publish(Event(event_type="UserDeleted", data={"user_id": "u123"}))
```

### 事件总线与消息中间件

#### 1. 简易消息队列实现
```python
import queue
import threading
import time

class SimpleMessageQueue:
    def __init__(self):
        self.q = queue.Queue()
        self.subscribers: List[Callable[[Event], None]] = []
    
    def publish(self, event: Event):
        self.q.put(event)
    
    def subscribe(self, handler: Callable[[Event], None]):
        self.subscribers.append(handler)
    
    def start(self):
        def worker():
            while True:
                event = self.q.get()
                for handler in self.subscribers:
                    handler(event)
                self.q.task_done()
        threading.Thread(target=worker, daemon=True).start()

# 使用示例
mq = SimpleMessageQueue()
mq.subscribe(handle_user_created)
mq.start()
mq.publish(user_created)
```

#### 2. 与主流消息中间件集成（伪代码）
```python
# 以RabbitMQ为例，实际需安装pika库
# import pika
# connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
# channel = connection.channel()
# channel.queue_declare(queue='events')
# channel.basic_publish(exchange='', routing_key='events', body=event_json)
```

### 事件溯源（Event Sourcing）

#### 1. 事件存储与重放
```python
class EventStore:
    def __init__(self):
        self.events: List[Event] = []
    
    def append(self, event: Event):
        self.events.append(event)
    
    def replay(self, handler: Callable[[Event], None]):
        for event in self.events:
            handler(event)

# 示例：事件溯源重建状态
store = EventStore()
store.append(user_created)
store.append(Event(event_type="UserDeleted", data={"user_id": "u123"}))

print("重放事件：")
store.replay(lambda e: print(f"重放事件: {e.event_type} - {e.data}"))
```

### 事件一致性与幂等性

#### 1. 幂等事件处理
```python
class IdempotentEventHandler:
    def __init__(self):
        self.processed_event_ids = set()
    
    def handle(self, event: Event, handler: Callable[[Event], None]):
        if event.event_id in self.processed_event_ids:
            print(f"事件 {event.event_id} 已处理，跳过")
            return
        handler(event)
        self.processed_event_ids.add(event.event_id)

# 使用示例
idempotent_handler = IdempotentEventHandler()
idempotent_handler.handle(user_created, handle_user_created)
idempotent_handler.handle(user_created, handle_user_created)  # 第二次不会重复处理
```

### 应用案例

#### 1. 用户注册与通知事件流
```python
def send_welcome_email(event: Event):
    print(f"发送欢迎邮件给用户: {event.data['username']}")

# 注册事件处理器
bus.subscribe("UserCreated", send_welcome_email)

# 用户注册流程
new_user_event = Event(event_type="UserCreated", data={"user_id": "u456", "username": "bob"})
bus.publish(new_user_event)
```

#### 2. 订单系统中的事件驱动
```python
def handle_order_created(event: Event):
    print(f"订单创建: {event.data}")
    # 发布库存扣减事件
    bus.publish(Event(event_type="InventoryDeducted", data={"order_id": event.data["order_id"]}))

def handle_inventory_deducted(event: Event):
    print(f"库存已扣减: {event.data}")

bus.subscribe("OrderCreated", handle_order_created)
bus.subscribe("InventoryDeducted", handle_inventory_deducted)

# 订单创建事件
order_event = Event(event_type="OrderCreated", data={"order_id": "o1001", "user_id": "u456"})
bus.publish(order_event)
```

### 理论总结

事件驱动架构通过事件解耦系统各组件，提升系统的可扩展性、灵活性和容错性。通过事件总线、消息中间件、事件溯源等机制，支持复杂业务流程的异步处理和高可用设计，是现代分布式系统和微服务架构的重要基础。 