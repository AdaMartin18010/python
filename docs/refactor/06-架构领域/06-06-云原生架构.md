# 云原生架构

## 6.6 云原生架构

### 概念与原理

云原生架构是一种基于云计算技术构建和运行应用程序的方法，强调容器化、微服务、DevOps和持续交付等实践。

#### 核心特征

1. **容器化**：应用程序打包在容器中运行
2. **微服务**：应用程序拆分为小型、独立的服务
3. **DevOps**：开发与运维的协作和自动化
4. **持续交付**：快速、频繁地交付软件
5. **弹性扩展**：根据需求自动扩展资源

### 容器化技术

#### 1. Docker容器管理

```python
import subprocess
import json
import os
from typing import Dict, List

class DockerManager:
    def __init__(self):
        self.containers = {}
    
    def build_image(self, dockerfile_path: str, image_name: str, tag: str = "latest") -> bool:
        """构建Docker镜像"""
        try:
            cmd = f"docker build -t {image_name}:{tag} {dockerfile_path}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                print(f"镜像构建成功: {image_name}:{tag}")
                return True
            else:
                print(f"镜像构建失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"构建镜像异常: {e}")
            return False
    
    def run_container(self, image: str, container_name: str, port_mapping: str = None, 
                     env_vars: Dict[str, str] = None) -> bool:
        """运行容器"""
        try:
            cmd = f"docker run -d --name {container_name}"
            
            if port_mapping:
                cmd += f" -p {port_mapping}"
            
            if env_vars:
                for key, value in env_vars.items():
                    cmd += f" -e {key}={value}"
            
            cmd += f" {image}"
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                container_id = result.stdout.strip()
                self.containers[container_name] = {
                    "id": container_id,
                    "image": image,
                    "status": "running"
                }
                print(f"容器启动成功: {container_name}")
                return True
            else:
                print(f"容器启动失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"启动容器异常: {e}")
            return False
    
    def stop_container(self, container_name: str) -> bool:
        """停止容器"""
        try:
            cmd = f"docker stop {container_name}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                if container_name in self.containers:
                    self.containers[container_name]["status"] = "stopped"
                print(f"容器停止成功: {container_name}")
                return True
            else:
                print(f"容器停止失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"停止容器异常: {e}")
            return False
    
    def get_container_logs(self, container_name: str) -> str:
        """获取容器日志"""
        try:
            cmd = f"docker logs {container_name}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                return result.stdout
            else:
                return result.stderr
        except Exception as e:
            return f"获取日志异常: {e}"
    
    def list_containers(self) -> Dict:
        """列出所有容器"""
        return self.containers

def docker_example():
    """Docker示例"""
    docker_manager = DockerManager()
    
    # 构建镜像
    success = docker_manager.build_image("./app", "myapp", "v1.0")
    
    if success:
        # 运行容器
        env_vars = {"DB_HOST": "localhost", "DB_PORT": "5432"}
        docker_manager.run_container("myapp:v1.0", "myapp-container", "8080:8080", env_vars)
        
        # 获取日志
        logs = docker_manager.get_container_logs("myapp-container")
        print(f"容器日志: {logs}")
        
        # 列出容器
        containers = docker_manager.list_containers()
        print(f"容器列表: {containers}")
    
    return docker_manager
```

### Kubernetes集群管理

#### 1. Kubernetes API客户端

```python
from kubernetes import client, config
from kubernetes.client.rest import ApiException
import yaml

class KubernetesManager:
    def __init__(self):
        try:
            config.load_kube_config()
            self.v1 = client.CoreV1Api()
            self.apps_v1 = client.AppsV1Api()
        except Exception as e:
            print(f"Kubernetes配置加载失败: {e}")
    
    def create_namespace(self, name: str) -> bool:
        """创建命名空间"""
        try:
            namespace = client.V1Namespace(
                metadata=client.V1ObjectMeta(name=name)
            )
            self.v1.create_namespace(namespace)
            print(f"命名空间创建成功: {name}")
            return True
        except ApiException as e:
            print(f"创建命名空间失败: {e}")
            return False
    
    def create_deployment(self, name: str, image: str, replicas: int = 1) -> bool:
        """创建Deployment"""
        try:
            deployment = client.V1Deployment(
                metadata=client.V1ObjectMeta(name=name),
                spec=client.V1DeploymentSpec(
                    replicas=replicas,
                    selector=client.V1LabelSelector(
                        match_labels={"app": name}
                    ),
                    template=client.V1PodTemplateSpec(
                        metadata=client.V1ObjectMeta(
                            labels={"app": name}
                        ),
                        spec=client.V1PodSpec(
                            containers=[
                                client.V1Container(
                                    name=name,
                                    image=image
                                )
                            ]
                        )
                    )
                )
            )
            
            self.apps_v1.create_namespaced_deployment(
                namespace="default",
                body=deployment
            )
            print(f"Deployment创建成功: {name}")
            return True
        except ApiException as e:
            print(f"创建Deployment失败: {e}")
            return False
    
    def create_service(self, name: str, port: int, target_port: int) -> bool:
        """创建Service"""
        try:
            service = client.V1Service(
                metadata=client.V1ObjectMeta(name=name),
                spec=client.V1ServiceSpec(
                    selector={"app": name},
                    ports=[
                        client.V1ServicePort(
                            port=port,
                            target_port=target_port
                        )
                    ]
                )
            )
            
            self.v1.create_namespaced_service(
                namespace="default",
                body=service
            )
            print(f"Service创建成功: {name}")
            return True
        except ApiException as e:
            print(f"创建Service失败: {e}")
            return False
    
    def get_pods(self, namespace: str = "default") -> List[Dict]:
        """获取Pod列表"""
        try:
            pods = self.v1.list_namespaced_pod(namespace)
            return [
                {
                    "name": pod.metadata.name,
                    "status": pod.status.phase,
                    "ip": pod.status.pod_ip
                }
                for pod in pods.items
            ]
        except ApiException as e:
            print(f"获取Pod列表失败: {e}")
            return []
    
    def scale_deployment(self, name: str, replicas: int) -> bool:
        """扩缩容Deployment"""
        try:
            self.apps_v1.patch_namespaced_deployment_scale(
                name=name,
                namespace="default",
                body={"spec": {"replicas": replicas}}
            )
            print(f"Deployment扩缩容成功: {name} -> {replicas} replicas")
            return True
        except ApiException as e:
            print(f"扩缩容失败: {e}")
            return False

def kubernetes_example():
    """Kubernetes示例"""
    k8s_manager = KubernetesManager()
    
    # 创建命名空间
    k8s_manager.create_namespace("myapp")
    
    # 创建Deployment
    k8s_manager.create_deployment("myapp", "myapp:v1.0", 3)
    
    # 创建Service
    k8s_manager.create_service("myapp-service", 80, 8080)
    
    # 获取Pod列表
    pods = k8s_manager.get_pods("default")
    print(f"Pod列表: {pods}")
    
    # 扩缩容
    k8s_manager.scale_deployment("myapp", 5)
    
    return k8s_manager
```

### 服务网格（Service Mesh）

#### 1. Istio服务网格模拟

```python
class ServiceMesh:
    def __init__(self):
        self.services = {}
        self.policies = {}
        self.traffic_rules = {}
    
    def register_service(self, service_name: str, version: str, endpoints: List[str]):
        """注册服务"""
        if service_name not in self.services:
            self.services[service_name] = {}
        
        self.services[service_name][version] = {
            "endpoints": endpoints,
            "weight": 100,
            "health": "healthy"
        }
    
    def set_traffic_policy(self, service_name: str, policy: Dict):
        """设置流量策略"""
        self.policies[service_name] = policy
    
    def route_traffic(self, service_name: str, request: Dict) -> str:
        """路由流量"""
        if service_name not in self.services:
            return None
        
        # 应用流量策略
        policy = self.policies.get(service_name, {})
        
        if "version_weights" in policy:
            # 按权重路由
            return self._weighted_routing(service_name, policy["version_weights"])
        elif "circuit_breaker" in policy:
            # 熔断器
            return self._circuit_breaker_routing(service_name, policy["circuit_breaker"])
        else:
            # 默认轮询
            return self._round_robin_routing(service_name)
    
    def _weighted_routing(self, service_name: str, weights: Dict[str, int]) -> str:
        """权重路由"""
        import random
        
        versions = list(weights.keys())
        weight_values = list(weights.values())
        
        chosen_version = random.choices(versions, weights=weight_values)[0]
        endpoints = self.services[service_name][chosen_version]["endpoints"]
        
        return random.choice(endpoints)
    
    def _circuit_breaker_routing(self, service_name: str, config: Dict) -> str:
        """熔断器路由"""
        # 检查熔断器状态
        if self._is_circuit_open(service_name, config):
            return None
        
        # 选择健康端点
        healthy_endpoints = []
        for version, info in self.services[service_name].items():
            if info["health"] == "healthy":
                healthy_endpoints.extend(info["endpoints"])
        
        if healthy_endpoints:
            return random.choice(healthy_endpoints)
        else:
            return None
    
    def _round_robin_routing(self, service_name: str) -> str:
        """轮询路由"""
        all_endpoints = []
        for version, info in self.services[service_name].items():
            all_endpoints.extend(info["endpoints"])
        
        if all_endpoints:
            return random.choice(all_endpoints)
        else:
            return None
    
    def _is_circuit_open(self, service_name: str, config: Dict) -> bool:
        """检查熔断器是否开启"""
        # 简化实现
        return False

def service_mesh_example():
    """服务网格示例"""
    mesh = ServiceMesh()
    
    # 注册服务
    mesh.register_service("user-service", "v1", ["user-v1-1:8080", "user-v1-2:8080"])
    mesh.register_service("user-service", "v2", ["user-v2-1:8080"])
    
    # 设置流量策略
    mesh.set_traffic_policy("user-service", {
        "version_weights": {"v1": 80, "v2": 20}
    })
    
    # 路由流量
    for i in range(10):
        endpoint = mesh.route_traffic("user-service", {"user_id": i})
        print(f"请求 {i} 路由到: {endpoint}")
    
    return mesh
```

### DevOps与CI/CD

#### 1. 持续集成流水线

```python
import subprocess
import time
from typing import List, Dict

class CICDPipeline:
    def __init__(self):
        self.stages = []
        self.current_stage = 0
        self.status = "pending"
    
    def add_stage(self, name: str, commands: List[str]):
        """添加流水线阶段"""
        self.stages.append({
            "name": name,
            "commands": commands,
            "status": "pending"
        })
    
    def run_pipeline(self) -> bool:
        """运行流水线"""
        print("开始运行CI/CD流水线...")
        self.status = "running"
        
        for i, stage in enumerate(self.stages):
            print(f"执行阶段: {stage['name']}")
            stage['status'] = 'running'
            
            success = self._execute_stage(stage)
            
            if success:
                stage['status'] = 'success'
                print(f"阶段 {stage['name']} 执行成功")
            else:
                stage['status'] = 'failed'
                self.status = 'failed'
                print(f"阶段 {stage['name']} 执行失败")
                return False
        
        self.status = 'success'
        print("流水线执行完成")
        return True
    
    def _execute_stage(self, stage: Dict) -> bool:
        """执行单个阶段"""
        for command in stage['commands']:
            try:
                print(f"执行命令: {command}")
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode != 0:
                    print(f"命令执行失败: {result.stderr}")
                    return False
                
                print(f"命令执行成功: {result.stdout}")
            except Exception as e:
                print(f"命令执行异常: {e}")
                return False
        
        return True
    
    def get_status(self) -> Dict:
        """获取流水线状态"""
        return {
            "status": self.status,
            "stages": self.stages
        }

def cicd_example():
    """CI/CD示例"""
    pipeline = CICDPipeline()
    
    # 添加流水线阶段
    pipeline.add_stage("代码检查", [
        "python -m flake8 .",
        "python -m pytest tests/"
    ])
    
    pipeline.add_stage("构建", [
        "docker build -t myapp:latest ."
    ])
    
    pipeline.add_stage("测试", [
        "docker run --rm myapp:latest python -m pytest"
    ])
    
    pipeline.add_stage("部署", [
        "docker push myapp:latest",
        "kubectl apply -f k8s/"
    ])
    
    # 运行流水线
    success = pipeline.run_pipeline()
    
    # 获取状态
    status = pipeline.get_status()
    print(f"流水线状态: {status}")
    
    return pipeline
```

### 云原生存储

#### 1. 分布式存储系统

```python
class DistributedStorage:
    def __init__(self, nodes: List[str]):
        self.nodes = nodes
        self.data = {}
        self.replication_factor = 3
    
    def put(self, key: str, value: str) -> bool:
        """存储数据"""
        # 选择存储节点
        storage_nodes = self._select_storage_nodes(key)
        
        # 复制数据到多个节点
        success_count = 0
        for node in storage_nodes:
            if self._store_on_node(node, key, value):
                success_count += 1
        
        # 如果多数节点成功，认为存储成功
        return success_count >= (self.replication_factor + 1) // 2
    
    def get(self, key: str) -> str:
        """获取数据"""
        # 从多个节点读取
        storage_nodes = self._select_storage_nodes(key)
        
        for node in storage_nodes:
            value = self._get_from_node(node, key)
            if value is not None:
                return value
        
        return None
    
    def _select_storage_nodes(self, key: str) -> List[str]:
        """选择存储节点"""
        import hashlib
        
        # 使用一致性哈希选择节点
        hash_value = int(hashlib.md5(key.encode()).hexdigest(), 16)
        node_index = hash_value % len(self.nodes)
        
        selected_nodes = []
        for i in range(self.replication_factor):
            node_index = (node_index + i) % len(self.nodes)
            selected_nodes.append(self.nodes[node_index])
        
        return selected_nodes
    
    def _store_on_node(self, node: str, key: str, value: str) -> bool:
        """在节点上存储数据"""
        # 模拟网络存储
        if node not in self.data:
            self.data[node] = {}
        
        self.data[node][key] = value
        return True
    
    def _get_from_node(self, node: str, key: str) -> str:
        """从节点获取数据"""
        # 模拟网络读取
        if node in self.data and key in self.data[node]:
            return self.data[node][key]
        return None

def storage_example():
    """存储示例"""
    storage = DistributedStorage(["node1", "node2", "node3", "node4"])
    
    # 存储数据
    storage.put("user:1", "Alice")
    storage.put("user:2", "Bob")
    
    # 读取数据
    user1 = storage.get("user:1")
    user2 = storage.get("user:2")
    
    print(f"用户1: {user1}")
    print(f"用户2: {user2}")
    
    return storage
```

### 云原生安全

#### 1. 身份认证与授权

```python
import jwt
import hashlib
from datetime import datetime, timedelta

class SecurityManager:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.users = {}
        self.tokens = {}
    
    def register_user(self, username: str, password: str) -> bool:
        """注册用户"""
        if username in self.users:
            return False
        
        # 密码哈希
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        
        self.users[username] = {
            "password_hash": password_hash,
            "roles": ["user"],
            "created_at": datetime.now()
        }
        
        return True
    
    def authenticate(self, username: str, password: str) -> str:
        """用户认证"""
        if username not in self.users:
            return None
        
        user = self.users[username]
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        
        if password_hash == user["password_hash"]:
            # 生成JWT令牌
            token = jwt.encode({
                "username": username,
                "roles": user["roles"],
                "exp": datetime.utcnow() + timedelta(hours=24)
            }, self.secret_key, algorithm="HS256")
            
            self.tokens[token] = {
                "username": username,
                "expires_at": datetime.utcnow() + timedelta(hours=24)
            }
            
            return token
        
        return None
    
    def verify_token(self, token: str) -> Dict:
        """验证令牌"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            return payload
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
    
    def authorize(self, token: str, required_role: str) -> bool:
        """授权检查"""
        payload = self.verify_token(token)
        if payload is None:
            return False
        
        return required_role in payload.get("roles", [])

def security_example():
    """安全示例"""
    security = SecurityManager("my-secret-key")
    
    # 注册用户
    security.register_user("alice", "password123")
    security.register_user("bob", "password456")
    
    # 用户认证
    token = security.authenticate("alice", "password123")
    print(f"认证令牌: {token}")
    
    # 验证令牌
    payload = security.verify_token(token)
    print(f"令牌载荷: {payload}")
    
    # 授权检查
    authorized = security.authorize(token, "user")
    print(f"授权结果: {authorized}")
    
    return security
```

### 实战案例：云原生应用部署

```python
class CloudNativeApp:
    def __init__(self):
        self.docker_manager = DockerManager()
        self.k8s_manager = KubernetesManager()
        self.cicd_pipeline = CICDPipeline()
        self.storage = DistributedStorage(["storage1", "storage2", "storage3"])
        self.security = SecurityManager("app-secret-key")
    
    def deploy_application(self, app_name: str, image: str):
        """部署应用"""
        print(f"开始部署应用: {app_name}")
        
        # 1. 构建镜像
        print("1. 构建Docker镜像")
        self.docker_manager.build_image("./app", image, "latest")
        
        # 2. 创建Kubernetes资源
        print("2. 创建Kubernetes资源")
        self.k8s_manager.create_deployment(app_name, f"{image}:latest", 3)
        self.k8s_manager.create_service(f"{app_name}-service", 80, 8080)
        
        # 3. 配置存储
        print("3. 配置存储")
        self.storage.put(f"app:{app_name}:config", "app-config")
        
        # 4. 设置安全策略
        print("4. 设置安全策略")
        self.security.register_user("admin", "admin123")
        
        print(f"应用 {app_name} 部署完成")
    
    def scale_application(self, app_name: str, replicas: int):
        """扩缩容应用"""
        print(f"扩缩容应用 {app_name} 到 {replicas} 个副本")
        self.k8s_manager.scale_deployment(app_name, replicas)
    
    def monitor_application(self, app_name: str):
        """监控应用"""
        print(f"监控应用: {app_name}")
        
        # 获取Pod状态
        pods = self.k8s_manager.get_pods()
        print(f"Pod状态: {pods}")
        
        # 检查存储状态
        config = self.storage.get(f"app:{app_name}:config")
        print(f"应用配置: {config}")

def cloud_native_example():
    """云原生应用示例"""
    app = CloudNativeApp()
    
    # 部署应用
    app.deploy_application("myapp", "myapp")
    
    # 扩缩容
    app.scale_application("myapp", 5)
    
    # 监控
    app.monitor_application("myapp")
    
    return app

# 运行示例
if __name__ == "__main__":
    print("=== 云原生架构实战示例 ===")
    
    # Docker容器化
    print("\n1. Docker容器化")
    docker_manager = docker_example()
    
    # Kubernetes集群管理
    print("\n2. Kubernetes集群管理")
    k8s_manager = kubernetes_example()
    
    # 服务网格
    print("\n3. 服务网格")
    service_mesh = service_mesh_example()
    
    # CI/CD流水线
    print("\n4. CI/CD流水线")
    cicd_pipeline = cicd_example()
    
    # 分布式存储
    print("\n5. 分布式存储")
    storage = storage_example()
    
    # 安全认证
    print("\n6. 安全认证")
    security = security_example()
    
    # 完整云原生应用
    print("\n7. 云原生应用部署")
    cloud_app = cloud_native_example()
    
    print("\n云原生架构实战完成！")
```

### 理论总结

云原生架构通过容器化、微服务、DevOps等技术和实践，实现了应用程序的快速部署、弹性扩展和高可用性。Kubernetes提供了强大的容器编排能力，服务网格实现了细粒度的流量管理，CI/CD流水线实现了自动化部署，分布式存储和安全机制为云原生应用提供了可靠的基础设施支撑。
