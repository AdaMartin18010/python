# 微服务架构

## 6.3 微服务架构

### 概念与原理

微服务架构是一种将单体应用拆分为多个小型、独立服务的架构模式，每个服务负责特定的业务功能。

#### 核心特征

1. **服务拆分**：按业务领域划分服务
2. **独立部署**：每个服务可独立开发、测试、部署
3. **技术多样性**：不同服务可使用不同技术栈
4. **数据隔离**：每个服务拥有独立的数据存储
5. **服务治理**：服务注册、发现、配置、监控

### 服务拆分策略

#### 1. 领域驱动设计（DDD）

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any
import uuid
from datetime import datetime

class DomainEvent:
    def __init__(self, event_type: str, data: Dict[str, Any]):
        self.event_id = str(uuid.uuid4())
        self.event_type = event_type
        self.data = data
        self.timestamp = datetime.now()

class AggregateRoot(ABC):
    def __init__(self, id: str):
        self.id = id
        self._events: List[DomainEvent] = []
        self._version = 0
    
    def add_event(self, event: DomainEvent):
        self._events.append(event)
    
    def get_events(self) -> List[DomainEvent]:
        return self._events.copy()
    
    def clear_events(self):
        self._events.clear()
    
    @abstractmethod
    def apply_event(self, event: DomainEvent):
        pass

# 用户领域
class User(AggregateRoot):
    def __init__(self, user_id: str, username: str, email: str):
        super().__init__(user_id)
        self.username = username
        self.email = email
        self.status = "active"
    
    def change_email(self, new_email: str):
        if new_email != self.email:
            self.email = new_email
            event = DomainEvent("UserEmailChanged", {
                "user_id": self.id,
                "old_email": self.email,
                "new_email": new_email
            })
            self.add_event(event)
    
    def deactivate(self):
        if self.status == "active":
            self.status = "inactive"
            event = DomainEvent("UserDeactivated", {
                "user_id": self.id
            })
            self.add_event(event)
    
    def apply_event(self, event: DomainEvent):
        if event.event_type == "UserEmailChanged":
            self.email = event.data["new_email"]
        elif event.event_type == "UserDeactivated":
            self.status = "inactive"

# 订单领域
class Order(AggregateRoot):
    def __init__(self, order_id: str, user_id: str, items: List[Dict]):
        super().__init__(order_id)
        self.user_id = user_id
        self.items = items
        self.status = "created"
        self.total_amount = sum(item["price"] * item["quantity"] for item in items)
    
    def confirm(self):
        if self.status == "created":
            self.status = "confirmed"
            event = DomainEvent("OrderConfirmed", {
                "order_id": self.id,
                "user_id": self.user_id,
                "total_amount": self.total_amount
            })
            self.add_event(event)
    
    def cancel(self):
        if self.status in ["created", "confirmed"]:
            self.status = "cancelled"
            event = DomainEvent("OrderCancelled", {
                "order_id": self.id,
                "user_id": self.user_id
            })
            self.add_event(event)
    
    def apply_event(self, event: DomainEvent):
        if event.event_type == "OrderConfirmed":
            self.status = "confirmed"
        elif event.event_type == "OrderCancelled":
            self.status = "cancelled"

class DomainService:
    def __init__(self):
        self.aggregates: Dict[str, AggregateRoot] = {}
    
    def save_aggregate(self, aggregate: AggregateRoot):
        self.aggregates[aggregate.id] = aggregate
    
    def get_aggregate(self, aggregate_id: str) -> AggregateRoot:
        return self.aggregates.get(aggregate_id)
    
    def publish_events(self, aggregate: AggregateRoot):
        events = aggregate.get_events()
        for event in events:
            # 发布到事件总线
            self._publish_to_event_bus(event)
        aggregate.clear_events()
    
    def _publish_to_event_bus(self, event: DomainEvent):
        # 实现事件发布逻辑
        print(f"发布事件: {event.event_type} - {event.data}")
```

#### 2. 服务边界识别

```python
class ServiceBoundaryAnalyzer:
    def __init__(self):
        self.business_capabilities = []
        self.data_entities = []
        self.service_candidates = []
    
    def identify_business_capabilities(self, business_domain: str) -> List[str]:
        """识别业务能力"""
        capabilities_map = {
            "电商": [
                "用户管理", "商品管理", "订单管理", "支付处理",
                "库存管理", "物流配送", "评价管理", "营销活动"
            ],
            "银行": [
                "账户管理", "交易处理", "风险控制", "客户服务",
                "产品管理", "合规监管", "报表统计", "通知服务"
            ],
            "医疗": [
                "患者管理", "医生管理", "预约挂号", "病历管理",
                "药品管理", "检查检验", "收费结算", "统计分析"
            ]
        }
        
        return capabilities_map.get(business_domain, [])
    
    def identify_data_entities(self, business_domain: str) -> List[str]:
        """识别数据实体"""
        entities_map = {
            "电商": [
                "用户", "商品", "订单", "支付", "库存", "物流", "评价", "优惠券"
            ],
            "银行": [
                "客户", "账户", "交易", "产品", "风险", "合规", "报表", "通知"
            ],
            "医疗": [
                "患者", "医生", "预约", "病历", "药品", "检查", "收费", "统计"
            ]
        }
        
        return entities_map.get(business_domain, [])
    
    def suggest_service_boundaries(self, business_domain: str) -> List[Dict]:
        """建议服务边界"""
        capabilities = self.identify_business_capabilities(business_domain)
        entities = self.identify_data_entities(business_domain)
        
        service_boundaries = []
        
        for capability in capabilities:
            service = {
                "service_name": f"{capability}Service",
                "business_capability": capability,
                "responsibilities": [capability],
                "data_entities": self._map_entities_to_capability(capability, entities),
                "api_endpoints": self._suggest_api_endpoints(capability),
                "dependencies": self._identify_dependencies(capability, capabilities)
            }
            service_boundaries.append(service)
        
        return service_boundaries
    
    def _map_entities_to_capability(self, capability: str, entities: List[str]) -> List[str]:
        """映射实体到业务能力"""
        mapping = {
            "用户管理": ["用户"],
            "商品管理": ["商品"],
            "订单管理": ["订单"],
            "支付处理": ["支付"],
            "库存管理": ["库存"],
            "物流配送": ["物流"],
            "评价管理": ["评价"],
            "营销活动": ["优惠券"]
        }
        
        return mapping.get(capability, [])
    
    def _suggest_api_endpoints(self, capability: str) -> List[str]:
        """建议API端点"""
        endpoints_map = {
            "用户管理": ["/users", "/users/{id}", "/users/{id}/profile"],
            "商品管理": ["/products", "/products/{id}", "/products/search"],
            "订单管理": ["/orders", "/orders/{id}", "/orders/{id}/status"],
            "支付处理": ["/payments", "/payments/{id}", "/payments/process"]
        }
        
        return endpoints_map.get(capability, [])
    
    def _identify_dependencies(self, capability: str, all_capabilities: List[str]) -> List[str]:
        """识别依赖关系"""
        dependencies_map = {
            "订单管理": ["用户管理", "商品管理", "库存管理"],
            "支付处理": ["订单管理"],
            "物流配送": ["订单管理"],
            "评价管理": ["订单管理", "用户管理"]
        }
        
        return dependencies_map.get(capability, [])

def service_boundary_analysis_example():
    """服务边界分析示例"""
    analyzer = ServiceBoundaryAnalyzer()
    
    # 分析电商领域
    boundaries = analyzer.suggest_service_boundaries("电商")
    
    print("电商微服务边界建议:")
    for service in boundaries:
        print(f"\n服务: {service['service_name']}")
        print(f"业务能力: {service['business_capability']}")
        print(f"数据实体: {service['data_entities']}")
        print(f"API端点: {service['api_endpoints']}")
        print(f"依赖服务: {service['dependencies']}")
    
    return boundaries
```

### 服务注册与发现

#### 1. 服务注册中心

```python
import json
import time
from typing import Dict, List, Optional
import threading

class ServiceRegistry:
    def __init__(self):
        self.services: Dict[str, List[Dict]] = {}
        self.health_check_thread = None
        self.running = False
    
    def register_service(self, service_name: str, service_instance: Dict):
        """注册服务"""
        if service_name not in self.services:
            self.services[service_name] = []
        
        # 添加注册时间
        service_instance['registered_at'] = time.time()
        service_instance['last_heartbeat'] = time.time()
        
        self.services[service_name].append(service_instance)
        print(f"服务注册: {service_name} - {service_instance['host']}:{service_instance['port']}")
    
    def deregister_service(self, service_name: str, service_id: str):
        """注销服务"""
        if service_name in self.services:
            self.services[service_name] = [
                service for service in self.services[service_name]
                if service.get('id') != service_id
            ]
            print(f"服务注销: {service_name} - {service_id}")
    
    def get_service_instances(self, service_name: str) -> List[Dict]:
        """获取服务实例"""
        return self.services.get(service_name, [])
    
    def update_heartbeat(self, service_name: str, service_id: str):
        """更新心跳"""
        if service_name in self.services:
            for service in self.services[service_name]:
                if service.get('id') == service_id:
                    service['last_heartbeat'] = time.time()
                    break
    
    def start_health_check(self, check_interval: int = 30):
        """启动健康检查"""
        self.running = True
        self.health_check_thread = threading.Thread(
            target=self._health_check_loop, args=(check_interval,)
        )
        self.health_check_thread.start()
    
    def stop_health_check(self):
        """停止健康检查"""
        self.running = False
        if self.health_check_thread:
            self.health_check_thread.join()
    
    def _health_check_loop(self, check_interval: int):
        """健康检查循环"""
        while self.running:
            current_time = time.time()
            
            for service_name, instances in self.services.items():
                for instance in instances[:]:  # 创建副本避免修改迭代对象
                    last_heartbeat = instance.get('last_heartbeat', 0)
                    
                    # 如果超过60秒没有心跳，认为服务不可用
                    if current_time - last_heartbeat > 60:
                        print(f"服务不可用: {service_name} - {instance.get('id')}")
                        instances.remove(instance)
            
            time.sleep(check_interval)
    
    def get_registry_status(self) -> Dict:
        """获取注册中心状态"""
        status = {
            'total_services': len(self.services),
            'service_details': {}
        }
        
        for service_name, instances in self.services.items():
            status['service_details'][service_name] = {
                'instance_count': len(instances),
                'instances': instances
            }
        
        return status

class ServiceDiscovery:
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.load_balancer = RoundRobinLoadBalancer()
    
    def discover_service(self, service_name: str) -> Optional[Dict]:
        """服务发现"""
        instances = self.registry.get_service_instances(service_name)
        
        if not instances:
            return None
        
        # 使用负载均衡器选择实例
        return self.load_balancer.select_instance(instances)
    
    def get_all_instances(self, service_name: str) -> List[Dict]:
        """获取所有服务实例"""
        return self.registry.get_service_instances(service_name)

class RoundRobinLoadBalancer:
    def __init__(self):
        self.current_index = 0
    
    def select_instance(self, instances: List[Dict]) -> Dict:
        """轮询选择实例"""
        if not instances:
            return None
        
        instance = instances[self.current_index]
        self.current_index = (self.current_index + 1) % len(instances)
        
        return instance

class ServiceClient:
    def __init__(self, discovery: ServiceDiscovery):
        self.discovery = discovery
        self.service_cache = {}
    
    def call_service(self, service_name: str, endpoint: str, method: str = "GET", data: Dict = None):
        """调用服务"""
        # 服务发现
        instance = self.discovery.discover_service(service_name)
        
        if not instance:
            raise Exception(f"服务 {service_name} 不可用")
        
        # 构建请求URL
        url = f"http://{instance['host']}:{instance['port']}{endpoint}"
        
        # 发送HTTP请求（简化实现）
        print(f"调用服务: {method} {url}")
        if data:
            print(f"请求数据: {data}")
        
        # 模拟响应
        return {
            "status": "success",
            "data": f"来自 {service_name} 的响应",
            "instance": instance
        }
```

#### 2. 服务配置管理

```python
class ConfigurationManager:
    def __init__(self):
        self.configs: Dict[str, Dict] = {}
        self.watchers: Dict[str, List] = {}
    
    def set_config(self, service_name: str, config: Dict):
        """设置服务配置"""
        self.configs[service_name] = config
        self._notify_watchers(service_name, config)
    
    def get_config(self, service_name: str) -> Dict:
        """获取服务配置"""
        return self.configs.get(service_name, {})
    
    def watch_config(self, service_name: str, callback):
        """监听配置变化"""
        if service_name not in self.watchers:
            self.watchers[service_name] = []
        self.watchers[service_name].append(callback)
    
    def _notify_watchers(self, service_name: str, config: Dict):
        """通知配置变化"""
        if service_name in self.watchers:
            for callback in self.watchers[service_name]:
                try:
                    callback(config)
                except Exception as e:
                    print(f"配置变化通知失败: {e}")

class ServiceConfig:
    def __init__(self, service_name: str, config_manager: ConfigurationManager):
        self.service_name = service_name
        self.config_manager = config_manager
        self.config = {}
        self._load_config()
    
    def _load_config(self):
        """加载配置"""
        self.config = self.config_manager.get_config(self.service_name)
    
    def get(self, key: str, default=None):
        """获取配置值"""
        return self.config.get(key, default)
    
    def set(self, key: str, value):
        """设置配置值"""
        self.config[key] = value
        self.config_manager.set_config(self.service_name, self.config)
    
    def watch(self, callback):
        """监听配置变化"""
        self.config_manager.watch_config(self.service_name, callback)
```

### API网关

#### 1. 网关实现

```python
from flask import Flask, request, jsonify
import requests
import time
import jwt

class APIGateway:
    def __init__(self, service_discovery: ServiceDiscovery):
        self.app = Flask(__name__)
        self.service_discovery = service_discovery
        self.routes = {}
        self.middleware = []
        self.setup_routes()
        self.setup_middleware()
    
    def setup_routes(self):
        """设置路由"""
        # 用户服务路由
        self.add_route("/api/users", "user-service", "/users")
        self.add_route("/api/users/<user_id>", "user-service", "/users/{user_id}")
        
        # 订单服务路由
        self.add_route("/api/orders", "order-service", "/orders")
        self.add_route("/api/orders/<order_id>", "order-service", "/orders/{order_id}")
        
        # 商品服务路由
        self.add_route("/api/products", "product-service", "/products")
        self.add_route("/api/products/<product_id>", "product-service", "/products/{product_id}")
    
    def add_route(self, gateway_path: str, service_name: str, service_path: str):
        """添加路由"""
        self.routes[gateway_path] = {
            "service_name": service_name,
            "service_path": service_path
        }
    
    def setup_middleware(self):
        """设置中间件"""
        self.middleware = [
            self.auth_middleware,
            self.logging_middleware,
            self.rate_limiting_middleware
        ]
    
    def auth_middleware(self, request_data):
        """认证中间件"""
        token = request_data.get('headers', {}).get('Authorization')
        if not token:
            return {"error": "未提供认证令牌"}, 401
        
        try:
            # 验证JWT令牌
            payload = jwt.decode(token, "secret", algorithms=["HS256"])
            request_data['user'] = payload
            return None
        except jwt.InvalidTokenError:
            return {"error": "无效的认证令牌"}, 401
    
    def logging_middleware(self, request_data):
        """日志中间件"""
        print(f"[{time.time()}] {request_data['method']} {request_data['path']}")
        return None
    
    def rate_limiting_middleware(self, request_data):
        """限流中间件"""
        # 简单的限流实现
        client_ip = request_data.get('client_ip', 'unknown')
        # 这里可以实现更复杂的限流逻辑
        return None
    
    def route_request(self, path: str, method: str = "GET", data: Dict = None, headers: Dict = None):
        """路由请求"""
        # 查找匹配的路由
        route_info = None
        for route_path, info in self.routes.items():
            if self._match_route(route_path, path):
                route_info = info
                break
        
        if not route_info:
            return {"error": "路由不存在"}, 404
        
        # 准备请求数据
        request_data = {
            "method": method,
            "path": path,
            "data": data,
            "headers": headers or {},
            "client_ip": "127.0.0.1"  # 简化实现
        }
        
        # 执行中间件
        for middleware in self.middleware:
            result = middleware(request_data)
            if result:
                return result
        
        # 转发请求到目标服务
        return self._forward_request(route_info, request_data)
    
    def _match_route(self, route_path: str, request_path: str) -> bool:
        """匹配路由"""
        # 简单的路由匹配实现
        return route_path == request_path or route_path.replace("<user_id>", ".*") == request_path
    
    def _forward_request(self, route_info: Dict, request_data: Dict):
        """转发请求"""
        service_name = route_info["service_name"]
        service_path = route_info["service_path"]
        
        # 服务发现
        instance = self.service_discovery.discover_service(service_name)
        if not instance:
            return {"error": f"服务 {service_name} 不可用"}, 503
        
        # 构建目标URL
        target_url = f"http://{instance['host']}:{instance['port']}{service_path}"
        
        # 发送请求（简化实现）
        print(f"转发请求到: {target_url}")
        
        # 模拟响应
        return {
            "status": "success",
            "data": f"来自 {service_name} 的响应",
            "service": service_name,
            "instance": instance
        }

def api_gateway_example():
    """API网关示例"""
    # 创建服务注册中心
    registry = ServiceRegistry()
    
    # 注册服务实例
    registry.register_service("user-service", {
        "id": "user-1",
        "host": "localhost",
        "port": 8081,
        "health": "healthy"
    })
    
    registry.register_service("order-service", {
        "id": "order-1",
        "host": "localhost",
        "port": 8082,
        "health": "healthy"
    })
    
    # 创建服务发现
    discovery = ServiceDiscovery(registry)
    
    # 创建API网关
    gateway = APIGateway(discovery)
    
    # 测试路由
    response = gateway.route_request("/api/users", "GET")
    print(f"网关响应: {response}")
    
    return gateway
```

### 容器化与部署

#### 1. Docker容器管理

```python
import subprocess
import json
import os

class DockerManager:
    def __init__(self):
        self.containers = {}
    
    def build_image(self, service_name: str, dockerfile_path: str, tag: str = "latest"):
        """构建Docker镜像"""
        try:
            cmd = f"docker build -t {service_name}:{tag} {dockerfile_path}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                print(f"镜像构建成功: {service_name}:{tag}")
                return True
            else:
                print(f"镜像构建失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"构建镜像异常: {e}")
            return False
    
    def run_container(self, service_name: str, image: str, port: int, env_vars: Dict = None):
        """运行容器"""
        try:
            env_str = ""
            if env_vars:
                env_str = " ".join([f"-e {k}={v}" for k, v in env_vars.items()])
            
            cmd = f"docker run -d --name {service_name} -p {port}:{port} {env_str} {image}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                container_id = result.stdout.strip()
                self.containers[service_name] = {
                    "id": container_id,
                    "image": image,
                    "port": port,
                    "status": "running"
                }
                print(f"容器启动成功: {service_name} ({container_id})")
                return True
            else:
                print(f"容器启动失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"启动容器异常: {e}")
            return False
    
    def stop_container(self, service_name: str):
        """停止容器"""
        try:
            cmd = f"docker stop {service_name}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                if service_name in self.containers:
                    self.containers[service_name]["status"] = "stopped"
                print(f"容器停止成功: {service_name}")
                return True
            else:
                print(f"容器停止失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"停止容器异常: {e}")
            return False
    
    def remove_container(self, service_name: str):
        """删除容器"""
        try:
            cmd = f"docker rm {service_name}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                if service_name in self.containers:
                    del self.containers[service_name]
                print(f"容器删除成功: {service_name}")
                return True
            else:
                print(f"容器删除失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"删除容器异常: {e}")
            return False
    
    def get_container_status(self, service_name: str):
        """获取容器状态"""
        try:
            cmd = f"docker ps -a --filter name={service_name} --format '{{{{.Names}}}} {{{{.Status}}}}'"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                return result.stdout.strip()
            else:
                return "unknown"
        except Exception as e:
            print(f"获取容器状态异常: {e}")
            return "unknown"
    
    def list_containers(self):
        """列出所有容器"""
        return self.containers

class DockerComposeManager:
    def __init__(self, compose_file: str):
        self.compose_file = compose_file
    
    def up(self, services: List[str] = None):
        """启动服务"""
        try:
            cmd = f"docker-compose -f {self.compose_file} up -d"
            if services:
                cmd += f" {' '.join(services)}"
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("Docker Compose 启动成功")
                return True
            else:
                print(f"Docker Compose 启动失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"Docker Compose 启动异常: {e}")
            return False
    
    def down(self):
        """停止服务"""
        try:
            cmd = f"docker-compose -f {self.compose_file} down"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("Docker Compose 停止成功")
                return True
            else:
                print(f"Docker Compose 停止失败: {result.stderr}")
                return False
        except Exception as e:
            print(f"Docker Compose 停止异常: {e}")
            return False
    
    def logs(self, service: str):
        """查看服务日志"""
        try:
            cmd = f"docker-compose -f {self.compose_file} logs {service}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                return result.stdout
            else:
                return result.stderr
        except Exception as e:
            print(f"查看日志异常: {e}")
            return ""

def create_docker_compose_file():
    """创建Docker Compose文件"""
    compose_config = {
        "version": "3.8",
        "services": {
            "user-service": {
                "build": "./user-service",
                "ports": ["8081:8081"],
                "environment": {
                    "DB_HOST": "postgres",
                    "DB_PORT": "5432",
                    "DB_NAME": "users",
                    "DB_USER": "postgres",
                    "DB_PASSWORD": "password"
                },
                "depends_on": ["postgres"]
            },
            "order-service": {
                "build": "./order-service",
                "ports": ["8082:8082"],
                "environment": {
                    "DB_HOST": "postgres",
                    "DB_PORT": "5432",
                    "DB_NAME": "orders",
                    "DB_USER": "postgres",
                    "DB_PASSWORD": "password"
                },
                "depends_on": ["postgres"]
            },
            "product-service": {
                "build": "./product-service",
                "ports": ["8083:8083"],
                "environment": {
                    "DB_HOST": "postgres",
                    "DB_PORT": "5432",
                    "DB_NAME": "products",
                    "DB_USER": "postgres",
                    "DB_PASSWORD": "password"
                },
                "depends_on": ["postgres"]
            },
            "api-gateway": {
                "build": "./api-gateway",
                "ports": ["8080:8080"],
                "depends_on": ["user-service", "order-service", "product-service"]
            },
            "postgres": {
                "image": "postgres:13",
                "environment": {
                    "POSTGRES_DB": "microservices",
                    "POSTGRES_USER": "postgres",
                    "POSTGRES_PASSWORD": "password"
                },
                "ports": ["5432:5432"],
                "volumes": ["./data:/var/lib/postgresql/data"]
            }
        }
    }
    
    with open("docker-compose.yml", "w") as f:
        import yaml
        yaml.dump(compose_config, f, default_flow_style=False)
    
    print("Docker Compose 文件创建成功")

def containerization_example():
    """容器化示例"""
    # 创建Docker Compose文件
    create_docker_compose_file()
    
    # 创建Docker管理器
    docker_manager = DockerManager()
    
    # 创建Compose管理器
    compose_manager = DockerComposeManager("docker-compose.yml")
    
    # 启动服务
    success = compose_manager.up()
    
    if success:
        print("微服务启动成功")
        
        # 查看服务状态
        for service in ["user-service", "order-service", "product-service"]:
            logs = compose_manager.logs(service)
            print(f"\n{service} 日志:")
            print(logs[:200] + "..." if len(logs) > 200 else logs)
    
    return docker_manager, compose_manager
```

### 服务监控与链路追踪

#### 1. 服务监控

```python
import psutil
import time
from datetime import datetime

class ServiceMonitor:
    def __init__(self):
        self.metrics = {}
    
    def collect_system_metrics(self):
        """收集系统指标"""
        metrics = {
            "timestamp": datetime.now().isoformat(),
            "cpu_percent": psutil.cpu_percent(interval=1),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent,
            "network_io": psutil.net_io_counters()._asdict()
        }
        
        return metrics
    
    def collect_service_metrics(self, service_name: str, port: int):
        """收集服务指标"""
        try:
            # 检查端口是否监听
            connections = []
            for conn in psutil.net_connections():
                if conn.laddr.port == port:
                    connections.append(conn)
            
            metrics = {
                "service_name": service_name,
                "port": port,
                "timestamp": datetime.now().isoformat(),
                "is_listening": len(connections) > 0,
                "connection_count": len(connections),
                "status": "healthy" if len(connections) > 0 else "unhealthy"
            }
            
            return metrics
        except Exception as e:
            return {
                "service_name": service_name,
                "port": port,
                "timestamp": datetime.now().isoformat(),
                "error": str(e),
                "status": "error"
            }
    
    def monitor_services(self, services: List[Dict]):
        """监控多个服务"""
        all_metrics = {
            "system": self.collect_system_metrics(),
            "services": []
        }
        
        for service in services:
            service_metrics = self.collect_service_metrics(
                service["name"], service["port"]
            )
            all_metrics["services"].append(service_metrics)
        
        return all_metrics

class MetricsCollector:
    def __init__(self):
        self.metrics_history = []
    
    def collect_metrics(self, monitor: ServiceMonitor, services: List[Dict]):
        """收集指标"""
        metrics = monitor.monitor_services(services)
        self.metrics_history.append(metrics)
        
        # 保持最近1000条记录
        if len(self.metrics_history) > 1000:
            self.metrics_history = self.metrics_history[-1000:]
        
        return metrics
    
    def get_service_health(self, service_name: str) -> Dict:
        """获取服务健康状态"""
        if not self.metrics_history:
            return {"status": "unknown"}
        
        # 获取最近的服务指标
        for metrics in reversed(self.metrics_history):
            for service in metrics["services"]:
                if service["service_name"] == service_name:
                    return service
        
        return {"status": "unknown"}
    
    def get_system_trends(self, hours: int = 24) -> Dict:
        """获取系统趋势"""
        if not self.metrics_history:
            return {}
        
        # 计算最近N小时的趋势
        recent_metrics = self.metrics_history[-hours:] if len(self.metrics_history) >= hours else self.metrics_history
        
        cpu_trend = [m["system"]["cpu_percent"] for m in recent_metrics]
        memory_trend = [m["system"]["memory_percent"] for m in recent_metrics]
        
        return {
            "cpu_avg": sum(cpu_trend) / len(cpu_trend),
            "memory_avg": sum(memory_trend) / len(memory_trend),
            "cpu_max": max(cpu_trend),
            "memory_max": max(memory_trend)
        }

def monitoring_example():
    """监控示例"""
    # 创建监控器
    monitor = ServiceMonitor()
    collector = MetricsCollector()
    
    # 定义要监控的服务
    services = [
        {"name": "user-service", "port": 8081},
        {"name": "order-service", "port": 8082},
        {"name": "product-service", "port": 8083},
        {"name": "api-gateway", "port": 8080}
    ]
    
    # 收集指标
    metrics = collector.collect_metrics(monitor, services)
    
    print("系统监控指标:")
    print(f"CPU使用率: {metrics['system']['cpu_percent']}%")
    print(f"内存使用率: {metrics['system']['memory_percent']}%")
    print(f"磁盘使用率: {metrics['system']['disk_percent']}%")
    
    print("\n服务健康状态:")
    for service in metrics["services"]:
        print(f"{service['service_name']}: {service['status']}")
    
    return monitor, collector
```

### 实战案例：完整微服务系统

```python
class MicroservicesSystem:
    def __init__(self):
        # 初始化各个组件
        self.registry = ServiceRegistry()
        self.discovery = ServiceDiscovery(self.registry)
        self.gateway = APIGateway(self.discovery)
        self.config_manager = ConfigurationManager()
        self.docker_manager = DockerManager()
        self.monitor = ServiceMonitor()
        self.metrics_collector = MetricsCollector()
        
        # 启动健康检查
        self.registry.start_health_check()
    
    def deploy_service(self, service_name: str, service_config: Dict):
        """部署服务"""
        print(f"部署服务: {service_name}")
        
        # 1. 构建镜像
        if not self.docker_manager.build_image(
            service_name, 
            service_config["dockerfile_path"],
            service_config.get("tag", "latest")
        ):
            return False
        
        # 2. 运行容器
        if not self.docker_manager.run_container(
            service_name,
            f"{service_name}:{service_config.get('tag', 'latest')}",
            service_config["port"],
            service_config.get("environment", {})
        ):
            return False
        
        # 3. 注册服务
        self.registry.register_service(service_name, {
            "id": f"{service_name}-1",
            "host": "localhost",
            "port": service_config["port"],
            "health": "healthy"
        })
        
        # 4. 设置配置
        self.config_manager.set_config(service_name, service_config.get("config", {}))
        
        print(f"服务 {service_name} 部署成功")
        return True
    
    def deploy_all_services(self):
        """部署所有服务"""
        services_config = {
            "user-service": {
                "dockerfile_path": "./user-service",
                "port": 8081,
                "environment": {
                    "DB_HOST": "localhost",
                    "DB_PORT": "5432"
                },
                "config": {
                    "database": "users",
                    "cache_ttl": 300
                }
            },
            "order-service": {
                "dockerfile_path": "./order-service",
                "port": 8082,
                "environment": {
                    "DB_HOST": "localhost",
                    "DB_PORT": "5432"
                },
                "config": {
                    "database": "orders",
                    "payment_timeout": 30
                }
            },
            "product-service": {
                "dockerfile_path": "./product-service",
                "port": 8083,
                "environment": {
                    "DB_HOST": "localhost",
                    "DB_PORT": "5432"
                },
                "config": {
                    "database": "products",
                    "inventory_threshold": 10
                }
            }
        }
        
        for service_name, config in services_config.items():
            if not self.deploy_service(service_name, config):
                print(f"服务 {service_name} 部署失败")
                return False
        
        return True
    
    def monitor_system(self):
        """监控系统"""
        services = [
            {"name": "user-service", "port": 8081},
            {"name": "order-service", "port": 8082},
            {"name": "product-service", "port": 8083}
        ]
        
        metrics = self.metrics_collector.collect_metrics(self.monitor, services)
        
        # 检查服务健康状态
        unhealthy_services = []
        for service in metrics["services"]:
            if service["status"] != "healthy":
                unhealthy_services.append(service["service_name"])
        
        if unhealthy_services:
            print(f"不健康的服务: {unhealthy_services}")
        
        return metrics
    
    def get_system_status(self):
        """获取系统状态"""
        status = {
            "registry": self.registry.get_registry_status(),
            "containers": self.docker_manager.list_containers(),
            "metrics": self.monitor_system()
        }
        
        return status
    
    def shutdown(self):
        """关闭系统"""
        print("关闭微服务系统...")
        
        # 停止健康检查
        self.registry.stop_health_check()
        
        # 停止所有容器
        for service_name in self.docker_manager.containers:
            self.docker_manager.stop_container(service_name)
            self.docker_manager.remove_container(service_name)
        
        print("系统已关闭")

def microservices_system_example():
    """微服务系统示例"""
    # 创建微服务系统
    system = MicroservicesSystem()
    
    try:
        # 部署所有服务
        if system.deploy_all_services():
            print("所有服务部署成功")
            
            # 监控系统
            status = system.get_system_status()
            print(f"系统状态: {status}")
            
            # 模拟服务调用
            client = ServiceClient(system.discovery)
            
            # 调用用户服务
            response = client.call_service("user-service", "/users", "GET")
            print(f"用户服务响应: {response}")
            
            # 调用订单服务
            response = client.call_service("order-service", "/orders", "GET")
            print(f"订单服务响应: {response}")
            
            # 调用商品服务
            response = client.call_service("product-service", "/products", "GET")
            print(f"商品服务响应: {response}")
            
            # 通过网关调用
            gateway_response = system.gateway.route_request("/api/users", "GET")
            print(f"网关响应: {gateway_response}")
        
    finally:
        # 关闭系统
        system.shutdown()
    
    return system

# 运行示例
if __name__ == "__main__":
    print("=== 微服务架构实战示例 ===")
    
    # 服务边界分析
    print("\n1. 服务边界分析")
    boundaries = service_boundary_analysis_example()
    
    # API网关
    print("\n2. API网关")
    gateway = api_gateway_example()
    
    # 容器化
    print("\n3. 容器化")
    docker_manager, compose_manager = containerization_example()
    
    # 监控
    print("\n4. 服务监控")
    monitor, collector = monitoring_example()
    
    # 完整系统
    print("\n5. 完整微服务系统")
    system = microservices_system_example()
    
    print("\n微服务架构实战完成！")
```

### 理论总结

微服务架构是现代软件系统的重要架构模式，通过服务拆分、独立部署、服务治理等技术手段，能够提高系统的可扩展性、可维护性和容错能力，为大型复杂系统的构建提供有效的解决方案。
