# 分布式系统架构

## 6.4 分布式系统架构

### 概念与原理

分布式系统是由多个独立计算机节点组成的系统，这些节点通过网络通信协作完成共同的任务。

#### 核心特征

1. **节点独立性**：每个节点可独立运行
2. **网络通信**：节点间通过网络通信
3. **故障容错**：部分节点故障不影响整体
4. **可扩展性**：可动态添加节点
5. **一致性**：保证数据一致性

### 分布式计算模型

#### 1. MapReduce实现

```python
import multiprocessing as mp
from typing import List, Callable, Any
import time

class MapReduce:
    def __init__(self, num_workers: int = None):
        self.num_workers = num_workers or mp.cpu_count()
        self.pool = mp.Pool(processes=self.num_workers)
    
    def map_reduce(self, data: List[Any], map_func: Callable, reduce_func: Callable) -> Any:
        """执行MapReduce"""
        # Map阶段
        print("开始Map阶段...")
        map_results = self.pool.map(map_func, data)
        
        # 收集Map结果
        intermediate_results = []
        for result in map_results:
            intermediate_results.extend(result)
        
        # Reduce阶段
        print("开始Reduce阶段...")
        final_result = reduce_func(intermediate_results)
        
        return final_result
    
    def close(self):
        """关闭进程池"""
        self.pool.close()
        self.pool.join()

def word_count_map(text: str) -> List[tuple]:
    """单词计数Map函数"""
    words = text.lower().split()
    word_counts = {}
    
    for word in words:
        # 清理单词
        word = word.strip('.,!?;:')
        if word:
            word_counts[word] = word_counts.get(word, 0) + 1
    
    return list(word_counts.items())

def word_count_reduce(results: List[tuple]) -> dict:
    """单词计数Reduce函数"""
    word_counts = {}
    
    for word, count in results:
        word_counts[word] = word_counts.get(word, 0) + count
    
    return word_counts

def mapreduce_example():
    """MapReduce示例"""
    # 准备数据
    texts = [
        "Hello world hello python",
        "Python is a programming language",
        "Hello python world",
        "Programming with python is fun"
    ]
    
    # 创建MapReduce实例
    mr = MapReduce(num_workers=2)
    
    try:
        # 执行MapReduce
        result = mr.map_reduce(texts, word_count_map, word_count_reduce)
        
        print("单词计数结果:")
        for word, count in sorted(result.items()):
            print(f"{word}: {count}")
        
        return result
    
    finally:
        mr.close()

class DistributedTaskExecutor:
    def __init__(self, nodes: List[str]):
        self.nodes = nodes
        self.task_queue = []
        self.results = {}
    
    def submit_task(self, task_id: str, task_func: Callable, *args, **kwargs):
        """提交任务"""
        task = {
            'id': task_id,
            'func': task_func,
            'args': args,
            'kwargs': kwargs,
            'status': 'pending'
        }
        self.task_queue.append(task)
    
    def execute_tasks(self):
        """执行任务"""
        # 模拟分布式执行
        for i, task in enumerate(self.task_queue):
            node = self.nodes[i % len(self.nodes)]
            print(f"在节点 {node} 上执行任务 {task['id']}")
            
            try:
                # 执行任务
                result = task['func'](*task['args'], **task['kwargs'])
                task['status'] = 'completed'
                self.results[task['id']] = result
                
                print(f"任务 {task['id']} 完成，结果: {result}")
                
            except Exception as e:
                task['status'] = 'failed'
                self.results[task['id']] = f"错误: {str(e)}"
                print(f"任务 {task['id']} 失败: {e}")
    
    def get_results(self) -> dict:
        """获取结果"""
        return self.results

def distributed_task_example():
    """分布式任务示例"""
    # 定义任务函数
    def fibonacci(n):
        if n <= 1:
            return n
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    
    def prime_check(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    
    # 创建分布式执行器
    nodes = ['node1', 'node2', 'node3']
    executor = DistributedTaskExecutor(nodes)
    
    # 提交任务
    executor.submit_task('fib_20', fibonacci, 20)
    executor.submit_task('fib_30', fibonacci, 30)
    executor.submit_task('prime_100', prime_check, 100)
    executor.submit_task('prime_101', prime_check, 101)
    
    # 执行任务
    executor.execute_tasks()
    
    # 获取结果
    results = executor.get_results()
    print("任务执行结果:", results)
    
    return executor
```

### 一致性协议

#### 1. 两阶段提交（2PC）

```python
import threading
import time
from enum import Enum
from typing import List, Dict

class TransactionState(Enum):
    INITIAL = "initial"
    PREPARED = "prepared"
    COMMITTED = "committed"
    ABORTED = "aborted"

class Participant:
    def __init__(self, participant_id: str):
        self.participant_id = participant_id
        self.state = TransactionState.INITIAL
        self.lock = threading.Lock()
    
    def can_prepare(self) -> bool:
        """检查是否可以准备"""
        # 模拟检查资源是否可用
        return True
    
    def prepare(self) -> bool:
        """准备阶段"""
        with self.lock:
            if self.can_prepare():
                self.state = TransactionState.PREPARED
                print(f"参与者 {self.participant_id} 准备就绪")
                return True
            else:
                self.state = TransactionState.ABORTED
                print(f"参与者 {self.participant_id} 准备失败")
                return False
    
    def commit(self) -> bool:
        """提交阶段"""
        with self.lock:
            if self.state == TransactionState.PREPARED:
                self.state = TransactionState.COMMITTED
                print(f"参与者 {self.participant_id} 提交成功")
                return True
            else:
                print(f"参与者 {self.participant_id} 提交失败")
                return False
    
    def abort(self) -> bool:
        """回滚阶段"""
        with self.lock:
            self.state = TransactionState.ABORTED
            print(f"参与者 {self.participant_id} 回滚")
            return True

class TwoPhaseCommit:
    def __init__(self, participants: List[Participant]):
        self.participants = participants
        self.coordinator_id = "coordinator"
    
    def execute_transaction(self) -> bool:
        """执行两阶段提交"""
        print("开始两阶段提交...")
        
        # 第一阶段：准备阶段
        if not self.prepare_phase():
            print("准备阶段失败，开始回滚")
            self.abort_phase()
            return False
        
        # 第二阶段：提交阶段
        if not self.commit_phase():
            print("提交阶段失败")
            return False
        
        print("事务提交成功")
        return True
    
    def prepare_phase(self) -> bool:
        """准备阶段"""
        print("=== 准备阶段 ===")
        
        for participant in self.participants:
            if not participant.prepare():
                return False
        
        return True
    
    def commit_phase(self) -> bool:
        """提交阶段"""
        print("=== 提交阶段 ===")
        
        for participant in self.participants:
            if not participant.commit():
                return False
        
        return True
    
    def abort_phase(self) -> bool:
        """回滚阶段"""
        print("=== 回滚阶段 ===")
        
        for participant in self.participants:
            participant.abort()
        
        return True

def two_phase_commit_example():
    """两阶段提交示例"""
    # 创建参与者
    participants = [
        Participant("database_1"),
        Participant("database_2"),
        Participant("cache_1")
    ]
    
    # 创建协调者
    coordinator = TwoPhaseCommit(participants)
    
    # 执行事务
    success = coordinator.execute_transaction()
    
    print(f"事务执行结果: {'成功' if success else '失败'}")
    
    return coordinator
```

#### 2. Raft共识算法

```python
import random
import time
from enum import Enum
from typing import List, Dict, Optional

class NodeState(Enum):
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    LEADER = "leader"

class LogEntry:
    def __init__(self, term: int, command: str, index: int):
        self.term = term
        self.command = command
        self.index = index

class RaftNode:
    def __init__(self, node_id: str, nodes: List[str]):
        self.node_id = node_id
        self.nodes = nodes
        self.state = NodeState.FOLLOWER
        self.current_term = 0
        self.voted_for = None
        self.log = []
        self.commit_index = 0
        self.last_applied = 0
        
        # 领导者选举相关
        self.election_timeout = random.randint(150, 300)  # 毫秒
        self.last_heartbeat = time.time()
        
        # 领导者状态
        self.next_index = {}
        self.match_index = {}
        
        # 初始化领导者状态
        for node in nodes:
            if node != node_id:
                self.next_index[node] = 1
                self.match_index[node] = 0
    
    def start_election(self):
        """开始选举"""
        self.current_term += 1
        self.state = NodeState.CANDIDATE
        self.voted_for = self.node_id
        self.last_heartbeat = time.time()
        
        print(f"节点 {self.node_id} 开始选举，任期: {self.current_term}")
        
        # 请求投票
        votes_received = 1  # 自己的一票
        
        for node in self.nodes:
            if node != self.node_id:
                if self.request_vote(node):
                    votes_received += 1
        
        # 检查是否获得多数票
        if votes_received > len(self.nodes) // 2:
            self.become_leader()
        else:
            self.state = NodeState.FOLLOWER
    
    def request_vote(self, target_node: str) -> bool:
        """请求投票"""
        # 模拟网络请求
        # 在实际实现中，这里会发送RPC请求
        return random.choice([True, False])
    
    def become_leader(self):
        """成为领导者"""
        self.state = NodeState.LEADER
        print(f"节点 {self.node_id} 成为领导者，任期: {self.current_term}")
        
        # 初始化领导者状态
        for node in self.nodes:
            if node != self.node_id:
                self.next_index[node] = len(self.log) + 1
                self.match_index[node] = 0
        
        # 发送心跳
        self.send_heartbeat()
    
    def send_heartbeat(self):
        """发送心跳"""
        for node in self.nodes:
            if node != self.node_id:
                self.append_entries(node)
    
    def append_entries(self, target_node: str) -> bool:
        """追加条目"""
        # 模拟网络请求
        # 在实际实现中，这里会发送RPC请求
        return True
    
    def receive_heartbeat(self, leader_id: str, term: int):
        """接收心跳"""
        if term >= self.current_term:
            self.current_term = term
            self.state = NodeState.FOLLOWER
            self.voted_for = None
            self.last_heartbeat = time.time()
    
    def propose_command(self, command: str) -> bool:
        """提议命令"""
        if self.state != NodeState.LEADER:
            return False
        
        # 添加日志条目
        log_entry = LogEntry(self.current_term, command, len(self.log) + 1)
        self.log.append(log_entry)
        
        print(f"领导者 {self.node_id} 提议命令: {command}")
        
        # 复制到其他节点
        success_count = 1  # 自己
        
        for node in self.nodes:
            if node != self.node_id:
                if self.append_entries(node):
                    success_count += 1
        
        # 如果多数节点复制成功，提交日志
        if success_count > len(self.nodes) // 2:
            self.commit_log()
            return True
        
        return False
    
    def commit_log(self):
        """提交日志"""
        while self.commit_index < len(self.log):
            self.commit_index += 1
            entry = self.log[self.commit_index - 1]
            print(f"提交日志条目: {entry.command}")
    
    def check_timeout(self):
        """检查超时"""
        if self.state == NodeState.FOLLOWER:
            if time.time() - self.last_heartbeat > self.election_timeout / 1000:
                self.start_election()

class RaftCluster:
    def __init__(self, node_ids: List[str]):
        self.nodes = {}
        for node_id in node_ids:
            self.nodes[node_id] = RaftNode(node_id, node_ids)
    
    def run_election(self):
        """运行选举"""
        print("开始Raft选举...")
        
        # 所有节点开始选举
        for node in self.nodes.values():
            node.start_election()
        
        # 等待选举结果
        time.sleep(1)
        
        # 显示选举结果
        for node in self.nodes.values():
            print(f"节点 {node.node_id}: {node.state.value}, 任期: {node.current_term}")
    
    def get_leader(self) -> Optional[RaftNode]:
        """获取领导者"""
        for node in self.nodes.values():
            if node.state == NodeState.LEADER:
                return node
        return None
    
    def propose_command(self, command: str) -> bool:
        """提议命令"""
        leader = self.get_leader()
        if leader:
            return leader.propose_command(command)
        else:
            print("没有领导者")
            return False

def raft_example():
    """Raft示例"""
    # 创建集群
    node_ids = ['node1', 'node2', 'node3', 'node4', 'node5']
    cluster = RaftCluster(node_ids)
    
    # 运行选举
    cluster.run_election()
    
    # 获取领导者
    leader = cluster.get_leader()
    if leader:
        print(f"领导者: {leader.node_id}")
        
        # 提议命令
        commands = ['set x=1', 'set y=2', 'get x', 'delete y']
        for command in commands:
            success = cluster.propose_command(command)
            print(f"命令 '{command}' 提议结果: {'成功' if success else '失败'}")
    else:
        print("没有选出领导者")
    
    return cluster
```

### 负载均衡

#### 1. 负载均衡器实现

```python
import random
import time
from typing import List, Dict, Callable
from collections import defaultdict

class Server:
    def __init__(self, server_id: str, host: str, port: int):
        self.server_id = server_id
        self.host = host
        self.port = port
        self.weight = 1
        self.connections = 0
        self.response_time = 0
        self.is_healthy = True
        self.last_health_check = time.time()
    
    def handle_request(self, request: str) -> str:
        """处理请求"""
        if not self.is_healthy:
            raise Exception(f"服务器 {self.server_id} 不健康")
        
        # 模拟处理时间
        processing_time = random.uniform(0.1, 0.5)
        time.sleep(processing_time)
        
        self.connections += 1
        self.response_time = processing_time
        
        return f"服务器 {self.server_id} 处理请求: {request}"
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            # 模拟健康检查
            self.is_healthy = random.random() > 0.1  # 90%概率健康
            self.last_health_check = time.time()
            return self.is_healthy
        except Exception:
            self.is_healthy = False
            return False

class LoadBalancer:
    def __init__(self, algorithm: str = "round_robin"):
        self.servers: List[Server] = []
        self.algorithm = algorithm
        self.current_index = 0
        self.request_count = defaultdict(int)
    
    def add_server(self, server: Server):
        """添加服务器"""
        self.servers.append(server)
        print(f"添加服务器: {server.server_id}")
    
    def remove_server(self, server_id: str):
        """移除服务器"""
        self.servers = [s for s in self.servers if s.server_id != server_id]
        print(f"移除服务器: {server_id}")
    
    def select_server(self) -> Server:
        """选择服务器"""
        healthy_servers = [s for s in self.servers if s.is_healthy]
        
        if not healthy_servers:
            raise Exception("没有可用的服务器")
        
        if self.algorithm == "round_robin":
            return self._round_robin(healthy_servers)
        elif self.algorithm == "random":
            return self._random(healthy_servers)
        elif self.algorithm == "least_connections":
            return self._least_connections(healthy_servers)
        elif self.algorithm == "weighted_round_robin":
            return self._weighted_round_robin(healthy_servers)
        else:
            return self._round_robin(healthy_servers)
    
    def _round_robin(self, servers: List[Server]) -> Server:
        """轮询算法"""
        server = servers[self.current_index % len(servers)]
        self.current_index += 1
        return server
    
    def _random(self, servers: List[Server]) -> Server:
        """随机算法"""
        return random.choice(servers)
    
    def _least_connections(self, servers: List[Server]) -> Server:
        """最少连接算法"""
        return min(servers, key=lambda s: s.connections)
    
    def _weighted_round_robin(self, servers: List[Server]) -> Server:
        """加权轮询算法"""
        total_weight = sum(s.weight for s in servers)
        current_weight = 0
        
        for server in servers:
            current_weight += server.weight
            if current_weight >= self.current_index:
                self.current_index += 1
                return server
        
        # 重置
        self.current_index = 1
        return servers[0]
    
    def handle_request(self, request: str) -> str:
        """处理请求"""
        server = self.select_server()
        self.request_count[server.server_id] += 1
        
        try:
            response = server.handle_request(request)
            return response
        except Exception as e:
            print(f"服务器 {server.server_id} 处理请求失败: {e}")
            # 重新选择服务器
            return self.handle_request(request)
    
    def health_check_all(self):
        """检查所有服务器健康状态"""
        for server in self.servers:
            server.health_check()
    
    def get_statistics(self) -> Dict:
        """获取统计信息"""
        stats = {
            'total_servers': len(self.servers),
            'healthy_servers': len([s for s in self.servers if s.is_healthy]),
            'total_requests': sum(self.request_count.values()),
            'server_stats': {}
        }
        
        for server in self.servers:
            stats['server_stats'][server.server_id] = {
                'connections': server.connections,
                'response_time': server.response_time,
                'is_healthy': server.is_healthy,
                'requests': self.request_count[server.server_id]
            }
        
        return stats

def load_balancer_example():
    """负载均衡器示例"""
    # 创建服务器
    servers = [
        Server("server1", "192.168.1.10", 8080),
        Server("server2", "192.168.1.11", 8080),
        Server("server3", "192.168.1.12", 8080)
    ]
    
    # 设置权重
    servers[0].weight = 2
    servers[1].weight = 1
    servers[2].weight = 1
    
    # 创建负载均衡器
    algorithms = ["round_robin", "random", "least_connections", "weighted_round_robin"]
    
    for algorithm in algorithms:
        print(f"\n=== 使用 {algorithm} 算法 ===")
        
        lb = LoadBalancer(algorithm)
        for server in servers:
            lb.add_server(server)
        
        # 发送请求
        requests = [f"request_{i}" for i in range(10)]
        
        for request in requests:
            try:
                response = lb.handle_request(request)
                print(f"请求: {request} -> {response}")
            except Exception as e:
                print(f"请求失败: {e}")
        
        # 显示统计信息
        stats = lb.get_statistics()
        print(f"统计信息: {stats}")
    
    return lb
```

### 故障恢复

#### 1. 故障检测与恢复

```python
import threading
import time
from typing import Dict, List, Callable

class FailureDetector:
    def __init__(self, timeout: float = 5.0):
        self.timeout = timeout
        self.nodes = {}
        self.suspected_nodes = set()
        self.detection_callbacks = []
    
    def add_node(self, node_id: str, heartbeat_callback: Callable = None):
        """添加节点"""
        self.nodes[node_id] = {
            'last_heartbeat': time.time(),
            'heartbeat_callback': heartbeat_callback,
            'is_suspected': False
        }
    
    def receive_heartbeat(self, node_id: str):
        """接收心跳"""
        if node_id in self.nodes:
            self.nodes[node_id]['last_heartbeat'] = time.time()
            self.nodes[node_id]['is_suspected'] = False
            if node_id in self.suspected_nodes:
                self.suspected_nodes.remove(node_id)
    
    def start_detection(self):
        """开始故障检测"""
        def detection_loop():
            while True:
                current_time = time.time()
                
                for node_id, node_info in self.nodes.items():
                    if current_time - node_info['last_heartbeat'] > self.timeout:
                        if not node_info['is_suspected']:
                            node_info['is_suspected'] = True
                            self.suspected_nodes.add(node_id)
                            self._notify_failure(node_id)
                
                time.sleep(1)
        
        detection_thread = threading.Thread(target=detection_loop, daemon=True)
        detection_thread.start()
    
    def add_failure_callback(self, callback: Callable):
        """添加故障回调"""
        self.detection_callbacks.append(callback)
    
    def _notify_failure(self, node_id: str):
        """通知故障"""
        print(f"检测到节点故障: {node_id}")
        for callback in self.detection_callbacks:
            try:
                callback(node_id)
            except Exception as e:
                print(f"故障回调执行失败: {e}")
    
    def get_suspected_nodes(self) -> List[str]:
        """获取可疑节点"""
        return list(self.suspected_nodes)

class ReplicationManager:
    def __init__(self, primary_node: str, replica_nodes: List[str]):
        self.primary_node = primary_node
        self.replica_nodes = replica_nodes
        self.data = {}
        self.replication_log = []
    
    def write_data(self, key: str, value: str) -> bool:
        """写入数据"""
        # 写入主节点
        self.data[key] = value
        
        # 记录复制日志
        log_entry = {
            'operation': 'write',
            'key': key,
            'value': value,
            'timestamp': time.time()
        }
        self.replication_log.append(log_entry)
        
        # 复制到从节点
        success_count = 1  # 主节点
        
        for replica in self.replica_nodes:
            if self._replicate_to_node(replica, log_entry):
                success_count += 1
        
        # 如果多数节点成功，认为写入成功
        return success_count > (len(self.replica_nodes) + 1) // 2
    
    def read_data(self, key: str) -> str:
        """读取数据"""
        return self.data.get(key)
    
    def _replicate_to_node(self, node: str, log_entry: Dict) -> bool:
        """复制到节点"""
        # 模拟网络复制
        # 在实际实现中，这里会发送网络请求
        return random.random() > 0.1  # 90%成功率
    
    def failover(self, new_primary: str):
        """故障转移"""
        if new_primary not in self.replica_nodes:
            raise ValueError(f"节点 {new_primary} 不是从节点")
        
        print(f"执行故障转移: {self.primary_node} -> {new_primary}")
        
        # 更新主节点
        old_primary = self.primary_node
        self.primary_node = new_primary
        self.replica_nodes.remove(new_primary)
        self.replica_nodes.append(old_primary)
        
        # 同步数据
        self._sync_data_to_new_primary()
    
    def _sync_data_to_new_primary(self):
        """同步数据到新主节点"""
        print(f"同步数据到新主节点: {self.primary_node}")
        # 在实际实现中，这里会同步所有数据

class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = 0
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    def call(self, func: Callable, *args, **kwargs):
        """调用函数"""
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
                print("熔断器进入半开状态")
            else:
                raise Exception("熔断器开启，拒绝请求")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _on_success(self):
        """成功回调"""
        self.failure_count = 0
        if self.state == "HALF_OPEN":
            self.state = "CLOSED"
            print("熔断器关闭")
    
    def _on_failure(self):
        """失败回调"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"
            print("熔断器开启")

def fault_tolerance_example():
    """故障恢复示例"""
    # 创建故障检测器
    detector = FailureDetector(timeout=3.0)
    
    # 添加节点
    nodes = ['node1', 'node2', 'node3']
    for node in nodes:
        detector.add_node(node)
    
    # 添加故障回调
    def on_node_failure(node_id: str):
        print(f"处理节点故障: {node_id}")
        # 这里可以实现故障恢复逻辑
    
    detector.add_failure_callback(on_node_failure)
    
    # 启动故障检测
    detector.start_detection()
    
    # 创建复制管理器
    replication_manager = ReplicationManager('node1', ['node2', 'node3'])
    
    # 写入数据
    success = replication_manager.write_data('key1', 'value1')
    print(f"数据写入: {'成功' if success else '失败'}")
    
    # 读取数据
    value = replication_manager.read_data('key1')
    print(f"数据读取: {value}")
    
    # 创建熔断器
    circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30.0)
    
    # 模拟服务调用
    def unreliable_service():
        if random.random() > 0.7:
            raise Exception("服务调用失败")
        return "服务调用成功"
    
    for i in range(10):
        try:
            result = circuit_breaker.call(unreliable_service)
            print(f"调用 {i+1}: {result}")
        except Exception as e:
            print(f"调用 {i+1}: {e}")
    
    return detector, replication_manager, circuit_breaker
```

### 实战案例：分布式缓存系统

```python
class DistributedCache:
    def __init__(self, nodes: List[str]):
        self.nodes = nodes
        self.consistent_hash = ConsistentHash(nodes)
        self.cache_data = {}
        self.replication_factor = 2
    
    def set(self, key: str, value: str, ttl: int = 3600) -> bool:
        """设置缓存"""
        # 计算哈希
        node = self.consistent_hash.get_node(key)
        
        # 存储数据
        self.cache_data[key] = {
            'value': value,
            'node': node,
            'ttl': ttl,
            'timestamp': time.time()
        }
        
        # 复制到其他节点
        replica_nodes = self.consistent_hash.get_replica_nodes(key, self.replication_factor)
        for replica_node in replica_nodes:
            if replica_node != node:
                self._replicate_data(replica_node, key, value, ttl)
        
        return True
    
    def get(self, key: str) -> str:
        """获取缓存"""
        if key not in self.cache_data:
            return None
        
        data = self.cache_data[key]
        
        # 检查TTL
        if time.time() - data['timestamp'] > data['ttl']:
            del self.cache_data[key]
            return None
        
        return data['value']
    
    def delete(self, key: str) -> bool:
        """删除缓存"""
        if key in self.cache_data:
            del self.cache_data[key]
            return True
        return False
    
    def _replicate_data(self, node: str, key: str, value: str, ttl: int):
        """复制数据"""
        # 模拟网络复制
        print(f"复制数据到节点 {node}: {key} = {value}")
    
    def get_statistics(self) -> Dict:
        """获取统计信息"""
        return {
            'total_keys': len(self.cache_data),
            'nodes': self.nodes,
            'replication_factor': self.replication_factor
        }

class ConsistentHash:
    def __init__(self, nodes: List[str], virtual_nodes: int = 150):
        self.nodes = nodes
        self.virtual_nodes = virtual_nodes
        self.ring = {}
        self._build_ring()
    
    def _build_ring(self):
        """构建哈希环"""
        for node in self.nodes:
            for i in range(self.virtual_nodes):
                virtual_node = f"{node}#{i}"
                hash_value = hash(virtual_node)
                self.ring[hash_value] = node
    
    def get_node(self, key: str) -> str:
        """获取节点"""
        hash_value = hash(key)
        
        # 找到下一个节点
        sorted_hashes = sorted(self.ring.keys())
        
        for hash_val in sorted_hashes:
            if hash_val >= hash_value:
                return self.ring[hash_val]
        
        # 如果没找到，返回第一个节点
        return self.ring[sorted_hashes[0]]
    
    def get_replica_nodes(self, key: str, count: int) -> List[str]:
        """获取副本节点"""
        primary_node = self.get_node(key)
        replica_nodes = [primary_node]
        
        hash_value = hash(key)
        sorted_hashes = sorted(self.ring.keys())
        
        for hash_val in sorted_hashes:
            if hash_val > hash_value:
                node = self.ring[hash_val]
                if node not in replica_nodes and len(replica_nodes) < count:
                    replica_nodes.append(node)
        
        # 如果副本数量不够，从头开始找
        for hash_val in sorted_hashes:
            node = self.ring[hash_val]
            if node not in replica_nodes and len(replica_nodes) < count:
                replica_nodes.append(node)
        
        return replica_nodes

def distributed_cache_example():
    """分布式缓存示例"""
    # 创建分布式缓存
    nodes = ['cache1', 'cache2', 'cache3', 'cache4']
    cache = DistributedCache(nodes)
    
    # 设置缓存
    test_data = {
        'user:1': 'Alice',
        'user:2': 'Bob',
        'user:3': 'Charlie',
        'product:1': 'iPhone',
        'product:2': 'MacBook'
    }
    
    for key, value in test_data.items():
        cache.set(key, value, ttl=3600)
        print(f"设置缓存: {key} = {value}")
    
    # 获取缓存
    for key in test_data.keys():
        value = cache.get(key)
        print(f"获取缓存: {key} = {value}")
    
    # 显示统计信息
    stats = cache.get_statistics()
    print(f"缓存统计: {stats}")
    
    return cache

# 运行示例
if __name__ == "__main__":
    print("=== 分布式系统架构实战示例 ===")
    
    # MapReduce
    print("\n1. MapReduce")
    result = mapreduce_example()
    
    # 分布式任务
    print("\n2. 分布式任务")
    executor = distributed_task_example()
    
    # 两阶段提交
    print("\n3. 两阶段提交")
    coordinator = two_phase_commit_example()
    
    # Raft共识
    print("\n4. Raft共识")
    cluster = raft_example()
    
    # 负载均衡
    print("\n5. 负载均衡")
    lb = load_balancer_example()
    
    # 故障恢复
    print("\n6. 故障恢复")
    detector, replication_manager, circuit_breaker = fault_tolerance_example()
    
    # 分布式缓存
    print("\n7. 分布式缓存")
    cache = distributed_cache_example()
    
    print("\n分布式系统架构实战完成！")
```

### 理论总结

分布式系统架构是现代大规模应用的基础，通过分布式计算、一致性协议、负载均衡、故障恢复等技术手段，能够构建高可用、高扩展、高容错的系统，为云计算、大数据、微服务等应用场景提供强有力的技术支撑。
