# 01.01 é›†åˆè®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

é›†åˆè®ºæ˜¯æ•°å­¦çš„åŸºç¡€ç†è®ºï¼Œä¹Ÿæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æ•°æ®ç»“æ„ã€ç®—æ³•å’Œå½¢å¼åŒ–æ–¹æ³•çš„é‡è¦åŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰é›†åˆè®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆçš„åŸºæœ¬å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
é›†åˆæ˜¯ä¸€ä¸ªæ— åºçš„ã€ä¸é‡å¤çš„å…ƒç´ é›†åˆã€‚å½¢å¼åŒ–åœ°ï¼Œé›†åˆ $A$ æ»¡è¶³ï¼š

- æ— åºæ€§ï¼š$\{a, b\} = \{b, a\}$
- å”¯ä¸€æ€§ï¼š$\{a, a\} = \{a\}$
- å…ƒç´ æ€§ï¼š$a \in A$ æˆ– $a \notin A$

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, Generic, Iterator, Any, List, Set
from abc import ABC, abstractmethod
from dataclasses import dataclass
from collections.abc import Collection

T = TypeVar('T')

class MathematicalSet(Generic[T]):
    """æ•°å­¦é›†åˆçš„æŠ½è±¡å®ç°"""
    
    def __init__(self, elements: Collection[T] = None):
        self._elements: Set[T] = set(elements) if elements else set()
    
    def __contains__(self, element: T) -> bool:
        """å…ƒç´ å±äºå…³ç³»ï¼šx âˆˆ A"""
        return element in self._elements
    
    def __iter__(self) -> Iterator[T]:
        """è¿­ä»£å™¨"""
        return iter(self._elements)
    
    def __len__(self) -> int:
        """é›†åˆåŸºæ•°ï¼š|A|"""
        return len(self._elements)
    
    def __eq__(self, other: 'MathematicalSet[T]') -> bool:
        """é›†åˆç›¸ç­‰ï¼šA = B"""
        if not isinstance(other, MathematicalSet):
            return False
        return self._elements == other._elements
    
    def __repr__(self) -> str:
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        return f"{{{', '.join(map(str, self._elements))}}}"
    
    def add(self, element: T) -> None:
        """æ·»åŠ å…ƒç´ ï¼šA âˆª {x}"""
        self._elements.add(element)
    
    def remove(self, element: T) -> None:
        """ç§»é™¤å…ƒç´ ï¼šA \ {x}"""
        self._elements.discard(element)
    
    def is_empty(self) -> bool:
        """ç©ºé›†åˆ¤æ–­ï¼šA = âˆ…"""
        return len(self._elements) == 0
    
    def is_subset(self, other: 'MathematicalSet[T]') -> bool:
        """å­é›†å…³ç³»ï¼šA âŠ† B"""
        return self._elements.issubset(other._elements)
    
    def is_superset(self, other: 'MathematicalSet[T]') -> bool:
        """è¶…é›†å…³ç³»ï¼šA âŠ‡ B"""
        return self._elements.issuperset(other._elements)
    
    def union(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """å¹¶é›†ï¼šA âˆª B"""
        return MathematicalSet(self._elements.union(other._elements))
    
    def intersection(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """äº¤é›†ï¼šA âˆ© B"""
        return MathematicalSet(self._elements.intersection(other._elements))
    
    def difference(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """å·®é›†ï¼šA \ B"""
        return MathematicalSet(self._elements.difference(other._elements))
    
    def symmetric_difference(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """å¯¹ç§°å·®ï¼šA â–³ B = (A \ B) âˆª (B \ A)"""
        return MathematicalSet(self._elements.symmetric_difference(other._elements))
    
    def complement(self, universal_set: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """è¡¥é›†ï¼šA' = U \ A"""
        return universal_set.difference(self)
    
    def power_set(self) -> 'MathematicalSet[MathematicalSet[T]]':
        """å¹‚é›†ï¼šP(A)"""
        from itertools import combinations
        
        power_set_elements = set()
        elements_list = list(self._elements)
        
        for r in range(len(elements_list) + 1):
            for combo in combinations(elements_list, r):
                power_set_elements.add(MathematicalSet(combo))
        
        return MathematicalSet(power_set_elements)
    
    def cartesian_product(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[tuple[T, T]]':
        """ç¬›å¡å°”ç§¯ï¼šA Ã— B"""
        from itertools import product
        
        product_elements = set()
        for a, b in product(self._elements, other._elements):
            product_elements.add((a, b))
        
        return MathematicalSet(product_elements)

# ç¤ºä¾‹ï¼šåŸºæœ¬é›†åˆæ“ä½œ
def demonstrate_basic_set_operations():
    """æ¼”ç¤ºåŸºæœ¬é›†åˆæ“ä½œ"""
    # åˆ›å»ºé›†åˆ
    A = MathematicalSet([1, 2, 3, 4, 5])
    B = MathematicalSet([4, 5, 6, 7, 8])
    
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"|A| = {len(A)}")
    print(f"3 âˆˆ A: {3 in A}")
    print(f"6 âˆˆ A: {6 in A}")
    
    # é›†åˆè¿ç®—
    print(f"A âˆª B = {A.union(B)}")
    print(f"A âˆ© B = {A.intersection(B)}")
    print(f"A \\ B = {A.difference(B)}")
    print(f"A â–³ B = {A.symmetric_difference(B)}")
    
    # å­é›†å…³ç³»
    C = MathematicalSet([1, 2])
    print(f"C = {C}")
    print(f"C âŠ† A: {C.is_subset(A)}")
    print(f"A âŠ‡ C: {A.is_superset(C)}")
    
    return A, B, C

# è¿è¡Œç¤ºä¾‹
A, B, C = demonstrate_basic_set_operations()
```

### 2. é›†åˆçš„ä»£æ•°æ€§è´¨

#### 2.1 é›†åˆè¿ç®—å¾‹

**æ•°å­¦å®šä¹‰**ï¼š
é›†åˆè¿ç®—æ»¡è¶³ä»¥ä¸‹åŸºæœ¬å®šå¾‹ï¼š

1. **äº¤æ¢å¾‹**ï¼š$A \cup B = B \cup A$, $A \cap B = B \cap A$
2. **ç»“åˆå¾‹**ï¼š$(A \cup B) \cup C = A \cup (B \cup C)$, $(A \cap B) \cap C = A \cap (B \cap C)$
3. **åˆ†é…å¾‹**ï¼š$A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$, $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$
4. **å¾·æ‘©æ ¹å¾‹**ï¼š$(A \cup B)' = A' \cap B'$, $(A \cap B)' = A' \cup B'$

**Pythonå®ç°**ï¼š

```python
class SetAlgebra:
    """é›†åˆä»£æ•°éªŒè¯å™¨"""
    
    def __init__(self):
        self.universal_set = MathematicalSet(range(1, 11))  # U = {1, 2, ..., 10}
    
    def verify_commutative_law(self, A: MathematicalSet, B: MathematicalSet) -> bool:
        """éªŒè¯äº¤æ¢å¾‹"""
        union_commutative = A.union(B) == B.union(A)
        intersection_commutative = A.intersection(B) == B.intersection(A)
        
        print(f"äº¤æ¢å¾‹éªŒè¯:")
        print(f"  A âˆª B = B âˆª A: {union_commutative}")
        print(f"  A âˆ© B = B âˆ© A: {intersection_commutative}")
        
        return union_commutative and intersection_commutative
    
    def verify_associative_law(self, A: MathematicalSet, B: MathematicalSet, C: MathematicalSet) -> bool:
        """éªŒè¯ç»“åˆå¾‹"""
        union_associative = (A.union(B)).union(C) == A.union(B.union(C))
        intersection_associative = (A.intersection(B)).intersection(C) == A.intersection(B.intersection(C))
        
        print(f"ç»“åˆå¾‹éªŒè¯:")
        print(f"  (A âˆª B) âˆª C = A âˆª (B âˆª C): {union_associative}")
        print(f"  (A âˆ© B) âˆ© C = A âˆ© (B âˆ© C): {intersociative}")
        
        return union_associative and intersection_associative
    
    def verify_distributive_law(self, A: MathematicalSet, B: MathematicalSet, C: MathematicalSet) -> bool:
        """éªŒè¯åˆ†é…å¾‹"""
        union_over_intersection = A.union(B.intersection(C)) == (A.union(B)).intersection(A.union(C))
        intersection_over_union = A.intersection(B.union(C)) == (A.intersection(B)).union(A.intersection(C))
        
        print(f"åˆ†é…å¾‹éªŒè¯:")
        print(f"  A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C): {union_over_intersection}")
        print(f"  A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C): {intersection_over_union}")
        
        return union_over_intersection and intersection_over_union
    
    def verify_de_morgan_law(self, A: MathematicalSet, B: MathematicalSet) -> bool:
        """éªŒè¯å¾·æ‘©æ ¹å¾‹"""
        A_complement = A.complement(self.universal_set)
        B_complement = B.complement(self.universal_set)
        
        union_complement = (A.union(B)).complement(self.universal_set) == A_complement.intersection(B_complement)
        intersection_complement = (A.intersection(B)).complement(self.universal_set) == A_complement.union(B_complement)
        
        print(f"å¾·æ‘©æ ¹å¾‹éªŒè¯:")
        print(f"  (A âˆª B)' = A' âˆ© B': {union_complement}")
        print(f"  (A âˆ© B)' = A' âˆª B': {intersection_complement}")
        
        return union_complement and intersection_complement
    
    def verify_all_laws(self, A: MathematicalSet, B: MathematicalSet, C: MathematicalSet) -> bool:
        """éªŒè¯æ‰€æœ‰å®šå¾‹"""
        print("=== é›†åˆä»£æ•°å®šå¾‹éªŒè¯ ===")
        
        commutative = self.verify_commutative_law(A, B)
        associative = self.verify_associative_law(A, B, C)
        distributive = self.verify_distributive_law(A, B, C)
        de_morgan = self.verify_de_morgan_law(A, B)
        
        all_valid = commutative and associative and distributive and de_morgan
        print(f"\næ‰€æœ‰å®šå¾‹éªŒè¯ç»“æœ: {'é€šè¿‡' if all_valid else 'å¤±è´¥'}")
        
        return all_valid

# ç¤ºä¾‹ï¼šéªŒè¯é›†åˆä»£æ•°å®šå¾‹
def verify_set_algebra():
    """éªŒè¯é›†åˆä»£æ•°å®šå¾‹"""
    algebra = SetAlgebra()
    
    # åˆ›å»ºæµ‹è¯•é›†åˆ
    A = MathematicalSet([1, 2, 3, 4, 5])
    B = MathematicalSet([4, 5, 6, 7, 8])
    C = MathematicalSet([7, 8, 9, 10])
    
    print(f"U = {algebra.universal_set}")
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"C = {C}")
    print()
    
    # éªŒè¯æ‰€æœ‰å®šå¾‹
    algebra.verify_all_laws(A, B, C)
    
    return algebra

# è¿è¡Œç¤ºä¾‹
set_algebra = verify_set_algebra()
```

#### 2.2 é›†åˆçš„åŸºæ•°

**æ•°å­¦å®šä¹‰**ï¼š
é›†åˆ $A$ çš„åŸºæ•° $|A|$ æ˜¯é›†åˆä¸­å…ƒç´ çš„ä¸ªæ•°ã€‚å¯¹äºæœ‰é™é›†ï¼ŒåŸºæ•°æ˜¯è‡ªç„¶æ•°ï¼›å¯¹äºæ— é™é›†ï¼ŒåŸºæ•°ç”¨è¶…é™æ•°è¡¨ç¤ºã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Union, Dict, Any
from dataclasses import dataclass

@dataclass
class Cardinality:
    """åŸºæ•°å®šä¹‰"""
    value: Union[int, str]  # æœ‰é™é›†ç”¨æ•´æ•°ï¼Œæ— é™é›†ç”¨å­—ç¬¦ä¸²
    is_finite: bool
    description: str

class SetCardinality:
    """é›†åˆåŸºæ•°åˆ†æ"""
    
    def __init__(self):
        self.special_sets = {
            'natural_numbers': MathematicalSet(range(1, 1000)),  # æœ‰é™è¡¨ç¤º
            'integers': MathematicalSet(range(-500, 501)),       # æœ‰é™è¡¨ç¤º
            'rational_numbers': MathematicalSet(),               # å¤æ‚è¡¨ç¤º
            'real_numbers': MathematicalSet()                    # ä¸å¯æ•°
        }
    
    def get_cardinality(self, A: MathematicalSet) -> Cardinality:
        """è·å–é›†åˆåŸºæ•°"""
        size = len(A)
        
        if size < float('inf'):
            return Cardinality(
                value=size,
                is_finite=True,
                description=f"æœ‰é™é›†ï¼ŒåŸºæ•°ä¸º {size}"
            )
        else:
            return Cardinality(
                value="â„µâ‚€",  # é˜¿åˆ—å¤«é›¶
                is_finite=False,
                description="æ— é™å¯æ•°é›†"
            )
    
    def compare_cardinalities(self, A: MathematicalSet, B: MathematicalSet) -> str:
        """æ¯”è¾ƒä¸¤ä¸ªé›†åˆçš„åŸºæ•°"""
        card_A = self.get_cardinality(A)
        card_B = self.get_cardinality(B)
        
        if card_A.is_finite and card_B.is_finite:
            if card_A.value < card_B.value:
                return f"|A| < |B| ({card_A.value} < {card_B.value})"
            elif card_A.value > card_B.value:
                return f"|A| > |B| ({card_A.value} > {card_B.value})"
            else:
                return f"|A| = |B| ({card_A.value})"
        else:
            return f"è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æ— é™é›†ï¼Œæ— æ³•ç›´æ¥æ¯”è¾ƒ"
    
    def power_set_cardinality(self, A: MathematicalSet) -> Cardinality:
        """è®¡ç®—å¹‚é›†åŸºæ•°ï¼š|P(A)| = 2^|A|"""
        card_A = self.get_cardinality(A)
        
        if card_A.is_finite:
            power_set_size = 2 ** card_A.value
            return Cardinality(
                value=power_set_size,
                is_finite=True,
                description=f"|P(A)| = 2^{card_A.value} = {power_set_size}"
            )
        else:
            return Cardinality(
                value="2^â„µâ‚€",
                is_finite=False,
                description="å¹‚é›†åŸºæ•°ä¸º 2^â„µâ‚€"
            )
    
    def cartesian_product_cardinality(self, A: MathematicalSet, B: MathematicalSet) -> Cardinality:
        """è®¡ç®—ç¬›å¡å°”ç§¯åŸºæ•°ï¼š|A Ã— B| = |A| Ã— |B|"""
        card_A = self.get_cardinality(A)
        card_B = self.get_cardinality(B)
        
        if card_A.is_finite and card_B.is_finite:
            product_size = card_A.value * card_B.value
            return Cardinality(
                value=product_size,
                is_finite=True,
                description=f"|A Ã— B| = {card_A.value} Ã— {card_B.value} = {product_size}"
            )
        else:
            return Cardinality(
                value="â„µâ‚€",
                is_finite=False,
                description="è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æ— é™é›†ï¼Œç§¯ä¸º â„µâ‚€"
            )

# ç¤ºä¾‹ï¼šåŸºæ•°åˆ†æ
def demonstrate_cardinality():
    """æ¼”ç¤ºåŸºæ•°åˆ†æ"""
    cardinality_analyzer = SetCardinality()
    
    # æµ‹è¯•ä¸åŒå¤§å°çš„é›†åˆ
    sets = [
        MathematicalSet([]),                    # ç©ºé›†
        MathematicalSet([1]),                   # å•å…ƒç´ é›†
        MathematicalSet([1, 2, 3, 4, 5]),      # 5å…ƒç´ é›†
        MathematicalSet(range(100)),            # 100å…ƒç´ é›†
    ]
    
    print("=== é›†åˆåŸºæ•°åˆ†æ ===")
    for i, A in enumerate(sets):
        card = cardinality_analyzer.get_cardinality(A)
        print(f"é›†åˆ {i+1}: {A}")
        print(f"  åŸºæ•°: {card.description}")
        
        # å¹‚é›†åŸºæ•°
        power_card = cardinality_analyzer.power_set_cardinality(A)
        print(f"  å¹‚é›†åŸºæ•°: {power_card.description}")
        print()
    
    # æ¯”è¾ƒåŸºæ•°
    A = MathematicalSet([1, 2, 3])
    B = MathematicalSet([1, 2, 3, 4, 5])
    comparison = cardinality_analyzer.compare_cardinalities(A, B)
    print(f"åŸºæ•°æ¯”è¾ƒ: {comparison}")
    
    # ç¬›å¡å°”ç§¯åŸºæ•°
    cartesian_card = cardinality_analyzer.cartesian_product_cardinality(A, B)
    print(f"ç¬›å¡å°”ç§¯åŸºæ•°: {cartesian_card.description}")
    
    return cardinality_analyzer

# è¿è¡Œç¤ºä¾‹
cardinality_demo = demonstrate_cardinality()
```

### 3. å…³ç³»ä¸å‡½æ•°

#### 3.1 äºŒå…ƒå…³ç³»

**æ•°å­¦å®šä¹‰**ï¼š
é›†åˆ $A$ å’Œ $B$ çš„äºŒå…ƒå…³ç³» $R$ æ˜¯ç¬›å¡å°”ç§¯ $A \times B$ çš„å­é›†ï¼š$R \subseteq A \times B$

**Pythonå®ç°**ï¼š

```python
from typing import Set, Tuple, List, Dict, Any
from dataclasses import dataclass

@dataclass
class BinaryRelation:
    """äºŒå…ƒå…³ç³»"""
    domain: MathematicalSet
    codomain: MathematicalSet
    pairs: Set[Tuple[Any, Any]]
    
    def __post_init__(self):
        # éªŒè¯æ‰€æœ‰åºå¯¹éƒ½åœ¨ç¬›å¡å°”ç§¯ä¸­
        cartesian_product = self.domain.cartesian_product(self.codomain)
        valid_pairs = set()
        
        for pair in self.pairs:
            if pair in cartesian_product:
                valid_pairs.add(pair)
        
        self.pairs = valid_pairs
    
    def __contains__(self, pair: Tuple[Any, Any]) -> bool:
        """æ£€æŸ¥åºå¯¹æ˜¯å¦åœ¨å…³ç³»ä¸­"""
        return pair in self.pairs
    
    def domain_set(self) -> MathematicalSet:
        """å®šä¹‰åŸŸï¼šdom(R) = {a | âˆƒb: (a,b) âˆˆ R}"""
        domain_elements = set()
        for a, b in self.pairs:
            domain_elements.add(a)
        return MathematicalSet(domain_elements)
    
    def range_set(self) -> MathematicalSet:
        """å€¼åŸŸï¼šran(R) = {b | âˆƒa: (a,b) âˆˆ R}"""
        range_elements = set()
        for a, b in self.pairs:
            range_elements.add(b)
        return MathematicalSet(range_elements)
    
    def is_reflexive(self) -> bool:
        """è‡ªåæ€§ï¼šâˆ€a âˆˆ A: (a,a) âˆˆ R"""
        if self.domain != self.codomain:
            return False
        
        for element in self.domain:
            if (element, element) not in self.pairs:
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """å¯¹ç§°æ€§ï¼šâˆ€a,b: (a,b) âˆˆ R â†’ (b,a) âˆˆ R"""
        for a, b in self.pairs:
            if (b, a) not in self.pairs:
                return False
        return True
    
    def is_antisymmetric(self) -> bool:
        """åå¯¹ç§°æ€§ï¼šâˆ€a,b: (a,b) âˆˆ R âˆ§ (b,a) âˆˆ R â†’ a = b"""
        for a, b in self.pairs:
            if (b, a) in self.pairs and a != b:
                return False
        return True
    
    def is_transitive(self) -> bool:
        """ä¼ é€’æ€§ï¼šâˆ€a,b,c: (a,b) âˆˆ R âˆ§ (b,c) âˆˆ R â†’ (a,c) âˆˆ R"""
        for a, b in self.pairs:
            for c, d in self.pairs:
                if b == c and (a, d) not in self.pairs:
                    return False
        return True
    
    def is_equivalence_relation(self) -> bool:
        """ç­‰ä»·å…³ç³»ï¼šè‡ªåã€å¯¹ç§°ã€ä¼ é€’"""
        return (self.is_reflexive() and 
                self.is_symmetric() and 
                self.is_transitive())
    
    def is_partial_order(self) -> bool:
        """ååºå…³ç³»ï¼šè‡ªåã€åå¯¹ç§°ã€ä¼ é€’"""
        return (self.is_reflexive() and 
                self.is_antisymmetric() and 
                self.is_transitive())
    
    def composition(self, other: 'BinaryRelation') -> 'BinaryRelation':
        """å…³ç³»å¤åˆï¼šR âˆ˜ S = {(a,c) | âˆƒb: (a,b) âˆˆ S âˆ§ (b,c) âˆˆ R}"""
        if self.domain != other.codomain:
            raise ValueError("å…³ç³»å¤åˆéœ€è¦åŒ¹é…çš„åŸŸå’Œé™ªåŸŸ")
        
        composition_pairs = set()
        for a, b in other.pairs:
            for c, d in self.pairs:
                if b == c:
                    composition_pairs.add((a, d))
        
        return BinaryRelation(other.domain, self.codomain, composition_pairs)
    
    def inverse(self) -> 'BinaryRelation':
        """é€†å…³ç³»ï¼šR^(-1) = {(b,a) | (a,b) âˆˆ R}"""
        inverse_pairs = {(b, a) for a, b in self.pairs}
        return BinaryRelation(self.codomain, self.domain, inverse_pairs)

# ç¤ºä¾‹ï¼šå…³ç³»åˆ†æ
def demonstrate_binary_relations():
    """æ¼”ç¤ºäºŒå…ƒå…³ç³»"""
    # åˆ›å»ºé›†åˆ
    A = MathematicalSet([1, 2, 3, 4])
    B = MathematicalSet([1, 2, 3, 4])
    
    # å®šä¹‰å…³ç³»
    equality_relation = BinaryRelation(A, B, {
        (1, 1), (2, 2), (3, 3), (4, 4)
    })
    
    less_than_relation = BinaryRelation(A, B, {
        (1, 2), (1, 3), (1, 4),
        (2, 3), (2, 4),
        (3, 4)
    })
    
    divides_relation = BinaryRelation(A, B, {
        (1, 1), (1, 2), (1, 3), (1, 4),
        (2, 2), (2, 4),
        (3, 3),
        (4, 4)
    })
    
    print("=== äºŒå…ƒå…³ç³»åˆ†æ ===")
    
    relations = [
        ("ç›¸ç­‰å…³ç³»", equality_relation),
        ("å°äºå…³ç³»", less_than_relation),
        ("æ•´é™¤å…³ç³»", divides_relation)
    ]
    
    for name, relation in relations:
        print(f"\n{name}:")
        print(f"  åºå¯¹: {relation.pairs}")
        print(f"  å®šä¹‰åŸŸ: {relation.domain_set()}")
        print(f"  å€¼åŸŸ: {relation.range_set()}")
        print(f"  è‡ªåæ€§: {relation.is_reflexive()}")
        print(f"  å¯¹ç§°æ€§: {relation.is_symmetric()}")
        print(f"  åå¯¹ç§°æ€§: {relation.is_antisymmetric()}")
        print(f"  ä¼ é€’æ€§: {relation.is_transitive()}")
        print(f"  ç­‰ä»·å…³ç³»: {relation.is_equivalence_relation()}")
        print(f"  ååºå…³ç³»: {relation.is_partial_order()}")
    
    return relations

# è¿è¡Œç¤ºä¾‹
relation_demo = demonstrate_binary_relations()
```

#### 3.2 å‡½æ•°

**æ•°å­¦å®šä¹‰**ï¼š
å‡½æ•° $f: A \rightarrow B$ æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„äºŒå…ƒå…³ç³»ï¼Œæ»¡è¶³ï¼š

- å•å€¼æ€§ï¼š$\forall a \in A, \exists! b \in B: (a,b) \in f$
- å®šä¹‰åŸŸå®Œæ•´æ€§ï¼š$dom(f) = A$

**Pythonå®ç°**ï¼š

```python
from typing import Callable, Any, Dict, Optional
from dataclasses import dataclass

@dataclass
class MathematicalFunction:
    """æ•°å­¦å‡½æ•°"""
    domain: MathematicalSet
    codomain: MathematicalSet
    mapping: Callable[[Any], Any]
    relation: BinaryRelation
    
    def __post_init__(self):
        # ä»æ˜ å°„å‡½æ•°æ„å»ºå…³ç³»
        pairs = set()
        for element in self.domain:
            try:
                result = self.mapping(element)
                if result in self.codomain:
                    pairs.add((element, result))
            except Exception:
                pass
        
        self.relation = BinaryRelation(self.domain, self.codomain, pairs)
    
    def __call__(self, x: Any) -> Any:
        """å‡½æ•°è°ƒç”¨ï¼šf(x)"""
        if x not in self.domain:
            raise ValueError(f"{x} ä¸åœ¨å®šä¹‰åŸŸä¸­")
        
        return self.mapping(x)
    
    def is_injective(self) -> bool:
        """å•å°„ï¼šâˆ€a,b âˆˆ A: f(a) = f(b) â†’ a = b"""
        seen_values = set()
        for element in self.domain:
            value = self.mapping(element)
            if value in seen_values:
                return False
            seen_values.add(value)
        return True
    
    def is_surjective(self) -> bool:
        """æ»¡å°„ï¼šâˆ€b âˆˆ B, âˆƒa âˆˆ A: f(a) = b"""
        range_values = set()
        for element in self.domain:
            range_values.add(self.mapping(element))
        
        return range_values == self.codomain._elements
    
    def is_bijective(self) -> bool:
        """åŒå°„ï¼šæ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„"""
        return self.is_injective() and self.is_surjective()
    
    def inverse_function(self) -> Optional['MathematicalFunction']:
        """é€†å‡½æ•°ï¼šf^(-1): B â†’ A"""
        if not self.is_bijective():
            return None
        
        # æ„å»ºé€†æ˜ å°„
        inverse_mapping = {}
        for element in self.domain:
            value = self.mapping(element)
            inverse_mapping[value] = element
        
        def inverse_call(y: Any) -> Any:
            if y not in self.codomain:
                raise ValueError(f"{y} ä¸åœ¨é™ªåŸŸä¸­")
            return inverse_mapping[y]
        
        return MathematicalFunction(
            domain=self.codomain,
            codomain=self.domain,
            mapping=inverse_call,
            relation=BinaryRelation(self.codomain, self.domain, set())
        )
    
    def composition(self, g: 'MathematicalFunction') -> 'MathematicalFunction':
        """å‡½æ•°å¤åˆï¼š(f âˆ˜ g)(x) = f(g(x))"""
        if self.domain != g.codomain:
            raise ValueError("å‡½æ•°å¤åˆéœ€è¦åŒ¹é…çš„åŸŸå’Œé™ªåŸŸ")
        
        def composed_call(x: Any) -> Any:
            return self.mapping(g.mapping(x))
        
        return MathematicalFunction(
            domain=g.domain,
            codomain=self.codomain,
            mapping=composed_call,
            relation=BinaryRelation(g.domain, self.codomain, set())
        )

# ç¤ºä¾‹ï¼šå‡½æ•°åˆ†æ
def demonstrate_functions():
    """æ¼”ç¤ºå‡½æ•°åˆ†æ"""
    # åˆ›å»ºé›†åˆ
    A = MathematicalSet([1, 2, 3, 4])
    B = MathematicalSet([1, 2, 3, 4, 5, 6, 7, 8])
    
    # å®šä¹‰å‡½æ•°
    def square_function(x: int) -> int:
        return x ** 2
    
    def identity_function(x: int) -> int:
        return x
    
    def constant_function(x: int) -> int:
        return 1
    
    functions = [
        ("å¹³æ–¹å‡½æ•°", MathematicalFunction(A, B, square_function, BinaryRelation(A, B, set()))),
        ("æ’ç­‰å‡½æ•°", MathematicalFunction(A, A, identity_function, BinaryRelation(A, A, set()))),
        ("å¸¸å‡½æ•°", MathematicalFunction(A, A, constant_function, BinaryRelation(A, A, set())))
    ]
    
    print("=== å‡½æ•°åˆ†æ ===")
    
    for name, func in functions:
        print(f"\n{name}:")
        print(f"  å®šä¹‰åŸŸ: {func.domain}")
        print(f"  é™ªåŸŸ: {func.codomain}")
        print(f"  æ˜ å°„å…³ç³»: {func.relation.pairs}")
        
        # è®¡ç®—å‡½æ•°å€¼
        values = []
        for element in func.domain:
            try:
                values.append(func(element))
            except Exception as e:
                values.append(f"Error: {e}")
        
        print(f"  å‡½æ•°å€¼: {dict(zip(func.domain, values))}")
        print(f"  å•å°„: {func.is_injective()}")
        print(f"  æ»¡å°„: {func.is_surjective()}")
        print(f"  åŒå°„: {func.is_bijective()}")
        
        # é€†å‡½æ•°
        inverse = func.inverse_function()
        if inverse:
            print(f"  é€†å‡½æ•°: å­˜åœ¨")
        else:
            print(f"  é€†å‡½æ•°: ä¸å­˜åœ¨")
    
    # å‡½æ•°å¤åˆ
    if len(functions) >= 2:
        f = functions[0][1]  # å¹³æ–¹å‡½æ•°
        g = functions[1][1]  # æ’ç­‰å‡½æ•°
        
        composed = f.composition(g)
        print(f"\nå‡½æ•°å¤åˆ f âˆ˜ g:")
        print(f"  å®šä¹‰åŸŸ: {composed.domain}")
        print(f"  é™ªåŸŸ: {composed.codomain}")
        
        # æµ‹è¯•å¤åˆå‡½æ•°
        test_value = 3
        try:
            result = composed(test_value)
            print(f"  (f âˆ˜ g)({test_value}) = {result}")
        except Exception as e:
            print(f"  Error: {e}")
    
    return functions

# è¿è¡Œç¤ºä¾‹
function_demo = demonstrate_functions()
```

### 4. æ— é™é›†ä¸åŸºæ•°

#### 4.1 å¯æ•°é›†ä¸ä¸å¯æ•°é›†

**æ•°å­¦å®šä¹‰**ï¼š

- å¯æ•°é›†ï¼šä¸è‡ªç„¶æ•°é›†ç­‰åŠ¿çš„é›†åˆï¼ŒåŸºæ•° $â„µâ‚€$
- ä¸å¯æ•°é›†ï¼šä¸å®æ•°é›†ç­‰åŠ¿çš„é›†åˆï¼ŒåŸºæ•° $2^{â„µâ‚€}$

**Pythonå®ç°**ï¼š

```python
from typing import Iterator, Any, Optional
from dataclasses import dataclass
from enum import Enum

class InfinityType(Enum):
    COUNTABLE = "â„µâ‚€"      # å¯æ•°æ— é™
    UNCOUNTABLE = "2^â„µâ‚€"  # ä¸å¯æ•°æ— é™

@dataclass
class InfiniteSet:
    """æ— é™é›†æŠ½è±¡"""
    name: str
    infinity_type: InfinityType
    description: str

class InfiniteSetTheory:
    """æ— é™é›†ç†è®º"""
    
    def __init__(self):
        self.infinite_sets = {
            'natural_numbers': InfiniteSet(
                "è‡ªç„¶æ•°é›† â„•", 
                InfinityType.COUNTABLE, 
                "ä¸è‡ªç„¶æ•°ç­‰åŠ¿çš„æ— é™é›†"
            ),
            'integers': InfiniteSet(
                "æ•´æ•°é›† â„¤", 
                InfinityType.COUNTABLE, 
                "ä¸æ•´æ•°ç­‰åŠ¿çš„æ— é™é›†"
            ),
            'rational_numbers': InfiniteSet(
                "æœ‰ç†æ•°é›† â„š", 
                InfinityType.COUNTABLE, 
                "ä¸æœ‰ç†æ•°ç­‰åŠ¿çš„æ— é™é›†"
            ),
            'real_numbers': InfiniteSet(
                "å®æ•°é›† â„", 
                InfinityType.UNCOUNTABLE, 
                "ä¸å®æ•°ç­‰åŠ¿çš„ä¸å¯æ•°é›†"
            ),
            'power_set_naturals': InfiniteSet(
                "è‡ªç„¶æ•°å¹‚é›† P(â„•)", 
                InfinityType.UNCOUNTABLE, 
                "ä¸è‡ªç„¶æ•°å¹‚é›†ç­‰åŠ¿çš„ä¸å¯æ•°é›†"
            )
        }
    
    def cantor_diagonal_argument(self, n: int = 5) -> str:
        """åº·æ‰˜å°”å¯¹è§’çº¿è®ºè¯çš„æœ‰é™ç‰ˆæœ¬"""
        # æ„é€ ä¸€ä¸ªæœ‰é™çš„"å®æ•°"åˆ—è¡¨
        reals = []
        for i in range(n):
            # æ„é€ ä¸€ä¸ª"å®æ•°"ï¼ˆç”¨äºŒè¿›åˆ¶è¡¨ç¤ºï¼‰
            real = []
            for j in range(n):
                real.append((i + j) % 2)
            reals.append(real)
        
        # æ„é€ å¯¹è§’çº¿å…ƒç´ 
        diagonal = []
        for i in range(n):
            diagonal.append(1 - reals[i][i])  # å–å
        
        result = f"""
åº·æ‰˜å°”å¯¹è§’çº¿è®ºè¯ï¼ˆæœ‰é™ç‰ˆæœ¬ n={n}ï¼‰:

åŸå§‹"å®æ•°"åˆ—è¡¨:
{chr(10).join(f"  {i}: {reals[i]}" for i in range(n))}

å¯¹è§’çº¿å…ƒç´ : {diagonal}
å¯¹è§’çº¿å–å: {[1-x for x in diagonal]}

è¿™ä¸ªæ–°"å®æ•°"ä¸åœ¨åŸåˆ—è¡¨ä¸­ï¼Œè¯æ˜äº†ä¸å¯æ•°æ€§ã€‚
        """
        return result
    
    def hilbert_hotel_paradox(self, n: int = 3) -> str:
        """å¸Œå°”ä¼¯ç‰¹æ—…é¦†æ‚–è®º"""
        original_guests = list(range(1, n + 1))
        
        # ç­–ç•¥1ï¼šæ‰€æœ‰å®¢äººå‘å³ç§»åŠ¨nä¸ªæˆ¿é—´
        strategy1 = [guest + n for guest in original_guests]
        
        # ç­–ç•¥2ï¼šæ‰€æœ‰å®¢äººå‘å³ç§»åŠ¨1ä¸ªæˆ¿é—´
        strategy2 = [guest + 1 for guest in original_guests]
        
        result = f"""
å¸Œå°”ä¼¯ç‰¹æ—…é¦†æ‚–è®ºï¼ˆæœ‰é™ç‰ˆæœ¬ n={n}ï¼‰:

åŸå§‹å®¢äºº: {original_guests}

ç­–ç•¥1 - ä¸ºæ–°å®¢äººè…¾å‡ºå‰nä¸ªæˆ¿é—´:
  æ‰€æœ‰å®¢äººå‘å³ç§»åŠ¨{n}ä¸ªæˆ¿é—´: {strategy1}
  æ–°å®¢äººå¯ä»¥å…¥ä½æˆ¿é—´: {list(range(1, n + 1))}

ç­–ç•¥2 - ä¸ºæ–°å®¢äººè…¾å‡º1ä¸ªæˆ¿é—´:
  æ‰€æœ‰å®¢äººå‘å³ç§»åŠ¨1ä¸ªæˆ¿é—´: {strategy2}
  æ–°å®¢äººå¯ä»¥å…¥ä½æˆ¿é—´: [1]

è¿™å±•ç¤ºäº†å¯æ•°æ— é™é›†çš„ç¥å¥‡æ€§è´¨ã€‚
        """
        return result
    
    def compare_infinite_sets(self, set1_name: str, set2_name: str) -> str:
        """æ¯”è¾ƒä¸¤ä¸ªæ— é™é›†"""
        if set1_name not in self.infinite_sets or set2_name not in self.infinite_sets:
            return "é›†åˆåç§°æ— æ•ˆ"
        
        set1 = self.infinite_sets[set1_name]
        set2 = self.infinite_sets[set2_name]
        
        if set1.infinity_type == set2.infinity_type:
            comparison = f"{set1.name} å’Œ {set2.name} å…·æœ‰ç›¸åŒçš„åŸºæ•° {set1.infinity_type.value}"
        else:
            comparison = f"{set1.name} çš„åŸºæ•° {set1.infinity_type.value} å°äº {set2.name} çš„åŸºæ•° {set2.infinity_type.value}"
        
        return f"""
æ— é™é›†æ¯”è¾ƒ:

{set1.name}: {set1.description}
{set2.name}: {set2.description}

æ¯”è¾ƒç»“æœ: {comparison}
        """
    
    def list_all_sets(self) -> str:
        """åˆ—å‡ºæ‰€æœ‰æ— é™é›†"""
        result = "=== æ— é™é›†åˆ†ç±» ===\n"
        
        for name, infinite_set in self.infinite_sets.items():
            result += f"\n{infinite_set.name}:\n"
            result += f"  åŸºæ•°: {infinite_set.infinity_type.value}\n"
            result += f"  æè¿°: {infinite_set.description}\n"
        
        return result

# ç¤ºä¾‹ï¼šæ— é™é›†ç†è®º
def demonstrate_infinite_sets():
    """æ¼”ç¤ºæ— é™é›†ç†è®º"""
    infinite_theory = InfiniteSetTheory()
    
    print(infinite_theory.list_all_sets())
    
    print(infinite_theory.cantor_diagonal_argument(5))
    
    print(infinite_theory.hilbert_hotel_paradox(4))
    
    print(infinite_theory.compare_infinite_sets('natural_numbers', 'real_numbers'))
    
    return infinite_theory

# è¿è¡Œç¤ºä¾‹
infinite_demo = demonstrate_infinite_sets()
```

## ğŸ“Š é›†åˆè®ºæ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µ

1. **é›†åˆ**ï¼šæ— åºã€ä¸é‡å¤çš„å…ƒç´ é›†åˆ
2. **è¿ç®—**ï¼šå¹¶ã€äº¤ã€å·®ã€å¯¹ç§°å·®ã€è¡¥é›†
3. **å…³ç³»**ï¼šå­é›†ã€ç›¸ç­‰ã€ç¬›å¡å°”ç§¯
4. **å‡½æ•°**ï¼šç‰¹æ®Šçš„äºŒå…ƒå…³ç³»ï¼Œæ»¡è¶³å•å€¼æ€§
5. **åŸºæ•°**ï¼šé›†åˆå¤§å°çš„åº¦é‡

### æ•°å­¦å½¢å¼åŒ–

é›†åˆè®ºå¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦ç»“æ„è¡¨ç¤ºï¼š

$$SetTheory = (Sets, Relations, Functions, Cardinality)$$

å…¶ä¸­ï¼š

- $Sets = \{Union, Intersection, Difference, \ldots\}$
- $Relations = \{Binary, Equivalence, Order, \ldots\}$
- $Functions = \{Injection, Surjection, Bijection, \ldots\}$
- $Cardinality = \{Finite, Countable, Uncountable, \ldots\}$

### Pythonå®ç°éªŒè¯

```python
class SetTheoryValidator:
    """é›†åˆè®ºéªŒè¯å™¨"""
    
    def __init__(self):
        self.test_sets = {
            'empty': MathematicalSet([]),
            'singleton': MathematicalSet([1]),
            'finite': MathematicalSet([1, 2, 3, 4, 5]),
            'large': MathematicalSet(range(100))
        }
    
    def validate_set_operations(self) -> bool:
        """éªŒè¯é›†åˆè¿ç®—"""
        A = MathematicalSet([1, 2, 3])
        B = MathematicalSet([3, 4, 5])
        
        # éªŒè¯åŸºæœ¬è¿ç®—
        union_result = A.union(B)
        intersection_result = A.intersection(B)
        difference_result = A.difference(B)
        
        expected_union = MathematicalSet([1, 2, 3, 4, 5])
        expected_intersection = MathematicalSet([3])
        expected_difference = MathematicalSet([1, 2])
        
        return (union_result == expected_union and
                intersection_result == expected_intersection and
                difference_result == expected_difference)
    
    def validate_relations(self) -> bool:
        """éªŒè¯å…³ç³»"""
        A = MathematicalSet([1, 2, 3])
        
        # éªŒè¯ç­‰ä»·å…³ç³»
        equality = BinaryRelation(A, A, {(1, 1), (2, 2), (3, 3)})
        
        return equality.is_equivalence_relation()
    
    def validate_functions(self) -> bool:
        """éªŒè¯å‡½æ•°"""
        A = MathematicalSet([1, 2, 3])
        B = MathematicalSet([1, 2, 3])
        
        def identity(x):
            return x
        
        func = MathematicalFunction(A, B, identity, BinaryRelation(A, B, set()))
        
        return func.is_bijective()
    
    def validate_cardinality(self) -> bool:
        """éªŒè¯åŸºæ•°"""
        empty = MathematicalSet([])
        singleton = MathematicalSet([1])
        finite = MathematicalSet([1, 2, 3])
        
        return (len(empty) == 0 and
                len(singleton) == 1 and
                len(finite) == 3)
    
    def run_all_tests(self) -> Dict[str, bool]:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        tests = {
            'set_operations': self.validate_set_operations(),
            'relations': self.validate_relations(),
            'functions': self.validate_functions(),
            'cardinality': self.validate_cardinality()
        }
        
        print("=== é›†åˆè®ºéªŒè¯ç»“æœ ===")
        for test_name, result in tests.items():
            print(f"{test_name}: {'PASS' if result else 'FAIL'}")
        
        return tests

# ä½¿ç”¨ç¤ºä¾‹
validator = SetTheoryValidator()
test_results = validator.run_all_tests()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.03 è®¡ç®—æ€ç»´](../00-ç†å¿µåŸºç¡€/00.03-è®¡ç®—æ€ç»´.md)
- [01.02 é€»è¾‘å­¦åŸºç¡€](./01.02-é€»è¾‘å­¦åŸºç¡€.md)
- [01.03 å›¾è®ºåŸºç¡€](./01.03-å›¾è®ºåŸºç¡€.md)

---

*é›†åˆè®ºæ˜¯æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦çš„åŸºç¡€ç†è®ºï¼Œé€šè¿‡å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸¥è°¨çš„æ•°å­¦åŸºç¡€æ¥æ”¯æŒè½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„å‘å±•ã€‚*
