# 01-01-数学基础

## 概述

数学基础是软件工程和计算科学的理论基础，为算法设计、数据结构、形式化证明等提供数学支撑。本文档建立完整的数学基础体系。

## 1. 集合论基础

### 1.1 集合的基本概念

**集合** (Set) 是数学中的基本概念，表示具有某种共同特征的事物的总体。

#### 1.1.1 集合的定义

设 $A$ 为集合，$x$ 为元素，则：

- $x \in A$ 表示 $x$ 属于集合 $A$
- $x \notin A$ 表示 $x$ 不属于集合 $A$

#### 1.1.2 Python实现

```python
from typing import Set, List, Dict, Any, Union, Optional
from dataclasses import dataclass
from abc import ABC, abstractmethod
import math

class SetTheory:
    """集合论实现"""
    
    def __init__(self):
        self.universal_set: Set[Any] = set()
        self.sets: Dict[str, Set[Any]] = {}
    
    def create_set(self, name: str, elements: Set[Any]) -> None:
        """创建集合 A = {a, b, c}"""
        self.sets[name] = elements
        self.universal_set.update(elements)
    
    def union(self, set_a: str, set_b: str) -> Set[Any]:
        """并集 A ∪ B = {x | x ∈ A ∨ x ∈ B}"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] | self.sets[set_b]
        return set()
    
    def intersection(self, set_a: str, set_b: str) -> Set[Any]:
        """交集 A ∩ B = {x | x ∈ A ∧ x ∈ B}"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] & self.sets[set_b]
        return set()
    
    def difference(self, set_a: str, set_b: str) -> Set[Any]:
        """差集 A - B = {x | x ∈ A ∧ x ∉ B}"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] - self.sets[set_b]
        return set()
    
    def complement(self, set_name: str) -> Set[Any]:
        """补集 A' = U - A"""
        if set_name in self.sets:
            return self.universal_set - self.sets[set_name]
        return set()
    
    def cartesian_product(self, set_a: str, set_b: str) -> Set[tuple]:
        """笛卡尔积 A × B = {(a, b) | a ∈ A ∧ b ∈ B}"""
        if set_a in self.sets and set_b in self.sets:
            return {(a, b) for a in self.sets[set_a] for b in self.sets[set_b]}
        return set()
    
    def power_set(self, set_name: str) -> Set[frozenset]:
        """幂集 P(A) = {B | B ⊆ A}"""
        if set_name not in self.sets:
            return set()
        
        elements = list(self.sets[set_name])
        power_set = set()
        
        # 生成所有子集
        for i in range(2**len(elements)):
            subset = set()
            for j in range(len(elements)):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set
    
    def is_subset(self, set_a: str, set_b: str) -> bool:
        """子集 A ⊆ B"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a].issubset(self.sets[set_b])
        return False
    
    def is_proper_subset(self, set_a: str, set_b: str) -> bool:
        """真子集 A ⊂ B"""
        if set_a in self.sets and set_b in self.sets:
            return self.sets[set_a] < self.sets[set_b]
        return False
    
    def cardinality(self, set_name: str) -> int:
        """基数 |A|"""
        if set_name in self.sets:
            return len(self.sets[set_name])
        return 0

# 使用示例
def test_set_theory():
    """测试集合论"""
    st = SetTheory()
    
    # 创建集合
    st.create_set("A", {1, 2, 3, 4})
    st.create_set("B", {3, 4, 5, 6})
    st.create_set("C", {1, 2})
    
    print(f"集合 A: {st.sets['A']}")
    print(f"集合 B: {st.sets['B']}")
    print(f"并集 A ∪ B: {st.union('A', 'B')}")
    print(f"交集 A ∩ B: {st.intersection('A', 'B')}")
    print(f"差集 A - B: {st.difference('A', 'B')}")
    print(f"笛卡尔积 A × C: {st.cartesian_product('A', 'C')}")
    print(f"幂集 P(C): {st.power_set('C')}")
    print(f"C 是 A 的子集: {st.is_subset('C', 'A')}")
    print(f"集合 A 的基数: {st.cardinality('A')}")

if __name__ == "__main__":
    test_set_theory()
```

### 1.2 关系与函数

#### 1.2.1 关系的定义

**关系** (Relation) 是集合的笛卡尔积的子集。

设 $A$ 和 $B$ 为集合，则 $R \subseteq A \times B$ 称为从 $A$ 到 $B$ 的关系。

#### 1.2.2 Python实现

```python
class Relation:
    """关系类"""
    
    def __init__(self, domain: Set[Any], codomain: Set[Any]):
        self.domain = domain
        self.codomain = codomain
        self.pairs: Set[tuple] = set()
    
    def add_pair(self, a: Any, b: Any) -> None:
        """添加关系对 (a, b)"""
        if a in self.domain and b in self.codomain:
            self.pairs.add((a, b))
    
    def is_reflexive(self) -> bool:
        """自反性: ∀a ∈ A, (a, a) ∈ R"""
        for a in self.domain:
            if (a, a) not in self.pairs:
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """对称性: ∀a, b ∈ A, (a, b) ∈ R → (b, a) ∈ R"""
        for a, b in self.pairs:
            if (b, a) not in self.pairs:
                return False
        return True
    
    def is_transitive(self) -> bool:
        """传递性: ∀a, b, c ∈ A, (a, b) ∈ R ∧ (b, c) ∈ R → (a, c) ∈ R"""
        for a, b in self.pairs:
            for c, d in self.pairs:
                if b == c and (a, d) not in self.pairs:
                    return False
        return True
    
    def is_equivalence(self) -> bool:
        """等价关系: 自反、对称、传递"""
        return self.is_reflexive() and self.is_symmetric() and self.is_transitive()
    
    def equivalence_classes(self) -> List[Set[Any]]:
        """等价类"""
        if not self.is_equivalence():
            return []
        
        classes = []
        processed = set()
        
        for a in self.domain:
            if a in processed:
                continue
            
            # 找到包含 a 的等价类
            eq_class = {a}
            for b in self.domain:
                if (a, b) in self.pairs:
                    eq_class.add(b)
                    processed.add(b)
            
            classes.append(eq_class)
        
        return classes

class Function(Relation):
    """函数类"""
    
    def __init__(self, domain: Set[Any], codomain: Set[Any]):
        super().__init__(domain, codomain)
        self.mapping: Dict[Any, Any] = {}
    
    def define_mapping(self, mapping: Dict[Any, Any]) -> None:
        """定义映射关系"""
        for a, b in mapping.items():
            if a in self.domain and b in self.codomain:
                self.mapping[a] = b
                self.add_pair(a, b)
    
    def is_function(self) -> bool:
        """检查是否为函数: 每个定义域元素有唯一的像"""
        images = set()
        for a in self.domain:
            if a in self.mapping:
                if self.mapping[a] in images:
                    return False
                images.add(self.mapping[a])
        return True
    
    def is_injective(self) -> bool:
        """单射: 不同的定义域元素映射到不同的值域元素"""
        if not self.is_function():
            return False
        
        images = set()
        for image in self.mapping.values():
            if image in images:
                return False
            images.add(image)
        return True
    
    def is_surjective(self) -> bool:
        """满射: 值域中的每个元素都有原像"""
        if not self.is_function():
            return False
        
        return set(self.mapping.values()) == self.codomain
    
    def is_bijective(self) -> bool:
        """双射: 既是单射又是满射"""
        return self.is_injective() and self.is_surjective()
    
    def inverse(self) -> Optional['Function']:
        """逆函数"""
        if not self.is_bijective():
            return None
        
        inverse_func = Function(self.codomain, self.domain)
        inverse_mapping = {v: k for k, v in self.mapping.items()}
        inverse_func.define_mapping(inverse_mapping)
        
        return inverse_func

# 使用示例
def test_relations_and_functions():
    """测试关系和函数"""
    # 测试关系
    domain = {1, 2, 3, 4}
    codomain = {1, 2, 3, 4}
    
    relation = Relation(domain, codomain)
    relation.add_pair(1, 1)
    relation.add_pair(2, 2)
    relation.add_pair(3, 3)
    relation.add_pair(4, 4)
    relation.add_pair(1, 2)
    relation.add_pair(2, 1)
    
    print(f"关系是否自反: {relation.is_reflexive()}")
    print(f"关系是否对称: {relation.is_symmetric()}")
    print(f"关系是否传递: {relation.is_transitive()}")
    print(f"关系是否等价: {relation.is_equivalence()}")
    
    # 测试函数
    func = Function(domain, codomain)
    func.define_mapping({1: 2, 2: 3, 3: 4, 4: 1})
    
    print(f"是否为函数: {func.is_function()}")
    print(f"是否为单射: {func.is_injective()}")
    print(f"是否为满射: {func.is_surjective()}")
    print(f"是否为双射: {func.is_bijective()}")

if __name__ == "__main__":
    test_relations_and_functions()
```

## 2. 数论基础

### 2.1 整除与同余

#### 2.1.1 整除的定义

设 $a, b \in \mathbb{Z}$，如果存在 $c \in \mathbb{Z}$ 使得 $a = bc$，则称 $b$ 整除 $a$，记作 $b \mid a$。

#### 2.1.2 Python实现

```python
class NumberTheory:
    """数论基础"""
    
    def __init__(self):
        pass
    
    def divides(self, a: int, b: int) -> bool:
        """判断 b 是否整除 a"""
        if b == 0:
            return False
        return a % b == 0
    
    def gcd(self, a: int, b: int) -> int:
        """最大公约数 - 欧几里得算法"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    def lcm(self, a: int, b: int) -> int:
        """最小公倍数"""
        return abs(a * b) // self.gcd(a, b)
    
    def extended_gcd(self, a: int, b: int) -> tuple:
        """扩展欧几里得算法"""
        if b == 0:
            return a, 1, 0
        
        gcd, x1, y1 = self.extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        
        return gcd, x, y
    
    def mod_inverse(self, a: int, m: int) -> Optional[int]:
        """模逆元"""
        gcd, x, y = self.extended_gcd(a, m)
        if gcd != 1:
            return None
        return (x % m + m) % m
    
    def is_prime(self, n: int) -> bool:
        """判断是否为素数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    def prime_factors(self, n: int) -> Dict[int, int]:
        """质因数分解"""
        factors = {}
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors[d] = factors.get(d, 0) + 1
                n //= d
            d += 1
        
        if n > 1:
            factors[n] = factors.get(n, 0) + 1
        
        return factors
    
    def euler_totient(self, n: int) -> int:
        """欧拉函数 φ(n)"""
        if n == 1:
            return 1
        
        factors = self.prime_factors(n)
        result = n
        
        for prime in factors:
            result *= (1 - 1 / prime)
        
        return int(result)
    
    def chinese_remainder_theorem(self, remainders: List[int], moduli: List[int]) -> Optional[int]:
        """中国剩余定理"""
        if len(remainders) != len(moduli):
            return None
        
        # 检查模数两两互质
        for i in range(len(moduli)):
            for j in range(i + 1, len(moduli)):
                if self.gcd(moduli[i], moduli[j]) != 1:
                    return None
        
        # 计算解
        M = 1
        for m in moduli:
            M *= m
        
        result = 0
        for i in range(len(remainders)):
            Mi = M // moduli[i]
            Mi_inv = self.mod_inverse(Mi, moduli[i])
            if Mi_inv is None:
                return None
            result = (result + remainders[i] * Mi * Mi_inv) % M
        
        return result

# 使用示例
def test_number_theory():
    """测试数论"""
    nt = NumberTheory()
    
    print(f"gcd(48, 18) = {nt.gcd(48, 18)}")
    print(f"lcm(12, 18) = {nt.lcm(12, 18)}")
    print(f"17 是否为素数: {nt.is_prime(17)}")
    print(f"100 的质因数分解: {nt.prime_factors(100)}")
    print(f"φ(12) = {nt.euler_totient(12)}")
    
    # 中国剩余定理
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]
    result = nt.chinese_remainder_theorem(remainders, moduli)
    print(f"中国剩余定理解: x ≡ {result} (mod 105)")

if __name__ == "__main__":
    test_number_theory()
```

### 2.2 同余理论

#### 2.2.1 同余的定义

设 $a, b, m \in \mathbb{Z}$，如果 $m \mid (a - b)$，则称 $a$ 与 $b$ 模 $m$ 同余，记作 $a \equiv b \pmod{m}$。

#### 2.2.2 Python实现

```python
class CongruenceTheory:
    """同余理论"""
    
    def __init__(self):
        self.nt = NumberTheory()
    
    def is_congruent(self, a: int, b: int, m: int) -> bool:
        """判断 a ≡ b (mod m)"""
        return (a - b) % m == 0
    
    def solve_linear_congruence(self, a: int, b: int, m: int) -> List[int]:
        """解线性同余方程 ax ≡ b (mod m)"""
        gcd, x, y = self.nt.extended_gcd(a, m)
        
        if b % gcd != 0:
            return []  # 无解
        
        x0 = (x * (b // gcd)) % m
        solutions = []
        
        for k in range(gcd):
            solution = (x0 + k * (m // gcd)) % m
            solutions.append(solution)
        
        return sorted(solutions)
    
    def solve_system_congruences(self, coefficients: List[int], 
                                remainders: List[int], 
                                moduli: List[int]) -> Optional[int]:
        """解同余方程组"""
        if len(coefficients) != len(remainders) or len(remainders) != len(moduli):
            return None
        
        # 转换为标准形式
        for i in range(len(coefficients)):
            if coefficients[i] != 1:
                # 求解 ax ≡ b (mod m)
                solutions = self.solve_linear_congruence(coefficients[i], remainders[i], moduli[i])
                if not solutions:
                    return None
                remainders[i] = solutions[0]
        
        # 使用中国剩余定理
        return self.nt.chinese_remainder_theorem(remainders, moduli)
    
    def quadratic_residue(self, a: int, p: int) -> bool:
        """判断 a 是否为模 p 的二次剩余"""
        if not self.nt.is_prime(p) or p == 2:
            return True
        
        return pow(a, (p - 1) // 2, p) == 1
    
    def legendre_symbol(self, a: int, p: int) -> int:
        """勒让德符号"""
        if not self.nt.is_prime(p):
            return 0
        
        if a % p == 0:
            return 0
        
        if self.quadratic_residue(a, p):
            return 1
        else:
            return -1

# 使用示例
def test_congruence_theory():
    """测试同余理论"""
    ct = CongruenceTheory()
    
    print(f"7 ≡ 2 (mod 5): {ct.is_congruent(7, 2, 5)}")
    
    # 解线性同余方程
    solutions = ct.solve_linear_congruence(3, 2, 7)
    print(f"3x ≡ 2 (mod 7) 的解: {solutions}")
    
    # 解同余方程组
    coefficients = [1, 1, 1]
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]
    result = ct.solve_system_congruences(coefficients, remainders, moduli)
    print(f"同余方程组的解: x ≡ {result} (mod 105)")
    
    # 二次剩余
    print(f"3 是否为模 7 的二次剩余: {ct.quadratic_residue(3, 7)}")
    print(f"勒让德符号 (3/7) = {ct.legendre_symbol(3, 7)}")

if __name__ == "__main__":
    test_congruence_theory()
```

## 3. 代数基础

### 3.1 群论

#### 3.1.1 群的定义

**群** (Group) 是一个集合 $G$ 和一个二元运算 $\cdot$，满足：

1. 封闭性: $\forall a, b \in G, a \cdot b \in G$
2. 结合律: $\forall a, b, c \in G, (a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. 单位元: $\exists e \in G, \forall a \in G, e \cdot a = a \cdot e = a$
4. 逆元: $\forall a \in G, \exists a^{-1} \in G, a \cdot a^{-1} = a^{-1} \cdot a = e$

#### 3.1.2 Python实现

```python
class Group:
    """群类"""
    
    def __init__(self, elements: Set[Any], operation: callable, identity: Any):
        self.elements = elements
        self.operation = operation
        self.identity = identity
        self.inverses: Dict[Any, Any] = {}
    
    def is_closed(self) -> bool:
        """检查封闭性"""
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) not in self.elements:
                    return False
        return True
    
    def is_associative(self) -> bool:
        """检查结合律"""
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    left = self.operation(self.operation(a, b), c)
                    right = self.operation(a, self.operation(b, c))
                    if left != right:
                        return False
        return True
    
    def has_identity(self) -> bool:
        """检查是否有单位元"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if (self.operation(e, a) != a or 
                    self.operation(a, e) != a):
                    is_identity = False
                    break
            if is_identity:
                return True
        return False
    
    def has_inverses(self) -> bool:
        """检查是否有逆元"""
        for a in self.elements:
            has_inverse = False
            for b in self.elements:
                if (self.operation(a, b) == self.identity and 
                    self.operation(b, a) == self.identity):
                    self.inverses[a] = b
                    has_inverse = True
                    break
            if not has_inverse:
                return False
        return True
    
    def is_group(self) -> bool:
        """检查是否为群"""
        return (self.is_closed() and 
                self.is_associative() and 
                self.has_identity() and 
                self.has_inverses())
    
    def order(self) -> int:
        """群的阶"""
        return len(self.elements)
    
    def is_abelian(self) -> bool:
        """检查是否为阿贝尔群"""
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) != self.operation(b, a):
                    return False
        return True
    
    def subgroup(self, subset: Set[Any]) -> Optional['Group']:
        """子群"""
        if not subset.issubset(self.elements):
            return None
        
        subgroup = Group(subset, self.operation, self.identity)
        if subgroup.is_group():
            return subgroup
        return None

class CyclicGroup(Group):
    """循环群"""
    
    def __init__(self, n: int):
        self.n = n
        elements = set(range(n))
        
        def addition_mod_n(a: int, b: int) -> int:
            return (a + b) % n
        
        super().__init__(elements, addition_mod_n, 0)
    
    def generator(self) -> int:
        """生成元"""
        for g in range(1, self.n):
            if self.nt.gcd(g, self.n) == 1:
                return g
        return 1
    
    def is_cyclic(self) -> bool:
        """检查是否为循环群"""
        return True  # 循环群总是循环的

# 使用示例
def test_group_theory():
    """测试群论"""
    # 测试循环群
    cyclic_group = CyclicGroup(6)
    print(f"循环群 Z6 是否为群: {cyclic_group.is_group()}")
    print(f"循环群 Z6 的阶: {cyclic_group.order()}")
    print(f"循环群 Z6 是否为阿贝尔群: {cyclic_group.is_abelian()}")
    print(f"循环群 Z6 的生成元: {cyclic_group.generator()}")
    
    # 测试子群
    subgroup_elements = {0, 2, 4}
    subgroup = cyclic_group.subgroup(subgroup_elements)
    if subgroup:
        print(f"子群 {subgroup_elements} 的阶: {subgroup.order()}")

if __name__ == "__main__":
    test_group_theory()
```

### 3.2 环与域

#### 3.2.1 环的定义

**环** (Ring) 是一个集合 $R$ 和两个二元运算 $+$ 和 $\cdot$，满足：

1. $(R, +)$ 是阿贝尔群
2. $(R, \cdot)$ 是半群
3. 分配律: $\forall a, b, c \in R, a \cdot (b + c) = a \cdot b + a \cdot c$

#### 3.2.2 Python实现

```python
class Ring:
    """环类"""
    
    def __init__(self, elements: Set[Any], addition: callable, 
                 multiplication: callable, zero: Any, one: Any):
        self.elements = elements
        self.addition = addition
        self.multiplication = multiplication
        self.zero = zero
        self.one = one
    
    def is_ring(self) -> bool:
        """检查是否为环"""
        # 检查加法群
        addition_group = Group(self.elements, self.addition, self.zero)
        if not addition_group.is_group() or not addition_group.is_abelian():
            return False
        
        # 检查乘法半群
        for a in self.elements:
            for b in self.elements:
                if self.multiplication(a, b) not in self.elements:
                    return False
        
        # 检查分配律
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    left = self.multiplication(a, self.addition(b, c))
                    right = self.addition(self.multiplication(a, b), 
                                        self.multiplication(a, c))
                    if left != right:
                        return False
        
        return True
    
    def is_field(self) -> bool:
        """检查是否为域"""
        if not self.is_ring():
            return False
        
        # 检查乘法群（除零元素外）
        non_zero = self.elements - {self.zero}
        if not non_zero:
            return False
        
        multiplication_group = Group(non_zero, self.multiplication, self.one)
        return multiplication_group.is_group()

class FiniteField(Ring):
    """有限域"""
    
    def __init__(self, p: int):
        self.p = p
        elements = set(range(p))
        
        def addition_mod_p(a: int, b: int) -> int:
            return (a + b) % p
        
        def multiplication_mod_p(a: int, b: int) -> int:
            return (a * b) % p
        
        super().__init__(elements, addition_mod_p, multiplication_mod_p, 0, 1)
    
    def is_prime_field(self) -> bool:
        """检查是否为素域"""
        nt = NumberTheory()
        return nt.is_prime(self.p)
    
    def primitive_element(self) -> Optional[int]:
        """本原元"""
        if not self.is_prime_field():
            return None
        
        for g in range(1, self.p):
            if self._is_primitive(g):
                return g
        return None
    
    def _is_primitive(self, g: int) -> bool:
        """检查 g 是否为本原元"""
        powers = set()
        current = 1
        
        for _ in range(self.p - 1):
            current = (current * g) % self.p
            if current in powers:
                return False
            powers.add(current)
        
        return len(powers) == self.p - 1

# 使用示例
def test_ring_and_field():
    """测试环与域"""
    # 测试有限域
    field = FiniteField(7)
    print(f"有限域 F7 是否为环: {field.is_ring()}")
    print(f"有限域 F7 是否为域: {field.is_field()}")
    print(f"有限域 F7 是否为素域: {field.is_prime_field()}")
    print(f"有限域 F7 的本原元: {field.primitive_element()}")

if __name__ == "__main__":
    test_ring_and_field()
```

## 4. 总结

数学基础为软件工程提供了坚实的理论基础，包括：

1. **集合论**: 为数据结构提供基础
2. **数论**: 为密码学和算法提供支撑
3. **代数**: 为抽象代数和形式化方法提供基础

这些数学工具相互关联，共同构成了现代计算科学的数学基础，为后续的理论基础层提供了严格的数学支撑。

## 相关链接

- [00-01-编程哲学](../00-理念基础/00-01-编程哲学.md)
- [00-02-形式化思维](../00-理念基础/00-02-形式化思维.md)
- [01-02-逻辑学](./01-02-逻辑学.md)
- [01-03-集合论](./01-03-集合论.md)
- [02-01-算法理论](../02-理论基础/02-01-算法理论.md)
