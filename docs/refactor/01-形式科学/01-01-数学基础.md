# 01-01 æ•°å­¦åŸºç¡€ (Mathematical Foundation)

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. é›†åˆè®ºåŸºç¡€](#1-é›†åˆè®ºåŸºç¡€)
- [2. é€»è¾‘å­¦åŸºç¡€](#2-é€»è¾‘å­¦åŸºç¡€)
- [3. ä»£æ•°ç»“æ„](#3-ä»£æ•°ç»“æ„)
- [4. å‡½æ•°ä¸å…³ç³»](#4-å‡½æ•°ä¸å…³ç³»)
- [5. æ•°è®ºåŸºç¡€](#5-æ•°è®ºåŸºç¡€)
- [6. å½¢å¼åŒ–è¡¨ç¤º](#6-å½¢å¼åŒ–è¡¨ç¤º)
- [7. Pythonå®ç°](#7-pythonå®ç°)
- [8. å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## æ¦‚è¿°

æ•°å­¦åŸºç¡€æ˜¯è®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹çš„ç†è®ºåŸºçŸ³ã€‚æœ¬æ–‡æ¡£æ¶µç›–é›†åˆè®ºã€é€»è¾‘å­¦ã€ä»£æ•°ç»“æ„ç­‰æ ¸å¿ƒæ•°å­¦æ¦‚å¿µï¼Œä¸ºåç»­çš„ç®—æ³•ç†è®ºã€æ•°æ®ç»“æ„ç­‰æä¾›æ•°å­¦æ”¯æ’‘ã€‚

## 1. é›†åˆè®ºåŸºç¡€

### 1.1 é›†åˆçš„å®šä¹‰

é›†åˆæ˜¯ä¸åŒå¯¹è±¡çš„æ— åºèšé›†ï¼Œå¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$A = \{x \mid P(x)\}$$

å…¶ä¸­ $P(x)$ æ˜¯è°“è¯ï¼Œè¡¨ç¤ºå…ƒç´  $x$ æ»¡è¶³çš„æ€§è´¨ã€‚

### 1.2 é›†åˆè¿ç®—

**å¹¶é›†**: $A \cup B = \{x \mid x \in A \lor x \in B\}$

**äº¤é›†**: $A \cap B = \{x \mid x \in A \land x \in B\}$

**å·®é›†**: $A \setminus B = \{x \mid x \in A \land x \notin B\}$

**è¡¥é›†**: $A^c = \{x \mid x \notin A\}$

### 1.3 é›†åˆå…³ç³»

**åŒ…å«**: $A \subseteq B \iff \forall x(x \in A \rightarrow x \in B)$

**ç›¸ç­‰**: $A = B \iff A \subseteq B \land B \subseteq A$

**çœŸåŒ…å«**: $A \subset B \iff A \subseteq B \land A \neq B$

## 2. é€»è¾‘å­¦åŸºç¡€

### 2.1 å‘½é¢˜é€»è¾‘

**å‘½é¢˜**: å¯ä»¥åˆ¤æ–­çœŸå‡çš„é™ˆè¿°å¥ã€‚

**é€»è¾‘è¿ç®—ç¬¦**:
- å¦å®š: $\neg p$
- åˆå–: $p \land q$
- æå–: $p \lor q$
- è•´å«: $p \rightarrow q$
- ç­‰ä»·: $p \leftrightarrow q$

### 2.2 è°“è¯é€»è¾‘

**å…¨ç§°é‡è¯**: $\forall x P(x)$ - å¯¹æ‰€æœ‰ $x$ï¼Œ$P(x)$ æˆç«‹

**å­˜åœ¨é‡è¯**: $\exists x P(x)$ - å­˜åœ¨ $x$ï¼Œä½¿å¾— $P(x)$ æˆç«‹

### 2.3 é€»è¾‘ç­‰ä»·

**å¾·æ‘©æ ¹å¾‹**: 
- $\neg(p \land q) \equiv \neg p \lor \neg q$
- $\neg(p \lor q) \equiv \neg p \land \neg q$

**åˆ†é…å¾‹**:
- $p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$
- $p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$

## 3. ä»£æ•°ç»“æ„

### 3.1 ç¾¤è®º

**ç¾¤**: ä¸€ä¸ªé›†åˆ $G$ å’ŒäºŒå…ƒè¿ç®— $\cdot$ æ»¡è¶³ï¼š
1. å°é—­æ€§: $\forall a,b \in G: a \cdot b \in G$
2. ç»“åˆå¾‹: $\forall a,b,c \in G: (a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. å•ä½å…ƒ: $\exists e \in G: \forall a \in G: e \cdot a = a \cdot e = a$
4. é€†å…ƒ: $\forall a \in G: \exists a^{-1} \in G: a \cdot a^{-1} = a^{-1} \cdot a = e$

### 3.2 ç¯è®º

**ç¯**: ä¸€ä¸ªé›†åˆ $R$ å’Œä¸¤ä¸ªäºŒå…ƒè¿ç®— $+$ å’Œ $\cdot$ æ»¡è¶³ï¼š
1. $(R, +)$ æ˜¯é˜¿è´å°”ç¾¤
2. $(R, \cdot)$ æ˜¯åŠç¾¤
3. åˆ†é…å¾‹: $a \cdot (b + c) = a \cdot b + a \cdot c$

### 3.3 åŸŸè®º

**åŸŸ**: ä¸€ä¸ªç¯ $(F, +, \cdot)$ æ»¡è¶³ï¼š
1. $(F \setminus \{0\}, \cdot)$ æ˜¯é˜¿è´å°”ç¾¤
2. $0 \neq 1$

## 4. å‡½æ•°ä¸å…³ç³»

### 4.1 å‡½æ•°å®šä¹‰

**å‡½æ•°**: ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„å…³ç³» $f$ æ»¡è¶³ï¼š
$\forall a \in A: \exists! b \in B: (a,b) \in f$

è®°ä½œ: $f: A \rightarrow B$

### 4.2 å‡½æ•°æ€§è´¨

**å•å°„**: $\forall a_1, a_2 \in A: f(a_1) = f(a_2) \rightarrow a_1 = a_2$

**æ»¡å°„**: $\forall b \in B: \exists a \in A: f(a) = b$

**åŒå°„**: æ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„

### 4.3 å…³ç³»

**å…³ç³»**: é›†åˆ $A$ å’Œ $B$ çš„ç¬›å¡å°”ç§¯ $A \times B$ çš„å­é›†

**ç­‰ä»·å…³ç³»**: æ»¡è¶³è‡ªåæ€§ã€å¯¹ç§°æ€§ã€ä¼ é€’æ€§çš„å…³ç³»

## 5. æ•°è®ºåŸºç¡€

### 5.1 æ•´é™¤æ€§

**æ•´é™¤**: $a \mid b \iff \exists k \in \mathbb{Z}: b = ak$

**æœ€å¤§å…¬çº¦æ•°**: $\gcd(a,b) = \max\{d \in \mathbb{N} \mid d \mid a \land d \mid b\}$

**æœ€å°å…¬å€æ•°**: $\text{lcm}(a,b) = \min\{m \in \mathbb{N} \mid a \mid m \land b \mid m\}$

### 5.2 åŒä½™

**åŒä½™**: $a \equiv b \pmod{m} \iff m \mid (a - b)$

**æ¬§æ‹‰å‡½æ•°**: $\phi(n) = |\{k \in \mathbb{N} \mid 1 \leq k \leq n \land \gcd(k,n) = 1\}|$

## 6. å½¢å¼åŒ–è¡¨ç¤º

### 6.1 æ•°å­¦ç¬¦å·ç³»ç»Ÿ

$$\mathcal{M} = \langle \mathcal{S}, \mathcal{O}, \mathcal{R}, \mathcal{A} \rangle$$

å…¶ä¸­ï¼š
- $\mathcal{S}$ æ˜¯ç¬¦å·é›†åˆ
- $\mathcal{O}$ æ˜¯è¿ç®—ç¬¦é›†åˆ
- $\mathcal{R}$ æ˜¯å…³ç³»ç¬¦é›†åˆ
- $\mathcal{A}$ æ˜¯å…¬ç†é›†åˆ

### 6.2 è¯æ˜ç³»ç»Ÿ

**è‡ªç„¶æ¼”ç»**: åŸºäºæ¨ç†è§„åˆ™çš„è¯æ˜ç³»ç»Ÿ

**å…¬ç†åŒ–ç³»ç»Ÿ**: åŸºäºå…¬ç†å’Œæ¨ç†è§„åˆ™çš„è¯æ˜ç³»ç»Ÿ

## 7. Pythonå®ç°

### 7.1 é›†åˆè®ºå®ç°

```python
from typing import Set, List, Any, Callable, TypeVar, Generic
from abc import ABC, abstractmethod
import math

T = TypeVar('T')

class SetTheory:
    """é›†åˆè®ºå®ç°"""
    
    @staticmethod
    def union(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """å¹¶é›†è¿ç®—"""
        return set_a | set_b
    
    @staticmethod
    def intersection(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """äº¤é›†è¿ç®—"""
        return set_a & set_b
    
    @staticmethod
    def difference(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """å·®é›†è¿ç®—"""
        return set_a - set_b
    
    @staticmethod
    def complement(universal_set: Set[T], set_a: Set[T]) -> Set[T]:
        """è¡¥é›†è¿ç®—"""
        return universal_set - set_a
    
    @staticmethod
    def is_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """åˆ¤æ–­åŒ…å«å…³ç³»"""
        return set_a.issubset(set_b)
    
    @staticmethod
    def is_equal(set_a: Set[T], set_b: Set[T]) -> bool:
        """åˆ¤æ–­ç›¸ç­‰å…³ç³»"""
        return set_a == set_b
    
    @staticmethod
    def is_proper_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """åˆ¤æ–­çœŸåŒ…å«å…³ç³»"""
        return set_a.issubset(set_b) and set_a != set_b
    
    @staticmethod
    def power_set(set_a: Set[T]) -> Set[frozenset]:
        """å¹‚é›†"""
        elements = list(set_a)
        power_set = set()
        
        for i in range(2 ** len(elements)):
            subset = set()
            for j in range(len(elements)):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set
    
    @staticmethod
    def cartesian_product(set_a: Set[T], set_b: Set[T]) -> Set[tuple]:
        """ç¬›å¡å°”ç§¯"""
        return {(a, b) for a in set_a for b in set_b}

class Logic:
    """é€»è¾‘å­¦å®ç°"""
    
    @staticmethod
    def negation(p: bool) -> bool:
        """å¦å®š"""
        return not p
    
    @staticmethod
    def conjunction(p: bool, q: bool) -> bool:
        """åˆå–"""
        return p and q
    
    @staticmethod
    def disjunction(p: bool, q: bool) -> bool:
        """æå–"""
        return p or q
    
    @staticmethod
    def implication(p: bool, q: bool) -> bool:
        """è•´å«"""
        return not p or q
    
    @staticmethod
    def equivalence(p: bool, q: bool) -> bool:
        """ç­‰ä»·"""
        return p == q
    
    @staticmethod
    def exclusive_or(p: bool, q: bool) -> bool:
        """å¼‚æˆ–"""
        return p != q
    
    @staticmethod
    def truth_table(expression: Callable[[bool, bool], bool]) -> List[dict]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        table = []
        for p in [True, False]:
            for q in [True, False]:
                result = expression(p, q)
                table.append({
                    'p': p,
                    'q': q,
                    'result': result
                })
        return table
    
    @staticmethod
    def is_tautology(expression: Callable[[bool, bool], bool]) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºé‡è¨€å¼"""
        table = Logic.truth_table(expression)
        return all(row['result'] for row in table)
    
    @staticmethod
    def is_contradiction(expression: Callable[[bool, bool], bool]) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        table = Logic.truth_table(expression)
        return not any(row['result'] for row in table)

class AlgebraicStructure:
    """ä»£æ•°ç»“æ„å®ç°"""
    
    class Group:
        """ç¾¤"""
        
        def __init__(self, elements: Set, operation: Callable, identity: Any):
            self.elements = elements
            self.operation = operation
            self.identity = identity
        
        def is_closed(self) -> bool:
            """æ£€æŸ¥å°é—­æ€§"""
            for a in self.elements:
                for b in self.elements:
                    if self.operation(a, b) not in self.elements:
                        return False
            return True
        
        def is_associative(self) -> bool:
            """æ£€æŸ¥ç»“åˆå¾‹"""
            for a in self.elements:
                for b in self.elements:
                    for c in self.elements:
                        left = self.operation(self.operation(a, b), c)
                        right = self.operation(a, self.operation(b, c))
                        if left != right:
                            return False
            return True
        
        def has_identity(self) -> bool:
            """æ£€æŸ¥å•ä½å…ƒ"""
            return self.identity in self.elements
        
        def has_inverses(self) -> bool:
            """æ£€æŸ¥é€†å…ƒ"""
            for a in self.elements:
                has_inverse = False
                for b in self.elements:
                    if (self.operation(a, b) == self.identity and 
                        self.operation(b, a) == self.identity):
                        has_inverse = True
                        break
                if not has_inverse:
                    return False
            return True
        
        def is_group(self) -> bool:
            """åˆ¤æ–­æ˜¯å¦ä¸ºç¾¤"""
            return (self.is_closed() and 
                    self.is_associative() and 
                    self.has_identity() and 
                    self.has_inverses())
    
    class Ring:
        """ç¯"""
        
        def __init__(self, elements: Set, addition: Callable, 
                     multiplication: Callable, zero: Any, one: Any):
            self.elements = elements
            self.addition = addition
            self.multiplication = multiplication
            self.zero = zero
            self.one = one
        
        def is_ring(self) -> bool:
            """åˆ¤æ–­æ˜¯å¦ä¸ºç¯"""
            # æ£€æŸ¥åŠ æ³•ç¾¤
            addition_group = self.Group(self.elements, self.addition, self.zero)
            if not addition_group.is_group():
                return False
            
            # æ£€æŸ¥ä¹˜æ³•åŠç¾¤
            if not self._is_multiplication_semigroup():
                return False
            
            # æ£€æŸ¥åˆ†é…å¾‹
            return self._satisfies_distributivity()
        
        def _is_multiplication_semigroup(self) -> bool:
            """æ£€æŸ¥ä¹˜æ³•åŠç¾¤"""
            # å°é—­æ€§
            for a in self.elements:
                for b in self.elements:
                    if self.multiplication(a, b) not in self.elements:
                        return False
            
            # ç»“åˆå¾‹
            for a in self.elements:
                for b in self.elements:
                    for c in self.elements:
                        left = self.multiplication(self.multiplication(a, b), c)
                        right = self.multiplication(a, self.multiplication(b, c))
                        if left != right:
                            return False
            
            return True
        
        def _satisfies_distributivity(self) -> bool:
            """æ£€æŸ¥åˆ†é…å¾‹"""
            for a in self.elements:
                for b in self.elements:
                    for c in self.elements:
                        # å·¦åˆ†é…å¾‹
                        left_dist = self.multiplication(a, self.addition(b, c))
                        right_dist = self.addition(
                            self.multiplication(a, b),
                            self.multiplication(a, c)
                        )
                        if left_dist != right_dist:
                            return False
            return True

class NumberTheory:
    """æ•°è®ºå®ç°"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """æœ€å¤§å…¬çº¦æ•° - æ¬§å‡ é‡Œå¾—ç®—æ³•"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """æœ€å°å…¬å€æ•°"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """åˆ¤æ–­ç´ æ•°"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def prime_factors(n: int) -> List[int]:
        """è´¨å› æ•°åˆ†è§£"""
        factors = []
        d = 2
        
        while n > 1:
            while n % d == 0:
                factors.append(d)
                n //= d
            d += 1
            if d * d > n:
                if n > 1:
                    factors.append(n)
                break
        
        return factors
    
    @staticmethod
    def euler_phi(n: int) -> int:
        """æ¬§æ‹‰å‡½æ•°"""
        if n == 1:
            return 1
        
        result = n
        for p in set(NumberTheory.prime_factors(n)):
            result *= (1 - 1/p)
        
        return int(result)
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> tuple:
        """æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•"""
        if a == 0:
            return b, 0, 1
        
        gcd, x1, y1 = NumberTheory.extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        
        return gcd, x, y
    
    @staticmethod
    def mod_inverse(a: int, m: int) -> int:
        """æ¨¡é€†å…ƒ"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            raise ValueError("æ¨¡é€†å…ƒä¸å­˜åœ¨")
        
        return (x % m + m) % m
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> int:
        """ä¸­å›½å‰©ä½™å®šç†"""
        if len(remainders) != len(moduli):
            raise ValueError("ä½™æ•°å’Œæ¨¡æ•°æ•°é‡ä¸åŒ¹é…")
        
        n = len(remainders)
        product = 1
        for m in moduli:
            product *= m
        
        result = 0
        for i in range(n):
            pi = product // moduli[i]
            result += remainders[i] * pi * NumberTheory.mod_inverse(pi, moduli[i])
        
        return result % product

class FunctionTheory:
    """å‡½æ•°è®ºå®ç°"""
    
    @staticmethod
    def is_injective(domain: Set, codomain: Set, func: Callable) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå•å°„"""
        image = set()
        for x in domain:
            y = func(x)
            if y in image:
                return False
            image.add(y)
        return True
    
    @staticmethod
    def is_surjective(domain: Set, codomain: Set, func: Callable) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡å°„"""
        image = set()
        for x in domain:
            image.add(func(x))
        return image == codomain
    
    @staticmethod
    def is_bijective(domain: Set, codomain: Set, func: Callable) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºåŒå°„"""
        return (FunctionTheory.is_injective(domain, codomain, func) and
                FunctionTheory.is_surjective(domain, codomain, func))
    
    @staticmethod
    def composition(f: Callable, g: Callable) -> Callable:
        """å‡½æ•°å¤åˆ"""
        return lambda x: f(g(x))
    
    @staticmethod
    def inverse_function(domain: Set, codomain: Set, func: Callable) -> Callable:
        """é€†å‡½æ•°"""
        if not FunctionTheory.is_bijective(domain, codomain, func):
            raise ValueError("å‡½æ•°ä¸æ˜¯åŒå°„ï¼Œæ— æ³•æ±‚é€†")
        
        # æ„å»ºé€†æ˜ å°„
        inverse_map = {}
        for x in domain:
            y = func(x)
            inverse_map[y] = x
        
        return lambda y: inverse_map[y]

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_mathematical_foundations():
    """æ¼”ç¤ºæ•°å­¦åŸºç¡€æ¦‚å¿µ"""
    
    print("=== é›†åˆè®ºæ¼”ç¤º ===\n")
    
    # é›†åˆè¿ç®—
    A = {1, 2, 3, 4}
    B = {3, 4, 5, 6}
    
    print(f"é›†åˆ A: {A}")
    print(f"é›†åˆ B: {B}")
    print(f"å¹¶é›† A âˆª B: {SetTheory.union(A, B)}")
    print(f"äº¤é›† A âˆ© B: {SetTheory.intersection(A, B)}")
    print(f"å·®é›† A - B: {SetTheory.difference(A, B)}")
    print(f"A æ˜¯ B çš„å­é›†: {SetTheory.is_subset(A, B)}")
    print(f"A ç­‰äº B: {SetTheory.is_equal(A, B)}")
    
    # å¹‚é›†
    small_set = {1, 2}
    power_set = SetTheory.power_set(small_set)
    print(f"\n{small_set} çš„å¹‚é›†: {power_set}")
    
    print("\n=== é€»è¾‘å­¦æ¼”ç¤º ===\n")
    
    # çœŸå€¼è¡¨
    def implication_example(p: bool, q: bool) -> bool:
        return Logic.implication(p, q)
    
    truth_table = Logic.truth_table(implication_example)
    print("è•´å«è¿ç®—çœŸå€¼è¡¨:")
    for row in truth_table:
        print(f"  p={row['p']}, q={row['q']}, pâ†’q={row['result']}")
    
    # é‡è¨€å¼æ£€æŸ¥
    def tautology_example(p: bool, q: bool) -> bool:
        return Logic.implication(p, Logic.implication(q, p))
    
    print(f"\n(pâ†’(qâ†’p)) æ˜¯é‡è¨€å¼: {Logic.is_tautology(tautology_example)}")
    
    print("\n=== ä»£æ•°ç»“æ„æ¼”ç¤º ===\n")
    
    # ç¾¤ç¤ºä¾‹ï¼šæ¨¡5åŠ æ³•ç¾¤
    Z5 = {0, 1, 2, 3, 4}
    
    def addition_mod5(a: int, b: int) -> int:
        return (a + b) % 5
    
    group = AlgebraicStructure.Group(Z5, addition_mod5, 0)
    print(f"æ¨¡5åŠ æ³•ç¾¤æ˜¯ç¾¤: {group.is_group()}")
    
    # ç¯ç¤ºä¾‹ï¼šæ¨¡6ç¯
    Z6 = {0, 1, 2, 3, 4, 5}
    
    def multiplication_mod6(a: int, b: int) -> int:
        return (a * b) % 6
    
    ring = AlgebraicStructure.Ring(Z6, addition_mod5, multiplication_mod6, 0, 1)
    print(f"æ¨¡6ç¯æ˜¯ç¯: {ring.is_ring()}")
    
    print("\n=== æ•°è®ºæ¼”ç¤º ===\n")
    
    # åŸºæœ¬æ•°è®ºå‡½æ•°
    a, b = 48, 18
    print(f"gcd({a}, {b}) = {NumberTheory.gcd(a, b)}")
    print(f"lcm({a}, {b}) = {NumberTheory.lcm(a, b)}")
    print(f"{a} çš„è´¨å› æ•°: {NumberTheory.prime_factors(a)}")
    print(f"Ï†({a}) = {NumberTheory.euler_phi(a)}")
    
    # æ¨¡é€†å…ƒ
    try:
        inv = NumberTheory.mod_inverse(3, 7)
        print(f"3 åœ¨æ¨¡7ä¸‹çš„é€†å…ƒ: {inv}")
    except ValueError as e:
        print(f"é”™è¯¯: {e}")
    
    # ä¸­å›½å‰©ä½™å®šç†
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]
    result = NumberTheory.chinese_remainder_theorem(remainders, moduli)
    print(f"ä¸­å›½å‰©ä½™å®šç†: x â‰¡ {remainders} (mod {moduli}) => x = {result}")
    
    print("\n=== å‡½æ•°è®ºæ¼”ç¤º ===\n")
    
    # å‡½æ•°æ€§è´¨
    domain = {1, 2, 3}
    codomain = {2, 4, 6}
    
    def square(x: int) -> int:
        return x * 2
    
    print(f"å‡½æ•° f(x) = 2x åœ¨ç»™å®šåŸŸä¸Š:")
    print(f"  æ˜¯å•å°„: {FunctionTheory.is_injective(domain, codomain, square)}")
    print(f"  æ˜¯æ»¡å°„: {FunctionTheory.is_surjective(domain, codomain, square)}")
    print(f"  æ˜¯åŒå°„: {FunctionTheory.is_bijective(domain, codomain, square)}")

if __name__ == "__main__":
    demonstrate_mathematical_foundations()
```

### 7.2 é«˜çº§æ•°å­¦å·¥å…·

```python
import numpy as np
from typing import List, Tuple, Optional
import matplotlib.pyplot as plt

class AdvancedMathematics:
    """é«˜çº§æ•°å­¦å·¥å…·"""
    
    @staticmethod
    def matrix_operations():
        """çŸ©é˜µè¿ç®—"""
        # åˆ›å»ºçŸ©é˜µ
        A = np.array([[1, 2], [3, 4]])
        B = np.array([[5, 6], [7, 8]])
        
        print("çŸ©é˜µè¿ç®—:")
        print(f"A = \n{A}")
        print(f"B = \n{B}")
        print(f"A + B = \n{A + B}")
        print(f"A * B = \n{A @ B}")
        print(f"det(A) = {np.linalg.det(A)}")
        print(f"A^(-1) = \n{np.linalg.inv(A)}")
    
    @staticmethod
    def polynomial_arithmetic():
        """å¤šé¡¹å¼ç®—æœ¯"""
        # å¤šé¡¹å¼ç³»æ•°
        p1 = [1, 2, 3]  # x^2 + 2x + 3
        p2 = [1, 1]     # x + 1
        
        # å¤šé¡¹å¼ä¹˜æ³•
        product = np.polymul(p1, p2)
        print(f"å¤šé¡¹å¼ä¹˜æ³•: {p1} * {p2} = {product}")
        
        # å¤šé¡¹å¼é™¤æ³•
        quotient, remainder = np.polydiv(p1, p2)
        print(f"å¤šé¡¹å¼é™¤æ³•: {p1} / {p2} = å•†: {quotient}, ä½™æ•°: {remainder}")
    
    @staticmethod
    def linear_algebra():
        """çº¿æ€§ä»£æ•°"""
        # ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡
        A = np.array([[4, -2], [-2, 4]])
        eigenvalues, eigenvectors = np.linalg.eig(A)
        
        print("çº¿æ€§ä»£æ•°:")
        print(f"çŸ©é˜µ A = \n{A}")
        print(f"ç‰¹å¾å€¼: {eigenvalues}")
        print(f"ç‰¹å¾å‘é‡: \n{eigenvectors}")
        
        # å¥‡å¼‚å€¼åˆ†è§£
        U, s, Vt = np.linalg.svd(A)
        print(f"SVD: A = U @ diag(s) @ Vt")
        print(f"å¥‡å¼‚å€¼: {s}")
    
    @staticmethod
    def calculus_approximations():
        """å¾®ç§¯åˆ†è¿‘ä¼¼"""
        def f(x):
            return x**2 + 2*x + 1
        
        # æ•°å€¼ç§¯åˆ†
        x = np.linspace(0, 5, 1000)
        y = f(x)
        integral = np.trapz(y, x)
        print(f"æ•°å€¼ç§¯åˆ† âˆ«(xÂ²+2x+1)dx from 0 to 5 â‰ˆ {integral}")
        
        # æ•°å€¼å¾®åˆ†
        dx = x[1] - x[0]
        derivative = np.gradient(y, dx)
        print(f"æ•°å€¼å¾®åˆ†åœ¨ x=2: {derivative[400]:.2f}")  # x=2 å¯¹åº”çš„ç´¢å¼•
    
    @staticmethod
    def probability_theory():
        """æ¦‚ç‡è®º"""
        # éšæœºæ•°ç”Ÿæˆ
        np.random.seed(42)
        samples = np.random.normal(0, 1, 1000)
        
        print("æ¦‚ç‡è®º:")
        print(f"æ­£æ€åˆ†å¸ƒæ ·æœ¬å‡å€¼: {np.mean(samples):.4f}")
        print(f"æ­£æ€åˆ†å¸ƒæ ·æœ¬æ–¹å·®: {np.var(samples):.4f}")
        
        # æ¦‚ç‡åˆ†å¸ƒ
        from scipy import stats
        x = np.linspace(-4, 4, 100)
        pdf = stats.norm.pdf(x, 0, 1)
        cdf = stats.norm.cdf(x, 0, 1)
        
        print(f"æ ‡å‡†æ­£æ€åˆ†å¸ƒ P(X < 1.96) = {stats.norm.cdf(1.96):.4f}")

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_advanced_mathematics():
    """æ¼”ç¤ºé«˜çº§æ•°å­¦å·¥å…·"""
    
    print("=== é«˜çº§æ•°å­¦å·¥å…·æ¼”ç¤º ===\n")
    
    # çŸ©é˜µè¿ç®—
    AdvancedMathematics.matrix_operations()
    
    print("\n" + "="*50 + "\n")
    
    # å¤šé¡¹å¼ç®—æœ¯
    AdvancedMathematics.polynomial_arithmetic()
    
    print("\n" + "="*50 + "\n")
    
    # çº¿æ€§ä»£æ•°
    AdvancedMathematics.linear_algebra()
    
    print("\n" + "="*50 + "\n")
    
    # å¾®ç§¯åˆ†è¿‘ä¼¼
    AdvancedMathematics.calculus_approximations()
    
    print("\n" + "="*50 + "\n")
    
    # æ¦‚ç‡è®º
    AdvancedMathematics.probability_theory()

if __name__ == "__main__":
    demonstrate_advanced_mathematics()
```

## 8. å‚è€ƒæ–‡çŒ®

1. Halmos, P. R. (1974). "Naive Set Theory".
2. Enderton, H. B. (1977). "Elements of Set Theory".
3. Mendelson, E. (2015). "Introduction to Mathematical Logic".
4. Hungerford, T. W. (1974). "Algebra".
5. Hardy, G. H., & Wright, E. M. (1979). "An Introduction to the Theory of Numbers".

---

**ç›¸å…³æ–‡æ¡£**:
- [01-02-é€»è¾‘å­¦](./01-02-é€»è¾‘å­¦.md)
- [01-03-é›†åˆè®º](./01-03-é›†åˆè®º.md)
- [02-01-ç®—æ³•ç†è®º](./../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º.md)

**æœ€åæ›´æ–°**: 2024-01-XX  
**ç‰ˆæœ¬**: 1.0.0 