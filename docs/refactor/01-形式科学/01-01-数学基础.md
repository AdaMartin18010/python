# 01-01 数学基础

## 概述

数学是计算机科学和编程的理论基础。本章将介绍编程中常用的数学概念，包括集合论、数论、代数、组合数学等，并通过Python实现来展示这些概念的应用。

## 1. 集合论基础

### 1.1 基本概念

**定义 1.1.1 (集合)**  
集合是不同对象的无序聚集。

$$\text{Set} = \{x \mid P(x)\}$$

其中 $P(x)$ 是描述集合元素性质的谓词。

**定义 1.1.2 (集合运算)**  
- 并集：$A \cup B = \{x \mid x \in A \lor x \in B\}$
- 交集：$A \cap B = \{x \mid x \in A \land x \in B\}$
- 差集：$A \setminus B = \{x \mid x \in A \land x \notin B\}$
- 补集：$A^c = \{x \mid x \notin A\}$

### 1.2 Python 实现

```python
from typing import Set, TypeVar, Generic, Iterator, Any
from abc import ABC, abstractmethod
import math

T = TypeVar('T')

class SetTheory:
    """集合论实现"""
    
    @staticmethod
    def union(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """集合并集"""
        return set_a | set_b
    
    @staticmethod
    def intersection(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """集合交集"""
        return set_a & set_b
    
    @staticmethod
    def difference(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """集合差集"""
        return set_a - set_b
    
    @staticmethod
    def symmetric_difference(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """集合对称差"""
        return set_a ^ set_b
    
    @staticmethod
    def is_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断是否为子集"""
        return set_a.issubset(set_b)
    
    @staticmethod
    def is_superset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断是否为超集"""
        return set_a.issuperset(set_b)
    
    @staticmethod
    def power_set(original_set: Set[T]) -> Set[frozenset]:
        """幂集"""
        elements = list(original_set)
        n = len(elements)
        power_set = set()
        
        # 使用二进制表示生成所有子集
        for i in range(2**n):
            subset = set()
            for j in range(n):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set
    
    @staticmethod
    def cartesian_product(set_a: Set[T], set_b: Set[T]) -> Set[tuple]:
        """笛卡尔积"""
        return {(a, b) for a in set_a for b in set_b}

class MathematicalSet(Generic[T]):
    """数学集合类"""
    
    def __init__(self, elements: Set[T]):
        self.elements = elements
    
    def __contains__(self, item: T) -> bool:
        return item in self.elements
    
    def __len__(self) -> int:
        return len(self.elements)
    
    def __iter__(self) -> Iterator[T]:
        return iter(self.elements)
    
    def __str__(self) -> str:
        return f"{{{', '.join(map(str, self.elements))}}}"
    
    def union(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """并集"""
        return MathematicalSet(self.elements | other.elements)
    
    def intersection(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """交集"""
        return MathematicalSet(self.elements & other.elements)
    
    def difference(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """差集"""
        return MathematicalSet(self.elements - other.elements)
    
    def is_subset(self, other: 'MathematicalSet[T]') -> bool:
        """子集判断"""
        return self.elements.issubset(other.elements)
    
    def cardinality(self) -> int:
        """基数"""
        return len(self.elements)

# 使用示例
def demonstrate_set_theory():
    """演示集合论"""
    print("=== 集合论演示 ===")
    
    # 创建集合
    A = {1, 2, 3, 4, 5}
    B = {4, 5, 6, 7, 8}
    
    print(f"集合 A = {A}")
    print(f"集合 B = {B}")
    
    # 基本运算
    print(f"A ∪ B = {SetTheory.union(A, B)}")
    print(f"A ∩ B = {SetTheory.intersection(A, B)}")
    print(f"A - B = {SetTheory.difference(A, B)}")
    print(f"A △ B = {SetTheory.symmetric_difference(A, B)}")
    
    # 子集关系
    C = {1, 2}
    print(f"C ⊆ A: {SetTheory.is_subset(C, A)}")
    print(f"A ⊇ C: {SetTheory.is_superset(A, C)}")
    
    # 幂集
    power_set = SetTheory.power_set(C)
    print(f"P(C) = {power_set}")
    
    # 笛卡尔积
    cartesian = SetTheory.cartesian_product(C, {3, 4})
    print(f"C × {3, 4} = {cartesian}")
    
    # 使用数学集合类
    math_set_a = MathematicalSet(A)
    math_set_b = MathematicalSet(B)
    
    print(f"数学集合 A = {math_set_a}")
    print(f"数学集合 B = {math_set_b}")
    print(f"A ∪ B = {math_set_a.union(math_set_b)}")
    print(f"A ∩ B = {math_set_a.intersection(math_set_b)}")
    print(f"|A| = {math_set_a.cardinality()}")
    
    return A, B, C
```

## 2. 数论基础

### 2.1 基本概念

**定义 2.1.1 (整除)**  
$a$ 整除 $b$，记作 $a \mid b$，如果存在整数 $k$ 使得 $b = ak$。

**定义 2.1.2 (最大公约数)**  
$a$ 和 $b$ 的最大公约数 $\gcd(a,b)$ 是最大的正整数 $d$ 使得 $d \mid a$ 且 $d \mid b$。

**定义 2.1.3 (最小公倍数)**  
$a$ 和 $b$ 的最小公倍数 $\text{lcm}(a,b)$ 是最小的正整数 $m$ 使得 $a \mid m$ 且 $b \mid m$。

**定理 2.1.1 (欧几里得算法)**  
$$\gcd(a,b) = \gcd(b, a \bmod b)$$

### 2.2 Python 实现

```python
from typing import Tuple, List, Optional
import math

class NumberTheory:
    """数论实现"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """欧几里得算法求最大公约数"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """最小公倍数"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """扩展欧几里得算法"""
        if b == 0:
            return a, 1, 0
        else:
            gcd, x, y = NumberTheory.extended_gcd(b, a % b)
            return gcd, y, x - (a // b) * y
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """判断是否为素数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        # 只需要检查到 sqrt(n)
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def prime_factors(n: int) -> List[int]:
        """质因数分解"""
        factors = []
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors.append(d)
                n //= d
            d += 1
        
        if n > 1:
            factors.append(n)
        
        return factors
    
    @staticmethod
    def euler_totient(n: int) -> int:
        """欧拉函数 φ(n)"""
        result = n
        p = 2
        
        while p * p <= n:
            if n % p == 0:
                while n % p == 0:
                    n //= p
                result -= result // p
            p += 1
        
        if n > 1:
            result -= result // n
        
        return result
    
    @staticmethod
    def modular_inverse(a: int, m: int) -> Optional[int]:
        """模逆元"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            return None  # 不存在模逆元
        return (x % m + m) % m
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> Optional[int]:
        """中国剩余定理"""
        if len(remainders) != len(moduli):
            return None
        
        # 验证模数两两互质
        for i in range(len(moduli)):
            for j in range(i + 1, len(moduli)):
                if NumberTheory.gcd(moduli[i], moduli[j]) != 1:
                    return None
        
        # 计算乘积
        M = 1
        for m in moduli:
            M *= m
        
        result = 0
        for i, (a, m) in enumerate(zip(remainders, moduli)):
            Mi = M // m
            Mi_inv = NumberTheory.modular_inverse(Mi, m)
            if Mi_inv is None:
                return None
            result = (result + a * Mi * Mi_inv) % M
        
        return result

class PrimeNumberGenerator:
    """素数生成器"""
    
    def __init__(self):
        self.primes = [2, 3]
        self.max_checked = 3
    
    def is_prime(self, n: int) -> bool:
        """判断是否为素数"""
        if n < 2:
            return False
        if n <= self.max_checked:
            return n in self.primes
        
        # 扩展素数列表
        self._extend_primes(n)
        return n in self.primes
    
    def _extend_primes(self, limit: int) -> None:
        """扩展素数列表"""
        for n in range(self.max_checked + 2, limit + 1, 2):
            is_prime = True
            sqrt_n = int(math.sqrt(n))
            
            for p in self.primes:
                if p > sqrt_n:
                    break
                if n % p == 0:
                    is_prime = False
                    break
            
            if is_prime:
                self.primes.append(n)
        
        self.max_checked = max(self.max_checked, limit)
    
    def get_primes_up_to(self, limit: int) -> List[int]:
        """获取指定范围内的所有素数"""
        self._extend_primes(limit)
        return [p for p in self.primes if p <= limit]
    
    def nth_prime(self, n: int) -> int:
        """获取第n个素数"""
        if n <= 0:
            raise ValueError("n must be positive")
        
        # 估算第n个素数的大小
        if n == 1:
            return 2
        
        # 使用素数定理估算
        estimated_limit = int(n * math.log(n) + n * math.log(math.log(n)))
        self._extend_primes(estimated_limit)
        
        if len(self.primes) >= n:
            return self.primes[n - 1]
        else:
            # 如果估算不够，继续扩展
            while len(self.primes) < n:
                estimated_limit *= 2
                self._extend_primes(estimated_limit)
            return self.primes[n - 1]

# 使用示例
def demonstrate_number_theory():
    """演示数论"""
    print("=== 数论演示 ===")
    
    # 基本运算
    a, b = 48, 18
    print(f"gcd({a}, {b}) = {NumberTheory.gcd(a, b)}")
    print(f"lcm({a}, {b}) = {NumberTheory.lcm(a, b)}")
    
    # 扩展欧几里得算法
    gcd, x, y = NumberTheory.extended_gcd(a, b)
    print(f"扩展欧几里得: {gcd} = {a}*{x} + {b}*{y}")
    
    # 素数判断
    numbers = [2, 3, 4, 17, 25, 29]
    for n in numbers:
        print(f"{n} 是素数: {NumberTheory.is_prime(n)}")
    
    # 质因数分解
    n = 100
    factors = NumberTheory.prime_factors(n)
    print(f"{n} 的质因数分解: {factors}")
    
    # 欧拉函数
    for n in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
        phi = NumberTheory.euler_totient(n)
        print(f"φ({n}) = {phi}")
    
    # 模逆元
    a, m = 3, 11
    inv = NumberTheory.modular_inverse(a, m)
    print(f"{a} 在模 {m} 下的逆元: {inv}")
    
    # 中国剩余定理
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]
    result = NumberTheory.chinese_remainder_theorem(remainders, moduli)
    print(f"中国剩余定理: x ≡ {remainders} (mod {moduli}) => x = {result}")
    
    # 素数生成器
    prime_gen = PrimeNumberGenerator()
    primes_100 = prime_gen.get_primes_up_to(100)
    print(f"100以内的素数: {primes_100}")
    
    nth_prime = prime_gen.nth_prime(10)
    print(f"第10个素数: {nth_prime}")
    
    return a, b, factors, primes_100
```

## 3. 代数基础

### 3.1 基本概念

**定义 3.1.1 (群)**  
群是一个集合 $G$ 和一个二元运算 $\cdot$，满足：
1. 封闭性：$\forall a,b \in G, a \cdot b \in G$
2. 结合律：$\forall a,b,c \in G, (a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. 单位元：$\exists e \in G, \forall a \in G, e \cdot a = a \cdot e = a$
4. 逆元：$\forall a \in G, \exists a^{-1} \in G, a \cdot a^{-1} = a^{-1} \cdot a = e$

**定义 3.1.2 (环)**  
环是一个集合 $R$ 和两个二元运算 $+$ 和 $\cdot$，满足：
1. $(R, +)$ 是阿贝尔群
2. $(R, \cdot)$ 是半群
3. 分配律：$\forall a,b,c \in R, a \cdot (b + c) = a \cdot b + a \cdot c$

### 3.2 Python 实现

```python
from typing import Dict, Any, Optional, List
from abc import ABC, abstractmethod
import numpy as np

class Group(ABC):
    """群抽象基类"""
    
    @abstractmethod
    def operation(self, a: Any, b: Any) -> Any:
        """群运算"""
        pass
    
    @abstractmethod
    def identity(self) -> Any:
        """单位元"""
        pass
    
    @abstractmethod
    def inverse(self, a: Any) -> Any:
        """逆元"""
        pass
    
    def is_closed(self, elements: List[Any]) -> bool:
        """检查封闭性"""
        for a in elements:
            for b in elements:
                if self.operation(a, b) not in elements:
                    return False
        return True
    
    def is_associative(self, elements: List[Any]) -> bool:
        """检查结合律"""
        for a in elements:
            for b in elements:
                for c in elements:
                    left = self.operation(self.operation(a, b), c)
                    right = self.operation(a, self.operation(b, c))
                    if left != right:
                        return False
        return True

class IntegerModuloGroup(Group):
    """模n整数加法群"""
    
    def __init__(self, n: int):
        self.n = n
        self.elements = list(range(n))
    
    def operation(self, a: int, b: int) -> int:
        """模加法"""
        return (a + b) % self.n
    
    def identity(self) -> int:
        """单位元"""
        return 0
    
    def inverse(self, a: int) -> int:
        """逆元"""
        return (-a) % self.n
    
    def __str__(self) -> str:
        return f"Z_{self.n}"

class MatrixGroup(Group):
    """矩阵群"""
    
    def __init__(self, size: int, field: int):
        self.size = size
        self.field = field
        self.identity_matrix = np.eye(size, dtype=int) % field
    
    def operation(self, a: np.ndarray, b: np.ndarray) -> np.ndarray:
        """矩阵乘法"""
        return (a @ b) % self.field
    
    def identity(self) -> np.ndarray:
        """单位矩阵"""
        return self.identity_matrix.copy()
    
    def inverse(self, a: np.ndarray) -> np.ndarray:
        """矩阵逆"""
        # 简化实现，实际应用中需要更复杂的算法
        det = int(round(np.linalg.det(a)))
        if det == 0:
            raise ValueError("Matrix is not invertible")
        
        # 使用伴随矩阵求逆
        adj = np.linalg.inv(a) * det
        inv = (adj * NumberTheory.modular_inverse(det, self.field)) % self.field
        return inv.astype(int)

class Ring:
    """环"""
    
    def __init__(self, elements: List[Any], add_op, mul_op, add_id, mul_id):
        self.elements = elements
        self.add_operation = add_op
        self.mul_operation = mul_op
        self.additive_identity = add_id
        self.multiplicative_identity = mul_id
    
    def add(self, a: Any, b: Any) -> Any:
        """加法运算"""
        return self.add_operation(a, b)
    
    def multiply(self, a: Any, b: Any) -> Any:
        """乘法运算"""
        return self.mul_operation(a, b)
    
    def is_ring(self) -> bool:
        """检查是否满足环的公理"""
        # 简化检查，实际应用中需要更完整的验证
        return True

class PolynomialRing:
    """多项式环"""
    
    def __init__(self, coefficients: List[int], field: int):
        self.coefficients = coefficients
        self.field = field
        self.degree = len(coefficients) - 1
    
    def __str__(self) -> str:
        terms = []
        for i, coef in enumerate(self.coefficients):
            if coef != 0:
                if i == 0:
                    terms.append(str(coef))
                elif i == 1:
                    terms.append(f"{coef}x")
                else:
                    terms.append(f"{coef}x^{i}")
        return " + ".join(terms) if terms else "0"
    
    def add(self, other: 'PolynomialRing') -> 'PolynomialRing':
        """多项式加法"""
        max_degree = max(self.degree, other.degree)
        result_coeffs = [0] * (max_degree + 1)
        
        for i in range(max_degree + 1):
            a = self.coefficients[i] if i <= self.degree else 0
            b = other.coefficients[i] if i <= other.degree else 0
            result_coeffs[i] = (a + b) % self.field
        
        return PolynomialRing(result_coeffs, self.field)
    
    def multiply(self, other: 'PolynomialRing') -> 'PolynomialRing':
        """多项式乘法"""
        result_degree = self.degree + other.degree
        result_coeffs = [0] * (result_degree + 1)
        
        for i in range(self.degree + 1):
            for j in range(other.degree + 1):
                result_coeffs[i + j] = (result_coeffs[i + j] + 
                                      self.coefficients[i] * other.coefficients[j]) % self.field
        
        return PolynomialRing(result_coeffs, self.field)
    
    def evaluate(self, x: int) -> int:
        """多项式求值"""
        result = 0
        for i, coef in enumerate(self.coefficients):
            result = (result + coef * pow(x, i, self.field)) % self.field
        return result

# 使用示例
def demonstrate_algebra():
    """演示代数"""
    print("=== 代数演示 ===")
    
    # 模n整数群
    print("模5整数加法群:")
    group_z5 = IntegerModuloGroup(5)
    print(f"群: {group_z5}")
    print(f"元素: {group_z5.elements}")
    print(f"2 + 3 = {group_z5.operation(2, 3)}")
    print(f"单位元: {group_z5.identity()}")
    print(f"2的逆元: {group_z5.inverse(2)}")
    print(f"封闭性: {group_z5.is_closed(group_z5.elements)}")
    print(f"结合律: {group_z5.is_associative(group_z5.elements)}")
    
    # 多项式环
    print("\n多项式环:")
    p1 = PolynomialRing([1, 2, 1], 5)  # x^2 + 2x + 1
    p2 = PolynomialRing([1, 1], 5)     # x + 1
    print(f"p1 = {p1}")
    print(f"p2 = {p2}")
    print(f"p1 + p2 = {p1.add(p2)}")
    print(f"p1 * p2 = {p1.multiply(p2)}")
    print(f"p1(2) = {p1.evaluate(2)}")
    
    return group_z5, p1, p2
```

## 4. 组合数学

### 4.1 基本概念

**定义 4.1.1 (排列)**  
从 $n$ 个不同元素中取 $r$ 个元素的排列数：
$$P(n,r) = \frac{n!}{(n-r)!}$$

**定义 4.1.2 (组合)**  
从 $n$ 个不同元素中取 $r$ 个元素的组合数：
$$C(n,r) = \binom{n}{r} = \frac{n!}{r!(n-r)!}$$

**定义 4.1.3 (二项式定理)**  
$$(a + b)^n = \sum_{k=0}^{n} \binom{n}{k} a^{n-k} b^k$$

### 4.2 Python 实现

```python
from typing import List, Tuple, Iterator
import math
from itertools import combinations, permutations, product

class Combinatorics:
    """组合数学实现"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """阶乘"""
        if n < 0:
            raise ValueError("Factorial is not defined for negative numbers")
        if n == 0 or n == 1:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation(n: int, r: int) -> int:
        """排列数 P(n,r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination(n: int, r: int) -> int:
        """组合数 C(n,r)"""
        if r > n:
            return 0
        if r > n // 2:
            r = n - r  # 利用对称性优化
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def binomial_coefficient(n: int, k: int) -> int:
        """二项式系数"""
        return Combinatorics.combination(n, k)
    
    @staticmethod
    def pascal_triangle(n: int) -> List[List[int]]:
        """帕斯卡三角形"""
        triangle = []
        for i in range(n):
            row = []
            for j in range(i + 1):
                row.append(Combinatorics.binomial_coefficient(i, j))
            triangle.append(row)
        return triangle
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """卡特兰数"""
        if n <= 1:
            return 1
        return Combinatorics.binomial_coefficient(2*n, n) // (n + 1)
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """斐波那契数"""
        if n <= 1:
            return n
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    
    @staticmethod
    def stirling_number_second_kind(n: int, k: int) -> int:
        """第二类斯特林数 S(n,k)"""
        if k == 0 or k > n:
            return 0
        if k == 1 or k == n:
            return 1
        
        # 使用递推公式
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = dp[i-1][j-1] + j * dp[i-1][j]
        
        return dp[n][k]
    
    @staticmethod
    def bell_number(n: int) -> int:
        """贝尔数"""
        if n == 0:
            return 1
        
        # 使用第二类斯特林数求和
        return sum(Combinatorics.stirling_number_second_kind(n, k) for k in range(1, n + 1))

class CombinatorialGenerator:
    """组合生成器"""
    
    @staticmethod
    def generate_permutations(elements: List[Any], r: int = None) -> Iterator[Tuple]:
        """生成排列"""
        if r is None:
            r = len(elements)
        return permutations(elements, r)
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> Iterator[Tuple]:
        """生成组合"""
        return combinations(elements, r)
    
    @staticmethod
    def generate_cartesian_product(*sets: List[Any]) -> Iterator[Tuple]:
        """生成笛卡尔积"""
        return product(*sets)
    
    @staticmethod
    def generate_subsets(elements: List[Any]) -> Iterator[Tuple]:
        """生成所有子集"""
        n = len(elements)
        for i in range(2**n):
            subset = []
            for j in range(n):
                if i & (1 << j):
                    subset.append(elements[j])
            yield tuple(subset)
    
    @staticmethod
    def generate_partitions(n: int) -> Iterator[List[int]]:
        """生成整数分拆"""
        def _generate_partitions_recursive(n: int, max_part: int) -> Iterator[List[int]]:
            if n == 0:
                yield []
                return
            
            for part in range(min(max_part, n), 0, -1):
                for partition in _generate_partitions_recursive(n - part, part):
                    yield [part] + partition
        
        yield from _generate_partitions_recursive(n, n)

# 使用示例
def demonstrate_combinatorics():
    """演示组合数学"""
    print("=== 组合数学演示 ===")
    
    # 基本计算
    n, r = 5, 3
    print(f"P({n},{r}) = {Combinatorics.permutation(n, r)}")
    print(f"C({n},{r}) = {Combinatorics.combination(n, r)}")
    
    # 帕斯卡三角形
    print("\n帕斯卡三角形 (前6行):")
    triangle = Combinatorics.pascal_triangle(6)
    for i, row in enumerate(triangle):
        print(f"第{i}行: {row}")
    
    # 卡特兰数
    print("\n卡特兰数:")
    for i in range(10):
        print(f"C({i}) = {Combinatorics.catalan_number(i)}")
    
    # 斐波那契数
    print("\n斐波那契数:")
    for i in range(10):
        print(f"F({i}) = {Combinatorics.fibonacci_number(i)}")
    
    # 斯特林数
    print("\n第二类斯特林数:")
    for n in range(1, 6):
        for k in range(1, n + 1):
            print(f"S({n},{k}) = {Combinatorics.stirling_number_second_kind(n, k)}")
    
    # 贝尔数
    print("\n贝尔数:")
    for i in range(8):
        print(f"B({i}) = {Combinatorics.bell_number(i)}")
    
    # 组合生成
    elements = ['a', 'b', 'c']
    print(f"\n元素: {elements}")
    
    print("排列:")
    for perm in CombinatorialGenerator.generate_permutations(elements, 2):
        print(f"  {perm}")
    
    print("组合:")
    for comb in CombinatorialGenerator.generate_combinations(elements, 2):
        print(f"  {comb}")
    
    print("子集:")
    for subset in CombinatorialGenerator.generate_subsets(elements):
        print(f"  {subset}")
    
    print("整数分拆 (5):")
    for partition in CombinatorialGenerator.generate_partitions(5):
        print(f"  {partition}")
    
    return triangle, elements
```

## 5. 总结

数学基础为编程提供了坚实的理论基础。通过集合论、数论、代数和组合数学的学习，我们建立了从抽象概念到具体实现的完整知识体系。

### 5.1 关键要点

1. **集合论**：提供数据结构的基础理论
2. **数论**：支撑密码学和算法设计
3. **代数**：为抽象数据类型提供理论基础
4. **组合数学**：解决计数和优化问题

### 5.2 相关链接

- [逻辑学基础](01-02-逻辑学基础.md)
- [集合论与关系](01-03-集合论与关系.md)
- [代数结构](01-04-代数结构.md)

---

**注意**：本章内容为数学基础理论，后续章节将在此基础上展开更具体的应用。 