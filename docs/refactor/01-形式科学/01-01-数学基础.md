# 01-01-æ•°å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°å­¦åŸºç¡€æ˜¯è®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹çš„ç†è®ºåŸºçŸ³ï¼ŒåŒ…æ‹¬é›†åˆè®ºã€æ•°è®ºã€ä»£æ•°ã€ç»„åˆæ•°å­¦ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚è¿™äº›æ•°å­¦å·¥å…·ä¸ºç®—æ³•è®¾è®¡ã€æ•°æ®ç»“æ„ã€å¯†ç å­¦ç­‰æä¾›äº†ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆè®º (Set Theory)

**æ¦‚å¿µå®šä¹‰**: é›†åˆè®ºæ˜¯ç ”ç©¶é›†åˆåŠå…¶æ€§è´¨çš„æ•°å­¦åˆ†æ”¯ï¼Œä¸ºç°ä»£æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦æä¾›äº†åŸºç¡€è¯­è¨€ã€‚

**æ•°å­¦å½¢å¼**:
é›†åˆçš„åŸºæœ¬è¿ç®—ï¼š

- å¹¶é›†ï¼š$A \cup B = \{x | x \in A \text{ æˆ– } x \in B\}$
- äº¤é›†ï¼š$A \cap B = \{x | x \in A \text{ ä¸” } x \in B\}$
- å·®é›†ï¼š$A - B = \{x | x \in A \text{ ä¸” } x \notin B\}$
- è¡¥é›†ï¼š$A' = \{x | x \notin A\}$
- ç¬›å¡å°”ç§¯ï¼š$A \times B = \{(a, b) | a \in A, b \in B\}$

**Pythonå®ç°**:

```python
from typing import Set, List, Tuple, Any, Dict, Iterator
from dataclasses import dataclass
from abc import ABC, abstractmethod
import math

class SetTheory:
    """é›†åˆè®ºå®ç°"""
    
    @staticmethod
    def union(set_a: Set[Any], set_b: Set[Any]) -> Set[Any]:
        """é›†åˆå¹¶é›†"""
        return set_a | set_b
    
    @staticmethod
    def intersection(set_a: Set[Any], set_b: Set[Any]) -> Set[Any]:
        """é›†åˆäº¤é›†"""
        return set_a & set_b
    
    @staticmethod
    def difference(set_a: Set[Any], set_b: Set[Any]) -> Set[Any]:
        """é›†åˆå·®é›†"""
        return set_a - set_b
    
    @staticmethod
    def complement(universal_set: Set[Any], set_a: Set[Any]) -> Set[Any]:
        """é›†åˆè¡¥é›†"""
        return universal_set - set_a
    
    @staticmethod
    def cartesian_product(set_a: Set[Any], set_b: Set[Any]) -> Set[Tuple[Any, Any]]:
        """ç¬›å¡å°”ç§¯"""
        return {(a, b) for a in set_a for b in set_b}
    
    @staticmethod
    def power_set(set_a: Set[Any]) -> Set[frozenset]:
        """å¹‚é›†"""
        elements = list(set_a)
        power_set = set()
        
        # ä½¿ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºç”Ÿæˆæ‰€æœ‰å­é›†
        for i in range(2 ** len(elements)):
            subset = set()
            for j in range(len(elements)):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set
    
    @staticmethod
    def is_subset(set_a: Set[Any], set_b: Set[Any]) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå­é›†"""
        return set_a.issubset(set_b)
    
    @staticmethod
    def is_proper_subset(set_a: Set[Any], set_b: Set[Any]) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºçœŸå­é›†"""
        return set_a.issubset(set_b) and set_a != set_b
    
    @staticmethod
    def cardinality(set_a: Set[Any]) -> int:
        """é›†åˆåŸºæ•°"""
        return len(set_a)
    
    @staticmethod
    def is_finite(set_a: Set[Any]) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰é™é›†"""
        return len(set_a) < float('inf')
    
    @staticmethod
    def partition(set_a: Set[Any], num_parts: int) -> List[Set[Any]]:
        """é›†åˆåˆ†å‰²"""
        elements = list(set_a)
        if len(elements) < num_parts:
            raise ValueError("åˆ†å‰²æ•°ä¸èƒ½å¤§äºé›†åˆå…ƒç´ æ•°")
        
        partitions = [set() for _ in range(num_parts)]
        elements_per_part = len(elements) // num_parts
        remainder = len(elements) % num_parts
        
        current_index = 0
        for i in range(num_parts):
            part_size = elements_per_part + (1 if i < remainder else 0)
            partitions[i] = set(elements[current_index:current_index + part_size])
            current_index += part_size
        
        return partitions

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_set_theory():
    """æ¼”ç¤ºé›†åˆè®º"""
    print("=== é›†åˆè®ºæ¼”ç¤º ===")
    
    # åˆ›å»ºæµ‹è¯•é›†åˆ
    A = {1, 2, 3, 4, 5}
    B = {4, 5, 6, 7, 8}
    universal = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    print(f"é›†åˆ A: {A}")
    print(f"é›†åˆ B: {B}")
    print(f"å…¨é›†: {universal}")
    
    # åŸºæœ¬è¿ç®—
    print(f"\nå¹¶é›† A âˆª B: {SetTheory.union(A, B)}")
    print(f"äº¤é›† A âˆ© B: {SetTheory.intersection(A, B)}")
    print(f"å·®é›† A - B: {SetTheory.difference(A, B)}")
    print(f"è¡¥é›† A': {SetTheory.complement(universal, A)}")
    print(f"ç¬›å¡å°”ç§¯ A Ã— B: {SetTheory.cartesian_product(A, B)}")
    
    # å¹‚é›†
    small_set = {1, 2, 3}
    power_set = SetTheory.power_set(small_set)
    print(f"\nå¹‚é›† P({{1,2,3}}): {power_set}")
    
    # å­é›†å…³ç³»
    print(f"\nA æ˜¯ B çš„å­é›†: {SetTheory.is_subset(A, B)}")
    print(f"A æ˜¯ B çš„çœŸå­é›†: {SetTheory.is_proper_subset(A, B)}")
    
    # åŸºæ•°
    print(f"\né›†åˆ A çš„åŸºæ•°: {SetTheory.cardinality(A)}")
    print(f"é›†åˆ A æ˜¯æœ‰é™é›†: {SetTheory.is_finite(A)}")
    
    # åˆ†å‰²
    partitions = SetTheory.partition(A, 2)
    print(f"\né›†åˆ A çš„2åˆ†å‰²: {partitions}")
```

### 2. æ•°è®º (Number Theory)

**æ¦‚å¿µå®šä¹‰**: æ•°è®ºæ˜¯ç ”ç©¶æ•´æ•°æ€§è´¨çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨å¯†ç å­¦ã€ç®—æ³•è®¾è®¡å’Œè®¡ç®—æœºç§‘å­¦ä¸­æœ‰é‡è¦åº”ç”¨ã€‚

**æ•°å­¦å½¢å¼**:

- æ•´é™¤ï¼š$a | b$ è¡¨ç¤º $a$ æ•´é™¤ $b$
- æœ€å¤§å…¬çº¦æ•°ï¼š$\gcd(a, b)$
- æœ€å°å…¬å€æ•°ï¼š$\text{lcm}(a, b) = \frac{|ab|}{\gcd(a, b)}$
- æ¬§æ‹‰å‡½æ•°ï¼š$\phi(n)$ è¡¨ç¤ºå°äº $n$ ä¸”ä¸ $n$ äº’è´¨çš„æ•°çš„ä¸ªæ•°
- è´¹é©¬å°å®šç†ï¼šå¦‚æœ $p$ æ˜¯è´¨æ•°ä¸” $a$ ä¸ $p$ äº’è´¨ï¼Œåˆ™ $a^{p-1} \equiv 1 \pmod{p}$

**Pythonå®ç°**:

```python
from typing import List, Tuple, Dict, Set
import math
import random

class NumberTheory:
    """æ•°è®ºå®ç°"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """æ¬§å‡ é‡Œå¾—ç®—æ³•è®¡ç®—æœ€å¤§å…¬çº¦æ•°"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """è®¡ç®—æœ€å°å…¬å€æ•°"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•"""
        if a == 0:
            return b, 0, 1
        else:
            gcd, x, y = NumberTheory.extended_gcd(b % a, a)
            return gcd, y - (b // a) * x, x
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºè´¨æ•°"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        # åªéœ€è¦æ£€æŸ¥åˆ° sqrt(n)
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def prime_factors(n: int) -> Dict[int, int]:
        """è´¨å› æ•°åˆ†è§£"""
        factors = {}
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors[d] = factors.get(d, 0) + 1
                n //= d
            d += 1
        
        if n > 1:
            factors[n] = factors.get(n, 0) + 1
        
        return factors
    
    @staticmethod
    def euler_totient(n: int) -> int:
        """æ¬§æ‹‰å‡½æ•°"""
        if n == 1:
            return 1
        
        factors = NumberTheory.prime_factors(n)
        result = n
        
        for prime in factors:
            result *= (1 - 1 / prime)
        
        return int(result)
    
    @staticmethod
    def modular_inverse(a: int, m: int) -> int:
        """æ¨¡é€†å…ƒ"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            raise ValueError("æ¨¡é€†å…ƒä¸å­˜åœ¨")
        return (x % m + m) % m
    
    @staticmethod
    def fast_power(base: int, exponent: int, modulus: int = None) -> int:
        """å¿«é€Ÿå¹‚ç®—æ³•"""
        result = 1
        base = base % modulus if modulus else base
        
        while exponent > 0:
            if exponent % 2 == 1:
                result = (result * base) % modulus if modulus else result * base
            base = (base * base) % modulus if modulus else base * base
            exponent //= 2
        
        return result
    
    @staticmethod
    def fermat_primality_test(n: int, k: int = 5) -> bool:
        """è´¹é©¬ç´ æ€§æµ‹è¯•"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0:
            return False
        
        for _ in range(k):
            a = random.randint(2, n - 2)
            if NumberTheory.fast_power(a, n - 1, n) != 1:
                return False
        
        return True
    
    @staticmethod
    def generate_prime(bits: int) -> int:
        """ç”ŸæˆæŒ‡å®šä½æ•°çš„è´¨æ•°"""
        while True:
            # ç”Ÿæˆéšæœºå¥‡æ•°
            n = random.getrandbits(bits)
            n |= (1 << bits - 1) | 1  # ç¡®ä¿æœ€é«˜ä½å’Œæœ€ä½ä½ä¸º1
            
            if NumberTheory.fermat_primality_test(n):
                return n
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> int:
        """ä¸­å›½å‰©ä½™å®šç†"""
        if len(remainders) != len(moduli):
            raise ValueError("ä½™æ•°å’Œæ¨¡æ•°æ•°é‡ä¸åŒ¹é…")
        
        # è®¡ç®—æ€»æ¨¡æ•°
        total_modulus = 1
        for modulus in moduli:
            total_modulus *= modulus
        
        result = 0
        for remainder, modulus in zip(remainders, moduli):
            # è®¡ç®— Mi
            Mi = total_modulus // modulus
            # è®¡ç®— Mi çš„æ¨¡é€†å…ƒ
            Mi_inverse = NumberTheory.modular_inverse(Mi, modulus)
            # ç´¯åŠ ç»“æœ
            result = (result + remainder * Mi * Mi_inverse) % total_modulus
        
        return result

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_number_theory():
    """æ¼”ç¤ºæ•°è®º"""
    print("=== æ•°è®ºæ¼”ç¤º ===")
    
    # åŸºæœ¬è¿ç®—
    a, b = 48, 18
    print(f"gcd({a}, {b}) = {NumberTheory.gcd(a, b)}")
    print(f"lcm({a}, {b}) = {NumberTheory.lcm(a, b)}")
    
    # æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•
    gcd, x, y = NumberTheory.extended_gcd(a, b)
    print(f"æ‰©å±•æ¬§å‡ é‡Œå¾—: {a}*{x} + {b}*{y} = {gcd}")
    
    # è´¨æ•°æµ‹è¯•
    test_numbers = [2, 3, 4, 17, 25, 97]
    for n in test_numbers:
        print(f"{n} æ˜¯è´¨æ•°: {NumberTheory.is_prime(n)}")
    
    # è´¨å› æ•°åˆ†è§£
    n = 100
    factors = NumberTheory.prime_factors(n)
    print(f"\n{n} çš„è´¨å› æ•°åˆ†è§£: {factors}")
    
    # æ¬§æ‹‰å‡½æ•°
    phi_values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    for n in phi_values:
        phi = NumberTheory.euler_totient(n)
        print(f"Ï†({n}) = {phi}")
    
    # æ¨¡é€†å…ƒ
    a, m = 7, 11
    try:
        inverse = NumberTheory.modular_inverse(a, m)
        print(f"\n{a} åœ¨æ¨¡ {m} ä¸‹çš„é€†å…ƒ: {inverse}")
        print(f"éªŒè¯: {a} * {inverse} â‰¡ {(a * inverse) % m} (mod {m})")
    except ValueError as e:
        print(f"é”™è¯¯: {e}")
    
    # å¿«é€Ÿå¹‚
    base, exp, mod = 2, 10, 1000
    result = NumberTheory.fast_power(base, exp, mod)
    print(f"\n{base}^{exp} mod {mod} = {result}")
    
    # ä¸­å›½å‰©ä½™å®šç†
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]
    result = NumberTheory.chinese_remainder_theorem(remainders, moduli)
    print(f"\nä¸­å›½å‰©ä½™å®šç†: x â‰¡ {remainders} (mod {moduli})")
    print(f"è§£: x = {result}")
    
    # éªŒè¯ç»“æœ
    for remainder, modulus in zip(remainders, moduli):
        print(f"éªŒè¯: {result} â‰¡ {result % modulus} (mod {modulus})")
```

### 3. ä»£æ•° (Algebra)

**æ¦‚å¿µå®šä¹‰**: ä»£æ•°æ˜¯ç ”ç©¶ä»£æ•°ç»“æ„ï¼ˆå¦‚ç¾¤ã€ç¯ã€åŸŸï¼‰çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨å¯†ç å­¦ã€ç¼–ç ç†è®ºå’Œç®—æ³•è®¾è®¡ä¸­æœ‰é‡è¦åº”ç”¨ã€‚

**æ•°å­¦å½¢å¼**:

- ç¾¤ï¼š$(G, \cdot)$ æ»¡è¶³å°é—­æ€§ã€ç»“åˆå¾‹ã€å•ä½å…ƒã€é€†å…ƒ
- ç¯ï¼š$(R, +, \cdot)$ æ»¡è¶³åŠ æ³•ç¾¤ã€ä¹˜æ³•åŠç¾¤ã€åˆ†é…å¾‹
- åŸŸï¼š$(F, +, \cdot)$ æ»¡è¶³åŠ æ³•ç¾¤ã€ä¹˜æ³•ç¾¤ï¼ˆé™¤é›¶å…ƒï¼‰ã€åˆ†é…å¾‹

**Pythonå®ç°**:

```python
from typing import List, Dict, Set, Optional, Callable
from abc import ABC, abstractmethod
from dataclasses import dataclass
import math

@dataclass
class GroupElement:
    """ç¾¤å…ƒç´ """
    value: int
    order: int = 1

class Group:
    """ç¾¤çš„åŸºæœ¬å®ç°"""
    
    def __init__(self, elements: List[int], operation: Callable[[int, int], int]):
        self.elements = set(elements)
        self.operation = operation
        self.identity = self._find_identity()
        self.inverses = self._find_inverses()
    
    def _find_identity(self) -> Optional[int]:
        """å¯»æ‰¾å•ä½å…ƒ"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if (self.operation(e, a) != a or 
                    self.operation(a, e) != a):
                    is_identity = False
                    break
            if is_identity:
                return e
        return None
    
    def _find_inverses(self) -> Dict[int, int]:
        """å¯»æ‰¾é€†å…ƒ"""
        inverses = {}
        if self.identity is None:
            return inverses
        
        for a in self.elements:
            for b in self.elements:
                if (self.operation(a, b) == self.identity and 
                    self.operation(b, a) == self.identity):
                    inverses[a] = b
                    break
        
        return inverses
    
    def is_group(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç¾¤"""
        # æ£€æŸ¥å°é—­æ€§
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) not in self.elements:
                    return False
        
        # æ£€æŸ¥å•ä½å…ƒ
        if self.identity is None:
            return False
        
        # æ£€æŸ¥é€†å…ƒ
        if len(self.inverses) != len(self.elements):
            return False
        
        return True
    
    def order(self, element: int) -> int:
        """è®¡ç®—å…ƒç´ çš„é˜¶"""
        if element not in self.elements:
            raise ValueError("å…ƒç´ ä¸åœ¨ç¾¤ä¸­")
        
        current = element
        order = 1
        
        while current != self.identity:
            current = self.operation(current, element)
            order += 1
            if order > len(self.elements):
                return float('inf')  # æ— é™é˜¶
        
        return order
    
    def generate_subgroup(self, generator: int) -> Set[int]:
        """ç”Ÿæˆå­ç¾¤"""
        if generator not in self.elements:
            raise ValueError("ç”Ÿæˆå…ƒä¸åœ¨ç¾¤ä¸­")
        
        subgroup = {self.identity}
        current = generator
        
        while current != self.identity:
            subgroup.add(current)
            current = self.operation(current, generator)
            if len(subgroup) > len(self.elements):
                break
        
        return subgroup

class FiniteField:
    """æœ‰é™åŸŸå®ç°"""
    
    def __init__(self, p: int):
        if not NumberTheory.is_prime(p):
            raise ValueError("p å¿…é¡»æ˜¯è´¨æ•°")
        self.p = p
        self.elements = list(range(p))
    
    def add(self, a: int, b: int) -> int:
        """åŠ æ³•"""
        return (a + b) % self.p
    
    def multiply(self, a: int, b: int) -> int:
        """ä¹˜æ³•"""
        return (a * b) % self.p
    
    def inverse(self, a: int) -> int:
        """ä¹˜æ³•é€†å…ƒ"""
        if a == 0:
            raise ValueError("é›¶å…ƒæ²¡æœ‰é€†å…ƒ")
        return NumberTheory.modular_inverse(a, self.p)
    
    def power(self, a: int, n: int) -> int:
        """å¹‚è¿ç®—"""
        return NumberTheory.fast_power(a, n, self.p)
    
    def primitive_root(self) -> Optional[int]:
        """å¯»æ‰¾åŸæ ¹"""
        if self.p == 2:
            return 1
        
        # è®¡ç®— p-1 çš„è´¨å› æ•°
        factors = NumberTheory.prime_factors(self.p - 1)
        
        for g in range(2, self.p):
            is_primitive = True
            for prime in factors:
                if self.power(g, (self.p - 1) // prime) == 1:
                    is_primitive = False
                    break
            if is_primitive:
                return g
        
        return None

class Polynomial:
    """å¤šé¡¹å¼å®ç°"""
    
    def __init__(self, coefficients: List[int]):
        # å»é™¤å‰å¯¼é›¶
        while coefficients and coefficients[-1] == 0:
            coefficients.pop()
        self.coefficients = coefficients or [0]
    
    def degree(self) -> int:
        """å¤šé¡¹å¼æ¬¡æ•°"""
        return len(self.coefficients) - 1
    
    def evaluate(self, x: int) -> int:
        """æ±‚å€¼"""
        result = 0
        for i, coeff in enumerate(self.coefficients):
            result += coeff * (x ** i)
        return result
    
    def add(self, other: 'Polynomial') -> 'Polynomial':
        """å¤šé¡¹å¼åŠ æ³•"""
        max_degree = max(self.degree(), other.degree())
        result_coeffs = [0] * (max_degree + 1)
        
        for i in range(len(self.coefficients)):
            result_coeffs[i] += self.coefficients[i]
        
        for i in range(len(other.coefficients)):
            result_coeffs[i] += other.coefficients[i]
        
        return Polynomial(result_coeffs)
    
    def multiply(self, other: 'Polynomial') -> 'Polynomial':
        """å¤šé¡¹å¼ä¹˜æ³•"""
        result_degree = self.degree() + other.degree()
        result_coeffs = [0] * (result_degree + 1)
        
        for i, coeff1 in enumerate(self.coefficients):
            for j, coeff2 in enumerate(other.coefficients):
                result_coeffs[i + j] += coeff1 * coeff2
        
        return Polynomial(result_coeffs)
    
    def __str__(self) -> str:
        terms = []
        for i, coeff in enumerate(reversed(self.coefficients)):
            if coeff != 0:
                if i == 0:
                    terms.append(str(coeff))
                elif i == 1:
                    terms.append(f"{coeff}x" if coeff != 1 else "x")
                else:
                    terms.append(f"{coeff}x^{i}" if coeff != 1 else f"x^{i}")
        
        if not terms:
            return "0"
        
        return " + ".join(terms)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_algebra():
    """æ¼”ç¤ºä»£æ•°"""
    print("=== ä»£æ•°æ¼”ç¤º ===")
    
    # ç¾¤ç¤ºä¾‹ï¼šæ¨¡5åŠ æ³•ç¾¤
    def mod5_add(a: int, b: int) -> int:
        return (a + b) % 5
    
    group_elements = [0, 1, 2, 3, 4]
    mod5_group = Group(group_elements, mod5_add)
    
    print(f"æ¨¡5åŠ æ³•ç¾¤: {group_elements}")
    print(f"æ˜¯ç¾¤: {mod5_group.is_group()}")
    print(f"å•ä½å…ƒ: {mod5_group.identity}")
    print(f"é€†å…ƒ: {mod5_group.inverses}")
    
    # å…ƒç´ é˜¶
    for element in group_elements:
        order = mod5_group.order(element)
        print(f"å…ƒç´  {element} çš„é˜¶: {order}")
    
    # å­ç¾¤
    generator = 2
    subgroup = mod5_group.generate_subgroup(generator)
    print(f"ç”± {generator} ç”Ÿæˆçš„å­ç¾¤: {subgroup}")
    
    # æœ‰é™åŸŸ
    print(f"\n--- æœ‰é™åŸŸ GF(7) ---")
    gf7 = FiniteField(7)
    print(f"å…ƒç´ : {gf7.elements}")
    
    a, b = 3, 5
    print(f"{a} + {b} = {gf7.add(a, b)}")
    print(f"{a} * {b} = {gf7.multiply(a, b)}")
    print(f"{a} çš„é€†å…ƒ: {gf7.inverse(a)}")
    print(f"{a}^{b} = {gf7.power(a, b)}")
    
    primitive_root = gf7.primitive_root()
    print(f"åŸæ ¹: {primitive_root}")
    
    # å¤šé¡¹å¼
    print(f"\n--- å¤šé¡¹å¼ ---")
    p1 = Polynomial([1, 2, 3])  # 3xÂ² + 2x + 1
    p2 = Polynomial([1, 1])     # x + 1
    
    print(f"p1 = {p1}")
    print(f"p2 = {p2}")
    print(f"p1 + p2 = {p1.add(p2)}")
    print(f"p1 * p2 = {p1.multiply(p2)}")
    print(f"p1(2) = {p1.evaluate(2)}")

if __name__ == "__main__":
    demonstrate_set_theory()
    print("\n" + "="*50 + "\n")
    demonstrate_number_theory()
    print("\n" + "="*50 + "\n")
    demonstrate_algebra()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [01-02-é€»è¾‘å­¦åŸºç¡€](./01-02-é€»è¾‘å­¦åŸºç¡€.md)
- [01-03-é›†åˆè®ºåŸºç¡€](./01-03-é›†åˆè®ºåŸºç¡€.md)
- [02-01-ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Rosen, K. H. (2018). Discrete mathematics and its applications.
2. Hardy, G. H., & Wright, E. M. (2008). An introduction to the theory of numbers.
3. Hungerford, T. W. (2012). Abstract algebra: an introduction.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
