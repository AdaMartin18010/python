# 01-01 数学基础 (Mathematical Foundation)

## 📋 目录

- [概述](#概述)
- [1. 集合论基础](#1-集合论基础)
- [2. 逻辑学基础](#2-逻辑学基础)
- [3. 代数结构](#3-代数结构)
- [4. 函数与关系](#4-函数与关系)
- [5. 数论基础](#5-数论基础)
- [6. 形式化表示](#6-形式化表示)
- [7. Python实现](#7-python实现)
- [8. 参考文献](#8-参考文献)

## 概述

数学基础是计算机科学和软件工程的理论基石。本文档涵盖集合论、逻辑学、代数结构等核心数学概念，为后续的算法理论、数据结构等提供数学支撑。

## 1. 集合论基础

### 1.1 集合的定义

集合是不同对象的无序聚集，可以形式化定义为：

$$A = \{x \mid P(x)\}$$

其中 $P(x)$ 是谓词，表示元素 $x$ 满足的性质。

### 1.2 集合运算

**并集**: $A \cup B = \{x \mid x \in A \lor x \in B\}$

**交集**: $A \cap B = \{x \mid x \in A \land x \in B\}$

**差集**: $A \setminus B = \{x \mid x \in A \land x \notin B\}$

**补集**: $A^c = \{x \mid x \notin A\}$

### 1.3 集合关系

**包含**: $A \subseteq B \iff \forall x(x \in A \rightarrow x \in B)$

**相等**: $A = B \iff A \subseteq B \land B \subseteq A$

**真包含**: $A \subset B \iff A \subseteq B \land A \neq B$

## 2. 逻辑学基础

### 2.1 命题逻辑

**命题**: 可以判断真假的陈述句。

**逻辑运算符**:
- 否定: $\neg p$
- 合取: $p \land q$
- 析取: $p \lor q$
- 蕴含: $p \rightarrow q$
- 等价: $p \leftrightarrow q$

### 2.2 谓词逻辑

**全称量词**: $\forall x P(x)$ - 对所有 $x$，$P(x)$ 成立

**存在量词**: $\exists x P(x)$ - 存在 $x$，使得 $P(x)$ 成立

### 2.3 逻辑等价

**德摩根律**: 
- $\neg(p \land q) \equiv \neg p \lor \neg q$
- $\neg(p \lor q) \equiv \neg p \land \neg q$

**分配律**:
- $p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$
- $p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$

## 3. 代数结构

### 3.1 群论

**群**: 一个集合 $G$ 和二元运算 $\cdot$ 满足：
1. 封闭性: $\forall a,b \in G: a \cdot b \in G$
2. 结合律: $\forall a,b,c \in G: (a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. 单位元: $\exists e \in G: \forall a \in G: e \cdot a = a \cdot e = a$
4. 逆元: $\forall a \in G: \exists a^{-1} \in G: a \cdot a^{-1} = a^{-1} \cdot a = e$

### 3.2 环论

**环**: 一个集合 $R$ 和两个二元运算 $+$ 和 $\cdot$ 满足：
1. $(R, +)$ 是阿贝尔群
2. $(R, \cdot)$ 是半群
3. 分配律: $a \cdot (b + c) = a \cdot b + a \cdot c$

### 3.3 域论

**域**: 一个环 $(F, +, \cdot)$ 满足：
1. $(F \setminus \{0\}, \cdot)$ 是阿贝尔群
2. $0 \neq 1$

## 4. 函数与关系

### 4.1 函数定义

**函数**: 从集合 $A$ 到集合 $B$ 的关系 $f$ 满足：
$\forall a \in A: \exists! b \in B: (a,b) \in f$

记作: $f: A \rightarrow B$

### 4.2 函数性质

**单射**: $\forall a_1, a_2 \in A: f(a_1) = f(a_2) \rightarrow a_1 = a_2$

**满射**: $\forall b \in B: \exists a \in A: f(a) = b$

**双射**: 既是单射又是满射

### 4.3 关系

**关系**: 集合 $A$ 和 $B$ 的笛卡尔积 $A \times B$ 的子集

**等价关系**: 满足自反性、对称性、传递性的关系

## 5. 数论基础

### 5.1 整除性

**整除**: $a \mid b \iff \exists k \in \mathbb{Z}: b = ak$

**最大公约数**: $\gcd(a,b) = \max\{d \in \mathbb{N} \mid d \mid a \land d \mid b\}$

**最小公倍数**: $\text{lcm}(a,b) = \min\{m \in \mathbb{N} \mid a \mid m \land b \mid m\}$

### 5.2 同余

**同余**: $a \equiv b \pmod{m} \iff m \mid (a - b)$

**欧拉函数**: $\phi(n) = |\{k \in \mathbb{N} \mid 1 \leq k \leq n \land \gcd(k,n) = 1\}|$

## 6. 形式化表示

### 6.1 数学符号系统

$$\mathcal{M} = \langle \mathcal{S}, \mathcal{O}, \mathcal{R}, \mathcal{A} \rangle$$

其中：
- $\mathcal{S}$ 是符号集合
- $\mathcal{O}$ 是运算符集合
- $\mathcal{R}$ 是关系符集合
- $\mathcal{A}$ 是公理集合

### 6.2 证明系统

**自然演绎**: 基于推理规则的证明系统

**公理化系统**: 基于公理和推理规则的证明系统

## 7. Python实现

### 7.1 集合论实现

```python
from typing import Set, List, Any, Callable, TypeVar, Generic
from abc import ABC, abstractmethod
import math

T = TypeVar('T')

class SetTheory:
    """集合论实现"""
    
    @staticmethod
    def union(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """并集运算"""
        return set_a | set_b
    
    @staticmethod
    def intersection(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """交集运算"""
        return set_a & set_b
    
    @staticmethod
    def difference(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """差集运算"""
        return set_a - set_b
    
    @staticmethod
    def complement(universal_set: Set[T], set_a: Set[T]) -> Set[T]:
        """补集运算"""
        return universal_set - set_a
    
    @staticmethod
    def is_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断包含关系"""
        return set_a.issubset(set_b)
    
    @staticmethod
    def is_equal(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断相等关系"""
        return set_a == set_b
    
    @staticmethod
    def is_proper_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断真包含关系"""
        return set_a.issubset(set_b) and set_a != set_b
    
    @staticmethod
    def power_set(set_a: Set[T]) -> Set[frozenset]:
        """幂集"""
        elements = list(set_a)
        power_set = set()
        
        for i in range(2 ** len(elements)):
            subset = set()
            for j in range(len(elements)):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set
    
    @staticmethod
    def cartesian_product(set_a: Set[T], set_b: Set[T]) -> Set[tuple]:
        """笛卡尔积"""
        return {(a, b) for a in set_a for b in set_b}

class Logic:
    """逻辑学实现"""
    
    @staticmethod
    def negation(p: bool) -> bool:
        """否定"""
        return not p
    
    @staticmethod
    def conjunction(p: bool, q: bool) -> bool:
        """合取"""
        return p and q
    
    @staticmethod
    def disjunction(p: bool, q: bool) -> bool:
        """析取"""
        return p or q
    
    @staticmethod
    def implication(p: bool, q: bool) -> bool:
        """蕴含"""
        return not p or q
    
    @staticmethod
    def equivalence(p: bool, q: bool) -> bool:
        """等价"""
        return p == q
    
    @staticmethod
    def exclusive_or(p: bool, q: bool) -> bool:
        """异或"""
        return p != q
    
    @staticmethod
    def truth_table(expression: Callable[[bool, bool], bool]) -> List[dict]:
        """生成真值表"""
        table = []
        for p in [True, False]:
            for q in [True, False]:
                result = expression(p, q)
                table.append({
                    'p': p,
                    'q': q,
                    'result': result
                })
        return table
    
    @staticmethod
    def is_tautology(expression: Callable[[bool, bool], bool]) -> bool:
        """判断是否为重言式"""
        table = Logic.truth_table(expression)
        return all(row['result'] for row in table)
    
    @staticmethod
    def is_contradiction(expression: Callable[[bool, bool], bool]) -> bool:
        """判断是否为矛盾式"""
        table = Logic.truth_table(expression)
        return not any(row['result'] for row in table)

class AlgebraicStructure:
    """代数结构实现"""
    
    class Group:
        """群"""
        
        def __init__(self, elements: Set, operation: Callable, identity: Any):
            self.elements = elements
            self.operation = operation
            self.identity = identity
        
        def is_closed(self) -> bool:
            """检查封闭性"""
            for a in self.elements:
                for b in self.elements:
                    if self.operation(a, b) not in self.elements:
                        return False
            return True
        
        def is_associative(self) -> bool:
            """检查结合律"""
            for a in self.elements:
                for b in self.elements:
                    for c in self.elements:
                        left = self.operation(self.operation(a, b), c)
                        right = self.operation(a, self.operation(b, c))
                        if left != right:
                            return False
            return True
        
        def has_identity(self) -> bool:
            """检查单位元"""
            return self.identity in self.elements
        
        def has_inverses(self) -> bool:
            """检查逆元"""
            for a in self.elements:
                has_inverse = False
                for b in self.elements:
                    if (self.operation(a, b) == self.identity and 
                        self.operation(b, a) == self.identity):
                        has_inverse = True
                        break
                if not has_inverse:
                    return False
            return True
        
        def is_group(self) -> bool:
            """判断是否为群"""
            return (self.is_closed() and 
                    self.is_associative() and 
                    self.has_identity() and 
                    self.has_inverses())
    
    class Ring:
        """环"""
        
        def __init__(self, elements: Set, addition: Callable, 
                     multiplication: Callable, zero: Any, one: Any):
            self.elements = elements
            self.addition = addition
            self.multiplication = multiplication
            self.zero = zero
            self.one = one
        
        def is_ring(self) -> bool:
            """判断是否为环"""
            # 检查加法群
            addition_group = self.Group(self.elements, self.addition, self.zero)
            if not addition_group.is_group():
                return False
            
            # 检查乘法半群
            if not self._is_multiplication_semigroup():
                return False
            
            # 检查分配律
            return self._satisfies_distributivity()
        
        def _is_multiplication_semigroup(self) -> bool:
            """检查乘法半群"""
            # 封闭性
            for a in self.elements:
                for b in self.elements:
                    if self.multiplication(a, b) not in self.elements:
                        return False
            
            # 结合律
            for a in self.elements:
                for b in self.elements:
                    for c in self.elements:
                        left = self.multiplication(self.multiplication(a, b), c)
                        right = self.multiplication(a, self.multiplication(b, c))
                        if left != right:
                            return False
            
            return True
        
        def _satisfies_distributivity(self) -> bool:
            """检查分配律"""
            for a in self.elements:
                for b in self.elements:
                    for c in self.elements:
                        # 左分配律
                        left_dist = self.multiplication(a, self.addition(b, c))
                        right_dist = self.addition(
                            self.multiplication(a, b),
                            self.multiplication(a, c)
                        )
                        if left_dist != right_dist:
                            return False
            return True

class NumberTheory:
    """数论实现"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """最大公约数 - 欧几里得算法"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """最小公倍数"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """判断素数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def prime_factors(n: int) -> List[int]:
        """质因数分解"""
        factors = []
        d = 2
        
        while n > 1:
            while n % d == 0:
                factors.append(d)
                n //= d
            d += 1
            if d * d > n:
                if n > 1:
                    factors.append(n)
                break
        
        return factors
    
    @staticmethod
    def euler_phi(n: int) -> int:
        """欧拉函数"""
        if n == 1:
            return 1
        
        result = n
        for p in set(NumberTheory.prime_factors(n)):
            result *= (1 - 1/p)
        
        return int(result)
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> tuple:
        """扩展欧几里得算法"""
        if a == 0:
            return b, 0, 1
        
        gcd, x1, y1 = NumberTheory.extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        
        return gcd, x, y
    
    @staticmethod
    def mod_inverse(a: int, m: int) -> int:
        """模逆元"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            raise ValueError("模逆元不存在")
        
        return (x % m + m) % m
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> int:
        """中国剩余定理"""
        if len(remainders) != len(moduli):
            raise ValueError("余数和模数数量不匹配")
        
        n = len(remainders)
        product = 1
        for m in moduli:
            product *= m
        
        result = 0
        for i in range(n):
            pi = product // moduli[i]
            result += remainders[i] * pi * NumberTheory.mod_inverse(pi, moduli[i])
        
        return result % product

class FunctionTheory:
    """函数论实现"""
    
    @staticmethod
    def is_injective(domain: Set, codomain: Set, func: Callable) -> bool:
        """判断是否为单射"""
        image = set()
        for x in domain:
            y = func(x)
            if y in image:
                return False
            image.add(y)
        return True
    
    @staticmethod
    def is_surjective(domain: Set, codomain: Set, func: Callable) -> bool:
        """判断是否为满射"""
        image = set()
        for x in domain:
            image.add(func(x))
        return image == codomain
    
    @staticmethod
    def is_bijective(domain: Set, codomain: Set, func: Callable) -> bool:
        """判断是否为双射"""
        return (FunctionTheory.is_injective(domain, codomain, func) and
                FunctionTheory.is_surjective(domain, codomain, func))
    
    @staticmethod
    def composition(f: Callable, g: Callable) -> Callable:
        """函数复合"""
        return lambda x: f(g(x))
    
    @staticmethod
    def inverse_function(domain: Set, codomain: Set, func: Callable) -> Callable:
        """逆函数"""
        if not FunctionTheory.is_bijective(domain, codomain, func):
            raise ValueError("函数不是双射，无法求逆")
        
        # 构建逆映射
        inverse_map = {}
        for x in domain:
            y = func(x)
            inverse_map[y] = x
        
        return lambda y: inverse_map[y]

# 使用示例
def demonstrate_mathematical_foundations():
    """演示数学基础概念"""
    
    print("=== 集合论演示 ===\n")
    
    # 集合运算
    A = {1, 2, 3, 4}
    B = {3, 4, 5, 6}
    
    print(f"集合 A: {A}")
    print(f"集合 B: {B}")
    print(f"并集 A ∪ B: {SetTheory.union(A, B)}")
    print(f"交集 A ∩ B: {SetTheory.intersection(A, B)}")
    print(f"差集 A - B: {SetTheory.difference(A, B)}")
    print(f"A 是 B 的子集: {SetTheory.is_subset(A, B)}")
    print(f"A 等于 B: {SetTheory.is_equal(A, B)}")
    
    # 幂集
    small_set = {1, 2}
    power_set = SetTheory.power_set(small_set)
    print(f"\n{small_set} 的幂集: {power_set}")
    
    print("\n=== 逻辑学演示 ===\n")
    
    # 真值表
    def implication_example(p: bool, q: bool) -> bool:
        return Logic.implication(p, q)
    
    truth_table = Logic.truth_table(implication_example)
    print("蕴含运算真值表:")
    for row in truth_table:
        print(f"  p={row['p']}, q={row['q']}, p→q={row['result']}")
    
    # 重言式检查
    def tautology_example(p: bool, q: bool) -> bool:
        return Logic.implication(p, Logic.implication(q, p))
    
    print(f"\n(p→(q→p)) 是重言式: {Logic.is_tautology(tautology_example)}")
    
    print("\n=== 代数结构演示 ===\n")
    
    # 群示例：模5加法群
    Z5 = {0, 1, 2, 3, 4}
    
    def addition_mod5(a: int, b: int) -> int:
        return (a + b) % 5
    
    group = AlgebraicStructure.Group(Z5, addition_mod5, 0)
    print(f"模5加法群是群: {group.is_group()}")
    
    # 环示例：模6环
    Z6 = {0, 1, 2, 3, 4, 5}
    
    def multiplication_mod6(a: int, b: int) -> int:
        return (a * b) % 6
    
    ring = AlgebraicStructure.Ring(Z6, addition_mod5, multiplication_mod6, 0, 1)
    print(f"模6环是环: {ring.is_ring()}")
    
    print("\n=== 数论演示 ===\n")
    
    # 基本数论函数
    a, b = 48, 18
    print(f"gcd({a}, {b}) = {NumberTheory.gcd(a, b)}")
    print(f"lcm({a}, {b}) = {NumberTheory.lcm(a, b)}")
    print(f"{a} 的质因数: {NumberTheory.prime_factors(a)}")
    print(f"φ({a}) = {NumberTheory.euler_phi(a)}")
    
    # 模逆元
    try:
        inv = NumberTheory.mod_inverse(3, 7)
        print(f"3 在模7下的逆元: {inv}")
    except ValueError as e:
        print(f"错误: {e}")
    
    # 中国剩余定理
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]
    result = NumberTheory.chinese_remainder_theorem(remainders, moduli)
    print(f"中国剩余定理: x ≡ {remainders} (mod {moduli}) => x = {result}")
    
    print("\n=== 函数论演示 ===\n")
    
    # 函数性质
    domain = {1, 2, 3}
    codomain = {2, 4, 6}
    
    def square(x: int) -> int:
        return x * 2
    
    print(f"函数 f(x) = 2x 在给定域上:")
    print(f"  是单射: {FunctionTheory.is_injective(domain, codomain, square)}")
    print(f"  是满射: {FunctionTheory.is_surjective(domain, codomain, square)}")
    print(f"  是双射: {FunctionTheory.is_bijective(domain, codomain, square)}")

if __name__ == "__main__":
    demonstrate_mathematical_foundations()
```

### 7.2 高级数学工具

```python
import numpy as np
from typing import List, Tuple, Optional
import matplotlib.pyplot as plt

class AdvancedMathematics:
    """高级数学工具"""
    
    @staticmethod
    def matrix_operations():
        """矩阵运算"""
        # 创建矩阵
        A = np.array([[1, 2], [3, 4]])
        B = np.array([[5, 6], [7, 8]])
        
        print("矩阵运算:")
        print(f"A = \n{A}")
        print(f"B = \n{B}")
        print(f"A + B = \n{A + B}")
        print(f"A * B = \n{A @ B}")
        print(f"det(A) = {np.linalg.det(A)}")
        print(f"A^(-1) = \n{np.linalg.inv(A)}")
    
    @staticmethod
    def polynomial_arithmetic():
        """多项式算术"""
        # 多项式系数
        p1 = [1, 2, 3]  # x^2 + 2x + 3
        p2 = [1, 1]     # x + 1
        
        # 多项式乘法
        product = np.polymul(p1, p2)
        print(f"多项式乘法: {p1} * {p2} = {product}")
        
        # 多项式除法
        quotient, remainder = np.polydiv(p1, p2)
        print(f"多项式除法: {p1} / {p2} = 商: {quotient}, 余数: {remainder}")
    
    @staticmethod
    def linear_algebra():
        """线性代数"""
        # 特征值和特征向量
        A = np.array([[4, -2], [-2, 4]])
        eigenvalues, eigenvectors = np.linalg.eig(A)
        
        print("线性代数:")
        print(f"矩阵 A = \n{A}")
        print(f"特征值: {eigenvalues}")
        print(f"特征向量: \n{eigenvectors}")
        
        # 奇异值分解
        U, s, Vt = np.linalg.svd(A)
        print(f"SVD: A = U @ diag(s) @ Vt")
        print(f"奇异值: {s}")
    
    @staticmethod
    def calculus_approximations():
        """微积分近似"""
        def f(x):
            return x**2 + 2*x + 1
        
        # 数值积分
        x = np.linspace(0, 5, 1000)
        y = f(x)
        integral = np.trapz(y, x)
        print(f"数值积分 ∫(x²+2x+1)dx from 0 to 5 ≈ {integral}")
        
        # 数值微分
        dx = x[1] - x[0]
        derivative = np.gradient(y, dx)
        print(f"数值微分在 x=2: {derivative[400]:.2f}")  # x=2 对应的索引
    
    @staticmethod
    def probability_theory():
        """概率论"""
        # 随机数生成
        np.random.seed(42)
        samples = np.random.normal(0, 1, 1000)
        
        print("概率论:")
        print(f"正态分布样本均值: {np.mean(samples):.4f}")
        print(f"正态分布样本方差: {np.var(samples):.4f}")
        
        # 概率分布
        from scipy import stats
        x = np.linspace(-4, 4, 100)
        pdf = stats.norm.pdf(x, 0, 1)
        cdf = stats.norm.cdf(x, 0, 1)
        
        print(f"标准正态分布 P(X < 1.96) = {stats.norm.cdf(1.96):.4f}")

# 使用示例
def demonstrate_advanced_mathematics():
    """演示高级数学工具"""
    
    print("=== 高级数学工具演示 ===\n")
    
    # 矩阵运算
    AdvancedMathematics.matrix_operations()
    
    print("\n" + "="*50 + "\n")
    
    # 多项式算术
    AdvancedMathematics.polynomial_arithmetic()
    
    print("\n" + "="*50 + "\n")
    
    # 线性代数
    AdvancedMathematics.linear_algebra()
    
    print("\n" + "="*50 + "\n")
    
    # 微积分近似
    AdvancedMathematics.calculus_approximations()
    
    print("\n" + "="*50 + "\n")
    
    # 概率论
    AdvancedMathematics.probability_theory()

if __name__ == "__main__":
    demonstrate_advanced_mathematics()
```

## 8. 参考文献

1. Halmos, P. R. (1974). "Naive Set Theory".
2. Enderton, H. B. (1977). "Elements of Set Theory".
3. Mendelson, E. (2015). "Introduction to Mathematical Logic".
4. Hungerford, T. W. (1974). "Algebra".
5. Hardy, G. H., & Wright, E. M. (1979). "An Introduction to the Theory of Numbers".

---

**相关文档**:
- [01-02-逻辑学](./01-02-逻辑学.md)
- [01-03-集合论](./01-03-集合论.md)
- [02-01-算法理论](./../02-理论基础/02-01-算法理论.md)

**最后更新**: 2024-01-XX  
**版本**: 1.0.0 