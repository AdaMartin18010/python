# 集合论基础

## 目录

- [集合论基础](#集合论基础)
  - [目录](#目录)
  - [1. 基本概念](#1-基本概念)
    - [1.1 集合定义](#11-集合定义)
    - [1.2 集合表示](#12-集合表示)
    - [1.3 集合运算](#13-集合运算)
  - [2. 形式化表达](#2-形式化表达)
    - [2.1 数学定义](#21-数学定义)
    - [2.2 公理化系统](#22-公理化系统)
    - [2.3 形式化证明](#23-形式化证明)
  - [3. Python 实现](#3-python-实现)
    - [3.1 集合类型](#31-集合类型)
    - [3.2 集合操作](#32-集合操作)
    - [3.3 集合应用](#33-集合应用)
  - [4. 编程应用](#4-编程应用)
    - [4.1 数据结构](#41-数据结构)
    - [4.2 算法设计](#42-算法设计)
    - [4.3 问题建模](#43-问题建模)
  - [5. 高级主题](#5-高级主题)
    - [5.1 无限集合](#51-无限集合)
    - [5.2 模糊集合](#52-模糊集合)

---

## 1. 基本概念

### 1.1 集合定义

**定义 1.1.1 (集合)**
集合是不同对象的无序聚集，这些对象称为集合的元素。

**定义 1.1.2 (元素属于关系)**
如果 $a$ 是集合 $A$ 的元素，记作 $a \in A$；如果 $a$ 不是集合 $A$ 的元素，记作 $a \notin A$。

**定义 1.1.3 (集合相等)**
两个集合 $A$ 和 $B$ 相等，当且仅当它们包含相同的元素，记作 $A = B$。

### 1.2 集合表示

**定义 1.2.1 (列举法)**
通过列出所有元素来表示集合：
$$A = \{a_1, a_2, a_3, ..., a_n\}$$

**定义 1.2.2 (描述法)**
通过描述元素的性质来表示集合：
$$A = \{x | P(x)\}$$
其中 $P(x)$ 是元素 $x$ 满足的性质。

**定义 1.2.3 (空集)**
不包含任何元素的集合称为空集，记作 $\emptyset$。

### 1.3 集合运算

**定义 1.3.1 (并集)**
集合 $A$ 和 $B$ 的并集是包含 $A$ 和 $B$ 中所有元素的集合：
$$A \cup B = \{x | x \in A \text{ 或 } x \in B\}$$

**定义 1.3.2 (交集)**
集合 $A$ 和 $B$ 的交集是同时属于 $A$ 和 $B$ 的元素的集合：
$$A \cap B = \{x | x \in A \text{ 且 } x \in B\}$$

**定义 1.3.3 (差集)**
集合 $A$ 和 $B$ 的差集是属于 $A$ 但不属于 $B$ 的元素的集合：
$$A \setminus B = \{x | x \in A \text{ 且 } x \notin B\}$$

## 2. 形式化表达

### 2.1 数学定义

**定义 2.1.1 (集合代数)**
集合代数是一个三元组 $\langle \mathcal{P}(U), \cup, \cap \rangle$，其中：

- $\mathcal{P}(U)$ 是全集 $U$ 的幂集
- $\cup$ 是并集运算
- $\cap$ 是交集运算

**定义 2.1.2 (幂集)**
集合 $A$ 的幂集是 $A$ 的所有子集的集合：
$$\mathcal{P}(A) = \{B | B \subseteq A\}$$

**定义 2.1.3 (笛卡尔积)**
集合 $A$ 和 $B$ 的笛卡尔积是：
$$A \times B = \{(a, b) | a \in A \text{ 且 } b \in B\}$$

### 2.2 公理化系统

**公理 2.2.1 (外延公理)**
两个集合相等当且仅当它们包含相同的元素：
$$\forall A \forall B [A = B \leftrightarrow \forall x(x \in A \leftrightarrow x \in B)]$$

**公理 2.2.2 (空集公理)**
存在一个不包含任何元素的集合：
$$\exists A \forall x(x \notin A)$$

**公理 2.2.3 (并集公理)**
对于任意集合族，存在一个包含所有成员元素的集合：
$$\forall F \exists A \forall x[x \in A \leftrightarrow \exists B(B \in F \land x \in B)]$$

### 2.3 形式化证明

**定理 2.3.1 (德摩根定律)**
对于任意集合 $A$ 和 $B$：
$$(A \cup B)^c = A^c \cap B^c$$
$$(A \cap B)^c = A^c \cup B^c$$

**证明**：

1. 设 $x \in (A \cup B)^c$
2. 则 $x \notin A \cup B$
3. 因此 $x \notin A$ 且 $x \notin B$
4. 所以 $x \in A^c$ 且 $x \in B^c$
5. 因此 $x \in A^c \cap B^c$
6. 反之亦然，得证。

## 3. Python 实现

### 3.1 集合类型

```python
from typing import Set, List, Any, Iterator, Optional
from abc import ABC, abstractmethod
import math

class SetTheory:
    """
    集合论基础实现
    提供集合的基本操作和理论支持
    """
    
    def __init__(self):
        self.universal_set: Set[Any] = set()
    
    @staticmethod
    def create_set(elements: List[Any]) -> Set[Any]:
        """创建集合"""
        return set(elements)
    
    @staticmethod
    def empty_set() -> Set[Any]:
        """创建空集"""
        return set()
    
    @staticmethod
    def is_empty(s: Set[Any]) -> bool:
        """判断集合是否为空"""
        return len(s) == 0
    
    @staticmethod
    def cardinality(s: Set[Any]) -> int:
        """计算集合的基数（元素个数）"""
        return len(s)
    
    @staticmethod
    def is_subset(A: Set[Any], B: Set[Any]) -> bool:
        """判断 A 是否为 B 的子集"""
        return A.issubset(B)
    
    @staticmethod
    def is_proper_subset(A: Set[Any], B: Set[Any]) -> bool:
        """判断 A 是否为 B 的真子集"""
        return A.issubset(B) and A != B
    
    @staticmethod
    def is_superset(A: Set[Any], B: Set[Any]) -> bool:
        """判断 A 是否为 B 的超集"""
        return A.issuperset(B)
    
    @staticmethod
    def union(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """计算并集 A ∪ B"""
        return A.union(B)
    
    @staticmethod
    def intersection(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """计算交集 A ∩ B"""
        return A.intersection(B)
    
    @staticmethod
    def difference(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """计算差集 A - B"""
        return A.difference(B)
    
    @staticmethod
    def symmetric_difference(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """计算对称差集 A △ B"""
        return A.symmetric_difference(B)
    
    @staticmethod
    def complement(A: Set[Any], universal_set: Set[Any]) -> Set[Any]:
        """计算补集 A^c"""
        return universal_set.difference(A)
    
    @staticmethod
    def power_set(A: Set[Any]) -> Set[frozenset]:
        """计算幂集 P(A)"""
        elements = list(A)
        n = len(elements)
        power_set = set()
        
        # 使用二进制表示生成所有子集
        for i in range(2**n):
            subset = set()
            for j in range(n):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set
    
    @staticmethod
    def cartesian_product(A: Set[Any], B: Set[Any]) -> Set[tuple]:
        """计算笛卡尔积 A × B"""
        return {(a, b) for a in A for b in B}
    
    @staticmethod
    def is_disjoint(A: Set[Any], B: Set[Any]) -> bool:
        """判断两个集合是否不相交"""
        return A.isdisjoint(B)
    
    @staticmethod
    def partition(A: Set[Any], subsets: List[Set[Any]]) -> bool:
        """判断子集族是否为集合 A 的划分"""
        # 检查所有子集的并集是否等于 A
        union_all = set()
        for subset in subsets:
            union_all.update(subset)
        
        if union_all != A:
            return False
        
        # 检查子集之间是否两两不相交
        for i in range(len(subsets)):
            for j in range(i + 1, len(subsets)):
                if not subsets[i].isdisjoint(subsets[j]):
                    return False
        
        return True

# 高级集合操作
class AdvancedSetOperations:
    """高级集合操作类"""
    
    @staticmethod
    def set_partition_generator(A: Set[Any]) -> Iterator[List[Set[Any]]]:
        """生成集合的所有可能划分"""
        if len(A) == 0:
            yield []
            return
        
        if len(A) == 1:
            yield [A]
            return
        
        elements = list(A)
        first_element = elements[0]
        remaining_elements = set(elements[1:])
        
        # 递归生成剩余元素的划分
        for partition in AdvancedSetOperations.set_partition_generator(remaining_elements):
            # 将第一个元素添加到每个子集中
            for i in range(len(partition)):
                new_partition = partition.copy()
                new_partition[i] = new_partition[i].copy()
                new_partition[i].add(first_element)
                yield new_partition
            
            # 将第一个元素作为新的单元素子集
            yield partition + [{first_element}]
    
    @staticmethod
    def bell_number(n: int) -> int:
        """计算第 n 个贝尔数（集合划分的数量）"""
        if n == 0:
            return 1
        
        bell = [[0] * (n + 1) for _ in range(n + 1)]
        bell[0][0] = 1
        
        for i in range(1, n + 1):
            bell[i][0] = bell[i - 1][i - 1]
            for j in range(1, i + 1):
                bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
        
        return bell[n][0]
    
    @staticmethod
    def set_cover_greedy(universe: Set[Any], subsets: List[Set[Any]]) -> List[Set[Any]]:
        """贪心算法求解集合覆盖问题"""
        uncovered = universe.copy()
        cover = []
        
        while uncovered:
            # 选择覆盖最多未覆盖元素的子集
            best_subset = None
            best_coverage = 0
            
            for subset in subsets:
                coverage = len(subset.intersection(uncovered))
                if coverage > best_coverage:
                    best_coverage = coverage
                    best_subset = subset
            
            if best_subset is None:
                break
            
            cover.append(best_subset)
            uncovered -= best_subset
        
        return cover

# 使用示例
def demonstrate_set_theory():
    """演示集合论基础操作"""
    
    # 创建集合
    A = {1, 2, 3, 4, 5}
    B = {4, 5, 6, 7, 8}
    C = {1, 3, 5, 7, 9}
    
    print("=== 基本集合操作 ===")
    print(f"集合 A: {A}")
    print(f"集合 B: {B}")
    print(f"集合 C: {C}")
    
    # 基本运算
    print(f"A ∪ B = {SetTheory.union(A, B)}")
    print(f"A ∩ B = {SetTheory.intersection(A, B)}")
    print(f"A - B = {SetTheory.difference(A, B)}")
    print(f"A △ B = {SetTheory.symmetric_difference(A, B)}")
    
    # 关系判断
    print(f"A ⊆ B: {SetTheory.is_subset(A, B)}")
    print(f"A ⊂ B: {SetTheory.is_proper_subset(A, B)}")
    print(f"A 与 B 不相交: {SetTheory.is_disjoint(A, B)}")
    
    # 高级操作
    print(f"\n=== 高级操作 ===")
    print(f"|A| = {SetTheory.cardinality(A)}")
    
    # 幂集（只显示前几个元素）
    power_set_A = SetTheory.power_set(A)
    print(f"P(A) 的元素个数: {len(power_set_A)}")
    print(f"P(A) 的前5个元素: {list(power_set_A)[:5]}")
    
    # 笛卡尔积
    cartesian_AB = SetTheory.cartesian_product(A, B)
    print(f"A × B 的元素个数: {len(cartesian_AB)}")
    print(f"A × B 的前5个元素: {list(cartesian_AB)[:5]}")
    
    # 集合划分
    partition = [{1, 2}, {3, 4}, {5}]
    print(f"{{1,2}, {{3,4}}, {{5}}} 是 A 的划分: {SetTheory.partition(A, partition)}")
    
    # 贝尔数
    print(f"B(5) = {AdvancedSetOperations.bell_number(5)}")
    
    # 集合覆盖
    universe = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    subsets = [{1, 2, 3, 4}, {3, 4, 5, 6}, {5, 6, 7, 8}, {7, 8, 9, 10}]
    cover = AdvancedSetOperations.set_cover_greedy(universe, subsets)
    print(f"集合覆盖: {cover}")

if __name__ == "__main__":
    demonstrate_set_theory()
```

### 3.2 集合操作

```python
# 集合操作的高级实现

from typing import TypeVar, Generic, Callable, Any
from collections import defaultdict
import itertools

T = TypeVar('T')

class SetOperations(Generic[T]):
    """
    泛型集合操作类
    提供类型安全的集合操作
    """
    
    def __init__(self, elements: Set[T] = None):
        self.elements = elements or set()
    
    def add(self, element: T) -> None:
        """添加元素"""
        self.elements.add(element)
    
    def remove(self, element: T) -> None:
        """移除元素"""
        self.elements.discard(element)
    
    def contains(self, element: T) -> bool:
        """检查元素是否存在"""
        return element in self.elements
    
    def union_with(self, other: 'SetOperations[T]') -> 'SetOperations[T]':
        """与另一个集合求并集"""
        return SetOperations(self.elements.union(other.elements))
    
    def intersection_with(self, other: 'SetOperations[T]') -> 'SetOperations[T]':
        """与另一个集合求交集"""
        return SetOperations(self.elements.intersection(other.elements))
    
    def difference_with(self, other: 'SetOperations[T]') -> 'SetOperations[T]':
        """与另一个集合求差集"""
        return SetOperations(self.elements.difference(other.elements))
    
    def filter(self, predicate: Callable[[T], bool]) -> 'SetOperations[T]':
        """过滤集合元素"""
        return SetOperations({x for x in self.elements if predicate(x)})
    
    def map(self, func: Callable[[T], Any]) -> 'SetOperations[Any]':
        """映射集合元素"""
        return SetOperations({func(x) for x in self.elements})
    
    def reduce(self, func: Callable[[Any, T], Any], initial: Any = None) -> Any:
        """归约集合元素"""
        if initial is None:
            if not self.elements:
                raise ValueError("Cannot reduce empty set without initial value")
            iterator = iter(self.elements)
            result = next(iterator)
            for element in iterator:
                result = func(result, element)
            return result
        else:
            result = initial
            for element in self.elements:
                result = func(result, element)
            return result
    
    def __len__(self) -> int:
        return len(self.elements)
    
    def __iter__(self):
        return iter(self.elements)
    
    def __str__(self) -> str:
        return f"SetOperations({self.elements})"

class SetAlgebra:
    """
    集合代数类
    提供集合的代数运算
    """
    
    @staticmethod
    def associative_law(A: Set[Any], B: Set[Any], C: Set[Any]) -> bool:
        """验证结合律: (A ∪ B) ∪ C = A ∪ (B ∪ C)"""
        left = (A.union(B)).union(C)
        right = A.union(B.union(C))
        return left == right
    
    @staticmethod
    def commutative_law(A: Set[Any], B: Set[Any]) -> bool:
        """验证交换律: A ∪ B = B ∪ A"""
        return A.union(B) == B.union(A)
    
    @staticmethod
    def distributive_law(A: Set[Any], B: Set[Any], C: Set[Any]) -> bool:
        """验证分配律: A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)"""
        left = A.intersection(B.union(C))
        right = A.intersection(B).union(A.intersection(C))
        return left == right
    
    @staticmethod
    def de_morgan_law(A: Set[Any], B: Set[Any], universal: Set[Any]) -> bool:
        """验证德摩根定律: (A ∪ B)^c = A^c ∩ B^c"""
        left = universal.difference(A.union(B))
        right = universal.difference(A).intersection(universal.difference(B))
        return left == right
    
    @staticmethod
    def idempotent_law(A: Set[Any]) -> bool:
        """验证幂等律: A ∪ A = A"""
        return A.union(A) == A

class SetRelations:
    """
    集合关系类
    提供集合间关系的分析
    """
    
    @staticmethod
    def equivalence_relation(elements: Set[Any], relation: Callable[[Any, Any], bool]) -> bool:
        """验证等价关系"""
        # 自反性
        for x in elements:
            if not relation(x, x):
                return False
        
        # 对称性
        for x in elements:
            for y in elements:
                if relation(x, y) != relation(y, x):
                    return False
        
        # 传递性
        for x in elements:
            for y in elements:
                for z in elements:
                    if relation(x, y) and relation(y, z) and not relation(x, z):
                        return False
        
        return True
    
    @staticmethod
    def partial_order(elements: Set[Any], relation: Callable[[Any, Any], bool]) -> bool:
        """验证偏序关系"""
        # 自反性
        for x in elements:
            if not relation(x, x):
                return False
        
        # 反对称性
        for x in elements:
            for y in elements:
                if relation(x, y) and relation(y, x) and x != y:
                    return False
        
        # 传递性
        for x in elements:
            for y in elements:
                for z in elements:
                    if relation(x, y) and relation(y, z) and not relation(x, z):
                        return False
        
        return True
    
    @staticmethod
    def equivalence_classes(elements: Set[Any], relation: Callable[[Any, Any], bool]) -> List[Set[Any]]:
        """计算等价类"""
        classes = []
        remaining = elements.copy()
        
        while remaining:
            x = remaining.pop()
            class_elements = {x}
            
            to_remove = set()
            for y in remaining:
                if relation(x, y):
                    class_elements.add(y)
                    to_remove.add(y)
            
            remaining -= to_remove
            classes.append(class_elements)
        
        return classes

# 使用示例
def demonstrate_advanced_operations():
    """演示高级集合操作"""
    
    # 泛型集合操作
    print("=== 泛型集合操作 ===")
    int_set = SetOperations({1, 2, 3, 4, 5})
    str_set = SetOperations({'a', 'b', 'c', 'd'})
    
    print(f"整数集合: {int_set}")
    print(f"字符串集合: {str_set}")
    
    # 函数式操作
    filtered_set = int_set.filter(lambda x: x % 2 == 0)
    mapped_set = int_set.map(lambda x: x * 2)
    sum_result = int_set.reduce(lambda acc, x: acc + x, 0)
    
    print(f"过滤后的集合: {filtered_set}")
    print(f"映射后的集合: {mapped_set}")
    print(f"集合元素和: {sum_result}")
    
    # 集合代数验证
    print("\n=== 集合代数验证 ===")
    A = {1, 2, 3}
    B = {3, 4, 5}
    C = {5, 6, 7}
    U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    print(f"结合律验证: {SetAlgebra.associative_law(A, B, C)}")
    print(f"交换律验证: {SetAlgebra.commutative_law(A, B)}")
    print(f"分配律验证: {SetAlgebra.distributive_law(A, B, C)}")
    print(f"德摩根定律验证: {SetAlgebra.de_morgan_law(A, B, U)}")
    print(f"幂等律验证: {SetAlgebra.idempotent_law(A)}")
    
    # 集合关系
    print("\n=== 集合关系 ===")
    numbers = {1, 2, 3, 4, 5}
    
    # 等价关系：模3同余
    def mod3_relation(x: int, y: int) -> bool:
        return x % 3 == y % 3
    
    print(f"模3同余是等价关系: {SetRelations.equivalence_relation(numbers, mod3_relation)}")
    
    # 等价类
    classes = SetRelations.equivalence_classes(numbers, mod3_relation)
    print(f"模3同余的等价类: {classes}")
    
    # 偏序关系：整除关系
    def divides(x: int, y: int) -> bool:
        return y % x == 0 if x != 0 else False
    
    print(f"整除关系是偏序关系: {SetRelations.partial_order(numbers, divides)}")

if __name__ == "__main__":
    demonstrate_advanced_operations()
```

### 3.3 集合应用

```python
# 集合在编程中的应用

from typing import Dict, List, Tuple, Set
import random
import time

class SetApplications:
    """集合应用类"""
    
    @staticmethod
    def remove_duplicates(data: List[Any]) -> List[Any]:
        """使用集合去重"""
        return list(set(data))
    
    @staticmethod
    def find_common_elements(list1: List[Any], list2: List[Any]) -> List[Any]:
        """查找两个列表的公共元素"""
        return list(set(list1).intersection(set(list2)))
    
    @staticmethod
    def find_unique_elements(list1: List[Any], list2: List[Any]) -> List[Any]:
        """查找两个列表的唯一元素"""
        return list(set(list1).symmetric_difference(set(list2)))
    
    @staticmethod
    def is_subset_check(small_list: List[Any], large_list: List[Any]) -> bool:
        """检查一个列表是否为另一个列表的子集"""
        return set(small_list).issubset(set(large_list))
    
    @staticmethod
    def set_operations_demo():
        """集合操作演示"""
        # 用户权限管理
        admin_permissions = {'read', 'write', 'delete', 'admin'}
        user_permissions = {'read', 'write'}
        guest_permissions = {'read'}
        
        # 权限检查
        def has_permission(user_perms: Set[str], required_perms: Set[str]) -> bool:
            return required_perms.issubset(user_perms)
        
        print(f"用户是否有删除权限: {has_permission(user_permissions, {'delete'})}")
        print(f"用户是否有读取权限: {has_permission(user_permissions, {'read'})}")
        
        # 权限交集
        common_permissions = user_permissions.intersection(admin_permissions)
        print(f"用户和管理员的共同权限: {common_permissions}")
        
        # 权限差集
        admin_only = admin_permissions.difference(user_permissions)
        print(f"管理员独有权限: {admin_only}")

class SetPerformanceAnalysis:
    """集合性能分析类"""
    
    @staticmethod
    def performance_comparison():
        """比较列表和集合的性能"""
        # 生成测试数据
        size = 10000
        test_data = list(range(size))
        search_elements = random.sample(test_data, 1000)
        
        # 列表查找性能
        start_time = time.time()
        for element in search_elements:
            element in test_data
        list_time = time.time() - start_time
        
        # 集合查找性能
        test_set = set(test_data)
        start_time = time.time()
        for element in search_elements:
            element in test_set
        set_time = time.time() - start_time
        
        print(f"列表查找时间: {list_time:.4f} 秒")
        print(f"集合查找时间: {set_time:.4f} 秒")
        print(f"性能提升: {list_time / set_time:.2f} 倍")
    
    @staticmethod
    def memory_usage_comparison():
        """比较内存使用"""
        import sys
        
        # 列表内存使用
        test_list = list(range(1000))
        list_memory = sys.getsizeof(test_list)
        
        # 集合内存使用
        test_set = set(range(1000))
        set_memory = sys.getsizeof(test_set)
        
        print(f"列表内存使用: {list_memory} 字节")
        print(f"集合内存使用: {set_memory} 字节")
        print(f"内存差异: {set_memory - list_memory} 字节")

class SetAlgorithms:
    """基于集合的算法"""
    
    @staticmethod
    def find_duplicates(data: List[Any]) -> List[Any]:
        """查找重复元素"""
        seen = set()
        duplicates = set()
        
        for item in data:
            if item in seen:
                duplicates.add(item)
            else:
                seen.add(item)
        
        return list(duplicates)
    
    @staticmethod
    def find_missing_numbers(complete_range: range, actual_numbers: List[int]) -> List[int]:
        """查找缺失的数字"""
        expected_set = set(complete_range)
        actual_set = set(actual_numbers)
        return list(expected_set.difference(actual_set))
    
    @staticmethod
    def find_common_subsequences(seq1: List[Any], seq2: List[Any], min_length: int = 2) -> List[Tuple[Any, ...]]:
        """查找公共子序列"""
        def get_subsequences(seq: List[Any], min_len: int) -> Set[Tuple[Any, ...]]:
            subsequences = set()
            for length in range(min_len, len(seq) + 1):
                for i in range(len(seq) - length + 1):
                    subsequences.add(tuple(seq[i:i + length]))
            return subsequences
        
        subseq1 = get_subsequences(seq1, min_length)
        subseq2 = get_subsequences(seq2, min_length)
        
        return list(subseq1.intersection(subseq2))
    
    @staticmethod
    def set_cover_approximation(universe: Set[Any], subsets: List[Set[Any]]) -> List[Set[Any]]:
        """集合覆盖近似算法"""
        uncovered = universe.copy()
        cover = []
        
        while uncovered:
            # 选择覆盖最多未覆盖元素的子集
            best_subset = None
            best_coverage = 0
            
            for subset in subsets:
                coverage = len(subset.intersection(uncovered))
                if coverage > best_coverage:
                    best_coverage = coverage
                    best_subset = subset
            
            if best_subset is None:
                break
            
            cover.append(best_subset)
            uncovered -= best_subset
        
        return cover

# 使用示例
def demonstrate_applications():
    """演示集合应用"""
    
    print("=== 集合应用演示 ===")
    
    # 基本应用
    data = [1, 2, 2, 3, 3, 4, 5, 5, 5]
    unique_data = SetApplications.remove_duplicates(data)
    print(f"去重前: {data}")
    print(f"去重后: {unique_data}")
    
    list1 = [1, 2, 3, 4, 5]
    list2 = [4, 5, 6, 7, 8]
    common = SetApplications.find_common_elements(list1, list2)
    unique = SetApplications.find_unique_elements(list1, list2)
    print(f"公共元素: {common}")
    print(f"唯一元素: {unique}")
    
    # 权限管理演示
    SetApplications.set_operations_demo()
    
    # 性能分析
    print("\n=== 性能分析 ===")
    SetPerformanceAnalysis.performance_comparison()
    SetPerformanceAnalysis.memory_usage_comparison()
    
    # 算法应用
    print("\n=== 算法应用 ===")
    
    # 查找重复元素
    test_data = [1, 2, 2, 3, 4, 4, 5, 5, 5]
    duplicates = SetAlgorithms.find_duplicates(test_data)
    print(f"重复元素: {duplicates}")
    
    # 查找缺失数字
    complete = range(1, 11)
    actual = [1, 2, 4, 6, 8, 10]
    missing = SetAlgorithms.find_missing_numbers(complete, actual)
    print(f"缺失数字: {missing}")
    
    # 查找公共子序列
    seq1 = [1, 2, 3, 4, 5]
    seq2 = [2, 3, 4, 6, 7]
    common_subseqs = SetAlgorithms.find_common_subsequences(seq1, seq2, 2)
    print(f"公共子序列: {common_subseqs}")
    
    # 集合覆盖
    universe = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    subsets = [{1, 2, 3, 4}, {3, 4, 5, 6}, {5, 6, 7, 8}, {7, 8, 9, 10}]
    cover = SetAlgorithms.set_cover_approximation(universe, subsets)
    print(f"集合覆盖: {cover}")

if __name__ == "__main__":
    demonstrate_applications()
```

## 4. 编程应用

### 4.1 数据结构

集合在数据结构中的应用：

1. **哈希表**：使用集合实现快速查找
2. **图论**：使用集合表示图的顶点和边
3. **关系数据库**：使用集合表示关系
4. **缓存系统**：使用集合实现快速缓存查找

### 4.2 算法设计

集合在算法设计中的应用：

1. **去重算法**：使用集合快速去除重复元素
2. **查找算法**：使用集合实现快速查找
3. **图算法**：使用集合表示图的连通分量
4. **组合算法**：使用集合生成组合

### 4.3 问题建模

集合在问题建模中的应用：

1. **权限管理**：使用集合表示用户权限
2. **资源分配**：使用集合表示可用资源
3. **状态管理**：使用集合表示系统状态
4. **配置管理**：使用集合表示配置选项

## 5. 高级主题

### 5.1 无限集合

```python
# 无限集合的实现

class InfiniteSet:
    """无限集合的抽象表示"""
    
    def __init__(self, predicate: Callable[[Any], bool]):
        self.predicate = predicate
    
    def contains(self, element: Any) -> bool:
        """检查元素是否属于集合"""
        return self.predicate(element)
    
    def __contains__(self, element: Any) -> bool:
        return self.contains(element)

# 自然数集合
natural_numbers = InfiniteSet(lambda x: isinstance(x, int) and x >= 0)

# 偶数集合
even_numbers = InfiniteSet(lambda x: isinstance(x, int) and x % 2 == 0)

# 质数集合
def is_prime(n: int) -> bool:
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

prime_numbers = InfiniteSet(is_prime)
```

### 5.2 模糊集合

```python
# 模糊集合的实现

class FuzzySet:
    """模糊集合类"""
    
    def __init__(self, membership_function: Callable[[Any], float]):
        self.membership_function = membership_function
    
    def membership_degree(self, element: Any) -> float:
        """获取元素的隶属度"""
        return self.membership_function(element)
    
    def union(self, other: 'FuzzySet') -> 'FuzzySet':
        """模糊并集"""
        def union_membership(x: Any) -> float:
            return max(self.membership_degree(x), other.membership_degree(x))
        return FuzzySet(union_membership)
    
    def intersection(self, other: 'FuzzySet') -> 'FuzzySet':
        """模糊交集"""
        def intersection_membership(x: Any) -> float:
            return min(self.membership_degree(x), other.membership_degree(x))
        return FuzzySet(intersection_membership)

# 示例：年轻人的模糊集合
def young_membership(age: int) -> float:
    if age <= 20:
        return 1.0
    elif age <= 30:
        return 1.0 - (age - 20) / 10
    else:
        return 0.0

young_people = FuzzySet(young_membership)
```

---

**总结**：集合论是数学的基础理论，在编程中有着广泛的应用。通过 Python 的实现，我们可以更好地理解集合的概念和操作，并将其应用到实际问题中。
