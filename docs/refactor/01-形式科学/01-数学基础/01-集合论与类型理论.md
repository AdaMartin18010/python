# 01. 集合论与类型理论

## 1.1 集合论基础

### 1.1.1 基本定义

**定义 1.1.1** (集合): 集合是不同对象的无序聚集。

**定义 1.1.2** (成员关系): 如果 $x$ 是集合 $A$ 的元素，记作 $x \in A$。

**定义 1.1.3** (子集): 如果集合 $A$ 的每个元素都是集合 $B$ 的元素，则称 $A$ 是 $B$ 的子集，记作 $A \subseteq B$。

### 1.1.2 集合运算

**并集**: $A \cup B = \{x | x \in A \lor x \in B\}$

**交集**: $A \cap B = \{x | x \in A \land x \in B\}$

**差集**: $A \setminus B = \{x | x \in A \land x \notin B\}$

**补集**: $A^c = \{x | x \notin A\}$

## 1.2 类型理论

### 1.2.1 简单类型理论

**定义 1.2.1** (类型): 类型是值的集合。

**定义 1.2.2** (类型构造器):

- 基本类型: $\text{Bool}, \text{Int}, \text{String}$
- 函数类型: $A \rightarrow B$
- 积类型: $A \times B$
- 和类型: $A + B$

### 1.2.2 类型规则

**函数应用规则**:

```latex
Γ ⊢ f : A → B    Γ ⊢ x : A
─────────────────────────
Γ ⊢ f(x) : B
```

**函数抽象规则**:

```latex
Γ, x : A ⊢ e : B
────────────────
Γ ⊢ λx.e : A → B
```

## 1.3 Python实现

### 1.3.1 集合论实现

```python
from typing import Set, TypeVar, Generic, Iterator
from abc import ABC, abstractmethod
from dataclasses import dataclass

T = TypeVar('T')

class SetTheory:
    """集合论实现"""
    
    @staticmethod
    def union(a: Set[T], b: Set[T]) -> Set[T]:
        """并集运算"""
        return a | b
    
    @staticmethod
    def intersection(a: Set[T], b: Set[T]) -> Set[T]:
        """交集运算"""
        return a & b
    
    @staticmethod
    def difference(a: Set[T], b: Set[T]) -> Set[T]:
        """差集运算"""
        return a - b
    
    @staticmethod
    def complement(a: Set[T], universal: Set[T]) -> Set[T]:
        """补集运算"""
        return universal - a
    
    @staticmethod
    def is_subset(a: Set[T], b: Set[T]) -> bool:
        """子集关系检查"""
        return a.issubset(b)
    
    @staticmethod
    def is_proper_subset(a: Set[T], b: Set[T]) -> bool:
        """真子集关系检查"""
        return a.issubset(b) and a != b
    
    @staticmethod
    def powerset(s: Set[T]) -> Set[frozenset]:
        """幂集"""
        from itertools import combinations
        
        result = set()
        for i in range(len(s) + 1):
            for combo in combinations(s, i):
                result.add(frozenset(combo))
        return result

# 使用示例
def demonstrate_set_theory():
    """演示集合论运算"""
    A = {1, 2, 3, 4}
    B = {3, 4, 5, 6}
    universal = {1, 2, 3, 4, 5, 6, 7, 8}
    
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"A ∪ B = {SetTheory.union(A, B)}")
    print(f"A ∩ B = {SetTheory.intersection(A, B)}")
    print(f"A - B = {SetTheory.difference(A, B)}")
    print(f"A^c = {SetTheory.complement(A, universal)}")
    print(f"A ⊆ B = {SetTheory.is_subset(A, B)}")
    print(f"P(A) = {SetTheory.powerset(A)}")

if __name__ == "__main__":
    demonstrate_set_theory()
```

### 1.3.2 类型理论实现

```python
from typing import Any, Dict, List, Optional, Union, Callable
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod

class TypeKind(Enum):
    """类型种类"""
    BASIC = "basic"
    FUNCTION = "function"
    PRODUCT = "product"
    SUM = "sum"

@dataclass
class Type:
    """类型定义"""
    name: str
    kind: TypeKind
    params: List['Type'] = None
    
    def __post_init__(self):
        if self.params is None:
            self.params = []
    
    def __str__(self):
        if self.kind == TypeKind.BASIC:
            return self.name
        elif self.kind == TypeKind.FUNCTION:
            return f"({self.params[0]} -> {self.params[1]})"
        elif self.kind == TypeKind.PRODUCT:
            return f"({self.params[0]} × {self.params[1]})"
        elif self.kind == TypeKind.SUM:
            return f"({self.params[0]} + {self.params[1]})"
        return self.name

class TypeTheory:
    """类型理论实现"""
    
    def __init__(self):
        self.types: Dict[str, Type] = {}
        self.subtype_relations: Dict[str, List[str]] = {}
        self.type_rules: List[Callable] = []
    
    def register_basic_type(self, name: str) -> Type:
        """注册基本类型"""
        type_def = Type(name, TypeKind.BASIC)
        self.types[name] = type_def
        return type_def
    
    def create_function_type(self, domain: Type, codomain: Type) -> Type:
        """创建函数类型"""
        return Type("function", TypeKind.FUNCTION, [domain, codomain])
    
    def create_product_type(self, left: Type, right: Type) -> Type:
        """创建积类型"""
        return Type("product", TypeKind.PRODUCT, [left, right])
    
    def create_sum_type(self, left: Type, right: Type) -> Type:
        """创建和类型"""
        return Type("sum", TypeKind.SUM, [left, right])
    
    def type_check(self, expression: Any, expected_type: Type) -> bool:
        """类型检查"""
        if expected_type.kind == TypeKind.BASIC:
            return self._check_basic_type(expression, expected_type)
        elif expected_type.kind == TypeKind.FUNCTION:
            return self._check_function_type(expression, expected_type)
        elif expected_type.kind == TypeKind.PRODUCT:
            return self._check_product_type(expression, expected_type)
        elif expected_type.kind == TypeKind.SUM:
            return self._check_sum_type(expression, expected_type)
        return False
    
    def _check_basic_type(self, expression: Any, type_def: Type) -> bool:
        """基本类型检查"""
        if type_def.name == "Int":
            return isinstance(expression, int)
        elif type_def.name == "Bool":
            return isinstance(expression, bool)
        elif type_def.name == "String":
            return isinstance(expression, str)
        return False
    
    def _check_function_type(self, expression: Any, type_def: Type) -> bool:
        """函数类型检查"""
        return callable(expression)
    
    def _check_product_type(self, expression: Any, type_def: Type) -> bool:
        """积类型检查"""
        if not isinstance(expression, (tuple, list)) or len(expression) != 2:
            return False
        return (self.type_check(expression[0], type_def.params[0]) and 
                self.type_check(expression[1], type_def.params[1]))
    
    def _check_sum_type(self, expression: Any, type_def: Type) -> bool:
        """和类型检查"""
        return (self.type_check(expression, type_def.params[0]) or 
                self.type_check(expression, type_def.params[1]))

# 使用示例
def demonstrate_type_theory():
    """演示类型理论"""
    tt = TypeTheory()
    
    # 注册基本类型
    int_type = tt.register_basic_type("Int")
    bool_type = tt.register_basic_type("Bool")
    string_type = tt.register_basic_type("String")
    
    # 创建复合类型
    int_to_bool = tt.create_function_type(int_type, bool_type)
    int_pair = tt.create_product_type(int_type, int_type)
    int_or_bool = tt.create_sum_type(int_type, bool_type)
    
    # 类型检查
    assert tt.type_check(42, int_type)
    assert tt.type_check(True, bool_type)
    assert tt.type_check("hello", string_type)
    assert tt.type_check(lambda x: x > 0, int_to_bool)
    assert tt.type_check((1, 2), int_pair)
    assert tt.type_check(42, int_or_bool)
    assert tt.type_check(True, int_or_bool)
    
    print("所有类型检查通过!")

if __name__ == "__main__":
    demonstrate_type_theory()
```

## 1.4 形式化证明

### 1.4.1 集合运算性质

**定理 1.4.1** (交换律): $A \cup B = B \cup A$ 且 $A \cap B = B \cap A$

**证明**:

```latex
对于任意 x ∈ A ∪ B
根据并集定义: x ∈ A ∨ x ∈ B
根据逻辑或的交换律: x ∈ B ∨ x ∈ A
因此 x ∈ B ∪ A
同理可证 A ∩ B = B ∩ A
```

**定理 1.4.2** (结合律): $(A \cup B) \cup C = A \cup (B \cup C)$

**证明**:

```latex
对于任意 x ∈ (A ∪ B) ∪ C
根据并集定义: (x ∈ A ∨ x ∈ B) ∨ x ∈ C
根据逻辑或的结合律: x ∈ A ∨ (x ∈ B ∨ x ∈ C)
因此 x ∈ A ∪ (B ∪ C)
```

### 1.4.2 类型安全性质

**定理 1.4.3** (类型保持): 如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$

**证明**:

```text
通过结构归纳法证明
对于每种归约规则，证明类型保持不变
```

## 1.5 应用实例

### 1.5.1 数据库关系代数

```python
@dataclass
class Relation:
    """关系定义"""
    name: str
    attributes: List[str]
    tuples: List[tuple]
    
    def projection(self, attributes: List[str]) -> 'Relation':
        """投影运算"""
        indices = [self.attributes.index(attr) for attr in attributes]
        new_tuples = [tuple(t[i] for i in indices) for t in self.tuples]
        return Relation(f"π_{attributes}({self.name})", attributes, new_tuples)
    
    def selection(self, condition: Callable) -> 'Relation':
        """选择运算"""
        new_tuples = [t for t in self.tuples if condition(t)]
        return Relation(f"σ_{condition.__name__}({self.name})", 
                       self.attributes, new_tuples)
    
    def join(self, other: 'Relation', condition: Callable) -> 'Relation':
        """连接运算"""
        new_attributes = self.attributes + other.attributes
        new_tuples = []
        
        for t1 in self.tuples:
            for t2 in other.tuples:
                if condition(t1, t2):
                    new_tuples.append(t1 + t2)
        
        return Relation(f"{self.name}⋈{other.name}", new_attributes, new_tuples)

# 使用示例
def demonstrate_relational_algebra():
    """演示关系代数"""
    # 创建关系
    students = Relation("Students", ["id", "name", "age"], [
        (1, "Alice", 20),
        (2, "Bob", 22),
        (3, "Charlie", 21)
    ])
    
    courses = Relation("Courses", ["id", "name", "credits"], [
        (1, "Math", 3),
        (2, "Physics", 4),
        (3, "Chemistry", 3)
    ])
    
    # 投影
    names = students.projection(["name"])
    print(f"Names: {names.tuples}")
    
    # 选择
    young_students = students.selection(lambda t: t[2] < 22)
    print(f"Young students: {young_students.tuples}")
    
    # 连接
    def student_course_condition(s, c):
        return s[0] == c[0]  # 简单的等值连接
    
    joined = students.join(courses, student_course_condition)
    print(f"Joined: {joined.tuples}")

if __name__ == "__main__":
    demonstrate_relational_algebra()
```

## 1.6 总结

集合论与类型理论为计算机科学提供了坚实的数学基础。通过严格的数学定义、Python实现和形式化证明，我们建立了从抽象数学概念到具体程序实现的桥梁。
