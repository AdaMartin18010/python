# 数学基础 - 软件设计的数学理论

## 概述

数学基础为软件设计提供形式化的理论支撑，包括集合论、关系理论、函数理论、图论、代数结构等核心数学概念。这些概念为软件系统的建模、分析和验证提供了严格的数学工具。

## 1. 集合论基础

### 1.1 基本概念

**定义 1.1.1 (集合)**
集合是不同对象的无序聚集，每个对象称为集合的元素。

**定义 1.1.2 (软件实体集合)**
软件实体集合 $S = \{s_1, s_2, ..., s_n\}$ 是所有软件组件的集合，其中每个 $s_i$ 表示一个软件组件。

**Python实现**：
```python
from typing import Set, Any, Iterator
from abc import ABC, abstractmethod

class SoftwareEntity(ABC):
    """软件实体抽象基类"""
    
    def __init__(self, name: str, entity_id: str):
        self.name = name
        self.entity_id = entity_id
    
    @abstractmethod
    def get_type(self) -> str:
        """获取实体类型"""
        pass
    
    def __hash__(self):
        return hash(self.entity_id)
    
    def __eq__(self, other):
        return self.entity_id == other.entity_id

class SoftwareEntitySet:
    """软件实体集合"""
    
    def __init__(self):
        self._entities: Set[SoftwareEntity] = set()
    
    def add(self, entity: SoftwareEntity) -> None:
        """添加实体到集合"""
        self._entities.add(entity)
    
    def remove(self, entity: SoftwareEntity) -> None:
        """从集合中移除实体"""
        self._entities.discard(entity)
    
    def contains(self, entity: SoftwareEntity) -> bool:
        """检查集合是否包含实体"""
        return entity in self._entities
    
    def size(self) -> int:
        """获取集合大小"""
        return len(self._entities)
    
    def union(self, other: 'SoftwareEntitySet') -> 'SoftwareEntitySet':
        """集合并集"""
        result = SoftwareEntitySet()
        result._entities = self._entities.union(other._entities)
        return result
    
    def intersection(self, other: 'SoftwareEntitySet') -> 'SoftwareEntitySet':
        """集合交集"""
        result = SoftwareEntitySet()
        result._entities = self._entities.intersection(other._entities)
        return result
    
    def difference(self, other: 'SoftwareEntitySet') -> 'SoftwareEntitySet':
        """集合差集"""
        result = SoftwareEntitySet()
        result._entities = self._entities.difference(other._entities)
        return result
    
    def __iter__(self) -> Iterator[SoftwareEntity]:
        return iter(self._entities)
```

### 1.2 集合运算

**定理 1.1.1 (集合运算性质)**
对于任意软件实体集合 $A, B, C$，以下性质成立：

1. **交换律**: $A \cup B = B \cup A$, $A \cap B = B \cap A$
2. **结合律**: $(A \cup B) \cup C = A \cup (B \cup C)$, $(A \cap B) \cap C = A \cap (B \cap C)$
3. **分配律**: $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$, $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$

*证明*：根据集合论基本定理，这些性质对所有集合都成立。

**Python实现**：
```python
def verify_set_properties():
    """验证集合运算性质"""
    # 创建测试集合
    A = SoftwareEntitySet()
    B = SoftwareEntitySet()
    C = SoftwareEntitySet()
    
    # 添加测试实体
    entities = [
        SoftwareEntity("Component1", "comp1"),
        SoftwareEntity("Component2", "comp2"),
        SoftwareEntity("Component3", "comp3"),
        SoftwareEntity("Component4", "comp4")
    ]
    
    A.add(entities[0])
    A.add(entities[1])
    B.add(entities[1])
    B.add(entities[2])
    C.add(entities[2])
    C.add(entities[3])
    
    # 验证交换律
    assert A.union(B).size() == B.union(A).size()
    assert A.intersection(B).size() == B.intersection(A).size()
    
    # 验证结合律
    assert (A.union(B)).union(C).size() == A.union(B.union(C)).size()
    assert (A.intersection(B)).intersection(C).size() == A.intersection(B.intersection(C)).size()
    
    print("集合运算性质验证通过")
```

## 2. 关系理论

### 2.1 二元关系

**定义 2.1.1 (二元关系)**
设 $A$ 和 $B$ 为两个集合，$A \times B$ 的子集 $R$ 称为从 $A$ 到 $B$ 的二元关系。

**定义 2.1.2 (软件依赖关系)**
软件依赖关系 $D \subseteq S \times S$ 表示软件组件间的依赖关系，其中 $(s_i, s_j) \in D$ 表示组件 $s_i$ 依赖于组件 $s_j$。

**Python实现**：
```python
from typing import Dict, List, Tuple

class BinaryRelation:
    """二元关系"""
    
    def __init__(self, domain: Set[Any], codomain: Set[Any]):
        self.domain = domain
        self.codomain = codomain
        self._pairs: Set[Tuple[Any, Any]] = set()
    
    def add_pair(self, a: Any, b: Any) -> None:
        """添加关系对"""
        if a in self.domain and b in self.codomain:
            self._pairs.add((a, b))
    
    def remove_pair(self, a: Any, b: Any) -> None:
        """移除关系对"""
        self._pairs.discard((a, b))
    
    def contains(self, a: Any, b: Any) -> bool:
        """检查关系是否包含指定对"""
        return (a, b) in self._pairs
    
    def get_related(self, a: Any) -> Set[Any]:
        """获取与a相关的所有元素"""
        return {b for (x, b) in self._pairs if x == a}
    
    def get_inverse_related(self, b: Any) -> Set[Any]:
        """获取与b相关的所有元素（逆关系）"""
        return {a for (a, x) in self._pairs if x == b}
    
    def is_reflexive(self) -> bool:
        """检查是否自反"""
        return all((a, a) in self._pairs for a in self.domain)
    
    def is_symmetric(self) -> bool:
        """检查是否对称"""
        return all((b, a) in self._pairs for (a, b) in self._pairs)
    
    def is_transitive(self) -> bool:
        """检查是否传递"""
        for (a, b) in self._pairs:
            for (c, d) in self._pairs:
                if b == c and (a, d) not in self._pairs:
                    return False
        return True

class SoftwareDependencyRelation(BinaryRelation):
    """软件依赖关系"""
    
    def __init__(self, components: Set[SoftwareEntity]):
        super().__init__(components, components)
        self.components = components
    
    def add_dependency(self, dependent: SoftwareEntity, dependency: SoftwareEntity) -> None:
        """添加依赖关系"""
        self.add_pair(dependent, dependency)
    
    def get_dependencies(self, component: SoftwareEntity) -> Set[SoftwareEntity]:
        """获取组件的所有依赖"""
        return self.get_related(component)
    
    def get_dependents(self, component: SoftwareEntity) -> Set[SoftwareEntity]:
        """获取依赖该组件的所有组件"""
        return self.get_inverse_related(component)
    
    def has_circular_dependency(self) -> bool:
        """检查是否存在循环依赖"""
        # 使用深度优先搜索检测循环
        visited = set()
        rec_stack = set()
        
        def dfs(component: SoftwareEntity) -> bool:
            visited.add(component)
            rec_stack.add(component)
            
            for dep in self.get_dependencies(component):
                if dep not in visited:
                    if dfs(dep):
                        return True
                elif dep in rec_stack:
                    return True
            
            rec_stack.remove(component)
            return False
        
        for component in self.components:
            if component not in visited:
                if dfs(component):
                    return True
        return False
```

### 2.2 关系性质

**定理 2.1.1 (依赖关系性质)**
软件依赖关系 $D$ 具有以下性质：

1. **非自反性**: $\forall s \in S, (s, s) \notin D$
2. **传递性**: 如果 $(s_i, s_j) \in D$ 且 $(s_j, s_k) \in D$，则 $(s_i, s_k) \in D$
3. **反对称性**: 如果 $(s_i, s_j) \in D$ 且 $(s_j, s_i) \in D$，则 $s_i = s_j$

*证明*：
1. 组件不能依赖自身，因此非自反性成立
2. 如果A依赖B，B依赖C，则A间接依赖C，传递性成立
3. 如果A依赖B且B依赖A，则存在循环依赖，违反软件设计原则

**Python实现**：
```python
def analyze_dependency_properties(dependency_relation: SoftwareDependencyRelation) -> Dict[str, bool]:
    """分析依赖关系性质"""
    properties = {}
    
    # 检查非自反性
    properties['irreflexive'] = not any(
        dependency_relation.contains(comp, comp) 
        for comp in dependency_relation.components
    )
    
    # 检查传递性
    properties['transitive'] = dependency_relation.is_transitive()
    
    # 检查反对称性
    properties['antisymmetric'] = not any(
        dependency_relation.contains(a, b) and dependency_relation.contains(b, a) and a != b
        for a in dependency_relation.components
        for b in dependency_relation.components
    )
    
    return properties
```

## 3. 函数理论

### 3.1 函数定义

**定义 3.1.1 (函数)**
从集合 $A$ 到集合 $B$ 的函数 $f: A \rightarrow B$ 是一个关系，满足：
1. $\forall a \in A, \exists b \in B, (a, b) \in f$
2. $\forall a \in A, \forall b_1, b_2 \in B, (a, b_1) \in f \land (a, b_2) \in f \Rightarrow b_1 = b_2$

**定义 3.1.2 (状态转换函数)**
状态转换函数 $T: S \times I \rightarrow S$ 表示在输入 $i \in I$ 作用下，系统从状态 $s \in S$ 转换到新状态 $T(s, i)$。

**Python实现**：
```python
from typing import Callable, TypeVar, Generic

S = TypeVar('S')  # 状态类型
I = TypeVar('I')  # 输入类型
O = TypeVar('O')  # 输出类型

class StateTransitionFunction(Generic[S, I]):
    """状态转换函数"""
    
    def __init__(self, transition_map: Dict[Tuple[S, I], S]):
        self.transition_map = transition_map
    
    def transition(self, state: S, input_val: I) -> S:
        """执行状态转换"""
        return self.transition_map.get((state, input_val), state)
    
    def is_deterministic(self) -> bool:
        """检查是否为确定性函数"""
        return len(self.transition_map) == len(set((s, i) for (s, i), _ in self.transition_map.items()))
    
    def get_reachable_states(self, initial_state: S) -> Set[S]:
        """获取从初始状态可达的所有状态"""
        reachable = {initial_state}
        changed = True
        
        while changed:
            changed = False
            new_states = set()
            for state in reachable:
                for (s, i), next_state in self.transition_map.items():
                    if s == state:
                        if next_state not in reachable:
                            new_states.add(next_state)
                            changed = True
            reachable.update(new_states)
        
        return reachable

class SoftwareSystem(Generic[S, I, O]):
    """软件系统抽象"""
    
    def __init__(self, 
                 initial_state: S,
                 transition_func: StateTransitionFunction[S, I],
                 output_func: Callable[[S, I], O]):
        self.current_state = initial_state
        self.transition_func = transition_func
        self.output_func = output_func
        self.state_history: List[S] = [initial_state]
        self.input_history: List[I] = []
        self.output_history: List[O] = []
    
    def process_input(self, input_val: I) -> O:
        """处理输入并返回输出"""
        # 计算输出
        output = self.output_func(self.current_state, input_val)
        
        # 状态转换
        self.current_state = self.transition_func.transition(self.current_state, input_val)
        
        # 记录历史
        self.state_history.append(self.current_state)
        self.input_history.append(input_val)
        self.output_history.append(output)
        
        return output
    
    def get_current_state(self) -> S:
        """获取当前状态"""
        return self.current_state
    
    def get_state_history(self) -> List[S]:
        """获取状态历史"""
        return self.state_history.copy()
    
    def reset(self, new_initial_state: S) -> None:
        """重置系统状态"""
        self.current_state = new_initial_state
        self.state_history = [new_initial_state]
        self.input_history = []
        self.output_history = []
```

### 3.2 函数性质

**定理 3.1.1 (状态转换函数性质)**
对于状态转换函数 $T: S \times I \rightarrow S$，如果系统是确定性的，则：

1. **确定性**: $\forall s \in S, \forall i \in I, T(s, i)$ 是唯一确定的
2. **可达性**: 从初始状态可达的所有状态构成可达状态集
3. **终止性**: 如果状态空间有限，则系统要么终止，要么进入循环

*证明*：
1. 确定性由函数定义保证
2. 可达性通过可达性分析算法可计算
3. 终止性由鸽巢原理保证

**Python实现**：
```python
def analyze_system_properties(system: SoftwareSystem) -> Dict[str, Any]:
    """分析系统性质"""
    properties = {}
    
    # 确定性检查
    properties['deterministic'] = system.transition_func.is_deterministic()
    
    # 可达性分析
    reachable_states = system.transition_func.get_reachable_states(
        system.state_history[0]
    )
    properties['reachable_states'] = reachable_states
    properties['reachable_count'] = len(reachable_states)
    
    # 终止性分析（简化版本）
    if len(reachable_states) < float('inf'):
        properties['finite_state_space'] = True
        properties['termination_guaranteed'] = True
    else:
        properties['finite_state_space'] = False
        properties['termination_guaranteed'] = False
    
    return properties
```

## 4. 图论基础

### 4.1 图的基本概念

**定义 4.1.1 (有向图)**
有向图 $G = (V, E)$ 由顶点集 $V$ 和边集 $E \subseteq V \times V$ 组成。

**定义 4.1.2 (依赖图)**
软件依赖图 $G_D = (S, D)$ 是一个有向图，其中 $S$ 是软件组件集合，$D$ 是依赖关系集合。

**Python实现**：
```python
from collections import defaultdict, deque

class DirectedGraph:
    """有向图"""
    
    def __init__(self):
        self.vertices: Set[Any] = set()
        self.edges: Dict[Any, Set[Any]] = defaultdict(set)
        self.in_edges: Dict[Any, Set[Any]] = defaultdict(set)
    
    def add_vertex(self, vertex: Any) -> None:
        """添加顶点"""
        self.vertices.add(vertex)
    
    def add_edge(self, from_vertex: Any, to_vertex: Any) -> None:
        """添加边"""
        self.vertices.add(from_vertex)
        self.vertices.add(to_vertex)
        self.edges[from_vertex].add(to_vertex)
        self.in_edges[to_vertex].add(from_vertex)
    
    def remove_edge(self, from_vertex: Any, to_vertex: Any) -> None:
        """移除边"""
        self.edges[from_vertex].discard(to_vertex)
        self.in_edges[to_vertex].discard(from_vertex)
    
    def get_neighbors(self, vertex: Any) -> Set[Any]:
        """获取顶点的邻居"""
        return self.edges[vertex]
    
    def get_in_neighbors(self, vertex: Any) -> Set[Any]:
        """获取顶点的入邻居"""
        return self.in_edges[vertex]
    
    def get_out_degree(self, vertex: Any) -> int:
        """获取顶点的出度"""
        return len(self.edges[vertex])
    
    def get_in_degree(self, vertex: Any) -> int:
        """获取顶点的入度"""
        return len(self.in_edges[vertex])
    
    def is_acyclic(self) -> bool:
        """检查是否为有向无环图"""
        # 使用拓扑排序检测环
        in_degree = {v: self.get_in_degree(v) for v in self.vertices}
        queue = deque([v for v in self.vertices if in_degree[v] == 0])
        visited = 0
        
        while queue:
            vertex = queue.popleft()
            visited += 1
            
            for neighbor in self.get_neighbors(vertex):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return visited == len(self.vertices)
    
    def topological_sort(self) -> List[Any]:
        """拓扑排序"""
        if not self.is_acyclic():
            raise ValueError("图包含环，无法进行拓扑排序")
        
        in_degree = {v: self.get_in_degree(v) for v in self.vertices}
        queue = deque([v for v in self.vertices if in_degree[v] == 0])
        result = []
        
        while queue:
            vertex = queue.popleft()
            result.append(vertex)
            
            for neighbor in self.get_neighbors(vertex):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result

class DependencyGraph(DirectedGraph):
    """软件依赖图"""
    
    def __init__(self):
        super().__init__()
        self.components: Dict[str, SoftwareEntity] = {}
    
    def add_component(self, component: SoftwareEntity) -> None:
        """添加组件"""
        self.add_vertex(component.entity_id)
        self.components[component.entity_id] = component
    
    def add_dependency(self, dependent: SoftwareEntity, dependency: SoftwareEntity) -> None:
        """添加依赖关系"""
        self.add_component(dependent)
        self.add_component(dependency)
        self.add_edge(dependent.entity_id, dependency.entity_id)
    
    def get_dependencies(self, component: SoftwareEntity) -> Set[SoftwareEntity]:
        """获取组件的依赖"""
        return {self.components[dep_id] for dep_id in self.get_neighbors(component.entity_id)}
    
    def get_dependents(self, component: SoftwareEntity) -> Set[SoftwareEntity]:
        """获取依赖该组件的组件"""
        return {self.components[dep_id] for dep_id in self.get_in_neighbors(component.entity_id)}
    
    def get_build_order(self) -> List[SoftwareEntity]:
        """获取构建顺序（拓扑排序）"""
        sorted_ids = self.topological_sort()
        return [self.components[comp_id] for comp_id in sorted_ids]
    
    def has_circular_dependencies(self) -> bool:
        """检查是否存在循环依赖"""
        return not self.is_acyclic()
```

### 4.2 图的性质

**定理 4.1.1 (依赖图性质)**
软件依赖图 $G_D$ 具有以下性质：

1. **无环性**: 理想的依赖图应该是无环的，即 $G_D$ 是有向无环图(DAG)
2. **连通性**: 如果系统是连通的，则依赖图是弱连通的
3. **层次性**: 可以通过拓扑排序确定组件的构建顺序

*证明*：
1. 循环依赖会导致构建失败，因此理想情况下应该避免
2. 连通性确保所有组件都能被构建
3. 拓扑排序提供了有效的构建顺序

**Python实现**：
```python
def analyze_dependency_graph(graph: DependencyGraph) -> Dict[str, Any]:
    """分析依赖图性质"""
    analysis = {}
    
    # 检查无环性
    analysis['is_acyclic'] = graph.is_acyclic()
    
    # 检查连通性
    analysis['is_connected'] = len(graph.vertices) == 0 or all(
        len(graph.get_neighbors(v)) > 0 or len(graph.get_in_neighbors(v)) > 0
        for v in graph.vertices
    )
    
    # 计算统计信息
    analysis['component_count'] = len(graph.vertices)
    analysis['dependency_count'] = sum(len(graph.edges[v]) for v in graph.vertices)
    
    # 计算平均依赖度
    if graph.vertices:
        analysis['avg_out_degree'] = analysis['dependency_count'] / len(graph.vertices)
        analysis['avg_in_degree'] = analysis['dependency_count'] / len(graph.vertices)
    else:
        analysis['avg_out_degree'] = 0
        analysis['avg_in_degree'] = 0
    
    # 获取构建顺序
    if analysis['is_acyclic']:
        analysis['build_order'] = graph.get_build_order()
    else:
        analysis['build_order'] = None
    
    return analysis
```

## 5. 代数结构

### 5.1 半群和群

**定义 5.1.1 (半群)**
半群 $(S, \circ)$ 是一个集合 $S$ 和一个满足结合律的二元运算 $\circ: S \times S \rightarrow S$。

**定义 5.1.2 (软件操作半群)**
软件操作半群 $(O, \circ)$ 是所有可能的软件操作的集合，其中 $\circ$ 表示操作的组合。

**Python实现**：
```python
from typing import Protocol

class SoftwareOperation(Protocol):
    """软件操作协议"""
    
    def execute(self, context: Any) -> Any:
        """执行操作"""
        ...
    
    def get_name(self) -> str:
        """获取操作名称"""
        ...

class OperationComposition:
    """操作组合"""
    
    def __init__(self, operations: List[SoftwareOperation]):
        self.operations = operations
    
    def execute(self, context: Any) -> Any:
        """顺序执行所有操作"""
        result = context
        for operation in self.operations:
            result = operation.execute(result)
        return result
    
    def get_name(self) -> str:
        """获取组合操作名称"""
        return " -> ".join(op.get_name() for op in self.operations)

class SoftwareOperationSemigroup:
    """软件操作半群"""
    
    def __init__(self):
        self.operations: Dict[str, SoftwareOperation] = {}
        self.composition_cache: Dict[Tuple[str, str], OperationComposition] = {}
    
    def add_operation(self, operation: SoftwareOperation) -> None:
        """添加操作"""
        self.operations[operation.get_name()] = operation
    
    def compose(self, op1_name: str, op2_name: str) -> OperationComposition:
        """组合两个操作"""
        if (op1_name, op2_name) in self.composition_cache:
            return self.composition_cache[(op1_name, op2_name)]
        
        if op1_name not in self.operations or op2_name not in self.operations:
            raise ValueError(f"操作 {op1_name} 或 {op2_name} 不存在")
        
        composition = OperationComposition([
            self.operations[op1_name],
            self.operations[op2_name]
        ])
        
        self.composition_cache[(op1_name, op2_name)] = composition
        return composition
    
    def execute_sequence(self, sequence: List[str], context: Any) -> Any:
        """执行操作序列"""
        if not sequence:
            return context
        
        result = context
        for op_name in sequence:
            if op_name in self.operations:
                result = self.operations[op_name].execute(result)
            else:
                raise ValueError(f"操作 {op_name} 不存在")
        
        return result
```

### 5.2 格结构

**定义 5.1.3 (格)**
格 $(L, \leq)$ 是一个偏序集，其中任意两个元素都有最小上界和最大下界。

**定义 5.1.4 (抽象层次格)**
软件抽象层次格 $(H, \leq)$ 是所有抽象层次的集合，其中 $h_1 \leq h_2$ 表示 $h_1$ 比 $h_2$ 更抽象。

**Python实现**：
```python
from typing import Optional

class AbstractionLevel:
    """抽象层次"""
    
    def __init__(self, name: str, level: int, description: str):
        self.name = name
        self.level = level  # 数值越小越抽象
        self.description = description
    
    def __le__(self, other: 'AbstractionLevel') -> bool:
        """比较抽象程度"""
        return self.level <= other.level
    
    def __eq__(self, other: 'AbstractionLevel') -> bool:
        """相等性比较"""
        return self.level == other.level
    
    def __hash__(self):
        return hash(self.level)

class AbstractionLattice:
    """抽象层次格"""
    
    def __init__(self):
        self.levels: List[AbstractionLevel] = []
    
    def add_level(self, level: AbstractionLevel) -> None:
        """添加抽象层次"""
        self.levels.append(level)
        self.levels.sort(key=lambda x: x.level)
    
    def get_least_upper_bound(self, level1: AbstractionLevel, level2: AbstractionLevel) -> Optional[AbstractionLevel]:
        """获取最小上界"""
        candidates = [level for level in self.levels 
                     if level >= level1 and level >= level2]
        if candidates:
            return min(candidates, key=lambda x: x.level)
        return None
    
    def get_greatest_lower_bound(self, level1: AbstractionLevel, level2: AbstractionLevel) -> Optional[AbstractionLevel]:
        """获取最大下界"""
        candidates = [level for level in self.levels 
                     if level <= level1 and level <= level2]
        if candidates:
            return max(candidates, key=lambda x: x.level)
        return None
    
    def get_levels_between(self, lower: AbstractionLevel, upper: AbstractionLevel) -> List[AbstractionLevel]:
        """获取两个层次之间的所有层次"""
        return [level for level in self.levels 
                if lower <= level <= upper]
    
    def get_concrete_levels(self, abstract_level: AbstractionLevel) -> List[AbstractionLevel]:
        """获取比指定层次更具体的所有层次"""
        return [level for level in self.levels if level >= abstract_level]
    
    def get_abstract_levels(self, concrete_level: AbstractionLevel) -> List[AbstractionLevel]:
        """获取比指定层次更抽象的所有层次"""
        return [level for level in self.levels if level <= concrete_level]
```

## 6. 概率论基础

### 6.1 概率分布

**定义 6.1.1 (离散概率分布)**
离散概率分布 $P: X \rightarrow [0,1]$ 满足 $\sum_{x \in X} P(x) = 1$。

**定义 6.1.2 (软件可靠性分布)**
软件可靠性分布 $R(t)$ 表示软件在时间 $t$ 正常运行的概率。

**Python实现**：
```python
import random
from typing import Dict, List, Tuple

class DiscreteProbabilityDistribution:
    """离散概率分布"""
    
    def __init__(self, probabilities: Dict[Any, float]):
        self.probabilities = probabilities
        self._validate()
    
    def _validate(self) -> None:
        """验证概率分布的有效性"""
        total = sum(self.probabilities.values())
        if not (0.99 <= total <= 1.01):  # 允许小的浮点误差
            raise ValueError(f"概率总和必须为1，当前为{total}")
        
        if any(p < 0 for p in self.probabilities.values()):
            raise ValueError("概率值不能为负数")
    
    def probability(self, event: Any) -> float:
        """获取事件概率"""
        return self.probabilities.get(event, 0.0)
    
    def expected_value(self) -> float:
        """计算期望值"""
        return sum(event * prob for event, prob in self.probabilities.items())
    
    def variance(self) -> float:
        """计算方差"""
        mean = self.expected_value()
        return sum(prob * (event - mean) ** 2 for event, prob in self.probabilities.items())
    
    def sample(self, n: int = 1) -> List[Any]:
        """采样"""
        events = list(self.probabilities.keys())
        probabilities = list(self.probabilities.values())
        return random.choices(events, weights=probabilities, k=n)

class SoftwareReliabilityModel:
    """软件可靠性模型"""
    
    def __init__(self, failure_rate: float, initial_reliability: float = 1.0):
        self.failure_rate = failure_rate  # 故障率
        self.initial_reliability = initial_reliability
    
    def reliability_at_time(self, t: float) -> float:
        """计算时间t的可靠性"""
        # 指数分布模型
        return self.initial_reliability * math.exp(-self.failure_rate * t)
    
    def mean_time_to_failure(self) -> float:
        """平均故障时间"""
        return 1.0 / self.failure_rate
    
    def probability_of_failure_before(self, t: float) -> float:
        """在时间t之前发生故障的概率"""
        return 1.0 - self.reliability_at_time(t)
    
    def expected_failures_in_interval(self, t1: float, t2: float) -> float:
        """在时间区间[t1, t2]内期望的故障次数"""
        return self.failure_rate * (t2 - t1)
```

### 6.2 随机过程

**定义 6.1.3 (马尔可夫链)**
马尔可夫链是一个随机过程，满足无记忆性：$P(X_{n+1} = x | X_n = x_n, ..., X_0 = x_0) = P(X_{n+1} = x | X_n = x_n)$。

**Python实现**：
```python
import numpy as np

class MarkovChain:
    """马尔可夫链"""
    
    def __init__(self, states: List[Any], transition_matrix: List[List[float]]):
        self.states = states
        self.transition_matrix = np.array(transition_matrix)
        self.state_to_index = {state: i for i, state in enumerate(states)}
        self._validate_transition_matrix()
    
    def _validate_transition_matrix(self) -> None:
        """验证转移矩阵的有效性"""
        if self.transition_matrix.shape != (len(self.states), len(self.states)):
            raise ValueError("转移矩阵维度不匹配")
        
        for row in self.transition_matrix:
            if not (0.99 <= sum(row) <= 1.01):
                raise ValueError("每行概率和必须为1")
    
    def transition_probability(self, from_state: Any, to_state: Any) -> float:
        """获取转移概率"""
        i = self.state_to_index[from_state]
        j = self.state_to_index[to_state]
        return self.transition_matrix[i, j]
    
    def next_state(self, current_state: Any) -> Any:
        """生成下一个状态"""
        i = self.state_to_index[current_state]
        probabilities = self.transition_matrix[i]
        return random.choices(self.states, weights=probabilities)[0]
    
    def simulate(self, initial_state: Any, steps: int) -> List[Any]:
        """模拟马尔可夫链"""
        path = [initial_state]
        current_state = initial_state
        
        for _ in range(steps - 1):
            current_state = self.next_state(current_state)
            path.append(current_state)
        
        return path
    
    def stationary_distribution(self) -> Dict[Any, float]:
        """计算平稳分布"""
        # 使用特征值分解
        eigenvalues, eigenvectors = np.linalg.eig(self.transition_matrix.T)
        
        # 找到特征值为1的特征向量
        stationary_idx = np.argmin(np.abs(eigenvalues - 1))
        stationary_vector = eigenvectors[:, stationary_idx].real
        
        # 归一化
        stationary_vector = stationary_vector / stationary_vector.sum()
        
        return {state: stationary_vector[i] for i, state in enumerate(self.states)}
```

## 7. 信息论基础

### 7.1 信息熵

**定义 7.1.1 (信息熵)**
离散随机变量 $X$ 的信息熵定义为：$H(X) = -\sum_{x} P(x) \log P(x)$。

**定义 7.1.2 (软件复杂度熵)**
软件复杂度熵 $H(C)$ 表示软件系统复杂度的不确定性度量。

**Python实现**：
```python
import math

class InformationTheory:
    """信息论工具"""
    
    @staticmethod
    def entropy(probabilities: List[float]) -> float:
        """计算信息熵"""
        return -sum(p * math.log2(p) for p in probabilities if p > 0)
    
    @staticmethod
    def joint_entropy(probabilities: List[List[float]]) -> float:
        """计算联合熵"""
        total_entropy = 0
        for row in probabilities:
            for p in row:
                if p > 0:
                    total_entropy -= p * math.log2(p)
        return total_entropy
    
    @staticmethod
    def conditional_entropy(probabilities: List[List[float]]) -> float:
        """计算条件熵"""
        # 计算边缘概率
        marginal_prob = [sum(row) for row in probabilities]
        
        conditional_entropy = 0
        for i, row in enumerate(probabilities):
            if marginal_prob[i] > 0:
                for p in row:
                    if p > 0:
                        conditional_entropy -= p * math.log2(p / marginal_prob[i])
        
        return conditional_entropy
    
    @staticmethod
    def mutual_information(probabilities: List[List[float]]) -> float:
        """计算互信息"""
        joint_entropy = InformationTheory.joint_entropy(probabilities)
        marginal_entropy_x = InformationTheory.entropy([sum(row) for row in probabilities])
        marginal_entropy_y = InformationTheory.entropy([sum(col) for col in zip(*probabilities)])
        
        return marginal_entropy_x + marginal_entropy_y - joint_entropy

class SoftwareComplexityAnalysis:
    """软件复杂度分析"""
    
    def __init__(self):
        self.metrics = {}
    
    def calculate_cyclomatic_complexity(self, control_flow_graph: Dict[str, List[str]]) -> int:
        """计算圈复杂度"""
        edges = sum(len(neighbors) for neighbors in control_flow_graph.values())
        nodes = len(control_flow_graph)
        return edges - nodes + 2
    
    def calculate_halstead_complexity(self, 
                                    operators: Dict[str, int], 
                                    operands: Dict[str, int]) -> Dict[str, float]:
        """计算Halstead复杂度"""
        n1 = len(operators)  # 不同操作符数量
        n2 = len(operands)   # 不同操作数数量
        N1 = sum(operators.values())  # 操作符总数
        N2 = sum(operands.values())   # 操作数总数
        
        # 程序长度
        N = N1 + N2
        
        # 程序词汇量
        n = n1 + n2
        
        # 程序难度
        D = (n1 * N2) / (2 * n2) if n2 > 0 else 0
        
        # 程序工作量
        E = D * N
        
        # 程序时间
        T = E / 18
        
        # 程序错误数
        B = E ** (2/3) / 3000
        
        return {
            'length': N,
            'vocabulary': n,
            'difficulty': D,
            'effort': E,
            'time': T,
            'bugs': B
        }
    
    def calculate_information_entropy(self, code_metrics: Dict[str, float]) -> float:
        """计算代码信息熵"""
        total = sum(code_metrics.values())
        if total == 0:
            return 0
        
        probabilities = [value / total for value in code_metrics.values()]
        return InformationTheory.entropy(probabilities)
```

## 总结

数学基础为软件设计提供了严格的理论支撑。通过集合论、关系理论、函数理论、图论、代数结构、概率论和信息论等数学工具，我们可以：

1. **形式化建模**：将软件系统抽象为数学对象
2. **性质分析**：分析系统的结构性质和动态性质
3. **优化设计**：基于数学理论优化系统设计
4. **质量保证**：通过数学方法保证系统质量

这些数学基础为后续的理论层、具体科学层和行业应用层提供了坚实的理论基础。

---

*本章建立了软件设计的数学基础，为后续各层次的理论和应用提供了形式化工具。*
