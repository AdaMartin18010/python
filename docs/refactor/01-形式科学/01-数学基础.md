# 01.1 数学基础

## 📋 概述

数学是软件工程和计算科学的理论基础，为算法设计、数据结构、形式化验证等提供严格的数学工具。本章节从形式化角度介绍软件工程中常用的数学基础，包括集合论、函数论、代数结构、图论等。

## 🎯 核心概念

### 1. 集合论基础

#### 1.1 集合的形式化定义

**定义 1.1.1** 集合 $A$ 是一个数学对象，满足：

$$A = \{x | P(x)\}$$

其中 $P(x)$ 是谓词，表示元素 $x$ 属于集合 $A$ 的条件。

**定义 1.1.2** 集合运算：

- **并集**: $A \cup B = \{x | x \in A \lor x \in B\}$
- **交集**: $A \cap B = \{x | x \in A \land x \in B\}$
- **差集**: $A \setminus B = \{x | x \in A \land x \notin B\}$
- **补集**: $A^c = \{x | x \notin A\}$

**Python 实现**：

```python
from typing import Set, Any, Callable, TypeVar, Generic
from abc import ABC, abstractmethod
import math

T = TypeVar('T')

class Set(Generic[T]):
    """集合抽象基类"""
    
    def __init__(self, elements: Set[T] = None):
        self._elements = elements or set()
    
    def add(self, element: T):
        """添加元素"""
        self._elements.add(element)
    
    def remove(self, element: T):
        """移除元素"""
        self._elements.discard(element)
    
    def contains(self, element: T) -> bool:
        """检查元素是否属于集合"""
        return element in self._elements
    
    def union(self, other: 'Set[T]') -> 'Set[T]':
        """并集"""
        return Set(self._elements | other._elements)
    
    def intersection(self, other: 'Set[T]') -> 'Set[T]':
        """交集"""
        return Set(self._elements & other._elements)
    
    def difference(self, other: 'Set[T]') -> 'Set[T]':
        """差集"""
        return Set(self._elements - other._elements)
    
    def complement(self, universe: 'Set[T]') -> 'Set[T]':
        """补集"""
        return universe.difference(self)
    
    def is_subset(self, other: 'Set[T]') -> bool:
        """检查是否为子集"""
        return self._elements.issubset(other._elements)
    
    def is_superset(self, other: 'Set[T]') -> bool:
        """检查是否为超集"""
        return self._elements.issuperset(other._elements)
    
    def size(self) -> int:
        """集合大小"""
        return len(self._elements)
    
    def is_empty(self) -> bool:
        """检查是否为空集"""
        return len(self._elements) == 0
    
    def __iter__(self):
        return iter(self._elements)
    
    def __str__(self):
        return f"Set({self._elements})"

class FiniteSet(Set[T]):
    """有限集合"""
    
    def __init__(self, elements: Set[T]):
        super().__init__(elements)
        if not self._is_finite():
            raise ValueError("集合必须是有限的")
    
    def _is_finite(self) -> bool:
        """检查是否为有限集合"""
        return len(self._elements) < float('inf')
    
    def power_set(self) -> 'Set[Set[T]]':
        """幂集"""
        elements_list = list(self._elements)
        power_set_elements = set()
        
        # 生成所有子集
        for i in range(2 ** len(elements_list)):
            subset = set()
            for j in range(len(elements_list)):
                if i & (1 << j):
                    subset.add(elements_list[j])
            power_set_elements.add(frozenset(subset))
        
        return Set(power_set_elements)

class InfiniteSet(Set[T]):
    """无限集合"""
    
    def __init__(self, predicate: Callable[[T], bool]):
        self.predicate = predicate
        super().__init__()
    
    def contains(self, element: T) -> bool:
        """检查元素是否属于集合"""
        return self.predicate(element)
    
    def size(self) -> float:
        """集合大小（无限）"""
        return float('inf')

# 使用示例
def demonstrate_set_operations():
    """演示集合运算"""
    # 创建有限集合
    set_a = FiniteSet({1, 2, 3, 4, 5})
    set_b = FiniteSet({4, 5, 6, 7, 8})
    
    print(f"集合 A: {set_a}")
    print(f"集合 B: {set_b}")
    
    # 基本运算
    union_set = set_a.union(set_b)
    intersection_set = set_a.intersection(set_b)
    difference_set = set_a.difference(set_b)
    
    print(f"并集 A ∪ B: {union_set}")
    print(f"交集 A ∩ B: {intersection_set}")
    print(f"差集 A - B: {difference_set}")
    
    # 子集关系
    subset = FiniteSet({1, 2})
    print(f"{subset} 是 {set_a} 的子集: {subset.is_subset(set_a)}")
    
    # 幂集
    small_set = FiniteSet({1, 2})
    power_set = small_set.power_set()
    print(f"{small_set} 的幂集: {power_set}")
    
    return set_a, set_b, union_set, intersection_set, difference_set
```

#### 1.2 关系与函数

**定义 1.2.1** 关系 $R$ 是集合 $A \times B$ 的子集：

$$R \subseteq A \times B$$

**定义 1.2.2** 函数 $f: A \rightarrow B$ 是满足以下条件的关系：

$$\forall a \in A, \exists! b \in B: (a, b) \in f$$

**Python 实现**：

```python
from typing import Dict, List, Tuple, Optional, Callable

class Relation(Generic[T, U]):
    """关系类"""
    
    def __init__(self, pairs: Set[Tuple[T, U]]):
        self.pairs = pairs
    
    def domain(self) -> Set[T]:
        """定义域"""
        return {pair[0] for pair in self.pairs}
    
    def codomain(self) -> Set[U]:
        """陪域"""
        return {pair[1] for pair in self.pairs}
    
    def is_function(self) -> bool:
        """检查是否为函数"""
        domain_elements = self.domain()
        for element in domain_elements:
            images = {pair[1] for pair in self.pairs if pair[0] == element}
            if len(images) != 1:
                return False
        return True
    
    def apply(self, element: T) -> Optional[U]:
        """应用关系（如果是函数）"""
        if not self.is_function():
            raise ValueError("关系不是函数")
        
        for pair in self.pairs:
            if pair[0] == element:
                return pair[1]
        return None

class Function(Generic[T, U]):
    """函数类"""
    
    def __init__(self, mapping: Dict[T, U]):
        self.mapping = mapping
    
    def domain(self) -> Set[T]:
        """定义域"""
        return set(self.mapping.keys())
    
    def codomain(self) -> Set[U]:
        """陪域"""
        return set(self.mapping.values())
    
    def apply(self, element: T) -> U:
        """应用函数"""
        if element not in self.mapping:
            raise ValueError(f"元素 {element} 不在函数定义域中")
        return self.mapping[element]
    
    def is_injective(self) -> bool:
        """检查是否为单射"""
        values = list(self.mapping.values())
        return len(values) == len(set(values))
    
    def is_surjective(self, codomain: Set[U]) -> bool:
        """检查是否为满射"""
        return self.codomain() == codomain
    
    def is_bijective(self, codomain: Set[U]) -> bool:
        """检查是否为双射"""
        return self.is_injective() and self.is_surjective(codomain)
    
    def inverse(self) -> 'Function[U, T]':
        """求逆函数（如果存在）"""
        if not self.is_bijective(self.codomain()):
            raise ValueError("函数不是双射，无法求逆")
        
        inverse_mapping = {v: k for k, v in self.mapping.items()}
        return Function(inverse_mapping)
    
    def compose(self, other: 'Function[U, V]') -> 'Function[T, V]':
        """函数复合"""
        composed_mapping = {}
        for x in self.domain():
            y = self.apply(x)
            if y in other.domain():
                composed_mapping[x] = other.apply(y)
        
        return Function(composed_mapping)

# 使用示例
def demonstrate_functions():
    """演示函数操作"""
    # 创建函数
    f = Function({1: 'a', 2: 'b', 3: 'c'})
    g = Function({'a': 'x', 'b': 'y', 'c': 'z'})
    
    print(f"函数 f: {f.mapping}")
    print(f"函数 g: {g.mapping}")
    
    # 函数性质
    print(f"f 是单射: {f.is_injective()}")
    print(f"f 是满射: {f.is_surjective({'a', 'b', 'c'})}")
    print(f"f 是双射: {f.is_bijective({'a', 'b', 'c'})}")
    
    # 函数应用
    print(f"f(1) = {f.apply(1)}")
    
    # 函数复合
    h = f.compose(g)
    print(f"复合函数 h = g ∘ f: {h.mapping}")
    
    return f, g, h
```

### 2. 代数结构

#### 2.1 群论基础

**定义 2.1.1** 群 $(G, \circ)$ 是一个集合 $G$ 和二元运算 $\circ$，满足：

1. **封闭性**: $\forall a, b \in G: a \circ b \in G$
2. **结合律**: $\forall a, b, c \in G: (a \circ b) \circ c = a \circ (b \circ c)$
3. **单位元**: $\exists e \in G: \forall a \in G: e \circ a = a \circ e = a$
4. **逆元**: $\forall a \in G: \exists a^{-1} \in G: a \circ a^{-1} = a^{-1} \circ a = e$

**Python 实现**：

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class Group(ABC):
    """群抽象基类"""
    
    def __init__(self, elements: Set[Any], operation: callable, identity: T):
        self.elements = elements
        self.operation = operation
        self.identity = identity
        self._inverses = {}
        self._validate_group_axioms()
    
    def _validate_group_axioms(self):
        """验证群公理"""
        # 验证封闭性
        for a in self.elements.iterator():
            for b in self.elements.iterator():
                result = self.operation(a, b)
                if not self.elements.contains(result):
                    raise ValueError(f"Operation not closed: {a} * {b} = {result}")
        
        # 验证单位元
        for a in self.elements.iterator():
            if self.operation(self.identity, a) != a or self.operation(a, self.identity) != a:
                raise ValueError(f"Identity element {self.identity} is not valid")
        
        # 计算逆元
        for a in self.elements.iterator():
            for b in self.elements.iterator():
                if (self.operation(a, b) == self.identity and 
                    self.operation(b, a) == self.identity):
                    self._inverses[a] = b
                    break
        
        # 验证每个元素都有逆元
        for a in self.elements.iterator():
            if a not in self._inverses:
                raise ValueError(f"Element {a} has no inverse")
    
    def multiply(self, a: T, b: T) -> T:
        """群运算"""
        if not (self.elements.contains(a) and self.elements.contains(b)):
            raise ValueError("Elements not in group")
        return self.operation(a, b)
    
    def inverse(self, a: T) -> T:
        """求逆元"""
        if not self.elements.contains(a):
            raise ValueError("Element not in group")
        return self._inverses[a]
    
    def order(self) -> int:
        """群的阶"""
        return self.elements.size()
    
    def is_abelian(self) -> bool:
        """检查是否为阿贝尔群"""
        for a in self.elements.iterator():
            for b in self.elements.iterator():
                if self.operation(a, b) != self.operation(b, a):
                    return False
        return True

class IntegerGroup(Group[int]):
    """整数加法群"""
    
    def __init__(self, modulus: int):
        self.modulus = modulus
        elements = set(range(modulus))
        super().__init__(elements, self._add_mod, 0)
    
    def _add_mod(self, a: int, b: int) -> int:
        """模加法"""
        return (a + b) % self.modulus
    
    def _find_identity(self) -> int:
        """找到单位元（0）"""
        return 0
    
    def _find_inverses(self) -> Dict[int, int]:
        """找到所有元素的逆元"""
        inverses = {}
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) == 0:
                    inverses[a] = b
                    break
        return inverses

class PermutationGroup(Group[List[int]]):
    """置换群"""
    
    def __init__(self, n: int):
        self.n = n
        elements = self._generate_permutations(n)
        super().__init__(elements, self._compose_permutations, list(range(n)))
    
    def _generate_permutations(self, n: int) -> Set[List[int]]:
        """生成所有置换"""
        if n == 1:
            return {[0]}
        
        perms = set()
        for perm in self._generate_permutations(n - 1):
            for i in range(n):
                new_perm = perm[:i] + [n-1] + perm[i:]
                perms.add(tuple(new_perm))
        
        return {list(perm) for perm in perms}
    
    def _compose_permutations(self, p1: List[int], p2: List[int]) -> List[int]:
        """置换复合"""
        return [p1[p2[i]] for i in range(len(p1))]
    
    def _find_identity(self) -> List[int]:
        """找到单位元（恒等置换）"""
        return list(range(self.n))
    
    def _find_inverses(self) -> Dict[List[int], List[int]]:
        """找到所有元素的逆元"""
        inverses = {}
        for perm in self.elements:
            inverse = [0] * self.n
            for i in range(self.n):
                inverse[perm[i]] = i
            inverses[tuple(perm)] = inverse
        return {list(k): v for k, v in inverses.items()}

# 使用示例
def demonstrate_groups():
    """演示群论"""
    # 整数加法群
    z5 = IntegerGroup(5)
    print(f"Z5 是群: {z5.is_abelian()}")
    print(f"Z5 是阿贝尔群: {z5.is_abelian()}")
    print(f"Z5 的阶: {z5.order()}")
    
    # 置换群
    s3 = PermutationGroup(3)
    print(f"S3 是群: {s3.is_abelian()}")
    print(f"S3 的阶: {s3.order()}")
    print(f"S3 是阿贝尔群: {s3.is_abelian()}")
    
    return z5, s3
```

#### 2.2 环与域

**定义 2.2.1** 环 $(R, +, \cdot)$ 是一个集合 $R$ 和两个二元运算 $+$ 和 $\cdot$，满足：

1. $(R, +)$ 是阿贝尔群
2. $(R, \cdot)$ 是半群
3. **分配律**: $\forall a, b, c \in R: a \cdot (b + c) = a \cdot b + a \cdot c$

**Python 实现**：

```python
class Ring(ABC):
    """环抽象基类"""
    
    def __init__(self, elements: Set[Any], addition: callable, multiplication: callable):
        self.elements = elements
        self.addition = addition
        self.multiplication = multiplication
    
    def is_ring(self) -> bool:
        """检查是否为环"""
        # 检查加法群性质
        additive_group = self._create_additive_group()
        if not additive_group.is_group() or not additive_group.is_abelian():
            return False
        
        # 检查乘法半群性质
        if not self._is_multiplicative_semigroup():
            return False
        
        # 检查分配律
        return self._satisfies_distributivity()
    
    def _create_additive_group(self) -> Group:
        """创建加法群"""
        return Group(self.elements, self.addition, 0)
    
    def _is_multiplicative_semigroup(self) -> bool:
        """检查乘法半群性质"""
        # 封闭性
        for a in self.elements:
            for b in self.elements:
                if self.multiplication(a, b) not in self.elements:
                    return False
        
        # 结合律
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    left = self.multiplication(self.multiplication(a, b), c)
                    right = self.multiplication(a, self.multiplication(b, c))
                    if left != right:
                        return False
        
        return True
    
    def _satisfies_distributivity(self) -> bool:
        """检查分配律"""
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    left = self.multiplication(a, self.addition(b, c))
                    right = self.addition(self.multiplication(a, b), self.multiplication(a, c))
                    if left != right:
                        return False
        return True

class IntegerRing(Ring[int]):
    """整数环"""
    
    def __init__(self, modulus: int):
        self.modulus = modulus
        elements = set(range(modulus))
        super().__init__(elements, self._add_mod, self._mul_mod)
    
    def _add_mod(self, a: int, b: int) -> int:
        """模加法"""
        return (a + b) % self.modulus
    
    def _mul_mod(self, a: int, b: int) -> int:
        """模乘法"""
        return (a * b) % self.modulus
```

### 3. 图论基础

#### 3.1 图的基本概念

**定义 3.1.1** 图 $G = (V, E)$ 由顶点集 $V$ 和边集 $E$ 组成，其中 $E \subseteq V \times V$。

**定义 3.1.2** 图的类型：

- **无向图**: $E$ 中的边是无序对
- **有向图**: $E$ 中的边是有序对
- **加权图**: 边有权重函数 $w: E \rightarrow \mathbb{R}$

**Python 实现**：

```python
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt

class Graph:
    """图基类"""
    
    def __init__(self, directed: bool = False, weighted: bool = False):
        self.vertices = set()
        self.edges = set()
        self.directed = directed
        self.weighted = weighted
        self.weights = {}
        self.adjacency_list = {}
    
    def add_vertex(self, vertex: Any):
        """添加顶点"""
        self.vertices.add(vertex)
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = []
    
    def add_edge(self, u: Any, v: Any, weight: float = 1.0):
        """添加边"""
        if u not in self.vertices:
            self.add_vertex(u)
        if v not in self.vertices:
            self.add_vertex(v)
        
        if self.directed:
            edge = (u, v)
        else:
            edge = tuple(sorted([u, v]))
        
        self.edges.add(edge)
        self.adjacency_list[u].append(v)
        
        if not self.directed:
            self.adjacency_list[v].append(u)
        
        if self.weighted:
            self.weights[edge] = weight
    
    def remove_vertex(self, vertex: Any):
        """移除顶点"""
        if vertex in self.vertices:
            self.vertices.remove(vertex)
            
            # 移除相关边
            edges_to_remove = set()
            for edge in self.edges:
                if vertex in edge:
                    edges_to_remove.add(edge)
            
            for edge in edges_to_remove:
                self.edges.remove(edge)
                if self.weighted and edge in self.weights:
                    del self.weights[edge]
            
            # 更新邻接表
            if vertex in self.adjacency_list:
                del self.adjacency_list[vertex]
            
            for adj_list in self.adjacency_list.values():
                if vertex in adj_list:
                    adj_list.remove(vertex)
    
    def remove_edge(self, u: Any, v: Any):
        """移除边"""
        if self.directed:
            edge = (u, v)
        else:
            edge = tuple(sorted([u, v]))
        
        if edge in self.edges:
            self.edges.remove(edge)
            self.adjacency_list[u].remove(v)
            
            if not self.directed:
                self.adjacency_list[v].remove(u)
            
            if self.weighted and edge in self.weights:
                del self.weights[edge]
    
    def get_neighbors(self, vertex: Any) -> List[Any]:
        """获取邻居"""
        return self.adjacency_list.get(vertex, [])
    
    def get_degree(self, vertex: Any) -> int:
        """获取度数"""
        return len(self.get_neighbors(vertex))
    
    def is_connected(self) -> bool:
        """检查是否连通"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        visited = set()
        self._dfs(start_vertex, visited)
        
        return len(visited) == len(self.vertices)
    
    def _dfs(self, vertex: Any, visited: Set[Any]):
        """深度优先搜索"""
        visited.add(vertex)
        for neighbor in self.get_neighbors(vertex):
            if neighbor not in visited:
                self._dfs(neighbor, visited)
    
    def get_shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """获取最短路径（Dijkstra算法）"""
        if not self.weighted:
            return self._bfs_shortest_path(start, end)
        
        distances = {vertex: float('inf') for vertex in self.vertices}
        distances[start] = 0
        previous = {}
        unvisited = set(self.vertices)
        
        while unvisited:
            # 找到距离最小的未访问顶点
            current = min(unvisited, key=lambda v: distances[v])
            
            if current == end:
                break
            
            unvisited.remove(current)
            
            for neighbor in self.get_neighbors(current):
                if neighbor in unvisited:
                    edge = (current, neighbor) if self.directed else tuple(sorted([current, neighbor]))
                    weight = self.weights.get(edge, 1.0)
                    
                    new_distance = distances[current] + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        previous[neighbor] = current
        
        # 重建路径
        if end not in previous and start != end:
            return None
        
        path = []
        current = end
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        return list(reversed(path))
    
    def _bfs_shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """BFS最短路径（无权图）"""
        queue = [(start, [start])]
        visited = {start}
        
        while queue:
            current, path = queue.pop(0)
            
            if current == end:
                return path
            
            for neighbor in self.get_neighbors(current):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return None
    
    def visualize(self):
        """可视化图"""
        G = nx.Graph() if not self.directed else nx.DiGraph()
        
        # 添加顶点
        G.add_nodes_from(self.vertices)
        
        # 添加边
        for edge in self.edges:
            if self.weighted:
                G.add_edge(edge[0], edge[1], weight=self.weights.get(edge, 1.0))
            else:
                G.add_edge(edge[0], edge[1])
        
        # 绘制图
        plt.figure(figsize=(8, 6))
        pos = nx.spring_layout(G)
        
        if self.weighted:
            edge_labels = nx.get_edge_attributes(G, 'weight')
            nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
        
        nx.draw(G, pos, with_labels=True, node_color='lightblue', 
                node_size=500, font_size=16, font_weight='bold')
        
        plt.title("Graph Visualization")
        plt.show()

# 使用示例
def demonstrate_graphs():
    """演示图论"""
    # 创建无向图
    undirected_graph = Graph(directed=False, weighted=True)
    
    # 添加顶点和边
    vertices = ['A', 'B', 'C', 'D', 'E']
    for vertex in vertices:
        undirected_graph.add_vertex(vertex)
    
    edges = [('A', 'B', 4), ('A', 'C', 2), ('B', 'C', 1), 
             ('B', 'D', 5), ('C', 'D', 8), ('C', 'E', 10), ('D', 'E', 2)]
    
    for u, v, weight in edges:
        undirected_graph.add_edge(u, v, weight)
    
    print(f"图是否连通: {undirected_graph.is_connected()}")
    print(f"顶点A的度数: {undirected_graph.get_degree('A')}")
    
    # 最短路径
    shortest_path = undirected_graph.get_shortest_path('A', 'E')
    print(f"A到E的最短路径: {shortest_path}")
    
    # 可视化
    undirected_graph.visualize()
    
    return undirected_graph
```

### 4. 组合数学

#### 4.1 排列与组合

**定义 4.1.1** $n$ 个元素的排列数：

$$P(n) = n!$$

**定义 4.1.2** $n$ 个元素中取 $r$ 个的排列数：

$$P(n, r) = \frac{n!}{(n-r)!}$$

**定义 4.1.3** $n$ 个元素中取 $r$ 个的组合数：

$$C(n, r) = \binom{n}{r} = \frac{n!}{r!(n-r)!}$$

**Python 实现**：

```python
import math
from typing import List, Set, Tuple
from itertools import permutations, combinations

class Combinatorics:
    """组合数学工具类"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """阶乘"""
        if n < 0:
            raise ValueError("阶乘不能用于负数")
        if n == 0 or n == 1:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation_count(n: int, r: int = None) -> int:
        """排列数"""
        if r is None:
            r = n
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination_count(n: int, r: int) -> int:
        """组合数"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def generate_permutations(elements: List[Any], r: int = None) -> List[Tuple[Any, ...]]:
        """生成排列"""
        if r is None:
            r = len(elements)
        return list(permutations(elements, r))
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> List[Tuple[Any, ...]]:
        """生成组合"""
        return list(combinations(elements, r))
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """卡特兰数"""
        if n <= 0:
            return 1
        return Combinatorics.combination_count(2 * n, n) // (n + 1)
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """斐波那契数"""
        if n <= 0:
            return 0
        if n == 1:
            return 1
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    
    @staticmethod
    def stirling_number_second_kind(n: int, k: int) -> int:
        """第二类斯特林数"""
        if k == 0:
            return 1 if n == 0 else 0
        if k == 1:
            return 1
        if k > n:
            return 0
        
        # 使用递推公式
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = dp[i-1][j-1] + j * dp[i-1][j]
        
        return dp[n][k]

# 使用示例
def demonstrate_combinatorics():
    """演示组合数学"""
    elements = ['A', 'B', 'C']
    
    # 排列
    perms = Combinatorics.generate_permutations(elements)
    print(f"元素 {elements} 的所有排列: {perms}")
    print(f"排列数: {Combinatorics.permutation_count(len(elements))}")
    
    # 组合
    combs = Combinatorics.generate_combinations(elements, 2)
    print(f"元素 {elements} 中取2个的组合: {combs}")
    print(f"组合数: {Combinatorics.combination_count(len(elements), 2)}")
    
    # 卡特兰数
    for n in range(6):
        print(f"C({n}) = {Combinatorics.catalan_number(n)}")
    
    # 斐波那契数
    for n in range(10):
        print(f"F({n}) = {Combinatorics.fibonacci_number(n)}")
    
    # 斯特林数
    for n in range(5):
        for k in range(n + 1):
            print(f"S({n}, {k}) = {Combinatorics.stirling_number_second_kind(n, k)}")
    
    return perms, combs
```

## 🔗 相关链接

- [00.3 计算思维](../00-理念基础/03-计算思维.md)
- [01.2 形式化逻辑](./02-形式化逻辑.md)
- [01.3 计算理论](./03-计算理论.md)

## 📚 参考文献

1. Rosen, K. H. (2018). Discrete mathematics and its applications. McGraw-Hill Education.
2. Grimaldi, R. P. (2017). Discrete and combinatorial mathematics: An applied introduction. Pearson.
3. Biggs, N. L. (2002). Discrete mathematics. Oxford University Press.

---

**下一节**: [01.2 形式化逻辑](./02-形式化逻辑.md)
