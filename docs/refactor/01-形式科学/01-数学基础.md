# 01.1 æ•°å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°å­¦æ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„ç†è®ºåŸºç¡€ï¼Œä¸ºç®—æ³•è®¾è®¡ã€æ•°æ®ç»“æ„ã€å½¢å¼åŒ–éªŒè¯ç­‰æä¾›ä¸¥æ ¼çš„æ•°å­¦å·¥å…·ã€‚æœ¬ç« èŠ‚ä»å½¢å¼åŒ–è§’åº¦ä»‹ç»è½¯ä»¶å·¥ç¨‹ä¸­å¸¸ç”¨çš„æ•°å­¦åŸºç¡€ï¼ŒåŒ…æ‹¬é›†åˆè®ºã€å‡½æ•°è®ºã€ä»£æ•°ç»“æ„ã€å›¾è®ºç­‰ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆè®ºåŸºç¡€

#### 1.1 é›†åˆçš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1.1** é›†åˆ $A$ æ˜¯ä¸€ä¸ªæ•°å­¦å¯¹è±¡ï¼Œæ»¡è¶³ï¼š

$$A = \{x | P(x)\}$$

å…¶ä¸­ $P(x)$ æ˜¯è°“è¯ï¼Œè¡¨ç¤ºå…ƒç´  $x$ å±äºé›†åˆ $A$ çš„æ¡ä»¶ã€‚

**å®šä¹‰ 1.1.2** é›†åˆè¿ç®—ï¼š

- **å¹¶é›†**: $A \cup B = \{x | x \in A \lor x \in B\}$
- **äº¤é›†**: $A \cap B = \{x | x \in A \land x \in B\}$
- **å·®é›†**: $A \setminus B = \{x | x \in A \land x \notin B\}$
- **è¡¥é›†**: $A^c = \{x | x \notin A\}$

**Python å®ç°**ï¼š

```python
from typing import Set, Any, Callable, TypeVar, Generic
from abc import ABC, abstractmethod
import math

T = TypeVar('T')

class Set(Generic[T]):
    """é›†åˆæŠ½è±¡åŸºç±»"""
    
    def __init__(self, elements: Set[T] = None):
        self._elements = elements or set()
    
    def add(self, element: T):
        """æ·»åŠ å…ƒç´ """
        self._elements.add(element)
    
    def remove(self, element: T):
        """ç§»é™¤å…ƒç´ """
        self._elements.discard(element)
    
    def contains(self, element: T) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        return element in self._elements
    
    def union(self, other: 'Set[T]') -> 'Set[T]':
        """å¹¶é›†"""
        return Set(self._elements | other._elements)
    
    def intersection(self, other: 'Set[T]') -> 'Set[T]':
        """äº¤é›†"""
        return Set(self._elements & other._elements)
    
    def difference(self, other: 'Set[T]') -> 'Set[T]':
        """å·®é›†"""
        return Set(self._elements - other._elements)
    
    def complement(self, universe: 'Set[T]') -> 'Set[T]':
        """è¡¥é›†"""
        return universe.difference(self)
    
    def is_subset(self, other: 'Set[T]') -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå­é›†"""
        return self._elements.issubset(other._elements)
    
    def is_superset(self, other: 'Set[T]') -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºè¶…é›†"""
        return self._elements.issuperset(other._elements)
    
    def size(self) -> int:
        """é›†åˆå¤§å°"""
        return len(self._elements)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©ºé›†"""
        return len(self._elements) == 0
    
    def __iter__(self):
        return iter(self._elements)
    
    def __str__(self):
        return f"Set({self._elements})"

class FiniteSet(Set[T]):
    """æœ‰é™é›†åˆ"""
    
    def __init__(self, elements: Set[T]):
        super().__init__(elements)
        if not self._is_finite():
            raise ValueError("é›†åˆå¿…é¡»æ˜¯æœ‰é™çš„")
    
    def _is_finite(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰é™é›†åˆ"""
        return len(self._elements) < float('inf')
    
    def power_set(self) -> 'Set[Set[T]]':
        """å¹‚é›†"""
        elements_list = list(self._elements)
        power_set_elements = set()
        
        # ç”Ÿæˆæ‰€æœ‰å­é›†
        for i in range(2 ** len(elements_list)):
            subset = set()
            for j in range(len(elements_list)):
                if i & (1 << j):
                    subset.add(elements_list[j])
            power_set_elements.add(frozenset(subset))
        
        return Set(power_set_elements)

class InfiniteSet(Set[T]):
    """æ— é™é›†åˆ"""
    
    def __init__(self, predicate: Callable[[T], bool]):
        self.predicate = predicate
        super().__init__()
    
    def contains(self, element: T) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        return self.predicate(element)
    
    def size(self) -> float:
        """é›†åˆå¤§å°ï¼ˆæ— é™ï¼‰"""
        return float('inf')

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_set_operations():
    """æ¼”ç¤ºé›†åˆè¿ç®—"""
    # åˆ›å»ºæœ‰é™é›†åˆ
    set_a = FiniteSet({1, 2, 3, 4, 5})
    set_b = FiniteSet({4, 5, 6, 7, 8})
    
    print(f"é›†åˆ A: {set_a}")
    print(f"é›†åˆ B: {set_b}")
    
    # åŸºæœ¬è¿ç®—
    union_set = set_a.union(set_b)
    intersection_set = set_a.intersection(set_b)
    difference_set = set_a.difference(set_b)
    
    print(f"å¹¶é›† A âˆª B: {union_set}")
    print(f"äº¤é›† A âˆ© B: {intersection_set}")
    print(f"å·®é›† A - B: {difference_set}")
    
    # å­é›†å…³ç³»
    subset = FiniteSet({1, 2})
    print(f"{subset} æ˜¯ {set_a} çš„å­é›†: {subset.is_subset(set_a)}")
    
    # å¹‚é›†
    small_set = FiniteSet({1, 2})
    power_set = small_set.power_set()
    print(f"{small_set} çš„å¹‚é›†: {power_set}")
    
    return set_a, set_b, union_set, intersection_set, difference_set
```

#### 1.2 å…³ç³»ä¸å‡½æ•°

**å®šä¹‰ 1.2.1** å…³ç³» $R$ æ˜¯é›†åˆ $A \times B$ çš„å­é›†ï¼š

$$R \subseteq A \times B$$

**å®šä¹‰ 1.2.2** å‡½æ•° $f: A \rightarrow B$ æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„å…³ç³»ï¼š

$$\forall a \in A, \exists! b \in B: (a, b) \in f$$

**Python å®ç°**ï¼š

```python
from typing import Dict, List, Tuple, Optional, Callable

class Relation(Generic[T, U]):
    """å…³ç³»ç±»"""
    
    def __init__(self, pairs: Set[Tuple[T, U]]):
        self.pairs = pairs
    
    def domain(self) -> Set[T]:
        """å®šä¹‰åŸŸ"""
        return {pair[0] for pair in self.pairs}
    
    def codomain(self) -> Set[U]:
        """é™ªåŸŸ"""
        return {pair[1] for pair in self.pairs}
    
    def is_function(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå‡½æ•°"""
        domain_elements = self.domain()
        for element in domain_elements:
            images = {pair[1] for pair in self.pairs if pair[0] == element}
            if len(images) != 1:
                return False
        return True
    
    def apply(self, element: T) -> Optional[U]:
        """åº”ç”¨å…³ç³»ï¼ˆå¦‚æœæ˜¯å‡½æ•°ï¼‰"""
        if not self.is_function():
            raise ValueError("å…³ç³»ä¸æ˜¯å‡½æ•°")
        
        for pair in self.pairs:
            if pair[0] == element:
                return pair[1]
        return None

class Function(Generic[T, U]):
    """å‡½æ•°ç±»"""
    
    def __init__(self, mapping: Dict[T, U]):
        self.mapping = mapping
    
    def domain(self) -> Set[T]:
        """å®šä¹‰åŸŸ"""
        return set(self.mapping.keys())
    
    def codomain(self) -> Set[U]:
        """é™ªåŸŸ"""
        return set(self.mapping.values())
    
    def apply(self, element: T) -> U:
        """åº”ç”¨å‡½æ•°"""
        if element not in self.mapping:
            raise ValueError(f"å…ƒç´  {element} ä¸åœ¨å‡½æ•°å®šä¹‰åŸŸä¸­")
        return self.mapping[element]
    
    def is_injective(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå•å°„"""
        values = list(self.mapping.values())
        return len(values) == len(set(values))
    
    def is_surjective(self, codomain: Set[U]) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ»¡å°„"""
        return self.codomain() == codomain
    
    def is_bijective(self, codomain: Set[U]) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºåŒå°„"""
        return self.is_injective() and self.is_surjective(codomain)
    
    def inverse(self) -> 'Function[U, T]':
        """æ±‚é€†å‡½æ•°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰"""
        if not self.is_bijective(self.codomain()):
            raise ValueError("å‡½æ•°ä¸æ˜¯åŒå°„ï¼Œæ— æ³•æ±‚é€†")
        
        inverse_mapping = {v: k for k, v in self.mapping.items()}
        return Function(inverse_mapping)
    
    def compose(self, other: 'Function[U, V]') -> 'Function[T, V]':
        """å‡½æ•°å¤åˆ"""
        composed_mapping = {}
        for x in self.domain():
            y = self.apply(x)
            if y in other.domain():
                composed_mapping[x] = other.apply(y)
        
        return Function(composed_mapping)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_functions():
    """æ¼”ç¤ºå‡½æ•°æ“ä½œ"""
    # åˆ›å»ºå‡½æ•°
    f = Function({1: 'a', 2: 'b', 3: 'c'})
    g = Function({'a': 'x', 'b': 'y', 'c': 'z'})
    
    print(f"å‡½æ•° f: {f.mapping}")
    print(f"å‡½æ•° g: {g.mapping}")
    
    # å‡½æ•°æ€§è´¨
    print(f"f æ˜¯å•å°„: {f.is_injective()}")
    print(f"f æ˜¯æ»¡å°„: {f.is_surjective({'a', 'b', 'c'})}")
    print(f"f æ˜¯åŒå°„: {f.is_bijective({'a', 'b', 'c'})}")
    
    # å‡½æ•°åº”ç”¨
    print(f"f(1) = {f.apply(1)}")
    
    # å‡½æ•°å¤åˆ
    h = f.compose(g)
    print(f"å¤åˆå‡½æ•° h = g âˆ˜ f: {h.mapping}")
    
    return f, g, h
```

### 2. ä»£æ•°ç»“æ„

#### 2.1 ç¾¤è®ºåŸºç¡€

**å®šä¹‰ 2.1.1** ç¾¤ $(G, \circ)$ æ˜¯ä¸€ä¸ªé›†åˆ $G$ å’ŒäºŒå…ƒè¿ç®— $\circ$ï¼Œæ»¡è¶³ï¼š

1. **å°é—­æ€§**: $\forall a, b \in G: a \circ b \in G$
2. **ç»“åˆå¾‹**: $\forall a, b, c \in G: (a \circ b) \circ c = a \circ (b \circ c)$
3. **å•ä½å…ƒ**: $\exists e \in G: \forall a \in G: e \circ a = a \circ e = a$
4. **é€†å…ƒ**: $\forall a \in G: \exists a^{-1} \in G: a \circ a^{-1} = a^{-1} \circ a = e$

**Python å®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class Group(ABC):
    """ç¾¤æŠ½è±¡åŸºç±»"""
    
    def __init__(self, elements: Set[Any], operation: callable, identity: T):
        self.elements = elements
        self.operation = operation
        self.identity = identity
        self._inverses = {}
        self._validate_group_axioms()
    
    def _validate_group_axioms(self):
        """éªŒè¯ç¾¤å…¬ç†"""
        # éªŒè¯å°é—­æ€§
        for a in self.elements.iterator():
            for b in self.elements.iterator():
                result = self.operation(a, b)
                if not self.elements.contains(result):
                    raise ValueError(f"Operation not closed: {a} * {b} = {result}")
        
        # éªŒè¯å•ä½å…ƒ
        for a in self.elements.iterator():
            if self.operation(self.identity, a) != a or self.operation(a, self.identity) != a:
                raise ValueError(f"Identity element {self.identity} is not valid")
        
        # è®¡ç®—é€†å…ƒ
        for a in self.elements.iterator():
            for b in self.elements.iterator():
                if (self.operation(a, b) == self.identity and 
                    self.operation(b, a) == self.identity):
                    self._inverses[a] = b
                    break
        
        # éªŒè¯æ¯ä¸ªå…ƒç´ éƒ½æœ‰é€†å…ƒ
        for a in self.elements.iterator():
            if a not in self._inverses:
                raise ValueError(f"Element {a} has no inverse")
    
    def multiply(self, a: T, b: T) -> T:
        """ç¾¤è¿ç®—"""
        if not (self.elements.contains(a) and self.elements.contains(b)):
            raise ValueError("Elements not in group")
        return self.operation(a, b)
    
    def inverse(self, a: T) -> T:
        """æ±‚é€†å…ƒ"""
        if not self.elements.contains(a):
            raise ValueError("Element not in group")
        return self._inverses[a]
    
    def order(self) -> int:
        """ç¾¤çš„é˜¶"""
        return self.elements.size()
    
    def is_abelian(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé˜¿è´å°”ç¾¤"""
        for a in self.elements.iterator():
            for b in self.elements.iterator():
                if self.operation(a, b) != self.operation(b, a):
                    return False
        return True

class IntegerGroup(Group[int]):
    """æ•´æ•°åŠ æ³•ç¾¤"""
    
    def __init__(self, modulus: int):
        self.modulus = modulus
        elements = set(range(modulus))
        super().__init__(elements, self._add_mod, 0)
    
    def _add_mod(self, a: int, b: int) -> int:
        """æ¨¡åŠ æ³•"""
        return (a + b) % self.modulus
    
    def _find_identity(self) -> int:
        """æ‰¾åˆ°å•ä½å…ƒï¼ˆ0ï¼‰"""
        return 0
    
    def _find_inverses(self) -> Dict[int, int]:
        """æ‰¾åˆ°æ‰€æœ‰å…ƒç´ çš„é€†å…ƒ"""
        inverses = {}
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) == 0:
                    inverses[a] = b
                    break
        return inverses

class PermutationGroup(Group[List[int]]):
    """ç½®æ¢ç¾¤"""
    
    def __init__(self, n: int):
        self.n = n
        elements = self._generate_permutations(n)
        super().__init__(elements, self._compose_permutations, list(range(n)))
    
    def _generate_permutations(self, n: int) -> Set[List[int]]:
        """ç”Ÿæˆæ‰€æœ‰ç½®æ¢"""
        if n == 1:
            return {[0]}
        
        perms = set()
        for perm in self._generate_permutations(n - 1):
            for i in range(n):
                new_perm = perm[:i] + [n-1] + perm[i:]
                perms.add(tuple(new_perm))
        
        return {list(perm) for perm in perms}
    
    def _compose_permutations(self, p1: List[int], p2: List[int]) -> List[int]:
        """ç½®æ¢å¤åˆ"""
        return [p1[p2[i]] for i in range(len(p1))]
    
    def _find_identity(self) -> List[int]:
        """æ‰¾åˆ°å•ä½å…ƒï¼ˆæ’ç­‰ç½®æ¢ï¼‰"""
        return list(range(self.n))
    
    def _find_inverses(self) -> Dict[List[int], List[int]]:
        """æ‰¾åˆ°æ‰€æœ‰å…ƒç´ çš„é€†å…ƒ"""
        inverses = {}
        for perm in self.elements:
            inverse = [0] * self.n
            for i in range(self.n):
                inverse[perm[i]] = i
            inverses[tuple(perm)] = inverse
        return {list(k): v for k, v in inverses.items()}

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_groups():
    """æ¼”ç¤ºç¾¤è®º"""
    # æ•´æ•°åŠ æ³•ç¾¤
    z5 = IntegerGroup(5)
    print(f"Z5 æ˜¯ç¾¤: {z5.is_abelian()}")
    print(f"Z5 æ˜¯é˜¿è´å°”ç¾¤: {z5.is_abelian()}")
    print(f"Z5 çš„é˜¶: {z5.order()}")
    
    # ç½®æ¢ç¾¤
    s3 = PermutationGroup(3)
    print(f"S3 æ˜¯ç¾¤: {s3.is_abelian()}")
    print(f"S3 çš„é˜¶: {s3.order()}")
    print(f"S3 æ˜¯é˜¿è´å°”ç¾¤: {s3.is_abelian()}")
    
    return z5, s3
```

#### 2.2 ç¯ä¸åŸŸ

**å®šä¹‰ 2.2.1** ç¯ $(R, +, \cdot)$ æ˜¯ä¸€ä¸ªé›†åˆ $R$ å’Œä¸¤ä¸ªäºŒå…ƒè¿ç®— $+$ å’Œ $\cdot$ï¼Œæ»¡è¶³ï¼š

1. $(R, +)$ æ˜¯é˜¿è´å°”ç¾¤
2. $(R, \cdot)$ æ˜¯åŠç¾¤
3. **åˆ†é…å¾‹**: $\forall a, b, c \in R: a \cdot (b + c) = a \cdot b + a \cdot c$

**Python å®ç°**ï¼š

```python
class Ring(ABC):
    """ç¯æŠ½è±¡åŸºç±»"""
    
    def __init__(self, elements: Set[Any], addition: callable, multiplication: callable):
        self.elements = elements
        self.addition = addition
        self.multiplication = multiplication
    
    def is_ring(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç¯"""
        # æ£€æŸ¥åŠ æ³•ç¾¤æ€§è´¨
        additive_group = self._create_additive_group()
        if not additive_group.is_group() or not additive_group.is_abelian():
            return False
        
        # æ£€æŸ¥ä¹˜æ³•åŠç¾¤æ€§è´¨
        if not self._is_multiplicative_semigroup():
            return False
        
        # æ£€æŸ¥åˆ†é…å¾‹
        return self._satisfies_distributivity()
    
    def _create_additive_group(self) -> Group:
        """åˆ›å»ºåŠ æ³•ç¾¤"""
        return Group(self.elements, self.addition, 0)
    
    def _is_multiplicative_semigroup(self) -> bool:
        """æ£€æŸ¥ä¹˜æ³•åŠç¾¤æ€§è´¨"""
        # å°é—­æ€§
        for a in self.elements:
            for b in self.elements:
                if self.multiplication(a, b) not in self.elements:
                    return False
        
        # ç»“åˆå¾‹
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    left = self.multiplication(self.multiplication(a, b), c)
                    right = self.multiplication(a, self.multiplication(b, c))
                    if left != right:
                        return False
        
        return True
    
    def _satisfies_distributivity(self) -> bool:
        """æ£€æŸ¥åˆ†é…å¾‹"""
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    left = self.multiplication(a, self.addition(b, c))
                    right = self.addition(self.multiplication(a, b), self.multiplication(a, c))
                    if left != right:
                        return False
        return True

class IntegerRing(Ring[int]):
    """æ•´æ•°ç¯"""
    
    def __init__(self, modulus: int):
        self.modulus = modulus
        elements = set(range(modulus))
        super().__init__(elements, self._add_mod, self._mul_mod)
    
    def _add_mod(self, a: int, b: int) -> int:
        """æ¨¡åŠ æ³•"""
        return (a + b) % self.modulus
    
    def _mul_mod(self, a: int, b: int) -> int:
        """æ¨¡ä¹˜æ³•"""
        return (a * b) % self.modulus
```

### 3. å›¾è®ºåŸºç¡€

#### 3.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 3.1.1** å›¾ $G = (V, E)$ ç”±é¡¶ç‚¹é›† $V$ å’Œè¾¹é›† $E$ ç»„æˆï¼Œå…¶ä¸­ $E \subseteq V \times V$ã€‚

**å®šä¹‰ 3.1.2** å›¾çš„ç±»å‹ï¼š

- **æ— å‘å›¾**: $E$ ä¸­çš„è¾¹æ˜¯æ— åºå¯¹
- **æœ‰å‘å›¾**: $E$ ä¸­çš„è¾¹æ˜¯æœ‰åºå¯¹
- **åŠ æƒå›¾**: è¾¹æœ‰æƒé‡å‡½æ•° $w: E \rightarrow \mathbb{R}$

**Python å®ç°**ï¼š

```python
from typing import Dict, List, Tuple, Optional, Set
import networkx as nx
import matplotlib.pyplot as plt

class Graph:
    """å›¾åŸºç±»"""
    
    def __init__(self, directed: bool = False, weighted: bool = False):
        self.vertices = set()
        self.edges = set()
        self.directed = directed
        self.weighted = weighted
        self.weights = {}
        self.adjacency_list = {}
    
    def add_vertex(self, vertex: Any):
        """æ·»åŠ é¡¶ç‚¹"""
        self.vertices.add(vertex)
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = []
    
    def add_edge(self, u: Any, v: Any, weight: float = 1.0):
        """æ·»åŠ è¾¹"""
        if u not in self.vertices:
            self.add_vertex(u)
        if v not in self.vertices:
            self.add_vertex(v)
        
        if self.directed:
            edge = (u, v)
        else:
            edge = tuple(sorted([u, v]))
        
        self.edges.add(edge)
        self.adjacency_list[u].append(v)
        
        if not self.directed:
            self.adjacency_list[v].append(u)
        
        if self.weighted:
            self.weights[edge] = weight
    
    def remove_vertex(self, vertex: Any):
        """ç§»é™¤é¡¶ç‚¹"""
        if vertex in self.vertices:
            self.vertices.remove(vertex)
            
            # ç§»é™¤ç›¸å…³è¾¹
            edges_to_remove = set()
            for edge in self.edges:
                if vertex in edge:
                    edges_to_remove.add(edge)
            
            for edge in edges_to_remove:
                self.edges.remove(edge)
                if self.weighted and edge in self.weights:
                    del self.weights[edge]
            
            # æ›´æ–°é‚»æ¥è¡¨
            if vertex in self.adjacency_list:
                del self.adjacency_list[vertex]
            
            for adj_list in self.adjacency_list.values():
                if vertex in adj_list:
                    adj_list.remove(vertex)
    
    def remove_edge(self, u: Any, v: Any):
        """ç§»é™¤è¾¹"""
        if self.directed:
            edge = (u, v)
        else:
            edge = tuple(sorted([u, v]))
        
        if edge in self.edges:
            self.edges.remove(edge)
            self.adjacency_list[u].remove(v)
            
            if not self.directed:
                self.adjacency_list[v].remove(u)
            
            if self.weighted and edge in self.weights:
                del self.weights[edge]
    
    def get_neighbors(self, vertex: Any) -> List[Any]:
        """è·å–é‚»å±…"""
        return self.adjacency_list.get(vertex, [])
    
    def get_degree(self, vertex: Any) -> int:
        """è·å–åº¦æ•°"""
        return len(self.get_neighbors(vertex))
    
    def is_connected(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¿é€š"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        visited = set()
        self._dfs(start_vertex, visited)
        
        return len(visited) == len(self.vertices)
    
    def _dfs(self, vertex: Any, visited: Set[Any]):
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited.add(vertex)
        for neighbor in self.get_neighbors(vertex):
            if neighbor not in visited:
                self._dfs(neighbor, visited)
    
    def get_shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """è·å–æœ€çŸ­è·¯å¾„ï¼ˆDijkstraç®—æ³•ï¼‰"""
        if not self.weighted:
            return self._bfs_shortest_path(start, end)
        
        distances = {vertex: float('inf') for vertex in self.vertices}
        distances[start] = 0
        previous = {}
        unvisited = set(self.vertices)
        
        while unvisited:
            # æ‰¾åˆ°è·ç¦»æœ€å°çš„æœªè®¿é—®é¡¶ç‚¹
            current = min(unvisited, key=lambda v: distances[v])
            
            if current == end:
                break
            
            unvisited.remove(current)
            
            for neighbor in self.get_neighbors(current):
                if neighbor in unvisited:
                    edge = (current, neighbor) if self.directed else tuple(sorted([current, neighbor]))
                    weight = self.weights.get(edge, 1.0)
                    
                    new_distance = distances[current] + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        previous[neighbor] = current
        
        # é‡å»ºè·¯å¾„
        if end not in previous and start != end:
            return None
        
        path = []
        current = end
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        return list(reversed(path))
    
    def _bfs_shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """BFSæœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰"""
        queue = [(start, [start])]
        visited = {start}
        
        while queue:
            current, path = queue.pop(0)
            
            if current == end:
                return path
            
            for neighbor in self.get_neighbors(current):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return None
    
    def visualize(self):
        """å¯è§†åŒ–å›¾"""
        G = nx.Graph() if not self.directed else nx.DiGraph()
        
        # æ·»åŠ é¡¶ç‚¹
        G.add_nodes_from(self.vertices)
        
        # æ·»åŠ è¾¹
        for edge in self.edges:
            if self.weighted:
                G.add_edge(edge[0], edge[1], weight=self.weights.get(edge, 1.0))
            else:
                G.add_edge(edge[0], edge[1])
        
        # ç»˜åˆ¶å›¾
        plt.figure(figsize=(8, 6))
        pos = nx.spring_layout(G)
        
        if self.weighted:
            edge_labels = nx.get_edge_attributes(G, 'weight')
            nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
        
        nx.draw(G, pos, with_labels=True, node_color='lightblue', 
                node_size=500, font_size=16, font_weight='bold')
        
        plt.title("Graph Visualization")
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_graphs():
    """æ¼”ç¤ºå›¾è®º"""
    # åˆ›å»ºæ— å‘å›¾
    undirected_graph = Graph(directed=False, weighted=True)
    
    # æ·»åŠ é¡¶ç‚¹å’Œè¾¹
    vertices = ['A', 'B', 'C', 'D', 'E']
    for vertex in vertices:
        undirected_graph.add_vertex(vertex)
    
    edges = [('A', 'B', 4), ('A', 'C', 2), ('B', 'C', 1), 
             ('B', 'D', 5), ('C', 'D', 8), ('C', 'E', 10), ('D', 'E', 2)]
    
    for u, v, weight in edges:
        undirected_graph.add_edge(u, v, weight)
    
    print(f"å›¾æ˜¯å¦è¿é€š: {undirected_graph.is_connected()}")
    print(f"é¡¶ç‚¹Açš„åº¦æ•°: {undirected_graph.get_degree('A')}")
    
    # æœ€çŸ­è·¯å¾„
    shortest_path = undirected_graph.get_shortest_path('A', 'E')
    print(f"Aåˆ°Eçš„æœ€çŸ­è·¯å¾„: {shortest_path}")
    
    # å¯è§†åŒ–
    undirected_graph.visualize()
    
    return undirected_graph
```

### 4. ç»„åˆæ•°å­¦

#### 4.1 æ’åˆ—ä¸ç»„åˆ

**å®šä¹‰ 4.1.1** $n$ ä¸ªå…ƒç´ çš„æ’åˆ—æ•°ï¼š

$$P(n) = n!$$

**å®šä¹‰ 4.1.2** $n$ ä¸ªå…ƒç´ ä¸­å– $r$ ä¸ªçš„æ’åˆ—æ•°ï¼š

$$P(n, r) = \frac{n!}{(n-r)!}$$

**å®šä¹‰ 4.1.3** $n$ ä¸ªå…ƒç´ ä¸­å– $r$ ä¸ªçš„ç»„åˆæ•°ï¼š

$$C(n, r) = \binom{n}{r} = \frac{n!}{r!(n-r)!}$$

**Python å®ç°**ï¼š

```python
import math
from typing import List, Set, Tuple
from itertools import permutations, combinations

class Combinatorics:
    """ç»„åˆæ•°å­¦å·¥å…·ç±»"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """é˜¶ä¹˜"""
        if n < 0:
            raise ValueError("é˜¶ä¹˜ä¸èƒ½ç”¨äºè´Ÿæ•°")
        if n == 0 or n == 1:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation_count(n: int, r: int = None) -> int:
        """æ’åˆ—æ•°"""
        if r is None:
            r = n
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination_count(n: int, r: int) -> int:
        """ç»„åˆæ•°"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def generate_permutations(elements: List[Any], r: int = None) -> List[Tuple[Any, ...]]:
        """ç”Ÿæˆæ’åˆ—"""
        if r is None:
            r = len(elements)
        return list(permutations(elements, r))
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> List[Tuple[Any, ...]]:
        """ç”Ÿæˆç»„åˆ"""
        return list(combinations(elements, r))
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """å¡ç‰¹å…°æ•°"""
        if n <= 0:
            return 1
        return Combinatorics.combination_count(2 * n, n) // (n + 1)
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """æ–æ³¢é‚£å¥‘æ•°"""
        if n <= 0:
            return 0
        if n == 1:
            return 1
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    
    @staticmethod
    def stirling_number_second_kind(n: int, k: int) -> int:
        """ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°"""
        if k == 0:
            return 1 if n == 0 else 0
        if k == 1:
            return 1
        if k > n:
            return 0
        
        # ä½¿ç”¨é€’æ¨å…¬å¼
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = dp[i-1][j-1] + j * dp[i-1][j]
        
        return dp[n][k]

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_combinatorics():
    """æ¼”ç¤ºç»„åˆæ•°å­¦"""
    elements = ['A', 'B', 'C']
    
    # æ’åˆ—
    perms = Combinatorics.generate_permutations(elements)
    print(f"å…ƒç´  {elements} çš„æ‰€æœ‰æ’åˆ—: {perms}")
    print(f"æ’åˆ—æ•°: {Combinatorics.permutation_count(len(elements))}")
    
    # ç»„åˆ
    combs = Combinatorics.generate_combinations(elements, 2)
    print(f"å…ƒç´  {elements} ä¸­å–2ä¸ªçš„ç»„åˆ: {combs}")
    print(f"ç»„åˆæ•°: {Combinatorics.combination_count(len(elements), 2)}")
    
    # å¡ç‰¹å…°æ•°
    for n in range(6):
        print(f"C({n}) = {Combinatorics.catalan_number(n)}")
    
    # æ–æ³¢é‚£å¥‘æ•°
    for n in range(10):
        print(f"F({n}) = {Combinatorics.fibonacci_number(n)}")
    
    # æ–¯ç‰¹æ—æ•°
    for n in range(5):
        for k in range(n + 1):
            print(f"S({n}, {k}) = {Combinatorics.stirling_number_second_kind(n, k)}")
    
    return perms, combs
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00.3 è®¡ç®—æ€ç»´](../00-ç†å¿µåŸºç¡€/03-è®¡ç®—æ€ç»´.md)
- [01.2 å½¢å¼åŒ–é€»è¾‘](./02-å½¢å¼åŒ–é€»è¾‘.md)
- [01.3 è®¡ç®—ç†è®º](./03-è®¡ç®—ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Rosen, K. H. (2018). Discrete mathematics and its applications. McGraw-Hill Education.
2. Grimaldi, R. P. (2017). Discrete and combinatorial mathematics: An applied introduction. Pearson.
3. Biggs, N. L. (2002). Discrete mathematics. Oxford University Press.

---

**ä¸‹ä¸€èŠ‚**: [01.2 å½¢å¼åŒ–é€»è¾‘](./02-å½¢å¼åŒ–é€»è¾‘.md)
