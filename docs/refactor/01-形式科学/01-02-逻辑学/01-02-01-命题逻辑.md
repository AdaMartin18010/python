# 01-02-01 å‘½é¢˜é€»è¾‘

## ğŸ“‹ æ¦‚è¿°

å‘½é¢˜é€»è¾‘æ˜¯å½¢å¼é€»è¾‘çš„åŸºç¡€ï¼Œç ”ç©¶å‘½é¢˜ä¹‹é—´çš„é€»è¾‘å…³ç³»ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰å‘½é¢˜é€»è¾‘ï¼Œå»ºç«‹å®Œæ•´çš„ç†è®ºä½“ç³»ï¼Œå¹¶æä¾›é«˜æ•ˆçš„Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å‘½é¢˜é€»è¾‘çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1** (å‘½é¢˜)
å‘½é¢˜æ˜¯ä¸€ä¸ªæœ‰çœŸå€¼çš„é™ˆè¿°å¥ï¼Œå…¶çœŸå€¼é›†åˆä¸ºï¼š
$$\mathbb{B} = \{True, False\}$$

**å®šä¹‰ 1.2** (å‘½é¢˜å˜é‡)
å‘½é¢˜å˜é‡æ˜¯è¡¨ç¤ºå‘½é¢˜çš„ç¬¦å·ï¼š
$$P, Q, R, \ldots \in \mathcal{P}$$

**å®šä¹‰ 1.3** (å‘½é¢˜å…¬å¼)
å‘½é¢˜å…¬å¼é€’å½’å®šä¹‰ä¸ºï¼š

1. å‘½é¢˜å˜é‡æ˜¯å‘½é¢˜å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯å‘½é¢˜å…¬å¼ï¼Œåˆ™ $\neg \phi$ æ˜¯å‘½é¢˜å…¬å¼
3. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å‘½é¢˜å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$ã€$(\phi \lor \psi)$ã€$(\phi \rightarrow \psi)$ã€$(\phi \leftrightarrow \psi)$ æ˜¯å‘½é¢˜å…¬å¼

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, Set, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import itertools

class TruthValue(Enum):
    """çœŸå€¼æšä¸¾"""
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """å‘½é¢˜ç±»"""
    name: str
    value: Optional[TruthValue] = None
    
    def __str__(self) -> str:
        return self.name
    
    def __repr__(self) -> str:
        return f"Proposition('{self.name}')"

class PropositionalFormula(ABC):
    """å‘½é¢˜å…¬å¼æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        """åœ¨ç»™å®šè§£é‡Šä¸‹æ±‚å€¼"""
        pass
    
    @abstractmethod
    def get_variables(self) -> Set[str]:
        """è·å–å…¬å¼ä¸­çš„å˜é‡"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        pass
    
    def is_tautology(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé‡è¨€å¼"""
        variables = self.get_variables()
        if not variables:
            return self.evaluate({}) == TruthValue.TRUE
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§£é‡Š
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            if self.evaluate(interpretation) != TruthValue.TRUE:
                return False
        return True
    
    def is_contradiction(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        variables = self.get_variables()
        if not variables:
            return self.evaluate({}) == TruthValue.FALSE
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§£é‡Š
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            if self.evaluate(interpretation) != TruthValue.FALSE:
                return False
        return True
    
    def is_satisfiable(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼"""
        return not self.is_contradiction()
    
    def is_equivalent(self, other: 'PropositionalFormula') -> bool:
        """æ£€æŸ¥ä¸¤ä¸ªå…¬å¼æ˜¯å¦ç­‰ä»·"""
        variables = self.get_variables().union(other.get_variables())
        if not variables:
            return self.evaluate({}) == other.evaluate({})
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§£é‡Š
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            if self.evaluate(interpretation) != other.evaluate(interpretation):
                return False
        return True

class Variable(PropositionalFormula):
    """å‘½é¢˜å˜é‡"""
    
    def __init__(self, name: str):
        self.name = name
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        if self.name not in interpretation:
            raise ValueError(f"Variable {self.name} not in interpretation")
        return interpretation[self.name]
    
    def get_variables(self) -> Set[str]:
        return {self.name}
    
    def __str__(self) -> str:
        return self.name

class Negation(PropositionalFormula):
    """å¦å®š"""
    
    def __init__(self, formula: PropositionalFormula):
        self.formula = formula
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        result = self.formula.evaluate(interpretation)
        return TruthValue.FALSE if result == TruthValue.TRUE else TruthValue.TRUE
    
    def get_variables(self) -> Set[str]:
        return self.formula.get_variables()
    
    def __str__(self) -> str:
        if isinstance(self.formula, (Variable, Negation)):
            return f"Â¬{self.formula}"
        else:
            return f"Â¬({self.formula})"

class Conjunction(PropositionalFormula):
    """åˆå–"""
    
    def __init__(self, left: PropositionalFormula, right: PropositionalFormula):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        left_result = self.left.evaluate(interpretation)
        right_result = self.right.evaluate(interpretation)
        return TruthValue.TRUE if (left_result == TruthValue.TRUE and right_result == TruthValue.TRUE) else TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables().union(self.right.get_variables())
    
    def __str__(self) -> str:
        return f"({self.left} âˆ§ {self.right})"

class Disjunction(PropositionalFormula):
    """æå–"""
    
    def __init__(self, left: PropositionalFormula, right: PropositionalFormula):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        left_result = self.left.evaluate(interpretation)
        right_result = self.right.evaluate(interpretation)
        return TruthValue.TRUE if (left_result == TruthValue.TRUE or right_result == TruthValue.TRUE) else TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables().union(self.right.get_variables())
    
    def __str__(self) -> str:
        return f"({self.left} âˆ¨ {self.right})"

class Implication(PropositionalFormula):
    """è•´å«"""
    
    def __init__(self, antecedent: PropositionalFormula, consequent: PropositionalFormula):
        self.antecedent = antecedent
        self.consequent = consequent
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        antecedent_result = self.antecedent.evaluate(interpretation)
        consequent_result = self.consequent.evaluate(interpretation)
        
        # p â†’ q ç­‰ä»·äº Â¬p âˆ¨ q
        if antecedent_result == TruthValue.FALSE:
            return TruthValue.TRUE
        elif consequent_result == TruthValue.TRUE:
            return TruthValue.TRUE
        else:
            return TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.antecedent.get_variables().union(self.consequent.get_variables())
    
    def __str__(self) -> str:
        return f"({self.antecedent} â†’ {self.consequent})"

class Equivalence(PropositionalFormula):
    """ç­‰ä»·"""
    
    def __init__(self, left: PropositionalFormula, right: PropositionalFormula):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        left_result = self.left.evaluate(interpretation)
        right_result = self.right.evaluate(interpretation)
        return TruthValue.TRUE if left_result == right_result else TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables().union(self.right.get_variables())
    
    def __str__(self) -> str:
        return f"({self.left} â†” {self.right})"

class TruthTable:
    """çœŸå€¼è¡¨"""
    
    def __init__(self, formula: PropositionalFormula):
        self.formula = formula
        self.variables = sorted(list(formula.get_variables()))
    
    def generate(self) -> List[Dict[str, Any]]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        table = []
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§£é‡Š
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(self.variables)):
            interpretation = dict(zip(self.variables, values))
            result = self.formula.evaluate(interpretation)
            
            row = interpretation.copy()
            row['result'] = result
            table.append(row)
        
        return table
    
    def print_table(self) -> None:
        """æ‰“å°çœŸå€¼è¡¨"""
        table = self.generate()
        
        # æ‰“å°è¡¨å¤´
        header = " | ".join(self.variables + ["Result"])
        print(header)
        print("-" * len(header))
        
        # æ‰“å°æ•°æ®è¡Œ
        for row in table:
            values = [str(row[var].value) for var in self.variables]
            values.append(str(row['result'].value))
            print(" | ".join(values))

class PropositionalLogic:
    """å‘½é¢˜é€»è¾‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.variables: Dict[str, Variable] = {}
    
    def variable(self, name: str) -> Variable:
        """åˆ›å»ºæˆ–è·å–å˜é‡"""
        if name not in self.variables:
            self.variables[name] = Variable(name)
        return self.variables[name]
    
    def neg(self, formula: PropositionalFormula) -> Negation:
        """å¦å®š"""
        return Negation(formula)
    
    def and_(self, left: PropositionalFormula, right: PropositionalFormula) -> Conjunction:
        """åˆå–"""
        return Conjunction(left, right)
    
    def or_(self, left: PropositionalFormula, right: PropositionalFormula) -> Disjunction:
        """æå–"""
        return Disjunction(left, right)
    
    def implies(self, antecedent: PropositionalFormula, consequent: PropositionalFormula) -> Implication:
        """è•´å«"""
        return Implication(antecedent, consequent)
    
    def equiv(self, left: PropositionalFormula, right: PropositionalFormula) -> Equivalence:
        """ç­‰ä»·"""
        return Equivalence(left, right)
    
    def tautology(self, formula: PropositionalFormula) -> bool:
        """æ£€æŸ¥é‡è¨€å¼"""
        return formula.is_tautology()
    
    def contradiction(self, formula: PropositionalFormula) -> bool:
        """æ£€æŸ¥çŸ›ç›¾å¼"""
        return formula.is_contradiction()
    
    def satisfiable(self, formula: PropositionalFormula) -> bool:
        """æ£€æŸ¥å¯æ»¡è¶³æ€§"""
        return formula.is_satisfiable()
    
    def equivalent(self, formula1: PropositionalFormula, formula2: PropositionalFormula) -> bool:
        """æ£€æŸ¥ç­‰ä»·æ€§"""
        return formula1.is_equivalent(formula2)

# é€»è¾‘æ¨ç†ç³»ç»Ÿ
class InferenceRule:
    """æ¨ç†è§„åˆ™åŸºç±»"""
    
    @abstractmethod
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        """åº”ç”¨æ¨ç†è§„åˆ™"""
        pass

class ModusPonens(InferenceRule):
    """å‡è¨€æ¨ç†"""
    
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        if len(premises) != 2:
            return None
        
        # æ£€æŸ¥æ˜¯å¦ä¸º p â†’ q å’Œ p çš„å½¢å¼
        if isinstance(premises[0], Implication):
            implication = premises[0]
            antecedent = implication.antecedent
            consequent = implication.consequent
            
            if antecedent.is_equivalent(premises[1]):
                return consequent
        
        return None

class ModusTollens(InferenceRule):
    """æ‹’å–å¼"""
    
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        if len(premises) != 2:
            return None
        
        # æ£€æŸ¥æ˜¯å¦ä¸º p â†’ q å’Œ Â¬q çš„å½¢å¼
        if isinstance(premises[0], Implication):
            implication = premises[0]
            antecedent = implication.antecedent
            consequent = implication.consequent
            
            if Negation(consequent).is_equivalent(premises[1]):
                return Negation(antecedent)
        
        return None

class HypotheticalSyllogism(InferenceRule):
    """å‡è¨€ä¸‰æ®µè®º"""
    
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        if len(premises) != 2:
            return None
        
        # æ£€æŸ¥æ˜¯å¦ä¸º p â†’ q å’Œ q â†’ r çš„å½¢å¼
        if (isinstance(premises[0], Implication) and 
            isinstance(premises[1], Implication)):
            
            imp1 = premises[0]
            imp2 = premises[1]
            
            if imp1.consequent.is_equivalent(imp2.antecedent):
                return Implication(imp1.antecedent, imp2.consequent)
        
        return None

class PropositionalProof:
    """å‘½é¢˜é€»è¾‘è¯æ˜ç³»ç»Ÿ"""
    
    def __init__(self):
        self.rules = [
            ModusPonens(),
            ModusTollens(),
            HypotheticalSyllogism()
        ]
    
    def prove(self, premises: List[PropositionalFormula], conclusion: PropositionalFormula) -> bool:
        """è¯æ˜ç»“è®ºæ˜¯å¦å¯ä»¥ä»å‰ææ¨å‡º"""
        # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥ç»“è®ºæ˜¯å¦ä¸ºå‰æçš„é€»è¾‘åæ‰¿
        # å³æ£€æŸ¥ (premises[0] âˆ§ premises[1] âˆ§ ... âˆ§ premises[n]) â†’ conclusion æ˜¯å¦ä¸ºé‡è¨€å¼
        
        if not premises:
            return conclusion.is_tautology()
        
        # æ„å»ºå‰æçš„åˆå–
        conjunction = premises[0]
        for premise in premises[1:]:
            conjunction = Conjunction(conjunction, premise)
        
        # æ„å»ºè•´å«å¼
        implication = Implication(conjunction, conclusion)
        
        return implication.is_tautology()

# æ¼”ç¤ºå’Œæµ‹è¯•
def demonstrate_propositional_logic():
    """æ¼”ç¤ºå‘½é¢˜é€»è¾‘çš„ä½¿ç”¨"""
    
    print("=== å‘½é¢˜é€»è¾‘æ¼”ç¤º ===\n")
    
    # åˆ›å»ºé€»è¾‘ç³»ç»Ÿ
    logic = PropositionalLogic()
    
    # åˆ›å»ºå˜é‡
    p = logic.variable("P")
    q = logic.variable("Q")
    r = logic.variable("R")
    
    # 1. åŸºæœ¬é€»è¾‘è¿ç®—
    print("1. åŸºæœ¬é€»è¾‘è¿ç®—")
    
    # åˆå–
    conjunction = logic.and_(p, q)
    print(f"åˆå–: {conjunction}")
    
    # æå–
    disjunction = logic.or_(p, q)
    print(f"æå–: {disjunction}")
    
    # å¦å®š
    negation = logic.neg(p)
    print(f"å¦å®š: {negation}")
    
    # è•´å«
    implication = logic.implies(p, q)
    print(f"è•´å«: {implication}")
    
    # ç­‰ä»·
    equivalence = logic.equiv(p, q)
    print(f"ç­‰ä»·: {equivalence}\n")
    
    # 2. çœŸå€¼è¡¨
    print("2. çœŸå€¼è¡¨")
    print("P âˆ§ Q çš„çœŸå€¼è¡¨:")
    tt = TruthTable(conjunction)
    tt.print_table()
    print()
    
    # 3. é€»è¾‘æ€§è´¨
    print("3. é€»è¾‘æ€§è´¨")
    
    # é‡è¨€å¼
    tautology = logic.or_(p, logic.neg(p))  # P âˆ¨ Â¬P
    print(f"P âˆ¨ Â¬P æ˜¯é‡è¨€å¼: {logic.tautology(tautology)}")
    
    # çŸ›ç›¾å¼
    contradiction = logic.and_(p, logic.neg(p))  # P âˆ§ Â¬P
    print(f"P âˆ§ Â¬P æ˜¯çŸ›ç›¾å¼: {logic.contradiction(contradiction)}")
    
    # å¯æ»¡è¶³å¼
    satisfiable = logic.and_(p, q)  # P âˆ§ Q
    print(f"P âˆ§ Q æ˜¯å¯æ»¡è¶³å¼: {logic.satisfiable(satisfiable)}\n")
    
    # 4. é€»è¾‘ç­‰ä»·
    print("4. é€»è¾‘ç­‰ä»·")
    
    # å¾·æ‘©æ ¹å¾‹
    demorgan1 = logic.neg(logic.and_(p, q))  # Â¬(P âˆ§ Q)
    demorgan2 = logic.or_(logic.neg(p), logic.neg(q))  # Â¬P âˆ¨ Â¬Q
    print(f"Â¬(P âˆ§ Q) â‰¡ Â¬P âˆ¨ Â¬Q: {logic.equivalent(demorgan1, demorgan2)}")
    
    # åˆ†é…å¾‹
    distrib1 = logic.and_(p, logic.or_(q, r))  # P âˆ§ (Q âˆ¨ R)
    distrib2 = logic.or_(logic.and_(p, q), logic.and_(p, r))  # (P âˆ§ Q) âˆ¨ (P âˆ§ R)
    print(f"P âˆ§ (Q âˆ¨ R) â‰¡ (P âˆ§ Q) âˆ¨ (P âˆ§ R): {logic.equivalent(distrib1, distrib2)}\n")
    
    # 5. é€»è¾‘æ¨ç†
    print("5. é€»è¾‘æ¨ç†")
    
    proof_system = PropositionalProof()
    
    # å‡è¨€æ¨ç†: P â†’ Q, P âŠ¢ Q
    premises1 = [logic.implies(p, q), p]
    conclusion1 = q
    result1 = proof_system.prove(premises1, conclusion1)
    print(f"P â†’ Q, P âŠ¢ Q: {result1}")
    
    # æ‹’å–å¼: P â†’ Q, Â¬Q âŠ¢ Â¬P
    premises2 = [logic.implies(p, q), logic.neg(q)]
    conclusion2 = logic.neg(p)
    result2 = proof_system.prove(premises2, conclusion2)
    print(f"P â†’ Q, Â¬Q âŠ¢ Â¬P: {result2}")
    
    # å‡è¨€ä¸‰æ®µè®º: P â†’ Q, Q â†’ R âŠ¢ P â†’ R
    premises3 = [logic.implies(p, q), logic.implies(q, r)]
    conclusion3 = logic.implies(p, r)
    result3 = proof_system.prove(premises3, conclusion3)
    print(f"P â†’ Q, Q â†’ R âŠ¢ P â†’ R: {result3}\n")

if __name__ == "__main__":
    demonstrate_propositional_logic()
```

## ğŸ“Š é€»è¾‘è¿ç®—

### 2.1 åŸºæœ¬é€»è¾‘è¿ç®—

#### 2.1.1 å¦å®šï¼ˆNOTï¼‰

**å®šä¹‰ 2.1** (å¦å®š)
å¦å®šè¿ç®—å®šä¹‰ä¸ºï¼š
$$\neg: \mathbb{B} \rightarrow \mathbb{B}$$
$$\neg p = \begin{cases}
False & \text{if } p = True \\
True & \text{if } p = False
\end{cases}$$

**çœŸå€¼è¡¨**:
| P | Â¬P |
|---|----|
| T | F  |
| F | T  |

#### 2.1.2 åˆå–ï¼ˆANDï¼‰

**å®šä¹‰ 2.2** (åˆå–)
åˆå–è¿ç®—å®šä¹‰ä¸ºï¼š
$$\land: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \land q = \begin{cases}
True & \text{if } p = True \text{ and } q = True \\
False & \text{otherwise}
\end{cases}$$

**çœŸå€¼è¡¨**:
| P | Q | P âˆ§ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   F   |
| F | F |   F   |

#### 2.1.3 æå–ï¼ˆORï¼‰

**å®šä¹‰ 2.3** (æå–)
æå–è¿ç®—å®šä¹‰ä¸ºï¼š
$$\lor: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \lor q = \begin{cases}
False & \text{if } p = False \text{ and } q = False \\
True & \text{otherwise}
\end{cases}$$

**çœŸå€¼è¡¨**:
| P | Q | P âˆ¨ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   T   |
| F | T |   T   |
| F | F |   F   |

#### 2.1.4 è•´å«ï¼ˆIMPLIESï¼‰

**å®šä¹‰ 2.4** (è•´å«)
è•´å«è¿ç®—å®šä¹‰ä¸ºï¼š
$$\rightarrow: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \rightarrow q = \begin{cases}
False & \text{if } p = True \text{ and } q = False \\
True & \text{otherwise}
\end{cases}$$

**çœŸå€¼è¡¨**:
| P | Q | P â†’ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   T   |
| F | F |   T   |

#### 2.1.5 ç­‰ä»·ï¼ˆIFFï¼‰

**å®šä¹‰ 2.5** (ç­‰ä»·)
ç­‰ä»·è¿ç®—å®šä¹‰ä¸ºï¼š
$$\leftrightarrow: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \leftrightarrow q = \begin{cases}
True & \text{if } p = q \\
False & \text{otherwise}
\end{cases}$$

**çœŸå€¼è¡¨**:
| P | Q | P â†” Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   F   |
| F | F |   T   |

### 2.2 é€»è¾‘ç­‰ä»·å¾‹

#### 2.2.1 åŸºæœ¬ç­‰ä»·å¾‹

**å®šç† 2.1** (åŒé‡å¦å®šå¾‹)
$$\neg \neg p \equiv p$$

**å®šç† 2.2** (å¾·æ‘©æ ¹å¾‹)
$$\neg(p \land q) \equiv \neg p \lor \neg q$$
$$\neg(p \lor q) \equiv \neg p \land \neg q$$

**å®šç† 2.3** (åˆ†é…å¾‹)
$$p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$$
$$p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$$

**å®šç† 2.4** (ç»“åˆå¾‹)
$$(p \land q) \land r \equiv p \land (q \land r)$$
$$(p \lor q) \lor r \equiv p \lor (q \lor r)$$

**å®šç† 2.5** (äº¤æ¢å¾‹)
$$p \land q \equiv q \land p$$
$$p \lor q \equiv q \lor p$$

#### 2.2.2 è•´å«ç­‰ä»·å¾‹

**å®šç† 2.6** (è•´å«ç­‰ä»·)
$$p \rightarrow q \equiv \neg p \lor q$$

**å®šç† 2.7** (ç­‰ä»·å±•å¼€)
$$p \leftrightarrow q \equiv (p \rightarrow q) \land (q \rightarrow p)$$

## ğŸ” é€»è¾‘æ¨ç†

### 3.1 æ¨ç†è§„åˆ™

#### 3.1.1 å‡è¨€æ¨ç†ï¼ˆModus Ponensï¼‰

**è§„åˆ™ 3.1** (å‡è¨€æ¨ç†)
$$\frac{p \rightarrow q \quad p}{q}$$

**è¯æ˜**:
1. å‡è®¾ $p \rightarrow q$ ä¸ºçœŸ
2. å‡è®¾ $p$ ä¸ºçœŸ
3. æ ¹æ®è•´å«å®šä¹‰ï¼Œ$q$ å¿…é¡»ä¸ºçœŸ
4. å› æ­¤ç»“è®º $q$ æˆç«‹

#### 3.1.2 æ‹’å–å¼ï¼ˆModus Tollensï¼‰

**è§„åˆ™ 3.2** (æ‹’å–å¼)
$$\frac{p \rightarrow q \quad \neg q}{\neg p}$$

**è¯æ˜**:
1. å‡è®¾ $p \rightarrow q$ ä¸ºçœŸ
2. å‡è®¾ $\neg q$ ä¸ºçœŸï¼ˆå³ $q$ ä¸ºå‡ï¼‰
3. å¦‚æœ $p$ ä¸ºçœŸï¼Œåˆ™æ ¹æ®è•´å«å®šä¹‰ $q$ å¿…é¡»ä¸ºçœŸï¼ŒçŸ›ç›¾
4. å› æ­¤ $p$ å¿…é¡»ä¸ºå‡ï¼Œå³ $\neg p$ ä¸ºçœŸ

#### 3.1.3 å‡è¨€ä¸‰æ®µè®º

**è§„åˆ™ 3.3** (å‡è¨€ä¸‰æ®µè®º)
$$\frac{p \rightarrow q \quad q \rightarrow r}{p \rightarrow r}$$

**è¯æ˜**:
1. å‡è®¾ $p \rightarrow q$ ä¸ºçœŸ
2. å‡è®¾ $q \rightarrow r$ ä¸ºçœŸ
3. å¦‚æœ $p$ ä¸ºçœŸï¼Œåˆ™ $q$ ä¸ºçœŸï¼ˆç”±1ï¼‰
4. å¦‚æœ $q$ ä¸ºçœŸï¼Œåˆ™ $r$ ä¸ºçœŸï¼ˆç”±2ï¼‰
5. å› æ­¤ $p \rightarrow r$ ä¸ºçœŸ

### 3.2 é€»è¾‘åæ‰¿

**å®šä¹‰ 3.1** (é€»è¾‘åæ‰¿)
å…¬å¼ $\psi$ æ˜¯å…¬å¼é›†åˆ $\Gamma$ çš„é€»è¾‘åæ‰¿ï¼Œè®°ä½œ $\Gamma \models \psi$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall I, (\forall \phi \in \Gamma, I \models \phi) \Rightarrow I \models \psi$$

å…¶ä¸­ $I$ æ˜¯è§£é‡Šï¼Œ$I \models \phi$ è¡¨ç¤ºåœ¨è§£é‡Š $I$ ä¸‹å…¬å¼ $\phi$ ä¸ºçœŸã€‚

**å®šç† 3.1** (é€»è¾‘åæ‰¿çš„æ€§è´¨)
1. **è‡ªåæ€§**: $\phi \models \phi$
2. **ä¼ é€’æ€§**: å¦‚æœ $\Gamma \models \phi$ ä¸” $\phi \models \psi$ï¼Œåˆ™ $\Gamma \models \psi$
3. **å•è°ƒæ€§**: å¦‚æœ $\Gamma \models \phi$ ä¸” $\Gamma \subseteq \Delta$ï¼Œåˆ™ $\Delta \models \phi$

## ğŸ¯ é€»è¾‘ç³»ç»Ÿ

### 4.1 å…¬ç†ç³»ç»Ÿ

#### 4.1.1 å‘½é¢˜é€»è¾‘å…¬ç†

**å…¬ç† 4.1** (å‘½é¢˜é€»è¾‘å…¬ç†)
1. $p \rightarrow (q \rightarrow p)$
2. $(p \rightarrow (q \rightarrow r)) \rightarrow ((p \rightarrow q) \rightarrow (p \rightarrow r))$
3. $(\neg p \rightarrow \neg q) \rightarrow (q \rightarrow p)$

**æ¨ç†è§„åˆ™ 4.1** (åˆ†ç¦»è§„åˆ™)
$$\frac{\phi \quad \phi \rightarrow \psi}{\psi}$$

#### 4.1.2 è‡ªç„¶æ¼”ç»ç³»ç»Ÿ

**è§„åˆ™ 4.2** (è‡ªç„¶æ¼”ç»è§„åˆ™)

**å¼•å…¥è§„åˆ™**:
- $\land I$: $\frac{\phi \quad \psi}{\phi \land \psi}$
- $\lor I$: $\frac{\phi}{\phi \lor \psi}$ æˆ– $\frac{\psi}{\phi \lor \psi}$
- $\rightarrow I$: $\frac{[\phi] \quad \psi}{\phi \rightarrow \psi}$

**æ¶ˆé™¤è§„åˆ™**:
- $\land E$: $\frac{\phi \land \psi}{\phi}$ æˆ– $\frac{\phi \land \psi}{\psi}$
- $\lor E$: $\frac{\phi \lor \psi \quad [\phi] \quad \chi \quad [\psi] \quad \chi}{\chi}$
- $\rightarrow E$: $\frac{\phi \quad \phi \rightarrow \psi}{\psi}$

### 4.2 å®Œå¤‡æ€§å®šç†

**å®šç† 4.1** (å‘½é¢˜é€»è¾‘å®Œå¤‡æ€§)
å¦‚æœ $\Gamma \models \phi$ï¼Œåˆ™ $\Gamma \vdash \phi$ã€‚

**è¯æ˜æ€è·¯**:
1. ä½¿ç”¨çœŸå€¼è¡¨æ–¹æ³•
2. æ„é€ è¯æ˜æ ‘
3. ä½¿ç”¨å½’ç»“æ–¹æ³•

## ğŸ“ˆ åº”ç”¨é¢†åŸŸ

### 5.1 è®¡ç®—æœºç§‘å­¦åº”ç”¨

#### 5.1.1 ç”µè·¯è®¾è®¡

- **é€»è¾‘é—¨**: ANDã€ORã€NOTã€NANDã€NORã€XOR
- **ç»„åˆç”µè·¯**: çœŸå€¼è¡¨åˆ°ç”µè·¯å›¾çš„è½¬æ¢
- **æ—¶åºç”µè·¯**: çŠ¶æ€æœºè®¾è®¡

#### 5.1.2 ç¨‹åºéªŒè¯

- **å‰ç½®æ¡ä»¶**: ç¨‹åºæ‰§è¡Œå‰çš„çŠ¶æ€çº¦æŸ
- **åç½®æ¡ä»¶**: ç¨‹åºæ‰§è¡Œåçš„çŠ¶æ€çº¦æŸ
- **ä¸å˜å¼**: ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­ä¿æŒçš„æ€§è´¨

#### 5.1.3 äººå·¥æ™ºèƒ½

- **çŸ¥è¯†è¡¨ç¤º**: å‘½é¢˜é€»è¾‘ä½œä¸ºçŸ¥è¯†è¡¨ç¤ºè¯­è¨€
- **æ¨ç†ç³»ç»Ÿ**: åŸºäºè§„åˆ™çš„ä¸“å®¶ç³»ç»Ÿ
- **çº¦æŸæ»¡è¶³**: çº¦æŸæ»¡è¶³é—®é¢˜çš„å»ºæ¨¡

### 5.2 æ•°å­¦åº”ç”¨

#### 5.2.1 é›†åˆè®º

- **é›†åˆè¿ç®—**: å¹¶é›†ã€äº¤é›†ã€è¡¥é›†
- **é›†åˆå…³ç³»**: åŒ…å«ã€ç›¸ç­‰ã€ä¸ç›¸äº¤

#### 5.2.2 æ•°è®º

- **æ•´é™¤æ€§**: è´¨æ•°ã€åˆæ•°ã€æœ€å¤§å…¬çº¦æ•°
- **åŒä½™**: æ¨¡è¿ç®—ã€ä¸­å›½å‰©ä½™å®šç†

## ğŸ”— ç›¸å…³é“¾æ¥

- [01-02-02 è°“è¯é€»è¾‘](./01-02-02-è°“è¯é€»è¾‘.md)
- [01-02-03 æ¨¡æ€é€»è¾‘](./01-02-03-æ¨¡æ€é€»è¾‘.md)
- [02-01-01 ç®—æ³•åŸºç¡€](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md)
- [03-01-01 åˆ›å»ºå‹æ¨¡å¼](../../03-å…·ä½“ç§‘å­¦/03-01-è®¾è®¡æ¨¡å¼/03-01-01-åˆ›å»ºå‹æ¨¡å¼.md)

---

*æœ¬æ–‡æ¡£å»ºç«‹äº†å‘½é¢˜é€»è¾‘çš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼Œä»å½¢å¼åŒ–å®šä¹‰åˆ°å®é™…å®ç°ï¼Œä¸ºåç»­çš„é€»è¾‘å­¦å­¦ä¹ å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚*
