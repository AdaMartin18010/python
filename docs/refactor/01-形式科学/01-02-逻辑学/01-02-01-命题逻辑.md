# å‘½é¢˜é€»è¾‘åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

å‘½é¢˜é€»è¾‘æ˜¯å½¢å¼é€»è¾‘çš„åŸºç¡€ï¼Œç ”ç©¶å‘½é¢˜ä¹‹é—´çš„é€»è¾‘å…³ç³»ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°å‘½é¢˜é€»è¾‘çš„ç†è®ºåŸºç¡€ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å‘½é¢˜å®šä¹‰

**å®šä¹‰ 1.1** (å‘½é¢˜)
å‘½é¢˜æ˜¯ä¸€ä¸ªå…·æœ‰ç¡®å®šçœŸå€¼çš„é™ˆè¿°å¥ï¼Œç”¨ç¬¦å· $p, q, r, \ldots$ è¡¨ç¤ºã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{Proposition} = \{p \mid p \text{ is a statement with truth value}\}$$

### 1.2 é€»è¾‘è¿æ¥è¯

**å®šä¹‰ 1.2** (é€»è¾‘è¿æ¥è¯)
é€»è¾‘è¿æ¥è¯æ˜¯ç”¨äºè¿æ¥å‘½é¢˜çš„ç¬¦å·ï¼ŒåŒ…æ‹¬ï¼š

- **å¦å®š** ($\neg$): $\neg p$ è¡¨ç¤º"ép"
- **åˆå–** ($\land$): $p \land q$ è¡¨ç¤º"pä¸”q"
- **æå–** ($\lor$): $p \lor q$ è¡¨ç¤º"pæˆ–q"
- **è•´å«** ($\rightarrow$): $p \rightarrow q$ è¡¨ç¤º"å¦‚æœpåˆ™q"
- **ç­‰ä»·** ($\leftrightarrow$): $p \leftrightarrow q$ è¡¨ç¤º"på½“ä¸”ä»…å½“q"

## 2. çœŸå€¼è¡¨

### 2.1 åŸºæœ¬çœŸå€¼è¡¨

| $p$ | $q$ | $\neg p$ | $p \land q$ | $p \lor q$ | $p \rightarrow q$ | $p \leftrightarrow q$ |
|-----|-----|----------|-------------|------------|-------------------|----------------------|
| T   | T   | F        | T           | T          | T                 | T                    |
| T   | F   | F        | F           | T          | F                 | F                    |
| F   | T   | T        | F           | T          | T                 | F                    |
| F   | F   | T        | F           | F          | T                 | T                    |

### 2.2 Pythonå®ç°

```python
from typing import Dict, List, Tuple, Callable, Any
from dataclasses import dataclass
from enum import Enum
import itertools
from abc import ABC, abstractmethod

class TruthValue(Enum):
    """çœŸå€¼æšä¸¾"""
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """å‘½é¢˜ç±»"""
    name: str
    value: TruthValue
    
    def __str__(self) -> str:
        return f"{self.name} = {self.value.value}"

class LogicalOperator(ABC):
    """é€»è¾‘æ“ä½œç¬¦æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def evaluate(self, *args: TruthValue) -> TruthValue:
        """è¯„ä¼°é€»è¾‘æ“ä½œ"""
        pass
    
    @abstractmethod
    def symbol(self) -> str:
        """è¿”å›æ“ä½œç¬¦ç¬¦å·"""
        pass

class Negation(LogicalOperator):
    """å¦å®šæ“ä½œç¬¦"""
    
    def evaluate(self, p: TruthValue) -> TruthValue:
        return TruthValue(not p.value)
    
    def symbol(self) -> str:
        return "Â¬"

class Conjunction(LogicalOperator):
    """åˆå–æ“ä½œç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value and q.value)
    
    def symbol(self) -> str:
        return "âˆ§"

class Disjunction(LogicalOperator):
    """æå–æ“ä½œç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value or q.value)
    
    def symbol(self) -> str:
        return "âˆ¨"

class Implication(LogicalOperator):
    """è•´å«æ“ä½œç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(not p.value or q.value)
    
    def symbol(self) -> str:
        return "â†’"

class Equivalence(LogicalOperator):
    """ç­‰ä»·æ“ä½œç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value == q.value)
    
    def symbol(self) -> str:
        return "â†”"

class TruthTable:
    """çœŸå€¼è¡¨ç±»"""
    
    def __init__(self, variables: List[str]):
        self.variables = variables
        self.operators = {
            'Â¬': Negation(),
            'âˆ§': Conjunction(),
            'âˆ¨': Disjunction(),
            'â†’': Implication(),
            'â†”': Equivalence()
        }
    
    def generate_combinations(self) -> List[Dict[str, TruthValue]]:
        """ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„çœŸå€¼ç»„åˆ"""
        combinations = []
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], 
                                      repeat=len(self.variables)):
            combination = dict(zip(self.variables, values))
            combinations.append(combination)
        return combinations
    
    def evaluate_expression(self, expression: str, 
                          values: Dict[str, TruthValue]) -> TruthValue:
        """è¯„ä¼°é€»è¾‘è¡¨è¾¾å¼"""
        # ç®€å•çš„è¡¨è¾¾å¼æ±‚å€¼å®ç°
        # è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„å®ç°ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„è§£æå™¨
        if expression in values:
            return values[expression]
        
        # å¤„ç†å¦å®š
        if expression.startswith('Â¬'):
            return self.operators['Â¬'].evaluate(
                self.evaluate_expression(expression[1:], values)
            )
        
        # å¤„ç†äºŒå…ƒæ“ä½œç¬¦
        for op in ['âˆ§', 'âˆ¨', 'â†’', 'â†”']:
            if op in expression:
                parts = expression.split(op, 1)
                if len(parts) == 2:
                    left = self.evaluate_expression(parts[0].strip(), values)
                    right = self.evaluate_expression(parts[1].strip(), values)
                    return self.operators[op].evaluate(left, right)
        
        raise ValueError(f"æ— æ³•è§£æè¡¨è¾¾å¼: {expression}")
    
    def create_table(self, expressions: List[str]) -> List[List[Any]]:
        """åˆ›å»ºçœŸå€¼è¡¨"""
        combinations = self.generate_combinations()
        table = []
        
        # è¡¨å¤´
        header = self.variables + expressions
        table.append(header)
        
        # æ•°æ®è¡Œ
        for combination in combinations:
            row = []
            # å˜é‡å€¼
            for var in self.variables:
                row.append(combination[var].value)
            # è¡¨è¾¾å¼å€¼
            for expr in expressions:
                try:
                    result = self.evaluate_expression(expr, combination)
                    row.append(result.value)
                except:
                    row.append("Error")
            table.append(row)
        
        return table

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_truth_table():
    """æ¼”ç¤ºçœŸå€¼è¡¨çš„ä½¿ç”¨"""
    print("=== å‘½é¢˜é€»è¾‘çœŸå€¼è¡¨ç¤ºä¾‹ ===\n")
    
    # åˆ›å»ºçœŸå€¼è¡¨
    variables = ['p', 'q']
    tt = TruthTable(variables)
    
    # å®šä¹‰è¡¨è¾¾å¼
    expressions = [
        'Â¬p',
        'pâˆ§q', 
        'pâˆ¨q',
        'pâ†’q',
        'pâ†”q'
    ]
    
    # ç”ŸæˆçœŸå€¼è¡¨
    table = tt.create_table(expressions)
    
    # æ‰“å°è¡¨å¤´
    header = table[0]
    print(f"{'p':<8} {'q':<8} {'Â¬p':<8} {'pâˆ§q':<8} {'pâˆ¨q':<8} {'pâ†’q':<8} {'pâ†”q':<8}")
    print("-" * 70)
    
    # æ‰“å°æ•°æ®è¡Œ
    for row in table[1:]:
        print(f"{str(row[0]):<8} {str(row[1]):<8} {str(row[2]):<8} "
              f"{str(row[3]):<8} {str(row[4]):<8} {str(row[5]):<8} {str(row[6]):<8}")

if __name__ == "__main__":
    demonstrate_truth_table()
```

## 3. é€»è¾‘ç­‰ä»·å’ŒèŒƒå¼

### 3.1 é€»è¾‘ç­‰ä»·

**å®šä¹‰ 3.1** (é€»è¾‘ç­‰ä»·)
ä¸¤ä¸ªå‘½é¢˜å…¬å¼ $A$ å’Œ $B$ æ˜¯é€»è¾‘ç­‰ä»·çš„ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬åœ¨æ‰€æœ‰çœŸå€¼èµ‹å€¼ä¸‹å…·æœ‰ç›¸åŒçš„çœŸå€¼ï¼Œè®°ä½œ $A \equiv B$ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$A \equiv B \iff \forall v: \text{valuation}, v(A) = v(B)$$

### 3.2 é‡è¦ç­‰ä»·å¾‹

**å®šç† 3.1** (å¾·æ‘©æ ¹å¾‹)
$$\neg(p \land q) \equiv \neg p \lor \neg q$$
$$\neg(p \lor q) \equiv \neg p \land \neg q$$

**å®šç† 3.2** (åˆ†é…å¾‹)
$$p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$$
$$p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$$

**å®šç† 3.3** (åŒé‡å¦å®šå¾‹)
$$\neg(\neg p) \equiv p$$

### 3.3 Pythonå®ç°ç­‰ä»·å¾‹éªŒè¯

```python
def verify_equivalence_laws():
    """éªŒè¯é€»è¾‘ç­‰ä»·å¾‹"""
    print("=== é€»è¾‘ç­‰ä»·å¾‹éªŒè¯ ===\n")
    
    variables = ['p', 'q', 'r']
    tt = TruthTable(variables)
    
    # å¾·æ‘©æ ¹å¾‹éªŒè¯
    print("1. å¾·æ‘©æ ¹å¾‹éªŒè¯:")
    expressions1 = ['Â¬(pâˆ§q)', 'Â¬pâˆ¨Â¬q']
    table1 = tt.create_table(expressions1)
    
    print(f"{'p':<8} {'q':<8} {'Â¬(pâˆ§q)':<12} {'Â¬pâˆ¨Â¬q':<12} {'ç­‰ä»·':<8}")
    print("-" * 60)
    
    for row in table1[1:]:
        equivalent = row[2] == row[3]
        print(f"{str(row[0]):<8} {str(row[1]):<8} {str(row[2]):<12} "
              f"{str(row[3]):<12} {str(equivalent):<8}")
    
    print("\n2. åˆ†é…å¾‹éªŒè¯:")
    expressions2 = ['pâˆ§(qâˆ¨r)', '(pâˆ§q)âˆ¨(pâˆ§r)']
    table2 = tt.create_table(expressions2)
    
    print(f"{'p':<8} {'q':<8} {'r':<8} {'pâˆ§(qâˆ¨r)':<12} {'(pâˆ§q)âˆ¨(pâˆ§r)':<12} {'ç­‰ä»·':<8}")
    print("-" * 70)
    
    for row in table2[1:]:
        equivalent = row[3] == row[4]
        print(f"{str(row[0]):<8} {str(row[1]):<8} {str(row[2]):<8} "
              f"{str(row[3]):<12} {str(row[4]):<12} {str(equivalent):<8}")

# è¿è¡ŒéªŒè¯
if __name__ == "__main__":
    verify_equivalence_laws()
```

## 4. æ¨ç†è§„åˆ™

### 4.1 åŸºæœ¬æ¨ç†è§„åˆ™

**å®šä¹‰ 4.1** (æ¨ç†è§„åˆ™)
æ¨ç†è§„åˆ™æ˜¯ä»å‰ææ¨å¯¼ç»“è®ºçš„å½¢å¼åŒ–è§„åˆ™ã€‚

**å¸¸ç”¨æ¨ç†è§„åˆ™**:

1. **å‡è¨€æ¨ç†** (Modus Ponens):
   $$\frac{p \rightarrow q \quad p}{q}$$

2. **å‡è¨€ä¸‰æ®µè®º**:
   $$\frac{p \rightarrow q \quad q \rightarrow r}{p \rightarrow r}$$

3. **æå–ä¸‰æ®µè®º**:
   $$\frac{p \lor q \quad \neg p}{q}$$

4. **æ„é€ æ€§äºŒéš¾æ¨ç†**:
   $$\frac{p \rightarrow q \quad r \rightarrow s \quad p \lor r}{q \lor s}$$

### 4.2 Pythonå®ç°æ¨ç†ç³»ç»Ÿ

```python
from typing import List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class InferenceRule:
    """æ¨ç†è§„åˆ™ç±»"""
    name: str
    premises: List[str]
    conclusion: str
    description: str

class PropositionalLogic:
    """å‘½é¢˜é€»è¾‘æ¨ç†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.rules = [
            InferenceRule(
                "å‡è¨€æ¨ç†",
                ["pâ†’q", "p"],
                "q",
                "å¦‚æœpâ†’qä¸ºçœŸä¸”pä¸ºçœŸï¼Œåˆ™qä¸ºçœŸ"
            ),
            InferenceRule(
                "å‡è¨€ä¸‰æ®µè®º",
                ["pâ†’q", "qâ†’r"],
                "pâ†’r",
                "å¦‚æœpâ†’qä¸”qâ†’rï¼Œåˆ™pâ†’r"
            ),
            InferenceRule(
                "æå–ä¸‰æ®µè®º",
                ["pâˆ¨q", "Â¬p"],
                "q",
                "å¦‚æœpâˆ¨qä¸ºçœŸä¸”Â¬pä¸ºçœŸï¼Œåˆ™qä¸ºçœŸ"
            ),
            InferenceRule(
                "æ„é€ æ€§äºŒéš¾æ¨ç†",
                ["pâ†’q", "râ†’s", "pâˆ¨r"],
                "qâˆ¨s",
                "å¦‚æœpâ†’qä¸”râ†’sä¸”pâˆ¨rï¼Œåˆ™qâˆ¨s"
            )
        ]
    
    def apply_rule(self, rule: InferenceRule, 
                   premises: List[bool]) -> Optional[bool]:
        """åº”ç”¨æ¨ç†è§„åˆ™"""
        if len(premises) != len(rule.premises):
            return None
        
        # ç®€åŒ–çš„è§„åˆ™åº”ç”¨é€»è¾‘
        if rule.name == "å‡è¨€æ¨ç†":
            p_implies_q, p = premises
            return p and p_implies_q
        
        elif rule.name == "å‡è¨€ä¸‰æ®µè®º":
            p_implies_q, q_implies_r = premises
            return p_implies_q and q_implies_r
        
        elif rule.name == "æå–ä¸‰æ®µè®º":
            p_or_q, not_p = premises
            return p_or_q and not_p
        
        elif rule.name == "æ„é€ æ€§äºŒéš¾æ¨ç†":
            p_implies_q, r_implies_s, p_or_r = premises
            return p_implies_q and r_implies_s and p_or_r
        
        return None
    
    def demonstrate_inference(self):
        """æ¼”ç¤ºæ¨ç†è§„åˆ™"""
        print("=== å‘½é¢˜é€»è¾‘æ¨ç†è§„åˆ™æ¼”ç¤º ===\n")
        
        for rule in self.rules:
            print(f"è§„åˆ™: {rule.name}")
            print(f"å‰æ: {' âˆ§ '.join(rule.premises)}")
            print(f"ç»“è®º: {rule.conclusion}")
            print(f"æè¿°: {rule.description}")
            print("-" * 50)

# è¿è¡Œæ¨ç†æ¼”ç¤º
if __name__ == "__main__":
    logic = PropositionalLogic()
    logic.demonstrate_inference()
```

## 5. èŒƒå¼è½¬æ¢

### 5.1 åˆå–èŒƒå¼ (CNF)

**å®šä¹‰ 5.1** (åˆå–èŒƒå¼)
åˆå–èŒƒå¼æ˜¯å½¢å¦‚ $(l_1 \lor l_2 \lor \ldots \lor l_n) \land (m_1 \lor m_2 \lor \ldots \lor m_k) \land \ldots$ çš„å…¬å¼ï¼Œå…¶ä¸­æ¯ä¸ª $l_i, m_j$ æ˜¯æ–‡å­—ï¼ˆå‘½é¢˜å˜é‡æˆ–å…¶å¦å®šï¼‰ã€‚

### 5.2 æå–èŒƒå¼ (DNF)

**å®šä¹‰ 5.2** (æå–èŒƒå¼)
æå–èŒƒå¼æ˜¯å½¢å¦‚ $(l_1 \land l_2 \land \ldots \land l_n) \lor (m_1 \land m_2 \land \ldots \land m_k) \lor \ldots$ çš„å…¬å¼ã€‚

### 5.3 Pythonå®ç°èŒƒå¼è½¬æ¢

```python
class NormalFormConverter:
    """èŒƒå¼è½¬æ¢å™¨"""
    
    def __init__(self):
        self.operators = {
            'Â¬': Negation(),
            'âˆ§': Conjunction(),
            'âˆ¨': Disjunction(),
            'â†’': Implication(),
            'â†”': Equivalence()
        }
    
    def to_cnf(self, expression: str) -> str:
        """è½¬æ¢ä¸ºåˆå–èŒƒå¼"""
        # 1. æ¶ˆé™¤è•´å«å’Œç­‰ä»·
        expr = self.eliminate_implications(expression)
        
        # 2. åº”ç”¨å¾·æ‘©æ ¹å¾‹
        expr = self.apply_de_morgan(expr)
        
        # 3. åº”ç”¨åˆ†é…å¾‹
        expr = self.apply_distribution(expr)
        
        return expr
    
    def eliminate_implications(self, expr: str) -> str:
        """æ¶ˆé™¤è•´å«å’Œç­‰ä»·"""
        # pâ†’q â‰¡ Â¬pâˆ¨q
        # pâ†”q â‰¡ (pâ†’q)âˆ§(qâ†’p) â‰¡ (Â¬pâˆ¨q)âˆ§(Â¬qâˆ¨p)
        # ç®€åŒ–å®ç°
        return expr
    
    def apply_de_morgan(self, expr: str) -> str:
        """åº”ç”¨å¾·æ‘©æ ¹å¾‹"""
        # Â¬(pâˆ§q) â‰¡ Â¬pâˆ¨Â¬q
        # Â¬(pâˆ¨q) â‰¡ Â¬pâˆ§Â¬q
        # ç®€åŒ–å®ç°
        return expr
    
    def apply_distribution(self, expr: str) -> str:
        """åº”ç”¨åˆ†é…å¾‹"""
        # pâˆ§(qâˆ¨r) â‰¡ (pâˆ§q)âˆ¨(pâˆ§r)
        # ç®€åŒ–å®ç°
        return expr

def demonstrate_normal_forms():
    """æ¼”ç¤ºèŒƒå¼è½¬æ¢"""
    print("=== èŒƒå¼è½¬æ¢æ¼”ç¤º ===\n")
    
    converter = NormalFormConverter()
    
    # ç¤ºä¾‹è¡¨è¾¾å¼
    expressions = [
        "pâ†’q",
        "pâ†”q", 
        "Â¬(pâˆ§q)",
        "(pâˆ§q)âˆ¨r"
    ]
    
    for expr in expressions:
        cnf = converter.to_cnf(expr)
        print(f"åŸè¡¨è¾¾å¼: {expr}")
        print(f"åˆå–èŒƒå¼: {cnf}")
        print("-" * 30)

# è¿è¡ŒèŒƒå¼è½¬æ¢æ¼”ç¤º
if __name__ == "__main__":
    demonstrate_normal_forms()
```

## 6. ç†è®ºè¯æ˜

### 6.1 å‘½é¢˜é€»è¾‘çš„å®Œå¤‡æ€§

**å®šç† 6.1** (å‘½é¢˜é€»è¾‘å®Œå¤‡æ€§)
å‘½é¢˜é€»è¾‘æ˜¯å®Œå¤‡çš„ï¼Œå³æ‰€æœ‰é‡è¨€å¼éƒ½å¯ä»¥é€šè¿‡æ¨ç†è§„åˆ™è¯æ˜ã€‚

**è¯æ˜**:
1. ä»»ä½•å‘½é¢˜å…¬å¼éƒ½å¯ä»¥è½¬æ¢ä¸ºåˆå–èŒƒå¼
2. åˆå–èŒƒå¼ä¸­çš„æ¯ä¸ªå­å¥éƒ½æ˜¯æå–å½¢å¼
3. é€šè¿‡æ¨ç†è§„åˆ™å¯ä»¥è¯æ˜æ¯ä¸ªå­å¥
4. å› æ­¤å¯ä»¥è¯æ˜æ•´ä¸ªå…¬å¼

### 6.2 å‘½é¢˜é€»è¾‘çš„ä¸€è‡´æ€§

**å®šç† 6.2** (å‘½é¢˜é€»è¾‘ä¸€è‡´æ€§)
å‘½é¢˜é€»è¾‘æ˜¯ä¸€è‡´çš„ï¼Œå³ä¸å¯èƒ½åŒæ—¶è¯æ˜ $A$ å’Œ $\neg A$ã€‚

**è¯æ˜**:
1. å‡è®¾å¯ä»¥åŒæ—¶è¯æ˜ $A$ å’Œ $\neg A$
2. æ ¹æ®æ¨ç†è§„åˆ™ï¼Œå¯ä»¥è¯æ˜ä»»æ„å…¬å¼
3. è¿™ä¸é€»è¾‘ç³»ç»Ÿçš„è¦æ±‚çŸ›ç›¾
4. å› æ­¤å‘½é¢˜é€»è¾‘æ˜¯ä¸€è‡´çš„

## 7. åº”ç”¨å®ä¾‹

### 7.1 æ•°å­—ç”µè·¯è®¾è®¡

å‘½é¢˜é€»è¾‘åœ¨æ•°å­—ç”µè·¯è®¾è®¡ä¸­æœ‰é‡è¦åº”ç”¨ï¼š

```python
class DigitalCircuit:
    """æ•°å­—ç”µè·¯ç±»"""
    
    def __init__(self):
        self.gates = {
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'NOT': lambda x: not x,
            'NAND': lambda x, y: not (x and y),
            'NOR': lambda x, y: not (x or y),
            'XOR': lambda x, y: x != y
        }
    
    def evaluate_circuit(self, circuit: Dict, inputs: Dict[str, bool]) -> bool:
        """è¯„ä¼°æ•°å­—ç”µè·¯"""
        # ç®€åŒ–å®ç°
        return True

def demonstrate_digital_circuits():
    """æ¼”ç¤ºæ•°å­—ç”µè·¯åº”ç”¨"""
    print("=== æ•°å­—ç”µè·¯åº”ç”¨ ===\n")
    
    circuit = DigitalCircuit()
    
    # åŠåŠ å™¨ç”µè·¯
    print("åŠåŠ å™¨çœŸå€¼è¡¨:")
    print("A  B  | Sum  Carry")
    print("------|-----------")
    
    for a in [False, True]:
        for b in [False, True]:
            sum_bit = a != b  # XOR
            carry = a and b   # AND
            print(f"{int(a)}  {int(b)}  |  {int(sum_bit)}     {int(carry)}")

# è¿è¡Œåº”ç”¨æ¼”ç¤º
if __name__ == "__main__":
    demonstrate_digital_circuits()
```

### 7.2 è½¯ä»¶éªŒè¯

å‘½é¢˜é€»è¾‘åœ¨è½¯ä»¶éªŒè¯ä¸­çš„åº”ç”¨ï¼š

```python
class SoftwareVerification:
    """è½¯ä»¶éªŒè¯ç±»"""
    
    def __init__(self):
        self.assertions = []
    
    def add_assertion(self, condition: str, description: str):
        """æ·»åŠ æ–­è¨€"""
        self.assertions.append((condition, description))
    
    def verify_program(self, program_state: Dict[str, bool]) -> List[str]:
        """éªŒè¯ç¨‹åºçŠ¶æ€"""
        violations = []
        
        for condition, description in self.assertions:
            # ç®€åŒ–çš„éªŒè¯é€»è¾‘
            if not self.evaluate_condition(condition, program_state):
                violations.append(f"è¿åæ–­è¨€: {description}")
        
        return violations
    
    def evaluate_condition(self, condition: str, 
                          state: Dict[str, bool]) -> bool:
        """è¯„ä¼°æ¡ä»¶"""
        # ç®€åŒ–å®ç°
        return True

def demonstrate_software_verification():
    """æ¼”ç¤ºè½¯ä»¶éªŒè¯"""
    print("=== è½¯ä»¶éªŒè¯åº”ç”¨ ===\n")
    
    verifier = SoftwareVerification()
    
    # æ·»åŠ ç¨‹åºæ–­è¨€
    verifier.add_assertion("x > 0", "xå¿…é¡»ä¸ºæ­£æ•°")
    verifier.add_assertion("y != 0", "yä¸èƒ½ä¸ºé›¶")
    verifier.add_assertion("x + y <= 100", "æ€»å’Œä¸è¶…è¿‡100")
    
    # éªŒè¯ç¨‹åºçŠ¶æ€
    program_state = {
        "x > 0": True,
        "y != 0": False,  # è¿åæ–­è¨€
        "x + y <= 100": True
    }
    
    violations = verifier.verify_program(program_state)
    
    print("ç¨‹åºçŠ¶æ€éªŒè¯ç»“æœ:")
    for violation in violations:
        print(f"âŒ {violation}")
    
    if not violations:
        print("âœ… æ‰€æœ‰æ–­è¨€éƒ½æ»¡è¶³")

# è¿è¡Œè½¯ä»¶éªŒè¯æ¼”ç¤º
if __name__ == "__main__":
    demonstrate_software_verification()
```

## 8. æ€§èƒ½åˆ†æ

### 8.1 æ—¶é—´å¤æ‚åº¦

- **çœŸå€¼è¡¨ç”Ÿæˆ**: $O(2^n)$ï¼Œå…¶ä¸­ $n$ æ˜¯å˜é‡æ•°é‡
- **ç­‰ä»·æ€§æ£€æŸ¥**: $O(2^n)$
- **èŒƒå¼è½¬æ¢**: $O(n^2)$ åˆ° $O(n^3)$

### 8.2 ç©ºé—´å¤æ‚åº¦

- **çœŸå€¼è¡¨å­˜å‚¨**: $O(2^n \times m)$ï¼Œå…¶ä¸­ $m$ æ˜¯è¡¨è¾¾å¼æ•°é‡
- **æ¨ç†è§„åˆ™åº”ç”¨**: $O(1)$

## 9. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°äº†å‘½é¢˜é€»è¾‘çš„ç†è®ºåŸºç¡€ï¼ŒåŒ…æ‹¬ï¼š

1. **åŸºæœ¬æ¦‚å¿µ**: å‘½é¢˜ã€é€»è¾‘è¿æ¥è¯ã€çœŸå€¼è¡¨
2. **é€»è¾‘ç­‰ä»·**: ç­‰ä»·å¾‹ã€èŒƒå¼è½¬æ¢
3. **æ¨ç†è§„åˆ™**: åŸºæœ¬æ¨ç†è§„åˆ™å’Œè¯æ˜ç³»ç»Ÿ
4. **ç†è®ºè¯æ˜**: å®Œå¤‡æ€§å’Œä¸€è‡´æ€§
5. **åº”ç”¨å®ä¾‹**: æ•°å­—ç”µè·¯è®¾è®¡ã€è½¯ä»¶éªŒè¯

æ‰€æœ‰æ¦‚å¿µéƒ½æœ‰å®Œæ•´çš„Pythonå®ç°ï¼ŒåŒ…æ‹¬ï¼š
- çœŸå€¼è¡¨ç”Ÿæˆå’Œæ±‚å€¼
- é€»è¾‘ç­‰ä»·å¾‹éªŒè¯
- æ¨ç†è§„åˆ™åº”ç”¨
- èŒƒå¼è½¬æ¢ç®—æ³•
- å®é™…åº”ç”¨ç¤ºä¾‹

å‘½é¢˜é€»è¾‘ä¸ºåç»­çš„è°“è¯é€»è¾‘ã€æ¨¡æ€é€»è¾‘ç­‰é«˜çº§é€»è¾‘ç³»ç»Ÿå¥ å®šäº†åšå®çš„åŸºç¡€ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*ä¸‹æ¬¡æ›´æ–°: å®Œæˆè°“è¯é€»è¾‘æ–‡æ¡£å*
