# 01-02-01 命题逻辑

## 📋 概述

命题逻辑是形式逻辑的基础，研究命题之间的逻辑关系。本文档从形式化角度定义命题逻辑，建立完整的推理体系，并提供Python实现。

## 🎯 核心概念

### 1. 命题逻辑的形式化定义

#### 1.1 基本定义

**定义 1.1** (命题)
命题是一个可以判断真假的陈述句，用符号 $p, q, r, \ldots$ 表示。

**定义 1.2** (命题变元)
命题变元是表示命题的符号，取值于集合 $\{true, false\}$。

**定义 1.3** (逻辑连接词)
逻辑连接词包括：
- $\neg$ (否定): $\neg p$ 表示"非 $p$"
- $\land$ (合取): $p \land q$ 表示"$p$ 且 $q$"
- $\lor$ (析取): $p \lor q$ 表示"$p$ 或 $q$"
- $\rightarrow$ (蕴含): $p \rightarrow q$ 表示"如果 $p$ 则 $q$"
- $\leftrightarrow$ (等价): $p \leftrightarrow q$ 表示"$p$ 当且仅当 $q$"

**定义 1.4** (命题公式)
命题公式递归定义如下：
1. 命题变元是命题公式
2. 如果 $\phi$ 是命题公式，则 $\neg \phi$ 是命题公式
3. 如果 $\phi$ 和 $\psi$ 是命题公式，则 $(\phi \land \psi)$、$(\phi \lor \psi)$、$(\phi \rightarrow \psi)$、$(\phi \leftrightarrow \psi)$ 是命题公式

#### 1.2 Python实现

```python
from abc import ABC, abstractmethod
from typing import Dict, Set, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import itertools

class TruthValue(Enum):
    """真值"""
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """命题"""
    name: str
    value: Optional[TruthValue] = None

    def __str__(self) -> str:
        return self.name

class LogicalOperator(Enum):
    """逻辑操作符"""
    NOT = "¬"
    AND = "∧"
    OR = "∨"
    IMPLIES = "→"
    EQUIVALENT = "↔"

class PropositionalFormula(ABC):
    """命题公式抽象基类"""

    @abstractmethod
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        """求值"""
        pass

    @abstractmethod
    def get_variables(self) -> Set[str]:
        """获取变量集合"""
        pass

    @abstractmethod
    def __str__(self) -> str:
        """字符串表示"""
        pass

class PropositionalVariable(PropositionalFormula):
    """命题变元"""

    def __init__(self, name: str):
        self.name = name

    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        return interpretation[self.name]

    def get_variables(self) -> Set[str]:
        return {self.name}

    def __str__(self) -> str:
        return self.name

class Negation(PropositionalFormula):
    """否定"""

    def __init__(self, formula: PropositionalFormula):
        self.formula = formula

    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        result = self.formula.evaluate(interpretation)
        return TruthValue.FALSE if result == TruthValue.TRUE else TruthValue.TRUE

    def get_variables(self) -> Set[str]:
        return self.formula.get_variables()

    def __str__(self) -> str:
        return f"¬({self.formula})"

class BinaryOperator(PropositionalFormula):
    """二元操作符"""

    def __init__(self, left: PropositionalFormula, right: PropositionalFormula, operator: LogicalOperator):
        self.left = left
        self.right = right
        self.operator = operator

    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        left_val = self.left.evaluate(interpretation)
        right_val = self.right.evaluate(interpretation)

        if self.operator == LogicalOperator.AND:
            return TruthValue.TRUE if (left_val == TruthValue.TRUE and right_val == TruthValue.TRUE) else TruthValue.FALSE
        elif self.operator == LogicalOperator.OR:
            return TruthValue.TRUE if (left_val == TruthValue.TRUE or right_val == TruthValue.TRUE) else TruthValue.FALSE
        elif self.operator == LogicalOperator.IMPLIES:
            return TruthValue.FALSE if (left_val == TruthValue.TRUE and right_val == TruthValue.FALSE) else TruthValue.TRUE
        elif self.operator == LogicalOperator.EQUIVALENT:
            return TruthValue.TRUE if left_val == right_val else TruthValue.FALSE
        else:
            raise ValueError(f"Unknown operator: {self.operator}")

    def get_variables(self) -> Set[str]:
        return self.left.get_variables() | self.right.get_variables()

    def __str__(self) -> str:
        return f"({self.left} {self.operator.value} {self.right})"

class TruthTable:
    """真值表"""

    def __init__(self, formula: PropositionalFormula):
        self.formula = formula
        self.variables = sorted(list(formula.get_variables()))

    def generate(self) -> List[Dict[str, Any]]:
        """生成真值表"""
        table = []
        n = len(self.variables)
        
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=n):
            interpretation = dict(zip(self.variables, values))
            result = self.formula.evaluate(interpretation)
            
            row = interpretation.copy()
            row['result'] = result
            table.append(row)
        
        return table

    def print_table(self) -> None:
        """打印真值表"""
        table = self.generate()
        
        # 打印表头
        header = " | ".join(self.variables + ["Result"])
        print(header)
        print("-" * len(header))
        
        # 打印数据行
        for row in table:
            values = [str(row[var].value) for var in self.variables]
            values.append(str(row['result'].value))
            print(" | ".join(values))

    def is_tautology(self) -> bool:
        """判断是否为重言式"""
        return all(row['result'] == TruthValue.TRUE for row in self.generate())

    def is_contradiction(self) -> bool:
        """判断是否为矛盾式"""
        return all(row['result'] == TruthValue.FALSE for row in self.generate())

    def is_satisfiable(self) -> bool:
        """判断是否为可满足式"""
        return any(row['result'] == TruthValue.TRUE for row in self.generate())

# 使用示例
def test_propositional_logic():
    """测试命题逻辑"""
    # 创建命题变元
    p = PropositionalVariable("p")
    q = PropositionalVariable("q")
    
    # 创建复合公式
    formula1 = BinaryOperator(p, q, LogicalOperator.AND)  # p ∧ q
    formula2 = BinaryOperator(p, q, LogicalOperator.OR)   # p ∨ q
    formula3 = BinaryOperator(p, q, LogicalOperator.IMPLIES)  # p → q
    formula4 = Negation(BinaryOperator(p, q, LogicalOperator.AND))  # ¬(p ∧ q)
    
    print("Testing Propositional Logic:")
    print(f"Formula 1: {formula1}")
    print(f"Formula 2: {formula2}")
    print(f"Formula 3: {formula3}")
    print(f"Formula 4: {formula4}")
    
    # 生成真值表
    print("\nTruth Table for p ∧ q:")
    tt1 = TruthTable(formula1)
    tt1.print_table()
    
    print(f"\nIs tautology: {tt1.is_tautology()}")
    print(f"Is contradiction: {tt1.is_contradiction()}")
    print(f"Is satisfiable: {tt1.is_satisfiable()}")

if __name__ == "__main__":
    test_propositional_logic()
```

## 📊 逻辑运算

### 2.1 基本逻辑运算

#### 2.1.1 否定（NOT）

**定义 2.1** (否定)
否定运算定义为：
$$\neg: \mathbb{B} \rightarrow \mathbb{B}$$
$$\neg p = \begin{cases}
False & \text{if } p = True \\
True & \text{if } p = False
\end{cases}$$

**真值表**:
| P | ¬P |
|---|----|
| T | F  |
| F | T  |

#### 2.1.2 合取（AND）

**定义 2.2** (合取)
合取运算定义为：
$$\land: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \land q = \begin{cases}
True & \text{if } p = True \text{ and } q = True \\
False & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P ∧ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   F   |
| F | F |   F   |

#### 2.1.3 析取（OR）

**定义 2.3** (析取)
析取运算定义为：
$$\lor: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \lor q = \begin{cases}
False & \text{if } p = False \text{ and } q = False \\
True & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P ∨ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   T   |
| F | T |   T   |
| F | F |   F   |

#### 2.1.4 蕴含（IMPLIES）

**定义 2.4** (蕴含)
蕴含运算定义为：
$$\rightarrow: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \rightarrow q = \begin{cases}
False & \text{if } p = True \text{ and } q = False \\
True & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P → Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   T   |
| F | F |   T   |

#### 2.1.5 等价（IFF）

**定义 2.5** (等价)
等价运算定义为：
$$\leftrightarrow: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \leftrightarrow q = \begin{cases}
True & \text{if } p = q \\
False & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P ↔ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   F   |
| F | F |   T   |

### 2.2 逻辑等价律

#### 2.2.1 基本等价律

**定理 2.1** (双重否定律)
$$\neg \neg p \equiv p$$

**定理 2.2** (德摩根律)
$$\neg(p \land q) \equiv \neg p \lor \neg q$$
$$\neg(p \lor q) \equiv \neg p \land \neg q$$

**定理 2.3** (分配律)
$$p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$$
$$p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$$

**定理 2.4** (结合律)
$$(p \land q) \land r \equiv p \land (q \land r)$$
$$(p \lor q) \lor r \equiv p \lor (q \lor r)$$

**定理 2.5** (交换律)
$$p \land q \equiv q \land p$$
$$p \lor q \equiv q \lor p$$

#### 2.2.2 蕴含等价律

**定理 2.6** (蕴含等价)
$$p \rightarrow q \equiv \neg p \lor q$$

**定理 2.7** (等价展开)
$$p \leftrightarrow q \equiv (p \rightarrow q) \land (q \rightarrow p)$$

## 🔍 逻辑推理

### 3.1 推理规则

#### 3.1.1 假言推理（Modus Ponens）

**规则 3.1** (假言推理)
$$\frac{p \rightarrow q, p}{q}$$

**证明**:
1. 假设 $p \rightarrow q$ 为真
2. 假设 $p$ 为真
3. 根据蕴含定义，$q$ 必须为真
4. 因此结论 $q$ 成立

#### 3.1.2 拒取式（Modus Tollens）

**规则 3.2** (拒取式)
$$\frac{p \rightarrow q, \neg q}{\neg p}$$

**证明**:
1. 假设 $p \rightarrow q$ 为真
2. 假设 $\neg q$ 为真（即 $q$ 为假）
3. 如果 $p$ 为真，则根据蕴含定义 $q$ 必须为真，矛盾
4. 因此 $p$ 必须为假，即 $\neg p$ 为真

#### 3.1.3 假言三段论

**规则 3.3** (假言三段论)
$$\frac{p \rightarrow q, q \rightarrow r}{p \rightarrow r}$$

**证明**:
1. 假设 $p \rightarrow q$ 为真
2. 假设 $q \rightarrow r$ 为真
3. 如果 $p$ 为真，则 $q$ 为真（由1）
4. 如果 $q$ 为真，则 $r$ 为真（由2）
5. 因此 $p \rightarrow r$ 为真

### 3.2 逻辑后承

**定义 3.1** (逻辑后承)
公式 $\psi$ 是公式集合 $\Gamma$ 的逻辑后承，记作 $\Gamma \models \psi$，当且仅当：
$$\forall I, (\forall \phi \in \Gamma, I \models \phi) \Rightarrow I \models \psi$$

其中 $I$ 是解释，$I \models \phi$ 表示在解释 $I$ 下公式 $\phi$ 为真。

**定理 3.1** (逻辑后承的性质)
1. **自反性**: $\phi \models \phi$
2. **传递性**: 如果 $\Gamma \models \phi$ 且 $\phi \models \psi$，则 $\Gamma \models \psi$
3. **单调性**: 如果 $\Gamma \models \phi$ 且 $\Gamma \subseteq \Delta$，则 $\Delta \models \phi$

## 🎯 逻辑系统

### 4.1 公理系统

#### 4.1.1 命题逻辑公理

**公理 4.1** (命题逻辑公理)
1. $p \rightarrow (q \rightarrow p)$
2. $(p \rightarrow (q \rightarrow r)) \rightarrow ((p \rightarrow q) \rightarrow (p \rightarrow r))$
3. $(\neg p \rightarrow \neg q) \rightarrow (q \rightarrow p)$

**推理规则 4.1** (分离规则)
$$\frac{\phi \quad \phi \rightarrow \psi}{\psi}$$

#### 4.1.2 自然演绎系统

**规则 4.2** (自然演绎规则)

**引入规则**:
- $\land I$: $\frac{\phi \quad \psi}{\phi \land \psi}$
- $\lor I$: $\frac{\phi}{\phi \lor \psi}$ 或 $\frac{\psi}{\phi \lor \psi}$
- $\rightarrow I$: $\frac{[\phi] \quad \psi}{\phi \rightarrow \psi}$

**消除规则**:
- $\land E$: $\frac{\phi \land \psi}{\phi}$ 或 $\frac{\phi \land \psi}{\psi}$
- $\lor E$: $\frac{\phi \lor \psi \quad [\phi] \quad \chi \quad [\psi] \quad \chi}{\chi}$
- $\rightarrow E$: $\frac{\phi \quad \phi \rightarrow \psi}{\psi}$

### 4.2 完备性定理

**定理 4.1** (命题逻辑完备性)
如果 $\Gamma \models \phi$，则 $\Gamma \vdash \phi$。

**证明思路**:
1. 使用真值表方法
2. 构造证明树
3. 使用归结方法

## 📈 应用领域

### 5.1 计算机科学应用

#### 5.1.1 电路设计

- **逻辑门**: AND、OR、NOT、NAND、NOR、XOR
- **组合电路**: 真值表到电路图的转换
- **时序电路**: 状态机设计

#### 5.1.2 程序验证

- **前置条件**: 程序执行前的状态约束
- **后置条件**: 程序执行后的状态约束
- **不变式**: 程序执行过程中保持的性质

#### 5.1.3 人工智能

- **知识表示**: 命题逻辑作为知识表示语言
- **推理系统**: 基于规则的专家系统
- **约束满足**: 约束满足问题的建模

### 5.2 数学应用

#### 5.2.1 集合论

- **集合运算**: 并集、交集、补集
- **集合关系**: 包含、相等、不相交

#### 5.2.2 数论

- **整除性**: 质数、合数、最大公约数
- **同余**: 模运算、中国剩余定理

## 🔗 相关链接

- [01-02-02 谓词逻辑](./01-02-02-谓词逻辑.md)
- [01-02-03 模态逻辑](./01-02-03-模态逻辑.md)
- [02-01-01 算法基础](../../02-理论基础/02-01-算法理论/02-01-01-算法基础.md)
- [03-01-01 创建型模式](../../03-具体科学/03-01-设计模式/03-01-01-创建型模式.md)

---

*本文档建立了命题逻辑的完整理论框架，从形式化定义到实际实现，为后续的逻辑学学习奠定了坚实的基础。*
