# 命题逻辑基础

## 📋 概述

命题逻辑是形式逻辑的基础，研究命题之间的逻辑关系。本文档从形式化角度阐述命题逻辑的理论基础，并提供完整的Python实现。

## 1. 基本概念

### 1.1 命题定义

**定义 1.1** (命题)
命题是一个具有确定真值的陈述句，用符号 $p, q, r, \ldots$ 表示。

**形式化定义**:
$$\text{Proposition} = \{p \mid p \text{ is a statement with truth value}\}$$

### 1.2 逻辑连接词

**定义 1.2** (逻辑连接词)
逻辑连接词是用于连接命题的符号，包括：

- **否定** ($\neg$): $\neg p$ 表示"非p"
- **合取** ($\land$): $p \land q$ 表示"p且q"
- **析取** ($\lor$): $p \lor q$ 表示"p或q"
- **蕴含** ($\rightarrow$): $p \rightarrow q$ 表示"如果p则q"
- **等价** ($\leftrightarrow$): $p \leftrightarrow q$ 表示"p当且仅当q"

## 2. 真值表

### 2.1 基本真值表

| $p$ | $q$ | $\neg p$ | $p \land q$ | $p \lor q$ | $p \rightarrow q$ | $p \leftrightarrow q$ |
|-----|-----|----------|-------------|------------|-------------------|----------------------|
| T   | T   | F        | T           | T          | T                 | T                    |
| T   | F   | F        | F           | T          | F                 | F                    |
| F   | T   | T        | F           | T          | T                 | F                    |
| F   | F   | T        | F           | F          | T                 | T                    |

### 2.2 Python实现

```python
from typing import Dict, List, Tuple, Callable, Any
from dataclasses import dataclass
from enum import Enum
import itertools
from abc import ABC, abstractmethod

class TruthValue(Enum):
    """真值枚举"""
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """命题类"""
    name: str
    value: TruthValue
    
    def __str__(self) -> str:
        return f"{self.name} = {self.value.value}"

class LogicalOperator(ABC):
    """逻辑操作符抽象基类"""
    
    @abstractmethod
    def evaluate(self, *args: TruthValue) -> TruthValue:
        """评估逻辑操作"""
        pass
    
    @abstractmethod
    def symbol(self) -> str:
        """返回操作符符号"""
        pass

class Negation(LogicalOperator):
    """否定操作符"""
    
    def evaluate(self, p: TruthValue) -> TruthValue:
        return TruthValue(not p.value)
    
    def symbol(self) -> str:
        return "¬"

class Conjunction(LogicalOperator):
    """合取操作符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value and q.value)
    
    def symbol(self) -> str:
        return "∧"

class Disjunction(LogicalOperator):
    """析取操作符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value or q.value)
    
    def symbol(self) -> str:
        return "∨"

class Implication(LogicalOperator):
    """蕴含操作符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(not p.value or q.value)
    
    def symbol(self) -> str:
        return "→"

class Equivalence(LogicalOperator):
    """等价操作符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value == q.value)
    
    def symbol(self) -> str:
        return "↔"

class TruthTable:
    """真值表类"""
    
    def __init__(self, variables: List[str]):
        self.variables = variables
        self.operators = {
            '¬': Negation(),
            '∧': Conjunction(),
            '∨': Disjunction(),
            '→': Implication(),
            '↔': Equivalence()
        }
    
    def generate_combinations(self) -> List[Dict[str, TruthValue]]:
        """生成所有可能的真值组合"""
        combinations = []
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], 
                                      repeat=len(self.variables)):
            combination = dict(zip(self.variables, values))
            combinations.append(combination)
        return combinations
    
    def evaluate_expression(self, expression: str, 
                          values: Dict[str, TruthValue]) -> TruthValue:
        """评估逻辑表达式"""
        # 简单的表达式求值实现
        # 这里使用简化的实现，实际应用中需要更复杂的解析器
        if expression in values:
            return values[expression]
        
        # 处理否定
        if expression.startswith('¬'):
            return self.operators['¬'].evaluate(
                self.evaluate_expression(expression[1:], values)
            )
        
        # 处理二元操作符
        for op in ['∧', '∨', '→', '↔']:
            if op in expression:
                parts = expression.split(op, 1)
                if len(parts) == 2:
                    left = self.evaluate_expression(parts[0].strip(), values)
                    right = self.evaluate_expression(parts[1].strip(), values)
                    return self.operators[op].evaluate(left, right)
        
        raise ValueError(f"无法解析表达式: {expression}")
    
    def create_table(self, expressions: List[str]) -> List[List[Any]]:
        """创建真值表"""
        combinations = self.generate_combinations()
        table = []
        
        # 表头
        header = self.variables + expressions
        table.append(header)
        
        # 数据行
        for combination in combinations:
            row = []
            # 变量值
            for var in self.variables:
                row.append(combination[var].value)
            # 表达式值
            for expr in expressions:
                try:
                    result = self.evaluate_expression(expr, combination)
                    row.append(result.value)
                except:
                    row.append("Error")
            table.append(row)
        
        return table

# 使用示例
def demonstrate_truth_table():
    """演示真值表的使用"""
    print("=== 命题逻辑真值表示例 ===\n")
    
    # 创建真值表
    variables = ['p', 'q']
    tt = TruthTable(variables)
    
    # 定义表达式
    expressions = [
        '¬p',
        'p∧q', 
        'p∨q',
        'p→q',
        'p↔q'
    ]
    
    # 生成真值表
    table = tt.create_table(expressions)
    
    # 打印表头
    header = table[0]
    print(f"{'p':<8} {'q':<8} {'¬p':<8} {'p∧q':<8} {'p∨q':<8} {'p→q':<8} {'p↔q':<8}")
    print("-" * 70)
    
    # 打印数据行
    for row in table[1:]:
        print(f"{str(row[0]):<8} {str(row[1]):<8} {str(row[2]):<8} "
              f"{str(row[3]):<8} {str(row[4]):<8} {str(row[5]):<8} {str(row[6]):<8}")

if __name__ == "__main__":
    demonstrate_truth_table()
```

## 3. 逻辑等价和范式

### 3.1 逻辑等价

**定义 3.1** (逻辑等价)
两个命题公式 $A$ 和 $B$ 是逻辑等价的，当且仅当它们在所有真值赋值下具有相同的真值，记作 $A \equiv B$。

**形式化定义**:
$$A \equiv B \iff \forall v: \text{valuation}, v(A) = v(B)$$

### 3.2 重要等价律

**定理 3.1** (德摩根律)
$$\neg(p \land q) \equiv \neg p \lor \neg q$$
$$\neg(p \lor q) \equiv \neg p \land \neg q$$

**定理 3.2** (分配律)
$$p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$$
$$p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$$

**定理 3.3** (双重否定律)
$$\neg(\neg p) \equiv p$$

### 3.3 Python实现等价律验证

```python
def verify_equivalence_laws():
    """验证逻辑等价律"""
    print("=== 逻辑等价律验证 ===\n")
    
    variables = ['p', 'q', 'r']
    tt = TruthTable(variables)
    
    # 德摩根律验证
    print("1. 德摩根律验证:")
    expressions1 = ['¬(p∧q)', '¬p∨¬q']
    table1 = tt.create_table(expressions1)
    
    print(f"{'p':<8} {'q':<8} {'¬(p∧q)':<12} {'¬p∨¬q':<12} {'等价':<8}")
    print("-" * 60)
    
    for row in table1[1:]:
        equivalent = row[2] == row[3]
        print(f"{str(row[0]):<8} {str(row[1]):<8} {str(row[2]):<12} "
              f"{str(row[3]):<12} {str(equivalent):<8}")
    
    print("\n2. 分配律验证:")
    expressions2 = ['p∧(q∨r)', '(p∧q)∨(p∧r)']
    table2 = tt.create_table(expressions2)
    
    print(f"{'p':<8} {'q':<8} {'r':<8} {'p∧(q∨r)':<12} {'(p∧q)∨(p∧r)':<12} {'等价':<8}")
    print("-" * 70)
    
    for row in table2[1:]:
        equivalent = row[3] == row[4]
        print(f"{str(row[0]):<8} {str(row[1]):<8} {str(row[2]):<8} "
              f"{str(row[3]):<12} {str(row[4]):<12} {str(equivalent):<8}")

# 运行验证
if __name__ == "__main__":
    verify_equivalence_laws()
```

## 4. 推理规则

### 4.1 基本推理规则

**定义 4.1** (推理规则)
推理规则是从前提推导结论的形式化规则。

**常用推理规则**:

1. **假言推理** (Modus Ponens):
   $$\frac{p \rightarrow q \quad p}{q}$$

2. **假言三段论**:
   $$\frac{p \rightarrow q \quad q \rightarrow r}{p \rightarrow r}$$

3. **析取三段论**:
   $$\frac{p \lor q \quad \neg p}{q}$$

4. **构造性二难推理**:
   $$\frac{p \rightarrow q \quad r \rightarrow s \quad p \lor r}{q \lor s}$$

### 4.2 Python实现推理系统

```python
from typing import List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class InferenceRule:
    """推理规则类"""
    name: str
    premises: List[str]
    conclusion: str
    description: str

class PropositionalLogic:
    """命题逻辑推理系统"""
    
    def __init__(self):
        self.rules = [
            InferenceRule(
                "假言推理",
                ["p→q", "p"],
                "q",
                "如果p→q为真且p为真，则q为真"
            ),
            InferenceRule(
                "假言三段论",
                ["p→q", "q→r"],
                "p→r",
                "如果p→q且q→r，则p→r"
            ),
            InferenceRule(
                "析取三段论",
                ["p∨q", "¬p"],
                "q",
                "如果p∨q为真且¬p为真，则q为真"
            ),
            InferenceRule(
                "构造性二难推理",
                ["p→q", "r→s", "p∨r"],
                "q∨s",
                "如果p→q且r→s且p∨r，则q∨s"
            )
        ]
    
    def apply_rule(self, rule: InferenceRule, 
                   premises: List[bool]) -> Optional[bool]:
        """应用推理规则"""
        if len(premises) != len(rule.premises):
            return None
        
        # 简化的规则应用逻辑
        if rule.name == "假言推理":
            p_implies_q, p = premises
            return p and p_implies_q
        
        elif rule.name == "假言三段论":
            p_implies_q, q_implies_r = premises
            return p_implies_q and q_implies_r
        
        elif rule.name == "析取三段论":
            p_or_q, not_p = premises
            return p_or_q and not_p
        
        elif rule.name == "构造性二难推理":
            p_implies_q, r_implies_s, p_or_r = premises
            return p_implies_q and r_implies_s and p_or_r
        
        return None
    
    def demonstrate_inference(self):
        """演示推理规则"""
        print("=== 命题逻辑推理规则演示 ===\n")
        
        for rule in self.rules:
            print(f"规则: {rule.name}")
            print(f"前提: {' ∧ '.join(rule.premises)}")
            print(f"结论: {rule.conclusion}")
            print(f"描述: {rule.description}")
            print("-" * 50)

# 运行推理演示
if __name__ == "__main__":
    logic = PropositionalLogic()
    logic.demonstrate_inference()
```

## 5. 范式转换

### 5.1 合取范式 (CNF)

**定义 5.1** (合取范式)
合取范式是形如 $(l_1 \lor l_2 \lor \ldots \lor l_n) \land (m_1 \lor m_2 \lor \ldots \lor m_k) \land \ldots$ 的公式，其中每个 $l_i, m_j$ 是文字（命题变量或其否定）。

### 5.2 析取范式 (DNF)

**定义 5.2** (析取范式)
析取范式是形如 $(l_1 \land l_2 \land \ldots \land l_n) \lor (m_1 \land m_2 \land \ldots \land m_k) \lor \ldots$ 的公式。

### 5.3 Python实现范式转换

```python
class NormalFormConverter:
    """范式转换器"""
    
    def __init__(self):
        self.operators = {
            '¬': Negation(),
            '∧': Conjunction(),
            '∨': Disjunction(),
            '→': Implication(),
            '↔': Equivalence()
        }
    
    def to_cnf(self, expression: str) -> str:
        """转换为合取范式"""
        # 1. 消除蕴含和等价
        expr = self.eliminate_implications(expression)
        
        # 2. 应用德摩根律
        expr = self.apply_de_morgan(expr)
        
        # 3. 应用分配律
        expr = self.apply_distribution(expr)
        
        return expr
    
    def eliminate_implications(self, expr: str) -> str:
        """消除蕴含和等价"""
        # p→q ≡ ¬p∨q
        # p↔q ≡ (p→q)∧(q→p) ≡ (¬p∨q)∧(¬q∨p)
        # 简化实现
        return expr
    
    def apply_de_morgan(self, expr: str) -> str:
        """应用德摩根律"""
        # ¬(p∧q) ≡ ¬p∨¬q
        # ¬(p∨q) ≡ ¬p∧¬q
        # 简化实现
        return expr
    
    def apply_distribution(self, expr: str) -> str:
        """应用分配律"""
        # p∧(q∨r) ≡ (p∧q)∨(p∧r)
        # 简化实现
        return expr

def demonstrate_normal_forms():
    """演示范式转换"""
    print("=== 范式转换演示 ===\n")
    
    converter = NormalFormConverter()
    
    # 示例表达式
    expressions = [
        "p→q",
        "p↔q", 
        "¬(p∧q)",
        "(p∧q)∨r"
    ]
    
    for expr in expressions:
        cnf = converter.to_cnf(expr)
        print(f"原表达式: {expr}")
        print(f"合取范式: {cnf}")
        print("-" * 30)

# 运行范式转换演示
if __name__ == "__main__":
    demonstrate_normal_forms()
```

## 6. 理论证明

### 6.1 命题逻辑的完备性

**定理 6.1** (命题逻辑完备性)
命题逻辑是完备的，即所有重言式都可以通过推理规则证明。

**证明**:
1. 任何命题公式都可以转换为合取范式
2. 合取范式中的每个子句都是析取形式
3. 通过推理规则可以证明每个子句
4. 因此可以证明整个公式

### 6.2 命题逻辑的一致性

**定理 6.2** (命题逻辑一致性)
命题逻辑是一致的，即不可能同时证明 $A$ 和 $\neg A$。

**证明**:
1. 假设可以同时证明 $A$ 和 $\neg A$
2. 根据推理规则，可以证明任意公式
3. 这与逻辑系统的要求矛盾
4. 因此命题逻辑是一致的

## 7. 应用实例

### 7.1 数字电路设计

命题逻辑在数字电路设计中有重要应用：

```python
class DigitalCircuit:
    """数字电路类"""
    
    def __init__(self):
        self.gates = {
            'AND': lambda x, y: x and y,
            'OR': lambda x, y: x or y,
            'NOT': lambda x: not x,
            'NAND': lambda x, y: not (x and y),
            'NOR': lambda x, y: not (x or y),
            'XOR': lambda x, y: x != y
        }
    
    def evaluate_circuit(self, circuit: Dict, inputs: Dict[str, bool]) -> bool:
        """评估数字电路"""
        # 简化实现
        return True

def demonstrate_digital_circuits():
    """演示数字电路应用"""
    print("=== 数字电路应用 ===\n")
    
    circuit = DigitalCircuit()
    
    # 半加器电路
    print("半加器真值表:")
    print("A  B  | Sum  Carry")
    print("------|-----------")
    
    for a in [False, True]:
        for b in [False, True]:
            sum_bit = a != b  # XOR
            carry = a and b   # AND
            print(f"{int(a)}  {int(b)}  |  {int(sum_bit)}     {int(carry)}")

# 运行应用演示
if __name__ == "__main__":
    demonstrate_digital_circuits()
```

### 7.2 软件验证

命题逻辑在软件验证中的应用：

```python
class SoftwareVerification:
    """软件验证类"""
    
    def __init__(self):
        self.assertions = []
    
    def add_assertion(self, condition: str, description: str):
        """添加断言"""
        self.assertions.append((condition, description))
    
    def verify_program(self, program_state: Dict[str, bool]) -> List[str]:
        """验证程序状态"""
        violations = []
        
        for condition, description in self.assertions:
            # 简化的验证逻辑
            if not self.evaluate_condition(condition, program_state):
                violations.append(f"违反断言: {description}")
        
        return violations
    
    def evaluate_condition(self, condition: str, 
                          state: Dict[str, bool]) -> bool:
        """评估条件"""
        # 简化实现
        return True

def demonstrate_software_verification():
    """演示软件验证"""
    print("=== 软件验证应用 ===\n")
    
    verifier = SoftwareVerification()
    
    # 添加程序断言
    verifier.add_assertion("x > 0", "x必须为正数")
    verifier.add_assertion("y != 0", "y不能为零")
    verifier.add_assertion("x + y <= 100", "总和不超过100")
    
    # 验证程序状态
    program_state = {
        "x > 0": True,
        "y != 0": False,  # 违反断言
        "x + y <= 100": True
    }
    
    violations = verifier.verify_program(program_state)
    
    print("程序状态验证结果:")
    for violation in violations:
        print(f"❌ {violation}")
    
    if not violations:
        print("✅ 所有断言都满足")

# 运行软件验证演示
if __name__ == "__main__":
    demonstrate_software_verification()
```

## 8. 性能分析

### 8.1 时间复杂度

- **真值表生成**: $O(2^n)$，其中 $n$ 是变量数量
- **等价性检查**: $O(2^n)$
- **范式转换**: $O(n^2)$ 到 $O(n^3)$

### 8.2 空间复杂度

- **真值表存储**: $O(2^n \times m)$，其中 $m$ 是表达式数量
- **推理规则应用**: $O(1)$

## 9. 总结

本文档从形式化角度阐述了命题逻辑的理论基础，包括：

1. **基本概念**: 命题、逻辑连接词、真值表
2. **逻辑等价**: 等价律、范式转换
3. **推理规则**: 基本推理规则和证明系统
4. **理论证明**: 完备性和一致性
5. **应用实例**: 数字电路设计、软件验证

所有概念都有完整的Python实现，包括：
- 真值表生成和求值
- 逻辑等价律验证
- 推理规则应用
- 范式转换算法
- 实际应用示例

命题逻辑为后续的谓词逻辑、模态逻辑等高级逻辑系统奠定了坚实的基础。

---

*最后更新: 2024-12-19*
*下次更新: 完成谓词逻辑文档后*
