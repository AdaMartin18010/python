# 01-02-01 命题逻辑

## 概述

命题逻辑是形式逻辑的基础分支，研究命题之间的逻辑关系。在软件工程中，命题逻辑为程序验证、形式化规范和逻辑推理提供理论基础。

## 形式化定义

### 命题逻辑语法

命题逻辑的语言 $\mathcal{L}$ 由以下部分组成：

1. **命题变量集合**: $P = \{p_1, p_2, p_3, \ldots\}$
2. **逻辑连接词**: $\{\neg, \land, \lor, \rightarrow, \leftrightarrow\}$
3. **括号**: $\{(, )\}$

### 命题公式

命题公式递归定义为：

1. 每个命题变量 $p \in P$ 是公式
2. 如果 $\phi$ 是公式，则 $\neg\phi$ 是公式
3. 如果 $\phi$ 和 $\psi$ 是公式，则 $(\phi \land \psi)$、$(\phi \lor \psi)$、$(\phi \rightarrow \psi)$、$(\phi \leftrightarrow \psi)$ 是公式

### 语义定义

**真值赋值**: 函数 $v: P \rightarrow \{0, 1\}$，其中 $0$ 表示假，$1$ 表示真。

**满足关系**: 对于公式 $\phi$ 和真值赋值 $v$，满足关系 $\models$ 定义为：

- $v \models p$ 当且仅当 $v(p) = 1$
- $v \models \neg\phi$ 当且仅当 $v \not\models \phi$
- $v \models \phi \land \psi$ 当且仅当 $v \models \phi$ 且 $v \models \psi$
- $v \models \phi \lor \psi$ 当且仅当 $v \models \phi$ 或 $v \models \psi$
- $v \models \phi \rightarrow \psi$ 当且仅当 $v \not\models \phi$ 或 $v \models \psi$
- $v \models \phi \leftrightarrow \psi$ 当且仅当 $v \models \phi$ 和 $v \models \psi$ 的真值相同

## Python实现

```python
from abc import ABC, abstractmethod
from typing import Dict, Set, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import copy

class LogicalOperator(Enum):
    """逻辑操作符"""
    NOT = "¬"
    AND = "∧"
    OR = "∨"
    IMPLIES = "→"
    EQUIVALENT = "↔"

@dataclass
class Proposition:
    """命题变量"""
    name: str
    
    def __str__(self) -> str:
        return self.name
    
    def __repr__(self) -> str:
        return f"Proposition('{self.name}')"

class Formula(ABC):
    """命题公式抽象基类"""
    
    @abstractmethod
    def evaluate(self, valuation: Dict[str, bool]) -> bool:
        """在给定真值赋值下求值"""
        pass
    
    @abstractmethod
    def get_variables(self) -> Set[str]:
        """获取公式中的所有命题变量"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """字符串表示"""
        pass

class PropositionalVariable(Formula):
    """命题变量公式"""
    
    def __init__(self, name: str):
        self.name = name
    
    def evaluate(self, valuation: Dict[str, bool]) -> bool:
        return valuation.get(self.name, False)
    
    def get_variables(self) -> Set[str]:
        return {self.name}
    
    def __str__(self) -> str:
        return self.name

class Negation(Formula):
    """否定公式 ¬φ"""
    
    def __init__(self, formula: Formula):
        self.formula = formula
    
    def evaluate(self, valuation: Dict[str, bool]) -> bool:
        return not self.formula.evaluate(valuation)
    
    def get_variables(self) -> Set[str]:
        return self.formula.get_variables()
    
    def __str__(self) -> str:
        return f"¬({self.formula})"

class BinaryFormula(Formula):
    """二元逻辑公式的基类"""
    
    def __init__(self, left: Formula, right: Formula, operator: LogicalOperator):
        self.left = left
        self.right = right
        self.operator = operator
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables() | self.right.get_variables()
    
    def __str__(self) -> str:
        return f"({self.left} {self.operator.value} {self.right})"

class Conjunction(BinaryFormula):
    """合取公式 φ ∧ ψ"""
    
    def __init__(self, left: Formula, right: Formula):
        super().__init__(left, right, LogicalOperator.AND)
    
    def evaluate(self, valuation: Dict[str, bool]) -> bool:
        return self.left.evaluate(valuation) and self.right.evaluate(valuation)

class Disjunction(BinaryFormula):
    """析取公式 φ ∨ ψ"""
    
    def __init__(self, left: Formula, right: Formula):
        super().__init__(left, right, LogicalOperator.OR)
    
    def evaluate(self, valuation: Dict[str, bool]) -> bool:
        return self.left.evaluate(valuation) or self.right.evaluate(valuation)

class Implication(BinaryFormula):
    """蕴含公式 φ → ψ"""
    
    def __init__(self, left: Formula, right: Formula):
        super().__init__(left, right, LogicalOperator.IMPLIES)
    
    def evaluate(self, valuation: Dict[str, bool]) -> bool:
        return (not self.left.evaluate(valuation)) or self.right.evaluate(valuation)

class Equivalence(BinaryFormula):
    """等价公式 φ ↔ ψ"""
    
    def __init__(self, left: Formula, right: Formula):
        super().__init__(left, right, LogicalOperator.EQUIVALENT)
    
    def evaluate(self, valuation: Dict[str, bool]) -> bool:
        return self.left.evaluate(valuation) == self.right.evaluate(valuation)

class TruthTable:
    """真值表"""
    
    def __init__(self, formula: Formula):
        self.formula = formula
        self.variables = sorted(list(formula.get_variables()))
    
    def generate(self) -> List[Dict[str, bool]]:
        """生成所有可能的真值赋值"""
        n = len(self.variables)
        assignments = []
        
        for i in range(2**n):
            assignment = {}
            for j, var in enumerate(self.variables):
                assignment[var] = bool((i >> j) & 1)
            assignments.append(assignment)
        
        return assignments
    
    def evaluate_all(self) -> List[Tuple[Dict[str, bool], bool]]:
        """计算所有真值赋值下的结果"""
        assignments = self.generate()
        results = []
        
        for assignment in assignments:
            result = self.formula.evaluate(assignment)
            results.append((assignment, result))
        
        return results
    
    def print_table(self):
        """打印真值表"""
        results = self.evaluate_all()
        
        # 打印表头
        header = " | ".join(self.variables + ["Result"])
        print(header)
        print("-" * len(header))
        
        # 打印每一行
        for assignment, result in results:
            row = " | ".join([
                "T" if assignment[var] else "F" 
                for var in self.variables
            ] + ["T" if result else "F"])
            print(row)

class PropositionalLogic:
    """命题逻辑系统"""
    
    @staticmethod
    def is_tautology(formula: Formula) -> bool:
        """判断公式是否为重言式"""
        table = TruthTable(formula)
        results = table.evaluate_all()
        return all(result for _, result in results)
    
    @staticmethod
    def is_contradiction(formula: Formula) -> bool:
        """判断公式是否为矛盾式"""
        table = TruthTable(formula)
        results = table.evaluate_all()
        return not any(result for _, result in results)
    
    @staticmethod
    def is_satisfiable(formula: Formula) -> bool:
        """判断公式是否可满足"""
        table = TruthTable(formula)
        results = table.evaluate_all()
        return any(result for _, result in results)
    
    @staticmethod
    def is_equivalent(formula1: Formula, formula2: Formula) -> bool:
        """判断两个公式是否等价"""
        # 创建等价公式 φ ↔ ψ
        equivalence = Equivalence(formula1, formula2)
        return PropositionalLogic.is_tautology(equivalence)
    
    @staticmethod
    def implies(formula1: Formula, formula2: Formula) -> bool:
        """判断 formula1 是否蕴含 formula2"""
        # 创建蕴含公式 φ → ψ
        implication = Implication(formula1, formula2)
        return PropositionalLogic.is_tautology(implication)

class CNFConverter:
    """合取范式转换器"""
    
    @staticmethod
    def to_cnf(formula: Formula) -> Formula:
        """将公式转换为合取范式"""
        # 消除蕴含和等价
        formula = CNFConverter._eliminate_implications(formula)
        # 消除双重否定
        formula = CNFConverter._eliminate_double_negation(formula)
        # 应用德摩根律
        formula = CNFConverter._apply_de_morgan(formula)
        # 分配律
        formula = CNFConverter._apply_distributive(formula)
        return formula
    
    @staticmethod
    def _eliminate_implications(formula: Formula) -> Formula:
        """消除蕴含和等价"""
        if isinstance(formula, PropositionalVariable):
            return formula
        elif isinstance(formula, Negation):
            return Negation(CNFConverter._eliminate_implications(formula.formula))
        elif isinstance(formula, Conjunction):
            return Conjunction(
                CNFConverter._eliminate_implications(formula.left),
                CNFConverter._eliminate_implications(formula.right)
            )
        elif isinstance(formula, Disjunction):
            return Disjunction(
                CNFConverter._eliminate_implications(formula.left),
                CNFConverter._eliminate_implications(formula.right)
            )
        elif isinstance(formula, Implication):
            # φ → ψ ≡ ¬φ ∨ ψ
            return Disjunction(
                Negation(CNFConverter._eliminate_implications(formula.left)),
                CNFConverter._eliminate_implications(formula.right)
            )
        elif isinstance(formula, Equivalence):
            # φ ↔ ψ ≡ (φ → ψ) ∧ (ψ → φ)
            left_impl = Implication(formula.left, formula.right)
            right_impl = Implication(formula.right, formula.left)
            return Conjunction(
                CNFConverter._eliminate_implications(left_impl),
                CNFConverter._eliminate_implications(right_impl)
            )
        return formula
    
    @staticmethod
    def _eliminate_double_negation(formula: Formula) -> Formula:
        """消除双重否定"""
        if isinstance(formula, Negation) and isinstance(formula.formula, Negation):
            return CNFConverter._eliminate_double_negation(formula.formula.formula)
        elif isinstance(formula, Negation):
            return Negation(CNFConverter._eliminate_double_negation(formula.formula))
        elif isinstance(formula, Conjunction):
            return Conjunction(
                CNFConverter._eliminate_double_negation(formula.left),
                CNFConverter._eliminate_double_negation(formula.right)
            )
        elif isinstance(formula, Disjunction):
            return Disjunction(
                CNFConverter._eliminate_double_negation(formula.left),
                CNFConverter._eliminate_double_negation(formula.right)
            )
        return formula
    
    @staticmethod
    def _apply_de_morgan(formula: Formula) -> Formula:
        """应用德摩根律"""
        if isinstance(formula, Negation):
            inner = formula.formula
            if isinstance(inner, Conjunction):
                # ¬(φ ∧ ψ) ≡ ¬φ ∨ ¬ψ
                return Disjunction(
                    CNFConverter._apply_de_morgan(Negation(inner.left)),
                    CNFConverter._apply_de_morgan(Negation(inner.right))
                )
            elif isinstance(inner, Disjunction):
                # ¬(φ ∨ ψ) ≡ ¬φ ∧ ¬ψ
                return Conjunction(
                    CNFConverter._apply_de_morgan(Negation(inner.left)),
                    CNFConverter._apply_de_morgan(Negation(inner.right))
                )
            else:
                return Negation(CNFConverter._apply_de_morgan(inner))
        elif isinstance(formula, Conjunction):
            return Conjunction(
                CNFConverter._apply_de_morgan(formula.left),
                CNFConverter._apply_de_morgan(formula.right)
            )
        elif isinstance(formula, Disjunction):
            return Disjunction(
                CNFConverter._apply_de_morgan(formula.left),
                CNFConverter._apply_de_morgan(formula.right)
            )
        return formula
    
    @staticmethod
    def _apply_distributive(formula: Formula) -> Formula:
        """应用分配律"""
        if isinstance(formula, Disjunction):
            left = CNFConverter._apply_distributive(formula.left)
            right = CNFConverter._apply_distributive(formula.right)
            
            # 如果左操作数是合取，应用分配律
            if isinstance(left, Conjunction):
                return Conjunction(
                    CNFConverter._apply_distributive(Disjunction(left.left, right)),
                    CNFConverter._apply_distributive(Disjunction(left.right, right))
                )
            # 如果右操作数是合取，应用分配律
            elif isinstance(right, Conjunction):
                return Conjunction(
                    CNFConverter._apply_distributive(Disjunction(left, right.left)),
                    CNFConverter._apply_distributive(Disjunction(left, right.right))
                )
            else:
                return Disjunction(left, right)
        elif isinstance(formula, Conjunction):
            return Conjunction(
                CNFConverter._apply_distributive(formula.left),
                CNFConverter._apply_distributive(formula.right)
            )
        return formula

# 使用示例
def demonstrate_propositional_logic():
    """演示命题逻辑的基本功能"""
    
    # 创建命题变量
    p = PropositionalVariable("p")
    q = PropositionalVariable("q")
    r = PropositionalVariable("r")
    
    # 创建复杂公式: (p → q) ∧ (q → r) → (p → r)
    formula = Implication(
        Conjunction(
            Implication(p, q),
            Implication(q, r)
        ),
        Implication(p, r)
    )
    
    print(f"公式: {formula}")
    print(f"变量: {formula.get_variables()}")
    
    # 生成真值表
    print("\n真值表:")
    table = TruthTable(formula)
    table.print_table()
    
    # 分析公式性质
    print(f"\n是否为重言式: {PropositionalLogic.is_tautology(formula)}")
    print(f"是否为矛盾式: {PropositionalLogic.is_contradiction(formula)}")
    print(f"是否可满足: {PropositionalLogic.is_satisfiable(formula)}")
    
    # 转换为CNF
    print(f"\n转换为CNF:")
    cnf_formula = CNFConverter.to_cnf(formula)
    print(f"CNF形式: {cnf_formula}")

if __name__ == "__main__":
    demonstrate_propositional_logic()
```

## 数学证明

### 命题逻辑的完备性定理

**定理**: 命题逻辑是完备的，即所有重言式都可以从公理系统推导出来。

**证明**:

1. **公理系统**: 使用以下公理模式：
   - A1: $\phi \rightarrow (\psi \rightarrow \phi)$
   - A2: $(\phi \rightarrow (\psi \rightarrow \chi)) \rightarrow ((\phi \rightarrow \psi) \rightarrow (\phi \rightarrow \chi))$
   - A3: $(\neg\phi \rightarrow \neg\psi) \rightarrow (\psi \rightarrow \phi)$

2. **推理规则**: 假言推理 (Modus Ponens)
   - 从 $\phi$ 和 $\phi \rightarrow \psi$ 推出 $\psi$

3. **完备性证明**:
   - 使用真值表方法证明每个重言式
   - 通过归纳法证明所有重言式都可推导
   - 利用CNF转换简化证明过程

### 命题逻辑的可靠性定理

**定理**: 命题逻辑是可靠的，即所有可推导的公式都是重言式。

**证明**:

1. **公理可靠性**: 验证所有公理都是重言式
2. **推理规则可靠性**: 验证假言推理保持重言性
3. **归纳证明**: 通过归纳法证明所有可推导公式都是重言式

## 应用场景

### 1. 程序验证

```python
class ProgramVerifier:
    """程序验证器"""
    
    def __init__(self):
        self.preconditions = {}
        self.postconditions = {}
    
    def add_contract(self, function_name: str, pre: Formula, post: Formula):
        """添加函数契约"""
        self.preconditions[function_name] = pre
        self.postconditions[function_name] = post
    
    def verify_function(self, function_name: str, inputs: Dict[str, bool]) -> bool:
        """验证函数是否满足契约"""
        if function_name not in self.preconditions:
            return True
        
        pre = self.preconditions[function_name]
        post = self.postconditions[function_name]
        
        # 检查前置条件
        if not pre.evaluate(inputs):
            return True  # 前置条件不满足，契约成立
        
        # 检查后置条件
        return post.evaluate(inputs)

# 使用示例
def verify_sort_function():
    """验证排序函数的正确性"""
    verifier = ProgramVerifier()
    
    # 定义排序函数的契约
    # 前置条件: 数组不为空
    # 后置条件: 数组是有序的
    array_not_empty = PropositionalVariable("array_not_empty")
    array_sorted = PropositionalVariable("array_sorted")
    
    verifier.add_contract(
        "sort",
        array_not_empty,  # 前置条件
        array_sorted      # 后置条件
    )
    
    # 验证各种输入情况
    test_cases = [
        {"array_not_empty": True, "array_sorted": True},
        {"array_not_empty": True, "array_sorted": False},
        {"array_not_empty": False, "array_sorted": True},
        {"array_not_empty": False, "array_sorted": False}
    ]
    
    for i, inputs in enumerate(test_cases):
        result = verifier.verify_function("sort", inputs)
        print(f"测试用例 {i+1}: {inputs} -> {result}")
```

### 2. 逻辑推理引擎

```python
class LogicEngine:
    """逻辑推理引擎"""
    
    def __init__(self):
        self.knowledge_base = []
    
    def add_knowledge(self, formula: Formula):
        """添加知识到知识库"""
        self.knowledge_base.append(formula)
    
    def query(self, formula: Formula) -> bool:
        """查询公式是否可以从知识库推导"""
        # 创建蕴含公式: KB → φ
        if not self.knowledge_base:
            return PropositionalLogic.is_tautology(formula)
        
        # 构建知识库的合取
        kb_formula = self.knowledge_base[0]
        for formula_in_kb in self.knowledge_base[1:]:
            kb_formula = Conjunction(kb_formula, formula_in_kb)
        
        # 检查 KB → φ 是否为重言式
        implication = Implication(kb_formula, formula)
        return PropositionalLogic.is_tautology(implication)
    
    def find_models(self) -> List[Dict[str, bool]]:
        """找到知识库的所有模型"""
        if not self.knowledge_base:
            return []
        
        # 构建知识库的合取
        kb_formula = self.knowledge_base[0]
        for formula_in_kb in self.knowledge_base[1:]:
            kb_formula = Conjunction(kb_formula, formula_in_kb)
        
        # 生成所有可能的真值赋值
        table = TruthTable(kb_formula)
        results = table.evaluate_all()
        
        # 返回满足知识库的赋值
        return [assignment for assignment, result in results if result]

# 使用示例
def demonstrate_logic_engine():
    """演示逻辑推理引擎"""
    engine = LogicEngine()
    
    # 添加知识
    p = PropositionalVariable("p")
    q = PropositionalVariable("q")
    r = PropositionalVariable("r")
    
    # 知识: p → q, q → r
    engine.add_knowledge(Implication(p, q))
    engine.add_knowledge(Implication(q, r))
    
    # 查询: p → r
    query = Implication(p, r)
    result = engine.query(query)
    print(f"查询 p → r: {result}")
    
    # 找到所有模型
    models = engine.find_models()
    print(f"知识库的模型数量: {len(models)}")
    for i, model in enumerate(models[:3]):  # 只显示前3个
        print(f"模型 {i+1}: {model}")
```

## 总结

命题逻辑为软件工程提供了重要的理论基础：

1. **形式化验证**: 通过命题逻辑可以形式化地验证程序正确性。

2. **逻辑推理**: 提供了强大的逻辑推理能力，用于知识表示和推理。

3. **程序分析**: 可以分析程序的性质，如可满足性、重言性等。

4. **自动化证明**: 为自动化定理证明和程序验证提供基础。

命题逻辑的研究将继续推动软件工程的发展，特别是在程序验证、形式化方法和人工智能领域发挥重要作用。
