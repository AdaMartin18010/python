# 01-02-01 命题逻辑

## 📋 概述

命题逻辑是形式逻辑的基础，研究命题之间的逻辑关系。本文档从形式化角度定义命题逻辑，建立完整的理论体系，并提供高效的Python实现。

## 🎯 核心概念

### 1. 命题逻辑的形式化定义

#### 1.1 基本定义

**定义 1.1** (命题)
命题是一个有真值的陈述句，其真值集合为：
$$\mathbb{B} = \{True, False\}$$

**定义 1.2** (命题变量)
命题变量是表示命题的符号：
$$P, Q, R, \ldots \in \mathcal{P}$$

**定义 1.3** (命题公式)
命题公式递归定义为：

1. 命题变量是命题公式
2. 如果 $\phi$ 是命题公式，则 $\neg \phi$ 是命题公式
3. 如果 $\phi$ 和 $\psi$ 是命题公式，则 $(\phi \land \psi)$、$(\phi \lor \psi)$、$(\phi \rightarrow \psi)$、$(\phi \leftrightarrow \psi)$ 是命题公式

#### 1.2 Python实现

```python
from abc import ABC, abstractmethod
from typing import Dict, Set, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import itertools

class TruthValue(Enum):
    """真值枚举"""
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """命题类"""
    name: str
    value: Optional[TruthValue] = None
    
    def __str__(self) -> str:
        return self.name
    
    def __repr__(self) -> str:
        return f"Proposition('{self.name}')"

class PropositionalFormula(ABC):
    """命题公式抽象基类"""
    
    @abstractmethod
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        """在给定解释下求值"""
        pass
    
    @abstractmethod
    def get_variables(self) -> Set[str]:
        """获取公式中的变量"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """字符串表示"""
        pass
    
    def is_tautology(self) -> bool:
        """检查是否为重言式"""
        variables = self.get_variables()
        if not variables:
            return self.evaluate({}) == TruthValue.TRUE
        
        # 生成所有可能的解释
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            if self.evaluate(interpretation) != TruthValue.TRUE:
                return False
        return True
    
    def is_contradiction(self) -> bool:
        """检查是否为矛盾式"""
        variables = self.get_variables()
        if not variables:
            return self.evaluate({}) == TruthValue.FALSE
        
        # 生成所有可能的解释
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            if self.evaluate(interpretation) != TruthValue.FALSE:
                return False
        return True
    
    def is_satisfiable(self) -> bool:
        """检查是否为可满足式"""
        return not self.is_contradiction()
    
    def is_equivalent(self, other: 'PropositionalFormula') -> bool:
        """检查两个公式是否等价"""
        variables = self.get_variables().union(other.get_variables())
        if not variables:
            return self.evaluate({}) == other.evaluate({})
        
        # 生成所有可能的解释
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            if self.evaluate(interpretation) != other.evaluate(interpretation):
                return False
        return True

class Variable(PropositionalFormula):
    """命题变量"""
    
    def __init__(self, name: str):
        self.name = name
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        if self.name not in interpretation:
            raise ValueError(f"Variable {self.name} not in interpretation")
        return interpretation[self.name]
    
    def get_variables(self) -> Set[str]:
        return {self.name}
    
    def __str__(self) -> str:
        return self.name

class Negation(PropositionalFormula):
    """否定"""
    
    def __init__(self, formula: PropositionalFormula):
        self.formula = formula
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        result = self.formula.evaluate(interpretation)
        return TruthValue.FALSE if result == TruthValue.TRUE else TruthValue.TRUE
    
    def get_variables(self) -> Set[str]:
        return self.formula.get_variables()
    
    def __str__(self) -> str:
        if isinstance(self.formula, (Variable, Negation)):
            return f"¬{self.formula}"
        else:
            return f"¬({self.formula})"

class Conjunction(PropositionalFormula):
    """合取"""
    
    def __init__(self, left: PropositionalFormula, right: PropositionalFormula):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        left_result = self.left.evaluate(interpretation)
        right_result = self.right.evaluate(interpretation)
        return TruthValue.TRUE if (left_result == TruthValue.TRUE and right_result == TruthValue.TRUE) else TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables().union(self.right.get_variables())
    
    def __str__(self) -> str:
        return f"({self.left} ∧ {self.right})"

class Disjunction(PropositionalFormula):
    """析取"""
    
    def __init__(self, left: PropositionalFormula, right: PropositionalFormula):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        left_result = self.left.evaluate(interpretation)
        right_result = self.right.evaluate(interpretation)
        return TruthValue.TRUE if (left_result == TruthValue.TRUE or right_result == TruthValue.TRUE) else TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables().union(self.right.get_variables())
    
    def __str__(self) -> str:
        return f"({self.left} ∨ {self.right})"

class Implication(PropositionalFormula):
    """蕴含"""
    
    def __init__(self, antecedent: PropositionalFormula, consequent: PropositionalFormula):
        self.antecedent = antecedent
        self.consequent = consequent
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        antecedent_result = self.antecedent.evaluate(interpretation)
        consequent_result = self.consequent.evaluate(interpretation)
        
        # p → q 等价于 ¬p ∨ q
        if antecedent_result == TruthValue.FALSE:
            return TruthValue.TRUE
        elif consequent_result == TruthValue.TRUE:
            return TruthValue.TRUE
        else:
            return TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.antecedent.get_variables().union(self.consequent.get_variables())
    
    def __str__(self) -> str:
        return f"({self.antecedent} → {self.consequent})"

class Equivalence(PropositionalFormula):
    """等价"""
    
    def __init__(self, left: PropositionalFormula, right: PropositionalFormula):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        left_result = self.left.evaluate(interpretation)
        right_result = self.right.evaluate(interpretation)
        return TruthValue.TRUE if left_result == right_result else TruthValue.FALSE
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables().union(self.right.get_variables())
    
    def __str__(self) -> str:
        return f"({self.left} ↔ {self.right})"

class TruthTable:
    """真值表"""
    
    def __init__(self, formula: PropositionalFormula):
        self.formula = formula
        self.variables = sorted(list(formula.get_variables()))
    
    def generate(self) -> List[Dict[str, Any]]:
        """生成真值表"""
        table = []
        
        # 生成所有可能的解释
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(self.variables)):
            interpretation = dict(zip(self.variables, values))
            result = self.formula.evaluate(interpretation)
            
            row = interpretation.copy()
            row['result'] = result
            table.append(row)
        
        return table
    
    def print_table(self) -> None:
        """打印真值表"""
        table = self.generate()
        
        # 打印表头
        header = " | ".join(self.variables + ["Result"])
        print(header)
        print("-" * len(header))
        
        # 打印数据行
        for row in table:
            values = [str(row[var].value) for var in self.variables]
            values.append(str(row['result'].value))
            print(" | ".join(values))

class PropositionalLogic:
    """命题逻辑系统"""
    
    def __init__(self):
        self.variables: Dict[str, Variable] = {}
    
    def variable(self, name: str) -> Variable:
        """创建或获取变量"""
        if name not in self.variables:
            self.variables[name] = Variable(name)
        return self.variables[name]
    
    def neg(self, formula: PropositionalFormula) -> Negation:
        """否定"""
        return Negation(formula)
    
    def and_(self, left: PropositionalFormula, right: PropositionalFormula) -> Conjunction:
        """合取"""
        return Conjunction(left, right)
    
    def or_(self, left: PropositionalFormula, right: PropositionalFormula) -> Disjunction:
        """析取"""
        return Disjunction(left, right)
    
    def implies(self, antecedent: PropositionalFormula, consequent: PropositionalFormula) -> Implication:
        """蕴含"""
        return Implication(antecedent, consequent)
    
    def equiv(self, left: PropositionalFormula, right: PropositionalFormula) -> Equivalence:
        """等价"""
        return Equivalence(left, right)
    
    def tautology(self, formula: PropositionalFormula) -> bool:
        """检查重言式"""
        return formula.is_tautology()
    
    def contradiction(self, formula: PropositionalFormula) -> bool:
        """检查矛盾式"""
        return formula.is_contradiction()
    
    def satisfiable(self, formula: PropositionalFormula) -> bool:
        """检查可满足性"""
        return formula.is_satisfiable()
    
    def equivalent(self, formula1: PropositionalFormula, formula2: PropositionalFormula) -> bool:
        """检查等价性"""
        return formula1.is_equivalent(formula2)

# 逻辑推理系统
class InferenceRule:
    """推理规则基类"""
    
    @abstractmethod
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        """应用推理规则"""
        pass

class ModusPonens(InferenceRule):
    """假言推理"""
    
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        if len(premises) != 2:
            return None
        
        # 检查是否为 p → q 和 p 的形式
        if isinstance(premises[0], Implication):
            implication = premises[0]
            antecedent = implication.antecedent
            consequent = implication.consequent
            
            if antecedent.is_equivalent(premises[1]):
                return consequent
        
        return None

class ModusTollens(InferenceRule):
    """拒取式"""
    
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        if len(premises) != 2:
            return None
        
        # 检查是否为 p → q 和 ¬q 的形式
        if isinstance(premises[0], Implication):
            implication = premises[0]
            antecedent = implication.antecedent
            consequent = implication.consequent
            
            if Negation(consequent).is_equivalent(premises[1]):
                return Negation(antecedent)
        
        return None

class HypotheticalSyllogism(InferenceRule):
    """假言三段论"""
    
    def apply(self, premises: List[PropositionalFormula]) -> Optional[PropositionalFormula]:
        if len(premises) != 2:
            return None
        
        # 检查是否为 p → q 和 q → r 的形式
        if (isinstance(premises[0], Implication) and 
            isinstance(premises[1], Implication)):
            
            imp1 = premises[0]
            imp2 = premises[1]
            
            if imp1.consequent.is_equivalent(imp2.antecedent):
                return Implication(imp1.antecedent, imp2.consequent)
        
        return None

class PropositionalProof:
    """命题逻辑证明系统"""
    
    def __init__(self):
        self.rules = [
            ModusPonens(),
            ModusTollens(),
            HypotheticalSyllogism()
        ]
    
    def prove(self, premises: List[PropositionalFormula], conclusion: PropositionalFormula) -> bool:
        """证明结论是否可以从前提推出"""
        # 简化实现：检查结论是否为前提的逻辑后承
        # 即检查 (premises[0] ∧ premises[1] ∧ ... ∧ premises[n]) → conclusion 是否为重言式
        
        if not premises:
            return conclusion.is_tautology()
        
        # 构建前提的合取
        conjunction = premises[0]
        for premise in premises[1:]:
            conjunction = Conjunction(conjunction, premise)
        
        # 构建蕴含式
        implication = Implication(conjunction, conclusion)
        
        return implication.is_tautology()

# 演示和测试
def demonstrate_propositional_logic():
    """演示命题逻辑的使用"""
    
    print("=== 命题逻辑演示 ===\n")
    
    # 创建逻辑系统
    logic = PropositionalLogic()
    
    # 创建变量
    p = logic.variable("P")
    q = logic.variable("Q")
    r = logic.variable("R")
    
    # 1. 基本逻辑运算
    print("1. 基本逻辑运算")
    
    # 合取
    conjunction = logic.and_(p, q)
    print(f"合取: {conjunction}")
    
    # 析取
    disjunction = logic.or_(p, q)
    print(f"析取: {disjunction}")
    
    # 否定
    negation = logic.neg(p)
    print(f"否定: {negation}")
    
    # 蕴含
    implication = logic.implies(p, q)
    print(f"蕴含: {implication}")
    
    # 等价
    equivalence = logic.equiv(p, q)
    print(f"等价: {equivalence}\n")
    
    # 2. 真值表
    print("2. 真值表")
    print("P ∧ Q 的真值表:")
    tt = TruthTable(conjunction)
    tt.print_table()
    print()
    
    # 3. 逻辑性质
    print("3. 逻辑性质")
    
    # 重言式
    tautology = logic.or_(p, logic.neg(p))  # P ∨ ¬P
    print(f"P ∨ ¬P 是重言式: {logic.tautology(tautology)}")
    
    # 矛盾式
    contradiction = logic.and_(p, logic.neg(p))  # P ∧ ¬P
    print(f"P ∧ ¬P 是矛盾式: {logic.contradiction(contradiction)}")
    
    # 可满足式
    satisfiable = logic.and_(p, q)  # P ∧ Q
    print(f"P ∧ Q 是可满足式: {logic.satisfiable(satisfiable)}\n")
    
    # 4. 逻辑等价
    print("4. 逻辑等价")
    
    # 德摩根律
    demorgan1 = logic.neg(logic.and_(p, q))  # ¬(P ∧ Q)
    demorgan2 = logic.or_(logic.neg(p), logic.neg(q))  # ¬P ∨ ¬Q
    print(f"¬(P ∧ Q) ≡ ¬P ∨ ¬Q: {logic.equivalent(demorgan1, demorgan2)}")
    
    # 分配律
    distrib1 = logic.and_(p, logic.or_(q, r))  # P ∧ (Q ∨ R)
    distrib2 = logic.or_(logic.and_(p, q), logic.and_(p, r))  # (P ∧ Q) ∨ (P ∧ R)
    print(f"P ∧ (Q ∨ R) ≡ (P ∧ Q) ∨ (P ∧ R): {logic.equivalent(distrib1, distrib2)}\n")
    
    # 5. 逻辑推理
    print("5. 逻辑推理")
    
    proof_system = PropositionalProof()
    
    # 假言推理: P → Q, P ⊢ Q
    premises1 = [logic.implies(p, q), p]
    conclusion1 = q
    result1 = proof_system.prove(premises1, conclusion1)
    print(f"P → Q, P ⊢ Q: {result1}")
    
    # 拒取式: P → Q, ¬Q ⊢ ¬P
    premises2 = [logic.implies(p, q), logic.neg(q)]
    conclusion2 = logic.neg(p)
    result2 = proof_system.prove(premises2, conclusion2)
    print(f"P → Q, ¬Q ⊢ ¬P: {result2}")
    
    # 假言三段论: P → Q, Q → R ⊢ P → R
    premises3 = [logic.implies(p, q), logic.implies(q, r)]
    conclusion3 = logic.implies(p, r)
    result3 = proof_system.prove(premises3, conclusion3)
    print(f"P → Q, Q → R ⊢ P → R: {result3}\n")

if __name__ == "__main__":
    demonstrate_propositional_logic()
```

## 📊 逻辑运算

### 2.1 基本逻辑运算

#### 2.1.1 否定（NOT）

**定义 2.1** (否定)
否定运算定义为：
$$\neg: \mathbb{B} \rightarrow \mathbb{B}$$
$$\neg p = \begin{cases}
False & \text{if } p = True \\
True & \text{if } p = False
\end{cases}$$

**真值表**:
| P | ¬P |
|---|----|
| T | F  |
| F | T  |

#### 2.1.2 合取（AND）

**定义 2.2** (合取)
合取运算定义为：
$$\land: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \land q = \begin{cases}
True & \text{if } p = True \text{ and } q = True \\
False & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P ∧ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   F   |
| F | F |   F   |

#### 2.1.3 析取（OR）

**定义 2.3** (析取)
析取运算定义为：
$$\lor: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \lor q = \begin{cases}
False & \text{if } p = False \text{ and } q = False \\
True & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P ∨ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   T   |
| F | T |   T   |
| F | F |   F   |

#### 2.1.4 蕴含（IMPLIES）

**定义 2.4** (蕴含)
蕴含运算定义为：
$$\rightarrow: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \rightarrow q = \begin{cases}
False & \text{if } p = True \text{ and } q = False \\
True & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P → Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   T   |
| F | F |   T   |

#### 2.1.5 等价（IFF）

**定义 2.5** (等价)
等价运算定义为：
$$\leftrightarrow: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$$
$$p \leftrightarrow q = \begin{cases}
True & \text{if } p = q \\
False & \text{otherwise}
\end{cases}$$

**真值表**:
| P | Q | P ↔ Q |
|---|---|-------|
| T | T |   T   |
| T | F |   F   |
| F | T |   F   |
| F | F |   T   |

### 2.2 逻辑等价律

#### 2.2.1 基本等价律

**定理 2.1** (双重否定律)
$$\neg \neg p \equiv p$$

**定理 2.2** (德摩根律)
$$\neg(p \land q) \equiv \neg p \lor \neg q$$
$$\neg(p \lor q) \equiv \neg p \land \neg q$$

**定理 2.3** (分配律)
$$p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$$
$$p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$$

**定理 2.4** (结合律)
$$(p \land q) \land r \equiv p \land (q \land r)$$
$$(p \lor q) \lor r \equiv p \lor (q \lor r)$$

**定理 2.5** (交换律)
$$p \land q \equiv q \land p$$
$$p \lor q \equiv q \lor p$$

#### 2.2.2 蕴含等价律

**定理 2.6** (蕴含等价)
$$p \rightarrow q \equiv \neg p \lor q$$

**定理 2.7** (等价展开)
$$p \leftrightarrow q \equiv (p \rightarrow q) \land (q \rightarrow p)$$

## 🔍 逻辑推理

### 3.1 推理规则

#### 3.1.1 假言推理（Modus Ponens）

**规则 3.1** (假言推理)
$$\frac{p \rightarrow q \quad p}{q}$$

**证明**:
1. 假设 $p \rightarrow q$ 为真
2. 假设 $p$ 为真
3. 根据蕴含定义，$q$ 必须为真
4. 因此结论 $q$ 成立

#### 3.1.2 拒取式（Modus Tollens）

**规则 3.2** (拒取式)
$$\frac{p \rightarrow q \quad \neg q}{\neg p}$$

**证明**:
1. 假设 $p \rightarrow q$ 为真
2. 假设 $\neg q$ 为真（即 $q$ 为假）
3. 如果 $p$ 为真，则根据蕴含定义 $q$ 必须为真，矛盾
4. 因此 $p$ 必须为假，即 $\neg p$ 为真

#### 3.1.3 假言三段论

**规则 3.3** (假言三段论)
$$\frac{p \rightarrow q \quad q \rightarrow r}{p \rightarrow r}$$

**证明**:
1. 假设 $p \rightarrow q$ 为真
2. 假设 $q \rightarrow r$ 为真
3. 如果 $p$ 为真，则 $q$ 为真（由1）
4. 如果 $q$ 为真，则 $r$ 为真（由2）
5. 因此 $p \rightarrow r$ 为真

### 3.2 逻辑后承

**定义 3.1** (逻辑后承)
公式 $\psi$ 是公式集合 $\Gamma$ 的逻辑后承，记作 $\Gamma \models \psi$，当且仅当：
$$\forall I, (\forall \phi \in \Gamma, I \models \phi) \Rightarrow I \models \psi$$

其中 $I$ 是解释，$I \models \phi$ 表示在解释 $I$ 下公式 $\phi$ 为真。

**定理 3.1** (逻辑后承的性质)
1. **自反性**: $\phi \models \phi$
2. **传递性**: 如果 $\Gamma \models \phi$ 且 $\phi \models \psi$，则 $\Gamma \models \psi$
3. **单调性**: 如果 $\Gamma \models \phi$ 且 $\Gamma \subseteq \Delta$，则 $\Delta \models \phi$

## 🎯 逻辑系统

### 4.1 公理系统

#### 4.1.1 命题逻辑公理

**公理 4.1** (命题逻辑公理)
1. $p \rightarrow (q \rightarrow p)$
2. $(p \rightarrow (q \rightarrow r)) \rightarrow ((p \rightarrow q) \rightarrow (p \rightarrow r))$
3. $(\neg p \rightarrow \neg q) \rightarrow (q \rightarrow p)$

**推理规则 4.1** (分离规则)
$$\frac{\phi \quad \phi \rightarrow \psi}{\psi}$$

#### 4.1.2 自然演绎系统

**规则 4.2** (自然演绎规则)

**引入规则**:
- $\land I$: $\frac{\phi \quad \psi}{\phi \land \psi}$
- $\lor I$: $\frac{\phi}{\phi \lor \psi}$ 或 $\frac{\psi}{\phi \lor \psi}$
- $\rightarrow I$: $\frac{[\phi] \quad \psi}{\phi \rightarrow \psi}$

**消除规则**:
- $\land E$: $\frac{\phi \land \psi}{\phi}$ 或 $\frac{\phi \land \psi}{\psi}$
- $\lor E$: $\frac{\phi \lor \psi \quad [\phi] \quad \chi \quad [\psi] \quad \chi}{\chi}$
- $\rightarrow E$: $\frac{\phi \quad \phi \rightarrow \psi}{\psi}$

### 4.2 完备性定理

**定理 4.1** (命题逻辑完备性)
如果 $\Gamma \models \phi$，则 $\Gamma \vdash \phi$。

**证明思路**:
1. 使用真值表方法
2. 构造证明树
3. 使用归结方法

## 📈 应用领域

### 5.1 计算机科学应用

#### 5.1.1 电路设计

- **逻辑门**: AND、OR、NOT、NAND、NOR、XOR
- **组合电路**: 真值表到电路图的转换
- **时序电路**: 状态机设计

#### 5.1.2 程序验证

- **前置条件**: 程序执行前的状态约束
- **后置条件**: 程序执行后的状态约束
- **不变式**: 程序执行过程中保持的性质

#### 5.1.3 人工智能

- **知识表示**: 命题逻辑作为知识表示语言
- **推理系统**: 基于规则的专家系统
- **约束满足**: 约束满足问题的建模

### 5.2 数学应用

#### 5.2.1 集合论

- **集合运算**: 并集、交集、补集
- **集合关系**: 包含、相等、不相交

#### 5.2.2 数论

- **整除性**: 质数、合数、最大公约数
- **同余**: 模运算、中国剩余定理

## 🔗 相关链接

- [01-02-02 谓词逻辑](./01-02-02-谓词逻辑.md)
- [01-02-03 模态逻辑](./01-02-03-模态逻辑.md)
- [02-01-01 算法基础](../../02-理论基础/02-01-算法理论/02-01-01-算法基础.md)
- [03-01-01 创建型模式](../../03-具体科学/03-01-设计模式/03-01-01-创建型模式.md)

---

*本文档建立了命题逻辑的完整理论框架，从形式化定义到实际实现，为后续的逻辑学学习奠定了坚实的基础。*
