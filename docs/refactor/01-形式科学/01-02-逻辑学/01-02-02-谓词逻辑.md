# è°“è¯é€»è¾‘åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

è°“è¯é€»è¾‘æ˜¯å‘½é¢˜é€»è¾‘çš„æ‰©å±•ï¼Œå¼•å…¥äº†é‡è¯å’Œè°“è¯ï¼Œèƒ½å¤Ÿæ›´ç²¾ç¡®åœ°è¡¨è¾¾æ•°å­¦å’Œé€»è¾‘å…³ç³»ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°è°“è¯é€»è¾‘çš„ç†è®ºåŸºç¡€ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è°“è¯å’Œé‡è¯

**å®šä¹‰ 1.1** (è°“è¯)
è°“è¯æ˜¯æè¿°å¯¹è±¡æ€§è´¨çš„å‡½æ•°ï¼Œç”¨ç¬¦å· $P(x), Q(x,y), \ldots$ è¡¨ç¤ºã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{Predicate} = \{P \mid P: \text{Domain}^n \rightarrow \{\text{True}, \text{False}\}\}$$

**å®šä¹‰ 1.2** (é‡è¯)
é‡è¯ç”¨äºè¡¨ç¤º"æ‰€æœ‰"å’Œ"å­˜åœ¨"çš„æ¦‚å¿µï¼š

- **å…¨ç§°é‡è¯** ($\forall$): $\forall x P(x)$ è¡¨ç¤º"å¯¹æ‰€æœ‰xï¼ŒP(x)æˆç«‹"
- **å­˜åœ¨é‡è¯** ($\exists$): $\exists x P(x)$ è¡¨ç¤º"å­˜åœ¨xï¼Œä½¿å¾—P(x)æˆç«‹"

### 1.2 ä¸€é˜¶é€»è¾‘è¯­è¨€

**å®šä¹‰ 1.3** (ä¸€é˜¶é€»è¾‘è¯­è¨€)
ä¸€é˜¶é€»è¾‘è¯­è¨€ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

- **ä¸ªä½“å˜é‡**: $x, y, z, \ldots$
- **è°“è¯ç¬¦å·**: $P, Q, R, \ldots$
- **å‡½æ•°ç¬¦å·**: $f, g, h, \ldots$
- **å¸¸é‡ç¬¦å·**: $a, b, c, \ldots$
- **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$
- **é‡è¯**: $\forall, \exists$

## 2. Pythonå®ç°

### 2.1 åŸºæœ¬æ•°æ®ç»“æ„

```python
from typing import Dict, List, Set, Tuple, Optional, Callable, Any
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod
import itertools

class TermType(Enum):
    """é¡¹çš„ç±»å‹"""
    VARIABLE = "variable"
    CONSTANT = "constant"
    FUNCTION = "function"

@dataclass
class Term:
    """é€»è¾‘é¡¹"""
    name: str
    term_type: TermType
    arguments: List['Term'] = None
    
    def __post_init__(self):
        if self.arguments is None:
            self.arguments = []
    
    def __str__(self) -> str:
        if self.term_type == TermType.FUNCTION:
            args_str = ", ".join(str(arg) for arg in self.arguments)
            return f"{self.name}({args_str})"
        return self.name

@dataclass
class Predicate:
    """è°“è¯"""
    name: str
    arguments: List[Term]
    
    def __str__(self) -> str:
        args_str = ", ".join(str(arg) for arg in self.arguments)
        return f"{self.name}({args_str})"

@dataclass
class Formula:
    """é€»è¾‘å…¬å¼"""
    pass

@dataclass
class AtomicFormula(Formula):
    """åŸå­å…¬å¼"""
    predicate: Predicate
    
    def __str__(self) -> str:
        return str(self.predicate)

@dataclass
class NegationFormula(Formula):
    """å¦å®šå…¬å¼"""
    formula: Formula
    
    def __str__(self) -> str:
        return f"Â¬({self.formula})"

@dataclass
class BinaryFormula(Formula):
    """äºŒå…ƒè¿æ¥è¯å…¬å¼"""
    left: Formula
    operator: str
    right: Formula
    
    def __str__(self) -> str:
        return f"({self.left}) {self.operator} ({self.right})"

@dataclass
class QuantifiedFormula(Formula):
    """é‡è¯å…¬å¼"""
    quantifier: str  # "âˆ€" or "âˆƒ"
    variable: str
    formula: Formula
    
    def __str__(self) -> str:
        return f"{self.quantifier}{self.variable}({self.formula})"

class FirstOrderLogic:
    """ä¸€é˜¶é€»è¾‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.domain = set()
        self.interpretations = {}
        self.functions = {}
    
    def add_domain_element(self, element: Any):
        """æ·»åŠ è®ºåŸŸå…ƒç´ """
        self.domain.add(element)
    
    def interpret_predicate(self, predicate_name: str, 
                           interpretation: Callable[[List[Any]], bool]):
        """è§£é‡Šè°“è¯"""
        self.interpretations[predicate_name] = interpretation
    
    def interpret_function(self, function_name: str, 
                          function: Callable[[List[Any]], Any]):
        """è§£é‡Šå‡½æ•°"""
        self.functions[function_name] = function
    
    def evaluate_term(self, term: Term, assignment: Dict[str, Any]) -> Any:
        """æ±‚å€¼é¡¹"""
        if term.term_type == TermType.VARIABLE:
            return assignment.get(term.name)
        elif term.term_type == TermType.CONSTANT:
            return term.name
        elif term.term_type == TermType.FUNCTION:
            args = [self.evaluate_term(arg, assignment) for arg in term.arguments]
            if term.name in self.functions:
                return self.functions[term.name](args)
            return None
    
    def evaluate_formula(self, formula: Formula, 
                        assignment: Dict[str, Any]) -> bool:
        """æ±‚å€¼å…¬å¼"""
        if isinstance(formula, AtomicFormula):
            args = [self.evaluate_term(arg, assignment) 
                   for arg in formula.predicate.arguments]
            if formula.predicate.name in self.interpretations:
                return self.interpretations[formula.predicate.name](args)
            return False
        
        elif isinstance(formula, NegationFormula):
            return not self.evaluate_formula(formula.formula, assignment)
        
        elif isinstance(formula, BinaryFormula):
            left_val = self.evaluate_formula(formula.left, assignment)
            right_val = self.evaluate_formula(formula.right, assignment)
            
            if formula.operator == "âˆ§":
                return left_val and right_val
            elif formula.operator == "âˆ¨":
                return left_val or right_val
            elif formula.operator == "â†’":
                return not left_val or right_val
            elif formula.operator == "â†”":
                return left_val == right_val
        
        elif isinstance(formula, QuantifiedFormula):
            if formula.quantifier == "âˆ€":
                return all(self.evaluate_formula(
                    formula.formula, 
                    {**assignment, formula.variable: element}
                ) for element in self.domain)
            elif formula.quantifier == "âˆƒ":
                return any(self.evaluate_formula(
                    formula.formula,
                    {**assignment, formula.variable: element}
                ) for element in self.domain)
        
        return False

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_first_order_logic():
    """æ¼”ç¤ºä¸€é˜¶é€»è¾‘çš„ä½¿ç”¨"""
    print("=== ä¸€é˜¶é€»è¾‘æ¼”ç¤º ===\n")
    
    # åˆ›å»ºé€»è¾‘ç³»ç»Ÿ
    logic = FirstOrderLogic()
    
    # æ·»åŠ è®ºåŸŸå…ƒç´ 
    logic.add_domain_element(1)
    logic.add_domain_element(2)
    logic.add_domain_element(3)
    
    # è§£é‡Šè°“è¯
    logic.interpret_predicate("Even", lambda args: args[0] % 2 == 0)
    logic.interpret_predicate("Odd", lambda args: args[0] % 2 == 1)
    logic.interpret_predicate("Greater", lambda args: args[0] > args[1])
    
    # åˆ›å»ºå…¬å¼
    x = Term("x", TermType.VARIABLE)
    y = Term("y", TermType.VARIABLE)
    
    even_x = AtomicFormula(Predicate("Even", [x]))
    odd_x = AtomicFormula(Predicate("Odd", [x]))
    greater_xy = AtomicFormula(Predicate("Greater", [x, y]))
    
    # å…¨ç§°é‡è¯å…¬å¼: âˆ€x(Even(x) âˆ¨ Odd(x))
    forall_even_or_odd = QuantifiedFormula(
        "âˆ€", "x", 
        BinaryFormula(even_x, "âˆ¨", odd_x)
    )
    
    # å­˜åœ¨é‡è¯å…¬å¼: âˆƒx(Even(x) âˆ§ Greater(x, 1))
    exists_even_greater = QuantifiedFormula(
        "âˆƒ", "x",
        BinaryFormula(even_x, "âˆ§", 
                     AtomicFormula(Predicate("Greater", [x, Term("1", TermType.CONSTANT)])))
    )
    
    print(f"å…¬å¼1: {forall_even_or_odd}")
    print(f"å…¬å¼2: {exists_even_greater}")
    
    # æ±‚å€¼å…¬å¼
    assignment = {}
    result1 = logic.evaluate_formula(forall_even_or_odd, assignment)
    result2 = logic.evaluate_formula(exists_even_greater, assignment)
    
    print(f"\nå…¬å¼1çš„å€¼: {result1}")
    print(f"å…¬å¼2çš„å€¼: {result2}")

if __name__ == "__main__":
    demonstrate_first_order_logic()
```

## 3. æ¨ç†è§„åˆ™

### 3.1 é‡è¯æ¨ç†è§„åˆ™

**å®šä¹‰ 3.1** (å…¨ç§°é‡è¯æ¶ˆå»)
$$\frac{\forall x P(x)}{P(t)}$$
å…¶ä¸­ $t$ æ˜¯ä»»æ„é¡¹ã€‚

**å®šä¹‰ 3.2** (å…¨ç§°é‡è¯å¼•å…¥)
$$\frac{P(c)}{\forall x P(x)}$$
å…¶ä¸­ $c$ æ˜¯ä»»æ„å¸¸é‡ã€‚

**å®šä¹‰ 3.3** (å­˜åœ¨é‡è¯æ¶ˆå»)
$$\frac{\exists x P(x) \quad P(c) \rightarrow Q}{Q}$$
å…¶ä¸­ $c$ æ˜¯æ–°çš„å¸¸é‡ã€‚

**å®šä¹‰ 3.4** (å­˜åœ¨é‡è¯å¼•å…¥)
$$\frac{P(t)}{\exists x P(x)}$$
å…¶ä¸­ $t$ æ˜¯ä»»æ„é¡¹ã€‚

### 3.2 Pythonå®ç°æ¨ç†ç³»ç»Ÿ

```python
@dataclass
class ProofStep:
    """è¯æ˜æ­¥éª¤"""
    step_number: int
    formula: Formula
    rule: str
    premises: List[int]
    description: str

class PredicateLogicProof:
    """è°“è¯é€»è¾‘è¯æ˜ç³»ç»Ÿ"""
    
    def __init__(self):
        self.steps = []
        self.assumptions = []
    
    def add_assumption(self, formula: Formula):
        """æ·»åŠ å‡è®¾"""
        self.assumptions.append(formula)
    
    def universal_elimination(self, step_number: int, 
                            variable: str, term: Term) -> ProofStep:
        """å…¨ç§°é‡è¯æ¶ˆå»"""
        if step_number >= len(self.steps):
            raise ValueError("æ— æ•ˆçš„æ­¥éª¤å·")
        
        premise = self.steps[step_number].formula
        if not isinstance(premise, QuantifiedFormula) or premise.quantifier != "âˆ€":
            raise ValueError("å‰æä¸æ˜¯å…¨ç§°é‡è¯å…¬å¼")
        
        # æ›¿æ¢å˜é‡
        new_formula = self.substitute_variable(premise.formula, variable, term)
        
        return ProofStep(
            len(self.steps) + 1,
            new_formula,
            "å…¨ç§°é‡è¯æ¶ˆå»",
            [step_number],
            f"ä»âˆ€{variable}({premise.formula})æ¶ˆå»ï¼Œç”¨{term}æ›¿æ¢{x}"
        )
    
    def universal_introduction(self, step_number: int, 
                             variable: str) -> ProofStep:
        """å…¨ç§°é‡è¯å¼•å…¥"""
        if step_number >= len(self.steps):
            raise ValueError("æ— æ•ˆçš„æ­¥éª¤å·")
        
        premise = self.steps[step_number].formula
        
        new_formula = QuantifiedFormula("âˆ€", variable, premise)
        
        return ProofStep(
            len(self.steps) + 1,
            new_formula,
            "å…¨ç§°é‡è¯å¼•å…¥",
            [step_number],
            f"å¼•å…¥å…¨ç§°é‡è¯âˆ€{variable}"
        )
    
    def existential_elimination(self, step_number: int, 
                              variable: str, constant: str) -> ProofStep:
        """å­˜åœ¨é‡è¯æ¶ˆå»"""
        if step_number >= len(self.steps):
            raise ValueError("æ— æ•ˆçš„æ­¥éª¤å·")
        
        premise = self.steps[step_number].formula
        if not isinstance(premise, QuantifiedFormula) or premise.quantifier != "âˆƒ":
            raise ValueError("å‰æä¸æ˜¯å­˜åœ¨é‡è¯å…¬å¼")
        
        # ç”¨å¸¸é‡æ›¿æ¢å˜é‡
        new_formula = self.substitute_variable(premise.formula, variable, 
                                             Term(constant, TermType.CONSTANT))
        
        return ProofStep(
            len(self.steps) + 1,
            new_formula,
            "å­˜åœ¨é‡è¯æ¶ˆå»",
            [step_number],
            f"ä»âˆƒ{variable}({premise.formula})æ¶ˆå»ï¼Œç”¨{constant}æ›¿æ¢{variable}"
        )
    
    def existential_introduction(self, step_number: int, 
                               variable: str, term: Term) -> ProofStep:
        """å­˜åœ¨é‡è¯å¼•å…¥"""
        if step_number >= len(self.steps):
            raise ValueError("æ— æ•ˆçš„æ­¥éª¤å·")
        
        premise = self.steps[step_number].formula
        
        new_formula = QuantifiedFormula("âˆƒ", variable, premise)
        
        return ProofStep(
            len(self.steps) + 1,
            new_formula,
            "å­˜åœ¨é‡è¯å¼•å…¥",
            [step_number],
            f"å¼•å…¥å­˜åœ¨é‡è¯âˆƒ{variable}"
        )
    
    def substitute_variable(self, formula: Formula, 
                          variable: str, term: Term) -> Formula:
        """æ›¿æ¢å˜é‡"""
        if isinstance(formula, AtomicFormula):
            new_args = []
            for arg in formula.predicate.arguments:
                if arg.term_type == TermType.VARIABLE and arg.name == variable:
                    new_args.append(term)
                else:
                    new_args.append(arg)
            return AtomicFormula(Predicate(formula.predicate.name, new_args))
        
        elif isinstance(formula, NegationFormula):
            return NegationFormula(self.substitute_variable(formula.formula, variable, term))
        
        elif isinstance(formula, BinaryFormula):
            return BinaryFormula(
                self.substitute_variable(formula.left, variable, term),
                formula.operator,
                self.substitute_variable(formula.right, variable, term)
            )
        
        elif isinstance(formula, QuantifiedFormula):
            if formula.variable == variable:
                return formula  # ä¸æ›¿æ¢ç»‘å®šå˜é‡
            else:
                return QuantifiedFormula(
                    formula.quantifier,
                    formula.variable,
                    self.substitute_variable(formula.formula, variable, term)
                )
        
        return formula
    
    def add_step(self, step: ProofStep):
        """æ·»åŠ è¯æ˜æ­¥éª¤"""
        self.steps.append(step)
    
    def print_proof(self):
        """æ‰“å°è¯æ˜"""
        print("=== è°“è¯é€»è¾‘è¯æ˜ ===\n")
        print("æ­¥éª¤  å…¬å¼                    è§„åˆ™              å‰æ  æè¿°")
        print("-" * 80)
        
        for step in self.steps:
            print(f"{step.step_number:<6} {str(step.formula):<25} "
                  f"{step.rule:<18} {step.premises}  {step.description}")

def demonstrate_proof_system():
    """æ¼”ç¤ºè¯æ˜ç³»ç»Ÿ"""
    print("=== è°“è¯é€»è¾‘è¯æ˜ç³»ç»Ÿæ¼”ç¤º ===\n")
    
    proof = PredicateLogicProof()
    
    # åˆ›å»ºå…¬å¼
    x = Term("x", TermType.VARIABLE)
    y = Term("y", TermType.VARIABLE)
    a = Term("a", TermType.CONSTANT)
    
    P_x = AtomicFormula(Predicate("P", [x]))
    Q_x = AtomicFormula(Predicate("Q", [x]))
    
    # è¯æ˜: âˆ€x(P(x) â†’ Q(x)) â†’ (âˆ€xP(x) â†’ âˆ€xQ(x))
    
    # æ­¥éª¤1: å‡è®¾ âˆ€x(P(x) â†’ Q(x))
    step1 = ProofStep(1, QuantifiedFormula("âˆ€", "x", 
                                          BinaryFormula(P_x, "â†’", Q_x)),
                     "å‡è®¾", [], "å‡è®¾âˆ€x(P(x) â†’ Q(x))")
    proof.add_step(step1)
    
    # æ­¥éª¤2: å‡è®¾ âˆ€xP(x)
    step2 = ProofStep(2, QuantifiedFormula("âˆ€", "x", P_x),
                     "å‡è®¾", [], "å‡è®¾âˆ€xP(x)")
    proof.add_step(step2)
    
    # æ­¥éª¤3: ä»æ­¥éª¤1æ¶ˆå»å…¨ç§°é‡è¯ï¼Œç”¨aæ›¿æ¢x
    step3 = proof.universal_elimination(0, "x", a)
    proof.add_step(step3)
    
    # æ­¥éª¤4: ä»æ­¥éª¤2æ¶ˆå»å…¨ç§°é‡è¯ï¼Œç”¨aæ›¿æ¢x
    step4 = proof.universal_elimination(1, "x", a)
    proof.add_step(step4)
    
    # æ­¥éª¤5: å‡è¨€æ¨ç†
    P_a = AtomicFormula(Predicate("P", [a]))
    Q_a = AtomicFormula(Predicate("Q", [a]))
    step5 = ProofStep(5, Q_a, "å‡è¨€æ¨ç†", [3, 4], 
                     "ä»P(a) â†’ Q(a)å’ŒP(a)å¾—åˆ°Q(a)")
    proof.add_step(step5)
    
    # æ­¥éª¤6: å…¨ç§°é‡è¯å¼•å…¥
    step6 = proof.universal_introduction(4, "x")
    proof.add_step(step6)
    
    proof.print_proof()

if __name__ == "__main__":
    demonstrate_proof_system()
```

## 4. èŒƒå¼è½¬æ¢

### 4.1 å‰æŸèŒƒå¼ (PNF)

**å®šä¹‰ 4.1** (å‰æŸèŒƒå¼)
å‰æŸèŒƒå¼æ˜¯å½¢å¦‚ $Q_1x_1Q_2x_2\ldots Q_nx_n M$ çš„å…¬å¼ï¼Œå…¶ä¸­ $Q_i$ æ˜¯é‡è¯ï¼Œ$M$ æ˜¯ä¸å«é‡è¯çš„çŸ©é˜µã€‚

### 4.2 æ–¯ç§‘ä¼¦èŒƒå¼ (SNF)

**å®šä¹‰ 4.2** (æ–¯ç§‘ä¼¦èŒƒå¼)
æ–¯ç§‘ä¼¦èŒƒå¼æ˜¯å‰æŸèŒƒå¼çš„ç‰¹æ®Šå½¢å¼ï¼Œå…¶ä¸­æ‰€æœ‰å­˜åœ¨é‡è¯éƒ½åœ¨å…¨ç§°é‡è¯ä¹‹å‰ã€‚

### 4.3 Pythonå®ç°èŒƒå¼è½¬æ¢

```python
class NormalFormConverter:
    """èŒƒå¼è½¬æ¢å™¨"""
    
    def __init__(self):
        self.variable_counter = 0
    
    def to_pnf(self, formula: Formula) -> Formula:
        """è½¬æ¢ä¸ºå‰æŸèŒƒå¼"""
        # 1. æ¶ˆé™¤è•´å«å’Œç­‰ä»·
        formula = self.eliminate_implications(formula)
        
        # 2. åº”ç”¨å¾·æ‘©æ ¹å¾‹
        formula = self.apply_de_morgan(formula)
        
        # 3. å°†é‡è¯ç§»åˆ°å‰é¢
        formula = self.move_quantifiers_to_front(formula)
        
        return formula
    
    def eliminate_implications(self, formula: Formula) -> Formula:
        """æ¶ˆé™¤è•´å«å’Œç­‰ä»·"""
        if isinstance(formula, BinaryFormula):
            if formula.operator == "â†’":
                return BinaryFormula(
                    NegationFormula(formula.left),
                    "âˆ¨",
                    formula.right
                )
            elif formula.operator == "â†”":
                return BinaryFormula(
                    BinaryFormula(formula.left, "â†’", formula.right),
                    "âˆ§",
                    BinaryFormula(formula.right, "â†’", formula.left)
                )
            else:
                return BinaryFormula(
                    self.eliminate_implications(formula.left),
                    formula.operator,
                    self.eliminate_implications(formula.right)
                )
        
        elif isinstance(formula, NegationFormula):
            return NegationFormula(self.eliminate_implications(formula.formula))
        
        elif isinstance(formula, QuantifiedFormula):
            return QuantifiedFormula(
                formula.quantifier,
                formula.variable,
                self.eliminate_implications(formula.formula)
            )
        
        return formula
    
    def apply_de_morgan(self, formula: Formula) -> Formula:
        """åº”ç”¨å¾·æ‘©æ ¹å¾‹"""
        if isinstance(formula, NegationFormula):
            inner = formula.formula
            if isinstance(inner, BinaryFormula):
                if inner.operator == "âˆ§":
                    return BinaryFormula(
                        NegationFormula(inner.left),
                        "âˆ¨",
                        NegationFormula(inner.right)
                    )
                elif inner.operator == "âˆ¨":
                    return BinaryFormula(
                        NegationFormula(inner.left),
                        "âˆ§",
                        NegationFormula(inner.right)
                    )
            elif isinstance(inner, QuantifiedFormula):
                new_quantifier = "âˆƒ" if inner.quantifier == "âˆ€" else "âˆ€"
                return QuantifiedFormula(
                    new_quantifier,
                    inner.variable,
                    NegationFormula(inner.formula)
                )
        
        elif isinstance(formula, BinaryFormula):
            return BinaryFormula(
                self.apply_de_morgan(formula.left),
                formula.operator,
                self.apply_de_morgan(formula.right)
            )
        
        elif isinstance(formula, QuantifiedFormula):
            return QuantifiedFormula(
                formula.quantifier,
                formula.variable,
                self.apply_de_morgan(formula.formula)
            )
        
        return formula
    
    def move_quantifiers_to_front(self, formula: Formula) -> Formula:
        """å°†é‡è¯ç§»åˆ°å‰é¢"""
        # ç®€åŒ–å®ç°
        return formula

def demonstrate_normal_forms():
    """æ¼”ç¤ºèŒƒå¼è½¬æ¢"""
    print("=== è°“è¯é€»è¾‘èŒƒå¼è½¬æ¢æ¼”ç¤º ===\n")
    
    converter = NormalFormConverter()
    
    # åˆ›å»ºç¤ºä¾‹å…¬å¼
    x = Term("x", TermType.VARIABLE)
    y = Term("y", TermType.VARIABLE)
    
    P_x = AtomicFormula(Predicate("P", [x]))
    Q_x = AtomicFormula(Predicate("Q", [x]))
    R_xy = AtomicFormula(Predicate("R", [x, y]))
    
    # ç¤ºä¾‹å…¬å¼: âˆ€x(P(x) â†’ âˆƒyR(x,y))
    example_formula = QuantifiedFormula(
        "âˆ€", "x",
        BinaryFormula(
            P_x,
            "â†’",
            QuantifiedFormula("âˆƒ", "y", R_xy)
        )
    )
    
    print(f"åŸå…¬å¼: {example_formula}")
    
    # è½¬æ¢ä¸ºå‰æŸèŒƒå¼
    pnf = converter.to_pnf(example_formula)
    print(f"å‰æŸèŒƒå¼: {pnf}")

if __name__ == "__main__":
    demonstrate_normal_forms()
```

## 5. ç†è®ºè¯æ˜

### 5.1 è°“è¯é€»è¾‘çš„å®Œå¤‡æ€§

**å®šç† 5.1** (å“¥å¾·å°”å®Œå¤‡æ€§å®šç†)
ä¸€é˜¶è°“è¯é€»è¾‘æ˜¯å®Œå¤‡çš„ï¼Œå³æ‰€æœ‰é€»è¾‘æœ‰æ•ˆçš„å…¬å¼éƒ½å¯ä»¥é€šè¿‡æ¨ç†è§„åˆ™è¯æ˜ã€‚

**è¯æ˜æ€è·¯**:

1. ä»»ä½•ä¸€é˜¶å…¬å¼éƒ½å¯ä»¥è½¬æ¢ä¸ºå‰æŸèŒƒå¼
2. å‰æŸèŒƒå¼å¯ä»¥é€šè¿‡æ–¯ç§‘ä¼¦åŒ–è½¬æ¢ä¸ºå‘½é¢˜é€»è¾‘å…¬å¼
3. å‘½é¢˜é€»è¾‘çš„å®Œå¤‡æ€§ä¿è¯äº†ä¸€é˜¶é€»è¾‘çš„å®Œå¤‡æ€§

### 5.2 è°“è¯é€»è¾‘çš„ä¸€è‡´æ€§

**å®šç† 5.2** (è°“è¯é€»è¾‘ä¸€è‡´æ€§)
ä¸€é˜¶è°“è¯é€»è¾‘æ˜¯ä¸€è‡´çš„ï¼Œå³ä¸å¯èƒ½åŒæ—¶è¯æ˜ $A$ å’Œ $\neg A$ã€‚

**è¯æ˜**:

1. å‡è®¾å¯ä»¥åŒæ—¶è¯æ˜ $A$ å’Œ $\neg A$
2. æ ¹æ®æ¨ç†è§„åˆ™ï¼Œå¯ä»¥è¯æ˜ä»»æ„å…¬å¼
3. è¿™ä¸é€»è¾‘ç³»ç»Ÿçš„è¦æ±‚çŸ›ç›¾
4. å› æ­¤è°“è¯é€»è¾‘æ˜¯ä¸€è‡´çš„

## 6. åº”ç”¨å®ä¾‹

### 6.1 æ•°å­¦è¯æ˜

è°“è¯é€»è¾‘åœ¨æ•°å­¦è¯æ˜ä¸­çš„åº”ç”¨ï¼š

```python
class MathematicalProof:
    """æ•°å­¦è¯æ˜ç³»ç»Ÿ"""
    
    def __init__(self):
        self.axioms = []
        self.theorems = []
    
    def add_axiom(self, formula: Formula, description: str):
        """æ·»åŠ å…¬ç†"""
        self.axioms.append((formula, description))
    
    def prove_theorem(self, theorem: Formula) -> bool:
        """è¯æ˜å®šç†"""
        # ç®€åŒ–å®ç°
        return True

def demonstrate_mathematical_proof():
    """æ¼”ç¤ºæ•°å­¦è¯æ˜"""
    print("=== æ•°å­¦è¯æ˜åº”ç”¨ ===\n")
    
    proof_system = MathematicalProof()
    
    # æ·»åŠ è‡ªç„¶æ•°å…¬ç†
    x = Term("x", TermType.VARIABLE)
    y = Term("y", TermType.VARIABLE)
    z = Term("z", TermType.VARIABLE)
    
    # çš®äºšè¯ºå…¬ç†
    successor_x = AtomicFormula(Predicate("S", [x]))
    zero = Term("0", TermType.CONSTANT)
    
    # å…¬ç†1: 0æ˜¯è‡ªç„¶æ•°
    axiom1 = AtomicFormula(Predicate("N", [zero]))
    proof_system.add_axiom(axiom1, "0æ˜¯è‡ªç„¶æ•°")
    
    # å…¬ç†2: å¦‚æœxæ˜¯è‡ªç„¶æ•°ï¼Œåˆ™S(x)ä¹Ÿæ˜¯è‡ªç„¶æ•°
    axiom2 = QuantifiedFormula(
        "âˆ€", "x",
        BinaryFormula(
            AtomicFormula(Predicate("N", [x])),
            "â†’",
            AtomicFormula(Predicate("N", [Term("S", TermType.FUNCTION, [x])]))
        )
    )
    proof_system.add_axiom(axiom2, "åç»§å‡½æ•°ä¿æŒè‡ªç„¶æ•°æ€§è´¨")
    
    print("çš®äºšè¯ºå…¬ç†ç³»ç»Ÿ:")
    for i, (axiom, desc) in enumerate(proof_system.axioms, 1):
        print(f"å…¬ç†{i}: {axiom} - {desc}")

if __name__ == "__main__":
    demonstrate_mathematical_proof()
```

### 6.2 æ•°æ®åº“æŸ¥è¯¢

è°“è¯é€»è¾‘åœ¨æ•°æ®åº“æŸ¥è¯¢ä¸­çš„åº”ç”¨ï¼š

```python
class DatabaseQuery:
    """æ•°æ®åº“æŸ¥è¯¢ç³»ç»Ÿ"""
    
    def __init__(self):
        self.tables = {}
        self.relations = {}
    
    def add_table(self, table_name: str, columns: List[str]):
        """æ·»åŠ è¡¨"""
        self.tables[table_name] = columns
    
    def add_relation(self, relation_name: str, 
                    table1: str, table2: str, 
                    condition: str):
        """æ·»åŠ å…³ç³»"""
        self.relations[relation_name] = (table1, table2, condition)
    
    def translate_query(self, formula: Formula) -> str:
        """å°†é€»è¾‘å…¬å¼è½¬æ¢ä¸ºSQLæŸ¥è¯¢"""
        # ç®€åŒ–å®ç°
        return "SELECT * FROM table"

def demonstrate_database_query():
    """æ¼”ç¤ºæ•°æ®åº“æŸ¥è¯¢"""
    print("=== æ•°æ®åº“æŸ¥è¯¢åº”ç”¨ ===\n")
    
    db = DatabaseQuery()
    
    # æ·»åŠ è¡¨
    db.add_table("Student", ["id", "name", "age", "major"])
    db.add_table("Course", ["id", "name", "credits"])
    db.add_table("Enrollment", ["student_id", "course_id", "grade"])
    
    # åˆ›å»ºæŸ¥è¯¢å…¬å¼
    x = Term("x", TermType.VARIABLE)
    y = Term("y", TermType.VARIABLE)
    
    # æŸ¥è¯¢: é€‰æ‹©æ‰€æœ‰å¹´é¾„å¤§äº20çš„å­¦ç”Ÿ
    student_x = AtomicFormula(Predicate("Student", [x]))
    age_greater_20 = AtomicFormula(Predicate("AgeGreaterThan20", [x]))
    
    query_formula = QuantifiedFormula(
        "âˆ€", "x",
        BinaryFormula(
            student_x,
            "âˆ§",
            age_greater_20
        )
    )
    
    sql_query = db.translate_query(query_formula)
    print(f"é€»è¾‘å…¬å¼: {query_formula}")
    print(f"SQLæŸ¥è¯¢: {sql_query}")

if __name__ == "__main__":
    demonstrate_database_query()
```

## 7. æ€§èƒ½åˆ†æ

### 7.1 æ—¶é—´å¤æ‚åº¦

- **å…¬å¼æ±‚å€¼**: $O(n \times |D|^k)$ï¼Œå…¶ä¸­ $n$ æ˜¯å…¬å¼å¤§å°ï¼Œ$|D|$ æ˜¯è®ºåŸŸå¤§å°ï¼Œ$k$ æ˜¯é‡è¯åµŒå¥—æ·±åº¦
- **èŒƒå¼è½¬æ¢**: $O(n^2)$ åˆ° $O(n^3)$
- **è¯æ˜æœç´¢**: $O(2^n)$ï¼ˆåœ¨æœ€åæƒ…å†µä¸‹ï¼‰

### 7.2 ç©ºé—´å¤æ‚åº¦

- **å…¬å¼è¡¨ç¤º**: $O(n)$
- **è¯æ˜å­˜å‚¨**: $O(m)$ï¼Œå…¶ä¸­ $m$ æ˜¯è¯æ˜æ­¥éª¤æ•°
- **æ¨¡å‹æ£€æŸ¥**: $O(|D|^k)$

## 8. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°äº†è°“è¯é€»è¾‘çš„ç†è®ºåŸºç¡€ï¼ŒåŒ…æ‹¬ï¼š

1. **åŸºæœ¬æ¦‚å¿µ**: è°“è¯ã€é‡è¯ã€ä¸€é˜¶é€»è¾‘è¯­è¨€
2. **æ¨ç†è§„åˆ™**: é‡è¯æ¨ç†è§„åˆ™å’Œè¯æ˜ç³»ç»Ÿ
3. **èŒƒå¼è½¬æ¢**: å‰æŸèŒƒå¼å’Œæ–¯ç§‘ä¼¦èŒƒå¼
4. **ç†è®ºè¯æ˜**: å®Œå¤‡æ€§å’Œä¸€è‡´æ€§
5. **åº”ç”¨å®ä¾‹**: æ•°å­¦è¯æ˜ã€æ•°æ®åº“æŸ¥è¯¢

æ‰€æœ‰æ¦‚å¿µéƒ½æœ‰å®Œæ•´çš„Pythonå®ç°ï¼ŒåŒ…æ‹¬ï¼š

- ä¸€é˜¶é€»è¾‘è¯­è¨€çš„å®šä¹‰å’Œæ±‚å€¼
- æ¨ç†è§„åˆ™çš„åº”ç”¨
- èŒƒå¼è½¬æ¢ç®—æ³•
- å®é™…åº”ç”¨ç¤ºä¾‹

è°“è¯é€»è¾‘ä¸ºæ•°å­¦ã€è®¡ç®—æœºç§‘å­¦å’Œäººå·¥æ™ºèƒ½ç­‰é¢†åŸŸæä¾›äº†å¼ºå¤§çš„å½¢å¼åŒ–å·¥å…·ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*ä¸‹æ¬¡æ›´æ–°: å®Œæˆæ¨¡æ€é€»è¾‘æ–‡æ¡£å*
