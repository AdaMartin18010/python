# è°“è¯é€»è¾‘

## ğŸ“š æ¦‚è¿°

è°“è¯é€»è¾‘æ˜¯å½¢å¼é€»è¾‘çš„é‡è¦åˆ†æ”¯ï¼Œæ‰©å±•äº†å‘½é¢˜é€»è¾‘ï¼Œå¼•å…¥äº†é‡è¯å’Œè°“è¯ï¼Œèƒ½å¤Ÿæ›´ç²¾ç¡®åœ°è¡¨è¾¾æ•°å­¦å’Œè‡ªç„¶è¯­è¨€ä¸­çš„é€»è¾‘å…³ç³»ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼ç§‘å­¦çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»è°“è¯é€»è¾‘çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è°“è¯é€»è¾‘çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 è°“è¯é€»è¾‘çš„æ•°å­¦å®šä¹‰

è°“è¯é€»è¾‘çš„è¯­è¨€ $\mathcal{L}$ åŒ…å«ï¼š

1. **ä¸ªä½“å˜é‡**: $x, y, z, \ldots$
2. **ä¸ªä½“å¸¸é‡**: $a, b, c, \ldots$
3. **è°“è¯ç¬¦å·**: $P, Q, R, \ldots$ (æ¯ä¸ªè°“è¯æœ‰å›ºå®šçš„å…ƒæ•°)
4. **å‡½æ•°ç¬¦å·**: $f, g, h, \ldots$ (æ¯ä¸ªå‡½æ•°æœ‰å›ºå®šçš„å…ƒæ•°)
5. **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$
6. **é‡è¯**: $\forall$ (å…¨ç§°é‡è¯), $\exists$ (å­˜åœ¨é‡è¯)
7. **ç­‰å·**: $=$

#### 1.2 è°“è¯é€»è¾‘çš„Pythonå®ç°

```python
from typing import List, Dict, Set, Any, Optional, Callable, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
import re

class TermType(Enum):
    """é¡¹çš„ç±»å‹"""
    VARIABLE = "variable"
    CONSTANT = "constant"
    FUNCTION = "function"

class QuantifierType(Enum):
    """é‡è¯ç±»å‹"""
    UNIVERSAL = "universal"  # âˆ€
    EXISTENTIAL = "existential"  # âˆƒ

@dataclass
class Term:
    """é€»è¾‘é¡¹"""
    name: str
    type: TermType
    arguments: List['Term'] = field(default_factory=list)
    
    def __str__(self) -> str:
        if self.type == TermType.FUNCTION:
            args_str = ", ".join(str(arg) for arg in self.arguments)
            return f"{self.name}({args_str})"
        else:
            return self.name
    
    def get_variables(self) -> Set[str]:
        """è·å–é¡¹ä¸­çš„å˜é‡"""
        variables = set()
        if self.type == TermType.VARIABLE:
            variables.add(self.name)
        elif self.type == TermType.FUNCTION:
            for arg in self.arguments:
                variables.update(arg.get_variables())
        return variables

@dataclass
class Predicate:
    """è°“è¯"""
    name: str
    arguments: List[Term]
    
    def __str__(self) -> str:
        args_str = ", ".join(str(arg) for arg in self.arguments)
        return f"{self.name}({args_str})"
    
    def get_variables(self) -> Set[str]:
        """è·å–è°“è¯ä¸­çš„å˜é‡"""
        variables = set()
        for arg in self.arguments:
            variables.update(arg.get_variables())
        return variables

class Formula(ABC):
    """æŠ½è±¡å…¬å¼ç±»"""
    
    @abstractmethod
    def get_variables(self) -> Set[str]:
        """è·å–å…¬å¼ä¸­çš„è‡ªç”±å˜é‡"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        pass

@dataclass
class AtomicFormula(Formula):
    """åŸå­å…¬å¼"""
    predicate: Predicate
    
    def get_variables(self) -> Set[str]:
        return self.predicate.get_variables()
    
    def __str__(self) -> str:
        return str(self.predicate)

@dataclass
class EqualityFormula(Formula):
    """ç­‰å¼å…¬å¼"""
    left: Term
    right: Term
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables() | self.right.get_variables()
    
    def __str__(self) -> str:
        return f"{self.left} = {self.right}"

@dataclass
class NegationFormula(Formula):
    """å¦å®šå…¬å¼"""
    formula: Formula
    
    def get_variables(self) -> Set[str]:
        return self.formula.get_variables()
    
    def __str__(self) -> str:
        return f"Â¬({self.formula})"

@dataclass
class BinaryFormula(Formula):
    """äºŒå…ƒè¿æ¥è¯å…¬å¼"""
    left: Formula
    right: Formula
    operator: str
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables() | self.right.get_variables()
    
    def __str__(self) -> str:
        return f"({self.left} {self.operator} {self.right})"

@dataclass
class QuantifiedFormula(Formula):
    """é‡è¯å…¬å¼"""
    quantifier: QuantifierType
    variable: str
    formula: Formula
    
    def get_variables(self) -> Set[str]:
        variables = self.formula.get_variables()
        variables.discard(self.variable)  # ç§»é™¤è¢«é‡åŒ–çš„å˜é‡
        return variables
    
    def __str__(self) -> str:
        quantifier_symbol = "âˆ€" if self.quantifier == QuantifierType.UNIVERSAL else "âˆƒ"
        return f"{quantifier_symbol}{self.variable}({self.formula})"

# ä½¿ç”¨ç¤ºä¾‹
# åˆ›å»ºé¡¹
x = Term("x", TermType.VARIABLE)
y = Term("y", TermType.VARIABLE)
a = Term("a", TermType.CONSTANT)
f_x = Term("f", TermType.FUNCTION, [x])

# åˆ›å»ºè°“è¯
P_x = Predicate("P", [x])
Q_xy = Predicate("Q", [x, y])
R_fx = Predicate("R", [f_x])

# åˆ›å»ºå…¬å¼
atomic = AtomicFormula(P_x)
equality = EqualityFormula(x, a)
negation = NegationFormula(atomic)
conjunction = BinaryFormula(atomic, AtomicFormula(Q_xy), "âˆ§")
universal = QuantifiedFormula(QuantifierType.UNIVERSAL, "x", atomic)
existential = QuantifiedFormula(QuantifierType.EXISTENTIAL, "y", AtomicFormula(Q_xy))

print(f"åŸå­å…¬å¼: {atomic}")
print(f"ç­‰å¼å…¬å¼: {equality}")
print(f"å¦å®šå…¬å¼: {negation}")
print(f"åˆå–å…¬å¼: {conjunction}")
print(f"å…¨ç§°å…¬å¼: {universal}")
print(f"å­˜åœ¨å…¬å¼: {existential}")
```

### 2. è¯­ä¹‰è§£é‡Š

#### 2.1 è¯­ä¹‰çš„æ•°å­¦å®šä¹‰

è°“è¯é€»è¾‘çš„è§£é‡Š $\mathcal{I}$ åŒ…å«ï¼š

1. **è®ºåŸŸ**: éç©ºé›†åˆ $D$
2. **ä¸ªä½“å¸¸é‡è§£é‡Š**: å‡½æ•° $I_c: \text{Constants} \rightarrow D$
3. **è°“è¯è§£é‡Š**: å‡½æ•° $I_P: \text{Predicates} \rightarrow \mathcal{P}(D^n)$
4. **å‡½æ•°è§£é‡Š**: å‡½æ•° $I_f: \text{Functions} \rightarrow D^n \rightarrow D$

#### 2.2 è¯­ä¹‰çš„Pythonå®ç°

```python
class Interpretation:
    """è°“è¯é€»è¾‘è§£é‡Š"""
    
    def __init__(self, domain: Set[Any]):
        self.domain = domain
        self.constant_interpretations: Dict[str, Any] = {}
        self.predicate_interpretations: Dict[str, Set[tuple]] = {}
        self.function_interpretations: Dict[str, Callable] = {}
        self.variable_assignments: Dict[str, Any] = {}
    
    def assign_constant(self, constant: str, value: Any):
        """åˆ†é…å¸¸é‡è§£é‡Š"""
        if value not in self.domain:
            raise ValueError(f"å¸¸é‡å€¼ {value} ä¸åœ¨è®ºåŸŸä¸­")
        self.constant_interpretations[constant] = value
    
    def assign_predicate(self, predicate: str, extension: Set[tuple]):
        """åˆ†é…è°“è¯è§£é‡Š"""
        for tuple_val in extension:
            for element in tuple_val:
                if element not in self.domain:
                    raise ValueError(f"è°“è¯æ‰©å±•ä¸­çš„å…ƒç´  {element} ä¸åœ¨è®ºåŸŸä¸­")
        self.predicate_interpretations[predicate] = extension
    
    def assign_function(self, function: str, func: Callable):
        """åˆ†é…å‡½æ•°è§£é‡Š"""
        self.function_interpretations[function] = func
    
    def assign_variable(self, variable: str, value: Any):
        """åˆ†é…å˜é‡å€¼"""
        if value not in self.domain:
            raise ValueError(f"å˜é‡å€¼ {value} ä¸åœ¨è®ºåŸŸä¸­")
        self.variable_assignments[variable] = value
    
    def evaluate_term(self, term: Term) -> Any:
        """æ±‚é¡¹çš„å€¼"""
        if term.type == TermType.VARIABLE:
            if term.name not in self.variable_assignments:
                raise ValueError(f"å˜é‡ {term.name} æœªèµ‹å€¼")
            return self.variable_assignments[term.name]
        
        elif term.type == TermType.CONSTANT:
            if term.name not in self.constant_interpretations:
                raise ValueError(f"å¸¸é‡ {term.name} æœªè§£é‡Š")
            return self.constant_interpretations[term.name]
        
        elif term.type == TermType.FUNCTION:
            if term.name not in self.function_interpretations:
                raise ValueError(f"å‡½æ•° {term.name} æœªè§£é‡Š")
            func = self.function_interpretations[term.name]
            args = [self.evaluate_term(arg) for arg in term.arguments]
            return func(*args)
    
    def evaluate_formula(self, formula: Formula) -> bool:
        """æ±‚å…¬å¼çš„çœŸå€¼"""
        if isinstance(formula, AtomicFormula):
            return self._evaluate_atomic_formula(formula)
        
        elif isinstance(formula, EqualityFormula):
            left_val = self.evaluate_term(formula.left)
            right_val = self.evaluate_term(formula.right)
            return left_val == right_val
        
        elif isinstance(formula, NegationFormula):
            return not self.evaluate_formula(formula.formula)
        
        elif isinstance(formula, BinaryFormula):
            left_val = self.evaluate_formula(formula.left)
            right_val = self.evaluate_formula(formula.right)
            
            if formula.operator == "âˆ§":
                return left_val and right_val
            elif formula.operator == "âˆ¨":
                return left_val or right_val
            elif formula.operator == "â†’":
                return (not left_val) or right_val
            elif formula.operator == "â†”":
                return left_val == right_val
        
        elif isinstance(formula, QuantifiedFormula):
            return self._evaluate_quantified_formula(formula)
        
        else:
            raise ValueError(f"æœªçŸ¥çš„å…¬å¼ç±»å‹: {type(formula)}")
    
    def _evaluate_atomic_formula(self, formula: AtomicFormula) -> bool:
        """æ±‚åŸå­å…¬å¼çš„çœŸå€¼"""
        predicate_name = formula.predicate.name
        if predicate_name not in self.predicate_interpretations:
            raise ValueError(f"è°“è¯ {predicate_name} æœªè§£é‡Š")
        
        args = tuple(self.evaluate_term(arg) for arg in formula.predicate.arguments)
        return args in self.predicate_interpretations[predicate_name]
    
    def _evaluate_quantified_formula(self, formula: QuantifiedFormula) -> bool:
        """æ±‚é‡è¯å…¬å¼çš„çœŸå€¼"""
        variable = formula.variable
        original_value = self.variable_assignments.get(variable)
        
        if formula.quantifier == QuantifierType.UNIVERSAL:
            # å…¨ç§°é‡è¯ï¼šå¯¹æ‰€æœ‰è®ºåŸŸä¸­çš„å€¼éƒ½ä¸ºçœŸ
            for value in self.domain:
                self.variable_assignments[variable] = value
                if not self.evaluate_formula(formula.formula):
                    if original_value is not None:
                        self.variable_assignments[variable] = original_value
                    else:
                        del self.variable_assignments[variable]
                    return False
            
            if original_value is not None:
                self.variable_assignments[variable] = original_value
            else:
                del self.variable_assignments[variable]
            return True
        
        else:  # EXISTENTIAL
            # å­˜åœ¨é‡è¯ï¼šå­˜åœ¨è®ºåŸŸä¸­çš„æŸä¸ªå€¼ä¸ºçœŸ
            for value in self.domain:
                self.variable_assignments[variable] = value
                if self.evaluate_formula(formula.formula):
                    if original_value is not None:
                        self.variable_assignments[variable] = original_value
                    else:
                        del self.variable_assignments[variable]
                    return True
            
            if original_value is not None:
                self.variable_assignments[variable] = original_value
            else:
                del self.variable_assignments[variable]
            return False

# ä½¿ç”¨ç¤ºä¾‹
# åˆ›å»ºè§£é‡Š
domain = {1, 2, 3, 4, 5}
interpretation = Interpretation(domain)

# åˆ†é…å¸¸é‡
interpretation.assign_constant("a", 1)
interpretation.assign_constant("b", 2)

# åˆ†é…è°“è¯
interpretation.assign_predicate("P", {(1,), (3,), (5,)})  # P(x) è¡¨ç¤º x æ˜¯å¥‡æ•°
interpretation.assign_predicate("Q", {(1, 2), (2, 3), (3, 4)})  # Q(x,y) è¡¨ç¤º x < y

# åˆ†é…å‡½æ•°
interpretation.assign_function("f", lambda x: x + 1)

# åˆ†é…å˜é‡
interpretation.assign_variable("x", 3)
interpretation.assign_variable("y", 4)

# æ±‚å…¬å¼çš„çœŸå€¼
P_x = AtomicFormula(Predicate("P", [Term("x", TermType.VARIABLE)]))
Q_xy = AtomicFormula(Predicate("Q", [Term("x", TermType.VARIABLE), Term("y", TermType.VARIABLE)]))

print(f"P(x) çš„çœŸå€¼: {interpretation.evaluate_formula(P_x)}")
print(f"Q(x,y) çš„çœŸå€¼: {interpretation.evaluate_formula(Q_xy)}")

# æµ‹è¯•é‡è¯å…¬å¼
universal_P = QuantifiedFormula(QuantifierType.UNIVERSAL, "x", P_x)
existential_Q = QuantifiedFormula(QuantifierType.EXISTENTIAL, "x", 
                                 AtomicFormula(Predicate("Q", [Term("x", TermType.VARIABLE), Term("a", TermType.CONSTANT)])))

print(f"âˆ€x P(x) çš„çœŸå€¼: {interpretation.evaluate_formula(universal_P)}")
print(f"âˆƒx Q(x,a) çš„çœŸå€¼: {interpretation.evaluate_formula(existential_Q)}")
```

### 3. æ¨ç†è§„åˆ™

#### 3.1 è‡ªç„¶æ¼”ç»ç³»ç»Ÿ

```python
class NaturalDeduction:
    """è‡ªç„¶æ¼”ç»ç³»ç»Ÿ"""
    
    def __init__(self):
        self.rules = {
            "universal_intro": self._universal_introduction,
            "universal_elim": self._universal_elimination,
            "existential_intro": self._existential_introduction,
            "existential_elim": self._existential_elimination,
            "conjunction_intro": self._conjunction_introduction,
            "conjunction_elim": self._conjunction_elimination,
            "disjunction_intro": self._disjunction_introduction,
            "disjunction_elim": self._disjunction_elimination,
            "implication_intro": self._implication_introduction,
            "implication_elim": self._implication_elimination,
            "negation_intro": self._negation_introduction,
            "negation_elim": self._negation_elimination
        }
    
    def _universal_introduction(self, premise: Formula, variable: str) -> QuantifiedFormula:
        """å…¨ç§°å¼•å…¥è§„åˆ™"""
        # å¦‚æœä»ä»»æ„ä¸ªä½“éƒ½èƒ½æ¨å‡ºå…¬å¼ï¼Œåˆ™å¯ä»¥å¼•å…¥å…¨ç§°é‡è¯
        return QuantifiedFormula(QuantifierType.UNIVERSAL, variable, premise)
    
    def _universal_elimination(self, premise: QuantifiedFormula, term: Term) -> Formula:
        """å…¨ç§°æ¶ˆé™¤è§„åˆ™"""
        # ä» âˆ€x Ï†(x) å¯ä»¥æ¨å‡º Ï†(t)
        if premise.quantifier != QuantifierType.UNIVERSAL:
            raise ValueError("å‰æå¿…é¡»æ˜¯å…¨ç§°é‡è¯å…¬å¼")
        
        # æ›¿æ¢å˜é‡
        return self._substitute_variable(premise.formula, premise.variable, term)
    
    def _existential_introduction(self, premise: Formula, term: Term, variable: str) -> QuantifiedFormula:
        """å­˜åœ¨å¼•å…¥è§„åˆ™"""
        # ä» Ï†(t) å¯ä»¥æ¨å‡º âˆƒx Ï†(x)
        return QuantifiedFormula(QuantifierType.EXISTENTIAL, variable, premise)
    
    def _existential_elimination(self, premise: QuantifiedFormula, conclusion: Formula, variable: str) -> Formula:
        """å­˜åœ¨æ¶ˆé™¤è§„åˆ™"""
        # ä» âˆƒx Ï†(x) å’Œ Ï†(y) â†’ Ïˆ å¯ä»¥æ¨å‡º Ïˆ (y æ˜¯æ–°çš„å˜é‡)
        if premise.quantifier != QuantifierType.EXISTENTIAL:
            raise ValueError("å‰æå¿…é¡»æ˜¯å­˜åœ¨é‡è¯å…¬å¼")
        
        # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
        return conclusion
    
    def _conjunction_introduction(self, left: Formula, right: Formula) -> BinaryFormula:
        """åˆå–å¼•å…¥è§„åˆ™"""
        return BinaryFormula(left, right, "âˆ§")
    
    def _conjunction_elimination(self, premise: BinaryFormula, which: str) -> Formula:
        """åˆå–æ¶ˆé™¤è§„åˆ™"""
        if premise.operator != "âˆ§":
            raise ValueError("å‰æå¿…é¡»æ˜¯åˆå–å…¬å¼")
        
        if which == "left":
            return premise.left
        elif which == "right":
            return premise.right
        else:
            raise ValueError("which å¿…é¡»æ˜¯ 'left' æˆ– 'right'")
    
    def _disjunction_introduction(self, premise: Formula, other: Formula, which: str) -> BinaryFormula:
        """æå–å¼•å…¥è§„åˆ™"""
        if which == "left":
            return BinaryFormula(premise, other, "âˆ¨")
        elif which == "right":
            return BinaryFormula(other, premise, "âˆ¨")
        else:
            raise ValueError("which å¿…é¡»æ˜¯ 'left' æˆ– 'right'")
    
    def _disjunction_elimination(self, premise: BinaryFormula, left_case: Formula, 
                                right_case: Formula) -> Formula:
        """æå–æ¶ˆé™¤è§„åˆ™"""
        if premise.operator != "âˆ¨":
            raise ValueError("å‰æå¿…é¡»æ˜¯æå–å…¬å¼")
        
        # ç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
        return left_case  # è¿™é‡Œåº”è¯¥æ ¹æ®å…·ä½“æƒ…å†µé€‰æ‹©
    
    def _implication_introduction(self, premise: Formula, conclusion: Formula) -> BinaryFormula:
        """è•´å«å¼•å…¥è§„åˆ™"""
        return BinaryFormula(premise, conclusion, "â†’")
    
    def _implication_elimination(self, premise: BinaryFormula, antecedent: Formula) -> Formula:
        """è•´å«æ¶ˆé™¤è§„åˆ™ï¼ˆå‡è¨€æ¨ç†ï¼‰"""
        if premise.operator != "â†’":
            raise ValueError("å‰æå¿…é¡»æ˜¯è•´å«å…¬å¼")
        
        if antecedent == premise.left:
            return premise.right
        else:
            raise ValueError("å‰æä¸åŒ¹é…")
    
    def _negation_introduction(self, premise: Formula) -> NegationFormula:
        """å¦å®šå¼•å…¥è§„åˆ™"""
        return NegationFormula(premise)
    
    def _negation_elimination(self, premise: NegationFormula) -> Formula:
        """å¦å®šæ¶ˆé™¤è§„åˆ™"""
        return premise.formula
    
    def _substitute_variable(self, formula: Formula, variable: str, term: Term) -> Formula:
        """å˜é‡æ›¿æ¢"""
        if isinstance(formula, AtomicFormula):
            new_args = []
            for arg in formula.predicate.arguments:
                if arg.type == TermType.VARIABLE and arg.name == variable:
                    new_args.append(term)
                else:
                    new_args.append(arg)
            return AtomicFormula(Predicate(formula.predicate.name, new_args))
        
        elif isinstance(formula, EqualityFormula):
            new_left = term if (formula.left.type == TermType.VARIABLE and 
                               formula.left.name == variable) else formula.left
            new_right = term if (formula.right.type == TermType.VARIABLE and 
                                formula.right.name == variable) else formula.right
            return EqualityFormula(new_left, new_right)
        
        elif isinstance(formula, NegationFormula):
            return NegationFormula(self._substitute_variable(formula.formula, variable, term))
        
        elif isinstance(formula, BinaryFormula):
            return BinaryFormula(
                self._substitute_variable(formula.left, variable, term),
                self._substitute_variable(formula.right, variable, term),
                formula.operator
            )
        
        elif isinstance(formula, QuantifiedFormula):
            if formula.variable == variable:
                return formula  # ä¸æ›¿æ¢è¢«é‡åŒ–çš„å˜é‡
            else:
                return QuantifiedFormula(
                    formula.quantifier,
                    formula.variable,
                    self._substitute_variable(formula.formula, variable, term)
                )
        
        else:
            return formula

# ä½¿ç”¨ç¤ºä¾‹
deduction = NaturalDeduction()

# åˆ›å»ºå…¬å¼
P_x = AtomicFormula(Predicate("P", [Term("x", TermType.VARIABLE)]))
Q_x = AtomicFormula(Predicate("Q", [Term("x", TermType.VARIABLE)]))

# åˆå–å¼•å…¥
conjunction = deduction._conjunction_introduction(P_x, Q_x)
print(f"åˆå–å¼•å…¥: {conjunction}")

# å…¨ç§°å¼•å…¥
universal = deduction._universal_introduction(P_x, "x")
print(f"å…¨ç§°å¼•å…¥: {universal}")

# å­˜åœ¨å¼•å…¥
a = Term("a", TermType.CONSTANT)
P_a = AtomicFormula(Predicate("P", [a]))
existential = deduction._existential_introduction(P_a, a, "x")
print(f"å­˜åœ¨å¼•å…¥: {existential}")
```

### 4. å‰æŸèŒƒå¼

#### 4.1 å‰æŸèŒƒå¼çš„æ•°å­¦å®šä¹‰

å‰æŸèŒƒå¼æ˜¯å½¢å¦‚ $Q_1x_1Q_2x_2\ldots Q_nx_n \phi$ çš„å…¬å¼ï¼Œå…¶ä¸­ï¼š

- $Q_i$ æ˜¯é‡è¯ ($\forall$ æˆ– $\exists$)
- $x_i$ æ˜¯å˜é‡
- $\phi$ æ˜¯ä¸å«é‡è¯çš„å…¬å¼ï¼ˆçŸ©é˜µï¼‰

#### 4.2 å‰æŸèŒƒå¼çš„Pythonå®ç°

```python
class PrenexNormalForm:
    """å‰æŸèŒƒå¼è½¬æ¢"""
    
    def __init__(self):
        self.variable_counter = 0
    
    def convert_to_prenex(self, formula: Formula) -> QuantifiedFormula:
        """è½¬æ¢ä¸ºå‰æŸèŒƒå¼"""
        # 1. æ¶ˆé™¤è•´å«å’Œç­‰ä»·
        formula = self._eliminate_implications(formula)
        
        # 2. å°†å¦å®šå†…ç§»
        formula = self._move_negations_inward(formula)
        
        # 3. æ ‡å‡†åŒ–å˜é‡
        formula = self._standardize_variables(formula)
        
        # 4. å°†é‡è¯å‰ç§»
        return self._move_quantifiers_to_front(formula)
    
    def _eliminate_implications(self, formula: Formula) -> Formula:
        """æ¶ˆé™¤è•´å«å’Œç­‰ä»·"""
        if isinstance(formula, BinaryFormula):
            if formula.operator == "â†’":
                # A â†’ B ç­‰ä»·äº Â¬A âˆ¨ B
                return BinaryFormula(
                    NegationFormula(formula.left),
                    formula.right,
                    "âˆ¨"
                )
            elif formula.operator == "â†”":
                # A â†” B ç­‰ä»·äº (A â†’ B) âˆ§ (B â†’ A)
                left_impl = BinaryFormula(formula.left, formula.right, "â†’")
                right_impl = BinaryFormula(formula.right, formula.left, "â†’")
                return BinaryFormula(left_impl, right_impl, "âˆ§")
            else:
                return BinaryFormula(
                    self._eliminate_implications(formula.left),
                    self._eliminate_implications(formula.right),
                    formula.operator
                )
        
        elif isinstance(formula, NegationFormula):
            return NegationFormula(self._eliminate_implications(formula.formula))
        
        elif isinstance(formula, QuantifiedFormula):
            return QuantifiedFormula(
                formula.quantifier,
                formula.variable,
                self._eliminate_implications(formula.formula)
            )
        
        else:
            return formula
    
    def _move_negations_inward(self, formula: Formula) -> Formula:
        """å°†å¦å®šå†…ç§»"""
        if isinstance(formula, NegationFormula):
            inner = formula.formula
            
            if isinstance(inner, NegationFormula):
                # Â¬Â¬A ç­‰ä»·äº A
                return self._move_negations_inward(inner.formula)
            
            elif isinstance(inner, BinaryFormula):
                if inner.operator == "âˆ§":
                    # Â¬(A âˆ§ B) ç­‰ä»·äº Â¬A âˆ¨ Â¬B
                    return BinaryFormula(
                        self._move_negations_inward(NegationFormula(inner.left)),
                        self._move_negations_inward(NegationFormula(inner.right)),
                        "âˆ¨"
                    )
                elif inner.operator == "âˆ¨":
                    # Â¬(A âˆ¨ B) ç­‰ä»·äº Â¬A âˆ§ Â¬B
                    return BinaryFormula(
                        self._move_negations_inward(NegationFormula(inner.left)),
                        self._move_negations_inward(NegationFormula(inner.right)),
                        "âˆ§"
                    )
            
            elif isinstance(inner, QuantifiedFormula):
                # Â¬âˆ€x Ï†(x) ç­‰ä»·äº âˆƒx Â¬Ï†(x)
                # Â¬âˆƒx Ï†(x) ç­‰ä»·äº âˆ€x Â¬Ï†(x)
                new_quantifier = (QuantifierType.EXISTENTIAL 
                                if inner.quantifier == QuantifierType.UNIVERSAL 
                                else QuantifierType.UNIVERSAL)
                return QuantifiedFormula(
                    new_quantifier,
                    inner.variable,
                    self._move_negations_inward(NegationFormula(inner.formula))
                )
        
        elif isinstance(formula, BinaryFormula):
            return BinaryFormula(
                self._move_negations_inward(formula.left),
                self._move_negations_inward(formula.right),
                formula.operator
            )
        
        elif isinstance(formula, QuantifiedFormula):
            return QuantifiedFormula(
                formula.quantifier,
                formula.variable,
                self._move_negations_inward(formula.formula)
            )
        
        else:
            return formula
    
    def _standardize_variables(self, formula: Formula) -> Formula:
        """æ ‡å‡†åŒ–å˜é‡å"""
        variable_mapping = {}
        
        def rename_variables(f: Formula) -> Formula:
            if isinstance(f, AtomicFormula):
                new_args = []
                for arg in f.predicate.arguments:
                    if arg.type == TermType.VARIABLE:
                        if arg.name not in variable_mapping:
                            variable_mapping[arg.name] = f"v{self.variable_counter}"
                            self.variable_counter += 1
                        new_args.append(Term(variable_mapping[arg.name], TermType.VARIABLE))
                    else:
                        new_args.append(arg)
                return AtomicFormula(Predicate(f.predicate.name, new_args))
            
            elif isinstance(f, BinaryFormula):
                return BinaryFormula(
                    rename_variables(f.left),
                    rename_variables(f.right),
                    f.operator
                )
            
            elif isinstance(f, NegationFormula):
                return NegationFormula(rename_variables(f.formula))
            
            elif isinstance(f, QuantifiedFormula):
                if f.variable not in variable_mapping:
                    variable_mapping[f.variable] = f"v{self.variable_counter}"
                    self.variable_counter += 1
                return QuantifiedFormula(
                    f.quantifier,
                    variable_mapping[f.variable],
                    rename_variables(f.formula)
                )
            
            else:
                return f
        
        return rename_variables(formula)
    
    def _move_quantifiers_to_front(self, formula: Formula) -> QuantifiedFormula:
        """å°†é‡è¯å‰ç§»"""
        if isinstance(formula, QuantifiedFormula):
            # å·²ç»æ˜¯é‡è¯å…¬å¼ï¼Œé€’å½’å¤„ç†å†…éƒ¨
            inner_prenex = self._move_quantifiers_to_front(formula.formula)
            return QuantifiedFormula(
                formula.quantifier,
                formula.variable,
                inner_prenex
            )
        
        elif isinstance(formula, BinaryFormula):
            # å¤„ç†äºŒå…ƒè¿æ¥è¯
            left_prenex = self._move_quantifiers_to_front(formula.left)
            right_prenex = self._move_quantifiers_to_front(formula.right)
            
            # å°†é‡è¯æå–åˆ°æœ€å¤–å±‚
            if isinstance(left_prenex, QuantifiedFormula):
                return QuantifiedFormula(
                    left_prenex.quantifier,
                    left_prenex.variable,
                    BinaryFormula(left_prenex.formula, right_prenex, formula.operator)
                )
            elif isinstance(right_prenex, QuantifiedFormula):
                return QuantifiedFormula(
                    right_prenex.quantifier,
                    right_prenex.variable,
                    BinaryFormula(left_prenex, right_prenex.formula, formula.operator)
                )
            else:
                return BinaryFormula(left_prenex, right_prenex, formula.operator)
        
        else:
            # åŸå­å…¬å¼æˆ–å¦å®šå…¬å¼ï¼Œç›´æ¥è¿”å›
            return formula

# ä½¿ç”¨ç¤ºä¾‹
prenex_converter = PrenexNormalForm()

# åˆ›å»ºå¤æ‚å…¬å¼: âˆ€x P(x) â†’ âˆƒy Q(y)
P_x = AtomicFormula(Predicate("P", [Term("x", TermType.VARIABLE)]))
Q_y = AtomicFormula(Predicate("Q", [Term("y", TermType.VARIABLE)]))

universal_P = QuantifiedFormula(QuantifierType.UNIVERSAL, "x", P_x)
existential_Q = QuantifiedFormula(QuantifierType.EXISTENTIAL, "y", Q_y)
complex_formula = BinaryFormula(universal_P, existential_Q, "â†’")

print(f"åŸå…¬å¼: {complex_formula}")

# è½¬æ¢ä¸ºå‰æŸèŒƒå¼
prenex_formula = prenex_converter.convert_to_prenex(complex_formula)
print(f"å‰æŸèŒƒå¼: {prenex_formula}")
```

### 5. å½’ç»“æ¨ç†

#### 5.1 å½’ç»“æ¨ç†çš„æ•°å­¦å®šä¹‰

å½’ç»“æ¨ç†æ˜¯ä¸€ç§è‡ªåŠ¨å®šç†è¯æ˜æ–¹æ³•ï¼ŒåŸºäºä»¥ä¸‹è§„åˆ™ï¼š

å¦‚æœ $C_1 = A \lor L$ å’Œ $C_2 = B \lor \neg L$ï¼Œåˆ™å½’ç»“å¼ä¸º $C = A \lor B$

#### 5.2 å½’ç»“æ¨ç†çš„Pythonå®ç°

```python
class Resolution:
    """å½’ç»“æ¨ç†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.clauses = []
    
    def add_clause(self, clause: List[Formula]):
        """æ·»åŠ å­å¥"""
        self.clauses.append(clause)
    
    def find_resolvents(self, clause1: List[Formula], clause2: List[Formula]) -> List[List[Formula]]:
        """å¯»æ‰¾å½’ç»“å¼"""
        resolvents = []
        
        for literal1 in clause1:
            for literal2 in clause2:
                # æ£€æŸ¥æ˜¯å¦å¯ä»¥å½’ç»“
                if self._can_resolve(literal1, literal2):
                    resolvent = self._resolve(literal1, literal2, clause1, clause2)
                    if resolvent:
                        resolvents.append(resolvent)
        
        return resolvents
    
    def _can_resolve(self, literal1: Formula, literal2: Formula) -> bool:
        """æ£€æŸ¥ä¸¤ä¸ªæ–‡å­—æ˜¯å¦å¯ä»¥å½’ç»“"""
        # ä¸€ä¸ªå¿…é¡»æ˜¯å¦ä¸€ä¸ªçš„å¦å®š
        if isinstance(literal1, NegationFormula) and literal1.formula == literal2:
            return True
        elif isinstance(literal2, NegationFormula) and literal2.formula == literal1:
            return True
        return False
    
    def _resolve(self, literal1: Formula, literal2: Formula, 
                clause1: List[Formula], clause2: List[Formula]) -> List[Formula]:
        """å½’ç»“ä¸¤ä¸ªå­å¥"""
        resolvent = []
        
        # æ·»åŠ ç¬¬ä¸€ä¸ªå­å¥ä¸­é™¤äº†literal1ä¹‹å¤–çš„æ‰€æœ‰æ–‡å­—
        for lit in clause1:
            if lit != literal1:
                resolvent.append(lit)
        
        # æ·»åŠ ç¬¬äºŒä¸ªå­å¥ä¸­é™¤äº†literal2ä¹‹å¤–çš„æ‰€æœ‰æ–‡å­—
        for lit in clause2:
            if lit != literal2:
                resolvent.append(lit)
        
        # å»é‡
        unique_resolvent = []
        for lit in resolvent:
            if lit not in unique_resolvent:
                unique_resolvent.append(lit)
        
        return unique_resolvent
    
    def prove(self, goal: Formula) -> bool:
        """è¯æ˜ç›®æ ‡å…¬å¼"""
        # å°†ç›®æ ‡å…¬å¼çš„å¦å®šæ·»åŠ åˆ°å­å¥é›†
        negated_goal = NegationFormula(goal)
        self.add_clause([negated_goal])
        
        # å½’ç»“æ¨ç†
        while True:
            new_clauses = []
            
            # å°è¯•å½’ç»“æ‰€æœ‰å­å¥å¯¹
            for i in range(len(self.clauses)):
                for j in range(i + 1, len(self.clauses)):
                    resolvents = self.find_resolvents(self.clauses[i], self.clauses[j])
                    
                    for resolvent in resolvents:
                        if not resolvent:  # ç©ºå­å¥
                            return True  # æ‰¾åˆ°çŸ›ç›¾ï¼Œè¯æ˜æˆåŠŸ
                        
                        if resolvent not in self.clauses and resolvent not in new_clauses:
                            new_clauses.append(resolvent)
            
            # å¦‚æœæ²¡æœ‰æ–°çš„å­å¥ï¼Œè¯æ˜å¤±è´¥
            if not new_clauses:
                return False
            
            # æ·»åŠ æ–°å­å¥
            self.clauses.extend(new_clauses)

# ä½¿ç”¨ç¤ºä¾‹
resolution = Resolution()

# æ·»åŠ å…¬ç†
P = AtomicFormula(Predicate("P", [Term("a", TermType.CONSTANT)]))
Q = AtomicFormula(Predicate("Q", [Term("a", TermType.CONSTANT)]))

# æ·»åŠ å­å¥: P âˆ¨ Q, Â¬P âˆ¨ Q, Â¬Q
resolution.add_clause([P, Q])  # P âˆ¨ Q
resolution.add_clause([NegationFormula(P), Q])  # Â¬P âˆ¨ Q
resolution.add_clause([NegationFormula(Q)])  # Â¬Q

# è¯æ˜ Q
result = resolution.prove(Q)
print(f"å½’ç»“æ¨ç†è¯æ˜ Q: {result}")
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. å‰æŸèŒƒå¼å­˜åœ¨æ€§å®šç†

**å®šç†**: æ¯ä¸ªè°“è¯é€»è¾‘å…¬å¼éƒ½æœ‰ä¸€ä¸ªç­‰ä»·çš„å‰æŸèŒƒå¼ã€‚

**è¯æ˜**: é€šè¿‡ä»¥ä¸‹æ­¥éª¤å¯ä»¥æ„é€ å‰æŸèŒƒå¼ï¼š

1. æ¶ˆé™¤è•´å«å’Œç­‰ä»·è¿æ¥è¯
2. å°†å¦å®šå†…ç§»
3. æ ‡å‡†åŒ–å˜é‡å
4. å°†é‡è¯å‰ç§»

### 2. å½’ç»“æ¨ç†å®Œå¤‡æ€§å®šç†

**å®šç†**: å½’ç»“æ¨ç†æ˜¯å®Œå¤‡çš„ï¼Œå³å¦‚æœå…¬å¼é›†æ˜¯ä¸ä¸€è‡´çš„ï¼Œåˆ™é€šè¿‡å½’ç»“æ¨ç†å¯ä»¥å¾—åˆ°ç©ºå­å¥ã€‚

**è¯æ˜**: åŸºäºHerbrandå®šç†å’Œæå‡å¼•ç†ï¼Œé€šè¿‡æ„é€ æ€§æ–¹æ³•è¯æ˜ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. è‡ªåŠ¨å®šç†è¯æ˜

```python
class AutomatedTheoremProver:
    """è‡ªåŠ¨å®šç†è¯æ˜å™¨"""
    
    def __init__(self):
        self.axioms = []
        self.theorems = []
    
    def add_axiom(self, axiom: Formula):
        """æ·»åŠ å…¬ç†"""
        self.axioms.append(axiom)
    
    def prove_theorem(self, theorem: Formula) -> bool:
        """è¯æ˜å®šç†"""
        # å°†å…¬ç†å’Œç›®æ ‡å®šç†è½¬æ¢ä¸ºå­å¥å½¢å¼
        clauses = []
        
        for axiom in self.axioms:
            clauses.extend(self._formula_to_clauses(axiom))
        
        # æ·»åŠ ç›®æ ‡å®šç†çš„å¦å®š
        negated_theorem = NegationFormula(theorem)
        clauses.extend(self._formula_to_clauses(negated_theorem))
        
        # ä½¿ç”¨å½’ç»“æ¨ç†
        resolution = Resolution()
        for clause in clauses:
            resolution.add_clause(clause)
        
        return resolution.prove(theorem)
    
    def _formula_to_clauses(self, formula: Formula) -> List[List[Formula]]:
        """å°†å…¬å¼è½¬æ¢ä¸ºå­å¥å½¢å¼"""
        # è½¬æ¢ä¸ºå‰æŸèŒƒå¼
        prenex_converter = PrenexNormalForm()
        prenex_formula = prenex_converter.convert_to_prenex(formula)
        
        # æå–çŸ©é˜µéƒ¨åˆ†
        matrix = self._extract_matrix(prenex_formula)
        
        # è½¬æ¢ä¸ºåˆå–èŒƒå¼
        cnf = self._to_conjunctive_normal_form(matrix)
        
        return cnf
    
    def _extract_matrix(self, formula: Formula) -> Formula:
        """æå–é‡è¯å…¬å¼çš„çŸ©é˜µéƒ¨åˆ†"""
        if isinstance(formula, QuantifiedFormula):
            return self._extract_matrix(formula.formula)
        else:
            return formula
    
    def _to_conjunctive_normal_form(self, formula: Formula) -> List[List[Formula]]:
        """è½¬æ¢ä¸ºåˆå–èŒƒå¼"""
        if isinstance(formula, BinaryFormula) and formula.operator == "âˆ§":
            left_clauses = self._to_conjunctive_normal_form(formula.left)
            right_clauses = self._to_conjunctive_normal_form(formula.right)
            return left_clauses + right_clauses
        
        elif isinstance(formula, BinaryFormula) and formula.operator == "âˆ¨":
            # æå–èŒƒå¼
            return [self._get_disjunctive_clause(formula)]
        
        else:
            return [[formula]]
    
    def _get_disjunctive_clause(self, formula: Formula) -> List[Formula]:
        """è·å–æå–å­å¥"""
        if isinstance(formula, BinaryFormula) and formula.operator == "âˆ¨":
            return (self._get_disjunctive_clause(formula.left) + 
                   self._get_disjunctive_clause(formula.right))
        else:
            return [formula]

# ä½¿ç”¨ç¤ºä¾‹
prover = AutomatedTheoremProver()

# æ·»åŠ å…¬ç†: âˆ€x (P(x) â†’ Q(x)), P(a)
x = Term("x", TermType.VARIABLE)
a = Term("a", TermType.CONSTANT)
P_x = AtomicFormula(Predicate("P", [x]))
Q_x = AtomicFormula(Predicate("Q", [x]))
P_a = AtomicFormula(Predicate("P", [a]))
Q_a = AtomicFormula(Predicate("Q", [a]))

# å…¬ç†1: âˆ€x (P(x) â†’ Q(x))
axiom1 = QuantifiedFormula(
    QuantifierType.UNIVERSAL, "x",
    BinaryFormula(P_x, Q_x, "â†’")
)

# å…¬ç†2: P(a)
axiom2 = P_a

prover.add_axiom(axiom1)
prover.add_axiom(axiom2)

# è¯æ˜å®šç†: Q(a)
theorem = Q_a
result = prover.prove_theorem(theorem)
print(f"è‡ªåŠ¨å®šç†è¯æ˜ Q(a): {result}")
```

### 2. çŸ¥è¯†è¡¨ç¤ºç³»ç»Ÿ

```python
class KnowledgeRepresentationSystem:
    """çŸ¥è¯†è¡¨ç¤ºç³»ç»Ÿ"""
    
    def __init__(self):
        self.knowledge_base = []
        self.interpretation = None
    
    def add_knowledge(self, formula: Formula):
        """æ·»åŠ çŸ¥è¯†"""
        self.knowledge_base.append(formula)
    
    def query(self, query: Formula) -> bool:
        """æŸ¥è¯¢çŸ¥è¯†"""
        if not self.interpretation:
            raise ValueError("æœªè®¾ç½®è§£é‡Š")
        
        # æ£€æŸ¥æ‰€æœ‰çŸ¥è¯†éƒ½ä¸ºçœŸ
        for knowledge in self.knowledge_base:
            if not self.interpretation.evaluate_formula(knowledge):
                return False
        
        # æ£€æŸ¥æŸ¥è¯¢æ˜¯å¦ä¸ºçœŸ
        return self.interpretation.evaluate_formula(query)
    
    def set_interpretation(self, interpretation: Interpretation):
        """è®¾ç½®è§£é‡Š"""
        self.interpretation = interpretation
    
    def find_models(self, domain: Set[Any]) -> List[Interpretation]:
        """å¯»æ‰¾æ»¡è¶³çŸ¥è¯†åº“çš„è§£é‡Š"""
        models = []
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§£é‡Šï¼ˆç®€åŒ–å®ç°ï¼‰
        # å®é™…åº”ç”¨ä¸­éœ€è¦æ›´é«˜æ•ˆçš„ç®—æ³•
        for const_val in domain:
            for pred_extension in self._generate_predicate_extensions(domain):
                interpretation = Interpretation(domain)
                interpretation.assign_constant("a", const_val)
                interpretation.assign_predicate("P", pred_extension)
                
                if self._satisfies_knowledge_base(interpretation):
                    models.append(interpretation)
        
        return models
    
    def _generate_predicate_extensions(self, domain: Set[Any]) -> List[Set[tuple]]:
        """ç”Ÿæˆè°“è¯çš„æ‰€æœ‰å¯èƒ½æ‰©å±•"""
        # ç®€åŒ–å®ç°ï¼šåªè€ƒè™‘ä¸€å…ƒè°“è¯
        extensions = []
        domain_list = list(domain)
        
        for i in range(2 ** len(domain_list)):
            extension = set()
            for j, element in enumerate(domain_list):
                if (i >> j) & 1:
                    extension.add((element,))
            extensions.append(extension)
        
        return extensions
    
    def _satisfies_knowledge_base(self, interpretation: Interpretation) -> bool:
        """æ£€æŸ¥è§£é‡Šæ˜¯å¦æ»¡è¶³çŸ¥è¯†åº“"""
        for knowledge in self.knowledge_base:
            if not interpretation.evaluate_formula(knowledge):
                return False
        return True

# ä½¿ç”¨ç¤ºä¾‹
krs = KnowledgeRepresentationSystem()

# æ·»åŠ çŸ¥è¯†
x = Term("x", TermType.VARIABLE)
a = Term("a", TermType.CONSTANT)
P_x = AtomicFormula(Predicate("P", [x]))
Q_x = AtomicFormula(Predicate("Q", [x]))

# çŸ¥è¯†1: âˆ€x (P(x) â†’ Q(x))
knowledge1 = QuantifiedFormula(
    QuantifierType.UNIVERSAL, "x",
    BinaryFormula(P_x, Q_x, "â†’")
)

# çŸ¥è¯†2: âˆƒx P(x)
knowledge2 = QuantifiedFormula(
    QuantifierType.EXISTENTIAL, "x",
    P_x
)

krs.add_knowledge(knowledge1)
krs.add_knowledge(knowledge2)

# è®¾ç½®è§£é‡Š
domain = {1, 2, 3}
interpretation = Interpretation(domain)
interpretation.assign_constant("a", 1)
interpretation.assign_predicate("P", {(1,), (2,)})
interpretation.assign_predicate("Q", {(1,), (2,), (3,)})

krs.set_interpretation(interpretation)

# æŸ¥è¯¢
query = QuantifiedFormula(QuantifierType.EXISTENTIAL, "x", Q_x)
result = krs.query(query)
print(f"çŸ¥è¯†æŸ¥è¯¢ç»“æœ: {result}")

# å¯»æ‰¾æ¨¡å‹
models = krs.find_models(domain)
print(f"æ‰¾åˆ° {len(models)} ä¸ªæ¨¡å‹")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [é€»è¾‘å­¦åŸºç¡€](../README.md)
- [å‘½é¢˜é€»è¾‘](01-02-01-å‘½é¢˜é€»è¾‘.md)
- [æ¨¡æ€é€»è¾‘](01-02-03-æ¨¡æ€é€»è¾‘.md)
- [æ•°å­¦åŸºç¡€](../01-01-æ•°å­¦åŸºç¡€/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Enderton, H. B. (2001). A Mathematical Introduction to Logic. Academic Press.
2. Mendelson, E. (2015). Introduction to Mathematical Logic. CRC Press.
3. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). Computability and Logic. Cambridge University Press.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
