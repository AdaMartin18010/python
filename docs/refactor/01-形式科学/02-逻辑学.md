# 逻辑学 - 软件设计的逻辑基础

## 概述

逻辑学为软件设计提供形式化的推理工具，包括命题逻辑、谓词逻辑、模态逻辑等。这些逻辑系统为软件系统的规范、验证和推理提供了严格的数学基础。

## 1. 命题逻辑

### 1.1 基本概念

**定义 1.1.1 (命题)**
命题是一个可以判断真假的陈述句。

**定义 1.1.2 (命题变量)**
命题变量是表示命题的符号，通常用 $p, q, r$ 等表示。

**定义 1.1.3 (逻辑连接词)**
常用的逻辑连接词包括：

- 否定 ($\neg$): 非
- 合取 ($\land$): 且
- 析取 ($\lor$): 或
- 蕴含 ($\rightarrow$): 如果...那么
- 等价 ($\leftrightarrow$): 当且仅当

**Python实现**：

```python
from typing import Dict, Set, List, Optional, Union
from enum import Enum
import itertools

class LogicalOperator(Enum):
    """逻辑操作符"""
    NOT = "¬"
    AND = "∧"
    OR = "∨"
    IMPLIES = "→"
    EQUIVALENT = "↔"

class PropositionalVariable:
    """命题变量"""
    
    def __init__(self, name: str):
        self.name = name
    
    def __str__(self):
        return self.name
    
    def __repr__(self):
        return f"PropositionalVariable('{self.name}')"
    
    def __hash__(self):
        return hash(self.name)
    
    def __eq__(self, other):
        return isinstance(other, PropositionalVariable) and self.name == other.name

class PropositionalFormula:
    """命题公式"""
    
    def __init__(self, 
                 operator: Optional[LogicalOperator] = None,
                 left: Optional[Union['PropositionalFormula', PropositionalVariable]] = None,
                 right: Optional[Union['PropositionalFormula', PropositionalVariable]] = None,
                 variable: Optional[PropositionalVariable] = None):
        self.operator = operator
        self.left = left
        self.right = right
        self.variable = variable
    
    @classmethod
    def variable(cls, var: PropositionalVariable) -> 'PropositionalFormula':
        """创建变量公式"""
        return cls(variable=var)
    
    @classmethod
    def negation(cls, formula: Union['PropositionalFormula', PropositionalVariable]) -> 'PropositionalFormula':
        """创建否定公式"""
        if isinstance(formula, PropositionalVariable):
            formula = cls.variable(formula)
        return cls(operator=LogicalOperator.NOT, left=formula)
    
    @classmethod
    def conjunction(cls, left: Union['PropositionalFormula', PropositionalVariable], 
                   right: Union['PropositionalFormula', PropositionalVariable]) -> 'PropositionalFormula':
        """创建合取公式"""
        if isinstance(left, PropositionalVariable):
            left = cls.variable(left)
        if isinstance(right, PropositionalVariable):
            right = cls.variable(right)
        return cls(operator=LogicalOperator.AND, left=left, right=right)
    
    @classmethod
    def disjunction(cls, left: Union['PropositionalFormula', PropositionalVariable], 
                   right: Union['PropositionalFormula', PropositionalVariable]) -> 'PropositionalFormula':
        """创建析取公式"""
        if isinstance(left, PropositionalVariable):
            left = cls.variable(left)
        if isinstance(right, PropositionalVariable):
            right = cls.variable(right)
        return cls(operator=LogicalOperator.OR, left=left, right=right)
    
    @classmethod
    def implication(cls, left: Union['PropositionalFormula', PropositionalVariable], 
                   right: Union['PropositionalFormula', PropositionalVariable]) -> 'PropositionalFormula':
        """创建蕴含公式"""
        if isinstance(left, PropositionalVariable):
            left = cls.variable(left)
        if isinstance(right, PropositionalVariable):
            right = cls.variable(right)
        return cls(operator=LogicalOperator.IMPLIES, left=left, right=right)
    
    @classmethod
    def equivalence(cls, left: Union['PropositionalFormula', PropositionalVariable], 
                   right: Union['PropositionalFormula', PropositionalVariable]) -> 'PropositionalFormula':
        """创建等价公式"""
        if isinstance(left, PropositionalVariable):
            left = cls.variable(left)
        if isinstance(right, PropositionalVariable):
            right = cls.variable(right)
        return cls(operator=LogicalOperator.EQUIVALENT, left=left, right=right)
    
    def get_variables(self) -> Set[PropositionalVariable]:
        """获取公式中的所有变量"""
        variables = set()
        
        if self.variable is not None:
            variables.add(self.variable)
        elif self.operator is not None:
            if self.left is not None:
                if isinstance(self.left, PropositionalVariable):
                    variables.add(self.left)
                else:
                    variables.update(self.left.get_variables())
            
            if self.right is not None:
                if isinstance(self.right, PropositionalVariable):
                    variables.add(self.right)
                else:
                    variables.update(self.right.get_variables())
        
        return variables
    
    def evaluate(self, assignment: Dict[PropositionalVariable, bool]) -> bool:
        """在给定赋值下求值"""
        if self.variable is not None:
            return assignment.get(self.variable, False)
        
        if self.operator == LogicalOperator.NOT:
            return not self.left.evaluate(assignment)
        
        left_val = self.left.evaluate(assignment)
        right_val = self.right.evaluate(assignment)
        
        if self.operator == LogicalOperator.AND:
            return left_val and right_val
        elif self.operator == LogicalOperator.OR:
            return left_val or right_val
        elif self.operator == LogicalOperator.IMPLIES:
            return (not left_val) or right_val
        elif self.operator == LogicalOperator.EQUIVALENT:
            return left_val == right_val
        
        raise ValueError(f"未知的操作符: {self.operator}")
    
    def __str__(self):
        if self.variable is not None:
            return str(self.variable)
        
        if self.operator == LogicalOperator.NOT:
            return f"¬({self.left})"
        
        left_str = str(self.left)
        right_str = str(self.right)
        
        if self.operator == LogicalOperator.AND:
            return f"({left_str} ∧ {right_str})"
        elif self.operator == LogicalOperator.OR:
            return f"({left_str} ∨ {right_str})"
        elif self.operator == LogicalOperator.IMPLIES:
            return f"({left_str} → {right_str})"
        elif self.operator == LogicalOperator.EQUIVALENT:
            return f"({left_str} ↔ {right_str})"
        
        return "未知公式"
```

### 1.2 真值表

**定义 1.1.4 (真值表)**
真值表是列出命题公式在所有可能赋值下真值的表格。

**Python实现**：

```python
class TruthTable:
    """真值表"""
    
    def __init__(self, formula: PropositionalFormula):
        self.formula = formula
        self.variables = sorted(list(formula.get_variables()), key=lambda x: x.name)
        self.table = self._generate_table()
    
    def _generate_table(self) -> List[Dict[str, bool]]:
        """生成真值表"""
        table = []
        n_vars = len(self.variables)
        
        # 生成所有可能的赋值
        for assignment_bits in itertools.product([False, True], repeat=n_vars):
            assignment = {var: bit for var, bit in zip(self.variables, assignment_bits)}
            result = self.formula.evaluate(assignment)
            
            row = {var.name: bit for var, bit in zip(self.variables, assignment_bits)}
            row['result'] = result
            table.append(row)
        
        return table
    
    def is_tautology(self) -> bool:
        """检查是否为重言式"""
        return all(row['result'] for row in self.table)
    
    def is_contradiction(self) -> bool:
        """检查是否为矛盾式"""
        return not any(row['result'] for row in self.table)
    
    def is_satisfiable(self) -> bool:
        """检查是否为可满足式"""
        return any(row['result'] for row in self.table)
    
    def get_satisfying_assignments(self) -> List[Dict[str, bool]]:
        """获取所有满足赋值"""
        return [row for row in self.table if row['result']]
    
    def print_table(self) -> None:
        """打印真值表"""
        # 打印表头
        header = " | ".join(var.name for var in self.variables) + " | result"
        print(header)
        print("-" * len(header))
        
        # 打印每一行
        for row in self.table:
            values = [str(int(row[var.name])) for var in self.variables]
            values.append(str(int(row['result'])))
            print(" | ".join(values))
```

### 1.3 逻辑等价

**定义 1.1.5 (逻辑等价)**
两个命题公式 $\phi$ 和 $\psi$ 逻辑等价，记作 $\phi \equiv \psi$，当且仅当它们在所有赋值下具有相同的真值。

**定理 1.1.1 (德摩根律)**
对于任意命题公式 $\phi$ 和 $\psi$：

1. $\neg(\phi \land \psi) \equiv \neg\phi \lor \neg\psi$
2. $\neg(\phi \lor \psi) \equiv \neg\phi \land \neg\psi$

**Python实现**：

```python
def are_logically_equivalent(formula1: PropositionalFormula, 
                           formula2: PropositionalFormula) -> bool:
    """检查两个公式是否逻辑等价"""
    # 获取所有变量
    all_variables = formula1.get_variables().union(formula2.get_variables())
    
    # 检查所有可能的赋值
    for assignment_bits in itertools.product([False, True], repeat=len(all_variables)):
        assignment = {var: bit for var, bit in zip(all_variables, assignment_bits)}
        
        if formula1.evaluate(assignment) != formula2.evaluate(assignment):
            return False
    
    return True

def apply_demorgan_law(formula: PropositionalFormula) -> PropositionalFormula:
    """应用德摩根律"""
    if formula.operator == LogicalOperator.NOT:
        inner = formula.left
        if inner.operator == LogicalOperator.AND:
            # ¬(φ ∧ ψ) ≡ ¬φ ∨ ¬ψ
            return PropositionalFormula.disjunction(
                PropositionalFormula.negation(inner.left),
                PropositionalFormula.negation(inner.right)
            )
        elif inner.operator == LogicalOperator.OR:
            # ¬(φ ∨ ψ) ≡ ¬φ ∧ ¬ψ
            return PropositionalFormula.conjunction(
                PropositionalFormula.negation(inner.left),
                PropositionalFormula.negation(inner.right)
            )
    
    return formula
```

## 2. 谓词逻辑

### 2.1 基本概念

**定义 2.1.1 (谓词)**
谓词是描述对象性质的函数，返回真值。

-**定义 2.1.2 (量词)**

- 全称量词 ($\forall$): 对所有
- 存在量词 ($\exists$): 存在

**定义 2.1.3 (谓词公式)**
谓词公式由谓词、变量、常量、函数符号和逻辑连接词组成。

**Python实现**：

```python
class Predicate:
    """谓词"""
    
    def __init__(self, name: str, arity: int):
        self.name = name
        self.arity = arity  # 参数个数
    
    def __call__(self, *args) -> bool:
        """调用谓词"""
        if len(args) != self.arity:
            raise ValueError(f"谓词 {self.name} 需要 {self.arity} 个参数，但提供了 {len(args)} 个")
        
        # 这里应该实现具体的谓词逻辑
        # 为了演示，我们使用一个简单的示例
        if self.name == "is_valid":
            return all(isinstance(arg, str) and len(arg) > 0 for arg in args)
        elif self.name == "is_greater_than":
            return args[0] > args[1]
        elif self.name == "is_equal":
            return args[0] == args[1]
        
        return False

class Quantifier(Enum):
    """量词"""
    FORALL = "∀"
    EXISTS = "∃"

class PredicateFormula:
    """谓词公式"""
    
    def __init__(self, 
                 predicate: Optional[Predicate] = None,
                 arguments: Optional[List[str]] = None,
                 operator: Optional[LogicalOperator] = None,
                 left: Optional['PredicateFormula'] = None,
                 right: Optional['PredicateFormula'] = None,
                 quantifier: Optional[Quantifier] = None,
                 variable: Optional[str] = None,
                 scope: Optional['PredicateFormula'] = None):
        self.predicate = predicate
        self.arguments = arguments or []
        self.operator = operator
        self.left = left
        self.right = right
        self.quantifier = quantifier
        self.variable = variable
        self.scope = scope
    
    @classmethod
    def atomic(cls, predicate: Predicate, arguments: List[str]) -> 'PredicateFormula':
        """创建原子公式"""
        return cls(predicate=predicate, arguments=arguments)
    
    @classmethod
    def universal(cls, variable: str, scope: 'PredicateFormula') -> 'PredicateFormula':
        """创建全称量词公式"""
        return cls(quantifier=Quantifier.FORALL, variable=variable, scope=scope)
    
    @classmethod
    def existential(cls, variable: str, scope: 'PredicateFormula') -> 'PredicateFormula':
        """创建存在量词公式"""
        return cls(quantifier=Quantifier.EXISTS, variable=variable, scope=scope)
    
    def evaluate(self, interpretation: Dict[str, Any]) -> bool:
        """在给定解释下求值"""
        if self.predicate is not None:
            # 原子公式
            args = [interpretation.get(arg, arg) for arg in self.arguments]
            return self.predicate(*args)
        
        if self.quantifier is not None:
            # 量词公式
            if self.quantifier == Quantifier.FORALL:
                # 全称量词：对所有可能的值都为真
                domain = interpretation.get('domain', [])
                return all(
                    self.scope.evaluate({**interpretation, self.variable: value})
                    for value in domain
                )
            elif self.quantifier == Quantifier.EXISTS:
                # 存在量词：存在一个值为真
                domain = interpretation.get('domain', [])
                return any(
                    self.scope.evaluate({**interpretation, self.variable: value})
                    for value in domain
                )
        
        # 复合公式
        if self.operator == LogicalOperator.NOT:
            return not self.left.evaluate(interpretation)
        
        left_val = self.left.evaluate(interpretation)
        right_val = self.right.evaluate(interpretation)
        
        if self.operator == LogicalOperator.AND:
            return left_val and right_val
        elif self.operator == LogicalOperator.OR:
            return left_val or right_val
        elif self.operator == LogicalOperator.IMPLIES:
            return (not left_val) or right_val
        elif self.operator == LogicalOperator.EQUIVALENT:
            return left_val == right_val
        
        raise ValueError(f"未知的操作符: {self.operator}")
    
    def __str__(self):
        if self.predicate is not None:
            args_str = ", ".join(self.arguments)
            return f"{self.predicate.name}({args_str})"
        
        if self.quantifier is not None:
            return f"{self.quantifier.value}{self.variable}({self.scope})"
        
        if self.operator == LogicalOperator.NOT:
            return f"¬({self.left})"
        
        left_str = str(self.left)
        right_str = str(self.right)
        
        if self.operator == LogicalOperator.AND:
            return f"({left_str} ∧ {right_str})"
        elif self.operator == LogicalOperator.OR:
            return f"({left_str} ∨ {right_str})"
        elif self.operator == LogicalOperator.IMPLIES:
            return f"({left_str} → {right_str})"
        elif self.operator == LogicalOperator.EQUIVALENT:
            return f"({left_str} ↔ {right_str})"
        
        return "未知公式"
```

### 2.2 软件规范

**定义 2.1.4 (前置条件)**
前置条件 $Pre$ 描述函数执行前必须满足的条件。

**定义 2.1.5 (后置条件)**
后置条件 $Post$ 描述函数执行后必须满足的条件。

**定义 2.1.6 (函数规范)**
函数规范 $Spec(f) = \{Pre\} f \{Post\}$ 表示如果 $Pre$ 成立，执行 $f$ 后 $Post$ 成立。

**Python实现**：

```python
from typing import Callable, Any

class FunctionSpecification:
    """函数规范"""
    
    def __init__(self, 
                 function_name: str,
                 precondition: PredicateFormula,
                 postcondition: PredicateFormula):
        self.function_name = function_name
        self.precondition = precondition
        self.postcondition = postcondition
    
    def verify(self, function: Callable, test_cases: List[Dict[str, Any]]) -> bool:
        """验证函数是否满足规范"""
        for test_case in test_cases:
            # 检查前置条件
            if not self.precondition.evaluate(test_case):
                continue  # 前置条件不满足，跳过
            
            # 执行函数
            try:
                result = function(**test_case)
                # 构建后置条件的解释
                post_interpretation = {**test_case, 'result': result}
                
                # 检查后置条件
                if not self.postcondition.evaluate(post_interpretation):
                    return False
            except Exception:
                # 函数执行异常，可能违反规范
                return False
        
        return True
    
    def __str__(self):
        return f"{{{self.precondition}}} {self.function_name} {{{self.postcondition}}}"

# 示例：验证排序函数
def create_sort_verification():
    """创建排序函数验证"""
    # 前置条件：输入是整数列表
    precondition = PredicateFormula.atomic(
        Predicate("is_integer_list", 1), ["input"]
    )
    
    # 后置条件：输出是排序后的列表
    postcondition = PredicateFormula.conjunction(
        PredicateFormula.atomic(Predicate("is_sorted", 1), ["result"]),
        PredicateFormula.atomic(Predicate("is_permutation", 2), ["input", "result"])
    )
    
    return FunctionSpecification("sort", precondition, postcondition)
```

## 3. 模态逻辑

### 3.1 基本概念

**定义 3.1.1 (模态算子)**:

- 必然算子 ($\Box$): 必然
- 可能算子 ($\Diamond$): 可能

**定义 3.1.2 (模态公式)**
模态公式在命题逻辑基础上增加模态算子。

**Python实现**：

```python
class ModalOperator(Enum):
    """模态算子"""
    NECESSARY = "□"
    POSSIBLE = "◇"

class ModalFormula:
    """模态公式"""
    
    def __init__(self, 
                 operator: Optional[ModalOperator] = None,
                 formula: Optional['ModalFormula'] = None,
                 propositional_formula: Optional[PropositionalFormula] = None,
                 logical_operator: Optional[LogicalOperator] = None,
                 left: Optional['ModalFormula'] = None,
                 right: Optional['ModalFormula'] = None):
        self.operator = operator
        self.formula = formula
        self.propositional_formula = propositional_formula
        self.logical_operator = logical_operator
        self.left = left
        self.right = right
    
    @classmethod
    def atomic(cls, prop_formula: PropositionalFormula) -> 'ModalFormula':
        """创建原子模态公式"""
        return cls(propositional_formula=prop_formula)
    
    @classmethod
    def necessary(cls, formula: 'ModalFormula') -> 'ModalFormula':
        """创建必然公式"""
        return cls(operator=ModalOperator.NECESSARY, formula=formula)
    
    @classmethod
    def possible(cls, formula: 'ModalFormula') -> 'ModalFormula':
        """创建可能公式"""
        return cls(operator=ModalOperator.POSSIBLE, formula=formula)
    
    def evaluate(self, world: str, accessibility_relation: Dict[str, Set[str]], 
                valuation: Dict[str, Dict[str, bool]]) -> bool:
        """在给定世界和可及关系下求值"""
        if self.propositional_formula is not None:
            # 原子公式
            return self.propositional_formula.evaluate(valuation.get(world, {}))
        
        if self.operator == ModalOperator.NECESSARY:
            # □φ 在所有可及世界中都为真
            accessible_worlds = accessibility_relation.get(world, set())
            return all(
                self.formula.evaluate(w, accessibility_relation, valuation)
                for w in accessible_worlds
            )
        
        if self.operator == ModalOperator.POSSIBLE:
            # ◇φ 在某个可及世界中为真
            accessible_worlds = accessibility_relation.get(world, set())
            return any(
                self.formula.evaluate(w, accessibility_relation, valuation)
                for w in accessible_worlds
            )
        
        # 逻辑连接词
        if self.logical_operator == LogicalOperator.NOT:
            return not self.left.evaluate(world, accessibility_relation, valuation)
        
        left_val = self.left.evaluate(world, accessibility_relation, valuation)
        right_val = self.right.evaluate(world, accessibility_relation, valuation)
        
        if self.logical_operator == LogicalOperator.AND:
            return left_val and right_val
        elif self.logical_operator == LogicalOperator.OR:
            return left_val or right_val
        elif self.logical_operator == LogicalOperator.IMPLIES:
            return (not left_val) or right_val
        elif self.logical_operator == LogicalOperator.EQUIVALENT:
            return left_val == right_val
        
        raise ValueError(f"未知的操作符: {self.logical_operator}")
    
    def __str__(self):
        if self.propositional_formula is not None:
            return str(self.propositional_formula)
        
        if self.operator == ModalOperator.NECESSARY:
            return f"□({self.formula})"
        
        if self.operator == ModalOperator.POSSIBLE:
            return f"◇({self.formula})"
        
        if self.logical_operator == LogicalOperator.NOT:
            return f"¬({self.left})"
        
        left_str = str(self.left)
        right_str = str(self.right)
        
        if self.logical_operator == LogicalOperator.AND:
            return f"({left_str} ∧ {right_str})"
        elif self.logical_operator == LogicalOperator.OR:
            return f"({left_str} ∨ {right_str})"
        elif self.logical_operator == LogicalOperator.IMPLIES:
            return f"({left_str} → {right_str})"
        elif self.logical_operator == LogicalOperator.EQUIVALENT:
            return f"({left_str} ↔ {right_str})"
        
        return "未知公式"
```

### 3.2 软件系统建模

**定义 3.1.3 (系统状态)**
系统状态是世界的一个实例，表示系统在某个时刻的配置。

**定义 3.1.4 (状态转换)**
状态转换关系表示系统从一个状态到另一个状态的可能转换。

**Python实现**：

```python
class SoftwareSystemModel:
    """软件系统模态模型"""
    
    def __init__(self, 
                 states: Set[str],
                 transitions: Dict[str, Set[str]],
                 propositions: Dict[str, Dict[str, bool]]):
        self.states = states
        self.transitions = transitions
        self.propositions = propositions
    
    def check_property(self, formula: ModalFormula, initial_state: str) -> bool:
        """检查系统是否满足属性"""
        return formula.evaluate(initial_state, self.transitions, self.propositions)
    
    def get_reachable_states(self, initial_state: str) -> Set[str]:
        """获取从初始状态可达的所有状态"""
        reachable = {initial_state}
        changed = True
        
        while changed:
            changed = False
            new_states = set()
            for state in reachable:
                for next_state in self.transitions.get(state, set()):
                    if next_state not in reachable:
                        new_states.add(next_state)
                        changed = True
            reachable.update(new_states)
        
        return reachable
    
    def verify_safety_property(self, property_formula: ModalFormula) -> bool:
        """验证安全属性（在所有可达状态中都成立）"""
        for state in self.states:
            if not property_formula.evaluate(state, self.transitions, self.propositions):
                return False
        return True
    
    def verify_liveness_property(self, property_formula: ModalFormula) -> bool:
        """验证活性属性（存在可达状态成立）"""
        for state in self.states:
            if property_formula.evaluate(state, self.transitions, self.propositions):
                return True
        return False
```

## 4. 时序逻辑

### 4.1 线性时序逻辑 (LTL)

**定义 4.1.1 (LTL算子)**:

- $X$ (Next): 下一个状态
- $F$ (Finally): 最终
- $G$ (Globally): 全局
- $U$ (Until): 直到

**Python实现**：

```python
class TemporalOperator(Enum):
    """时序算子"""
    NEXT = "X"
    FINALLY = "F"
    GLOBALLY = "G"
    UNTIL = "U"

class LTLFormula:
    """线性时序逻辑公式"""
    
    def __init__(self, 
                 operator: Optional[TemporalOperator] = None,
                 left: Optional['LTLFormula'] = None,
                 right: Optional['LTLFormula'] = None,
                 propositional_formula: Optional[PropositionalFormula] = None):
        self.operator = operator
        self.left = left
        self.right = right
        self.propositional_formula = propositional_formula
    
    @classmethod
    def atomic(cls, prop_formula: PropositionalFormula) -> 'LTLFormula':
        """创建原子公式"""
        return cls(propositional_formula=prop_formula)
    
    @classmethod
    def next(cls, formula: 'LTLFormula') -> 'LTLFormula':
        """创建下一个公式"""
        return cls(operator=TemporalOperator.NEXT, left=formula)
    
    @classmethod
    def finally_(cls, formula: 'LTLFormula') -> 'LTLFormula':
        """创建最终公式"""
        return cls(operator=TemporalOperator.FINALLY, left=formula)
    
    @classmethod
    def globally(cls, formula: 'LTLFormula') -> 'LTLFormula':
        """创建全局公式"""
        return cls(operator=TemporalOperator.GLOBALLY, left=formula)
    
    @classmethod
    def until(cls, left: 'LTLFormula', right: 'LTLFormula') -> 'LTLFormula':
        """创建直到公式"""
        return cls(operator=TemporalOperator.UNTIL, left=left, right=right)
    
    def evaluate(self, path: List[str], position: int, 
                valuation: Dict[str, Dict[str, bool]]) -> bool:
        """在给定路径和位置上求值"""
        if self.propositional_formula is not None:
            # 原子公式
            current_state = path[position]
            return self.propositional_formula.evaluate(valuation.get(current_state, {}))
        
        if self.operator == TemporalOperator.NEXT:
            # Xφ: 下一个位置满足φ
            if position + 1 < len(path):
                return self.left.evaluate(path, position + 1, valuation)
            return False
        
        if self.operator == TemporalOperator.FINALLY:
            # Fφ: 存在一个位置满足φ
            return any(
                self.left.evaluate(path, i, valuation)
                for i in range(position, len(path))
            )
        
        if self.operator == TemporalOperator.GLOBALLY:
            # Gφ: 所有位置都满足φ
            return all(
                self.left.evaluate(path, i, valuation)
                for i in range(position, len(path))
            )
        
        if self.operator == TemporalOperator.UNTIL:
            # φ U ψ: φ成立直到ψ成立
            for i in range(position, len(path)):
                if self.right.evaluate(path, i, valuation):
                    return True
                if not self.left.evaluate(path, i, valuation):
                    return False
            return False
        
        raise ValueError(f"未知的时序算子: {self.operator}")
    
    def __str__(self):
        if self.propositional_formula is not None:
            return str(self.propositional_formula)
        
        if self.operator == TemporalOperator.NEXT:
            return f"X({self.left})"
        elif self.operator == TemporalOperator.FINALLY:
            return f"F({self.left})"
        elif self.operator == TemporalOperator.GLOBALLY:
            return f"G({self.left})"
        elif self.operator == TemporalOperator.UNTIL:
            return f"({self.left} U {self.right})"
        
        return "未知公式"
```

### 4.2 软件属性验证

**定义 4.1.2 (安全属性)**
安全属性表示"坏事永远不会发生"，形式为 $G \neg bad$。

**定义 4.1.3 (活性属性)**
活性属性表示"好事最终会发生"，形式为 $F good$。

**Python实现**：

```python
class SoftwarePropertyVerifier:
    """软件属性验证器"""
    
    def __init__(self, system_model: SoftwareSystemModel):
        self.system_model = system_model
    
    def verify_safety_property(self, bad_condition: PropositionalFormula) -> bool:
        """验证安全属性"""
        # 安全属性: G ¬bad
        safety_formula = LTLFormula.globally(
            LTLFormula.atomic(
                PropositionalFormula.negation(bad_condition)
            )
        )
        
        # 检查所有可能的路径
        for initial_state in self.system_model.states:
            paths = self._generate_paths(initial_state)
            for path in paths:
                if not safety_formula.evaluate(path, 0, self.system_model.propositions):
                    return False
        
        return True
    
    def verify_liveness_property(self, good_condition: PropositionalFormula) -> bool:
        """验证活性属性"""
        # 活性属性: F good
        liveness_formula = LTLFormula.finally_(
            LTLFormula.atomic(good_condition)
        )
        
        # 检查所有可能的路径
        for initial_state in self.system_model.states:
            paths = self._generate_paths(initial_state)
            for path in paths:
                if not liveness_formula.evaluate(path, 0, self.system_model.propositions):
                    return False
        
        return True
    
    def _generate_paths(self, initial_state: str, max_length: int = 10) -> List[List[str]]:
        """生成从初始状态开始的所有路径"""
        paths = []
        
        def dfs(current_path: List[str], current_state: str, length: int):
            if length >= max_length:
                paths.append(current_path[:])
                return
            
            current_path.append(current_state)
            paths.append(current_path[:])
            
            for next_state in self.system_model.transitions.get(current_state, set()):
                dfs(current_path, next_state, length + 1)
            
            current_path.pop()
        
        dfs([], initial_state, 0)
        return paths
```

## 5. 软件验证应用

### 5.1 程序验证

**定义 5.1.1 (霍尔逻辑)**
霍尔逻辑用于验证程序的正确性，形式为 $\{P\} C \{Q\}$。

**Python实现**：

```python
class HoareTriple:
    """霍尔三元组"""
    
    def __init__(self, 
                 precondition: PredicateFormula,
                 program: str,
                 postcondition: PredicateFormula):
        self.precondition = precondition
        self.program = program
        self.postcondition = postcondition
    
    def verify(self, test_cases: List[Dict[str, Any]]) -> bool:
        """验证霍尔三元组"""
        for test_case in test_cases:
            # 检查前置条件
            if not self.precondition.evaluate(test_case):
                continue
            
            # 执行程序（这里简化处理）
            try:
                result = self._execute_program(test_case)
                post_interpretation = {**test_case, 'result': result}
                
                if not self.postcondition.evaluate(post_interpretation):
                    return False
            except Exception:
                return False
        
        return True
    
    def _execute_program(self, context: Dict[str, Any]) -> Any:
        """执行程序（简化实现）"""
        # 这里应该实现实际的程序执行
        # 为了演示，我们返回一个模拟结果
        return context.get('input', 0) + 1
    
    def __str__(self):
        return f"{{{self.precondition}}} {self.program} {{{self.postcondition}}}"

# 示例：验证排序函数
def create_sort_verification():
    """创建排序函数验证"""
    # 前置条件：输入是整数列表
    precondition = PredicateFormula.atomic(
        Predicate("is_integer_list", 1), ["input"]
    )
    
    # 后置条件：输出是排序后的列表
    postcondition = PredicateFormula.conjunction(
        PredicateFormula.atomic(Predicate("is_sorted", 1), ["result"]),
        PredicateFormula.atomic(Predicate("is_permutation", 2), ["input", "result"])
    )
    
    return HoareTriple(precondition, "sort(input)", postcondition)
```

### 5.2 模型检查

**定义 5.1.2 (模型检查)**
模型检查是自动验证有限状态系统是否满足时序逻辑公式的技术。

**Python实现**：

```python
class ModelChecker:
    """模型检查器"""
    
    def __init__(self, system_model: SoftwareSystemModel):
        self.system_model = system_model
    
    def check_ltl_formula(self, formula: LTLFormula) -> Dict[str, Any]:
        """检查LTL公式"""
        result = {
            'satisfied': True,
            'counterexamples': [],
            'satisfying_states': set()
        }
        
        for state in self.system_model.states:
            paths = self._generate_paths(state)
            state_satisfies = True
            
            for path in paths:
                if not formula.evaluate(path, 0, self.system_model.propositions):
                    state_satisfies = False
                    result['counterexamples'].append({
                        'initial_state': state,
                        'path': path
                    })
            
            if state_satisfies:
                result['satisfying_states'].add(state)
            else:
                result['satisfied'] = False
        
        return result
    
    def _generate_paths(self, initial_state: str, max_length: int = 10) -> List[List[str]]:
        """生成路径（简化实现）"""
        paths = []
        
        def dfs(current_path: List[str], current_state: str, length: int):
            if length >= max_length:
                paths.append(current_path[:])
                return
            
            current_path.append(current_state)
            paths.append(current_path[:])
            
            for next_state in self.system_model.transitions.get(current_state, set()):
                dfs(current_path, next_state, length + 1)
            
            current_path.pop()
        
        dfs([], initial_state, 0)
        return paths
```

## 总结

逻辑学为软件设计提供了强大的形式化推理工具：

1. **命题逻辑**：处理简单的真值判断
2. **谓词逻辑**：处理复杂的对象和关系
3. **模态逻辑**：处理可能性和必然性
4. **时序逻辑**：处理时间相关的属性

这些逻辑系统为软件系统的规范、验证和推理提供了严格的数学基础，确保软件系统的正确性和可靠性。

---

*本章建立了软件设计的逻辑基础，为后续的形式化验证和推理提供了理论工具。*
