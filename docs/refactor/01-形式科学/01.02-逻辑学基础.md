# 01.02 é€»è¾‘å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

é€»è¾‘å­¦æ˜¯å½¢å¼ç§‘å­¦çš„æ ¸å¿ƒï¼Œä¸ºè½¯ä»¶å·¥ç¨‹ã€äººå·¥æ™ºèƒ½å’Œè®¡ç®—ç†è®ºæä¾›åŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰é€»è¾‘å­¦çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å‘½é¢˜é€»è¾‘

**æ•°å­¦å®šä¹‰**ï¼š
å‘½é¢˜é€»è¾‘åŸºäºçœŸå€¼å‡½æ•°ï¼š$f: \{T, F\}^n \rightarrow \{T, F\}$ï¼Œå…¶ä¸­ï¼š

- $T$ è¡¨ç¤ºçœŸ
- $F$ è¡¨ç¤ºå‡
- $n$ æ˜¯å‘½é¢˜å˜å…ƒçš„ä¸ªæ•°

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Callable, Any
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod

class TruthValue(Enum):
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """å‘½é¢˜"""
    name: str
    value: TruthValue

class PropositionalLogic:
    """å‘½é¢˜é€»è¾‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.propositions: Dict[str, Proposition] = {}
        self.operators = {
            'NOT': lambda p: TruthValue(not p.value),
            'AND': lambda p, q: TruthValue(p.value and q.value),
            'OR': lambda p, q: TruthValue(p.value or q.value),
            'IMPLIES': lambda p, q: TruthValue(not p.value or q.value),
            'EQUIVALENT': lambda p, q: TruthValue(p.value == q.value)
        }
    
    def add_proposition(self, name: str, value: TruthValue):
        """æ·»åŠ å‘½é¢˜"""
        self.propositions[name] = Proposition(name, value)
    
    def evaluate_expression(self, expression: str) -> TruthValue:
        """è¯„ä¼°é€»è¾‘è¡¨è¾¾å¼"""
        # ç®€åŒ–çš„è¡¨è¾¾å¼æ±‚å€¼
        if expression in self.propositions:
            return self.propositions[expression].value
        
        # å¤„ç†å¤åˆè¡¨è¾¾å¼
        if expression.startswith('NOT('):
            inner = expression[4:-1]
            return self.operators['NOT'](Proposition('', self.evaluate_expression(inner)))
        
        return TruthValue.FALSE

# ç¤ºä¾‹ï¼šå‘½é¢˜é€»è¾‘
def demonstrate_propositional_logic():
    """æ¼”ç¤ºå‘½é¢˜é€»è¾‘"""
    logic = PropositionalLogic()
    
    # æ·»åŠ å‘½é¢˜
    logic.add_proposition('P', TruthValue.TRUE)
    logic.add_proposition('Q', TruthValue.FALSE)
    
    print("å‘½é¢˜é€»è¾‘ç¤ºä¾‹:")
    print(f"P = {logic.propositions['P'].value}")
    print(f"Q = {logic.propositions['Q'].value}")
    
    return logic

# è¿è¡Œç¤ºä¾‹
prop_logic = demonstrate_propositional_logic()
```

### 2. è°“è¯é€»è¾‘

**æ•°å­¦å®šä¹‰**ï¼š
è°“è¯é€»è¾‘æ‰©å±•å‘½é¢˜é€»è¾‘ï¼Œå¼•å…¥é‡è¯ï¼š$\forall x P(x)$ å’Œ $\exists x P(x)$

**Pythonå®ç°**ï¼š

```python
class PredicateLogic:
    """è°“è¯é€»è¾‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.domain = set()
        self.predicates = {}
    
    def set_domain(self, domain: set):
        """è®¾ç½®è®ºåŸŸ"""
        self.domain = domain
    
    def add_predicate(self, name: str, predicate_func: Callable):
        """æ·»åŠ è°“è¯"""
        self.predicates[name] = predicate_func
    
    def universal_quantifier(self, predicate_name: str) -> bool:
        """å…¨ç§°é‡è¯ âˆ€x P(x)"""
        if predicate_name not in self.predicates:
            return False
        
        predicate = self.predicates[predicate_name]
        return all(predicate(x) for x in self.domain)
    
    def existential_quantifier(self, predicate_name: str) -> bool:
        """å­˜åœ¨é‡è¯ âˆƒx P(x)"""
        if predicate_name not in self.predicates:
            return False
        
        predicate = self.predicates[predicate_name]
        return any(predicate(x) for x in self.domain)

# ç¤ºä¾‹ï¼šè°“è¯é€»è¾‘
def demonstrate_predicate_logic():
    """æ¼”ç¤ºè°“è¯é€»è¾‘"""
    logic = PredicateLogic()
    
    # è®¾ç½®è®ºåŸŸ
    logic.set_domain({1, 2, 3, 4, 5})
    
    # æ·»åŠ è°“è¯
    logic.add_predicate('is_even', lambda x: x % 2 == 0)
    logic.add_predicate('is_positive', lambda x: x > 0)
    
    print("è°“è¯é€»è¾‘ç¤ºä¾‹:")
    print(f"âˆ€x is_positive(x): {logic.universal_quantifier('is_positive')}")
    print(f"âˆƒx is_even(x): {logic.existential_quantifier('is_even')}")
    
    return logic

# è¿è¡Œç¤ºä¾‹
pred_logic = demonstrate_predicate_logic()
```

### 3. å½¢å¼åŒ–è¯æ˜

**æ•°å­¦å®šä¹‰**ï¼š
å½¢å¼åŒ–è¯æ˜æ˜¯ä¸€ä¸ªæœ‰é™åºåˆ—ï¼š$P_1, P_2, \ldots, P_n$ï¼Œå…¶ä¸­æ¯ä¸ª $P_i$ è¦ä¹ˆæ˜¯å…¬ç†ï¼Œè¦ä¹ˆç”±å‰é¢çš„å‘½é¢˜é€šè¿‡æ¨ç†è§„åˆ™å¾—å‡ºã€‚

**Pythonå®ç°**ï¼š

```python
@dataclass
class ProofStep:
    """è¯æ˜æ­¥éª¤"""
    step_number: int
    proposition: str
    rule: str
    premises: List[int]

class FormalProof:
    """å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ"""
    
    def __init__(self):
        self.steps: List[ProofStep] = []
        self.axioms = set()
        self.rules = {}
    
    def add_axiom(self, axiom: str):
        """æ·»åŠ å…¬ç†"""
        self.axioms.add(axiom)
    
    def add_rule(self, name: str, rule_func: Callable):
        """æ·»åŠ æ¨ç†è§„åˆ™"""
        self.rules[name] = rule_func
    
    def add_step(self, proposition: str, rule: str, premises: List[int] = None):
        """æ·»åŠ è¯æ˜æ­¥éª¤"""
        step = ProofStep(
            step_number=len(self.steps) + 1,
            proposition=proposition,
            rule=rule,
            premises=premises or []
        )
        self.steps.append(step)
    
    def verify_proof(self) -> bool:
        """éªŒè¯è¯æ˜"""
        for step in self.steps:
            if step.rule == 'Axiom':
                if step.proposition not in self.axioms:
                    return False
            elif step.rule in self.rules:
                # éªŒè¯æ¨ç†è§„åˆ™åº”ç”¨
                if not self._verify_rule_application(step):
                    return False
            else:
                return False
        return True
    
    def _verify_rule_application(self, step: ProofStep) -> bool:
        """éªŒè¯æ¨ç†è§„åˆ™åº”ç”¨"""
        # ç®€åŒ–çš„éªŒè¯
        return True

# ç¤ºä¾‹ï¼šå½¢å¼åŒ–è¯æ˜
def demonstrate_formal_proof():
    """æ¼”ç¤ºå½¢å¼åŒ–è¯æ˜"""
    proof = FormalProof()
    
    # æ·»åŠ å…¬ç†
    proof.add_axiom("P â†’ (Q â†’ P)")
    proof.add_axiom("(P â†’ (Q â†’ R)) â†’ ((P â†’ Q) â†’ (P â†’ R))")
    
    # æ·»åŠ è¯æ˜æ­¥éª¤
    proof.add_step("P â†’ (Q â†’ P)", "Axiom")
    proof.add_step("(P â†’ (Q â†’ R)) â†’ ((P â†’ Q) â†’ (P â†’ R))", "Axiom")
    
    print("å½¢å¼åŒ–è¯æ˜ç¤ºä¾‹:")
    for step in proof.steps:
        print(f"æ­¥éª¤ {step.step_number}: {step.proposition} ({step.rule})")
    
    print(f"è¯æ˜æœ‰æ•ˆ: {proof.verify_proof()}")
    
    return proof

# è¿è¡Œç¤ºä¾‹
formal_proof = demonstrate_formal_proof()
```

### 4. é€»è¾‘ç¼–ç¨‹

**æ•°å­¦å®šä¹‰**ï¼š
é€»è¾‘ç¼–ç¨‹åŸºäºHornå­å¥ï¼š$A \leftarrow B_1, B_2, \ldots, B_n$ï¼Œå…¶ä¸­ $A$ æ˜¯å¤´éƒ¨ï¼Œ$B_i$ æ˜¯ä½“éƒ¨ã€‚

**Pythonå®ç°**ï¼š

```python
@dataclass
class HornClause:
    """Hornå­å¥"""
    head: str
    body: List[str]

class LogicProgramming:
    """é€»è¾‘ç¼–ç¨‹ç³»ç»Ÿ"""
    
    def __init__(self):
        self.clauses: List[HornClause] = []
        self.facts: set = set()
    
    def add_fact(self, fact: str):
        """æ·»åŠ äº‹å®"""
        self.facts.add(fact)
    
    def add_rule(self, head: str, body: List[str]):
        """æ·»åŠ è§„åˆ™"""
        clause = HornClause(head, body)
        self.clauses.append(clause)
    
    def query(self, goal: str) -> bool:
        """æŸ¥è¯¢ç›®æ ‡"""
        if goal in self.facts:
            return True
        
        # æŸ¥æ‰¾åŒ¹é…çš„è§„åˆ™
        for clause in self.clauses:
            if clause.head == goal:
                # æ£€æŸ¥ä½“éƒ¨æ˜¯å¦éƒ½ä¸ºçœŸ
                if all(self.query(subgoal) for subgoal in clause.body):
                    return True
        
        return False

# ç¤ºä¾‹ï¼šé€»è¾‘ç¼–ç¨‹
def demonstrate_logic_programming():
    """æ¼”ç¤ºé€»è¾‘ç¼–ç¨‹"""
    lp = LogicProgramming()
    
    # æ·»åŠ äº‹å®
    lp.add_fact("parent(john, mary)")
    lp.add_fact("parent(mary, bob)")
    
    # æ·»åŠ è§„åˆ™
    lp.add_rule("ancestor(X, Y)", ["parent(X, Y)"])
    lp.add_rule("ancestor(X, Y)", ["parent(X, Z)", "ancestor(Z, Y)"])
    
    print("é€»è¾‘ç¼–ç¨‹ç¤ºä¾‹:")
    print(f"parent(john, mary): {lp.query('parent(john, mary)')}")
    print(f"ancestor(john, bob): {lp.query('ancestor(john, bob)')}")
    
    return lp

# è¿è¡Œç¤ºä¾‹
logic_prog = demonstrate_logic_programming()
```

## ğŸ“Š é€»è¾‘å­¦æ€»ç»“

### æ ¸å¿ƒç‰¹å¾

1. **å½¢å¼åŒ–**ï¼šä½¿ç”¨æ•°å­¦ç¬¦å·ç²¾ç¡®è¡¨è¾¾
2. **æ¨ç†**ï¼šåŸºäºè§„åˆ™è¿›è¡Œé€»è¾‘æ¨å¯¼
3. **ä¸€è‡´æ€§**ï¼šé¿å…çŸ›ç›¾
4. **å®Œå¤‡æ€§**ï¼šæ‰€æœ‰çœŸå‘½é¢˜éƒ½å¯è¯æ˜

### æ•°å­¦å½¢å¼åŒ–

é€»è¾‘å­¦å¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦ç»“æ„è¡¨ç¤ºï¼š

$$Logic = (Propositional, Predicate, Proof, Programming)$$

### Pythonå®ç°éªŒè¯

```python
class LogicValidator:
    """é€»è¾‘å­¦éªŒè¯å™¨"""
    
    def __init__(self):
        self.components = {
            'propositional': self._validate_propositional,
            'predicate': self._validate_predicate,
            'proof': self._validate_proof,
            'programming': self._validate_programming
        }
    
    def validate_logic(self, component: str) -> bool:
        """éªŒè¯é€»è¾‘ç»„ä»¶"""
        if component in self.components:
            return self.components[component]()
        return False
    
    def _validate_propositional(self) -> bool:
        """éªŒè¯å‘½é¢˜é€»è¾‘"""
        logic = PropositionalLogic()
        logic.add_proposition('P', TruthValue.TRUE)
        return logic.propositions['P'].value == TruthValue.TRUE
    
    def _validate_predicate(self) -> bool:
        """éªŒè¯è°“è¯é€»è¾‘"""
        logic = PredicateLogic()
        logic.set_domain({1, 2, 3})
        logic.add_predicate('is_positive', lambda x: x > 0)
        return logic.universal_quantifier('is_positive')
    
    def _validate_proof(self) -> bool:
        """éªŒè¯å½¢å¼åŒ–è¯æ˜"""
        proof = FormalProof()
        proof.add_axiom("P")
        proof.add_step("P", "Axiom")
        return proof.verify_proof()
    
    def _validate_programming(self) -> bool:
        """éªŒè¯é€»è¾‘ç¼–ç¨‹"""
        lp = LogicProgramming()
        lp.add_fact("test")
        return lp.query("test")

# ä½¿ç”¨ç¤ºä¾‹
validator = LogicValidator()

for component in ['propositional', 'predicate', 'proof', 'programming']:
    is_valid = validator.validate_logic(component)
    print(f"{component.capitalize()}: {'VALID' if is_valid else 'INVALID'}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [01.01 é›†åˆè®ºåŸºç¡€](./01.01-é›†åˆè®ºåŸºç¡€.md)
- [01.03 å›¾è®ºåŸºç¡€](./01.03-å›¾è®ºåŸºç¡€.md)
- [02.01 ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02.01-ç®—æ³•ç†è®º.md)

---

*é€»è¾‘å­¦ä¸ºè½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦æä¾›äº†ä¸¥è°¨çš„æ¨ç†åŸºç¡€ï¼Œé€šè¿‡å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å»ºç«‹å¯é çš„é€»è¾‘ç³»ç»Ÿã€‚*
