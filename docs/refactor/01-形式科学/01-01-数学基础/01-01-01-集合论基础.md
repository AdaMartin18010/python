# é›†åˆè®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

é›†åˆè®ºæ˜¯æ•°å­¦çš„åŸºç¡€ç†è®ºï¼Œä¸ºè®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ¢è®¨é›†åˆè®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œå»ºç«‹ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆçš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 åŸºæœ¬å®šä¹‰

é›†åˆå¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$\mathcal{S} = (U, R, F, O)$$

å…¶ä¸­ï¼š
- $U$ æ˜¯å…¨é›† (Universal Set)
- $R$ æ˜¯å…³ç³»é›†åˆ (Relations)
- $F$ æ˜¯å‡½æ•°é›†åˆ (Functions)
- $O$ æ˜¯è¿ç®—é›†åˆ (Operations)

#### 1.2 é›†åˆè®ºå…¬ç†ç³»ç»Ÿ

é›†åˆè®ºåŸºäºä»¥ä¸‹å…¬ç†ï¼š

1. **å¤–å»¶å…¬ç†**: $\forall x \forall y [\forall z(z \in x \leftrightarrow z \in y) \rightarrow x = y]$
2. **ç©ºé›†å…¬ç†**: $\exists x \forall y (y \notin x)$
3. **é…å¯¹å…¬ç†**: $\forall x \forall y \exists z \forall w(w \in z \leftrightarrow w = x \vee w = y)$
4. **å¹¶é›†å…¬ç†**: $\forall F \exists A \forall x(x \in A \leftrightarrow \exists B(B \in F \wedge x \in B))$
5. **å¹‚é›†å…¬ç†**: $\forall x \exists y \forall z(z \in y \leftrightarrow z \subseteq x)$

## ğŸ”§ Python å®ç°

### 1. é›†åˆè®ºåŸºç¡€ç±»

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Set, Optional, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
import math

class SetOperation(Enum):
    """é›†åˆè¿ç®—ç±»å‹"""
    UNION = "union"
    INTERSECTION = "intersection"
    DIFFERENCE = "difference"
    SYMMETRIC_DIFFERENCE = "symmetric_difference"
    COMPLEMENT = "complement"
    CARTESIAN_PRODUCT = "cartesian_product"

@dataclass
class SetAxiom:
    """é›†åˆè®ºå…¬ç†"""
    name: str
    formal_expression: str
    description: str
    python_implementation: str
    
    def __post_init__(self):
        """éªŒè¯å…¬ç†å®šä¹‰"""
        if not self.name or not self.formal_expression:
            raise ValueError("å…¬ç†åç§°å’Œå½¢å¼è¡¨è¾¾å¼ä¸èƒ½ä¸ºç©º")

class MathematicalSet:
    """æ•°å­¦é›†åˆç±»"""
    
    def __init__(self, elements: Optional[Set[Any]] = None):
        self.elements = elements or set()
        self.universal_set: Optional[Set[Any]] = None
    
    def __contains__(self, element: Any) -> bool:
        """å…ƒç´ å±äºå…³ç³»"""
        return element in self.elements
    
    def __len__(self) -> int:
        """é›†åˆåŸºæ•°"""
        return len(self.elements)
    
    def __iter__(self):
        """è¿­ä»£å™¨"""
        return iter(self.elements)
    
    def add(self, element: Any):
        """æ·»åŠ å…ƒç´ """
        self.elements.add(element)
    
    def remove(self, element: Any):
        """ç§»é™¤å…ƒç´ """
        if element in self.elements:
            self.elements.remove(element)
        else:
            raise KeyError(f"å…ƒç´  {element} ä¸åœ¨é›†åˆä¸­")
    
    def union(self, other: 'MathematicalSet') -> 'MathematicalSet':
        """å¹¶é›†è¿ç®—"""
        result_elements = self.elements.union(other.elements)
        return MathematicalSet(result_elements)
    
    def intersection(self, other: 'MathematicalSet') -> 'MathematicalSet':
        """äº¤é›†è¿ç®—"""
        result_elements = self.elements.intersection(other.elements)
        return MathematicalSet(result_elements)
    
    def difference(self, other: 'MathematicalSet') -> 'MathematicalSet':
        """å·®é›†è¿ç®—"""
        result_elements = self.elements.difference(other.elements)
        return MathematicalSet(result_elements)
    
    def symmetric_difference(self, other: 'MathematicalSet') -> 'MathematicalSet':
        """å¯¹ç§°å·®é›†è¿ç®—"""
        result_elements = self.elements.symmetric_difference(other.elements)
        return MathematicalSet(result_elements)
    
    def complement(self) -> 'MathematicalSet':
        """è¡¥é›†è¿ç®—"""
        if self.universal_set is None:
            raise ValueError("æœªå®šä¹‰å…¨é›†ï¼Œæ— æ³•è®¡ç®—è¡¥é›†")
        result_elements = self.universal_set.difference(self.elements)
        return MathematicalSet(result_elements)
    
    def cartesian_product(self, other: 'MathematicalSet') -> 'MathematicalSet':
        """ç¬›å¡å°”ç§¯"""
        result_elements = set()
        for x in self.elements:
            for y in other.elements:
                result_elements.add((x, y))
        return MathematicalSet(result_elements)
    
    def is_subset(self, other: 'MathematicalSet') -> bool:
        """å­é›†å…³ç³»"""
        return self.elements.issubset(other.elements)
    
    def is_superset(self, other: 'MathematicalSet') -> bool:
        """è¶…é›†å…³ç³»"""
        return self.elements.issuperset(other.elements)
    
    def is_disjoint(self, other: 'MathematicalSet') -> bool:
        """ä¸ç›¸äº¤å…³ç³»"""
        return self.elements.isdisjoint(other.elements)
    
    def power_set(self) -> 'MathematicalSet':
        """å¹‚é›†"""
        elements_list = list(self.elements)
        power_set_elements = set()
        
        # ç”Ÿæˆæ‰€æœ‰å­é›†
        for i in range(2 ** len(elements_list)):
            subset = set()
            for j in range(len(elements_list)):
                if i & (1 << j):
                    subset.add(elements_list[j])
            power_set_elements.add(frozenset(subset))
        
        return MathematicalSet(power_set_elements)
    
    def cardinality(self) -> int:
        """åŸºæ•°"""
        return len(self.elements)
    
    def is_finite(self) -> bool:
        """æ˜¯å¦ä¸ºæœ‰é™é›†"""
        return self.cardinality() < float('inf')
    
    def is_empty(self) -> bool:
        """æ˜¯å¦ä¸ºç©ºé›†"""
        return len(self.elements) == 0
    
    def __str__(self) -> str:
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        return f"{{{', '.join(map(str, self.elements))}}}"
    
    def __repr__(self) -> str:
        """è¡¨ç¤ºå½¢å¼"""
        return f"MathematicalSet({self.elements})"

class SetTheory:
    """é›†åˆè®ºç†è®ºæ¡†æ¶"""
    
    def __init__(self):
        self.axioms: List[SetAxiom] = []
        self.theorems: List[Dict[str, Any]] = []
        self.definitions: List[Dict[str, Any]] = []
        self.universal_set: Optional[MathematicalSet] = None
    
    def add_axiom(self, axiom: SetAxiom):
        """æ·»åŠ å…¬ç†"""
        self.axioms.append(axiom)
    
    def add_theorem(self, name: str, statement: str, proof: str):
        """æ·»åŠ å®šç†"""
        self.theorems.append({
            "name": name,
            "statement": statement,
            "proof": proof
        })
    
    def add_definition(self, name: str, definition: str, examples: List[str]):
        """æ·»åŠ å®šä¹‰"""
        self.definitions.append({
            "name": name,
            "definition": definition,
            "examples": examples
        })
    
    def set_universal_set(self, universal_set: MathematicalSet):
        """è®¾ç½®å…¨é›†"""
        self.universal_set = universal_set
    
    def de_morgan_law(self, set_a: MathematicalSet, set_b: MathematicalSet) -> Dict[str, MathematicalSet]:
        """å¾·æ‘©æ ¹å®šå¾‹"""
        # è®¾ç½®å…¨é›†
        if self.universal_set:
            set_a.universal_set = self.universal_set.elements
            set_b.universal_set = self.universal_set.elements
        
        # å¾·æ‘©æ ¹å®šå¾‹ï¼š(A âˆª B)' = A' âˆ© B'
        union_complement = (set_a.union(set_b)).complement()
        intersection_of_complements = set_a.complement().intersection(set_b.complement())
        
        # å¾·æ‘©æ ¹å®šå¾‹ï¼š(A âˆ© B)' = A' âˆª B'
        intersection_complement = (set_a.intersection(set_b)).complement()
        union_of_complements = set_a.complement().union(set_b.complement())
        
        return {
            "law1": {
                "statement": "(A âˆª B)' = A' âˆ© B'",
                "left_side": union_complement,
                "right_side": intersection_of_complements,
                "verified": union_complement.elements == intersection_of_complements.elements
            },
            "law2": {
                "statement": "(A âˆ© B)' = A' âˆª B'",
                "left_side": intersection_complement,
                "right_side": union_of_complements,
                "verified": intersection_complement.elements == union_of_complements.elements
            }
        }
    
    def distributive_law(self, set_a: MathematicalSet, set_b: MathematicalSet, set_c: MathematicalSet) -> Dict[str, MathematicalSet]:
        """åˆ†é…å¾‹"""
        # A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)
        left_side1 = set_a.intersection(set_b.union(set_c))
        right_side1 = set_a.intersection(set_b).union(set_a.intersection(set_c))
        
        # A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C)
        left_side2 = set_a.union(set_b.intersection(set_c))
        right_side2 = set_a.union(set_b).intersection(set_a.union(set_c))
        
        return {
            "intersection_over_union": {
                "statement": "A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)",
                "left_side": left_side1,
                "right_side": right_side1,
                "verified": left_side1.elements == right_side1.elements
            },
            "union_over_intersection": {
                "statement": "A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C)",
                "left_side": left_side2,
                "right_side": right_side2,
                "verified": left_side2.elements == right_side2.elements
            }
        }
    
    def generate_set_operations_table(self, set_a: MathematicalSet, set_b: MathematicalSet) -> Dict[str, Any]:
        """ç”Ÿæˆé›†åˆè¿ç®—è¡¨"""
        return {
            "set_a": set_a,
            "set_b": set_b,
            "union": set_a.union(set_b),
            "intersection": set_a.intersection(set_b),
            "difference_a_b": set_a.difference(set_b),
            "difference_b_a": set_b.difference(set_a),
            "symmetric_difference": set_a.symmetric_difference(set_b),
            "is_subset": set_a.is_subset(set_b),
            "is_superset": set_a.is_superset(set_b),
            "is_disjoint": set_a.is_disjoint(set_b),
            "cardinality_a": set_a.cardinality(),
            "cardinality_b": set_b.cardinality(),
            "power_set_a": set_a.power_set(),
            "power_set_b": set_b.power_set()
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_set_theory():
    """æ¼”ç¤ºé›†åˆè®ºç†è®º"""
    
    # åˆ›å»ºé›†åˆè®ºæ¡†æ¶
    set_theory = SetTheory()
    
    # æ·»åŠ å…¬ç†
    set_theory.add_axiom(SetAxiom(
        name="å¤–å»¶å…¬ç†",
        formal_expression="âˆ€xâˆ€y[âˆ€z(zâˆˆxâ†”zâˆˆy)â†’x=y]",
        description="ä¸¤ä¸ªé›†åˆç›¸ç­‰å½“ä¸”ä»…å½“å®ƒä»¬åŒ…å«ç›¸åŒçš„å…ƒç´ ",
        python_implementation="set_a == set_b if set_a.elements == set_b.elements"
    ))
    
    set_theory.add_axiom(SetAxiom(
        name="ç©ºé›†å…¬ç†",
        formal_expression="âˆƒxâˆ€y(yâˆ‰x)",
        description="å­˜åœ¨ä¸€ä¸ªä¸åŒ…å«ä»»ä½•å…ƒç´ çš„é›†åˆ",
        python_implementation="empty_set = MathematicalSet()"
    ))
    
    # åˆ›å»ºç¤ºä¾‹é›†åˆ
    set_a = MathematicalSet({1, 2, 3, 4, 5})
    set_b = MathematicalSet({4, 5, 6, 7, 8})
    set_c = MathematicalSet({1, 3, 5, 7, 9})
    
    # è®¾ç½®å…¨é›†
    universal_set = MathematicalSet({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
    set_theory.set_universal_set(universal_set)
    
    # ç”Ÿæˆè¿ç®—è¡¨
    operations_table = set_theory.generate_set_operations_table(set_a, set_b)
    
    print("=== é›†åˆè®ºè¿ç®—è¡¨ ===")
    print(f"é›†åˆA: {set_a}")
    print(f"é›†åˆB: {set_b}")
    print(f"å¹¶é›† AâˆªB: {operations_table['union']}")
    print(f"äº¤é›† Aâˆ©B: {operations_table['intersection']}")
    print(f"å·®é›† A-B: {operations_table['difference_a_b']}")
    print(f"å·®é›† B-A: {operations_table['difference_b_a']}")
    print(f"å¯¹ç§°å·®é›† Aâ–³B: {operations_table['symmetric_difference']}")
    print(f"Aæ˜¯Bçš„å­é›†: {operations_table['is_subset']}")
    print(f"Aæ˜¯Bçš„è¶…é›†: {operations_table['is_superset']}")
    print(f"Aä¸Bä¸ç›¸äº¤: {operations_table['is_disjoint']}")
    print(f"Açš„åŸºæ•°: {operations_table['cardinality_a']}")
    print(f"Bçš„åŸºæ•°: {operations_table['cardinality_b']}")
    
    # å¾·æ‘©æ ¹å®šå¾‹éªŒè¯
    de_morgan_result = set_theory.de_morgan_law(set_a, set_b)
    print("\n=== å¾·æ‘©æ ¹å®šå¾‹éªŒè¯ ===")
    for law_name, law_result in de_morgan_result.items():
        print(f"{law_name}: {law_result['statement']}")
        print(f"éªŒè¯ç»“æœ: {law_result['verified']}")
    
    # åˆ†é…å¾‹éªŒè¯
    distributive_result = set_theory.distributive_law(set_a, set_b, set_c)
    print("\n=== åˆ†é…å¾‹éªŒè¯ ===")
    for law_name, law_result in distributive_result.items():
        print(f"{law_name}: {law_result['statement']}")
        print(f"éªŒè¯ç»“æœ: {law_result['verified']}")
    
    return operations_table

if __name__ == "__main__":
    # è¿è¡Œæ¼”ç¤º
    result = demonstrate_set_theory()
```

## ğŸ“Š ç†è®ºè¯æ˜

### 1. å¾·æ‘©æ ¹å®šå¾‹è¯æ˜

**å®šç†**: å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œæœ‰ï¼š
1. $(A \cup B)' = A' \cap B'$
2. $(A \cap B)' = A' \cup B'$

**è¯æ˜**:
1. å¯¹äºç¬¬ä¸€ä¸ªç­‰å¼ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜ $(A \cup B)' \subseteq A' \cap B'$ å’Œ $A' \cap B' \subseteq (A \cup B)'$
2. è®¾ $x \in (A \cup B)'$ï¼Œåˆ™ $x \notin A \cup B$
3. å› æ­¤ $x \notin A$ ä¸” $x \notin B$
4. æ‰€ä»¥ $x \in A'$ ä¸” $x \in B'$
5. å› æ­¤ $x \in A' \cap B'$
6. ç±»ä¼¼åœ°å¯ä»¥è¯æ˜åå‘åŒ…å«å…³ç³»

### 2. åˆ†é…å¾‹è¯æ˜

**å®šç†**: å¯¹äºä»»æ„é›†åˆ $A$ã€$B$ å’Œ $C$ï¼Œæœ‰ï¼š
1. $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$
2. $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$

**è¯æ˜**:
1. å¯¹äºç¬¬ä¸€ä¸ªç­‰å¼ï¼Œè®¾ $x \in A \cap (B \cup C)$
2. åˆ™ $x \in A$ ä¸” $x \in B \cup C$
3. å› æ­¤ $x \in A$ ä¸” ($x \in B$ æˆ– $x \in C$)
4. æ‰€ä»¥ ($x \in A$ ä¸” $x \in B$) æˆ– ($x \in A$ ä¸” $x \in C$)
5. å› æ­¤ $x \in (A \cap B) \cup (A \cap C)$

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [é€»è¾‘å­¦åŸºç¡€](../01-02-é€»è¾‘å­¦/01-02-01-å‘½é¢˜é€»è¾‘.md)
- [å›¾è®ºåŸºç¡€](../01-04-å›¾è®º/01-04-01-å›¾è®ºåŸºç¡€.md)
- [ç®—æ³•ç†è®º](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md)
- [æ•°æ®ç»“æ„ç†è®º](../../02-ç†è®ºåŸºç¡€/02-02-æ•°æ®ç»“æ„ç†è®º/02-02-01-æ•°æ®ç»“æ„åŸºç¡€.md)

## ğŸ“ˆ åº”ç”¨å®ä¾‹

### 1. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```python
class DatabaseQueryOptimizer:
    """æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.tables = {}
        self.indexes = {}
    
    def add_table(self, table_name: str, columns: Set[str]):
        """æ·»åŠ è¡¨"""
        self.tables[table_name] = MathematicalSet(columns)
    
    def add_index(self, table_name: str, indexed_columns: Set[str]):
        """æ·»åŠ ç´¢å¼•"""
        if table_name not in self.indexes:
            self.indexes[table_name] = []
        self.indexes[table_name].append(MathematicalSet(indexed_columns))
    
    def optimize_join_order(self, tables: List[str], join_conditions: List[Dict[str, str]]) -> List[str]:
        """ä¼˜åŒ–è¿æ¥é¡ºåº"""
        # ä½¿ç”¨é›†åˆè®ºåˆ†æè¿æ¥å…³ç³»
        table_set = MathematicalSet(set(tables))
        
        # åˆ†æè¿æ¥å›¾
        join_graph = {}
        for condition in join_conditions:
            left_table = condition['left_table']
            right_table = condition['right_table']
            
            if left_table not in join_graph:
                join_graph[left_table] = MathematicalSet()
            if right_table not in join_graph:
                join_graph[right_table] = MathematicalSet()
            
            join_graph[left_table].add(right_table)
            join_graph[right_table].add(left_table)
        
        # ä½¿ç”¨è´ªå¿ƒç®—æ³•é€‰æ‹©è¿æ¥é¡ºåº
        optimized_order = []
        remaining_tables = MathematicalSet(set(tables))
        
        while not remaining_tables.is_empty():
            # é€‰æ‹©å…·æœ‰æœ€å¤šè¿æ¥çš„è¡¨
            best_table = None
            max_connections = -1
            
            for table in remaining_tables:
                if table in join_graph:
                    connections = join_graph[table].intersection(remaining_tables).cardinality()
                    if connections > max_connections:
                        max_connections = connections
                        best_table = table
            
            if best_table is None:
                best_table = list(remaining_tables.elements)[0]
            
            optimized_order.append(best_table)
            remaining_tables.remove(best_table)
        
        return optimized_order
    
    def analyze_query_plan(self, query: str) -> Dict[str, Any]:
        """åˆ†ææŸ¥è¯¢è®¡åˆ’"""
        # ç®€åŒ–çš„æŸ¥è¯¢åˆ†æ
        return {
            "query": query,
            "estimated_cost": 100,
            "optimization_suggestions": [
                "æ·»åŠ ç´¢å¼•",
                "é‡å†™æŸ¥è¯¢",
                "ä½¿ç”¨è¿æ¥æç¤º"
            ],
            "set_operations_used": [
                "äº¤é›† (JOIN)",
                "å¹¶é›† (UNION)",
                "å·®é›† (EXCEPT)"
            ]
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_database_optimization():
    """æ¼”ç¤ºæ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–"""
    
    optimizer = DatabaseQueryOptimizer()
    
    # æ·»åŠ è¡¨
    optimizer.add_table("users", {"id", "name", "email", "created_at"})
    optimizer.add_table("orders", {"id", "user_id", "amount", "status"})
    optimizer.add_table("products", {"id", "name", "price", "category"})
    
    # æ·»åŠ ç´¢å¼•
    optimizer.add_index("users", {"id", "email"})
    optimizer.add_index("orders", {"user_id", "status"})
    optimizer.add_index("products", {"category", "price"})
    
    # ä¼˜åŒ–è¿æ¥é¡ºåº
    tables = ["users", "orders", "products"]
    join_conditions = [
        {"left_table": "users", "right_table": "orders"},
        {"left_table": "orders", "right_table": "products"}
    ]
    
    optimized_order = optimizer.optimize_join_order(tables, join_conditions)
    
    print("=== æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ– ===")
    print(f"åŸå§‹è¡¨é¡ºåº: {tables}")
    print(f"ä¼˜åŒ–åé¡ºåº: {optimized_order}")
    
    # åˆ†ææŸ¥è¯¢è®¡åˆ’
    query = "SELECT u.name, o.amount FROM users u JOIN orders o ON u.id = o.user_id"
    plan = optimizer.analyze_query_plan(query)
    
    print("\n=== æŸ¥è¯¢è®¡åˆ’åˆ†æ ===")
    print(f"æŸ¥è¯¢: {plan['query']}")
    print(f"ä¼°ç®—æˆæœ¬: {plan['estimated_cost']}")
    print(f"ä¼˜åŒ–å»ºè®®: {plan['optimization_suggestions']}")
    print(f"ä½¿ç”¨çš„é›†åˆè¿ç®—: {plan['set_operations_used']}")

if __name__ == "__main__":
    demonstrate_database_optimization()
```

### 2. é›†åˆè¿ç®—æ€§èƒ½åˆ†æ

```python
import time
import random
from typing import List, Tuple

class SetPerformanceAnalyzer:
    """é›†åˆè¿ç®—æ€§èƒ½åˆ†æå™¨"""
    
    def __init__(self):
        self.results = {}
    
    def generate_test_sets(self, size: int) -> Tuple[MathematicalSet, MathematicalSet]:
        """ç”Ÿæˆæµ‹è¯•é›†åˆ"""
        elements = set(range(size * 2))
        set_a_elements = set(random.sample(list(elements), size))
        set_b_elements = set(random.sample(list(elements), size))
        
        return MathematicalSet(set_a_elements), MathematicalSet(set_b_elements)
    
    def measure_operation_performance(self, operation: Callable, set_a: MathematicalSet, set_b: MathematicalSet, iterations: int = 1000) -> float:
        """æµ‹é‡è¿ç®—æ€§èƒ½"""
        start_time = time.time()
        
        for _ in range(iterations):
            result = operation(set_a, set_b)
        
        end_time = time.time()
        return (end_time - start_time) / iterations
    
    def analyze_set_operations(self, sizes: List[int]) -> Dict[str, List[float]]:
        """åˆ†æé›†åˆè¿ç®—æ€§èƒ½"""
        operations = {
            "union": lambda a, b: a.union(b),
            "intersection": lambda a, b: a.intersection(b),
            "difference": lambda a, b: a.difference(b),
            "symmetric_difference": lambda a, b: a.symmetric_difference(b)
        }
        
        results = {op_name: [] for op_name in operations.keys()}
        
        for size in sizes:
            set_a, set_b = self.generate_test_sets(size)
            
            for op_name, operation in operations.items():
                performance = self.measure_operation_performance(operation, set_a, set_b)
                results[op_name].append(performance)
        
        return results
    
    def generate_performance_report(self, sizes: List[int]) -> Dict[str, Any]:
        """ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š"""
        results = self.analyze_set_operations(sizes)
        
        report = {
            "test_sizes": sizes,
            "performance_results": results,
            "analysis": {}
        }
        
        # åˆ†ææ€§èƒ½è¶‹åŠ¿
        for op_name, performances in results.items():
            avg_performance = sum(performances) / len(performances)
            max_performance = max(performances)
            min_performance = min(performances)
            
            report["analysis"][op_name] = {
                "average_time": avg_performance,
                "max_time": max_performance,
                "min_time": min_performance,
                "complexity": "O(n)" if "union" in op_name or "intersection" in op_name else "O(n)"
            }
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_set_performance():
    """æ¼”ç¤ºé›†åˆè¿ç®—æ€§èƒ½åˆ†æ"""
    
    analyzer = SetPerformanceAnalyzer()
    
    # æµ‹è¯•ä¸åŒå¤§å°çš„é›†åˆ
    sizes = [100, 500, 1000, 5000, 10000]
    
    # ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    report = analyzer.generate_performance_report(sizes)
    
    print("=== é›†åˆè¿ç®—æ€§èƒ½åˆ†æ ===")
    print(f"æµ‹è¯•é›†åˆå¤§å°: {report['test_sizes']}")
    
    print("\n=== æ€§èƒ½ç»“æœ ===")
    for op_name, performances in report['performance_results'].items():
        print(f"{op_name}:")
        for i, size in enumerate(sizes):
            print(f"  å¤§å° {size}: {performances[i]:.6f} ç§’")
    
    print("\n=== æ€§èƒ½åˆ†æ ===")
    for op_name, analysis in report['analysis'].items():
        print(f"{op_name}:")
        print(f"  å¹³å‡æ—¶é—´: {analysis['average_time']:.6f} ç§’")
        print(f"  æœ€å¤§æ—¶é—´: {analysis['max_time']:.6f} ç§’")
        print(f"  æœ€å°æ—¶é—´: {analysis['min_time']:.6f} ç§’")
        print(f"  å¤æ‚åº¦: {analysis['complexity']}")

if __name__ == "__main__":
    demonstrate_set_performance()
```

## ğŸ¯ æ€»ç»“

é›†åˆè®ºä¸ºè®¡ç®—æœºç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚é€šè¿‡å½¢å¼åŒ–å®šä¹‰ã€å¤šè¡¨å¾æ–¹å¼å’Œå®é™…åº”ç”¨ï¼Œæˆ‘ä»¬å»ºç«‹äº†å®Œæ•´çš„é›†åˆè®ºä½“ç³»ï¼Œä¸ºç®—æ³•è®¾è®¡ã€æ•°æ®ç»“æ„å®ç°å’Œç³»ç»Ÿå»ºæ¨¡æä¾›äº†æŒ‡å¯¼ã€‚

### å…³é”®è¦ç‚¹

1. **å½¢å¼åŒ–å®šä¹‰**: é›†åˆå¯ä»¥ç”¨å››å…ƒç»„ $\mathcal{S} = (U, R, F, O)$ è¡¨ç¤º
2. **å…¬ç†ç³»ç»Ÿ**: åŸºäºå¤–å»¶å…¬ç†ã€ç©ºé›†å…¬ç†ç­‰åŸºæœ¬å…¬ç†
3. **å¤šè¡¨å¾æ–¹å¼**: åŒ…å«æ¦‚å¿µè§£é‡Šã€æ•°å­¦å½¢å¼ã€ä»£ç å®ç°ã€å›¾è¡¨è¯´æ˜å’Œå®ä¾‹åˆ†æ
4. **å®é™…åº”ç”¨**: é€šè¿‡Pythonå®ç°éªŒè¯ç†è®ºæ¦‚å¿µ
5. **ç†è®ºè¯æ˜**: æä¾›å¾·æ‘©æ ¹å®šå¾‹å’Œåˆ†é…å¾‹çš„è¯æ˜

---

**ç›¸å…³æ–‡æ¡£**: 
- [æ•°è®ºåŸºç¡€](./01-01-02-æ•°è®ºåŸºç¡€.md)
- [ä»£æ•°åŸºç¡€](./01-01-03-ä»£æ•°åŸºç¡€.md)
- [é€»è¾‘å­¦åŸºç¡€](../01-02-é€»è¾‘å­¦/01-02-01-å‘½é¢˜é€»è¾‘.md)
- [å›¾è®ºåŸºç¡€](../01-04-å›¾è®º/01-04-01-å›¾è®ºåŸºç¡€.md) 