# é›†åˆè®ºåŸºç¡€

## ğŸ“š æ¦‚è¿°

é›†åˆè®ºæ˜¯ç°ä»£æ•°å­¦çš„åŸºç¡€ï¼Œä¸ºè®¡ç®—æœºç§‘å­¦å’Œç¼–ç¨‹è¯­è¨€æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼ç§‘å­¦çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»é›†åˆè®ºçš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆçš„åŸºæœ¬å®šä¹‰

#### 1.1 é›†åˆçš„æ•°å­¦å®šä¹‰

é›†åˆæ˜¯ä¸åŒå¯¹è±¡çš„æ— åºèšé›†ï¼Œç”¨å¤§å†™å­—æ¯è¡¨ç¤ºï¼š

$$A = \{a_1, a_2, \ldots, a_n\}$$

å…¶ä¸­ $a_i$ æ˜¯é›†åˆçš„å…ƒç´ ï¼Œ$a_i \in A$ è¡¨ç¤º $a_i$ å±äºé›†åˆ $A$ã€‚

#### 1.2 é›†åˆçš„Pythonå®ç°

```python
from typing import Set, Any, Iterator, Optional
from abc import ABC, abstractmethod
import math

class Set(ABC):
    """æŠ½è±¡é›†åˆåŸºç±»"""
    
    @abstractmethod
    def __contains__(self, item: Any) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        pass
    
    @abstractmethod
    def __len__(self) -> int:
        """è¿”å›é›†åˆçš„åŸºæ•°"""
        pass
    
    @abstractmethod
    def __iter__(self) -> Iterator[Any]:
        """è¿”å›é›†åˆçš„è¿­ä»£å™¨"""
        pass

class FiniteSet(Set):
    """æœ‰é™é›†åˆå®ç°"""
    
    def __init__(self, elements: set):
        self._elements = elements
    
    def __contains__(self, item: Any) -> bool:
        return item in self._elements
    
    def __len__(self) -> int:
        return len(self._elements)
    
    def __iter__(self) -> Iterator[Any]:
        return iter(self._elements)
    
    def __repr__(self) -> str:
        return f"FiniteSet({self._elements})"

# ä½¿ç”¨ç¤ºä¾‹
A = FiniteSet({1, 2, 3, 4, 5})
print(f"A = {A}")
print(f"3 âˆˆ A: {3 in A}")
print(f"|A| = {len(A)}")
```

### 2. é›†åˆè¿ç®—

#### 2.1 åŸºæœ¬è¿ç®—çš„æ•°å­¦å®šä¹‰

**å¹¶é›†**: $A \cup B = \{x | x \in A \text{ æˆ– } x \in B\}$

**äº¤é›†**: $A \cap B = \{x | x \in A \text{ ä¸” } x \in B\}$

**å·®é›†**: $A - B = \{x | x \in A \text{ ä¸” } x \notin B\}$

**è¡¥é›†**: $A^c = \{x | x \notin A\}$

#### 2.2 é›†åˆè¿ç®—çš„Pythonå®ç°

```python
class SetOperations:
    """é›†åˆè¿ç®—å®ç°"""
    
    @staticmethod
    def union(A: Set, B: Set) -> Set:
        """å¹¶é›†è¿ç®—"""
        if isinstance(A, FiniteSet) and isinstance(B, FiniteSet):
            return FiniteSet(A._elements | B._elements)
        else:
            # é€šç”¨å®ç°
            result_elements = set()
            for element in A:
                result_elements.add(element)
            for element in B:
                result_elements.add(element)
            return FiniteSet(result_elements)
    
    @staticmethod
    def intersection(A: Set, B: Set) -> Set:
        """äº¤é›†è¿ç®—"""
        if isinstance(A, FiniteSet) and isinstance(B, FiniteSet):
            return FiniteSet(A._elements & B._elements)
        else:
            # é€šç”¨å®ç°
            result_elements = set()
            for element in A:
                if element in B:
                    result_elements.add(element)
            return FiniteSet(result_elements)
    
    @staticmethod
    def difference(A: Set, B: Set) -> Set:
        """å·®é›†è¿ç®—"""
        if isinstance(A, FiniteSet) and isinstance(B, FiniteSet):
            return FiniteSet(A._elements - B._elements)
        else:
            # é€šç”¨å®ç°
            result_elements = set()
            for element in A:
                if element not in B:
                    result_elements.add(element)
            return FiniteSet(result_elements)
    
    @staticmethod
    def complement(A: Set, universal_set: Set) -> Set:
        """è¡¥é›†è¿ç®—"""
        return SetOperations.difference(universal_set, A)

# ä½¿ç”¨ç¤ºä¾‹
A = FiniteSet({1, 2, 3, 4})
B = FiniteSet({3, 4, 5, 6})
U = FiniteSet({1, 2, 3, 4, 5, 6, 7, 8})

print(f"A âˆª B = {SetOperations.union(A, B)}")
print(f"A âˆ© B = {SetOperations.intersection(A, B)}")
print(f"A - B = {SetOperations.difference(A, B)}")
print(f"A^c = {SetOperations.complement(A, U)}")
```

### 3. é›†åˆå…³ç³»

#### 3.1 åŒ…å«å…³ç³»çš„æ•°å­¦å®šä¹‰

**å­é›†**: $A \subseteq B \iff \forall x (x \in A \rightarrow x \in B)$

**çœŸå­é›†**: $A \subset B \iff A \subseteq B \land A \neq B$

**ç›¸ç­‰**: $A = B \iff A \subseteq B \land B \subseteq A$

#### 3.2 é›†åˆå…³ç³»çš„Pythonå®ç°

```python
class SetRelations:
    """é›†åˆå…³ç³»åˆ¤æ–­"""
    
    @staticmethod
    def is_subset(A: Set, B: Set) -> bool:
        """åˆ¤æ–­Aæ˜¯å¦ä¸ºBçš„å­é›†"""
        for element in A:
            if element not in B:
                return False
        return True
    
    @staticmethod
    def is_proper_subset(A: Set, B: Set) -> bool:
        """åˆ¤æ–­Aæ˜¯å¦ä¸ºBçš„çœŸå­é›†"""
        return SetRelations.is_subset(A, B) and len(A) < len(B)
    
    @staticmethod
    def is_equal(A: Set, B: Set) -> bool:
        """åˆ¤æ–­ä¸¤ä¸ªé›†åˆæ˜¯å¦ç›¸ç­‰"""
        return SetRelations.is_subset(A, B) and SetRelations.is_subset(B, A)
    
    @staticmethod
    def is_disjoint(A: Set, B: Set) -> bool:
        """åˆ¤æ–­ä¸¤ä¸ªé›†åˆæ˜¯å¦ä¸ç›¸äº¤"""
        for element in A:
            if element in B:
                return False
        return True

# ä½¿ç”¨ç¤ºä¾‹
A = FiniteSet({1, 2})
B = FiniteSet({1, 2, 3, 4})
C = FiniteSet({1, 2})

print(f"A âŠ† B: {SetRelations.is_subset(A, B)}")
print(f"A âŠ‚ B: {SetRelations.is_proper_subset(A, B)}")
print(f"A = C: {SetRelations.is_equal(A, C)}")
```

### 4. ç¬›å¡å°”ç§¯

#### 4.1 ç¬›å¡å°”ç§¯çš„æ•°å­¦å®šä¹‰

ä¸¤ä¸ªé›†åˆ $A$ å’Œ $B$ çš„ç¬›å¡å°”ç§¯å®šä¹‰ä¸ºï¼š

$$A \times B = \{(a, b) | a \in A \land b \in B\}$$

#### 4.2 ç¬›å¡å°”ç§¯çš„Pythonå®ç°

```python
from typing import Tuple

class CartesianProduct:
    """ç¬›å¡å°”ç§¯å®ç°"""
    
    @staticmethod
    def product(A: Set, B: Set) -> Set:
        """è®¡ç®—ä¸¤ä¸ªé›†åˆçš„ç¬›å¡å°”ç§¯"""
        result_elements = set()
        for a in A:
            for b in B:
                result_elements.add((a, b))
        return FiniteSet(result_elements)
    
    @staticmethod
    def power(A: Set, n: int) -> Set:
        """è®¡ç®—é›†åˆçš„næ¬¡å¹‚"""
        if n == 0:
            return FiniteSet({()})
        elif n == 1:
            return A
        else:
            result = A
            for _ in range(n - 1):
                result = CartesianProduct.product(result, A)
            return result

# ä½¿ç”¨ç¤ºä¾‹
A = FiniteSet({'a', 'b'})
B = FiniteSet({1, 2})

print(f"A Ã— B = {CartesianProduct.product(A, B)}")
print(f"AÂ² = {CartesianProduct.power(A, 2)}")
```

### 5. é›†åˆçš„åŸºæ•°

#### 5.1 åŸºæ•°çš„æ•°å­¦å®šä¹‰

é›†åˆ $A$ çš„åŸºæ•°ï¼ˆåŠ¿ï¼‰è®°ä½œ $|A|$ï¼Œè¡¨ç¤ºé›†åˆä¸­å…ƒç´ çš„ä¸ªæ•°ã€‚

å¯¹äºæœ‰é™é›†åˆï¼š$|A| = n$ï¼Œå…¶ä¸­ $n$ æ˜¯è‡ªç„¶æ•°ã€‚

#### 5.2 åŸºæ•°çš„Pythonå®ç°

```python
class SetCardinality:
    """é›†åˆåŸºæ•°è®¡ç®—"""
    
    @staticmethod
    def cardinality(A: Set) -> int:
        """è®¡ç®—é›†åˆçš„åŸºæ•°"""
        return len(A)
    
    @staticmethod
    def power_set_cardinality(A: Set) -> int:
        """è®¡ç®—å¹‚é›†çš„åŸºæ•°"""
        return 2 ** len(A)
    
    @staticmethod
    def cartesian_product_cardinality(A: Set, B: Set) -> int:
        """è®¡ç®—ç¬›å¡å°”ç§¯çš„åŸºæ•°"""
        return len(A) * len(B)

# ä½¿ç”¨ç¤ºä¾‹
A = FiniteSet({1, 2, 3, 4, 5})
print(f"|A| = {SetCardinality.cardinality(A)}")
print(f"|P(A)| = {SetCardinality.power_set_cardinality(A)}")
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. å¾·æ‘©æ ¹å®šå¾‹

**å®šç†**: å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œæœ‰ï¼š

$$(A \cup B)^c = A^c \cap B^c$$
$$(A \cap B)^c = A^c \cup B^c$$

**è¯æ˜**:

è®¾ $x \in (A \cup B)^c$ï¼Œåˆ™ $x \notin A \cup B$ï¼Œå³ $x \notin A$ ä¸” $x \notin B$ã€‚
å› æ­¤ $x \in A^c$ ä¸” $x \in B^c$ï¼Œæ‰€ä»¥ $x \in A^c \cap B^c$ã€‚

åä¹‹ï¼Œè®¾ $x \in A^c \cap B^c$ï¼Œåˆ™ $x \in A^c$ ä¸” $x \in B^c$ï¼Œå³ $x \notin A$ ä¸” $x \notin B$ã€‚
å› æ­¤ $x \notin A \cup B$ï¼Œæ‰€ä»¥ $x \in (A \cup B)^c$ã€‚

### 2. åˆ†é…å¾‹

**å®šç†**: å¯¹äºä»»æ„é›†åˆ $A$ã€$B$ å’Œ $C$ï¼Œæœ‰ï¼š

$$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$$
$$A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$$

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```python
class DatabaseQuery:
    """æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–ç¤ºä¾‹"""
    
    def __init__(self):
        self.users = FiniteSet({'Alice', 'Bob', 'Charlie', 'David'})
        self.admins = FiniteSet({'Alice', 'Bob'})
        self.moderators = FiniteSet({'Bob', 'Charlie'})
    
    def get_admin_moderators(self) -> Set:
        """è·å–æ—¢æ˜¯ç®¡ç†å‘˜åˆæ˜¯ç‰ˆä¸»çš„ç”¨æˆ·"""
        return SetOperations.intersection(self.admins, self.moderators)
    
    def get_all_privileged_users(self) -> Set:
        """è·å–æ‰€æœ‰æœ‰æƒé™çš„ç”¨æˆ·"""
        return SetOperations.union(self.admins, self.moderators)
    
    def get_regular_users(self) -> Set:
        """è·å–æ™®é€šç”¨æˆ·"""
        return SetOperations.difference(self.users, self.admins)

# ä½¿ç”¨ç¤ºä¾‹
db = DatabaseQuery()
print(f"ç®¡ç†å‘˜å…¼ç‰ˆä¸»: {db.get_admin_moderators()}")
print(f"æ‰€æœ‰æƒé™ç”¨æˆ·: {db.get_all_privileged_users()}")
print(f"æ™®é€šç”¨æˆ·: {db.get_regular_users()}")
```

### 2. å›¾è®ºä¸­çš„é‚»æ¥å…³ç³»

```python
class GraphTheory:
    """å›¾è®ºä¸­çš„é›†åˆåº”ç”¨"""
    
    def __init__(self):
        self.vertices = FiniteSet({'A', 'B', 'C', 'D'})
        self.edges = FiniteSet({('A', 'B'), ('B', 'C'), ('C', 'D'), ('A', 'D')})
    
    def get_neighbors(self, vertex: str) -> Set:
        """è·å–é¡¶ç‚¹çš„é‚»å±…"""
        neighbors = set()
        for edge in self.edges:
            if edge[0] == vertex:
                neighbors.add(edge[1])
            elif edge[1] == vertex:
                neighbors.add(edge[0])
        return FiniteSet(neighbors)
    
    def get_common_neighbors(self, v1: str, v2: str) -> Set:
        """è·å–ä¸¤ä¸ªé¡¶ç‚¹çš„å…±åŒé‚»å±…"""
        neighbors1 = self.get_neighbors(v1)
        neighbors2 = self.get_neighbors(v2)
        return SetOperations.intersection(neighbors1, neighbors2)

# ä½¿ç”¨ç¤ºä¾‹
graph = GraphTheory()
print(f"Bçš„é‚»å±…: {graph.get_neighbors('B')}")
print(f"Aå’ŒCçš„å…±åŒé‚»å±…: {graph.get_common_neighbors('A', 'C')}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [æ•°å­¦åŸºç¡€æ¦‚è¿°](../README.md)
- [æ•°è®ºåŸºç¡€](01-01-02-æ•°è®ºåŸºç¡€.md)
- [ä»£æ•°åŸºç¡€](01-01-03-ä»£æ•°åŸºç¡€.md)
- [é€»è¾‘å­¦åŸºç¡€](../01-02-é€»è¾‘å­¦/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Halmos, P. R. (1960). Naive Set Theory. Springer-Verlag.
2. Enderton, H. B. (1977). Elements of Set Theory. Academic Press.
3. Jech, T. (2003). Set Theory. Springer-Verlag.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
