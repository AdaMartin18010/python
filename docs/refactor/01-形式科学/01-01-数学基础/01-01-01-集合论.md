# 01-01-01 é›†åˆè®º

## ğŸ“‹ æ¦‚è¿°

é›†åˆè®ºæ˜¯æ•°å­¦çš„åŸºç¡€ç†è®ºï¼Œä¸ºè½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦æä¾›äº†é‡è¦çš„æ•°å­¦å·¥å…·ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°é›†åˆè®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œæä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜ï¼Œå¹¶é€šè¿‡Pythonä»£ç å®ç°ç›¸å…³æ¦‚å¿µã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆçš„åŸºæœ¬æ¦‚å¿µ

#### 1.1 é›†åˆçš„å®šä¹‰

**å®šä¹‰ 1.1** (é›†åˆ)
é›†åˆæ˜¯ä¸€ä¸ªæ— åºçš„ã€ä¸é‡å¤çš„å…ƒç´ é›†åˆã€‚é›†åˆ $A$ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$A = \{x \mid P(x)\}$$
å…¶ä¸­ $P(x)$ æ˜¯å…ƒç´  $x$ æ»¡è¶³çš„æ€§è´¨ã€‚

**å®šä¹‰ 1.2** (é›†åˆç›¸ç­‰)
ä¸¤ä¸ªé›†åˆ $A$ å’Œ $B$ ç›¸ç­‰ï¼Œå½“ä¸”ä»…å½“ï¼š
$$A = B \Leftrightarrow \forall x (x \in A \Leftrightarrow x \in B)$$

**å®šä¹‰ 1.3** (å­é›†)
é›†åˆ $A$ æ˜¯é›†åˆ $B$ çš„å­é›†ï¼Œè®°ä½œ $A \subseteq B$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$A \subseteq B \Leftrightarrow \forall x (x \in A \Rightarrow x \in B)$$

#### 1.2 é›†åˆè¿ç®—

**å®šä¹‰ 1.4** (å¹¶é›†)
é›†åˆ $A$ å’Œ $B$ çš„å¹¶é›†å®šä¹‰ä¸ºï¼š
$$A \cup B = \{x \mid x \in A \lor x \in B\}$$

**å®šä¹‰ 1.5** (äº¤é›†)
é›†åˆ $A$ å’Œ $B$ çš„äº¤é›†å®šä¹‰ä¸ºï¼š
$$A \cap B = \{x \mid x \in A \land x \in B\}$$

**å®šä¹‰ 1.6** (å·®é›†)
é›†åˆ $A$ å’Œ $B$ çš„å·®é›†å®šä¹‰ä¸ºï¼š
$$A \setminus B = \{x \mid x \in A \land x \notin B\}$$

**å®šä¹‰ 1.7** (è¡¥é›†)
é›†åˆ $A$ åœ¨å…¨é›† $U$ ä¸­çš„è¡¥é›†å®šä¹‰ä¸ºï¼š
$$A^c = U \setminus A = \{x \mid x \in U \land x \notin A\}$$

### 2. é›†åˆçš„åŸºæ•°

#### 2.1 æœ‰é™é›†å’Œæ— é™é›†

**å®šä¹‰ 2.1** (æœ‰é™é›†)
é›†åˆ $A$ æ˜¯æœ‰é™é›†ï¼Œå¦‚æœå­˜åœ¨è‡ªç„¶æ•° $n$ ä½¿å¾— $A$ ä¸ $\{1, 2, \ldots, n\}$ ä¹‹é—´å­˜åœ¨åŒå°„ã€‚

**å®šä¹‰ 2.2** (æ— é™é›†)
é›†åˆ $A$ æ˜¯æ— é™é›†ï¼Œå¦‚æœå®ƒä¸æ˜¯æœ‰é™é›†ã€‚

**å®šä¹‰ 2.3** (å¯æ•°é›†)
é›†åˆ $A$ æ˜¯å¯æ•°é›†ï¼Œå¦‚æœå®ƒä¸è‡ªç„¶æ•°é›† $\mathbb{N}$ ä¹‹é—´å­˜åœ¨åŒå°„ã€‚

#### 2.2 åŸºæ•°æ¯”è¾ƒ

**å®šä¹‰ 2.4** (åŸºæ•°)
é›†åˆ $A$ çš„åŸºæ•° $|A|$ æ˜¯è¡¡é‡é›†åˆå¤§å°çš„é‡ã€‚

**å®šç† 2.1** (åŸºæ•°æ¯”è¾ƒ)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼š

1. å¦‚æœå­˜åœ¨ $A$ åˆ° $B$ çš„å•å°„ï¼Œåˆ™ $|A| \leq |B|$
2. å¦‚æœå­˜åœ¨ $A$ åˆ° $B$ çš„åŒå°„ï¼Œåˆ™ $|A| = |B|$

### 3. ç¬›å¡å°”ç§¯å’Œå…³ç³»

#### 3.1 ç¬›å¡å°”ç§¯

**å®šä¹‰ 3.1** (ç¬›å¡å°”ç§¯)
é›†åˆ $A$ å’Œ $B$ çš„ç¬›å¡å°”ç§¯å®šä¹‰ä¸ºï¼š
$$A \times B = \{(a, b) \mid a \in A \land b \in B\}$$

**å®šä¹‰ 3.2** (nå…ƒç¬›å¡å°”ç§¯)
é›†åˆ $A_1, A_2, \ldots, A_n$ çš„nå…ƒç¬›å¡å°”ç§¯å®šä¹‰ä¸ºï¼š
$$A_1 \times A_2 \times \cdots \times A_n = \{(a_1, a_2, \ldots, a_n) \mid a_i \in A_i, i = 1, 2, \ldots, n\}$$

#### 3.2 å…³ç³»

**å®šä¹‰ 3.3** (äºŒå…ƒå…³ç³»)
é›†åˆ $A$ å’Œ $B$ ä¹‹é—´çš„äºŒå…ƒå…³ç³» $R$ æ˜¯ $A \times B$ çš„å­é›†ï¼š
$$R \subseteq A \times B$$

**å®šä¹‰ 3.4** (ç­‰ä»·å…³ç³»)
é›†åˆ $A$ ä¸Šçš„å…³ç³» $R$ æ˜¯ç­‰ä»·å…³ç³»ï¼Œå¦‚æœæ»¡è¶³ï¼š

1. è‡ªåæ€§ï¼š$\forall x \in A, xRx$
2. å¯¹ç§°æ€§ï¼š$\forall x, y \in A, xRy \Rightarrow yRx$
3. ä¼ é€’æ€§ï¼š$\forall x, y, z \in A, xRy \land yRz \Rightarrow xRz$

## ğŸ Pythonå®ç°

### 1. é›†åˆç±»å®ç°

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Set, Tuple, Union, Iterator
from dataclasses import dataclass
import math

class Set(ABC):
    """é›†åˆæŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def contains(self, element: Any) -> bool:
        """åˆ¤æ–­å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        pass
    
    @abstractmethod
    def cardinality(self) -> int:
        """è¿”å›é›†åˆçš„åŸºæ•°"""
        pass
    
    @abstractmethod
    def elements(self) -> Iterator[Any]:
        """è¿”å›é›†åˆçš„æ‰€æœ‰å…ƒç´ """
        pass

class FiniteSet(Set):
    """æœ‰é™é›†å®ç°"""
    
    def __init__(self, elements: Set[Any]):
        self._elements = elements
    
    def contains(self, element: Any) -> bool:
        """åˆ¤æ–­å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        return element in self._elements
    
    def cardinality(self) -> int:
        """è¿”å›é›†åˆçš„åŸºæ•°"""
        return len(self._elements)
    
    def elements(self) -> Iterator[Any]:
        """è¿”å›é›†åˆçš„æ‰€æœ‰å…ƒç´ """
        return iter(self._elements)
    
    def union(self, other: 'FiniteSet') -> 'FiniteSet':
        """å¹¶é›†è¿ç®—"""
        return FiniteSet(self._elements.union(other._elements))
    
    def intersection(self, other: 'FiniteSet') -> 'FiniteSet':
        """äº¤é›†è¿ç®—"""
        return FiniteSet(self._elements.intersection(other._elements))
    
    def difference(self, other: 'FiniteSet') -> 'FiniteSet':
        """å·®é›†è¿ç®—"""
        return FiniteSet(self._elements.difference(other._elements))
    
    def complement(self, universe: 'FiniteSet') -> 'FiniteSet':
        """è¡¥é›†è¿ç®—"""
        return universe.difference(self)
    
    def is_subset(self, other: 'FiniteSet') -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå­é›†"""
        return self._elements.issubset(other._elements)
    
    def is_equal(self, other: 'FiniteSet') -> bool:
        """åˆ¤æ–­æ˜¯å¦ç›¸ç­‰"""
        return self._elements == other._elements
    
    def __str__(self) -> str:
        return f"{{{', '.join(map(str, self._elements))}}}"
    
    def __repr__(self) -> str:
        return f"FiniteSet({self._elements})"

class InfiniteSet(Set):
    """æ— é™é›†å®ç°"""
    
    def __init__(self, predicate: callable):
        self.predicate = predicate
    
    def contains(self, element: Any) -> bool:
        """åˆ¤æ–­å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        return self.predicate(element)
    
    def cardinality(self) -> int:
        """è¿”å›é›†åˆçš„åŸºæ•°"""
        return float('inf')
    
    def elements(self) -> Iterator[Any]:
        """è¿”å›é›†åˆçš„æ‰€æœ‰å…ƒç´ ï¼ˆå¯èƒ½æ— é™ï¼‰"""
        # æ³¨æ„ï¼šè¿™åªæ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œå®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
        raise NotImplementedError("æ— é™é›†æ— æ³•æšä¸¾æ‰€æœ‰å…ƒç´ ")

class CartesianProduct:
    """ç¬›å¡å°”ç§¯å®ç°"""
    
    def __init__(self, sets: List[Set]):
        self.sets = sets
    
    def elements(self) -> Iterator[Tuple]:
        """è¿”å›ç¬›å¡å°”ç§¯çš„æ‰€æœ‰å…ƒç´ """
        if not self.sets:
            yield ()
            return
        
        first_set = self.sets[0]
        remaining_sets = self.sets[1:]
        remaining_product = CartesianProduct(remaining_sets)
        
        for element in first_set.elements():
            for remaining_tuple in remaining_product.elements():
                yield (element,) + remaining_tuple
    
    def cardinality(self) -> int:
        """è¿”å›ç¬›å¡å°”ç§¯çš„åŸºæ•°"""
        if not self.sets:
            return 1
        
        result = 1
        for set_obj in self.sets:
            card = set_obj.cardinality()
            if card == float('inf'):
                return float('inf')
            result *= card
        return result

class Relation:
    """å…³ç³»å®ç°"""
    
    def __init__(self, domain: Set, codomain: Set, pairs: Set[Tuple]):
        self.domain = domain
        self.codomain = codomain
        self.pairs = pairs
    
    def contains(self, pair: Tuple) -> bool:
        """åˆ¤æ–­åºå¯¹æ˜¯å¦å±äºå…³ç³»"""
        return pair in self.pairs
    
    def domain_elements(self) -> Set:
        """è¿”å›å®šä¹‰åŸŸ"""
        return FiniteSet({pair[0] for pair in self.pairs})
    
    def range_elements(self) -> Set:
        """è¿”å›å€¼åŸŸ"""
        return FiniteSet({pair[1] for pair in self.pairs})
    
    def is_reflexive(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦è‡ªå"""
        for element in self.domain.elements():
            if not self.contains((element, element)):
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦å¯¹ç§°"""
        for pair in self.pairs:
            if not self.contains((pair[1], pair[0])):
                return False
        return True
    
    def is_transitive(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¼ é€’"""
        for pair1 in self.pairs:
            for pair2 in self.pairs:
                if pair1[1] == pair2[0]:
                    if not self.contains((pair1[0], pair2[1])):
                        return False
        return True
    
    def is_equivalence(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç­‰ä»·å…³ç³»"""
        return self.is_reflexive() and self.is_symmetric() and self.is_transitive()

class SetOperations:
    """é›†åˆè¿ç®—å·¥å…·ç±»"""
    
    @staticmethod
    def power_set(original_set: FiniteSet) -> FiniteSet:
        """å¹‚é›†è¿ç®—"""
        elements = list(original_set.elements())
        n = len(elements)
        power_set_elements = set()
        
        for i in range(2**n):
            subset = set()
            for j in range(n):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set_elements.add(frozenset(subset))
        
        return FiniteSet(power_set_elements)
    
    @staticmethod
    def cartesian_product_sets(set1: FiniteSet, set2: FiniteSet) -> FiniteSet:
        """ä¸¤ä¸ªæœ‰é™é›†çš„ç¬›å¡å°”ç§¯"""
        product_elements = set()
        for elem1 in set1.elements():
            for elem2 in set2.elements():
                product_elements.add((elem1, elem2))
        return FiniteSet(product_elements)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_set_theory():
    """æ¼”ç¤ºé›†åˆè®ºæ¦‚å¿µ"""
    
    # 1. åˆ›å»ºæœ‰é™é›†
    A = FiniteSet({1, 2, 3, 4, 5})
    B = FiniteSet({4, 5, 6, 7, 8})
    
    print(f"é›†åˆ A = {A}")
    print(f"é›†åˆ B = {B}")
    print(f"A çš„åŸºæ•°: {A.cardinality()}")
    print(f"B çš„åŸºæ•°: {B.cardinality()}")
    
    # 2. é›†åˆè¿ç®—
    union_AB = A.union(B)
    intersection_AB = A.intersection(B)
    difference_AB = A.difference(B)
    
    print(f"A âˆª B = {union_AB}")
    print(f"A âˆ© B = {intersection_AB}")
    print(f"A - B = {difference_AB}")
    
    # 3. å­é›†å…³ç³»
    C = FiniteSet({1, 2, 3})
    print(f"C = {C}")
    print(f"C æ˜¯ A çš„å­é›†: {C.is_subset(A)}")
    print(f"A æ˜¯ C çš„å­é›†: {A.is_subset(C)}")
    
    # 4. ç¬›å¡å°”ç§¯
    cartesian_product = SetOperations.cartesian_product_sets(C, FiniteSet({'a', 'b'}))
    print(f"C Ã— {{'a', 'b'}} = {cartesian_product}")
    
    # 5. å¹‚é›†
    power_set_C = SetOperations.power_set(C)
    print(f"P(C) = {power_set_C}")
    
    # 6. å…³ç³»
    relation_pairs = {(1, 1), (2, 2), (3, 3), (1, 2), (2, 1), (2, 3), (3, 2)}
    relation = Relation(C, C, relation_pairs)
    
    print(f"å…³ç³» R = {relation_pairs}")
    print(f"R æ˜¯è‡ªåçš„: {relation.is_reflexive()}")
    print(f"R æ˜¯å¯¹ç§°çš„: {relation.is_symmetric()}")
    print(f"R æ˜¯ä¼ é€’çš„: {relation.is_transitive()}")
    print(f"R æ˜¯ç­‰ä»·å…³ç³»: {relation.is_equivalence()}")
    
    return {
        "set_A": A,
        "set_B": B,
        "union": union_AB,
        "intersection": intersection_AB,
        "difference": difference_AB,
        "cartesian_product": cartesian_product,
        "power_set": power_set_C,
        "relation": relation
    }

if __name__ == "__main__":
    result = demonstrate_set_theory()
    print("\né›†åˆè®ºæ¼”ç¤ºå®Œæˆ!")
```

### 2. é›†åˆè®ºå®šç†è¯æ˜

```python
class SetTheoryProofs:
    """é›†åˆè®ºå®šç†è¯æ˜"""
    
    @staticmethod
    def prove_de_morgan_law(set_A: FiniteSet, set_B: FiniteSet, universe: FiniteSet) -> bool:
        """è¯æ˜å¾·æ‘©æ ¹å¾‹: (A âˆª B)^c = A^c âˆ© B^c"""
        
        # è®¡ç®—å·¦è¾¹: (A âˆª B)^c
        union_AB = set_A.union(set_B)
        left_side = union_AB.complement(universe)
        
        # è®¡ç®—å³è¾¹: A^c âˆ© B^c
        complement_A = set_A.complement(universe)
        complement_B = set_B.complement(universe)
        right_side = complement_A.intersection(complement_B)
        
        # éªŒè¯ç›¸ç­‰
        return left_side.is_equal(right_side)
    
    @staticmethod
    def prove_distributive_law(set_A: FiniteSet, set_B: FiniteSet, set_C: FiniteSet) -> bool:
        """è¯æ˜åˆ†é…å¾‹: A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)"""
        
        # è®¡ç®—å·¦è¾¹: A âˆ© (B âˆª C)
        union_BC = set_B.union(set_C)
        left_side = set_A.intersection(union_BC)
        
        # è®¡ç®—å³è¾¹: (A âˆ© B) âˆª (A âˆ© C)
        intersection_AB = set_A.intersection(set_B)
        intersection_AC = set_A.intersection(set_C)
        right_side = intersection_AB.union(intersection_AC)
        
        # éªŒè¯ç›¸ç­‰
        return left_side.is_equal(right_side)
    
    @staticmethod
    def prove_cartesian_product_cardinality(set_A: FiniteSet, set_B: FiniteSet) -> bool:
        """è¯æ˜ç¬›å¡å°”ç§¯åŸºæ•°: |A Ã— B| = |A| Ã— |B|"""
        
        cartesian_product = SetOperations.cartesian_product_sets(set_A, set_B)
        expected_cardinality = set_A.cardinality() * set_B.cardinality()
        actual_cardinality = cartesian_product.cardinality()
        
        return expected_cardinality == actual_cardinality
    
    @staticmethod
    def prove_power_set_cardinality(original_set: FiniteSet) -> bool:
        """è¯æ˜å¹‚é›†åŸºæ•°: |P(A)| = 2^|A|"""
        
        power_set = SetOperations.power_set(original_set)
        expected_cardinality = 2 ** original_set.cardinality()
        actual_cardinality = power_set.cardinality()
        
        return expected_cardinality == actual_cardinality

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_set_theory_proofs():
    """æ¼”ç¤ºé›†åˆè®ºå®šç†è¯æ˜"""
    
    # åˆ›å»ºæµ‹è¯•é›†åˆ
    universe = FiniteSet({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
    A = FiniteSet({1, 2, 3, 4})
    B = FiniteSet({3, 4, 5, 6})
    C = FiniteSet({5, 6, 7, 8})
    
    print("é›†åˆè®ºå®šç†è¯æ˜æ¼”ç¤º:")
    print(f"å…¨é›† U = {universe}")
    print(f"é›†åˆ A = {A}")
    print(f"é›†åˆ B = {B}")
    print(f"é›†åˆ C = {C}")
    print()
    
    # 1. å¾·æ‘©æ ¹å¾‹è¯æ˜
    de_morgan_result = SetTheoryProofs.prove_de_morgan_law(A, B, universe)
    print(f"å¾·æ‘©æ ¹å¾‹ (A âˆª B)^c = A^c âˆ© B^c: {de_morgan_result}")
    
    # 2. åˆ†é…å¾‹è¯æ˜
    distributive_result = SetTheoryProofs.prove_distributive_law(A, B, C)
    print(f"åˆ†é…å¾‹ A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C): {distributive_result}")
    
    # 3. ç¬›å¡å°”ç§¯åŸºæ•°è¯æ˜
    cartesian_result = SetTheoryProofs.prove_cartesian_product_cardinality(A, B)
    print(f"ç¬›å¡å°”ç§¯åŸºæ•° |A Ã— B| = |A| Ã— |B|: {cartesian_result}")
    
    # 4. å¹‚é›†åŸºæ•°è¯æ˜
    power_set_result = SetTheoryProofs.prove_power_set_cardinality(A)
    print(f"å¹‚é›†åŸºæ•° |P(A)| = 2^|A|: {power_set_result}")
    
    return {
        "de_morgan": de_morgan_result,
        "distributive": distributive_result,
        "cartesian": cartesian_result,
        "power_set": power_set_result
    }
```

## ğŸ“Š æ•°å­¦è¯æ˜

### 1. å¾·æ‘©æ ¹å¾‹è¯æ˜

**å®šç† 1.1** (å¾·æ‘©æ ¹å¾‹)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œä»¥åŠå…¨é›† $U$ï¼š
$$(A \cup B)^c = A^c \cap B^c$$

**è¯æ˜**:

1. è®¾ $x \in (A \cup B)^c$
2. åˆ™ $x \notin A \cup B$
3. å› æ­¤ $x \notin A$ ä¸” $x \notin B$
4. æ‰€ä»¥ $x \in A^c$ ä¸” $x \in B^c$
5. å› æ­¤ $x \in A^c \cap B^c$
6. åŒç†å¯è¯åå‘åŒ…å«å…³ç³»
7. æ‰€ä»¥ $(A \cup B)^c = A^c \cap B^c$

### 2. åˆ†é…å¾‹è¯æ˜

**å®šç† 1.2** (åˆ†é…å¾‹)
å¯¹äºä»»æ„é›†åˆ $A$ã€$B$ å’Œ $C$ï¼š
$$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$$

**è¯æ˜**:

1. è®¾ $x \in A \cap (B \cup C)$
2. åˆ™ $x \in A$ ä¸” $x \in B \cup C$
3. å› æ­¤ $x \in A$ ä¸” ($x \in B$ æˆ– $x \in C$)
4. æ‰€ä»¥ ($x \in A$ ä¸” $x \in B$) æˆ– ($x \in A$ ä¸” $x \in C$)
5. å› æ­¤ $x \in (A \cap B) \cup (A \cap C)$
6. åŒç†å¯è¯åå‘åŒ…å«å…³ç³»
7. æ‰€ä»¥ $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$

### 3. ç¬›å¡å°”ç§¯åŸºæ•°å®šç†

**å®šç† 1.3** (ç¬›å¡å°”ç§¯åŸºæ•°)
å¯¹äºæœ‰é™é›† $A$ å’Œ $B$ï¼š
$$|A \times B| = |A| \times |B|$$

**è¯æ˜**:

1. è®¾ $A = \{a_1, a_2, \ldots, a_m\}$ï¼Œ$B = \{b_1, b_2, \ldots, b_n\}$
2. åˆ™ $A \times B = \{(a_i, b_j) \mid 1 \leq i \leq m, 1 \leq j \leq n\}$
3. å¯¹äºæ¯ä¸ª $a_i \in A$ï¼Œæœ‰ $n$ ä¸ªä¸åŒçš„åºå¯¹ $(a_i, b_j)$
4. å› æ­¤æ€»å…±æœ‰ $m \times n$ ä¸ªåºå¯¹
5. æ‰€ä»¥ $|A \times B| = |A| \times |B|$

### 4. å¹‚é›†åŸºæ•°å®šç†

**å®šç† 1.4** (å¹‚é›†åŸºæ•°)
å¯¹äºæœ‰é™é›† $A$ï¼š
$$|P(A)| = 2^{|A|}$$

**è¯æ˜**:

1. è®¾ $A = \{a_1, a_2, \ldots, a_n\}$
2. å¯¹äºæ¯ä¸ªå­é›†ï¼Œæ¯ä¸ªå…ƒç´  $a_i$ è¦ä¹ˆå±äºè¯¥å­é›†ï¼Œè¦ä¹ˆä¸å±äº
3. å› æ­¤æ¯ä¸ªå­é›†å¯¹åº”ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„äºŒè¿›åˆ¶ä¸²
4. æ€»å…±æœ‰ $2^n$ ä¸ªä¸åŒçš„äºŒè¿›åˆ¶ä¸²
5. æ‰€ä»¥ $|P(A)| = 2^n = 2^{|A|}$

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [å…³ç³»ç†è®º](./01-01-02-å…³ç³»ç†è®º.md)
- [å‡½æ•°ç†è®º](./01-01-03-å‡½æ•°ç†è®º.md)
- [ç»„åˆæ•°å­¦](./01-01-04-ç»„åˆæ•°å­¦.md)
- [é€»è¾‘å­¦åŸºç¡€](../01-02-é€»è¾‘å­¦/01-02-01-å‘½é¢˜é€»è¾‘.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Halmos, P. R. (1974). Naive Set Theory
2. Enderton, H. B. (1977). Elements of Set Theory
3. Jech, T. (2003). Set Theory
4. Kunen, K. (2011). Set Theory: An Introduction to Independence Proofs

---

*é›†åˆè®ºä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†é‡è¦çš„æ•°å­¦åŸºç¡€ï¼Œé€šè¿‡ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜ï¼Œæˆ‘ä»¬å»ºç«‹äº†é›†åˆè¿ç®—çš„å®Œæ•´ç†è®ºä½“ç³»ã€‚*
