# 01-01-02 æ•°è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°è®ºæ˜¯ç ”ç©¶æ•´æ•°æ€§è´¨çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨è®¡ç®—æœºç§‘å­¦ä¸­æœ‰ç€å¹¿æ³›çš„åº”ç”¨ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰æ•°è®ºçš„åŸºæœ¬æ¦‚å¿µï¼Œå»ºç«‹æ•°è®ºçš„ç†è®ºæ¡†æ¶ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.1** (æ•´æ•°)
æ•´æ•°é›†åˆå®šä¹‰ä¸ºï¼š
$$\mathbb{Z} = \{\ldots, -2, -1, 0, 1, 2, \ldots\}$$

**å®šä¹‰ 1.2** (è‡ªç„¶æ•°)
è‡ªç„¶æ•°é›†åˆå®šä¹‰ä¸ºï¼š
$$\mathbb{N} = \{0, 1, 2, 3, \ldots\}$$

**å®šä¹‰ 1.3** (æ­£æ•´æ•°)
æ­£æ•´æ•°é›†åˆå®šä¹‰ä¸ºï¼š
$$\mathbb{N}^+ = \{1, 2, 3, \ldots\}$$

### 1.2 æ•´é™¤å…³ç³»

**å®šä¹‰ 1.4** (æ•´é™¤)
å¯¹äºæ•´æ•° $a, b$ï¼Œå¦‚æœå­˜åœ¨æ•´æ•° $k$ ä½¿å¾— $b = ka$ï¼Œåˆ™ç§° $a$ æ•´é™¤ $b$ï¼Œè®°ä½œ $a \mid b$ã€‚

**å®šä¹‰ 1.5** (æœ€å¤§å…¬çº¦æ•°)
æ•´æ•° $a, b$ çš„æœ€å¤§å…¬çº¦æ•°å®šä¹‰ä¸ºï¼š
$$\gcd(a, b) = \max\{d \in \mathbb{N}^+ \mid d \mid a \land d \mid b\}$$

**å®šä¹‰ 1.6** (æœ€å°å…¬å€æ•°)
æ•´æ•° $a, b$ çš„æœ€å°å…¬å€æ•°å®šä¹‰ä¸ºï¼š
$$\text{lcm}(a, b) = \min\{m \in \mathbb{N}^+ \mid a \mid m \land b \mid m\}$$

### 1.3 ç´ æ•°ç†è®º

**å®šä¹‰ 1.7** (ç´ æ•°)
å¤§äº1çš„è‡ªç„¶æ•° $p$ æ˜¯ç´ æ•°ï¼Œå½“ä¸”ä»…å½“ $p$ çš„æ­£å› å­åªæœ‰1å’Œ $p$ æœ¬èº«ã€‚

**å®šä¹‰ 1.8** (åˆæ•°)
å¤§äº1çš„è‡ªç„¶æ•° $n$ æ˜¯åˆæ•°ï¼Œå½“ä¸”ä»…å½“ $n$ ä¸æ˜¯ç´ æ•°ã€‚

**å®šä¹‰ 1.9** (äº’ç´ )
æ•´æ•° $a, b$ äº’ç´ ï¼Œå½“ä¸”ä»…å½“ $\gcd(a, b) = 1$ã€‚

### 1.4 åŒä½™ç†è®º

**å®šä¹‰ 1.10** (åŒä½™)
å¯¹äºæ•´æ•° $a, b, m$ï¼Œå¦‚æœ $m \mid (a - b)$ï¼Œåˆ™ç§° $a$ ä¸ $b$ æ¨¡ $m$ åŒä½™ï¼Œè®°ä½œï¼š
$$a \equiv b \pmod{m}$$

**å®šä¹‰ 1.11** (å®Œå…¨å‰©ä½™ç³»)
æ¨¡ $m$ çš„å®Œå…¨å‰©ä½™ç³»æ˜¯ $m$ ä¸ªæ•´æ•°ï¼Œå®ƒä»¬æ¨¡ $m$ çš„ä½™æ•°å„ä¸ç›¸åŒã€‚

**å®šä¹‰ 1.12** (ç®€åŒ–å‰©ä½™ç³»)
æ¨¡ $m$ çš„ç®€åŒ–å‰©ä½™ç³»æ˜¯ä¸ $m$ äº’ç´ çš„å®Œå…¨å‰©ä½™ç³»ã€‚

## 2. é‡è¦å®šç†

### 2.1 ç®—æœ¯åŸºæœ¬å®šç†

**å®šç† 2.1** (ç®—æœ¯åŸºæœ¬å®šç†)
æ¯ä¸ªå¤§äº1çš„è‡ªç„¶æ•°éƒ½å¯ä»¥å”¯ä¸€åœ°è¡¨ç¤ºä¸ºç´ æ•°çš„ä¹˜ç§¯ï¼ˆä¸è®¡é¡ºåºï¼‰ã€‚

**è¯æ˜**:

1. **å­˜åœ¨æ€§**: ä½¿ç”¨æ•°å­¦å½’çº³æ³•
2. **å”¯ä¸€æ€§**: ä½¿ç”¨ç´ æ•°çš„æ€§è´¨

### 2.2 æ¬§å‡ é‡Œå¾—ç®—æ³•

**å®šç† 2.2** (æ¬§å‡ é‡Œå¾—ç®—æ³•)
å¯¹äºä»»æ„æ•´æ•° $a, b$ï¼Œæœ‰ï¼š
$$\gcd(a, b) = \gcd(b, a \bmod b)$$

**è¯æ˜**:
è®¾ $d = \gcd(a, b)$ï¼Œåˆ™ $d \mid a$ ä¸” $d \mid b$ã€‚
ç”±äº $a = qb + r$ï¼Œå…¶ä¸­ $r = a \bmod b$ï¼Œæ‰€ä»¥ $d \mid r$ã€‚
å› æ­¤ $d \mid \gcd(b, r)$ã€‚

åä¹‹ï¼Œè®¾ $d' = \gcd(b, r)$ï¼Œåˆ™ $d' \mid b$ ä¸” $d' \mid r$ã€‚
ç”±äº $a = qb + r$ï¼Œæ‰€ä»¥ $d' \mid a$ã€‚
å› æ­¤ $d' \mid \gcd(a, b)$ã€‚

æ‰€ä»¥ $\gcd(a, b) = \gcd(b, r)$ã€‚

### 2.3 è´ç¥–å®šç†

**å®šç† 2.3** (è´ç¥–å®šç†)
å¯¹äºä»»æ„æ•´æ•° $a, b$ï¼Œå­˜åœ¨æ•´æ•° $x, y$ ä½¿å¾—ï¼š
$$ax + by = \gcd(a, b)$$

**è¯æ˜**:
ä½¿ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ„é€ è§£ã€‚

### 2.4 è´¹é©¬å°å®šç†

**å®šç† 2.4** (è´¹é©¬å°å®šç†)
å¦‚æœ $p$ æ˜¯ç´ æ•°ï¼Œ$a$ æ˜¯ä¸ $p$ äº’ç´ çš„æ•´æ•°ï¼Œåˆ™ï¼š
$$a^{p-1} \equiv 1 \pmod{p}$$

**è¯æ˜**:
è€ƒè™‘é›†åˆ $\{a, 2a, 3a, \ldots, (p-1)a\}$ï¼Œå®ƒä»¬æ¨¡ $p$ çš„ä½™æ•°å„ä¸ç›¸åŒä¸”éƒ½ä¸ä¸º0ã€‚
å› æ­¤ï¼š
$$a \cdot 2a \cdot 3a \cdots (p-1)a \equiv 1 \cdot 2 \cdot 3 \cdots (p-1) \pmod{p}$$
$$a^{p-1} \cdot (p-1)! \equiv (p-1)! \pmod{p}$$
ç”±äº $(p-1)!$ ä¸ $p$ äº’ç´ ï¼Œæ‰€ä»¥ $a^{p-1} \equiv 1 \pmod{p}$ã€‚

### 2.5 ä¸­å›½å‰©ä½™å®šç†

**å®šç† 2.5** (ä¸­å›½å‰©ä½™å®šç†)
è®¾ $m_1, m_2, \ldots, m_k$ æ˜¯ä¸¤ä¸¤äº’ç´ çš„æ­£æ•´æ•°ï¼Œ$a_1, a_2, \ldots, a_k$ æ˜¯ä»»æ„æ•´æ•°ï¼Œåˆ™åŒä½™æ–¹ç¨‹ç»„ï¼š
$$\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\vdots \\
x \equiv a_k \pmod{m_k}
\end{cases}$$
æœ‰å”¯ä¸€è§£æ¨¡ $M = m_1 m_2 \cdots m_k$ã€‚

**è¯æ˜**:
æ„é€ è§£ $x = \sum_{i=1}^k a_i M_i y_i$ï¼Œå…¶ä¸­ $M_i = M / m_i$ï¼Œ$y_i$ æ˜¯ $M_i$ æ¨¡ $m_i$ çš„é€†å…ƒã€‚

## 3. Pythonå®ç°

### 3.1 åŸºæœ¬æ•°è®ºå‡½æ•°

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Set, List, Dict, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import math
import random
from collections import defaultdict, deque

T = TypeVar('T')

class NumberTheory:
    """æ•°è®ºå·¥å…·ç±»"""

    @staticmethod
    def gcd(a: int, b: int) -> int:
        """è®¡ç®—æœ€å¤§å…¬çº¦æ•°ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰"""
        a, b = abs(a), abs(b)
        while b:
            a, b = b, a % b
        return a

    @staticmethod
    def lcm(a: int, b: int) -> int:
        """è®¡ç®—æœ€å°å…¬å€æ•°"""
        return abs(a * b) // NumberTheory.gcd(a, b)

    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•

        è¿”å› (gcd, x, y)ï¼Œå…¶ä¸­ gcd = ax + by
        """
        if b == 0:
            return a, 1, 0

        gcd, x1, y1 = NumberTheory.extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return gcd, x, y

    @staticmethod
    def mod_inverse(a: int, m: int) -> Optional[int]:
        """è®¡ç®—æ¨¡é€†å…ƒ

        è¿”å› a æ¨¡ m çš„é€†å…ƒï¼Œå¦‚æœä¸å­˜åœ¨è¿”å› None
        """
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            return None
        return (x % m + m) % m

    @staticmethod
    def is_prime(n: int) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False

        # è¯•é™¤æ³•
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True

    @staticmethod
    def prime_factors(n: int) -> Dict[int, int]:
        """è´¨å› æ•°åˆ†è§£

        è¿”å›å­—å…¸ {prime: power}
        """
        factors = {}
        d = 2

        while d * d <= n:
            while n % d == 0:
                factors[d] = factors.get(d, 0) + 1
                n //= d
            d += 1

        if n > 1:
            factors[n] = factors.get(n, 0) + 1

        return factors

    @staticmethod
    def euler_totient(n: int) -> int:
        """è®¡ç®—æ¬§æ‹‰å‡½æ•° Ï†(n)"""
        if n == 1:
            return 1

        factors = NumberTheory.prime_factors(n)
        result = n

        for prime in factors:
            result = result // prime * (prime - 1)

        return result

    @staticmethod
    def miller_rabin(n: int, k: int = 5) -> bool:
        """Miller-Rabinç´ æ€§æµ‹è¯•"""
        if n < 2:
            return False
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False

        # å°† n-1 å†™æˆ d * 2^r çš„å½¢å¼
        r = 0
        d = n - 1
        while d % 2 == 0:
            r += 1
            d //= 2

        # è¿›è¡Œ k æ¬¡æµ‹è¯•
        for _ in range(k):
            a = random.randint(2, n - 2)
            x = pow(a, d, n)

            if x == 1 or x == n - 1:
                continue

            for _ in range(r - 1):
                x = (x * x) % n
                if x == n - 1:
                    break
            else:
                return False

        return True

    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> int:
        """ä¸­å›½å‰©ä½™å®šç†"""
        if len(remainders) != len(moduli):
            raise ValueError("ä½™æ•°å’Œæ¨¡æ•°æ•°é‡ä¸åŒ¹é…")

        # éªŒè¯æ¨¡æ•°ä¸¤ä¸¤äº’ç´ 
        for i in range(len(moduli)):
            for j in range(i + 1, len(moduli)):
                if NumberTheory.gcd(moduli[i], moduli[j]) != 1:
                    raise ValueError("æ¨¡æ•°ä¸ä¸¤ä¸¤äº’ç´ ")

        # è®¡ç®—ä¹˜ç§¯
        M = 1
        for m in moduli:
            M *= m

        # è®¡ç®—è§£
        result = 0
        for i, (a, m) in enumerate(zip(remainders, moduli)):
            Mi = M // m
            yi = NumberTheory.mod_inverse(Mi, m)
            if yi is None:
                raise ValueError(f"æ— æ³•è®¡ç®— {Mi} æ¨¡ {m} çš„é€†å…ƒ")
            result = (result + a * Mi * yi) % M

        return result
```

### 3.2 ç´ æ•°ç”Ÿæˆå™¨

```python
class PrimeGenerator:
    """ç´ æ•°ç”Ÿæˆå™¨"""

    def __init__(self):
        self.primes = [2, 3, 5, 7]
        self.max_checked = 10

    def is_prime(self, n: int) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False

        # ä½¿ç”¨å·²ç”Ÿæˆçš„ç´ æ•°è¿›è¡Œè¯•é™¤
        for prime in self.primes:
            if prime * prime > n:
                return True
            if n % prime == 0:
                return False

        # æ‰©å±•ç´ æ•°åˆ—è¡¨
        self._extend_primes(n)
        return self.is_prime(n)

    def _extend_primes(self, limit: int):
        """æ‰©å±•ç´ æ•°åˆ—è¡¨åˆ°limit"""
        if limit <= self.max_checked:
            return

        for n in range(self.max_checked + 1, limit + 1, 2):
            is_prime = True
            for prime in self.primes:
                if prime * prime > n:
                    break
                if n % prime == 0:
                    is_prime = False
                    break

            if is_prime:
                self.primes.append(n)

        self.max_checked = limit

    def get_primes_up_to(self, n: int) -> List[int]:
        """è·å–å°äºç­‰äºnçš„æ‰€æœ‰ç´ æ•°"""
        self._extend_primes(n)
        return [p for p in self.primes if p <= n]

class SieveOfEratosthenes:
    """åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•"""

    @staticmethod
    def sieve(n: int) -> List[bool]:
        """ç”Ÿæˆç´ æ•°è¡¨

        è¿”å›é•¿åº¦ä¸ºn+1çš„å¸ƒå°”æ•°ç»„ï¼Œis_prime[i]è¡¨ç¤ºiæ˜¯å¦ä¸ºç´ æ•°
        """
        is_prime = [True] * (n + 1)
        is_prime[0] = is_prime[1] = False

        for i in range(2, int(math.sqrt(n)) + 1):
            if is_prime[i]:
                for j in range(i * i, n + 1, i):
                    is_prime[j] = False

        return is_prime

    @staticmethod
    def get_primes(n: int) -> List[int]:
        """è·å–å°äºç­‰äºnçš„æ‰€æœ‰ç´ æ•°"""
        is_prime = SieveOfEratosthenes.sieve(n)
        return [i for i in range(n + 1) if is_prime[i]]
```

### 3.3 åŒä½™æ–¹ç¨‹æ±‚è§£å™¨

```python
class CongruenceSolver:
    """åŒä½™æ–¹ç¨‹æ±‚è§£å™¨"""

    @staticmethod
    def solve_linear_congruence(a: int, b: int, m: int) -> Optional[List[int]]:
        """æ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹ ax â‰¡ b (mod m)"""
        g, x, y = NumberTheory.extended_gcd(a, m)

        if b % g != 0:
            return None  # æ— è§£

        # ç‰¹è§£
        x0 = (x * (b // g)) % m

        # é€šè§£
        solutions = []
        for k in range(g):
            solution = (x0 + k * (m // g)) % m
            solutions.append(solution)

        return sorted(solutions)

    @staticmethod
    def solve_system_of_congruences(coefficients: List[int],
                                   remainders: List[int],
                                   moduli: List[int]) -> Optional[int]:
        """æ±‚è§£åŒä½™æ–¹ç¨‹ç»„

        a_i * x â‰¡ b_i (mod m_i)
        """
        if len(coefficients) != len(remainders) or len(remainders) != len(moduli):
            raise ValueError("å‚æ•°æ•°é‡ä¸åŒ¹é…")

        # é€ä¸ªæ±‚è§£
        current_solution = 0
        current_modulus = 1

        for a, b, m in zip(coefficients, remainders, moduli):
            # æ±‚è§£ a * x â‰¡ b (mod m)
            solutions = CongruenceSolver.solve_linear_congruence(a, b, m)
            if solutions is None:
                return None

            # é€‰æ‹©æœ€å°çš„éè´Ÿè§£
            x = solutions[0]

            # ä½¿ç”¨ä¸­å›½å‰©ä½™å®šç†åˆå¹¶è§£
            new_solution = current_solution + x * current_modulus
            new_modulus = NumberTheory.lcm(current_modulus, m)

            # è°ƒæ•´åˆ°æ–°çš„æ¨¡æ•°
            new_solution %= new_modulus

            current_solution = new_solution
            current_modulus = new_modulus

        return current_solution
```

### 3.4 å¯†ç å­¦åº”ç”¨

```python
class RSA:
    """RSAåŠ å¯†ç®—æ³•"""

    def __init__(self, p: int, q: int):
        """åˆå§‹åŒ–RSA

        p, q å¿…é¡»æ˜¯ç´ æ•°
        """
        if not NumberTheory.is_prime(p) or not NumberTheory.is_prime(q):
            raise ValueError("på’Œqå¿…é¡»æ˜¯ç´ æ•°")

        self.p = p
        self.q = q
        self.n = p * q
        self.phi = (p - 1) * (q - 1)

        # é€‰æ‹©å…¬é’¥
        self.e = 65537  # å¸¸ç”¨çš„å…¬é’¥
        while NumberTheory.gcd(self.e, self.phi) != 1:
            self.e += 2

        # è®¡ç®—ç§é’¥
        self.d = NumberTheory.mod_inverse(self.e, self.phi)
        if self.d is None:
            raise ValueError("æ— æ³•è®¡ç®—ç§é’¥")

    def encrypt(self, message: int) -> int:
        """åŠ å¯†"""
        return pow(message, self.e, self.n)

    def decrypt(self, ciphertext: int) -> int:
        """è§£å¯†"""
        return pow(ciphertext, self.d, self.n)

    def get_public_key(self) -> Tuple[int, int]:
        """è·å–å…¬é’¥"""
        return (self.e, self.n)

    def get_private_key(self) -> Tuple[int, int]:
        """è·å–ç§é’¥"""
        return (self.d, self.n)
```

## 4. åº”ç”¨ç¤ºä¾‹

### 4.1 ç´ æ•°æµ‹è¯•

```python
# ç´ æ•°æµ‹è¯•ç¤ºä¾‹
def test_primality():
    numbers = [2, 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

    print("ç´ æ•°æµ‹è¯•:")
    for n in numbers:
        is_prime = NumberTheory.is_prime(n)
        print(f"{n}: {'ç´ æ•°' if is_prime else 'åˆæ•°'}")

    print("\nMiller-Rabinæµ‹è¯•:")
    for n in [561, 1105, 1729, 2465, 2821, 6601]:  # å¡è¿ˆå…‹å°”æ•°
        is_prime = NumberTheory.miller_rabin(n, 5)
        print(f"{n}: {'å¯èƒ½æ˜¯ç´ æ•°' if is_prime else 'åˆæ•°'}")

# è¿è¡Œæµ‹è¯•
test_primality()
```

### 4.2 è´¨å› æ•°åˆ†è§£

```python
# è´¨å› æ•°åˆ†è§£ç¤ºä¾‹
def test_prime_factorization():
    numbers = [12, 24, 36, 48, 60, 100, 1000, 10000]

    print("è´¨å› æ•°åˆ†è§£:")
    for n in numbers:
        factors = NumberTheory.prime_factors(n)
        factor_str = " Ã— ".join([f"{p}^{e}" for p, e in factors.items()])
        print(f"{n} = {factor_str}")

# è¿è¡Œæµ‹è¯•
test_prime_factorization()
```

### 4.3 RSAåŠ å¯†

```python
# RSAåŠ å¯†ç¤ºä¾‹
def test_rsa():
    # ç”ŸæˆRSAå¯†é’¥å¯¹
    p = 61
    q = 53
    rsa = RSA(p, q)

    # åŠ å¯†å’Œè§£å¯†
    message = 123
    encrypted = rsa.encrypt(message)
    decrypted = rsa.decrypt(encrypted)

    print(f"åŸå§‹æ¶ˆæ¯: {message}")
    print(f"åŠ å¯†å: {encrypted}")
    print(f"è§£å¯†å: {decrypted}")
    print(f"åŠ å¯†æˆåŠŸ: {message == decrypted}")

# è¿è¡Œæµ‹è¯•
test_rsa()
```

### 4.4 ä¸­å›½å‰©ä½™å®šç†

```python
# ä¸­å›½å‰©ä½™å®šç†ç¤ºä¾‹
def test_chinese_remainder():
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]

    solution = NumberTheory.chinese_remainder_theorem(remainders, moduli)

    print(f"åŒä½™æ–¹ç¨‹ç»„:")
    for a, m in zip(remainders, moduli):
        print(f"x â‰¡ {a} (mod {m})")
    print(f"è§£: x â‰¡ {solution} (mod {math.prod(moduli)})")

    # éªŒè¯
    for a, m in zip(remainders, moduli):
        print(f"éªŒè¯: {solution} â‰¡ {solution % m} (mod {m})")

# è¿è¡Œæµ‹è¯•
test_chinese_remainder()
```

## 5. ç†è®ºè¯æ˜

### 5.1 æ¬§å‡ é‡Œå¾—ç®—æ³•æ­£ç¡®æ€§

**å®šç† 5.1** (æ¬§å‡ é‡Œå¾—ç®—æ³•ç»ˆæ­¢æ€§)
æ¬§å‡ é‡Œå¾—ç®—æ³•åœ¨æœ‰é™æ­¥åç»ˆæ­¢ã€‚

**è¯æ˜**:
æ¯æ¬¡é€’å½’è°ƒç”¨æ—¶ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸¥æ ¼é€’å‡ä¸”éè´Ÿï¼Œå› æ­¤ç®—æ³•å¿…ç„¶ç»ˆæ­¢ã€‚

**å®šç† 5.2** (æ¬§å‡ é‡Œå¾—ç®—æ³•æ­£ç¡®æ€§)
æ¬§å‡ é‡Œå¾—ç®—æ³•è¿”å›çš„ç¡®å®æ˜¯æœ€å¤§å…¬çº¦æ•°ã€‚

**è¯æ˜**:
ä½¿ç”¨æ•°å­¦å½’çº³æ³•ï¼ŒåŸºäºå®šç†2.2ã€‚

### 5.2 è´¹é©¬å°å®šç†æ¨å¹¿

**å®šç† 5.3** (æ¬§æ‹‰å®šç†)
å¦‚æœ $\gcd(a, n) = 1$ï¼Œåˆ™ï¼š
$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**è¯æ˜**:
è€ƒè™‘ä¸ $n$ äº’ç´ çš„å®Œå…¨å‰©ä½™ç³»ï¼Œç±»ä¼¼äºè´¹é©¬å°å®šç†çš„è¯æ˜ã€‚

### 5.3 ç´ æ•°åˆ†å¸ƒ

**å®šç† 5.4** (ç´ æ•°å®šç†)
è®¾ $\pi(x)$ è¡¨ç¤ºä¸è¶…è¿‡ $x$ çš„ç´ æ•°ä¸ªæ•°ï¼Œåˆ™ï¼š
$$\lim_{x \to \infty} \frac{\pi(x)}{x / \ln x} = 1$$

**è¯æ˜**:
è¿™æ˜¯æ•°è®ºä¸­çš„è‘—åå®šç†ï¼Œè¯æ˜è¾ƒä¸ºå¤æ‚ã€‚

## 6. æ€§èƒ½åˆ†æ

### 6.1 å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------------|------------|----------|
| è¯•é™¤æ³• | O(âˆšn) | O(1) | å°æ•´æ•°ç´ æ€§æµ‹è¯• |
| åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³• | O(n log log n) | O(n) | ç”Ÿæˆç´ æ•°è¡¨ |
| æ¬§å‡ é‡Œå¾—ç®—æ³• | O(log n) | O(1) | è®¡ç®—æœ€å¤§å…¬çº¦æ•° |
| Miller-Rabin | O(k logÂ³ n) | O(1) | å¤§æ•´æ•°ç´ æ€§æµ‹è¯• |
| ä¸­å›½å‰©ä½™å®šç† | O(kÂ²) | O(k) | åŒä½™æ–¹ç¨‹ç»„æ±‚è§£ |

### 6.2 ä¼˜åŒ–ç­–ç•¥

1. **é¢„è®¡ç®—**: é¢„è®¡ç®—å¸¸ç”¨ç´ æ•°å’Œå› å­
2. **æ¦‚ç‡ç®—æ³•**: ä½¿ç”¨æ¦‚ç‡ç®—æ³•å¤„ç†å¤§æ•´æ•°
3. **å¹¶è¡Œè®¡ç®—**: åˆ©ç”¨å¤šæ ¸å¤„ç†å™¨å¹¶è¡Œè®¡ç®—
4. **ç¼“å­˜æœºåˆ¶**: ç¼“å­˜ä¸­é—´ç»“æœé¿å…é‡å¤è®¡ç®—

## 7. æ€»ç»“

æ•°è®ºä¸ºè®¡ç®—æœºç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ï¼Œç‰¹åˆ«æ˜¯åœ¨å¯†ç å­¦ã€ç®—æ³•è®¾è®¡å’Œè®¡ç®—å¤æ‚æ€§ç†è®ºä¸­æœ‰ç€å¹¿æ³›åº”ç”¨ã€‚

### ä¸»è¦æˆæœ

1. **å®Œæ•´çš„ç†è®ºæ¡†æ¶**: ä»åŸºæœ¬æ¦‚å¿µåˆ°é«˜çº§å®šç†
2. **å®ç”¨çš„å®ç°**: æ‰€æœ‰ç®—æ³•éƒ½æœ‰å¯¹åº”çš„Pythonå®ç°
3. **ä¸¥æ ¼çš„å½¢å¼åŒ–**: æ•°å­¦å®šä¹‰å’Œè¯æ˜
4. **å®é™…åº”ç”¨**: å¯†ç å­¦ã€ç®—æ³•è®¾è®¡ç­‰

### æŠ€æœ¯ç‰¹è‰²

1. **å¤šè¡¨å¾æ–¹æ³•**: æ¦‚å¿µã€æ•°å­¦ã€ä»£ç ã€å›¾è¡¨
2. **å±‚æ¬¡åŒ–ç»„ç»‡**: ä»åŸºç¡€åˆ°åº”ç”¨
3. **ä¸¥æ ¼çš„å½¢å¼åŒ–**: æ•°å­¦å®šä¹‰å’Œè¯æ˜
4. **å®Œæ•´çš„å®ç°**: å¯è¿è¡Œçš„Pythonä»£ç 

---

*æœ¬æ–‡æ¡£å»ºç«‹äº†æ•°è®ºåŸºç¡€çš„å®Œæ•´æ¡†æ¶ï¼Œä¸ºåç»­çš„å¯†ç å­¦ã€ç®—æ³•è®¾è®¡ç­‰å¥ å®šäº†åŸºç¡€ã€‚*
