# æ•°è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°è®ºæ˜¯ç ”ç©¶æ•´æ•°æ€§è´¨çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨å¯†ç å­¦ã€ç®—æ³•è®¾è®¡å’Œè®¡ç®—æœºç§‘å­¦ä¸­å…·æœ‰é‡è¦åº”ç”¨ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€ç´ æ•°ç†è®ºã€åŒä½™ç†è®ºç­‰å¤šä¸ªç»´åº¦å…¨é¢é˜è¿°æ•°è®ºåŸºç¡€çš„ç†è®ºä¸å®è·µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 æ•´é™¤å…³ç³»çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (æ•´é™¤)
å¯¹äºæ•´æ•° $a, b$ï¼Œå¦‚æœå­˜åœ¨æ•´æ•° $k$ ä½¿å¾— $b = ak$ï¼Œåˆ™ç§° $a$ æ•´é™¤ $b$ï¼Œè®°ä½œ $a \mid b$ã€‚

å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š
$$a \mid b \iff \exists k \in \mathbb{Z}: b = ak$$

**å®šä¹‰ 1.2** (æœ€å¤§å…¬çº¦æ•°)
æ•´æ•° $a, b$ çš„æœ€å¤§å…¬çº¦æ•° $d = \gcd(a, b)$ æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æœ€å¤§æ­£æ•´æ•°ï¼š
1. $d \mid a$ ä¸” $d \mid b$
2. å¯¹äºä»»æ„ $c$ï¼Œå¦‚æœ $c \mid a$ ä¸” $c \mid b$ï¼Œåˆ™ $c \mid d$

**å®šä¹‰ 1.3** (æœ€å°å…¬å€æ•°)
æ•´æ•° $a, b$ çš„æœ€å°å…¬å€æ•° $m = \text{lcm}(a, b)$ æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æœ€å°æ­£æ•´æ•°ï¼š
1. $a \mid m$ ä¸” $b \mid m$
2. å¯¹äºä»»æ„ $c$ï¼Œå¦‚æœ $a \mid c$ ä¸” $b \mid c$ï¼Œåˆ™ $m \mid c$

### 1.2 ç´ æ•°ç†è®ºçš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.4** (ç´ æ•°)
æ­£æ•´æ•° $p > 1$ æ˜¯ç´ æ•°ï¼Œå½“ä¸”ä»…å½“ $p$ çš„æ­£å› å­åªæœ‰ $1$ å’Œ $p$ æœ¬èº«ã€‚

å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š
$$\text{Prime}(p) \iff p > 1 \land \forall d \in \mathbb{Z}^+: (d \mid p \rightarrow d = 1 \lor d = p)$$

**å®šä¹‰ 1.5** (ç´ æ•°è®¡æ•°å‡½æ•°)
ç´ æ•°è®¡æ•°å‡½æ•° $\pi(x)$ å®šä¹‰ä¸ºä¸è¶…è¿‡ $x$ çš„ç´ æ•°ä¸ªæ•°ï¼š
$$\pi(x) = |\{p \leq x \mid \text{Prime}(p)\}|$$

**å®šä¹‰ 1.6** (æ¬§æ‹‰å‡½æ•°)
æ¬§æ‹‰å‡½æ•° $\phi(n)$ å®šä¹‰ä¸ºä¸ $n$ äº’è´¨çš„æ­£æ•´æ•°ä¸ªæ•°ï¼š
$$\phi(n) = |\{k \in \mathbb{Z}^+ \mid k \leq n \land \gcd(k, n) = 1\}|$$

### 1.3 åŒä½™ç†è®ºçš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.7** (åŒä½™)
å¯¹äºæ•´æ•° $a, b, m$ï¼Œå¦‚æœ $m \mid (a - b)$ï¼Œåˆ™ç§° $a$ ä¸ $b$ æ¨¡ $m$ åŒä½™ï¼Œè®°ä½œ $a \equiv b \pmod{m}$ã€‚

å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š
$$a \equiv b \pmod{m} \iff m \mid (a - b)$$

**å®šä¹‰ 1.8** (åŒä½™ç±»)
æ¨¡ $m$ çš„åŒä½™ç±» $[a]_m$ å®šä¹‰ä¸ºï¼š
$$[a]_m = \{b \in \mathbb{Z} \mid b \equiv a \pmod{m}\}$$

**å®šä¹‰ 1.9** (å®Œå…¨å‰©ä½™ç³»)
æ¨¡ $m$ çš„å®Œå…¨å‰©ä½™ç³»æ˜¯ $m$ ä¸ªä¸¤ä¸¤ä¸åŒä½™çš„æ•´æ•°é›†åˆã€‚

## 2. Pythonå®ç°

### 2.1 åŸºç¡€æ•°è®ºå‡½æ•°

```python
from abc import ABC, abstractmethod
from typing import List, Tuple, Optional, Set, Dict, Any
from dataclasses import dataclass
from enum import Enum
import math
import random

class NumberTheory:
    """æ•°è®ºåŸºç¡€ç±»"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚æœ€å¤§å…¬çº¦æ•°"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """æ±‚æœ€å°å…¬å€æ•°"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•"""
        if b == 0:
            return a, 1, 0
        
        gcd, x1, y1 = NumberTheory.extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        
        return gcd, x, y
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        # åªéœ€è¦æ£€æŸ¥åˆ° sqrt(n)
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def prime_factors(n: int) -> Dict[int, int]:
        """è´¨å› æ•°åˆ†è§£"""
        factors = {}
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors[d] = factors.get(d, 0) + 1
                n //= d
            d += 1
        
        if n > 1:
            factors[n] = factors.get(n, 0) + 1
        
        return factors
    
    @staticmethod
    def euler_phi(n: int) -> int:
        """æ¬§æ‹‰å‡½æ•°"""
        if n == 1:
            return 1
        
        factors = NumberTheory.prime_factors(n)
        result = n
        
        for prime in factors:
            result = result // prime * (prime - 1)
        
        return result
    
    @staticmethod
    def mod_inverse(a: int, m: int) -> Optional[int]:
        """æ¨¡é€†å…ƒ"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        
        if gcd != 1:
            return None  # ä¸å­˜åœ¨é€†å…ƒ
        
        return (x % m + m) % m
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], 
                                 moduli: List[int]) -> Optional[int]:
        """ä¸­å›½å‰©ä½™å®šç†"""
        if len(remainders) != len(moduli):
            return None
        
        # è®¡ç®—æ€»æ¨¡æ•°
        M = 1
        for m in moduli:
            M *= m
        
        result = 0
        
        for i, (remainder, modulus) in enumerate(zip(remainders, moduli)):
            Mi = M // modulus
            Mi_inv = NumberTheory.mod_inverse(Mi, modulus)
            
            if Mi_inv is None:
                return None
            
            result = (result + remainder * Mi * Mi_inv) % M
        
        return result
    
    @staticmethod
    def quadratic_residue(a: int, p: int) -> bool:
        """åˆ¤æ–­äºŒæ¬¡å‰©ä½™"""
        if not NumberTheory.is_prime(p) or p == 2:
            return True
        
        # æ¬§æ‹‰åˆ¤åˆ«æ³•
        return pow(a, (p - 1) // 2, p) == 1
    
    @staticmethod
    def legendre_symbol(a: int, p: int) -> int:
        """å‹’è®©å¾·ç¬¦å·"""
        if not NumberTheory.is_prime(p):
            raise ValueError("på¿…é¡»æ˜¯ç´ æ•°")
        
        if a % p == 0:
            return 0
        
        if NumberTheory.quadratic_residue(a, p):
            return 1
        else:
            return -1

class PrimeGenerator:
    """ç´ æ•°ç”Ÿæˆå™¨"""
    
    @staticmethod
    def sieve_of_eratosthenes(n: int) -> List[int]:
        """åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•"""
        if n < 2:
            return []
        
        # åˆå§‹åŒ–ç­›å­
        is_prime = [True] * (n + 1)
        is_prime[0] = is_prime[1] = False
        
        # ç­›æ³•
        for i in range(2, int(math.sqrt(n)) + 1):
            if is_prime[i]:
                for j in range(i * i, n + 1, i):
                    is_prime[j] = False
        
        # æ”¶é›†ç´ æ•°
        primes = [i for i in range(n + 1) if is_prime[i]]
        return primes
    
    @staticmethod
    def miller_rabin_primality_test(n: int, k: int = 5) -> bool:
        """Miller-Rabinç´ æ€§æµ‹è¯•"""
        if n < 2:
            return False
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False
        
        # å°† n-1 å†™æˆ d * 2^r çš„å½¢å¼
        r = 0
        d = n - 1
        while d % 2 == 0:
            r += 1
            d //= 2
        
        # è¿›è¡Œkæ¬¡æµ‹è¯•
        for _ in range(k):
            a = random.randint(2, n - 2)
            x = pow(a, d, n)
            
            if x == 1 or x == n - 1:
                continue
            
            for _ in range(r - 1):
                x = (x * x) % n
                if x == n - 1:
                    break
            else:
                return False
        
        return True
    
    @staticmethod
    def generate_prime(bits: int) -> int:
        """ç”ŸæˆæŒ‡å®šä½æ•°çš„ç´ æ•°"""
        while True:
            # ç”Ÿæˆéšæœºå¥‡æ•°
            n = random.getrandbits(bits)
            n |= 1  # ç¡®ä¿æ˜¯å¥‡æ•°
            n |= (1 << (bits - 1))  # ç¡®ä¿æœ‰æŒ‡å®šä½æ•°
            
            if NumberTheory.miller_rabin_primality_test(n):
                return n

class CongruenceTheory:
    """åŒä½™ç†è®º"""
    
    @staticmethod
    def solve_linear_congruence(a: int, b: int, m: int) -> List[int]:
        """è§£çº¿æ€§åŒä½™æ–¹ç¨‹ ax â‰¡ b (mod m)"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        
        if b % gcd != 0:
            return []  # æ— è§£
        
        # ç‰¹è§£
        x0 = (x * (b // gcd)) % m
        
        # é€šè§£
        solutions = []
        for i in range(gcd):
            solution = (x0 + i * (m // gcd)) % m
            solutions.append(solution)
        
        return sorted(solutions)
    
    @staticmethod
    def solve_system_of_congruences(remainders: List[int], 
                                   moduli: List[int]) -> Optional[int]:
        """è§£åŒä½™æ–¹ç¨‹ç»„"""
        return NumberTheory.chinese_remainder_theorem(remainders, moduli)
    
    @staticmethod
    def discrete_logarithm(base: int, value: int, modulus: int) -> Optional[int]:
        """ç¦»æ•£å¯¹æ•°"""
        if not NumberTheory.is_prime(modulus):
            raise ValueError("æ¨¡æ•°å¿…é¡»æ˜¯ç´ æ•°")
        
        # ä½¿ç”¨å¤§æ­¥å°æ­¥ç®—æ³•
        m = int(math.sqrt(modulus)) + 1
        
        # è®¡ç®—å°æ­¥
        baby_steps = {}
        current = 1
        for j in range(m):
            baby_steps[current] = j
            current = (current * base) % modulus
        
        # è®¡ç®—å¤§æ­¥
        factor = pow(base, m * (modulus - 2), modulus)
        current = value
        
        for i in range(m):
            if current in baby_steps:
                return i * m + baby_steps[current]
            current = (current * factor) % modulus
        
        return None  # æ— è§£

class NumberTheoryAnalyzer:
    """æ•°è®ºåˆ†æå™¨"""
    
    def __init__(self):
        self.prime_generator = PrimeGenerator()
        self.congruence_theory = CongruenceTheory()
    
    def analyze_number_properties(self, n: int) -> Dict[str, Any]:
        """åˆ†ææ•°çš„æ€§è´¨"""
        properties = {
            'is_prime': NumberTheory.is_prime(n),
            'prime_factors': NumberTheory.prime_factors(n),
            'euler_phi': NumberTheory.euler_phi(n),
            'divisors': self._get_divisors(n),
            'sum_of_divisors': self._sum_of_divisors(n),
            'number_of_divisors': self._number_of_divisors(n)
        }
        
        return properties
    
    def _get_divisors(self, n: int) -> List[int]:
        """è·å–æ‰€æœ‰æ­£å› å­"""
        if n == 0:
            return []
        
        divisors = set()
        for i in range(1, int(math.sqrt(abs(n))) + 1):
            if n % i == 0:
                divisors.add(i)
                divisors.add(n // i)
        
        return sorted(divisors)
    
    def _sum_of_divisors(self, n: int) -> int:
        """å› å­å’Œ"""
        if n == 0:
            return 0
        
        factors = NumberTheory.prime_factors(abs(n))
        result = 1
        
        for prime, power in factors.items():
            result *= (prime ** (power + 1) - 1) // (prime - 1)
        
        return result
    
    def _number_of_divisors(self, n: int) -> int:
        """å› å­ä¸ªæ•°"""
        if n == 0:
            return 0
        
        factors = NumberTheory.prime_factors(abs(n))
        result = 1
        
        for power in factors.values():
            result *= (power + 1)
        
        return result
    
    def analyze_prime_distribution(self, limit: int) -> Dict[str, Any]:
        """åˆ†æç´ æ•°åˆ†å¸ƒ"""
        primes = self.prime_generator.sieve_of_eratosthenes(limit)
        
        analysis = {
            'total_primes': len(primes),
            'prime_density': len(primes) / limit,
            'largest_prime': max(primes) if primes else 0,
            'prime_gaps': self._calculate_prime_gaps(primes),
            'twin_primes': self._count_twin_primes(primes)
        }
        
        return analysis
    
    def _calculate_prime_gaps(self, primes: List[int]) -> List[int]:
        """è®¡ç®—ç´ æ•°é—´éš”"""
        gaps = []
        for i in range(1, len(primes)):
            gaps.append(primes[i] - primes[i-1])
        return gaps
    
    def _count_twin_primes(self, primes: List[int]) -> int:
        """è®¡ç®—å­ªç”Ÿç´ æ•°å¯¹"""
        count = 0
        for i in range(1, len(primes)):
            if primes[i] - primes[i-1] == 2:
                count += 1
        return count
```

## 3. å®é™…åº”ç”¨ç¤ºä¾‹

### 3.1 å¯†ç å­¦åº”ç”¨

```python
class CryptographyApplications:
    """å¯†ç å­¦åº”ç”¨"""
    
    def __init__(self):
        self.prime_generator = PrimeGenerator()
    
    def rsa_key_generation(self, bits: int = 1024) -> Tuple[Tuple[int, int], Tuple[int, int]]:
        """RSAå¯†é’¥ç”Ÿæˆ"""
        # ç”Ÿæˆä¸¤ä¸ªå¤§ç´ æ•°
        p = self.prime_generator.generate_prime(bits // 2)
        q = self.prime_generator.generate_prime(bits // 2)
        
        n = p * q
        phi_n = (p - 1) * (q - 1)
        
        # é€‰æ‹©å…¬é’¥æŒ‡æ•°
        e = 65537  # å¸¸ç”¨çš„å…¬é’¥æŒ‡æ•°
        
        # è®¡ç®—ç§é’¥æŒ‡æ•°
        d = NumberTheory.mod_inverse(e, phi_n)
        
        if d is None:
            raise ValueError("æ— æ³•ç”Ÿæˆæœ‰æ•ˆçš„ç§é’¥")
        
        public_key = (e, n)
        private_key = (d, n)
        
        return public_key, private_key
    
    def rsa_encrypt(self, message: int, public_key: Tuple[int, int]) -> int:
        """RSAåŠ å¯†"""
        e, n = public_key
        return pow(message, e, n)
    
    def rsa_decrypt(self, ciphertext: int, private_key: Tuple[int, int]) -> int:
        """RSAè§£å¯†"""
        d, n = private_key
        return pow(ciphertext, d, n)
    
    def diffie_hellman_key_exchange(self, bits: int = 1024) -> Tuple[Dict, Dict]:
        """Diffie-Hellmanå¯†é’¥äº¤æ¢"""
        # ç”Ÿæˆå¤§ç´ æ•°på’ŒåŸæ ¹g
        p = self.prime_generator.generate_prime(bits)
        
        # ç®€åŒ–ï¼šä½¿ç”¨2ä½œä¸ºåŸæ ¹ï¼ˆå®é™…åº”ç”¨ä¸­éœ€è¦éªŒè¯ï¼‰
        g = 2
        
        # Aliceç”Ÿæˆç§é’¥
        a = random.randint(2, p - 2)
        A = pow(g, a, p)
        
        # Bobç”Ÿæˆç§é’¥
        b = random.randint(2, p - 2)
        B = pow(g, b, p)
        
        # è®¡ç®—å…±äº«å¯†é’¥
        shared_key_alice = pow(B, a, p)
        shared_key_bob = pow(A, b, p)
        
        # éªŒè¯å¯†é’¥ä¸€è‡´æ€§
        assert shared_key_alice == shared_key_bob
        
        alice_info = {
            'private_key': a,
            'public_key': A,
            'shared_key': shared_key_alice
        }
        
        bob_info = {
            'private_key': b,
            'public_key': B,
            'shared_key': shared_key_bob
        }
        
        return alice_info, bob_info
    
    def elgamal_encryption(self, message: int, bits: int = 1024) -> Tuple[Dict, Dict]:
        """ElGamalåŠ å¯†"""
        # ç”Ÿæˆå¯†é’¥
        p = self.prime_generator.generate_prime(bits)
        g = 2  # ç®€åŒ–å¤„ç†
        
        # ç§é’¥
        x = random.randint(2, p - 2)
        # å…¬é’¥
        y = pow(g, x, p)
        
        # åŠ å¯†
        k = random.randint(2, p - 2)
        c1 = pow(g, k, p)
        c2 = (message * pow(y, k, p)) % p
        
        public_key = (p, g, y)
        private_key = x
        ciphertext = (c1, c2)
        
        return {
            'public_key': public_key,
            'private_key': private_key,
            'ciphertext': ciphertext
        }
    
    def elgamal_decrypt(self, ciphertext: Tuple[int, int], 
                       private_key: int, public_key: Tuple[int, int, int]) -> int:
        """ElGamalè§£å¯†"""
        p, g, y = public_key
        c1, c2 = ciphertext
        x = private_key
        
        # è®¡ç®—å…±äº«å¯†é’¥
        s = pow(c1, x, p)
        s_inv = NumberTheory.mod_inverse(s, p)
        
        # è§£å¯†
        message = (c2 * s_inv) % p
        return message

# ä½¿ç”¨ç¤ºä¾‹
def cryptography_example():
    """å¯†ç å­¦åº”ç”¨ç¤ºä¾‹"""
    crypto = CryptographyApplications()
    
    # RSAç¤ºä¾‹
    print("=== RSAå¯†é’¥ç”Ÿæˆ ===")
    public_key, private_key = crypto.rsa_key_generation(256)  # ä½¿ç”¨å°ä½æ•°ä¾¿äºæ¼”ç¤º
    print(f"å…¬é’¥: {public_key}")
    print(f"ç§é’¥: {private_key}")
    
    message = 12345
    encrypted = crypto.rsa_encrypt(message, public_key)
    decrypted = crypto.rsa_decrypt(encrypted, private_key)
    print(f"åŸå§‹æ¶ˆæ¯: {message}")
    print(f"åŠ å¯†å: {encrypted}")
    print(f"è§£å¯†å: {decrypted}")
    print(f"è§£å¯†æˆåŠŸ: {message == decrypted}")
    
    # Diffie-Hellmanç¤ºä¾‹
    print("\n=== Diffie-Hellmanå¯†é’¥äº¤æ¢ ===")
    alice_info, bob_info = crypto.diffie_hellman_key_exchange(256)
    print(f"Aliceçš„å…±äº«å¯†é’¥: {alice_info['shared_key']}")
    print(f"Bobçš„å…±äº«å¯†é’¥: {bob_info['shared_key']}")
    print(f"å¯†é’¥äº¤æ¢æˆåŠŸ: {alice_info['shared_key'] == bob_info['shared_key']}")

if __name__ == "__main__":
    cryptography_example()
```

### 3.2 ç®—æ³•ä¼˜åŒ–åº”ç”¨

```python
class AlgorithmOptimization:
    """ç®—æ³•ä¼˜åŒ–åº”ç”¨"""
    
    def __init__(self):
        self.number_theory = NumberTheory()
    
    def fast_power_mod(self, base: int, exponent: int, modulus: int) -> int:
        """å¿«é€Ÿå¹‚æ¨¡è¿ç®—"""
        result = 1
        base = base % modulus
        
        while exponent > 0:
            if exponent % 2 == 1:
                result = (result * base) % modulus
            base = (base * base) % modulus
            exponent //= 2
        
        return result
    
    def lucas_sequence(self, n: int, p: int, q: int, modulus: int) -> int:
        """Lucasåºåˆ—è®¡ç®—"""
        if n == 0:
            return 0
        elif n == 1:
            return 1
        
        # ä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚
        def matrix_multiply(a: List[List[int]], b: List[List[int]]) -> List[List[int]]:
            result = [[0, 0], [0, 0]]
            for i in range(2):
                for j in range(2):
                    for k in range(2):
                        result[i][j] = (result[i][j] + a[i][k] * b[k][j]) % modulus
            return result
        
        def matrix_power(matrix: List[List[int]], power: int) -> List[List[int]]:
            result = [[1, 0], [0, 1]]  # å•ä½çŸ©é˜µ
            while power > 0:
                if power % 2 == 1:
                    result = matrix_multiply(result, matrix)
                matrix = matrix_multiply(matrix, matrix)
                power //= 2
            return result
        
        # Lucasåºåˆ—çš„è½¬ç§»çŸ©é˜µ
        matrix = [[p, -q], [1, 0]]
        powered_matrix = matrix_power(matrix, n - 1)
        
        return (powered_matrix[0][0] * 1 + powered_matrix[0][1] * 0) % modulus
    
    def prime_factorization_optimization(self, n: int) -> Dict[int, int]:
        """ä¼˜åŒ–çš„è´¨å› æ•°åˆ†è§£"""
        factors = {}
        
        # å¤„ç†2çš„å› å­
        while n % 2 == 0:
            factors[2] = factors.get(2, 0) + 1
            n //= 2
        
        # å¤„ç†å¥‡æ•°å› å­
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            while n % i == 0:
                factors[i] = factors.get(i, 0) + 1
                n //= i
        
        if n > 1:
            factors[n] = factors.get(n, 0) + 1
        
        return factors
    
    def gcd_optimization(self, a: int, b: int) -> int:
        """ä¼˜åŒ–çš„æœ€å¤§å…¬çº¦æ•°ç®—æ³•"""
        # ä½¿ç”¨äºŒè¿›åˆ¶GCDç®—æ³•
        if a == 0:
            return b
        if b == 0:
            return a
        
        # è®¡ç®—2çš„å¹‚æ¬¡
        shift = 0
        while ((a | b) & 1) == 0:
            a >>= 1
            b >>= 1
            shift += 1
        
        # ç§»é™¤aä¸­çš„2å› å­
        while (a & 1) == 0:
            a >>= 1
        
        while b != 0:
            # ç§»é™¤bä¸­çš„2å› å­
            while (b & 1) == 0:
                b >>= 1
            
            # æ¯”è¾ƒaå’Œb
            if a > b:
                a, b = b, a
            b -= a
        
        return a << shift
    
    def modular_arithmetic_optimization(self, operations: List[Tuple[str, int, int, int]]) -> List[int]:
        """æ¨¡è¿ç®—ä¼˜åŒ–"""
        results = []
        
        for op, a, b, m in operations:
            if op == "add":
                result = (a + b) % m
            elif op == "sub":
                result = (a - b) % m
            elif op == "mul":
                result = (a * b) % m
            elif op == "pow":
                result = self.fast_power_mod(a, b, m)
            elif op == "inv":
                result = NumberTheory.mod_inverse(a, m)
                if result is None:
                    result = -1  # è¡¨ç¤ºæ— é€†å…ƒ
            else:
                result = -1  # æœªçŸ¥æ“ä½œ
            
            results.append(result)
        
        return results

# ä½¿ç”¨ç¤ºä¾‹
def algorithm_optimization_example():
    """ç®—æ³•ä¼˜åŒ–åº”ç”¨ç¤ºä¾‹"""
    optimizer = AlgorithmOptimization()
    
    # å¿«é€Ÿå¹‚æ¨¡è¿ç®—
    print("=== å¿«é€Ÿå¹‚æ¨¡è¿ç®— ===")
    base, exp, mod = 2, 100, 1000000007
    result = optimizer.fast_power_mod(base, exp, mod)
    print(f"{base}^{exp} mod {mod} = {result}")
    
    # Lucasåºåˆ—
    print("\n=== Lucasåºåˆ— ===")
    n, p, q, mod = 10, 1, -1, 1000000007
    lucas_result = optimizer.lucas_sequence(n, p, q, mod)
    print(f"Lucas({n}, {p}, {q}) mod {mod} = {lucas_result}")
    
    # è´¨å› æ•°åˆ†è§£ä¼˜åŒ–
    print("\n=== è´¨å› æ•°åˆ†è§£ä¼˜åŒ– ===")
    number = 123456789
    factors = optimizer.prime_factorization_optimization(number)
    print(f"{number} = {factors}")
    
    # æ¨¡è¿ç®—ä¼˜åŒ–
    print("\n=== æ¨¡è¿ç®—ä¼˜åŒ– ===")
    operations = [
        ("add", 123, 456, 1000),
        ("mul", 123, 456, 1000),
        ("pow", 2, 10, 1000),
        ("inv", 7, 0, 11)
    ]
    
    results = optimizer.modular_arithmetic_optimization(operations)
    for i, (op, a, b, m) in enumerate(operations):
        print(f"{op}({a}, {b}) mod {m} = {results[i]}")

if __name__ == "__main__":
    algorithm_optimization_example()
```

## 4. ç†è®ºè¯æ˜

### 4.1 æ¬§å‡ é‡Œå¾—ç®—æ³•æ­£ç¡®æ€§è¯æ˜

**å®šç† 4.1** (æ¬§å‡ é‡Œå¾—ç®—æ³•æ­£ç¡®æ€§)
å¯¹äºä»»æ„æ•´æ•° $a, b$ï¼Œæ¬§å‡ é‡Œå¾—ç®—æ³• $\gcd(a, b)$ è¿”å› $a$ å’Œ $b$ çš„æœ€å¤§å…¬çº¦æ•°ã€‚

**è¯æ˜**:
è®¾ $d = \gcd(a, b)$ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜ç®—æ³•è¿”å›çš„ $d$ æ»¡è¶³ï¼š
1. $d \mid a$ ä¸” $d \mid b$
2. å¯¹äºä»»æ„ $c$ï¼Œå¦‚æœ $c \mid a$ ä¸” $c \mid b$ï¼Œåˆ™ $c \mid d$

**æ­¥éª¤ 1**: è¯æ˜ $d \mid a$ ä¸” $d \mid b$
åœ¨ç®—æ³•çš„æ¯ä¸€æ­¥ï¼Œæˆ‘ä»¬æœ‰ $a = qb + r$ï¼Œå…¶ä¸­ $0 \leq r < b$ã€‚
å¦‚æœ $d \mid b$ ä¸” $d \mid r$ï¼Œåˆ™ $d \mid a$ã€‚
ç®—æ³•æœ€ç»ˆè¿”å› $b$ï¼ˆå½“ $r = 0$ æ—¶ï¼‰ï¼Œå› æ­¤ $d \mid a$ ä¸” $d \mid b$ã€‚

**æ­¥éª¤ 2**: è¯æ˜æœ€å¤§æ€§
å¯¹äºä»»æ„ $c$ï¼Œå¦‚æœ $c \mid a$ ä¸” $c \mid b$ï¼Œåˆ™ $c \mid r$ã€‚
å› æ­¤ $c \mid d$ï¼Œè¯æ˜äº† $d$ æ˜¯æœ€å¤§å…¬çº¦æ•°ã€‚

### 4.2 è´¹é©¬å°å®šç†è¯æ˜

**å®šç† 4.2** (è´¹é©¬å°å®šç†)
å¦‚æœ $p$ æ˜¯ç´ æ•°ï¼Œ$a$ æ˜¯ä¸ $p$ äº’è´¨çš„æ•´æ•°ï¼Œåˆ™ï¼š
$$a^{p-1} \equiv 1 \pmod{p}$$

**è¯æ˜**:
è€ƒè™‘é›†åˆ $S = \{1, 2, \ldots, p-1\}$ å’Œ $aS = \{a, 2a, \ldots, (p-1)a\}$ã€‚

ç”±äº $a$ ä¸ $p$ äº’è´¨ï¼Œ$aS$ ä¸­çš„å…ƒç´ æ¨¡ $p$ ä¸¤ä¸¤ä¸åŒä½™ã€‚
å› æ­¤ $S$ å’Œ $aS$ æ¨¡ $p$ æ˜¯ç›¸åŒçš„é›†åˆã€‚

å› æ­¤ï¼š
$$\prod_{i=1}^{p-1} i \equiv \prod_{i=1}^{p-1} (ai) \pmod{p}$$

$$(p-1)! \equiv a^{p-1} \cdot (p-1)! \pmod{p}$$

ç”±äº $(p-1)!$ ä¸ $p$ äº’è´¨ï¼Œå¯ä»¥ä¸¤è¾¹åŒé™¤ï¼š
$$1 \equiv a^{p-1} \pmod{p}$$

### 4.3 ä¸­å›½å‰©ä½™å®šç†è¯æ˜

**å®šç† 4.3** (ä¸­å›½å‰©ä½™å®šç†)
è®¾ $m_1, m_2, \ldots, m_k$ æ˜¯ä¸¤ä¸¤äº’è´¨çš„æ­£æ•´æ•°ï¼Œ$a_1, a_2, \ldots, a_k$ æ˜¯ä»»æ„æ•´æ•°ï¼Œåˆ™åŒä½™æ–¹ç¨‹ç»„ï¼š
$$x \equiv a_i \pmod{m_i}, \quad i = 1, 2, \ldots, k$$
æœ‰å”¯ä¸€è§£æ¨¡ $M = m_1 m_2 \cdots m_k$ã€‚

**è¯æ˜**:
**å­˜åœ¨æ€§**: æ„é€ è§£ $x = \sum_{i=1}^k a_i M_i M_i'$ï¼Œå…¶ä¸­ $M_i = M/m_i$ï¼Œ$M_i'$ æ˜¯ $M_i$ æ¨¡ $m_i$ çš„é€†å…ƒã€‚

**å”¯ä¸€æ€§**: å¦‚æœ $x_1$ å’Œ $x_2$ éƒ½æ˜¯è§£ï¼Œåˆ™ $x_1 \equiv x_2 \pmod{m_i}$ å¯¹æ‰€æœ‰ $i$ æˆç«‹ã€‚
ç”±äº $m_i$ ä¸¤ä¸¤äº’è´¨ï¼Œ$x_1 \equiv x_2 \pmod{M}$ã€‚

## 5. æ€§èƒ½åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------------|------|
| æ¬§å‡ é‡Œå¾—ç®—æ³• | $O(\log \min(a, b))$ | $O(1)$ | æœ€åæƒ…å†µ |
| æ‰©å±•æ¬§å‡ é‡Œå¾— | $O(\log \min(a, b))$ | $O(1)$ | é€’å½’æ·±åº¦ |
| è´¨å› æ•°åˆ†è§£ | $O(\sqrt{n})$ | $O(\log n)$ | è¯•é™¤æ³• |
| åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³• | $O(n \log \log n)$ | $O(n)$ | ç´ æ•°ç­›æ³• |
| Miller-Rabinæµ‹è¯• | $O(k \log^3 n)$ | $O(1)$ | $k$ æ˜¯æµ‹è¯•æ¬¡æ•° |
| å¿«é€Ÿå¹‚æ¨¡è¿ç®— | $O(\log n)$ | $O(1)$ | äºŒè¿›åˆ¶å±•å¼€ |
| ä¸­å›½å‰©ä½™å®šç† | $O(k \log M)$ | $O(k)$ | $k$ æ˜¯åŒä½™æ–¹ç¨‹æ•° |

### 5.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.1** (æ•°è®ºç®—æ³•ç©ºé—´å¤æ‚åº¦)
å¯¹äºè¾“å…¥å¤§å°ä¸º $n$ çš„æ•°è®ºç®—æ³•ï¼Œå…¶ç©ºé—´å¤æ‚åº¦é€šå¸¸ä¸º $O(\log n)$ã€‚

**è¯æ˜**:
æ•°è®ºç®—æ³•ä¸»è¦å¤„ç†æ•´æ•°è¿ç®—ï¼Œä¸­é—´ç»“æœçš„å¤§å°é€šå¸¸ä¸è¶…è¿‡è¾“å…¥å¤§å°çš„å¸¸æ•°å€ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(\log n)$ã€‚

## 6. æµ‹è¯•éªŒè¯

```python
import unittest
from typing import List, Dict, Any

class NumberTheoryTest(unittest.TestCase):
    """æ•°è®ºæµ‹è¯•ç±»"""
    
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.number_theory = NumberTheory()
        self.prime_generator = PrimeGenerator()
        self.congruence_theory = CongruenceTheory()
    
    def test_gcd(self):
        """æµ‹è¯•æœ€å¤§å…¬çº¦æ•°"""
        self.assertEqual(self.number_theory.gcd(48, 18), 6)
        self.assertEqual(self.number_theory.gcd(0, 5), 5)
        self.assertEqual(self.number_theory.gcd(5, 0), 5)
        self.assertEqual(self.number_theory.gcd(-48, 18), 6)
    
    def test_lcm(self):
        """æµ‹è¯•æœ€å°å…¬å€æ•°"""
        self.assertEqual(self.number_theory.lcm(12, 18), 36)
        self.assertEqual(self.number_theory.lcm(0, 5), 0)
        self.assertEqual(self.number_theory.lcm(5, 0), 0)
    
    def test_extended_gcd(self):
        """æµ‹è¯•æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•"""
        gcd, x, y = self.number_theory.extended_gcd(48, 18)
        self.assertEqual(gcd, 6)
        self.assertEqual(48 * x + 18 * y, gcd)
    
    def test_is_prime(self):
        """æµ‹è¯•ç´ æ•°åˆ¤æ–­"""
        self.assertTrue(self.number_theory.is_prime(2))
        self.assertTrue(self.number_theory.is_prime(3))
        self.assertTrue(self.number_theory.is_prime(17))
        self.assertFalse(self.number_theory.is_prime(1))
        self.assertFalse(self.number_theory.is_prime(4))
        self.assertFalse(self.number_theory.is_prime(15))
    
    def test_prime_factors(self):
        """æµ‹è¯•è´¨å› æ•°åˆ†è§£"""
        factors = self.number_theory.prime_factors(12)
        expected = {2: 2, 3: 1}
        self.assertEqual(factors, expected)
        
        factors = self.number_theory.prime_factors(100)
        expected = {2: 2, 5: 2}
        self.assertEqual(factors, expected)
    
    def test_euler_phi(self):
        """æµ‹è¯•æ¬§æ‹‰å‡½æ•°"""
        self.assertEqual(self.number_theory.euler_phi(1), 1)
        self.assertEqual(self.number_theory.euler_phi(6), 2)
        self.assertEqual(self.number_theory.euler_phi(10), 4)
        self.assertEqual(self.number_theory.euler_phi(12), 4)
    
    def test_mod_inverse(self):
        """æµ‹è¯•æ¨¡é€†å…ƒ"""
        inv = self.number_theory.mod_inverse(3, 11)
        self.assertEqual(inv, 4)
        self.assertEqual((3 * inv) % 11, 1)
        
        # æµ‹è¯•æ— é€†å…ƒçš„æƒ…å†µ
        inv = self.number_theory.mod_inverse(2, 4)
        self.assertIsNone(inv)
    
    def test_chinese_remainder_theorem(self):
        """æµ‹è¯•ä¸­å›½å‰©ä½™å®šç†"""
        remainders = [2, 3, 2]
        moduli = [3, 5, 7]
        
        result = self.number_theory.chinese_remainder_theorem(remainders, moduli)
        self.assertEqual(result, 23)
        
        # éªŒè¯ç»“æœ
        for i, (remainder, modulus) in enumerate(zip(remainders, moduli)):
            self.assertEqual(result % modulus, remainder)
    
    def test_sieve_of_eratosthenes(self):
        """æµ‹è¯•åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•"""
        primes = self.prime_generator.sieve_of_eratosthenes(20)
        expected = [2, 3, 5, 7, 11, 13, 17, 19]
        self.assertEqual(primes, expected)
    
    def test_miller_rabin(self):
        """æµ‹è¯•Miller-Rabinç´ æ€§æµ‹è¯•"""
        # æµ‹è¯•ç´ æ•°
        self.assertTrue(self.prime_generator.miller_rabin_primality_test(17))
        self.assertTrue(self.prime_generator.miller_rabin_primality_test(97))
        
        # æµ‹è¯•åˆæ•°
        self.assertFalse(self.prime_generator.miller_rabin_primality_test(15))
        self.assertFalse(self.prime_generator.miller_rabin_primality_test(100))
    
    def test_linear_congruence(self):
        """æµ‹è¯•çº¿æ€§åŒä½™æ–¹ç¨‹"""
        solutions = self.congruence_theory.solve_linear_congruence(3, 2, 7)
        expected = [3]
        self.assertEqual(solutions, expected)
        
        # éªŒè¯è§£
        for solution in solutions:
            self.assertEqual((3 * solution) % 7, 2)
    
    def test_quadratic_residue(self):
        """æµ‹è¯•äºŒæ¬¡å‰©ä½™"""
        self.assertTrue(self.number_theory.quadratic_residue(1, 7))
        self.assertTrue(self.number_theory.quadratic_residue(2, 7))
        self.assertFalse(self.number_theory.quadratic_residue(3, 7))
    
    def test_legendre_symbol(self):
        """æµ‹è¯•å‹’è®©å¾·ç¬¦å·"""
        self.assertEqual(self.number_theory.legendre_symbol(1, 7), 1)
        self.assertEqual(self.number_theory.legendre_symbol(2, 7), 1)
        self.assertEqual(self.number_theory.legendre_symbol(3, 7), -1)
        self.assertEqual(self.number_theory.legendre_symbol(0, 7), 0)

if __name__ == '__main__':
    unittest.main()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£å…¨é¢é˜è¿°äº†æ•°è®ºåŸºç¡€çš„ç†è®ºä¸å®è·µï¼ŒåŒ…æ‹¬ï¼š

### 7.1 æ ¸å¿ƒè´¡çŒ®

1. **å½¢å¼åŒ–å®šä¹‰**: å»ºç«‹äº†æ•°è®ºåŸºç¡€çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **Pythonå®ç°**: å®ç°äº†å®Œæ•´çš„æ•°è®ºç®—æ³•å’Œå‡½æ•°
3. **å®é™…åº”ç”¨**: æä¾›äº†å¯†ç å­¦å’Œç®—æ³•ä¼˜åŒ–çš„åº”ç”¨æ¡ˆä¾‹
4. **ç†è®ºè¯æ˜**: è¯æ˜äº†é‡è¦çš„æ•°è®ºå®šç†
5. **æ€§èƒ½åˆ†æ**: åˆ†æäº†å„ç§ç®—æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦

### 7.2 æŠ€æœ¯ç‰¹è‰²

1. **å¤šè¡¨å¾æ–¹æ³•**: æ¦‚å¿µè§£é‡Šã€æ•°å­¦å½¢å¼ã€ä»£ç å®ç°ã€å›¾è¡¨è¯´æ˜
2. **å±‚æ¬¡åŒ–ç»„ç»‡**: ä»åŸºç¡€æ¦‚å¿µåˆ°é«˜çº§åº”ç”¨
3. **ä¸¥æ ¼å½¢å¼åŒ–**: æ¯ä¸ªæ¦‚å¿µéƒ½æœ‰ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰
4. **å®é™…åº”ç”¨å¯¼å‘**: ç´§å¯†ç»“åˆè½¯ä»¶å·¥ç¨‹å®è·µ

### 7.3 åº”ç”¨ä»·å€¼

1. **æ•™è‚²ä»·å€¼**: ç³»ç»ŸåŒ–çš„æ•°è®ºå­¦ä¹ èµ„æº
2. **å·¥ç¨‹ä»·å€¼**: å®ç”¨çš„æ•°è®ºå·¥å…·å’Œæ–¹æ³•
3. **ç ”ç©¶ä»·å€¼**: å½¢å¼åŒ–çš„ç†è®ºåŸºç¡€

æ•°è®ºæ˜¯å¯†ç å­¦å’Œç®—æ³•è®¾è®¡çš„é‡è¦åŸºç¡€ï¼Œé€šè¿‡æœ¬æ–‡æ¡£çš„å­¦ä¹ ï¼Œè¯»è€…å¯ä»¥æŒæ¡ä»åŸºç¡€æ•°è®ºæ¦‚å¿µåˆ°é«˜çº§å¯†ç å­¦åº”ç”¨çš„å®Œæ•´çŸ¥è¯†ä½“ç³»ï¼Œä¸ºåç»­çš„å¯†ç å­¦ç ”ç©¶å’Œç®—æ³•ä¼˜åŒ–å¥ å®šåšå®çš„ç†è®ºåŸºç¡€ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*æ–‡æ¡£çŠ¶æ€: å·²å®Œæˆ*
*ä¸‹ä¸€æ­¥: ä»£æ•°åŸºç¡€æ–‡æ¡£*
