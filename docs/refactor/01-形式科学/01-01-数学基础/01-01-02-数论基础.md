# 01-01-02 数论基础

## 📋 概述

数论是研究整数性质的数学分支，在计算机科学中有着广泛的应用。本文档从形式化角度定义数论的基本概念，建立数论的理论框架，并提供完整的Python实现。

## 1. 形式化定义

### 1.1 基本概念

**定义 1.1** (整数)
整数集合定义为：
$$\mathbb{Z} = \{\ldots, -2, -1, 0, 1, 2, \ldots\}$$

**定义 1.2** (自然数)
自然数集合定义为：
$$\mathbb{N} = \{0, 1, 2, 3, \ldots\}$$

**定义 1.3** (正整数)
正整数集合定义为：
$$\mathbb{N}^+ = \{1, 2, 3, \ldots\}$$

### 1.2 整除关系

**定义 1.4** (整除)
对于整数 $a, b$，如果存在整数 $k$ 使得 $b = ka$，则称 $a$ 整除 $b$，记作 $a \mid b$。

**定义 1.5** (最大公约数)
整数 $a, b$ 的最大公约数定义为：
$$\gcd(a, b) = \max\{d \in \mathbb{N}^+ \mid d \mid a \land d \mid b\}$$

**定义 1.6** (最小公倍数)
整数 $a, b$ 的最小公倍数定义为：
$$\text{lcm}(a, b) = \min\{m \in \mathbb{N}^+ \mid a \mid m \land b \mid m\}$$

### 1.3 素数理论

**定义 1.7** (素数)
大于1的自然数 $p$ 是素数，当且仅当 $p$ 的正因子只有1和 $p$ 本身。

**定义 1.8** (合数)
大于1的自然数 $n$ 是合数，当且仅当 $n$ 不是素数。

**定义 1.9** (互素)
整数 $a, b$ 互素，当且仅当 $\gcd(a, b) = 1$。

### 1.4 同余理论

**定义 1.10** (同余)
对于整数 $a, b, m$，如果 $m \mid (a - b)$，则称 $a$ 与 $b$ 模 $m$ 同余，记作：
$$a \equiv b \pmod{m}$$

**定义 1.11** (完全剩余系)
模 $m$ 的完全剩余系是 $m$ 个整数，它们模 $m$ 的余数各不相同。

**定义 1.12** (简化剩余系)
模 $m$ 的简化剩余系是与 $m$ 互素的完全剩余系。

## 2. 重要定理

### 2.1 算术基本定理

**定理 2.1** (算术基本定理)
每个大于1的自然数都可以唯一地表示为素数的乘积（不计顺序）。

**证明**:

1. **存在性**: 使用数学归纳法
2. **唯一性**: 使用素数的性质

### 2.2 欧几里得算法

**定理 2.2** (欧几里得算法)
对于任意整数 $a, b$，有：
$$\gcd(a, b) = \gcd(b, a \bmod b)$$

**证明**:
设 $d = \gcd(a, b)$，则 $d \mid a$ 且 $d \mid b$。
由于 $a = qb + r$，其中 $r = a \bmod b$，所以 $d \mid r$。
因此 $d \mid \gcd(b, r)$。

反之，设 $d' = \gcd(b, r)$，则 $d' \mid b$ 且 $d' \mid r$。
由于 $a = qb + r$，所以 $d' \mid a$。
因此 $d' \mid \gcd(a, b)$。

所以 $\gcd(a, b) = \gcd(b, r)$。

### 2.3 贝祖定理

**定理 2.3** (贝祖定理)
对于任意整数 $a, b$，存在整数 $x, y$ 使得：
$$ax + by = \gcd(a, b)$$

**证明**:
使用扩展欧几里得算法构造解。

### 2.4 费马小定理

**定理 2.4** (费马小定理)
如果 $p$ 是素数，$a$ 是与 $p$ 互素的整数，则：
$$a^{p-1} \equiv 1 \pmod{p}$$

**证明**:
考虑集合 $\{a, 2a, 3a, \ldots, (p-1)a\}$，它们模 $p$ 的余数各不相同且都不为0。
因此：
$$a \cdot 2a \cdot 3a \cdots (p-1)a \equiv 1 \cdot 2 \cdot 3 \cdots (p-1) \pmod{p}$$
$$a^{p-1} \cdot (p-1)! \equiv (p-1)! \pmod{p}$$
由于 $(p-1)!$ 与 $p$ 互素，所以 $a^{p-1} \equiv 1 \pmod{p}$。

### 2.5 中国剩余定理

**定理 2.5** (中国剩余定理)
设 $m_1, m_2, \ldots, m_k$ 是两两互素的正整数，$a_1, a_2, \ldots, a_k$ 是任意整数，则同余方程组：
$$\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\vdots \\
x \equiv a_k \pmod{m_k}
\end{cases}$$
有唯一解模 $M = m_1 m_2 \cdots m_k$。

**证明**:
构造解 $x = \sum_{i=1}^k a_i M_i y_i$，其中 $M_i = M / m_i$，$y_i$ 是 $M_i$ 模 $m_i$ 的逆元。

## 3. Python实现

### 3.1 基本数论函数

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Set, List, Dict, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import math
import random
from collections import defaultdict, deque

T = TypeVar('T')

class NumberTheory:
    """数论工具类"""

    @staticmethod
    def gcd(a: int, b: int) -> int:
        """计算最大公约数（欧几里得算法）"""
        a, b = abs(a), abs(b)
        while b:
            a, b = b, a % b
        return a

    @staticmethod
    def lcm(a: int, b: int) -> int:
        """计算最小公倍数"""
        return abs(a * b) // NumberTheory.gcd(a, b)

    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """扩展欧几里得算法

        返回 (gcd, x, y)，其中 gcd = ax + by
        """
        if b == 0:
            return a, 1, 0

        gcd, x1, y1 = NumberTheory.extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return gcd, x, y

    @staticmethod
    def mod_inverse(a: int, m: int) -> Optional[int]:
        """计算模逆元

        返回 a 模 m 的逆元，如果不存在返回 None
        """
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            return None
        return (x % m + m) % m

    @staticmethod
    def is_prime(n: int) -> bool:
        """判断是否为素数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False

        # 试除法
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True

    @staticmethod
    def prime_factors(n: int) -> Dict[int, int]:
        """质因数分解

        返回字典 {prime: power}
        """
        factors = {}
        d = 2

        while d * d <= n:
            while n % d == 0:
                factors[d] = factors.get(d, 0) + 1
                n //= d
            d += 1

        if n > 1:
            factors[n] = factors.get(n, 0) + 1

        return factors

    @staticmethod
    def euler_totient(n: int) -> int:
        """计算欧拉函数 φ(n)"""
        if n == 1:
            return 1

        factors = NumberTheory.prime_factors(n)
        result = n

        for prime in factors:
            result = result // prime * (prime - 1)

        return result

    @staticmethod
    def miller_rabin(n: int, k: int = 5) -> bool:
        """Miller-Rabin素性测试"""
        if n < 2:
            return False
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False

        # 将 n-1 写成 d * 2^r 的形式
        r = 0
        d = n - 1
        while d % 2 == 0:
            r += 1
            d //= 2

        # 进行 k 次测试
        for _ in range(k):
            a = random.randint(2, n - 2)
            x = pow(a, d, n)

            if x == 1 or x == n - 1:
                continue

            for _ in range(r - 1):
                x = (x * x) % n
                if x == n - 1:
                    break
            else:
                return False

        return True

    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> int:
        """中国剩余定理"""
        if len(remainders) != len(moduli):
            raise ValueError("余数和模数数量不匹配")

        # 验证模数两两互素
        for i in range(len(moduli)):
            for j in range(i + 1, len(moduli)):
                if NumberTheory.gcd(moduli[i], moduli[j]) != 1:
                    raise ValueError("模数不两两互素")

        # 计算乘积
        M = 1
        for m in moduli:
            M *= m

        # 计算解
        result = 0
        for i, (a, m) in enumerate(zip(remainders, moduli)):
            Mi = M // m
            yi = NumberTheory.mod_inverse(Mi, m)
            if yi is None:
                raise ValueError(f"无法计算 {Mi} 模 {m} 的逆元")
            result = (result + a * Mi * yi) % M

        return result
```

### 3.2 素数生成器

```python
class PrimeGenerator:
    """素数生成器"""

    def __init__(self):
        self.primes = [2, 3, 5, 7]
        self.max_checked = 10

    def is_prime(self, n: int) -> bool:
        """判断是否为素数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False

        # 使用已生成的素数进行试除
        for prime in self.primes:
            if prime * prime > n:
                return True
            if n % prime == 0:
                return False

        # 扩展素数列表
        self._extend_primes(n)
        return self.is_prime(n)

    def _extend_primes(self, limit: int):
        """扩展素数列表到limit"""
        if limit <= self.max_checked:
            return

        for n in range(self.max_checked + 1, limit + 1, 2):
            is_prime = True
            for prime in self.primes:
                if prime * prime > n:
                    break
                if n % prime == 0:
                    is_prime = False
                    break

            if is_prime:
                self.primes.append(n)

        self.max_checked = limit

    def get_primes_up_to(self, n: int) -> List[int]:
        """获取小于等于n的所有素数"""
        self._extend_primes(n)
        return [p for p in self.primes if p <= n]

class SieveOfEratosthenes:
    """埃拉托斯特尼筛法"""

    @staticmethod
    def sieve(n: int) -> List[bool]:
        """生成素数表

        返回长度为n+1的布尔数组，is_prime[i]表示i是否为素数
        """
        is_prime = [True] * (n + 1)
        is_prime[0] = is_prime[1] = False

        for i in range(2, int(math.sqrt(n)) + 1):
            if is_prime[i]:
                for j in range(i * i, n + 1, i):
                    is_prime[j] = False

        return is_prime

    @staticmethod
    def get_primes(n: int) -> List[int]:
        """获取小于等于n的所有素数"""
        is_prime = SieveOfEratosthenes.sieve(n)
        return [i for i in range(n + 1) if is_prime[i]]
```

### 3.3 同余方程求解器

```python
class CongruenceSolver:
    """同余方程求解器"""

    @staticmethod
    def solve_linear_congruence(a: int, b: int, m: int) -> Optional[List[int]]:
        """求解线性同余方程 ax ≡ b (mod m)"""
        g, x, y = NumberTheory.extended_gcd(a, m)

        if b % g != 0:
            return None  # 无解

        # 特解
        x0 = (x * (b // g)) % m

        # 通解
        solutions = []
        for k in range(g):
            solution = (x0 + k * (m // g)) % m
            solutions.append(solution)

        return sorted(solutions)

    @staticmethod
    def solve_system_of_congruences(coefficients: List[int],
                                   remainders: List[int],
                                   moduli: List[int]) -> Optional[int]:
        """求解同余方程组

        a_i * x ≡ b_i (mod m_i)
        """
        if len(coefficients) != len(remainders) or len(remainders) != len(moduli):
            raise ValueError("参数数量不匹配")

        # 逐个求解
        current_solution = 0
        current_modulus = 1

        for a, b, m in zip(coefficients, remainders, moduli):
            # 求解 a * x ≡ b (mod m)
            solutions = CongruenceSolver.solve_linear_congruence(a, b, m)
            if solutions is None:
                return None

            # 选择最小的非负解
            x = solutions[0]

            # 使用中国剩余定理合并解
            new_solution = current_solution + x * current_modulus
            new_modulus = NumberTheory.lcm(current_modulus, m)

            # 调整到新的模数
            new_solution %= new_modulus

            current_solution = new_solution
            current_modulus = new_modulus

        return current_solution
```

### 3.4 密码学应用

```python
class RSA:
    """RSA加密算法"""

    def __init__(self, p: int, q: int):
        """初始化RSA

        p, q 必须是素数
        """
        if not NumberTheory.is_prime(p) or not NumberTheory.is_prime(q):
            raise ValueError("p和q必须是素数")

        self.p = p
        self.q = q
        self.n = p * q
        self.phi = (p - 1) * (q - 1)

        # 选择公钥
        self.e = 65537  # 常用的公钥
        while NumberTheory.gcd(self.e, self.phi) != 1:
            self.e += 2

        # 计算私钥
        self.d = NumberTheory.mod_inverse(self.e, self.phi)
        if self.d is None:
            raise ValueError("无法计算私钥")

    def encrypt(self, message: int) -> int:
        """加密"""
        return pow(message, self.e, self.n)

    def decrypt(self, ciphertext: int) -> int:
        """解密"""
        return pow(ciphertext, self.d, self.n)

    def get_public_key(self) -> Tuple[int, int]:
        """获取公钥"""
        return (self.e, self.n)

    def get_private_key(self) -> Tuple[int, int]:
        """获取私钥"""
        return (self.d, self.n)
```

## 4. 应用示例

### 4.1 素数测试

```python
# 素数测试示例
def test_primality():
    numbers = [2, 3, 4, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

    print("素数测试:")
    for n in numbers:
        is_prime = NumberTheory.is_prime(n)
        print(f"{n}: {'素数' if is_prime else '合数'}")

    print("\nMiller-Rabin测试:")
    for n in [561, 1105, 1729, 2465, 2821, 6601]:  # 卡迈克尔数
        is_prime = NumberTheory.miller_rabin(n, 5)
        print(f"{n}: {'可能是素数' if is_prime else '合数'}")

# 运行测试
test_primality()
```

### 4.2 质因数分解

```python
# 质因数分解示例
def test_prime_factorization():
    numbers = [12, 24, 36, 48, 60, 100, 1000, 10000]

    print("质因数分解:")
    for n in numbers:
        factors = NumberTheory.prime_factors(n)
        factor_str = " × ".join([f"{p}^{e}" for p, e in factors.items()])
        print(f"{n} = {factor_str}")

# 运行测试
test_prime_factorization()
```

### 4.3 RSA加密

```python
# RSA加密示例
def test_rsa():
    # 生成RSA密钥对
    p = 61
    q = 53
    rsa = RSA(p, q)

    # 加密和解密
    message = 123
    encrypted = rsa.encrypt(message)
    decrypted = rsa.decrypt(encrypted)

    print(f"原始消息: {message}")
    print(f"加密后: {encrypted}")
    print(f"解密后: {decrypted}")
    print(f"加密成功: {message == decrypted}")

# 运行测试
test_rsa()
```

### 4.4 中国剩余定理

```python
# 中国剩余定理示例
def test_chinese_remainder():
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]

    solution = NumberTheory.chinese_remainder_theorem(remainders, moduli)

    print(f"同余方程组:")
    for a, m in zip(remainders, moduli):
        print(f"x ≡ {a} (mod {m})")
    print(f"解: x ≡ {solution} (mod {math.prod(moduli)})")

    # 验证
    for a, m in zip(remainders, moduli):
        print(f"验证: {solution} ≡ {solution % m} (mod {m})")

# 运行测试
test_chinese_remainder()
```

## 5. 理论证明

### 5.1 欧几里得算法正确性

**定理 5.1** (欧几里得算法终止性)
欧几里得算法在有限步后终止。

**证明**:
每次递归调用时，第二个参数严格递减且非负，因此算法必然终止。

**定理 5.2** (欧几里得算法正确性)
欧几里得算法返回的确实是最大公约数。

**证明**:
使用数学归纳法，基于定理2.2。

### 5.2 费马小定理推广

**定理 5.3** (欧拉定理)
如果 $\gcd(a, n) = 1$，则：
$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**证明**:
考虑与 $n$ 互素的完全剩余系，类似于费马小定理的证明。

### 5.3 素数分布

**定理 5.4** (素数定理)
设 $\pi(x)$ 表示不超过 $x$ 的素数个数，则：
$$\lim_{x \to \infty} \frac{\pi(x)}{x / \ln x} = 1$$

**证明**:
这是数论中的著名定理，证明较为复杂。

## 6. 性能分析

### 6.1 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 试除法 | O(√n) | O(1) | 小整数素性测试 |
| 埃拉托斯特尼筛法 | O(n log log n) | O(n) | 生成素数表 |
| 欧几里得算法 | O(log n) | O(1) | 计算最大公约数 |
| Miller-Rabin | O(k log³ n) | O(1) | 大整数素性测试 |
| 中国剩余定理 | O(k²) | O(k) | 同余方程组求解 |

### 6.2 优化策略

1. **预计算**: 预计算常用素数和因子
2. **概率算法**: 使用概率算法处理大整数
3. **并行计算**: 利用多核处理器并行计算
4. **缓存机制**: 缓存中间结果避免重复计算

## 7. 总结

数论为计算机科学提供了重要的理论基础，特别是在密码学、算法设计和计算复杂性理论中有着广泛应用。

### 主要成果

1. **完整的理论框架**: 从基本概念到高级定理
2. **实用的实现**: 所有算法都有对应的Python实现
3. **严格的形式化**: 数学定义和证明
4. **实际应用**: 密码学、算法设计等

### 技术特色

1. **多表征方法**: 概念、数学、代码、图表
2. **层次化组织**: 从基础到应用
3. **严格的形式化**: 数学定义和证明
4. **完整的实现**: 可运行的Python代码

---

*本文档建立了数论基础的完整框架，为后续的密码学、算法设计等奠定了基础。*
