# 数论基础

## 📋 概述

数论是研究整数性质的数学分支，在密码学、算法设计和计算机科学中具有重要应用。本文档从形式化定义、素数理论、同余理论等多个维度全面阐述数论基础的理论与实践。

## 1. 形式化定义

### 1.1 整除关系的形式化定义

**定义 1.1** (整除)
对于整数 $a, b$，如果存在整数 $k$ 使得 $b = ak$，则称 $a$ 整除 $b$，记作 $a \mid b$。

形式化定义为：
$$a \mid b \iff \exists k \in \mathbb{Z}: b = ak$$

**定义 1.2** (最大公约数)
整数 $a, b$ 的最大公约数 $d = \gcd(a, b)$ 是满足以下条件的最大正整数：
1. $d \mid a$ 且 $d \mid b$
2. 对于任意 $c$，如果 $c \mid a$ 且 $c \mid b$，则 $c \mid d$

**定义 1.3** (最小公倍数)
整数 $a, b$ 的最小公倍数 $m = \text{lcm}(a, b)$ 是满足以下条件的最小正整数：
1. $a \mid m$ 且 $b \mid m$
2. 对于任意 $c$，如果 $a \mid c$ 且 $b \mid c$，则 $m \mid c$

### 1.2 素数理论的形式化定义

**定义 1.4** (素数)
正整数 $p > 1$ 是素数，当且仅当 $p$ 的正因子只有 $1$ 和 $p$ 本身。

形式化定义为：
$$\text{Prime}(p) \iff p > 1 \land \forall d \in \mathbb{Z}^+: (d \mid p \rightarrow d = 1 \lor d = p)$$

**定义 1.5** (素数计数函数)
素数计数函数 $\pi(x)$ 定义为不超过 $x$ 的素数个数：
$$\pi(x) = |\{p \leq x \mid \text{Prime}(p)\}|$$

**定义 1.6** (欧拉函数)
欧拉函数 $\phi(n)$ 定义为与 $n$ 互质的正整数个数：
$$\phi(n) = |\{k \in \mathbb{Z}^+ \mid k \leq n \land \gcd(k, n) = 1\}|$$

### 1.3 同余理论的形式化定义

**定义 1.7** (同余)
对于整数 $a, b, m$，如果 $m \mid (a - b)$，则称 $a$ 与 $b$ 模 $m$ 同余，记作 $a \equiv b \pmod{m}$。

形式化定义为：
$$a \equiv b \pmod{m} \iff m \mid (a - b)$$

**定义 1.8** (同余类)
模 $m$ 的同余类 $[a]_m$ 定义为：
$$[a]_m = \{b \in \mathbb{Z} \mid b \equiv a \pmod{m}\}$$

**定义 1.9** (完全剩余系)
模 $m$ 的完全剩余系是 $m$ 个两两不同余的整数集合。

## 2. Python实现

### 2.1 基础数论函数

```python
from abc import ABC, abstractmethod
from typing import List, Tuple, Optional, Set, Dict, Any
from dataclasses import dataclass
from enum import Enum
import math
import random

class NumberTheory:
    """数论基础类"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """欧几里得算法求最大公约数"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """求最小公倍数"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """扩展欧几里得算法"""
        if b == 0:
            return a, 1, 0
        
        gcd, x1, y1 = NumberTheory.extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        
        return gcd, x, y
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """判断是否为素数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        # 只需要检查到 sqrt(n)
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def prime_factors(n: int) -> Dict[int, int]:
        """质因数分解"""
        factors = {}
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors[d] = factors.get(d, 0) + 1
                n //= d
            d += 1
        
        if n > 1:
            factors[n] = factors.get(n, 0) + 1
        
        return factors
    
    @staticmethod
    def euler_phi(n: int) -> int:
        """欧拉函数"""
        if n == 1:
            return 1
        
        factors = NumberTheory.prime_factors(n)
        result = n
        
        for prime in factors:
            result = result // prime * (prime - 1)
        
        return result
    
    @staticmethod
    def mod_inverse(a: int, m: int) -> Optional[int]:
        """模逆元"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        
        if gcd != 1:
            return None  # 不存在逆元
        
        return (x % m + m) % m
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], 
                                 moduli: List[int]) -> Optional[int]:
        """中国剩余定理"""
        if len(remainders) != len(moduli):
            return None
        
        # 计算总模数
        M = 1
        for m in moduli:
            M *= m
        
        result = 0
        
        for i, (remainder, modulus) in enumerate(zip(remainders, moduli)):
            Mi = M // modulus
            Mi_inv = NumberTheory.mod_inverse(Mi, modulus)
            
            if Mi_inv is None:
                return None
            
            result = (result + remainder * Mi * Mi_inv) % M
        
        return result
    
    @staticmethod
    def quadratic_residue(a: int, p: int) -> bool:
        """判断二次剩余"""
        if not NumberTheory.is_prime(p) or p == 2:
            return True
        
        # 欧拉判别法
        return pow(a, (p - 1) // 2, p) == 1
    
    @staticmethod
    def legendre_symbol(a: int, p: int) -> int:
        """勒让德符号"""
        if not NumberTheory.is_prime(p):
            raise ValueError("p必须是素数")
        
        if a % p == 0:
            return 0
        
        if NumberTheory.quadratic_residue(a, p):
            return 1
        else:
            return -1

class PrimeGenerator:
    """素数生成器"""
    
    @staticmethod
    def sieve_of_eratosthenes(n: int) -> List[int]:
        """埃拉托斯特尼筛法"""
        if n < 2:
            return []
        
        # 初始化筛子
        is_prime = [True] * (n + 1)
        is_prime[0] = is_prime[1] = False
        
        # 筛法
        for i in range(2, int(math.sqrt(n)) + 1):
            if is_prime[i]:
                for j in range(i * i, n + 1, i):
                    is_prime[j] = False
        
        # 收集素数
        primes = [i for i in range(n + 1) if is_prime[i]]
        return primes
    
    @staticmethod
    def miller_rabin_primality_test(n: int, k: int = 5) -> bool:
        """Miller-Rabin素性测试"""
        if n < 2:
            return False
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False
        
        # 将 n-1 写成 d * 2^r 的形式
        r = 0
        d = n - 1
        while d % 2 == 0:
            r += 1
            d //= 2
        
        # 进行k次测试
        for _ in range(k):
            a = random.randint(2, n - 2)
            x = pow(a, d, n)
            
            if x == 1 or x == n - 1:
                continue
            
            for _ in range(r - 1):
                x = (x * x) % n
                if x == n - 1:
                    break
            else:
                return False
        
        return True
    
    @staticmethod
    def generate_prime(bits: int) -> int:
        """生成指定位数的素数"""
        while True:
            # 生成随机奇数
            n = random.getrandbits(bits)
            n |= 1  # 确保是奇数
            n |= (1 << (bits - 1))  # 确保有指定位数
            
            if NumberTheory.miller_rabin_primality_test(n):
                return n

class CongruenceTheory:
    """同余理论"""
    
    @staticmethod
    def solve_linear_congruence(a: int, b: int, m: int) -> List[int]:
        """解线性同余方程 ax ≡ b (mod m)"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        
        if b % gcd != 0:
            return []  # 无解
        
        # 特解
        x0 = (x * (b // gcd)) % m
        
        # 通解
        solutions = []
        for i in range(gcd):
            solution = (x0 + i * (m // gcd)) % m
            solutions.append(solution)
        
        return sorted(solutions)
    
    @staticmethod
    def solve_system_of_congruences(remainders: List[int], 
                                   moduli: List[int]) -> Optional[int]:
        """解同余方程组"""
        return NumberTheory.chinese_remainder_theorem(remainders, moduli)
    
    @staticmethod
    def discrete_logarithm(base: int, value: int, modulus: int) -> Optional[int]:
        """离散对数"""
        if not NumberTheory.is_prime(modulus):
            raise ValueError("模数必须是素数")
        
        # 使用大步小步算法
        m = int(math.sqrt(modulus)) + 1
        
        # 计算小步
        baby_steps = {}
        current = 1
        for j in range(m):
            baby_steps[current] = j
            current = (current * base) % modulus
        
        # 计算大步
        factor = pow(base, m * (modulus - 2), modulus)
        current = value
        
        for i in range(m):
            if current in baby_steps:
                return i * m + baby_steps[current]
            current = (current * factor) % modulus
        
        return None  # 无解

class NumberTheoryAnalyzer:
    """数论分析器"""
    
    def __init__(self):
        self.prime_generator = PrimeGenerator()
        self.congruence_theory = CongruenceTheory()
    
    def analyze_number_properties(self, n: int) -> Dict[str, Any]:
        """分析数的性质"""
        properties = {
            'is_prime': NumberTheory.is_prime(n),
            'prime_factors': NumberTheory.prime_factors(n),
            'euler_phi': NumberTheory.euler_phi(n),
            'divisors': self._get_divisors(n),
            'sum_of_divisors': self._sum_of_divisors(n),
            'number_of_divisors': self._number_of_divisors(n)
        }
        
        return properties
    
    def _get_divisors(self, n: int) -> List[int]:
        """获取所有正因子"""
        if n == 0:
            return []
        
        divisors = set()
        for i in range(1, int(math.sqrt(abs(n))) + 1):
            if n % i == 0:
                divisors.add(i)
                divisors.add(n // i)
        
        return sorted(divisors)
    
    def _sum_of_divisors(self, n: int) -> int:
        """因子和"""
        if n == 0:
            return 0
        
        factors = NumberTheory.prime_factors(abs(n))
        result = 1
        
        for prime, power in factors.items():
            result *= (prime ** (power + 1) - 1) // (prime - 1)
        
        return result
    
    def _number_of_divisors(self, n: int) -> int:
        """因子个数"""
        if n == 0:
            return 0
        
        factors = NumberTheory.prime_factors(abs(n))
        result = 1
        
        for power in factors.values():
            result *= (power + 1)
        
        return result
    
    def analyze_prime_distribution(self, limit: int) -> Dict[str, Any]:
        """分析素数分布"""
        primes = self.prime_generator.sieve_of_eratosthenes(limit)
        
        analysis = {
            'total_primes': len(primes),
            'prime_density': len(primes) / limit,
            'largest_prime': max(primes) if primes else 0,
            'prime_gaps': self._calculate_prime_gaps(primes),
            'twin_primes': self._count_twin_primes(primes)
        }
        
        return analysis
    
    def _calculate_prime_gaps(self, primes: List[int]) -> List[int]:
        """计算素数间隔"""
        gaps = []
        for i in range(1, len(primes)):
            gaps.append(primes[i] - primes[i-1])
        return gaps
    
    def _count_twin_primes(self, primes: List[int]) -> int:
        """计算孪生素数对"""
        count = 0
        for i in range(1, len(primes)):
            if primes[i] - primes[i-1] == 2:
                count += 1
        return count
```

## 3. 实际应用示例

### 3.1 密码学应用

```python
class CryptographyApplications:
    """密码学应用"""
    
    def __init__(self):
        self.prime_generator = PrimeGenerator()
    
    def rsa_key_generation(self, bits: int = 1024) -> Tuple[Tuple[int, int], Tuple[int, int]]:
        """RSA密钥生成"""
        # 生成两个大素数
        p = self.prime_generator.generate_prime(bits // 2)
        q = self.prime_generator.generate_prime(bits // 2)
        
        n = p * q
        phi_n = (p - 1) * (q - 1)
        
        # 选择公钥指数
        e = 65537  # 常用的公钥指数
        
        # 计算私钥指数
        d = NumberTheory.mod_inverse(e, phi_n)
        
        if d is None:
            raise ValueError("无法生成有效的私钥")
        
        public_key = (e, n)
        private_key = (d, n)
        
        return public_key, private_key
    
    def rsa_encrypt(self, message: int, public_key: Tuple[int, int]) -> int:
        """RSA加密"""
        e, n = public_key
        return pow(message, e, n)
    
    def rsa_decrypt(self, ciphertext: int, private_key: Tuple[int, int]) -> int:
        """RSA解密"""
        d, n = private_key
        return pow(ciphertext, d, n)
    
    def diffie_hellman_key_exchange(self, bits: int = 1024) -> Tuple[Dict, Dict]:
        """Diffie-Hellman密钥交换"""
        # 生成大素数p和原根g
        p = self.prime_generator.generate_prime(bits)
        
        # 简化：使用2作为原根（实际应用中需要验证）
        g = 2
        
        # Alice生成私钥
        a = random.randint(2, p - 2)
        A = pow(g, a, p)
        
        # Bob生成私钥
        b = random.randint(2, p - 2)
        B = pow(g, b, p)
        
        # 计算共享密钥
        shared_key_alice = pow(B, a, p)
        shared_key_bob = pow(A, b, p)
        
        # 验证密钥一致性
        assert shared_key_alice == shared_key_bob
        
        alice_info = {
            'private_key': a,
            'public_key': A,
            'shared_key': shared_key_alice
        }
        
        bob_info = {
            'private_key': b,
            'public_key': B,
            'shared_key': shared_key_bob
        }
        
        return alice_info, bob_info
    
    def elgamal_encryption(self, message: int, bits: int = 1024) -> Tuple[Dict, Dict]:
        """ElGamal加密"""
        # 生成密钥
        p = self.prime_generator.generate_prime(bits)
        g = 2  # 简化处理
        
        # 私钥
        x = random.randint(2, p - 2)
        # 公钥
        y = pow(g, x, p)
        
        # 加密
        k = random.randint(2, p - 2)
        c1 = pow(g, k, p)
        c2 = (message * pow(y, k, p)) % p
        
        public_key = (p, g, y)
        private_key = x
        ciphertext = (c1, c2)
        
        return {
            'public_key': public_key,
            'private_key': private_key,
            'ciphertext': ciphertext
        }
    
    def elgamal_decrypt(self, ciphertext: Tuple[int, int], 
                       private_key: int, public_key: Tuple[int, int, int]) -> int:
        """ElGamal解密"""
        p, g, y = public_key
        c1, c2 = ciphertext
        x = private_key
        
        # 计算共享密钥
        s = pow(c1, x, p)
        s_inv = NumberTheory.mod_inverse(s, p)
        
        # 解密
        message = (c2 * s_inv) % p
        return message

# 使用示例
def cryptography_example():
    """密码学应用示例"""
    crypto = CryptographyApplications()
    
    # RSA示例
    print("=== RSA密钥生成 ===")
    public_key, private_key = crypto.rsa_key_generation(256)  # 使用小位数便于演示
    print(f"公钥: {public_key}")
    print(f"私钥: {private_key}")
    
    message = 12345
    encrypted = crypto.rsa_encrypt(message, public_key)
    decrypted = crypto.rsa_decrypt(encrypted, private_key)
    print(f"原始消息: {message}")
    print(f"加密后: {encrypted}")
    print(f"解密后: {decrypted}")
    print(f"解密成功: {message == decrypted}")
    
    # Diffie-Hellman示例
    print("\n=== Diffie-Hellman密钥交换 ===")
    alice_info, bob_info = crypto.diffie_hellman_key_exchange(256)
    print(f"Alice的共享密钥: {alice_info['shared_key']}")
    print(f"Bob的共享密钥: {bob_info['shared_key']}")
    print(f"密钥交换成功: {alice_info['shared_key'] == bob_info['shared_key']}")

if __name__ == "__main__":
    cryptography_example()
```

### 3.2 算法优化应用

```python
class AlgorithmOptimization:
    """算法优化应用"""
    
    def __init__(self):
        self.number_theory = NumberTheory()
    
    def fast_power_mod(self, base: int, exponent: int, modulus: int) -> int:
        """快速幂模运算"""
        result = 1
        base = base % modulus
        
        while exponent > 0:
            if exponent % 2 == 1:
                result = (result * base) % modulus
            base = (base * base) % modulus
            exponent //= 2
        
        return result
    
    def lucas_sequence(self, n: int, p: int, q: int, modulus: int) -> int:
        """Lucas序列计算"""
        if n == 0:
            return 0
        elif n == 1:
            return 1
        
        # 使用矩阵快速幂
        def matrix_multiply(a: List[List[int]], b: List[List[int]]) -> List[List[int]]:
            result = [[0, 0], [0, 0]]
            for i in range(2):
                for j in range(2):
                    for k in range(2):
                        result[i][j] = (result[i][j] + a[i][k] * b[k][j]) % modulus
            return result
        
        def matrix_power(matrix: List[List[int]], power: int) -> List[List[int]]:
            result = [[1, 0], [0, 1]]  # 单位矩阵
            while power > 0:
                if power % 2 == 1:
                    result = matrix_multiply(result, matrix)
                matrix = matrix_multiply(matrix, matrix)
                power //= 2
            return result
        
        # Lucas序列的转移矩阵
        matrix = [[p, -q], [1, 0]]
        powered_matrix = matrix_power(matrix, n - 1)
        
        return (powered_matrix[0][0] * 1 + powered_matrix[0][1] * 0) % modulus
    
    def prime_factorization_optimization(self, n: int) -> Dict[int, int]:
        """优化的质因数分解"""
        factors = {}
        
        # 处理2的因子
        while n % 2 == 0:
            factors[2] = factors.get(2, 0) + 1
            n //= 2
        
        # 处理奇数因子
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            while n % i == 0:
                factors[i] = factors.get(i, 0) + 1
                n //= i
        
        if n > 1:
            factors[n] = factors.get(n, 0) + 1
        
        return factors
    
    def gcd_optimization(self, a: int, b: int) -> int:
        """优化的最大公约数算法"""
        # 使用二进制GCD算法
        if a == 0:
            return b
        if b == 0:
            return a
        
        # 计算2的幂次
        shift = 0
        while ((a | b) & 1) == 0:
            a >>= 1
            b >>= 1
            shift += 1
        
        # 移除a中的2因子
        while (a & 1) == 0:
            a >>= 1
        
        while b != 0:
            # 移除b中的2因子
            while (b & 1) == 0:
                b >>= 1
            
            # 比较a和b
            if a > b:
                a, b = b, a
            b -= a
        
        return a << shift
    
    def modular_arithmetic_optimization(self, operations: List[Tuple[str, int, int, int]]) -> List[int]:
        """模运算优化"""
        results = []
        
        for op, a, b, m in operations:
            if op == "add":
                result = (a + b) % m
            elif op == "sub":
                result = (a - b) % m
            elif op == "mul":
                result = (a * b) % m
            elif op == "pow":
                result = self.fast_power_mod(a, b, m)
            elif op == "inv":
                result = NumberTheory.mod_inverse(a, m)
                if result is None:
                    result = -1  # 表示无逆元
            else:
                result = -1  # 未知操作
            
            results.append(result)
        
        return results

# 使用示例
def algorithm_optimization_example():
    """算法优化应用示例"""
    optimizer = AlgorithmOptimization()
    
    # 快速幂模运算
    print("=== 快速幂模运算 ===")
    base, exp, mod = 2, 100, 1000000007
    result = optimizer.fast_power_mod(base, exp, mod)
    print(f"{base}^{exp} mod {mod} = {result}")
    
    # Lucas序列
    print("\n=== Lucas序列 ===")
    n, p, q, mod = 10, 1, -1, 1000000007
    lucas_result = optimizer.lucas_sequence(n, p, q, mod)
    print(f"Lucas({n}, {p}, {q}) mod {mod} = {lucas_result}")
    
    # 质因数分解优化
    print("\n=== 质因数分解优化 ===")
    number = 123456789
    factors = optimizer.prime_factorization_optimization(number)
    print(f"{number} = {factors}")
    
    # 模运算优化
    print("\n=== 模运算优化 ===")
    operations = [
        ("add", 123, 456, 1000),
        ("mul", 123, 456, 1000),
        ("pow", 2, 10, 1000),
        ("inv", 7, 0, 11)
    ]
    
    results = optimizer.modular_arithmetic_optimization(operations)
    for i, (op, a, b, m) in enumerate(operations):
        print(f"{op}({a}, {b}) mod {m} = {results[i]}")

if __name__ == "__main__":
    algorithm_optimization_example()
```

## 4. 理论证明

### 4.1 欧几里得算法正确性证明

**定理 4.1** (欧几里得算法正确性)
对于任意整数 $a, b$，欧几里得算法 $\gcd(a, b)$ 返回 $a$ 和 $b$ 的最大公约数。

**证明**:
设 $d = \gcd(a, b)$，我们需要证明算法返回的 $d$ 满足：
1. $d \mid a$ 且 $d \mid b$
2. 对于任意 $c$，如果 $c \mid a$ 且 $c \mid b$，则 $c \mid d$

**步骤 1**: 证明 $d \mid a$ 且 $d \mid b$
在算法的每一步，我们有 $a = qb + r$，其中 $0 \leq r < b$。
如果 $d \mid b$ 且 $d \mid r$，则 $d \mid a$。
算法最终返回 $b$（当 $r = 0$ 时），因此 $d \mid a$ 且 $d \mid b$。

**步骤 2**: 证明最大性
对于任意 $c$，如果 $c \mid a$ 且 $c \mid b$，则 $c \mid r$。
因此 $c \mid d$，证明了 $d$ 是最大公约数。

### 4.2 费马小定理证明

**定理 4.2** (费马小定理)
如果 $p$ 是素数，$a$ 是与 $p$ 互质的整数，则：
$$a^{p-1} \equiv 1 \pmod{p}$$

**证明**:
考虑集合 $S = \{1, 2, \ldots, p-1\}$ 和 $aS = \{a, 2a, \ldots, (p-1)a\}$。

由于 $a$ 与 $p$ 互质，$aS$ 中的元素模 $p$ 两两不同余。
因此 $S$ 和 $aS$ 模 $p$ 是相同的集合。

因此：
$$\prod_{i=1}^{p-1} i \equiv \prod_{i=1}^{p-1} (ai) \pmod{p}$$

$$(p-1)! \equiv a^{p-1} \cdot (p-1)! \pmod{p}$$

由于 $(p-1)!$ 与 $p$ 互质，可以两边同除：
$$1 \equiv a^{p-1} \pmod{p}$$

### 4.3 中国剩余定理证明

**定理 4.3** (中国剩余定理)
设 $m_1, m_2, \ldots, m_k$ 是两两互质的正整数，$a_1, a_2, \ldots, a_k$ 是任意整数，则同余方程组：
$$x \equiv a_i \pmod{m_i}, \quad i = 1, 2, \ldots, k$$
有唯一解模 $M = m_1 m_2 \cdots m_k$。

**证明**:
**存在性**: 构造解 $x = \sum_{i=1}^k a_i M_i M_i'$，其中 $M_i = M/m_i$，$M_i'$ 是 $M_i$ 模 $m_i$ 的逆元。

**唯一性**: 如果 $x_1$ 和 $x_2$ 都是解，则 $x_1 \equiv x_2 \pmod{m_i}$ 对所有 $i$ 成立。
由于 $m_i$ 两两互质，$x_1 \equiv x_2 \pmod{M}$。

## 5. 性能分析

### 5.1 时间复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 欧几里得算法 | $O(\log \min(a, b))$ | $O(1)$ | 最坏情况 |
| 扩展欧几里得 | $O(\log \min(a, b))$ | $O(1)$ | 递归深度 |
| 质因数分解 | $O(\sqrt{n})$ | $O(\log n)$ | 试除法 |
| 埃拉托斯特尼筛法 | $O(n \log \log n)$ | $O(n)$ | 素数筛法 |
| Miller-Rabin测试 | $O(k \log^3 n)$ | $O(1)$ | $k$ 是测试次数 |
| 快速幂模运算 | $O(\log n)$ | $O(1)$ | 二进制展开 |
| 中国剩余定理 | $O(k \log M)$ | $O(k)$ | $k$ 是同余方程数 |

### 5.2 空间复杂度分析

**定理 5.1** (数论算法空间复杂度)
对于输入大小为 $n$ 的数论算法，其空间复杂度通常为 $O(\log n)$。

**证明**:
数论算法主要处理整数运算，中间结果的大小通常不超过输入大小的常数倍，因此空间复杂度为 $O(\log n)$。

## 6. 测试验证

```python
import unittest
from typing import List, Dict, Any

class NumberTheoryTest(unittest.TestCase):
    """数论测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.number_theory = NumberTheory()
        self.prime_generator = PrimeGenerator()
        self.congruence_theory = CongruenceTheory()
    
    def test_gcd(self):
        """测试最大公约数"""
        self.assertEqual(self.number_theory.gcd(48, 18), 6)
        self.assertEqual(self.number_theory.gcd(0, 5), 5)
        self.assertEqual(self.number_theory.gcd(5, 0), 5)
        self.assertEqual(self.number_theory.gcd(-48, 18), 6)
    
    def test_lcm(self):
        """测试最小公倍数"""
        self.assertEqual(self.number_theory.lcm(12, 18), 36)
        self.assertEqual(self.number_theory.lcm(0, 5), 0)
        self.assertEqual(self.number_theory.lcm(5, 0), 0)
    
    def test_extended_gcd(self):
        """测试扩展欧几里得算法"""
        gcd, x, y = self.number_theory.extended_gcd(48, 18)
        self.assertEqual(gcd, 6)
        self.assertEqual(48 * x + 18 * y, gcd)
    
    def test_is_prime(self):
        """测试素数判断"""
        self.assertTrue(self.number_theory.is_prime(2))
        self.assertTrue(self.number_theory.is_prime(3))
        self.assertTrue(self.number_theory.is_prime(17))
        self.assertFalse(self.number_theory.is_prime(1))
        self.assertFalse(self.number_theory.is_prime(4))
        self.assertFalse(self.number_theory.is_prime(15))
    
    def test_prime_factors(self):
        """测试质因数分解"""
        factors = self.number_theory.prime_factors(12)
        expected = {2: 2, 3: 1}
        self.assertEqual(factors, expected)
        
        factors = self.number_theory.prime_factors(100)
        expected = {2: 2, 5: 2}
        self.assertEqual(factors, expected)
    
    def test_euler_phi(self):
        """测试欧拉函数"""
        self.assertEqual(self.number_theory.euler_phi(1), 1)
        self.assertEqual(self.number_theory.euler_phi(6), 2)
        self.assertEqual(self.number_theory.euler_phi(10), 4)
        self.assertEqual(self.number_theory.euler_phi(12), 4)
    
    def test_mod_inverse(self):
        """测试模逆元"""
        inv = self.number_theory.mod_inverse(3, 11)
        self.assertEqual(inv, 4)
        self.assertEqual((3 * inv) % 11, 1)
        
        # 测试无逆元的情况
        inv = self.number_theory.mod_inverse(2, 4)
        self.assertIsNone(inv)
    
    def test_chinese_remainder_theorem(self):
        """测试中国剩余定理"""
        remainders = [2, 3, 2]
        moduli = [3, 5, 7]
        
        result = self.number_theory.chinese_remainder_theorem(remainders, moduli)
        self.assertEqual(result, 23)
        
        # 验证结果
        for i, (remainder, modulus) in enumerate(zip(remainders, moduli)):
            self.assertEqual(result % modulus, remainder)
    
    def test_sieve_of_eratosthenes(self):
        """测试埃拉托斯特尼筛法"""
        primes = self.prime_generator.sieve_of_eratosthenes(20)
        expected = [2, 3, 5, 7, 11, 13, 17, 19]
        self.assertEqual(primes, expected)
    
    def test_miller_rabin(self):
        """测试Miller-Rabin素性测试"""
        # 测试素数
        self.assertTrue(self.prime_generator.miller_rabin_primality_test(17))
        self.assertTrue(self.prime_generator.miller_rabin_primality_test(97))
        
        # 测试合数
        self.assertFalse(self.prime_generator.miller_rabin_primality_test(15))
        self.assertFalse(self.prime_generator.miller_rabin_primality_test(100))
    
    def test_linear_congruence(self):
        """测试线性同余方程"""
        solutions = self.congruence_theory.solve_linear_congruence(3, 2, 7)
        expected = [3]
        self.assertEqual(solutions, expected)
        
        # 验证解
        for solution in solutions:
            self.assertEqual((3 * solution) % 7, 2)
    
    def test_quadratic_residue(self):
        """测试二次剩余"""
        self.assertTrue(self.number_theory.quadratic_residue(1, 7))
        self.assertTrue(self.number_theory.quadratic_residue(2, 7))
        self.assertFalse(self.number_theory.quadratic_residue(3, 7))
    
    def test_legendre_symbol(self):
        """测试勒让德符号"""
        self.assertEqual(self.number_theory.legendre_symbol(1, 7), 1)
        self.assertEqual(self.number_theory.legendre_symbol(2, 7), 1)
        self.assertEqual(self.number_theory.legendre_symbol(3, 7), -1)
        self.assertEqual(self.number_theory.legendre_symbol(0, 7), 0)

if __name__ == '__main__':
    unittest.main()
```

## 7. 总结

本文档全面阐述了数论基础的理论与实践，包括：

### 7.1 核心贡献

1. **形式化定义**: 建立了数论基础的严格数学定义
2. **Python实现**: 实现了完整的数论算法和函数
3. **实际应用**: 提供了密码学和算法优化的应用案例
4. **理论证明**: 证明了重要的数论定理
5. **性能分析**: 分析了各种算法的时间和空间复杂度

### 7.2 技术特色

1. **多表征方法**: 概念解释、数学形式、代码实现、图表说明
2. **层次化组织**: 从基础概念到高级应用
3. **严格形式化**: 每个概念都有严格的数学定义
4. **实际应用导向**: 紧密结合软件工程实践

### 7.3 应用价值

1. **教育价值**: 系统化的数论学习资源
2. **工程价值**: 实用的数论工具和方法
3. **研究价值**: 形式化的理论基础

数论是密码学和算法设计的重要基础，通过本文档的学习，读者可以掌握从基础数论概念到高级密码学应用的完整知识体系，为后续的密码学研究和算法优化奠定坚实的理论基础。

---

*最后更新: 2024-12-19*
*文档状态: 已完成*
*下一步: 代数基础文档*
