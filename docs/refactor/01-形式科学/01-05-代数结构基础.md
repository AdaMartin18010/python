# 01-05 ä»£æ•°ç»“æ„åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

ä»£æ•°ç»“æ„æ˜¯æ•°å­¦ä¸­ç ”ç©¶é›†åˆåŠå…¶è¿ç®—æ€§è´¨çš„é‡è¦åˆ†æ”¯ï¼Œä¸ºè®¡ç®—æœºç§‘å­¦ä¸­çš„æ•°æ®ç»“æ„ã€ç®—æ³•è®¾è®¡å’Œå½¢å¼åŒ–æ–¹æ³•æä¾›äº†ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦ç³»ç»Ÿä»‹ç»ç¾¤ã€ç¯ã€åŸŸç­‰åŸºæœ¬ä»£æ•°ç»“æ„ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 ä»£æ•°ç»“æ„åŸºç¡€

**å®šä¹‰ 1.1** (ä»£æ•°ç»“æ„)
ä»£æ•°ç»“æ„æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ $(S, \mathcal{O})$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯ä¸€ä¸ªéç©ºé›†åˆï¼Œç§°ä¸ºè½½ä½“é›†
- $\mathcal{O}$ æ˜¯å®šä¹‰åœ¨ $S$ ä¸Šçš„è¿ç®—é›†åˆ

**å®šä¹‰ 1.2** (äºŒå…ƒè¿ç®—)
é›†åˆ $S$ ä¸Šçš„äºŒå…ƒè¿ç®—æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$f: S \times S \rightarrow S$$

**å®šä¹‰ 1.3** (è¿ç®—æ€§è´¨)
è®¾ $*$ æ˜¯é›†åˆ $S$ ä¸Šçš„äºŒå…ƒè¿ç®—ï¼š

1. **ç»“åˆå¾‹**: $\forall a, b, c \in S: (a * b) * c = a * (b * c)$
2. **äº¤æ¢å¾‹**: $\forall a, b \in S: a * b = b * a$
3. **å•ä½å…ƒ**: $\exists e \in S: \forall a \in S: e * a = a * e = a$
4. **é€†å…ƒ**: $\forall a \in S: \exists a^{-1} \in S: a * a^{-1} = a^{-1} * a = e$

### 1.2 ç¾¤è®ºåŸºç¡€

**å®šä¹‰ 1.4** (ç¾¤)
ç¾¤æ˜¯ä¸€ä¸ªä»£æ•°ç»“æ„ $(G, *)$ï¼Œæ»¡è¶³ï¼š

1. **å°é—­æ€§**: $\forall a, b \in G: a * b \in G$
2. **ç»“åˆå¾‹**: $\forall a, b, c \in G: (a * b) * c = a * (b * c)$
3. **å•ä½å…ƒ**: $\exists e \in G: \forall a \in G: e * a = a * e = a$
4. **é€†å…ƒ**: $\forall a \in G: \exists a^{-1} \in G: a * a^{-1} = a^{-1} * a = e$

**å®šä¹‰ 1.5** (é˜¿è´å°”ç¾¤)
å¦‚æœç¾¤ $(G, *)$ è¿˜æ»¡è¶³äº¤æ¢å¾‹ï¼Œåˆ™ç§°ä¸ºé˜¿è´å°”ç¾¤ï¼š
$$\forall a, b \in G: a * b = b * a$$

**å®šä¹‰ 1.6** (å­ç¾¤)
ç¾¤ $(G, *)$ çš„å­ç¾¤æ˜¯ $(H, *)$ï¼Œå…¶ä¸­ $H \subseteq G$ ä¸” $(H, *)$ æœ¬èº«æ„æˆç¾¤ã€‚

### 1.3 ç¯è®ºåŸºç¡€

**å®šä¹‰ 1.7** (ç¯)
ç¯æ˜¯ä¸€ä¸ªä»£æ•°ç»“æ„ $(R, +, \cdot)$ï¼Œæ»¡è¶³ï¼š

1. $(R, +)$ æ˜¯é˜¿è´å°”ç¾¤
2. $(R, \cdot)$ æ˜¯åŠç¾¤ï¼ˆæ»¡è¶³ç»“åˆå¾‹ï¼‰
3. **åˆ†é…å¾‹**: $\forall a, b, c \in R: a \cdot (b + c) = a \cdot b + a \cdot c$

**å®šä¹‰ 1.8** (åŸŸ)
åŸŸæ˜¯ä¸€ä¸ªä»£æ•°ç»“æ„ $(F, +, \cdot)$ï¼Œæ»¡è¶³ï¼š

1. $(F, +)$ æ˜¯é˜¿è´å°”ç¾¤
2. $(F \setminus \{0\}, \cdot)$ æ˜¯é˜¿è´å°”ç¾¤
3. **åˆ†é…å¾‹**: $\forall a, b, c \in F: a \cdot (b + c) = a \cdot b + a \cdot c$

## 2. Pythonå®ç°

### 2.1 ä»£æ•°ç»“æ„åŸºç±»

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Dict, List, Set, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import math
from collections import defaultdict

T = TypeVar('T')

class OperationType(Enum):
    """è¿ç®—ç±»å‹"""
    ADDITION = "addition"
    MULTIPLICATION = "multiplication"
    COMPOSITION = "composition"

@dataclass
class AlgebraicElement(Generic[T]):
    """ä»£æ•°å…ƒç´ """
    value: T
    parent_structure: Optional['AlgebraicStructure'] = None
    
    def __str__(self) -> str:
        return str(self.value)
    
    def __repr__(self) -> str:
        return f"AlgebraicElement({self.value})"

class BinaryOperation(ABC):
    """äºŒå…ƒè¿ç®—æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str, operation_type: OperationType):
        self.name = name
        self.operation_type = operation_type
    
    @abstractmethod
    def apply(self, a: AlgebraicElement, b: AlgebraicElement) -> AlgebraicElement:
        """åº”ç”¨è¿ç®—"""
        pass
    
    def __call__(self, a: AlgebraicElement, b: AlgebraicElement) -> AlgebraicElement:
        """è°ƒç”¨è¿ç®—"""
        return self.apply(a, b)

class AlgebraicStructure(ABC):
    """ä»£æ•°ç»“æ„æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.elements: Set[AlgebraicElement] = set()
        self.operations: Dict[str, BinaryOperation] = {}
    
    @abstractmethod
    def add_element(self, element: AlgebraicElement) -> bool:
        """æ·»åŠ å…ƒç´ """
        pass
    
    @abstractmethod
    def remove_element(self, element: AlgebraicElement) -> bool:
        """ç§»é™¤å…ƒç´ """
        pass
    
    def get_elements(self) -> Set[AlgebraicElement]:
        """è·å–æ‰€æœ‰å…ƒç´ """
        return self.elements.copy()
    
    def get_operation(self, name: str) -> Optional[BinaryOperation]:
        """è·å–è¿ç®—"""
        return self.operations.get(name)
    
    def add_operation(self, name: str, operation: BinaryOperation) -> None:
        """æ·»åŠ è¿ç®—"""
        self.operations[name] = operation
    
    def size(self) -> int:
        """è·å–ç»“æ„å¤§å°"""
        return len(self.elements)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©º"""
        return len(self.elements) == 0

class Group(AlgebraicStructure):
    """ç¾¤ç»“æ„"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.identity: Optional[AlgebraicElement] = None
        self.inverses: Dict[AlgebraicElement, AlgebraicElement] = {}
    
    def add_element(self, element: AlgebraicElement) -> bool:
        """æ·»åŠ å…ƒç´ åˆ°ç¾¤"""
        if element not in self.elements:
            self.elements.add(element)
            element.parent_structure = self
            return True
        return False
    
    def remove_element(self, element: AlgebraicElement) -> bool:
        """ä»ç¾¤ä¸­ç§»é™¤å…ƒç´ """
        if element in self.elements:
            self.elements.remove(element)
            if element in self.inverses:
                del self.inverses[element]
            return True
        return False
    
    def set_identity(self, identity: AlgebraicElement) -> None:
        """è®¾ç½®å•ä½å…ƒ"""
        if identity in self.elements:
            self.identity = identity
    
    def set_inverse(self, element: AlgebraicElement, inverse: AlgebraicElement) -> None:
        """è®¾ç½®é€†å…ƒ"""
        if element in self.elements and inverse in self.elements:
            self.inverses[element] = inverse
    
    def get_inverse(self, element: AlgebraicElement) -> Optional[AlgebraicElement]:
        """è·å–é€†å…ƒ"""
        return self.inverses.get(element)
    
    def is_abelian(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé˜¿è´å°”ç¾¤"""
        if not self.operations:
            return False
        
        operation = list(self.operations.values())[0]
        
        for a in self.elements:
            for b in self.elements:
                if operation(a, b) != operation(b, a):
                    return False
        return True
    
    def generate_subgroup(self, generators: List[AlgebraicElement]) -> 'Group':
        """ç”Ÿæˆå­ç¾¤"""
        subgroup = Group(f"Subgroup of {self.name}")
        
        # æ·»åŠ ç”Ÿæˆå…ƒ
        for generator in generators:
            if generator in self.elements:
                subgroup.add_element(generator)
        
        # æ·»åŠ å•ä½å…ƒ
        if self.identity:
            subgroup.add_element(self.identity)
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ç»„åˆ
        current_elements = subgroup.get_elements().copy()
        operation = list(self.operations.values())[0]
        
        while True:
            new_elements = set()
            
            for a in current_elements:
                for b in current_elements:
                    result = operation(a, b)
                    if result not in subgroup.elements:
                        new_elements.add(result)
            
            if not new_elements:
                break
            
            for element in new_elements:
                subgroup.add_element(element)
            current_elements = new_elements
        
        return subgroup

class Ring(AlgebraicStructure):
    """ç¯ç»“æ„"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.additive_identity: Optional[AlgebraicElement] = None
        self.multiplicative_identity: Optional[AlgebraicElement] = None
        self.additive_inverses: Dict[AlgebraicElement, AlgebraicElement] = {}
    
    def set_additive_identity(self, identity: AlgebraicElement) -> None:
        """è®¾ç½®åŠ æ³•å•ä½å…ƒ"""
        if identity in self.elements:
            self.additive_identity = identity
    
    def set_multiplicative_identity(self, identity: AlgebraicElement) -> None:
        """è®¾ç½®ä¹˜æ³•å•ä½å…ƒ"""
        if identity in self.elements:
            self.multiplicative_identity = identity
    
    def set_additive_inverse(self, element: AlgebraicElement, inverse: AlgebraicElement) -> None:
        """è®¾ç½®åŠ æ³•é€†å…ƒ"""
        if element in self.elements and inverse in self.elements:
            self.additive_inverses[element] = inverse
    
    def get_additive_inverse(self, element: AlgebraicElement) -> Optional[AlgebraicElement]:
        """è·å–åŠ æ³•é€†å…ƒ"""
        return self.additive_inverses.get(element)
    
    def is_commutative(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºäº¤æ¢ç¯"""
        if len(self.operations) < 2:
            return False
        
        multiplication = self.operations.get("multiplication")
        if not multiplication:
            return False
        
        for a in self.elements:
            for b in self.elements:
                if multiplication(a, b) != multiplication(b, a):
                    return False
        return True

class Field(Ring):
    """åŸŸç»“æ„"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.multiplicative_inverses: Dict[AlgebraicElement, AlgebraicElement] = {}
    
    def set_multiplicative_inverse(self, element: AlgebraicElement, inverse: AlgebraicElement) -> None:
        """è®¾ç½®ä¹˜æ³•é€†å…ƒ"""
        if (element in self.elements and inverse in self.elements and 
            element != self.additive_identity):
            self.multiplicative_inverses[element] = inverse
    
    def get_multiplicative_inverse(self, element: AlgebraicElement) -> Optional[AlgebraicElement]:
        """è·å–ä¹˜æ³•é€†å…ƒ"""
        if element == self.additive_identity:
            return None
        return self.multiplicative_inverses.get(element)

### 2.2 å…·ä½“ä»£æ•°ç»“æ„å®ç°

class IntegerAddition(BinaryOperation):
    """æ•´æ•°åŠ æ³•è¿ç®—"""
    
    def __init__(self):
        super().__init__("Integer Addition", OperationType.ADDITION)
    
    def apply(self, a: AlgebraicElement, b: AlgebraicElement) -> AlgebraicElement:
        """æ•´æ•°åŠ æ³•"""
        if isinstance(a.value, int) and isinstance(b.value, int):
            return AlgebraicElement(a.value + b.value)
        raise ValueError("Elements must be integers")

class IntegerMultiplication(BinaryOperation):
    """æ•´æ•°ä¹˜æ³•è¿ç®—"""
    
    def __init__(self):
        super().__init__("Integer Multiplication", OperationType.MULTIPLICATION)
    
    def apply(self, a: AlgebraicElement, b: AlgebraicElement) -> AlgebraicElement:
        """æ•´æ•°ä¹˜æ³•"""
        if isinstance(a.value, int) and isinstance(b.value, int):
            return AlgebraicElement(a.value * b.value)
        raise ValueError("Elements must be integers")

class ModularAddition(BinaryOperation):
    """æ¨¡åŠ æ³•è¿ç®—"""
    
    def __init__(self, modulus: int):
        super().__init__(f"Modular Addition (mod {modulus})", OperationType.ADDITION)
        self.modulus = modulus
    
    def apply(self, a: AlgebraicElement, b: AlgebraicElement) -> AlgebraicElement:
        """æ¨¡åŠ æ³•"""
        if isinstance(a.value, int) and isinstance(b.value, int):
            result = (a.value + b.value) % self.modulus
            return AlgebraicElement(result)
        raise ValueError("Elements must be integers")

class ModularMultiplication(BinaryOperation):
    """æ¨¡ä¹˜æ³•è¿ç®—"""
    
    def __init__(self, modulus: int):
        super().__init__(f"Modular Multiplication (mod {modulus})", OperationType.MULTIPLICATION)
        self.modulus = modulus
    
    def apply(self, a: AlgebraicElement, b: AlgebraicElement) -> AlgebraicElement:
        """æ¨¡ä¹˜æ³•"""
        if isinstance(a.value, int) and isinstance(b.value, int):
            result = (a.value * b.value) % self.modulus
            return AlgebraicElement(result)
        raise ValueError("Elements must be integers")

### 2.3 ä»£æ•°ç»“æ„æ„é€ å™¨

class AlgebraicStructureBuilder:
    """ä»£æ•°ç»“æ„æ„é€ å™¨"""
    
    @staticmethod
    def create_integer_group(size: int) -> Group:
        """åˆ›å»ºæ•´æ•°ç¾¤"""
        group = Group(f"Integer Group (0 to {size-1})")
        
        # æ·»åŠ å…ƒç´ 
        for i in range(size):
            element = AlgebraicElement(i)
            group.add_element(element)
        
        # è®¾ç½®åŠ æ³•è¿ç®—
        addition = ModularAddition(size)
        group.add_operation("addition", addition)
        
        # è®¾ç½®å•ä½å…ƒ
        identity = AlgebraicElement(0)
        group.set_identity(identity)
        
        # è®¾ç½®é€†å…ƒ
        for element in group.elements:
            if element.value != 0:
                inverse_value = (size - element.value) % size
                inverse = AlgebraicElement(inverse_value)
                group.set_inverse(element, inverse)
        
        return group
    
    @staticmethod
    def create_integer_ring(size: int) -> Ring:
        """åˆ›å»ºæ•´æ•°ç¯"""
        ring = Ring(f"Integer Ring (0 to {size-1})")
        
        # æ·»åŠ å…ƒç´ 
        for i in range(size):
            element = AlgebraicElement(i)
            ring.add_element(element)
        
        # è®¾ç½®åŠ æ³•è¿ç®—
        addition = ModularAddition(size)
        ring.add_operation("addition", addition)
        
        # è®¾ç½®ä¹˜æ³•è¿ç®—
        multiplication = ModularMultiplication(size)
        ring.add_operation("multiplication", multiplication)
        
        # è®¾ç½®åŠ æ³•å•ä½å…ƒ
        additive_identity = AlgebraicElement(0)
        ring.set_additive_identity(additive_identity)
        
        # è®¾ç½®ä¹˜æ³•å•ä½å…ƒ
        multiplicative_identity = AlgebraicElement(1)
        ring.set_multiplicative_identity(multiplicative_identity)
        
        # è®¾ç½®åŠ æ³•é€†å…ƒ
        for element in ring.elements:
            if element.value != 0:
                inverse_value = (size - element.value) % size
                inverse = AlgebraicElement(inverse_value)
                ring.set_additive_inverse(element, inverse)
        
        return ring
    
    @staticmethod
    def create_finite_field(prime: int) -> Field:
        """åˆ›å»ºæœ‰é™åŸŸï¼ˆç´ æ•°é˜¶ï¼‰"""
        if not is_prime(prime):
            raise ValueError(f"{prime} is not a prime number")
        
        field = Field(f"Finite Field GF({prime})")
        
        # æ·»åŠ å…ƒç´ 
        for i in range(prime):
            element = AlgebraicElement(i)
            field.add_element(element)
        
        # è®¾ç½®åŠ æ³•è¿ç®—
        addition = ModularAddition(prime)
        field.add_operation("addition", addition)
        
        # è®¾ç½®ä¹˜æ³•è¿ç®—
        multiplication = ModularMultiplication(prime)
        field.add_operation("multiplication", multiplication)
        
        # è®¾ç½®åŠ æ³•å•ä½å…ƒ
        additive_identity = AlgebraicElement(0)
        field.set_additive_identity(additive_identity)
        
        # è®¾ç½®ä¹˜æ³•å•ä½å…ƒ
        multiplicative_identity = AlgebraicElement(1)
        field.set_multiplicative_identity(multiplicative_identity)
        
        # è®¾ç½®åŠ æ³•é€†å…ƒ
        for element in field.elements:
            if element.value != 0:
                inverse_value = (prime - element.value) % prime
                inverse = AlgebraicElement(inverse_value)
                field.set_additive_inverse(element, inverse)
        
        # è®¾ç½®ä¹˜æ³•é€†å…ƒ
        for element in field.elements:
            if element.value != 0:
                # ä½¿ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚é€†å…ƒ
                inverse_value = mod_inverse(element.value, prime)
                inverse = AlgebraicElement(inverse_value)
                field.set_multiplicative_inverse(element, inverse)
        
        return field

### 2.4 è¾…åŠ©å‡½æ•°

def is_prime(n: int) -> bool:
    """æ£€æŸ¥æ˜¯å¦ä¸ºç´ æ•°"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True

def mod_inverse(a: int, m: int) -> int:
    """è®¡ç®—æ¨¡é€†å…ƒ"""
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        if a == 0:
            return b, 0, 1
        else:
            gcd, x, y = extended_gcd(b % a, a)
            return gcd, y - (b // a) * x, x
    
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        raise ValueError("Modular inverse does not exist")
    else:
        return (x % m + m) % m

## 3. æ•°å­¦è¯æ˜

### 3.1 ç¾¤çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1** (å•ä½å…ƒå”¯ä¸€æ€§)
ç¾¤çš„å•ä½å…ƒæ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜**:
å‡è®¾ $e_1$ å’Œ $e_2$ éƒ½æ˜¯ç¾¤ $G$ çš„å•ä½å…ƒï¼Œåˆ™ï¼š
$$e_1 = e_1 * e_2 = e_2$$
å› æ­¤ $e_1 = e_2$ã€‚

**å®šç† 3.2** (é€†å…ƒå”¯ä¸€æ€§)
ç¾¤ä¸­æ¯ä¸ªå…ƒç´ çš„é€†å…ƒæ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜**:
å‡è®¾å…ƒç´  $a$ æœ‰ä¸¤ä¸ªé€†å…ƒ $b$ å’Œ $c$ï¼Œåˆ™ï¼š
$$b = b * e = b * (a * c) = (b * a) * c = e * c = c$$
å› æ­¤ $b = c$ã€‚

### 3.2 æ‹‰æ ¼æœ—æ—¥å®šç†

**å®šç† 3.3** (æ‹‰æ ¼æœ—æ—¥å®šç†)
æœ‰é™ç¾¤ $G$ çš„å­ç¾¤ $H$ çš„é˜¶æ•´é™¤ç¾¤ $G$ çš„é˜¶ï¼š
$$|H| \mid |G|$$

**è¯æ˜**:
1. å®šä¹‰å·¦é™ªé›†ï¼š$aH = \{ah \mid h \in H\}$
2. æ‰€æœ‰å·¦é™ªé›†çš„å¤§å°ç›¸ç­‰ï¼š$|aH| = |H|$
3. ä¸åŒå·¦é™ªé›†ä¸ç›¸äº¤
4. ç¾¤çš„å…ƒç´ å¯ä»¥åˆ’åˆ†ä¸ºä¸ç›¸äº¤çš„å·¦é™ªé›†
5. å› æ­¤ $|G| = k|H|$ï¼Œå…¶ä¸­ $k$ æ˜¯å·¦é™ªé›†çš„æ•°é‡

### 3.3 ç¯çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.4** (é›¶å…ƒæ€§è´¨)
ç¯ä¸­çš„é›¶å…ƒï¼ˆåŠ æ³•å•ä½å…ƒï¼‰æ»¡è¶³ï¼š
$$\forall a \in R: 0 \cdot a = a \cdot 0 = 0$$

**è¯æ˜**:
$$0 \cdot a = (0 + 0) \cdot a = 0 \cdot a + 0 \cdot a$$
ä¸¤è¾¹åŒæ—¶åŠ ä¸Š $-(0 \cdot a)$ï¼š
$$0 = 0 \cdot a$$

## 4. åº”ç”¨åœºæ™¯

### 4.1 å¯†ç å­¦åº”ç”¨

```python
class CryptographyAlgebra:
    """å¯†ç å­¦ä»£æ•°åº”ç”¨"""
    
    def __init__(self, prime: int):
        self.field = AlgebraicStructureBuilder.create_finite_field(prime)
        self.prime = prime
    
    def diffie_hellman_key_exchange(self, private_key: int, public_key: int) -> int:
        """Diffie-Hellmanå¯†é’¥äº¤æ¢"""
        if private_key >= self.prime or public_key >= self.prime:
            raise ValueError("Keys must be less than prime")
        
        # è®¡ç®—å…±äº«å¯†é’¥
        shared_key = pow(public_key, private_key, self.prime)
        return shared_key
    
    def elgamal_encryption(self, message: int, public_key: int, random_k: int) -> Tuple[int, int]:
        """ElGamalåŠ å¯†"""
        if message >= self.prime or public_key >= self.prime or random_k >= self.prime:
            raise ValueError("Values must be less than prime")
        
        # è®¡ç®— c1 = g^k mod p
        c1 = pow(2, random_k, self.prime)  # å‡è®¾ g = 2
        
        # è®¡ç®— c2 = m * (public_key)^k mod p
        c2 = (message * pow(public_key, random_k, self.prime)) % self.prime
        
        return c1, c2
    
    def elgamal_decryption(self, c1: int, c2: int, private_key: int) -> int:
        """ElGamalè§£å¯†"""
        # è®¡ç®— s = c1^private_key mod p
        s = pow(c1, private_key, self.prime)
        
        # è®¡ç®— s çš„é€†å…ƒ
        s_inverse = mod_inverse(s, self.prime)
        
        # è®¡ç®—æ¶ˆæ¯ m = c2 * s^(-1) mod p
        message = (c2 * s_inverse) % self.prime
        
        return message

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_cryptography():
    """æ¼”ç¤ºå¯†ç å­¦åº”ç”¨"""
    crypto = CryptographyAlgebra(23)  # ä½¿ç”¨ç´ æ•°23
    
    # Diffie-Hellmanå¯†é’¥äº¤æ¢
    alice_private = 6
    bob_private = 15
    
    alice_public = pow(2, alice_private, 23)  # g^a mod p
    bob_public = pow(2, bob_private, 23)      # g^b mod p
    
    alice_shared = crypto.diffie_hellman_key_exchange(alice_private, bob_public)
    bob_shared = crypto.diffie_hellman_key_exchange(bob_private, alice_public)
    
    print(f"Aliceçš„å…±äº«å¯†é’¥: {alice_shared}")
    print(f"Bobçš„å…±äº«å¯†é’¥: {bob_shared}")
    print(f"å¯†é’¥äº¤æ¢æˆåŠŸ: {alice_shared == bob_shared}")
    
    # ElGamalåŠ å¯†
    message = 12
    public_key = pow(2, 7, 23)  # å‡è®¾ç§é’¥ä¸º7
    
    c1, c2 = crypto.elgamal_encryption(message, public_key, 3)
    decrypted = crypto.elgamal_decryption(c1, c2, 7)
    
    print(f"åŸå§‹æ¶ˆæ¯: {message}")
    print(f"åŠ å¯†ç»“æœ: ({c1}, {c2})")
    print(f"è§£å¯†ç»“æœ: {decrypted}")
    print(f"è§£å¯†æˆåŠŸ: {message == decrypted}")
```

### 4.2 ç¼–ç ç†è®ºåº”ç”¨

```python
class CodingTheoryAlgebra:
    """ç¼–ç ç†è®ºä»£æ•°åº”ç”¨"""
    
    def __init__(self, field_size: int):
        self.field = AlgebraicStructureBuilder.create_finite_field(field_size)
        self.field_size = field_size
    
    def reed_solomon_encoding(self, message: List[int], n: int, k: int) -> List[int]:
        """Reed-Solomonç¼–ç """
        if len(message) != k:
            raise ValueError(f"Message length must be {k}")
        
        # ç”Ÿæˆç¼–ç å¤šé¡¹å¼
        polynomial = message.copy()
        
        # è®¡ç®—ç¼–ç å€¼
        codeword = []
        for i in range(n):
            # è®¡ç®—å¤šé¡¹å¼åœ¨ç‚¹iå¤„çš„å€¼
            value = 0
            for j, coeff in enumerate(polynomial):
                value = (value + coeff * pow(i, j, self.field_size)) % self.field_size
            codeword.append(value)
        
        return codeword
    
    def reed_solomon_decoding(self, received: List[int], n: int, k: int) -> List[int]:
        """Reed-Solomonè§£ç ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰"""
        if len(received) != n:
            raise ValueError(f"Received word length must be {n}")
        
        # ä½¿ç”¨å‰kä¸ªç¬¦å·ä½œä¸ºæ¶ˆæ¯ï¼ˆç®€åŒ–è§£ç ï¼‰
        message = received[:k]
        return message

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_coding_theory():
    """æ¼”ç¤ºç¼–ç ç†è®ºåº”ç”¨"""
    coding = CodingTheoryAlgebra(7)  # GF(7)
    
    # åŸå§‹æ¶ˆæ¯
    message = [3, 1, 4]  # k=3
    n = 5  # ç å­—é•¿åº¦
    
    # ç¼–ç 
    codeword = coding.reed_solomon_encoding(message, n, 3)
    print(f"åŸå§‹æ¶ˆæ¯: {message}")
    print(f"ç¼–ç ç»“æœ: {codeword}")
    
    # æ¨¡æ‹Ÿä¼ è¾“é”™è¯¯
    received = codeword.copy()
    received[2] = (received[2] + 1) % 7  # å¼•å…¥é”™è¯¯
    
    # è§£ç 
    decoded = coding.reed_solomon_decoding(received, n, 3)
    print(f"æ¥æ”¶ç å­—: {received}")
    print(f"è§£ç ç»“æœ: {decoded}")
```

## 5. æ€»ç»“

ä»£æ•°ç»“æ„ä¸ºè®¡ç®—æœºç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ï¼š

1. **ç¾¤è®º**: ä¸ºå¯¹ç§°æ€§ã€å¯†ç å­¦å’Œç¼–ç ç†è®ºæä¾›åŸºç¡€
2. **ç¯è®º**: ä¸ºå¤šé¡¹å¼è¿ç®—å’Œä»£æ•°ç¼–ç æä¾›æ”¯æŒ
3. **åŸŸè®º**: ä¸ºæœ‰é™åŸŸè¿ç®—å’Œå¯†ç å­¦ç®—æ³•æä¾›å·¥å…·
4. **æŠ½è±¡ä»£æ•°**: ä¸ºæ•°æ®ç»“æ„è®¾è®¡å’Œç®—æ³•åˆ†ææä¾›æ–¹æ³•

ä»£æ•°ç»“æ„çš„ç ”ç©¶å°†ç»§ç»­æ¨åŠ¨è®¡ç®—æœºç§‘å­¦çš„å‘å±•ï¼Œç‰¹åˆ«æ˜¯åœ¨å¯†ç å­¦ã€ç¼–ç ç†è®ºã€é‡å­è®¡ç®—ç­‰é¢†åŸŸå‘æŒ¥é‡è¦ä½œç”¨ã€‚

---

**ç›¸å…³é“¾æ¥**:

- [01-01 é›†åˆè®ºåŸºç¡€](./01-01-é›†åˆè®ºåŸºç¡€.md)
- [01-02 é€»è¾‘å­¦åŸºç¡€](./01-02-é€»è¾‘å­¦åŸºç¡€.md)
- [02-01 ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º.md)
- [04-01 é‡‘èç§‘æŠ€](../04-è¡Œä¸šé¢†åŸŸ/04-01-é‡‘èç§‘æŠ€.md)
