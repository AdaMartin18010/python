# 命题逻辑

## 目录

- [命题逻辑](#命题逻辑)
  - [目录](#目录)
  - [1. 基本概念](#1-基本概念)
    - [1.1 命题定义](#11-命题定义)
    - [1.2 逻辑连接词](#12-逻辑连接词)
    - [1.3 真值表](#13-真值表)
  - [2. 形式化表达](#2-形式化表达)
    - [2.1 数学定义](#21-数学定义)
    - [2.2 公理化系统](#22-公理化系统)
    - [2.3 形式化证明](#23-形式化证明)
  - [3. Python 实现](#3-python-实现)
    - [3.1 命题表示](#31-命题表示)
    - [3.2 逻辑运算](#32-逻辑运算)
    - [3.3 真值表生成](#33-真值表生成)
  - [4. 应用领域](#4-应用领域)
    - [4.1 程序验证](#41-程序验证)
    - [4.2 推理系统](#42-推理系统)
    - [4.3 知识表示](#43-知识表示)
  - [5. 高级主题](#5-高级主题)
    - [5.1 命题逻辑的局限性](#51-命题逻辑的局限性)
    - [5.2 扩展方向](#52-扩展方向)

---

## 1. 基本概念

### 1.1 命题定义

**定义 1.1.1 (命题)**
命题是一个具有确定真值的陈述句，其真值要么为真（True），要么为假（False）。

**定义 1.1.2 (原子命题)**
原子命题是最基本的命题，不能再分解为更简单的命题。

**定义 1.1.3 (复合命题)**
复合命题是由原子命题通过逻辑连接词组合而成的命题。

### 1.2 逻辑连接词

**定义 1.2.1 (否定)**
命题 $p$ 的否定记作 $\neg p$，当 $p$ 为真时 $\neg p$ 为假，当 $p$ 为假时 $\neg p$ 为真。

**定义 1.2.2 (合取)**
命题 $p$ 和 $q$ 的合取记作 $p \land q$，当且仅当 $p$ 和 $q$ 都为真时，$p \land q$ 为真。

**定义 1.2.3 (析取)**
命题 $p$ 和 $q$ 的析取记作 $p \lor q$，当且仅当 $p$ 或 $q$ 至少有一个为真时，$p \lor q$ 为真。

**定义 1.2.4 (蕴含)**
命题 $p$ 蕴含 $q$ 记作 $p \rightarrow q$，当且仅当 $p$ 为假或 $q$ 为真时，$p \rightarrow q$ 为真。

**定义 1.2.5 (等价)**
命题 $p$ 等价于 $q$ 记作 $p \leftrightarrow q$，当且仅当 $p$ 和 $q$ 具有相同的真值时，$p \leftrightarrow q$ 为真。

### 1.3 真值表

**定义 1.3.1 (真值表)**
真值表是表示命题逻辑公式在所有可能真值赋值下真值的表格。

## 2. 形式化表达

### 2.1 数学定义

**定义 2.1.1 (命题逻辑语言)**
命题逻辑语言 $\mathcal{L}$ 由以下部分组成：

- 命题变元集合 $\mathcal{P} = \{p_1, p_2, p_3, ...\}$
- 逻辑连接词集合 $\{\neg, \land, \lor, \rightarrow, \leftrightarrow\}$
- 括号 $\{(, )\}$

**定义 2.1.2 (命题公式)**
命题公式的递归定义：

1. 每个命题变元 $p \in \mathcal{P}$ 是命题公式
2. 如果 $\phi$ 是命题公式，则 $\neg \phi$ 是命题公式
3. 如果 $\phi$ 和 $\psi$ 是命题公式，则 $(\phi \land \psi)$、$(\phi \lor \psi)$、$(\phi \rightarrow \psi)$、$(\phi \leftrightarrow \psi)$ 是命题公式

**定义 2.1.3 (真值赋值)**
真值赋值是一个函数 $v: \mathcal{P} \rightarrow \{T, F\}$，其中 $T$ 表示真，$F$ 表示假。

### 2.2 公理化系统

**公理 2.2.1 (命题逻辑公理)**
对于任意命题公式 $\phi$、$\psi$、$\chi$：

1. $\phi \rightarrow (\psi \rightarrow \phi)$
2. $(\phi \rightarrow (\psi \rightarrow \chi)) \rightarrow ((\phi \rightarrow \psi) \rightarrow (\phi \rightarrow \chi))$
3. $(\neg \phi \rightarrow \neg \psi) \rightarrow (\psi \rightarrow \phi)$

**推理规则 2.2.1 (分离规则)**
从 $\phi$ 和 $\phi \rightarrow \psi$ 可以推出 $\psi$。

### 2.3 形式化证明

**定理 2.3.1 (双重否定律)**
对于任意命题公式 $\phi$：
$$\neg \neg \phi \leftrightarrow \phi$$

**证明**：

1. 设 $v$ 为任意真值赋值
2. 如果 $v(\phi) = T$，则 $v(\neg \phi) = F$，$v(\neg \neg \phi) = T$
3. 如果 $v(\phi) = F$，则 $v(\neg \phi) = T$，$v(\neg \neg \phi) = F$
4. 因此，$v(\neg \neg \phi) = v(\phi)$ 对所有真值赋值成立
5. 所以 $\neg \neg \phi \leftrightarrow \phi$ 是永真式。

## 3. Python 实现

### 3.1 命题表示

```python
from abc import ABC, abstractmethod
from typing import Dict, Set, List, Any, Optional
from enum import Enum
import itertools

class TruthValue(Enum):
    """真值枚举"""
    TRUE = True
    FALSE = False

class Proposition(ABC):
    """
    命题抽象基类
    表示命题逻辑中的命题
    """
    
    @abstractmethod
    def evaluate(self, assignment: Dict[str, TruthValue]) -> TruthValue:
        """在给定真值赋值下求值"""
        pass
    
    @abstractmethod
    def get_variables(self) -> Set[str]:
        """获取命题中的变量"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """字符串表示"""
        pass

class AtomicProposition(Proposition):
    """
    原子命题类
    表示最基本的命题变元
    """
    
    def __init__(self, name: str):
        self.name = name
    
    def evaluate(self, assignment: Dict[str, TruthValue]) -> TruthValue:
        """在给定真值赋值下求值"""
        if self.name not in assignment:
            raise ValueError(f"Variable {self.name} not in assignment")
        return assignment[self.name]
    
    def get_variables(self) -> Set[str]:
        """获取命题中的变量"""
        return {self.name}
    
    def __str__(self) -> str:
        return self.name

class Negation(Proposition):
    """
    否定命题类
    表示命题的否定
    """
    
    def __init__(self, proposition: Proposition):
        self.proposition = proposition
    
    def evaluate(self, assignment: Dict[str, TruthValue]) -> TruthValue:
        """在给定真值赋值下求值"""
        result = self.proposition.evaluate(assignment)
        return TruthValue(not result.value)
    
    def get_variables(self) -> Set[str]:
        """获取命题中的变量"""
        return self.proposition.get_variables()
    
    def __str__(self) -> str:
        return f"¬{self.proposition}"

class BinaryOperator(Proposition):
    """
    二元逻辑运算符基类
    """
    
    def __init__(self, left: Proposition, right: Proposition, operator: str):
        self.left = left
        self.right = right
        self.operator = operator
    
    def get_variables(self) -> Set[str]:
        """获取命题中的变量"""
        return self.left.get_variables().union(self.right.get_variables())
    
    def __str__(self) -> str:
        return f"({self.left} {self.operator} {self.right})"

class Conjunction(BinaryOperator):
    """
    合取命题类
    表示逻辑与
    """
    
    def __init__(self, left: Proposition, right: Proposition):
        super().__init__(left, right, "∧")
    
    def evaluate(self, assignment: Dict[str, TruthValue]) -> TruthValue:
        """在给定真值赋值下求值"""
        left_val = self.left.evaluate(assignment)
        right_val = self.right.evaluate(assignment)
        return TruthValue(left_val.value and right_val.value)

class Disjunction(BinaryOperator):
    """
    析取命题类
    表示逻辑或
    """
    
    def __init__(self, left: Proposition, right: Proposition):
        super().__init__(left, right, "∨")
    
    def evaluate(self, assignment: Dict[str, TruthValue]) -> TruthValue:
        """在给定真值赋值下求值"""
        left_val = self.left.evaluate(assignment)
        right_val = self.right.evaluate(assignment)
        return TruthValue(left_val.value or right_val.value)

class Implication(BinaryOperator):
    """
    蕴含命题类
    表示逻辑蕴含
    """
    
    def __init__(self, left: Proposition, right: Proposition):
        super().__init__(left, right, "→")
    
    def evaluate(self, assignment: Dict[str, TruthValue]) -> TruthValue:
        """在给定真值赋值下求值"""
        left_val = self.left.evaluate(assignment)
        right_val = self.right.evaluate(assignment)
        # p → q 等价于 ¬p ∨ q
        return TruthValue((not left_val.value) or right_val.value)

class Equivalence(BinaryOperator):
    """
    等价命题类
    表示逻辑等价
    """
    
    def __init__(self, left: Proposition, right: Proposition):
        super().__init__(left, right, "↔")
    
    def evaluate(self, assignment: Dict[str, TruthValue]) -> TruthValue:
        """在给定真值赋值下求值"""
        left_val = self.left.evaluate(assignment)
        right_val = self.right.evaluate(assignment)
        return TruthValue(left_val.value == right_val.value)

# 命题构建器
class PropositionBuilder:
    """
    命题构建器
    提供便捷的命题构建方法
    """
    
    @staticmethod
    def var(name: str) -> AtomicProposition:
        """创建原子命题"""
        return AtomicProposition(name)
    
    @staticmethod
    def neg(proposition: Proposition) -> Negation:
        """创建否定命题"""
        return Negation(proposition)
    
    @staticmethod
    def and_(left: Proposition, right: Proposition) -> Conjunction:
        """创建合取命题"""
        return Conjunction(left, right)
    
    @staticmethod
    def or_(left: Proposition, right: Proposition) -> Disjunction:
        """创建析取命题"""
        return Disjunction(left, right)
    
    @staticmethod
    def implies(left: Proposition, right: Proposition) -> Implication:
        """创建蕴含命题"""
        return Implication(left, right)
    
    @staticmethod
    def equiv(left: Proposition, right: Proposition) -> Equivalence:
        """创建等价命题"""
        return Equivalence(left, right)

# 使用示例
def demonstrate_proposition_creation():
    """演示命题创建"""
    
    # 创建原子命题
    p = PropositionBuilder.var("p")
    q = PropositionBuilder.var("q")
    r = PropositionBuilder.var("r")
    
    # 创建复合命题
    not_p = PropositionBuilder.neg(p)
    p_and_q = PropositionBuilder.and_(p, q)
    p_or_q = PropositionBuilder.or_(p, q)
    p_implies_q = PropositionBuilder.implies(p, q)
    p_equiv_q = PropositionBuilder.equiv(p, q)
    
    # 创建复杂命题
    complex_prop = PropositionBuilder.and_(
        PropositionBuilder.or_(p, q),
        PropositionBuilder.implies(r, not_p)
    )
    
    print("=== 命题创建演示 ===")
    print(f"原子命题 p: {p}")
    print(f"否定命题 ¬p: {not_p}")
    print(f"合取命题 p ∧ q: {p_and_q}")
    print(f"析取命题 p ∨ q: {p_or_q}")
    print(f"蕴含命题 p → q: {p_implies_q}")
    print(f"等价命题 p ↔ q: {p_equiv_q}")
    print(f"复杂命题 (p ∨ q) ∧ (r → ¬p): {complex_prop}")
    
    # 获取变量
    print(f"\n复杂命题中的变量: {complex_prop.get_variables()}")

if __name__ == "__main__":
    demonstrate_proposition_creation()
```

### 3.2 逻辑运算

```python
# 逻辑运算实现

class LogicalOperations:
    """
    逻辑运算类
    提供命题逻辑的各种运算
    """
    
    @staticmethod
    def generate_assignments(variables: Set[str]) -> List[Dict[str, TruthValue]]:
        """生成所有可能的真值赋值"""
        assignments = []
        var_list = list(variables)
        
        # 生成所有可能的真值组合
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], repeat=len(var_list)):
            assignment = dict(zip(var_list, values))
            assignments.append(assignment)
        
        return assignments
    
    @staticmethod
    def truth_table(proposition: Proposition) -> List[Dict[str, Any]]:
        """生成命题的真值表"""
        variables = proposition.get_variables()
        assignments = LogicalOperations.generate_assignments(variables)
        table = []
        
        for assignment in assignments:
            row = assignment.copy()
            try:
                result = proposition.evaluate(assignment)
                row['result'] = result
            except ValueError as e:
                row['result'] = f"Error: {e}"
            table.append(row)
        
        return table
    
    @staticmethod
    def is_tautology(proposition: Proposition) -> bool:
        """判断命题是否为永真式"""
        assignments = LogicalOperations.generate_assignments(proposition.get_variables())
        
        for assignment in assignments:
            try:
                if proposition.evaluate(assignment) != TruthValue.TRUE:
                    return False
            except ValueError:
                return False
        
        return True
    
    @staticmethod
    def is_contradiction(proposition: Proposition) -> bool:
        """判断命题是否为永假式"""
        assignments = LogicalOperations.generate_assignments(proposition.get_variables())
        
        for assignment in assignments:
            try:
                if proposition.evaluate(assignment) != TruthValue.FALSE:
                    return False
            except ValueError:
                return False
        
        return True
    
    @staticmethod
    def is_satisfiable(proposition: Proposition) -> bool:
        """判断命题是否可满足"""
        return not LogicalOperations.is_contradiction(proposition)
    
    @staticmethod
    def is_equivalent(prop1: Proposition, prop2: Proposition) -> bool:
        """判断两个命题是否等价"""
        # 获取所有变量
        all_variables = prop1.get_variables().union(prop2.get_variables())
        assignments = LogicalOperations.generate_assignments(all_variables)
        
        for assignment in assignments:
            try:
                val1 = prop1.evaluate(assignment)
                val2 = prop2.evaluate(assignment)
                if val1 != val2:
                    return False
            except ValueError:
                return False
        
        return True
    
    @staticmethod
    def logical_entailment(premises: List[Proposition], conclusion: Proposition) -> bool:
        """判断前提是否逻辑蕴含结论"""
        # 获取所有变量
        all_variables = set()
        for premise in premises:
            all_variables.update(premise.get_variables())
        all_variables.update(conclusion.get_variables())
        
        assignments = LogicalOperations.generate_assignments(all_variables)
        
        for assignment in assignments:
            try:
                # 检查所有前提是否为真
                all_premises_true = True
                for premise in premises:
                    if premise.evaluate(assignment) != TruthValue.TRUE:
                        all_premises_true = False
                        break
                
                # 如果所有前提为真，检查结论是否为真
                if all_premises_true:
                    if conclusion.evaluate(assignment) != TruthValue.TRUE:
                        return False
            except ValueError:
                continue
        
        return True

class PropositionSimplifier:
    """
    命题简化器
    提供命题的简化操作
    """
    
    @staticmethod
    def double_negation_elimination(proposition: Proposition) -> Proposition:
        """消除双重否定"""
        if isinstance(proposition, Negation):
            if isinstance(proposition.proposition, Negation):
                return proposition.proposition.proposition
        return proposition
    
    @staticmethod
    def de_morgan_law(proposition: Proposition) -> Proposition:
        """应用德摩根定律"""
        if isinstance(proposition, Negation):
            if isinstance(proposition.proposition, Conjunction):
                # ¬(p ∧ q) ≡ ¬p ∨ ¬q
                left = Negation(proposition.proposition.left)
                right = Negation(proposition.proposition.right)
                return Disjunction(left, right)
            elif isinstance(proposition.proposition, Disjunction):
                # ¬(p ∨ q) ≡ ¬p ∧ ¬q
                left = Negation(proposition.proposition.left)
                right = Negation(proposition.proposition.right)
                return Conjunction(left, right)
        return proposition
    
    @staticmethod
    def distributive_law(proposition: Proposition) -> Proposition:
        """应用分配律"""
        if isinstance(proposition, Conjunction):
            if isinstance(proposition.left, Disjunction):
                # p ∧ (q ∨ r) ≡ (p ∧ q) ∨ (p ∧ r)
                left_conj = Conjunction(proposition.right, proposition.left.left)
                right_conj = Conjunction(proposition.right, proposition.left.right)
                return Disjunction(left_conj, right_conj)
            elif isinstance(proposition.right, Disjunction):
                # (p ∨ q) ∧ r ≡ (p ∧ r) ∨ (q ∧ r)
                left_conj = Conjunction(proposition.left.left, proposition.right)
                right_conj = Conjunction(proposition.left.right, proposition.right)
                return Disjunction(left_conj, right_conj)
        return proposition

# 使用示例
def demonstrate_logical_operations():
    """演示逻辑运算"""
    
    # 创建命题
    p = PropositionBuilder.var("p")
    q = PropositionBuilder.var("q")
    
    # 创建各种命题
    tautology = PropositionBuilder.or_(p, PropositionBuilder.neg(p))  # p ∨ ¬p
    contradiction = PropositionBuilder.and_(p, PropositionBuilder.neg(p))  # p ∧ ¬p
    satisfiable = PropositionBuilder.and_(p, q)  # p ∧ q
    
    print("=== 逻辑运算演示 ===")
    
    # 真值表
    print("p ∨ ¬p 的真值表:")
    table = LogicalOperations.truth_table(tautology)
    for row in table:
        print(f"p={row['p']}, result={row['result']}")
    
    # 永真式、永假式、可满足性
    print(f"\np ∨ ¬p 是永真式: {LogicalOperations.is_tautology(tautology)}")
    print(f"p ∧ ¬p 是永假式: {LogicalOperations.is_contradiction(contradiction)}")
    print(f"p ∧ q 是可满足的: {LogicalOperations.is_satisfiable(satisfiable)}")
    
    # 等价性
    prop1 = PropositionBuilder.implies(p, q)
    prop2 = PropositionBuilder.or_(PropositionBuilder.neg(p), q)
    print(f"p → q 与 ¬p ∨ q 等价: {LogicalOperations.is_equivalent(prop1, prop2)}")
    
    # 逻辑蕴含
    premises = [p, PropositionBuilder.implies(p, q)]
    conclusion = q
    print(f"{{p, p → q}} 逻辑蕴含 q: {LogicalOperations.logical_entailment(premises, conclusion)}")

if __name__ == "__main__":
    demonstrate_logical_operations()
```

### 3.3 真值表生成

```python
# 真值表生成器

class TruthTableGenerator:
    """
    真值表生成器
    提供格式化的真值表输出
    """
    
    @staticmethod
    def format_truth_table(proposition: Proposition) -> str:
        """格式化真值表输出"""
        table = LogicalOperations.truth_table(proposition)
        if not table:
            return "Empty truth table"
        
        # 获取变量名
        variables = sorted(list(proposition.get_variables()))
        
        # 构建表头
        header = " | ".join(variables + ["Result"])
        separator = "-" * len(header)
        
        # 构建表体
        rows = []
        for row in table:
            row_values = [str(row[var]) for var in variables]
            row_values.append(str(row['result']))
            rows.append(" | ".join(row_values))
        
        # 组合输出
        return f"{header}\n{separator}\n" + "\n".join(rows)
    
    @staticmethod
    def compare_truth_tables(propositions: List[Proposition], names: List[str]) -> str:
        """比较多个命题的真值表"""
        if len(propositions) != len(names):
            raise ValueError("Number of propositions must match number of names")
        
        # 获取所有变量
        all_variables = set()
        for prop in propositions:
            all_variables.update(prop.get_variables())
        variables = sorted(list(all_variables))
        
        # 生成所有赋值
        assignments = LogicalOperations.generate_assignments(all_variables)
        
        # 构建表头
        header = " | ".join(variables + names)
        separator = "-" * len(header)
        
        # 构建表体
        rows = []
        for assignment in assignments:
            row_values = [str(assignment[var]) for var in variables]
            
            for prop in propositions:
                try:
                    result = prop.evaluate(assignment)
                    row_values.append(str(result))
                except ValueError:
                    row_values.append("Error")
            
            rows.append(" | ".join(row_values))
        
        # 组合输出
        return f"{header}\n{separator}\n" + "\n".join(rows)

class PropositionAnalyzer:
    """
    命题分析器
    提供命题的深入分析
    """
    
    @staticmethod
    def analyze_proposition(proposition: Proposition) -> Dict[str, Any]:
        """分析命题的各种性质"""
        analysis = {
            "proposition": str(proposition),
            "variables": list(proposition.get_variables()),
            "variable_count": len(proposition.get_variables()),
            "is_tautology": LogicalOperations.is_tautology(proposition),
            "is_contradiction": LogicalOperations.is_contradiction(proposition),
            "is_satisfiable": LogicalOperations.is_satisfiable(proposition),
            "truth_table": LogicalOperations.truth_table(proposition)
        }
        
        # 计算真值分布
        true_count = sum(1 for row in analysis["truth_table"] 
                        if row.get('result') == TruthValue.TRUE)
        total_count = len(analysis["truth_table"])
        analysis["true_ratio"] = true_count / total_count if total_count > 0 else 0
        
        return analysis
    
    @staticmethod
    def find_satisfying_assignments(proposition: Proposition) -> List[Dict[str, TruthValue]]:
        """找到所有满足命题的真值赋值"""
        assignments = LogicalOperations.generate_assignments(proposition.get_variables())
        satisfying = []
        
        for assignment in assignments:
            try:
                if proposition.evaluate(assignment) == TruthValue.TRUE:
                    satisfying.append(assignment)
            except ValueError:
                continue
        
        return satisfying
    
    @staticmethod
    def find_counterexamples(premises: List[Proposition], conclusion: Proposition) -> List[Dict[str, TruthValue]]:
        """找到逻辑蕴含的反例"""
        all_variables = set()
        for premise in premises:
            all_variables.update(premise.get_variables())
        all_variables.update(conclusion.get_variables())
        
        assignments = LogicalOperations.generate_assignments(all_variables)
        counterexamples = []
        
        for assignment in assignments:
            try:
                # 检查所有前提是否为真
                all_premises_true = True
                for premise in premises:
                    if premise.evaluate(assignment) != TruthValue.TRUE:
                        all_premises_true = False
                        break
                
                # 如果所有前提为真但结论为假，则为反例
                if all_premises_true and conclusion.evaluate(assignment) != TruthValue.TRUE:
                    counterexamples.append(assignment)
            except ValueError:
                continue
        
        return counterexamples

# 使用示例
def demonstrate_truth_table():
    """演示真值表生成"""
    
    # 创建命题
    p = PropositionBuilder.var("p")
    q = PropositionBuilder.var("q")
    
    # 创建各种命题
    prop1 = PropositionBuilder.and_(p, q)
    prop2 = PropositionBuilder.or_(p, q)
    prop3 = PropositionBuilder.implies(p, q)
    prop4 = PropositionBuilder.equiv(p, q)
    
    print("=== 真值表生成演示 ===")
    
    # 单个命题的真值表
    print("p ∧ q 的真值表:")
    print(TruthTableGenerator.format_truth_table(prop1))
    
    print("\np ∨ q 的真值表:")
    print(TruthTableGenerator.format_truth_table(prop2))
    
    # 比较多个命题
    print("\n=== 命题比较 ===")
    propositions = [prop1, prop2, prop3, prop4]
    names = ["p∧q", "p∨q", "p→q", "p↔q"]
    print(TruthTableGenerator.compare_truth_tables(propositions, names))
    
    # 命题分析
    print("\n=== 命题分析 ===")
    analysis = PropositionAnalyzer.analyze_proposition(prop3)
    for key, value in analysis.items():
        if key != "truth_table":
            print(f"{key}: {value}")
    
    # 找到满足的赋值
    print(f"\n满足 p → q 的赋值:")
    satisfying = PropositionAnalyzer.find_satisfying_assignments(prop3)
    for assignment in satisfying:
        print(assignment)

if __name__ == "__main__":
    demonstrate_truth_table()
```

## 4. 应用领域

### 4.1 程序验证

```python
# 程序验证中的应用

class ProgramVerifier:
    """
    程序验证器
    使用命题逻辑进行程序验证
    """
    
    @staticmethod
    def verify_condition(precondition: Proposition, postcondition: Proposition, 
                        program_logic: Proposition) -> bool:
        """验证程序逻辑"""
        # 程序正确性：precondition ∧ program_logic → postcondition
        antecedent = PropositionBuilder.and_(precondition, program_logic)
        return LogicalOperations.logical_entailment([antecedent], postcondition)
    
    @staticmethod
    def verify_loop_invariant(invariant: Proposition, loop_condition: Proposition,
                             loop_body: Proposition) -> bool:
        """验证循环不变式"""
        # 循环不变式必须满足：
        # 1. 初始时成立
        # 2. 循环条件为真且不变式成立时，执行循环体后不变式仍成立
        # 3. 循环条件为假且不变式成立时，最终条件成立
        
        # 这里简化处理，实际需要更复杂的逻辑
        return LogicalOperations.is_tautology(invariant)

# 使用示例
def demonstrate_program_verification():
    """演示程序验证"""
    
    # 定义变量
    x = PropositionBuilder.var("x")
    y = PropositionBuilder.var("y")
    
    # 验证交换程序
    # 前置条件：x = a ∧ y = b
    # 后置条件：x = b ∧ y = a
    # 程序逻辑：x = x + y; y = x - y; x = x - y
    
    # 简化的验证（实际需要更复杂的逻辑）
    print("程序验证需要更复杂的逻辑表示")
```

### 4.2 推理系统

```python
# 推理系统

class InferenceSystem:
    """
    推理系统
    基于命题逻辑的推理
    """
    
    def __init__(self):
        self.knowledge_base: List[Proposition] = []
    
    def add_knowledge(self, proposition: Proposition) -> None:
        """添加知识到知识库"""
        self.knowledge_base.append(proposition)
    
    def query(self, question: Proposition) -> bool:
        """查询知识库"""
        return LogicalOperations.logical_entailment(self.knowledge_base, question)
    
    def is_consistent(self) -> bool:
        """检查知识库是否一致"""
        # 知识库一致当且仅当不存在矛盾
        for i, prop1 in enumerate(self.knowledge_base):
            for j, prop2 in enumerate(self.knowledge_base[i+1:], i+1):
                if LogicalOperations.is_contradiction(
                    PropositionBuilder.and_(prop1, prop2)
                ):
                    return False
        return True

# 使用示例
def demonstrate_inference():
    """演示推理系统"""
    
    # 创建推理系统
    system = InferenceSystem()
    
    # 添加知识
    p = PropositionBuilder.var("p")  # 下雨
    q = PropositionBuilder.var("q")  # 地面湿
    r = PropositionBuilder.var("r")  # 带伞
    
    system.add_knowledge(p)  # 下雨
    system.add_knowledge(PropositionBuilder.implies(p, q))  # 下雨 → 地面湿
    system.add_knowledge(PropositionBuilder.implies(q, r))  # 地面湿 → 带伞
    
    # 查询
    print(f"知识库一致: {system.is_consistent()}")
    print(f"是否带伞: {system.query(r)}")
```

### 4.3 知识表示

```python
# 知识表示

class KnowledgeRepresentation:
    """
    知识表示系统
    使用命题逻辑表示知识
    """
    
    def __init__(self):
        self.facts: Set[Proposition] = set()
        self.rules: List[Proposition] = []
    
    def add_fact(self, fact: Proposition) -> None:
        """添加事实"""
        self.facts.add(fact)
    
    def add_rule(self, rule: Proposition) -> None:
        """添加规则"""
        self.rules.append(rule)
    
    def infer(self, query: Proposition) -> bool:
        """推理查询"""
        all_knowledge = list(self.facts) + self.rules
        return LogicalOperations.logical_entailment(all_knowledge, query)
    
    def explain(self, query: Proposition) -> List[Proposition]:
        """解释推理过程"""
        # 简化的解释，实际需要更复杂的算法
        if self.infer(query):
            return list(self.facts) + self.rules
        return []

# 使用示例
def demonstrate_knowledge_representation():
    """演示知识表示"""
    
    # 创建知识表示系统
    kr = KnowledgeRepresentation()
    
    # 定义变量
    bird = PropositionBuilder.var("bird")
    fly = PropositionBuilder.var("fly")
    penguin = PropositionBuilder.var("penguin")
    
    # 添加知识
    kr.add_fact(bird)  # 是一只鸟
    kr.add_rule(PropositionBuilder.implies(bird, fly))  # 鸟会飞
    kr.add_fact(penguin)  # 是企鹅
    kr.add_rule(PropositionBuilder.implies(penguin, bird))  # 企鹅是鸟
    kr.add_rule(PropositionBuilder.implies(penguin, PropositionBuilder.neg(fly)))  # 企鹅不会飞
    
    # 推理
    print(f"会飞吗: {kr.infer(fly)}")
    print(f"是鸟吗: {kr.infer(bird)}")
```

## 5. 高级主题

### 5.1 命题逻辑的局限性

1. **表达能力有限**：无法表示量词和关系
2. **推理能力有限**：无法进行复杂的推理
3. **知识表示有限**：无法表示复杂的知识结构

### 5.2 扩展方向

1. **一阶逻辑**：添加量词和谓词
2. **模态逻辑**：添加模态算子
3. **时态逻辑**：添加时间概念
4. **模糊逻辑**：处理不确定性

---

**总结**：命题逻辑是逻辑学的基础，在程序验证、推理系统和知识表示等领域有重要应用。通过 Python 的实现，我们可以更好地理解命题逻辑的概念和操作。
