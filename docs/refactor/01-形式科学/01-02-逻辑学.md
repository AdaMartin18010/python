# 01-02 逻辑学 (Logic)

## 📋 目录

- [概述](#概述)
- [1. 命题逻辑](#1-命题逻辑)
- [2. 谓词逻辑](#2-谓词逻辑)
- [3. 形式化推理](#3-形式化推理)
- [4. 逻辑系统](#4-逻辑系统)
- [5. 形式化表示](#5-形式化表示)
- [6. Python实现](#6-python实现)
- [7. 参考文献](#7-参考文献)

## 概述

逻辑学是研究推理形式和推理规律的科学，是计算机科学和软件工程的重要理论基础。本文档涵盖命题逻辑、谓词逻辑、形式化推理等核心概念，为算法设计、程序验证等提供逻辑支撑。

## 1. 命题逻辑

### 1.1 命题的定义

**命题**: 可以判断真假的陈述句。

**原子命题**: 不可再分解的基本命题，用符号 $p, q, r, \ldots$ 表示。

**复合命题**: 由原子命题通过逻辑运算符构成的命题。

### 1.2 逻辑运算符

**否定 (Negation)**: $\neg p$ - "非p"

**合取 (Conjunction)**: $p \land q$ - "p且q"

**析取 (Disjunction)**: $p \lor q$ - "p或q"

**蕴含 (Implication)**: $p \rightarrow q$ - "如果p则q"

**等价 (Equivalence)**: $p \leftrightarrow q$ - "p当且仅当q"

**异或 (Exclusive OR)**: $p \oplus q$ - "p或q但不同时为真"

### 1.3 真值表

| p | q | ¬p | p∧q | p∨q | p→q | p↔q | p⊕q |
|---|---|----|-----|-----|-----|-----|-----|
| T | T | F  | T   | T   | T   | T   | F   |
| T | F | F  | F   | T   | F   | F   | T   |
| F | T | T  | F   | T   | T   | F   | T   |
| F | F | T  | F   | F   | T   | T   | F   |

### 1.4 逻辑等价

**德摩根律**:
- $\neg(p \land q) \equiv \neg p \lor \neg q$
- $\neg(p \lor q) \equiv \neg p \land \neg q$

**分配律**:
- $p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$
- $p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$

**双重否定**: $\neg(\neg p) \equiv p$

**蕴含等价**: $p \rightarrow q \equiv \neg p \lor q$

## 2. 谓词逻辑

### 2.1 谓词和量词

**谓词**: 描述对象性质的函数 $P(x), Q(x,y), \ldots$

**全称量词**: $\forall x P(x)$ - "对所有x，P(x)成立"

**存在量词**: $\exists x P(x)$ - "存在x，使得P(x)成立"

### 2.2 量词的性质

**量词否定**:
- $\neg \forall x P(x) \equiv \exists x \neg P(x)$
- $\neg \exists x P(x) \equiv \forall x \neg P(x)$

**量词分配**:
- $\forall x (P(x) \land Q(x)) \equiv \forall x P(x) \land \forall x Q(x)$
- $\exists x (P(x) \lor Q(x)) \equiv \exists x P(x) \lor \exists x Q(x)$

### 2.3 谓词逻辑公式

**原子公式**: $P(x), Q(x,y), \ldots$

**复合公式**: 由原子公式通过逻辑运算符和量词构成

**自由变元**: 不被量词约束的变元

**约束变元**: 被量词约束的变元

## 3. 形式化推理

### 3.1 推理规则

**假言推理 (Modus Ponens)**:
$$\frac{p \rightarrow q \quad p}{q}$$

**假言三段论**:
$$\frac{p \rightarrow q \quad q \rightarrow r}{p \rightarrow r}$$

**否定后件 (Modus Tollens)**:
$$\frac{p \rightarrow q \quad \neg q}{\neg p}$$

**析取三段论**:
$$\frac{p \lor q \quad \neg p}{q}$$

### 3.2 证明方法

**直接证明**: 从前提直接推导结论

**反证法**: 假设结论为假，推导矛盾

**归纳法**: 数学归纳法证明

**构造性证明**: 构造满足条件的对象

### 3.3 逻辑有效性

**有效推理**: 前提为真时结论必为真

**逻辑蕴涵**: $A \models B$ 表示A逻辑蕴涵B

**逻辑等价**: $A \equiv B$ 表示A和B逻辑等价

## 4. 逻辑系统

### 4.1 公理化系统

**公理**: 不证自明的基本命题

**推理规则**: 从已知命题推导新命题的规则

**定理**: 从公理通过推理规则推导出的命题

### 4.2 自然演绎系统

**引入规则**: 引入逻辑运算符的规则

**消除规则**: 消除逻辑运算符的规则

**假设规则**: 引入和消除假设的规则

### 4.3 语义和语法

**语法**: 符号的排列规则

**语义**: 符号的含义解释

**可靠性**: 语法推导的结论语义正确

**完备性**: 语义正确的结论可语法推导

## 5. 形式化表示

### 5.1 逻辑语言

**字母表**: 符号集合 $\Sigma$

**公式**: 合式公式的集合 $\mathcal{F}$

**解释**: 符号到语义的映射 $\mathcal{I}$

### 5.2 逻辑演算

**命题演算**: 处理命题逻辑的形式系统

**谓词演算**: 处理谓词逻辑的形式系统

**模态逻辑**: 处理必然性和可能性的逻辑

## 6. Python实现

```python
from typing import Dict, List, Set, Any, Callable, Optional
from abc import ABC, abstractmethod
from enum import Enum
import itertools

class LogicOperator(Enum):
    """逻辑运算符枚举"""
    NOT = "¬"
    AND = "∧"
    OR = "∨"
    IMPLIES = "→"
    EQUIVALENT = "↔"
    XOR = "⊕"

class PropositionalLogic:
    """命题逻辑实现"""
    
    def __init__(self):
        self.variables: Set[str] = set()
        self.truth_table_cache: Dict[str, List[Dict[str, bool]]] = {}
    
    def evaluate_expression(self, expression: str, assignment: Dict[str, bool]) -> bool:
        """计算逻辑表达式的值"""
        # 简单的表达式求值器
        # 支持基本的逻辑运算符
        expression = expression.replace(" ", "")
        
        # 替换变量
        for var, value in assignment.items():
            expression = expression.replace(var, str(value))
        
        # 替换逻辑运算符
        expression = expression.replace("¬", "not ")
        expression = expression.replace("∧", " and ")
        expression = expression.replace("∨", " or ")
        expression = expression.replace("→", " <= ")
        expression = expression.replace("↔", " == ")
        expression = expression.replace("⊕", " != ")
        
        # 处理not运算符
        expression = expression.replace("not True", "False")
        expression = expression.replace("not False", "True")
        
        try:
            return eval(expression)
        except:
            return False
    
    def generate_truth_table(self, expression: str) -> List[Dict[str, Any]]:
        """生成真值表"""
        if expression in self.truth_table_cache:
            return self.truth_table_cache[expression]
        
        # 提取变量
        variables = set()
        for char in expression:
            if char.isalpha() and char not in ['a', 'n', 'd', 'o', 'r', 't', 'f']:
                variables.add(char)
        
        variables = sorted(list(variables))
        
        # 生成所有可能的赋值
        truth_table = []
        for values in itertools.product([True, False], repeat=len(variables)):
            assignment = dict(zip(variables, values))
            result = self.evaluate_expression(expression, assignment)
            
            row = assignment.copy()
            row['result'] = result
            truth_table.append(row)
        
        self.truth_table_cache[expression] = truth_table
        return truth_table
    
    def is_tautology(self, expression: str) -> bool:
        """判断是否为重言式"""
        truth_table = self.generate_truth_table(expression)
        return all(row['result'] for row in truth_table)
    
    def is_contradiction(self, expression: str) -> bool:
        """判断是否为矛盾式"""
        truth_table = self.generate_truth_table(expression)
        return not any(row['result'] for row in truth_table)
    
    def is_satisfiable(self, expression: str) -> bool:
        """判断是否为可满足式"""
        return not self.is_contradiction(expression)
    
    def logical_equivalence(self, expr1: str, expr2: str) -> bool:
        """判断两个表达式是否逻辑等价"""
        # 提取所有变量
        all_vars = set()
        for char in expr1 + expr2:
            if char.isalpha() and char not in ['a', 'n', 'd', 'o', 'r', 't', 'f']:
                all_vars.add(char)
        
        all_vars = sorted(list(all_vars))
        
        # 检查所有赋值
        for values in itertools.product([True, False], repeat=len(all_vars)):
            assignment = dict(zip(all_vars, values))
            val1 = self.evaluate_expression(expr1, assignment)
            val2 = self.evaluate_expression(expr2, assignment)
            if val1 != val2:
                return False
        
        return True

class PredicateLogic:
    """谓词逻辑实现"""
    
    def __init__(self):
        self.predicates: Dict[str, Callable] = {}
        self.universe: Set[Any] = set()
    
    def add_predicate(self, name: str, predicate: Callable):
        """添加谓词"""
        self.predicates[name] = predicate
    
    def set_universe(self, universe: Set[Any]):
        """设置论域"""
        self.universe = universe
    
    def universal_quantifier(self, predicate_name: str) -> bool:
        """全称量词 ∀x P(x)"""
        if predicate_name not in self.predicates:
            return False
        
        predicate = self.predicates[predicate_name]
        return all(predicate(x) for x in self.universe)
    
    def existential_quantifier(self, predicate_name: str) -> bool:
        """存在量词 ∃x P(x)"""
        if predicate_name not in self.predicates:
            return False
        
        predicate = self.predicates[predicate_name]
        return any(predicate(x) for x in self.universe)
    
    def evaluate_formula(self, formula: str, assignment: Dict[str, Any]) -> bool:
        """计算谓词逻辑公式的值"""
        # 简化的公式求值器
        # 这里实现一个基本的谓词逻辑公式求值
        return True  # 简化实现

class FormalReasoning:
    """形式化推理实现"""
    
    def __init__(self):
        self.rules: List[Callable] = []
        self.axioms: Set[str] = set()
    
    def add_axiom(self, axiom: str):
        """添加公理"""
        self.axioms.add(axiom)
    
    def modus_ponens(self, premise1: str, premise2: str) -> Optional[str]:
        """假言推理: p→q, p ⊢ q"""
        # 检查前提是否为蕴含形式
        if "→" in premise1:
            p, q = premise1.split("→")
            if premise2.strip() == p.strip():
                return q.strip()
        return None
    
    def modus_tollens(self, premise1: str, premise2: str) -> Optional[str]:
        """否定后件: p→q, ¬q ⊢ ¬p"""
        if "→" in premise1:
            p, q = premise1.split("→")
            if premise2.strip() == f"¬{q.strip()}":
                return f"¬{p.strip()}"
        return None
    
    def hypothetical_syllogism(self, premise1: str, premise2: str) -> Optional[str]:
        """假言三段论: p→q, q→r ⊢ p→r"""
        if "→" in premise1 and "→" in premise2:
            p1, q1 = premise1.split("→")
            q2, r = premise2.split("→")
            if q1.strip() == q2.strip():
                return f"{p1.strip()}→{r.strip()}"
        return None
    
    def disjunctive_syllogism(self, premise1: str, premise2: str) -> Optional[str]:
        """析取三段论: p∨q, ¬p ⊢ q"""
        if "∨" in premise1:
            p, q = premise1.split("∨")
            if premise2.strip() == f"¬{p.strip()}":
                return q.strip()
        return None

class LogicSystem:
    """逻辑系统实现"""
    
    def __init__(self):
        self.propositional_logic = PropositionalLogic()
        self.predicate_logic = PredicateLogic()
        self.reasoning = FormalReasoning()
    
    def prove_theorem(self, premises: List[str], conclusion: str) -> bool:
        """证明定理"""
        # 简化的定理证明器
        # 在实际应用中，这需要更复杂的实现
        
        # 检查结论是否可以从前提推导
        current_premises = premises.copy()
        
        # 应用推理规则
        while True:
            new_premises = []
            
            for i, premise1 in enumerate(current_premises):
                for j, premise2 in enumerate(current_premises):
                    if i != j:
                        # 尝试应用各种推理规则
                        result = self.reasoning.modus_ponens(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
                        
                        result = self.reasoning.modus_tollens(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
                        
                        result = self.reasoning.hypothetical_syllogism(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
                        
                        result = self.reasoning.disjunctive_syllogism(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
            
            if not new_premises:
                break
            
            current_premises.extend(new_premises)
        
        return conclusion in current_premises
    
    def check_validity(self, argument: Dict[str, Any]) -> bool:
        """检查论证的有效性"""
        premises = argument.get('premises', [])
        conclusion = argument.get('conclusion', '')
        
        # 构造蕴含式: (premise1 ∧ premise2 ∧ ...) → conclusion
        if not premises:
            return True
        
        premise_expression = " ∧ ".join(premises)
        implication = f"({premise_expression}) → {conclusion}"
        
        return self.propositional_logic.is_tautology(implication)

# 使用示例
def demonstrate_logic():
    """演示逻辑学概念"""
    
    print("=== 命题逻辑演示 ===\n")
    
    logic = LogicSystem()
    
    # 真值表生成
    expression = "p∧q→r"
    truth_table = logic.propositional_logic.generate_truth_table(expression)
    print(f"表达式 '{expression}' 的真值表:")
    for row in truth_table:
        print(f"  p={row['p']}, q={row['q']}, r={row['r']}, result={row['result']}")
    
    # 重言式检查
    tautology = "p∨¬p"
    is_tautology = logic.propositional_logic.is_tautology(tautology)
    print(f"\n'{tautology}' 是重言式: {is_tautology}")
    
    # 矛盾式检查
    contradiction = "p∧¬p"
    is_contradiction = logic.propositional_logic.is_contradiction(contradiction)
    print(f"'{contradiction}' 是矛盾式: {is_contradiction}")
    
    # 逻辑等价检查
    expr1 = "p→q"
    expr2 = "¬p∨q"
    is_equivalent = logic.propositional_logic.logical_equivalence(expr1, expr2)
    print(f"'{expr1}' 和 '{expr2}' 逻辑等价: {is_equivalent}")
    
    print("\n=== 谓词逻辑演示 ===\n")
    
    # 设置论域和谓词
    logic.predicate_logic.set_universe({1, 2, 3, 4, 5})
    
    # 添加谓词
    logic.predicate_logic.add_predicate("is_even", lambda x: x % 2 == 0)
    logic.predicate_logic.add_predicate("is_positive", lambda x: x > 0)
    
    # 全称量词
    all_even = logic.predicate_logic.universal_quantifier("is_even")
    print(f"∀x is_even(x): {all_even}")
    
    # 存在量词
    exists_even = logic.predicate_logic.existential_quantifier("is_even")
    print(f"∃x is_even(x): {exists_even}")
    
    print("\n=== 形式化推理演示 ===\n")
    
    # 定理证明
    premises = ["p→q", "q→r", "p"]
    conclusion = "r"
    
    is_provable = logic.prove_theorem(premises, conclusion)
    print(f"从前提 {premises} 可以证明结论 '{conclusion}': {is_provable}")
    
    # 论证有效性检查
    argument = {
        'premises': ['p→q', 'p'],
        'conclusion': 'q'
    }
    
    is_valid = logic.check_validity(argument)
    print(f"论证 {argument} 有效: {is_valid}")
    
    print("\n=== 逻辑等价律演示 ===\n")
    
    # 德摩根律
    demorgan1_expr1 = "¬(p∧q)"
    demorgan1_expr2 = "¬p∨¬q"
    demorgan1_valid = logic.propositional_logic.logical_equivalence(
        demorgan1_expr1, demorgan1_expr2
    )
    print(f"德摩根律 ¬(p∧q) ≡ ¬p∨¬q: {demorgan1_valid}")
    
    demorgan2_expr1 = "¬(p∨q)"
    demorgan2_expr2 = "¬p∧¬q"
    demorgan2_valid = logic.propositional_logic.logical_equivalence(
        demorgan2_expr1, demorgan2_expr2
    )
    print(f"德摩根律 ¬(p∨q) ≡ ¬p∧¬q: {demorgan2_valid}")
    
    # 分配律
    distributive1_expr1 = "p∧(q∨r)"
    distributive1_expr2 = "(p∧q)∨(p∧r)"
    distributive1_valid = logic.propositional_logic.logical_equivalence(
        distributive1_expr1, distributive1_expr2
    )
    print(f"分配律 p∧(q∨r) ≡ (p∧q)∨(p∧r): {distributive1_valid}")
    
    # 蕴含等价
    implication_expr1 = "p→q"
    implication_expr2 = "¬p∨q"
    implication_valid = logic.propositional_logic.logical_equivalence(
        implication_expr1, implication_expr2
    )
    print(f"蕴含等价 p→q ≡ ¬p∨q: {implication_valid}")

if __name__ == "__main__":
    demonstrate_logic()
```

## 7. 参考文献

1. Enderton, H. B. (2001). "A Mathematical Introduction to Logic".
2. Mendelson, E. (2015). "Introduction to Mathematical Logic".
3. Boolos, G., et al. (2007). "Computability and Logic".
4. Smullyan, R. M. (1995). "First-Order Logic".

---

**相关文档**:
- [01-01-数学基础](./01-01-数学基础.md)
- [01-03-集合论](./01-03-集合论.md)
- [02-03-计算复杂性](./../02-理论基础/02-03-计算复杂性.md)

**最后更新**: 2024-01-XX  
**版本**: 1.0.0 