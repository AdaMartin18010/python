# 01-02 é€»è¾‘å­¦ (Logic)

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. å‘½é¢˜é€»è¾‘](#1-å‘½é¢˜é€»è¾‘)
- [2. è°“è¯é€»è¾‘](#2-è°“è¯é€»è¾‘)
- [3. å½¢å¼åŒ–æ¨ç†](#3-å½¢å¼åŒ–æ¨ç†)
- [4. é€»è¾‘ç³»ç»Ÿ](#4-é€»è¾‘ç³»ç»Ÿ)
- [5. å½¢å¼åŒ–è¡¨ç¤º](#5-å½¢å¼åŒ–è¡¨ç¤º)
- [6. Pythonå®ç°](#6-pythonå®ç°)
- [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## æ¦‚è¿°

é€»è¾‘å­¦æ˜¯ç ”ç©¶æ¨ç†å½¢å¼å’Œæ¨ç†è§„å¾‹çš„ç§‘å­¦ï¼Œæ˜¯è®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹çš„é‡è¦ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£æ¶µç›–å‘½é¢˜é€»è¾‘ã€è°“è¯é€»è¾‘ã€å½¢å¼åŒ–æ¨ç†ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºç®—æ³•è®¾è®¡ã€ç¨‹åºéªŒè¯ç­‰æä¾›é€»è¾‘æ”¯æ’‘ã€‚

## 1. å‘½é¢˜é€»è¾‘

### 1.1 å‘½é¢˜çš„å®šä¹‰

**å‘½é¢˜**: å¯ä»¥åˆ¤æ–­çœŸå‡çš„é™ˆè¿°å¥ã€‚

**åŸå­å‘½é¢˜**: ä¸å¯å†åˆ†è§£çš„åŸºæœ¬å‘½é¢˜ï¼Œç”¨ç¬¦å· $p, q, r, \ldots$ è¡¨ç¤ºã€‚

**å¤åˆå‘½é¢˜**: ç”±åŸå­å‘½é¢˜é€šè¿‡é€»è¾‘è¿ç®—ç¬¦æ„æˆçš„å‘½é¢˜ã€‚

### 1.2 é€»è¾‘è¿ç®—ç¬¦

**å¦å®š (Negation)**: $\neg p$ - "ép"

**åˆå– (Conjunction)**: $p \land q$ - "pä¸”q"

**æå– (Disjunction)**: $p \lor q$ - "pæˆ–q"

**è•´å« (Implication)**: $p \rightarrow q$ - "å¦‚æœpåˆ™q"

**ç­‰ä»· (Equivalence)**: $p \leftrightarrow q$ - "på½“ä¸”ä»…å½“q"

**å¼‚æˆ– (Exclusive OR)**: $p \oplus q$ - "pæˆ–qä½†ä¸åŒæ—¶ä¸ºçœŸ"

### 1.3 çœŸå€¼è¡¨

| p | q | Â¬p | pâˆ§q | pâˆ¨q | pâ†’q | pâ†”q | pâŠ•q |
|---|---|----|-----|-----|-----|-----|-----|
| T | T | F  | T   | T   | T   | T   | F   |
| T | F | F  | F   | T   | F   | F   | T   |
| F | T | T  | F   | T   | T   | F   | T   |
| F | F | T  | F   | F   | T   | T   | F   |

### 1.4 é€»è¾‘ç­‰ä»·

**å¾·æ‘©æ ¹å¾‹**:
- $\neg(p \land q) \equiv \neg p \lor \neg q$
- $\neg(p \lor q) \equiv \neg p \land \neg q$

**åˆ†é…å¾‹**:
- $p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$
- $p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$

**åŒé‡å¦å®š**: $\neg(\neg p) \equiv p$

**è•´å«ç­‰ä»·**: $p \rightarrow q \equiv \neg p \lor q$

## 2. è°“è¯é€»è¾‘

### 2.1 è°“è¯å’Œé‡è¯

**è°“è¯**: æè¿°å¯¹è±¡æ€§è´¨çš„å‡½æ•° $P(x), Q(x,y), \ldots$

**å…¨ç§°é‡è¯**: $\forall x P(x)$ - "å¯¹æ‰€æœ‰xï¼ŒP(x)æˆç«‹"

**å­˜åœ¨é‡è¯**: $\exists x P(x)$ - "å­˜åœ¨xï¼Œä½¿å¾—P(x)æˆç«‹"

### 2.2 é‡è¯çš„æ€§è´¨

**é‡è¯å¦å®š**:
- $\neg \forall x P(x) \equiv \exists x \neg P(x)$
- $\neg \exists x P(x) \equiv \forall x \neg P(x)$

**é‡è¯åˆ†é…**:
- $\forall x (P(x) \land Q(x)) \equiv \forall x P(x) \land \forall x Q(x)$
- $\exists x (P(x) \lor Q(x)) \equiv \exists x P(x) \lor \exists x Q(x)$

### 2.3 è°“è¯é€»è¾‘å…¬å¼

**åŸå­å…¬å¼**: $P(x), Q(x,y), \ldots$

**å¤åˆå…¬å¼**: ç”±åŸå­å…¬å¼é€šè¿‡é€»è¾‘è¿ç®—ç¬¦å’Œé‡è¯æ„æˆ

**è‡ªç”±å˜å…ƒ**: ä¸è¢«é‡è¯çº¦æŸçš„å˜å…ƒ

**çº¦æŸå˜å…ƒ**: è¢«é‡è¯çº¦æŸçš„å˜å…ƒ

## 3. å½¢å¼åŒ–æ¨ç†

### 3.1 æ¨ç†è§„åˆ™

**å‡è¨€æ¨ç† (Modus Ponens)**:
$$\frac{p \rightarrow q \quad p}{q}$$

**å‡è¨€ä¸‰æ®µè®º**:
$$\frac{p \rightarrow q \quad q \rightarrow r}{p \rightarrow r}$$

**å¦å®šåä»¶ (Modus Tollens)**:
$$\frac{p \rightarrow q \quad \neg q}{\neg p}$$

**æå–ä¸‰æ®µè®º**:
$$\frac{p \lor q \quad \neg p}{q}$$

### 3.2 è¯æ˜æ–¹æ³•

**ç›´æ¥è¯æ˜**: ä»å‰æç›´æ¥æ¨å¯¼ç»“è®º

**åè¯æ³•**: å‡è®¾ç»“è®ºä¸ºå‡ï¼Œæ¨å¯¼çŸ›ç›¾

**å½’çº³æ³•**: æ•°å­¦å½’çº³æ³•è¯æ˜

**æ„é€ æ€§è¯æ˜**: æ„é€ æ»¡è¶³æ¡ä»¶çš„å¯¹è±¡

### 3.3 é€»è¾‘æœ‰æ•ˆæ€§

**æœ‰æ•ˆæ¨ç†**: å‰æä¸ºçœŸæ—¶ç»“è®ºå¿…ä¸ºçœŸ

**é€»è¾‘è•´æ¶µ**: $A \models B$ è¡¨ç¤ºAé€»è¾‘è•´æ¶µB

**é€»è¾‘ç­‰ä»·**: $A \equiv B$ è¡¨ç¤ºAå’ŒBé€»è¾‘ç­‰ä»·

## 4. é€»è¾‘ç³»ç»Ÿ

### 4.1 å…¬ç†åŒ–ç³»ç»Ÿ

**å…¬ç†**: ä¸è¯è‡ªæ˜çš„åŸºæœ¬å‘½é¢˜

**æ¨ç†è§„åˆ™**: ä»å·²çŸ¥å‘½é¢˜æ¨å¯¼æ–°å‘½é¢˜çš„è§„åˆ™

**å®šç†**: ä»å…¬ç†é€šè¿‡æ¨ç†è§„åˆ™æ¨å¯¼å‡ºçš„å‘½é¢˜

### 4.2 è‡ªç„¶æ¼”ç»ç³»ç»Ÿ

**å¼•å…¥è§„åˆ™**: å¼•å…¥é€»è¾‘è¿ç®—ç¬¦çš„è§„åˆ™

**æ¶ˆé™¤è§„åˆ™**: æ¶ˆé™¤é€»è¾‘è¿ç®—ç¬¦çš„è§„åˆ™

**å‡è®¾è§„åˆ™**: å¼•å…¥å’Œæ¶ˆé™¤å‡è®¾çš„è§„åˆ™

### 4.3 è¯­ä¹‰å’Œè¯­æ³•

**è¯­æ³•**: ç¬¦å·çš„æ’åˆ—è§„åˆ™

**è¯­ä¹‰**: ç¬¦å·çš„å«ä¹‰è§£é‡Š

**å¯é æ€§**: è¯­æ³•æ¨å¯¼çš„ç»“è®ºè¯­ä¹‰æ­£ç¡®

**å®Œå¤‡æ€§**: è¯­ä¹‰æ­£ç¡®çš„ç»“è®ºå¯è¯­æ³•æ¨å¯¼

## 5. å½¢å¼åŒ–è¡¨ç¤º

### 5.1 é€»è¾‘è¯­è¨€

**å­—æ¯è¡¨**: ç¬¦å·é›†åˆ $\Sigma$

**å…¬å¼**: åˆå¼å…¬å¼çš„é›†åˆ $\mathcal{F}$

**è§£é‡Š**: ç¬¦å·åˆ°è¯­ä¹‰çš„æ˜ å°„ $\mathcal{I}$

### 5.2 é€»è¾‘æ¼”ç®—

**å‘½é¢˜æ¼”ç®—**: å¤„ç†å‘½é¢˜é€»è¾‘çš„å½¢å¼ç³»ç»Ÿ

**è°“è¯æ¼”ç®—**: å¤„ç†è°“è¯é€»è¾‘çš„å½¢å¼ç³»ç»Ÿ

**æ¨¡æ€é€»è¾‘**: å¤„ç†å¿…ç„¶æ€§å’Œå¯èƒ½æ€§çš„é€»è¾‘

## 6. Pythonå®ç°

```python
from typing import Dict, List, Set, Any, Callable, Optional
from abc import ABC, abstractmethod
from enum import Enum
import itertools

class LogicOperator(Enum):
    """é€»è¾‘è¿ç®—ç¬¦æšä¸¾"""
    NOT = "Â¬"
    AND = "âˆ§"
    OR = "âˆ¨"
    IMPLIES = "â†’"
    EQUIVALENT = "â†”"
    XOR = "âŠ•"

class PropositionalLogic:
    """å‘½é¢˜é€»è¾‘å®ç°"""
    
    def __init__(self):
        self.variables: Set[str] = set()
        self.truth_table_cache: Dict[str, List[Dict[str, bool]]] = {}
    
    def evaluate_expression(self, expression: str, assignment: Dict[str, bool]) -> bool:
        """è®¡ç®—é€»è¾‘è¡¨è¾¾å¼çš„å€¼"""
        # ç®€å•çš„è¡¨è¾¾å¼æ±‚å€¼å™¨
        # æ”¯æŒåŸºæœ¬çš„é€»è¾‘è¿ç®—ç¬¦
        expression = expression.replace(" ", "")
        
        # æ›¿æ¢å˜é‡
        for var, value in assignment.items():
            expression = expression.replace(var, str(value))
        
        # æ›¿æ¢é€»è¾‘è¿ç®—ç¬¦
        expression = expression.replace("Â¬", "not ")
        expression = expression.replace("âˆ§", " and ")
        expression = expression.replace("âˆ¨", " or ")
        expression = expression.replace("â†’", " <= ")
        expression = expression.replace("â†”", " == ")
        expression = expression.replace("âŠ•", " != ")
        
        # å¤„ç†notè¿ç®—ç¬¦
        expression = expression.replace("not True", "False")
        expression = expression.replace("not False", "True")
        
        try:
            return eval(expression)
        except:
            return False
    
    def generate_truth_table(self, expression: str) -> List[Dict[str, Any]]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        if expression in self.truth_table_cache:
            return self.truth_table_cache[expression]
        
        # æå–å˜é‡
        variables = set()
        for char in expression:
            if char.isalpha() and char not in ['a', 'n', 'd', 'o', 'r', 't', 'f']:
                variables.add(char)
        
        variables = sorted(list(variables))
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„èµ‹å€¼
        truth_table = []
        for values in itertools.product([True, False], repeat=len(variables)):
            assignment = dict(zip(variables, values))
            result = self.evaluate_expression(expression, assignment)
            
            row = assignment.copy()
            row['result'] = result
            truth_table.append(row)
        
        self.truth_table_cache[expression] = truth_table
        return truth_table
    
    def is_tautology(self, expression: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºé‡è¨€å¼"""
        truth_table = self.generate_truth_table(expression)
        return all(row['result'] for row in truth_table)
    
    def is_contradiction(self, expression: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        truth_table = self.generate_truth_table(expression)
        return not any(row['result'] for row in truth_table)
    
    def is_satisfiable(self, expression: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼"""
        return not self.is_contradiction(expression)
    
    def logical_equivalence(self, expr1: str, expr2: str) -> bool:
        """åˆ¤æ–­ä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯å¦é€»è¾‘ç­‰ä»·"""
        # æå–æ‰€æœ‰å˜é‡
        all_vars = set()
        for char in expr1 + expr2:
            if char.isalpha() and char not in ['a', 'n', 'd', 'o', 'r', 't', 'f']:
                all_vars.add(char)
        
        all_vars = sorted(list(all_vars))
        
        # æ£€æŸ¥æ‰€æœ‰èµ‹å€¼
        for values in itertools.product([True, False], repeat=len(all_vars)):
            assignment = dict(zip(all_vars, values))
            val1 = self.evaluate_expression(expr1, assignment)
            val2 = self.evaluate_expression(expr2, assignment)
            if val1 != val2:
                return False
        
        return True

class PredicateLogic:
    """è°“è¯é€»è¾‘å®ç°"""
    
    def __init__(self):
        self.predicates: Dict[str, Callable] = {}
        self.universe: Set[Any] = set()
    
    def add_predicate(self, name: str, predicate: Callable):
        """æ·»åŠ è°“è¯"""
        self.predicates[name] = predicate
    
    def set_universe(self, universe: Set[Any]):
        """è®¾ç½®è®ºåŸŸ"""
        self.universe = universe
    
    def universal_quantifier(self, predicate_name: str) -> bool:
        """å…¨ç§°é‡è¯ âˆ€x P(x)"""
        if predicate_name not in self.predicates:
            return False
        
        predicate = self.predicates[predicate_name]
        return all(predicate(x) for x in self.universe)
    
    def existential_quantifier(self, predicate_name: str) -> bool:
        """å­˜åœ¨é‡è¯ âˆƒx P(x)"""
        if predicate_name not in self.predicates:
            return False
        
        predicate = self.predicates[predicate_name]
        return any(predicate(x) for x in self.universe)
    
    def evaluate_formula(self, formula: str, assignment: Dict[str, Any]) -> bool:
        """è®¡ç®—è°“è¯é€»è¾‘å…¬å¼çš„å€¼"""
        # ç®€åŒ–çš„å…¬å¼æ±‚å€¼å™¨
        # è¿™é‡Œå®ç°ä¸€ä¸ªåŸºæœ¬çš„è°“è¯é€»è¾‘å…¬å¼æ±‚å€¼
        return True  # ç®€åŒ–å®ç°

class FormalReasoning:
    """å½¢å¼åŒ–æ¨ç†å®ç°"""
    
    def __init__(self):
        self.rules: List[Callable] = []
        self.axioms: Set[str] = set()
    
    def add_axiom(self, axiom: str):
        """æ·»åŠ å…¬ç†"""
        self.axioms.add(axiom)
    
    def modus_ponens(self, premise1: str, premise2: str) -> Optional[str]:
        """å‡è¨€æ¨ç†: pâ†’q, p âŠ¢ q"""
        # æ£€æŸ¥å‰ææ˜¯å¦ä¸ºè•´å«å½¢å¼
        if "â†’" in premise1:
            p, q = premise1.split("â†’")
            if premise2.strip() == p.strip():
                return q.strip()
        return None
    
    def modus_tollens(self, premise1: str, premise2: str) -> Optional[str]:
        """å¦å®šåä»¶: pâ†’q, Â¬q âŠ¢ Â¬p"""
        if "â†’" in premise1:
            p, q = premise1.split("â†’")
            if premise2.strip() == f"Â¬{q.strip()}":
                return f"Â¬{p.strip()}"
        return None
    
    def hypothetical_syllogism(self, premise1: str, premise2: str) -> Optional[str]:
        """å‡è¨€ä¸‰æ®µè®º: pâ†’q, qâ†’r âŠ¢ pâ†’r"""
        if "â†’" in premise1 and "â†’" in premise2:
            p1, q1 = premise1.split("â†’")
            q2, r = premise2.split("â†’")
            if q1.strip() == q2.strip():
                return f"{p1.strip()}â†’{r.strip()}"
        return None
    
    def disjunctive_syllogism(self, premise1: str, premise2: str) -> Optional[str]:
        """æå–ä¸‰æ®µè®º: pâˆ¨q, Â¬p âŠ¢ q"""
        if "âˆ¨" in premise1:
            p, q = premise1.split("âˆ¨")
            if premise2.strip() == f"Â¬{p.strip()}":
                return q.strip()
        return None

class LogicSystem:
    """é€»è¾‘ç³»ç»Ÿå®ç°"""
    
    def __init__(self):
        self.propositional_logic = PropositionalLogic()
        self.predicate_logic = PredicateLogic()
        self.reasoning = FormalReasoning()
    
    def prove_theorem(self, premises: List[str], conclusion: str) -> bool:
        """è¯æ˜å®šç†"""
        # ç®€åŒ–çš„å®šç†è¯æ˜å™¨
        # åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™éœ€è¦æ›´å¤æ‚çš„å®ç°
        
        # æ£€æŸ¥ç»“è®ºæ˜¯å¦å¯ä»¥ä»å‰ææ¨å¯¼
        current_premises = premises.copy()
        
        # åº”ç”¨æ¨ç†è§„åˆ™
        while True:
            new_premises = []
            
            for i, premise1 in enumerate(current_premises):
                for j, premise2 in enumerate(current_premises):
                    if i != j:
                        # å°è¯•åº”ç”¨å„ç§æ¨ç†è§„åˆ™
                        result = self.reasoning.modus_ponens(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
                        
                        result = self.reasoning.modus_tollens(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
                        
                        result = self.reasoning.hypothetical_syllogism(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
                        
                        result = self.reasoning.disjunctive_syllogism(premise1, premise2)
                        if result and result not in current_premises:
                            new_premises.append(result)
            
            if not new_premises:
                break
            
            current_premises.extend(new_premises)
        
        return conclusion in current_premises
    
    def check_validity(self, argument: Dict[str, Any]) -> bool:
        """æ£€æŸ¥è®ºè¯çš„æœ‰æ•ˆæ€§"""
        premises = argument.get('premises', [])
        conclusion = argument.get('conclusion', '')
        
        # æ„é€ è•´å«å¼: (premise1 âˆ§ premise2 âˆ§ ...) â†’ conclusion
        if not premises:
            return True
        
        premise_expression = " âˆ§ ".join(premises)
        implication = f"({premise_expression}) â†’ {conclusion}"
        
        return self.propositional_logic.is_tautology(implication)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_logic():
    """æ¼”ç¤ºé€»è¾‘å­¦æ¦‚å¿µ"""
    
    print("=== å‘½é¢˜é€»è¾‘æ¼”ç¤º ===\n")
    
    logic = LogicSystem()
    
    # çœŸå€¼è¡¨ç”Ÿæˆ
    expression = "pâˆ§qâ†’r"
    truth_table = logic.propositional_logic.generate_truth_table(expression)
    print(f"è¡¨è¾¾å¼ '{expression}' çš„çœŸå€¼è¡¨:")
    for row in truth_table:
        print(f"  p={row['p']}, q={row['q']}, r={row['r']}, result={row['result']}")
    
    # é‡è¨€å¼æ£€æŸ¥
    tautology = "pâˆ¨Â¬p"
    is_tautology = logic.propositional_logic.is_tautology(tautology)
    print(f"\n'{tautology}' æ˜¯é‡è¨€å¼: {is_tautology}")
    
    # çŸ›ç›¾å¼æ£€æŸ¥
    contradiction = "pâˆ§Â¬p"
    is_contradiction = logic.propositional_logic.is_contradiction(contradiction)
    print(f"'{contradiction}' æ˜¯çŸ›ç›¾å¼: {is_contradiction}")
    
    # é€»è¾‘ç­‰ä»·æ£€æŸ¥
    expr1 = "pâ†’q"
    expr2 = "Â¬pâˆ¨q"
    is_equivalent = logic.propositional_logic.logical_equivalence(expr1, expr2)
    print(f"'{expr1}' å’Œ '{expr2}' é€»è¾‘ç­‰ä»·: {is_equivalent}")
    
    print("\n=== è°“è¯é€»è¾‘æ¼”ç¤º ===\n")
    
    # è®¾ç½®è®ºåŸŸå’Œè°“è¯
    logic.predicate_logic.set_universe({1, 2, 3, 4, 5})
    
    # æ·»åŠ è°“è¯
    logic.predicate_logic.add_predicate("is_even", lambda x: x % 2 == 0)
    logic.predicate_logic.add_predicate("is_positive", lambda x: x > 0)
    
    # å…¨ç§°é‡è¯
    all_even = logic.predicate_logic.universal_quantifier("is_even")
    print(f"âˆ€x is_even(x): {all_even}")
    
    # å­˜åœ¨é‡è¯
    exists_even = logic.predicate_logic.existential_quantifier("is_even")
    print(f"âˆƒx is_even(x): {exists_even}")
    
    print("\n=== å½¢å¼åŒ–æ¨ç†æ¼”ç¤º ===\n")
    
    # å®šç†è¯æ˜
    premises = ["pâ†’q", "qâ†’r", "p"]
    conclusion = "r"
    
    is_provable = logic.prove_theorem(premises, conclusion)
    print(f"ä»å‰æ {premises} å¯ä»¥è¯æ˜ç»“è®º '{conclusion}': {is_provable}")
    
    # è®ºè¯æœ‰æ•ˆæ€§æ£€æŸ¥
    argument = {
        'premises': ['pâ†’q', 'p'],
        'conclusion': 'q'
    }
    
    is_valid = logic.check_validity(argument)
    print(f"è®ºè¯ {argument} æœ‰æ•ˆ: {is_valid}")
    
    print("\n=== é€»è¾‘ç­‰ä»·å¾‹æ¼”ç¤º ===\n")
    
    # å¾·æ‘©æ ¹å¾‹
    demorgan1_expr1 = "Â¬(pâˆ§q)"
    demorgan1_expr2 = "Â¬pâˆ¨Â¬q"
    demorgan1_valid = logic.propositional_logic.logical_equivalence(
        demorgan1_expr1, demorgan1_expr2
    )
    print(f"å¾·æ‘©æ ¹å¾‹ Â¬(pâˆ§q) â‰¡ Â¬pâˆ¨Â¬q: {demorgan1_valid}")
    
    demorgan2_expr1 = "Â¬(pâˆ¨q)"
    demorgan2_expr2 = "Â¬pâˆ§Â¬q"
    demorgan2_valid = logic.propositional_logic.logical_equivalence(
        demorgan2_expr1, demorgan2_expr2
    )
    print(f"å¾·æ‘©æ ¹å¾‹ Â¬(pâˆ¨q) â‰¡ Â¬pâˆ§Â¬q: {demorgan2_valid}")
    
    # åˆ†é…å¾‹
    distributive1_expr1 = "pâˆ§(qâˆ¨r)"
    distributive1_expr2 = "(pâˆ§q)âˆ¨(pâˆ§r)"
    distributive1_valid = logic.propositional_logic.logical_equivalence(
        distributive1_expr1, distributive1_expr2
    )
    print(f"åˆ†é…å¾‹ pâˆ§(qâˆ¨r) â‰¡ (pâˆ§q)âˆ¨(pâˆ§r): {distributive1_valid}")
    
    # è•´å«ç­‰ä»·
    implication_expr1 = "pâ†’q"
    implication_expr2 = "Â¬pâˆ¨q"
    implication_valid = logic.propositional_logic.logical_equivalence(
        implication_expr1, implication_expr2
    )
    print(f"è•´å«ç­‰ä»· pâ†’q â‰¡ Â¬pâˆ¨q: {implication_valid}")

if __name__ == "__main__":
    demonstrate_logic()
```

## 7. å‚è€ƒæ–‡çŒ®

1. Enderton, H. B. (2001). "A Mathematical Introduction to Logic".
2. Mendelson, E. (2015). "Introduction to Mathematical Logic".
3. Boolos, G., et al. (2007). "Computability and Logic".
4. Smullyan, R. M. (1995). "First-Order Logic".

---

**ç›¸å…³æ–‡æ¡£**:
- [01-01-æ•°å­¦åŸºç¡€](./01-01-æ•°å­¦åŸºç¡€.md)
- [01-03-é›†åˆè®º](./01-03-é›†åˆè®º.md)
- [02-03-è®¡ç®—å¤æ‚æ€§](./../02-ç†è®ºåŸºç¡€/02-03-è®¡ç®—å¤æ‚æ€§.md)

**æœ€åæ›´æ–°**: 2024-01-XX  
**ç‰ˆæœ¬**: 1.0.0 