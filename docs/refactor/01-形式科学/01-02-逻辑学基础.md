# 01-02-é€»è¾‘å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

é€»è¾‘å­¦æ˜¯ç ”ç©¶æ¨ç†å½¢å¼å’Œæœ‰æ•ˆæ€§çš„å­¦ç§‘ï¼Œä¸ºè®¡ç®—æœºç§‘å­¦ã€äººå·¥æ™ºèƒ½å’Œè½¯ä»¶å·¥ç¨‹æä¾›äº†ç†è®ºåŸºç¡€ã€‚åŒ…æ‹¬å‘½é¢˜é€»è¾‘ã€è°“è¯é€»è¾‘ã€æ¨¡æ€é€»è¾‘ç­‰åˆ†æ”¯ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å‘½é¢˜é€»è¾‘ (Propositional Logic)

**æ¦‚å¿µå®šä¹‰**: å‘½é¢˜é€»è¾‘æ˜¯ç ”ç©¶ç®€å•å‘½é¢˜åŠå…¶é€»è¾‘è¿æ¥è¯çš„æ¨ç†ç³»ç»Ÿã€‚

**æ•°å­¦å½¢å¼**:
å‘½é¢˜é€»è¾‘çš„è¯­æ³•ï¼š

$$P ::= p | \neg P | P \land Q | P \lor Q | P \rightarrow Q | P \leftrightarrow Q$$

å…¶ä¸­ $p$ æ˜¯åŸå­å‘½é¢˜ï¼Œ$\neg, \land, \lor, \rightarrow, \leftrightarrow$ æ˜¯é€»è¾‘è¿æ¥è¯ã€‚

**Pythonå®ç°**:

```python
from typing import Dict, Set, List, Optional, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import itertools

class LogicalOperator(Enum):
    """é€»è¾‘è¿ç®—ç¬¦"""
    NOT = "Â¬"
    AND = "âˆ§"
    OR = "âˆ¨"
    IMPLIES = "â†’"
    EQUIVALENT = "â†”"

@dataclass
class PropositionalFormula:
    """å‘½é¢˜é€»è¾‘å…¬å¼"""
    operator: Optional[LogicalOperator]
    operands: List[Union[str, 'PropositionalFormula']]
    is_atomic: bool = False
    
    def __str__(self) -> str:
        if self.is_atomic:
            return self.operands[0]
        
        if self.operator == LogicalOperator.NOT:
            return f"Â¬({self.operands[0]})"
        elif self.operator == LogicalOperator.AND:
            return f"({' âˆ§ '.join(str(op) for op in self.operands)})"
        elif self.operator == LogicalOperator.OR:
            return f"({' âˆ¨ '.join(str(op) for op in self.operands)})"
        elif self.operator == LogicalOperator.IMPLIES:
            return f"({self.operands[0]} â†’ {self.operands[1]})"
        elif self.operator == LogicalOperator.EQUIVALENT:
            return f"({self.operands[0]} â†” {self.operands[1]})"
        
        return str(self.operands)

class PropositionalLogic:
    """å‘½é¢˜é€»è¾‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.variables: Set[str] = set()
        self.formulas: List[PropositionalFormula] = []
    
    def add_variable(self, variable: str) -> None:
        """æ·»åŠ å˜é‡"""
        self.variables.add(variable)
    
    def create_atomic(self, variable: str) -> PropositionalFormula:
        """åˆ›å»ºåŸå­å‘½é¢˜"""
        return PropositionalFormula(None, [variable], is_atomic=True)
    
    def create_not(self, formula: PropositionalFormula) -> PropositionalFormula:
        """åˆ›å»ºå¦å®š"""
        return PropositionalFormula(LogicalOperator.NOT, [formula])
    
    def create_and(self, formulas: List[PropositionalFormula]) -> PropositionalFormula:
        """åˆ›å»ºåˆå–"""
        return PropositionalFormula(LogicalOperator.AND, formulas)
    
    def create_or(self, formulas: List[PropositionalFormula]) -> PropositionalFormula:
        """åˆ›å»ºæå–"""
        return PropositionalFormula(LogicalOperator.OR, formulas)
    
    def create_implies(self, antecedent: PropositionalFormula, 
                      consequent: PropositionalFormula) -> PropositionalFormula:
        """åˆ›å»ºè•´å«"""
        return PropositionalFormula(LogicalOperator.IMPLIES, [antecedent, consequent])
    
    def create_equivalent(self, left: PropositionalFormula, 
                         right: PropositionalFormula) -> PropositionalFormula:
        """åˆ›å»ºç­‰ä»·"""
        return PropositionalFormula(LogicalOperator.EQUIVALENT, [left, right])
    
    def evaluate(self, formula: PropositionalFormula, 
                interpretation: Dict[str, bool]) -> bool:
        """è¯„ä¼°å…¬å¼åœ¨ç»™å®šè§£é‡Šä¸‹çš„çœŸå€¼"""
        if formula.is_atomic:
            variable = formula.operands[0]
            return interpretation.get(variable, False)
        
        if formula.operator == LogicalOperator.NOT:
            return not self.evaluate(formula.operands[0], interpretation)
        
        elif formula.operator == LogicalOperator.AND:
            return all(self.evaluate(op, interpretation) for op in formula.operands)
        
        elif formula.operator == LogicalOperator.OR:
            return any(self.evaluate(op, interpretation) for op in formula.operands)
        
        elif formula.operator == LogicalOperator.IMPLIES:
            antecedent = self.evaluate(formula.operands[0], interpretation)
            consequent = self.evaluate(formula.operands[1], interpretation)
            return not antecedent or consequent
        
        elif formula.operator == LogicalOperator.EQUIVALENT:
            left = self.evaluate(formula.operands[0], interpretation)
            right = self.evaluate(formula.operands[1], interpretation)
            return left == right
        
        return False
    
    def truth_table(self, formula: PropositionalFormula) -> List[Dict]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        variables = self._extract_variables(formula)
        truth_table = []
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§£é‡Š
        for values in itertools.product([True, False], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            result = self.evaluate(formula, interpretation)
            
            row = interpretation.copy()
            row['result'] = result
            truth_table.append(row)
        
        return truth_table
    
    def is_tautology(self, formula: PropositionalFormula) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºé‡è¨€å¼"""
        truth_table = self.truth_table(formula)
        return all(row['result'] for row in truth_table)
    
    def is_contradiction(self, formula: PropositionalFormula) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        truth_table = self.truth_table(formula)
        return not any(row['result'] for row in truth_table)
    
    def is_satisfiable(self, formula: PropositionalFormula) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼"""
        truth_table = self.truth_table(formula)
        return any(row['result'] for row in truth_table)
    
    def is_equivalent(self, formula1: PropositionalFormula, 
                     formula2: PropositionalFormula) -> bool:
        """åˆ¤æ–­ä¸¤ä¸ªå…¬å¼æ˜¯å¦ç­‰ä»·"""
        # åˆå¹¶ä¸¤ä¸ªå…¬å¼çš„å˜é‡
        variables = self._extract_variables(formula1) | self._extract_variables(formula2)
        
        for values in itertools.product([True, False], repeat=len(variables)):
            interpretation = dict(zip(variables, values))
            result1 = self.evaluate(formula1, interpretation)
            result2 = self.evaluate(formula2, interpretation)
            
            if result1 != result2:
                return False
        
        return True
    
    def _extract_variables(self, formula: PropositionalFormula) -> Set[str]:
        """æå–å…¬å¼ä¸­çš„å˜é‡"""
        variables = set()
        
        if formula.is_atomic:
            variables.add(formula.operands[0])
        else:
            for operand in formula.operands:
                if isinstance(operand, PropositionalFormula):
                    variables.update(self._extract_variables(operand))
                else:
                    variables.add(operand)
        
        return variables

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_propositional_logic():
    """æ¼”ç¤ºå‘½é¢˜é€»è¾‘"""
    print("=== å‘½é¢˜é€»è¾‘æ¼”ç¤º ===")
    
    logic = PropositionalLogic()
    
    # åˆ›å»ºå˜é‡
    p = logic.create_atomic("p")
    q = logic.create_atomic("q")
    r = logic.create_atomic("r")
    
    # åˆ›å»ºå…¬å¼
    formula1 = logic.create_implies(p, q)  # p â†’ q
    formula2 = logic.create_equivalent(
        logic.create_implies(p, q),
        logic.create_or(logic.create_not(p), q)
    )  # (p â†’ q) â†” (Â¬p âˆ¨ q)
    
    print(f"å…¬å¼1: {formula1}")
    print(f"å…¬å¼2: {formula2}")
    
    # çœŸå€¼è¡¨
    print(f"\nå…¬å¼1çš„çœŸå€¼è¡¨:")
    truth_table = logic.truth_table(formula1)
    for row in truth_table:
        print(f"p={row['p']}, q={row['q']} -> {row['result']}")
    
    # é€»è¾‘æ€§è´¨
    print(f"\nå…¬å¼1æ˜¯é‡è¨€å¼: {logic.is_tautology(formula1)}")
    print(f"å…¬å¼2æ˜¯é‡è¨€å¼: {logic.is_tautology(formula2)}")
    print(f"å…¬å¼1æ˜¯å¯æ»¡è¶³å¼: {logic.is_satisfiable(formula1)}")
    
    # ç­‰ä»·æ€§
    print(f"\nå…¬å¼1å’Œå…¬å¼2ç­‰ä»·: {logic.is_equivalent(formula1, formula2)}")
```

### 2. è°“è¯é€»è¾‘ (Predicate Logic)

**æ¦‚å¿µå®šä¹‰**: è°“è¯é€»è¾‘æ˜¯å‘½é¢˜é€»è¾‘çš„æ‰©å±•ï¼Œå¼•å…¥äº†é‡è¯å’Œè°“è¯ï¼Œèƒ½å¤Ÿè¡¨è¾¾æ›´å¤æ‚çš„é€»è¾‘å…³ç³»ã€‚

**æ•°å­¦å½¢å¼**:
è°“è¯é€»è¾‘çš„è¯­æ³•ï¼š

$$F ::= P(t_1, ..., t_n) | \neg F | F \land G | F \lor G | F \rightarrow G | \forall x F | \exists x F$$

å…¶ä¸­ $P$ æ˜¯è°“è¯ï¼Œ$t_i$ æ˜¯é¡¹ï¼Œ$\forall, \exists$ æ˜¯é‡è¯ã€‚

**Pythonå®ç°**:

```python
from typing import Dict, List, Set, Optional, Union, Callable
from dataclasses import dataclass
from enum import Enum

class Quantifier(Enum):
    """é‡è¯ç±»å‹"""
    FORALL = "âˆ€"
    EXISTS = "âˆƒ"

@dataclass
class Term:
    """é¡¹"""
    name: str
    is_variable: bool = True
    
    def __str__(self) -> str:
        return self.name

@dataclass
class Predicate:
    """è°“è¯"""
    name: str
    arguments: List[Term]
    
    def __str__(self) -> str:
        args_str = ", ".join(str(arg) for arg in self.arguments)
        return f"{self.name}({args_str})"

@dataclass
class PredicateFormula:
    """è°“è¯é€»è¾‘å…¬å¼"""
    operator: Optional[Union[LogicalOperator, Quantifier]]
    operands: List[Union[Predicate, 'PredicateFormula', str]]
    is_atomic: bool = False
    
    def __str__(self) -> str:
        if self.is_atomic:
            return str(self.operands[0])
        
        if self.operator in [Quantifier.FORALL, Quantifier.EXISTS]:
            variable = self.operands[0]
            formula = self.operands[1]
            return f"{self.operator.value}{variable}({formula})"
        
        if self.operator == LogicalOperator.NOT:
            return f"Â¬({self.operands[0]})"
        elif self.operator == LogicalOperator.AND:
            return f"({' âˆ§ '.join(str(op) for op in self.operands)})"
        elif self.operator == LogicalOperator.OR:
            return f"({' âˆ¨ '.join(str(op) for op in self.operands)})"
        elif self.operator == LogicalOperator.IMPLIES:
            return f"({self.operands[0]} â†’ {self.operands[1]})"
        elif self.operator == LogicalOperator.EQUIVALENT:
            return f"({self.operands[0]} â†” {self.operands[1]})"
        
        return str(self.operands)

class PredicateLogic:
    """è°“è¯é€»è¾‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.predicates: Dict[str, int] = {}  # è°“è¯å -> å‚æ•°æ•°é‡
        self.constants: Set[str] = set()
        self.functions: Dict[str, int] = {}  # å‡½æ•°å -> å‚æ•°æ•°é‡
    
    def add_predicate(self, name: str, arity: int) -> None:
        """æ·»åŠ è°“è¯"""
        self.predicates[name] = arity
    
    def add_constant(self, name: str) -> None:
        """æ·»åŠ å¸¸é‡"""
        self.constants.add(name)
    
    def add_function(self, name: str, arity: int) -> None:
        """æ·»åŠ å‡½æ•°"""
        self.functions[name] = arity
    
    def create_predicate(self, name: str, arguments: List[str]) -> Predicate:
        """åˆ›å»ºè°“è¯"""
        if name not in self.predicates:
            raise ValueError(f"è°“è¯ {name} æœªå®šä¹‰")
        
        if len(arguments) != self.predicates[name]:
            raise ValueError(f"è°“è¯ {name} éœ€è¦ {self.predicates[name]} ä¸ªå‚æ•°")
        
        terms = [Term(arg, arg not in self.constants) for arg in arguments]
        return Predicate(name, terms)
    
    def create_atomic(self, predicate: Predicate) -> PredicateFormula:
        """åˆ›å»ºåŸå­å…¬å¼"""
        return PredicateFormula(None, [predicate], is_atomic=True)
    
    def create_not(self, formula: PredicateFormula) -> PredicateFormula:
        """åˆ›å»ºå¦å®š"""
        return PredicateFormula(LogicalOperator.NOT, [formula])
    
    def create_and(self, formulas: List[PredicateFormula]) -> PredicateFormula:
        """åˆ›å»ºåˆå–"""
        return PredicateFormula(LogicalOperator.AND, formulas)
    
    def create_or(self, formulas: List[PredicateFormula]) -> PredicateFormula:
        """åˆ›å»ºæå–"""
        return PredicateFormula(LogicalOperator.OR, formulas)
    
    def create_implies(self, antecedent: PredicateFormula, 
                      consequent: PredicateFormula) -> PredicateFormula:
        """åˆ›å»ºè•´å«"""
        return PredicateFormula(LogicalOperator.IMPLIES, [antecedent, consequent])
    
    def create_forall(self, variable: str, formula: PredicateFormula) -> PredicateFormula:
        """åˆ›å»ºå…¨ç§°é‡è¯"""
        return PredicateFormula(Quantifier.FORALL, [variable, formula])
    
    def create_exists(self, variable: str, formula: PredicateFormula) -> PredicateFormula:
        """åˆ›å»ºå­˜åœ¨é‡è¯"""
        return PredicateFormula(Quantifier.EXISTS, [variable, formula])
    
    def evaluate(self, formula: PredicateFormula, 
                interpretation: Dict[str, Callable]) -> bool:
        """è¯„ä¼°å…¬å¼åœ¨ç»™å®šè§£é‡Šä¸‹çš„çœŸå€¼"""
        if formula.is_atomic:
            predicate = formula.operands[0]
            return self._evaluate_predicate(predicate, interpretation)
        
        if formula.operator == Quantifier.FORALL:
            variable = formula.operands[0]
            subformula = formula.operands[1]
            return self._evaluate_forall(variable, subformula, interpretation)
        
        elif formula.operator == Quantifier.EXISTS:
            variable = formula.operands[0]
            subformula = formula.operands[1]
            return self._evaluate_exists(variable, subformula, interpretation)
        
        elif formula.operator == LogicalOperator.NOT:
            return not self.evaluate(formula.operands[0], interpretation)
        
        elif formula.operator == LogicalOperator.AND:
            return all(self.evaluate(op, interpretation) for op in formula.operands)
        
        elif formula.operator == LogicalOperator.OR:
            return any(self.evaluate(op, interpretation) for op in formula.operands)
        
        elif formula.operator == LogicalOperator.IMPLIES:
            antecedent = self.evaluate(formula.operands[0], interpretation)
            consequent = self.evaluate(formula.operands[1], interpretation)
            return not antecedent or consequent
        
        elif formula.operator == LogicalOperator.EQUIVALENT:
            left = self.evaluate(formula.operands[0], interpretation)
            right = self.evaluate(formula.operands[1], interpretation)
            return left == right
        
        return False
    
    def _evaluate_predicate(self, predicate: Predicate, 
                          interpretation: Dict[str, Callable]) -> bool:
        """è¯„ä¼°è°“è¯"""
        predicate_func = interpretation.get(predicate.name)
        if predicate_func is None:
            return False
        
        # è¯„ä¼°å‚æ•°
        args = []
        for term in predicate.arguments:
            if term.is_variable:
                # å˜é‡éœ€è¦ä»ç¯å¢ƒä¸­è·å–å€¼
                value = interpretation.get(term.name)
                if value is None:
                    return False
                args.append(value)
            else:
                # å¸¸é‡ç›´æ¥ä½¿ç”¨
                args.append(term.name)
        
        return predicate_func(*args)
    
    def _evaluate_forall(self, variable: str, formula: PredicateFormula, 
                        interpretation: Dict[str, Callable]) -> bool:
        """è¯„ä¼°å…¨ç§°é‡è¯"""
        # è·å–è®ºåŸŸ
        domain = interpretation.get('domain', [])
        
        for value in domain:
            new_interpretation = interpretation.copy()
            new_interpretation[variable] = value
            
            if not self.evaluate(formula, new_interpretation):
                return False
        
        return True
    
    def _evaluate_exists(self, variable: str, formula: PredicateFormula, 
                        interpretation: Dict[str, Callable]) -> bool:
        """è¯„ä¼°å­˜åœ¨é‡è¯"""
        # è·å–è®ºåŸŸ
        domain = interpretation.get('domain', [])
        
        for value in domain:
            new_interpretation = interpretation.copy()
            new_interpretation[variable] = value
            
            if self.evaluate(formula, new_interpretation):
                return True
        
        return False

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_predicate_logic():
    """æ¼”ç¤ºè°“è¯é€»è¾‘"""
    print("=== è°“è¯é€»è¾‘æ¼”ç¤º ===")
    
    logic = PredicateLogic()
    
    # æ·»åŠ è°“è¯å’Œå¸¸é‡
    logic.add_predicate("Human", 1)
    logic.add_predicate("Mortal", 1)
    logic.add_constant("Socrates")
    
    # åˆ›å»ºå…¬å¼ï¼šæ‰€æœ‰äººéƒ½æ˜¯ä¼šæ­»çš„
    x = Term("x", is_variable=True)
    human_x = Predicate("Human", [x])
    mortal_x = Predicate("Mortal", [x])
    
    formula1 = logic.create_atomic(human_x)
    formula2 = logic.create_atomic(mortal_x)
    implication = logic.create_implies(formula1, formula2)
    forall_formula = logic.create_forall("x", implication)
    
    print(f"å…¬å¼: {forall_formula}")
    
    # åˆ›å»ºè§£é‡Š
    def human(value):
        return value in ["Socrates", "Plato", "Aristotle"]
    
    def mortal(value):
        return True  # æ‰€æœ‰äººéƒ½ä¼šæ­»
    
    interpretation = {
        'domain': ["Socrates", "Plato", "Aristotle", "Zeus"],
        'Human': human,
        'Mortal': mortal
    }
    
    # è¯„ä¼°å…¬å¼
    result = logic.evaluate(forall_formula, interpretation)
    print(f"å…¬å¼åœ¨ç»™å®šè§£é‡Šä¸‹çš„çœŸå€¼: {result}")
```

### 3. æ¨¡æ€é€»è¾‘ (Modal Logic)

**æ¦‚å¿µå®šä¹‰**: æ¨¡æ€é€»è¾‘æ˜¯ç ”ç©¶å¿…ç„¶æ€§å’Œå¯èƒ½æ€§æ¦‚å¿µçš„é€»è¾‘ç³»ç»Ÿï¼Œåœ¨äººå·¥æ™ºèƒ½å’Œè½¯ä»¶éªŒè¯ä¸­æœ‰é‡è¦åº”ç”¨ã€‚

**æ•°å­¦å½¢å¼**:
æ¨¡æ€é€»è¾‘çš„è¯­æ³•ï¼š

$$F ::= p | \neg F | F \land G | F \lor G | F \rightarrow G | \Box F | \Diamond F$$

å…¶ä¸­ $\Box$ è¡¨ç¤ºå¿…ç„¶ï¼Œ$\Diamond$ è¡¨ç¤ºå¯èƒ½ã€‚

**Pythonå®ç°**:

```python
from typing import Dict, List, Set, Tuple, Optional
from dataclasses import dataclass
from enum import Enum

class ModalOperator(Enum):
    """æ¨¡æ€è¿ç®—ç¬¦"""
    NECESSARY = "â–¡"  # å¿…ç„¶
    POSSIBLE = "â—‡"   # å¯èƒ½

@dataclass
class World:
    """å¯èƒ½ä¸–ç•Œ"""
    name: str
    propositions: Dict[str, bool]
    
    def __str__(self) -> str:
        return f"World({self.name})"

@dataclass
class KripkeModel:
    """å…‹é‡Œæ™®å…‹æ¨¡å‹"""
    worlds: List[World]
    accessibility: Dict[str, Set[str]]  # ä¸–ç•Œå -> å¯è¾¾ä¸–ç•Œé›†åˆ
    
    def add_world(self, world: World) -> None:
        """æ·»åŠ ä¸–ç•Œ"""
        self.worlds.append(world)
        if world.name not in self.accessibility:
            self.accessibility[world.name] = set()
    
    def add_accessibility(self, from_world: str, to_world: str) -> None:
        """æ·»åŠ å¯è¾¾å…³ç³»"""
        if from_world not in self.accessibility:
            self.accessibility[from_world] = set()
        self.accessibility[from_world].add(to_world)
    
    def get_accessible_worlds(self, world_name: str) -> Set[str]:
        """è·å–å¯è¾¾ä¸–ç•Œ"""
        return self.accessibility.get(world_name, set())

@dataclass
class ModalFormula:
    """æ¨¡æ€é€»è¾‘å…¬å¼"""
    operator: Optional[Union[LogicalOperator, ModalOperator]]
    operands: List[Union[str, 'ModalFormula']]
    is_atomic: bool = False
    
    def __str__(self) -> str:
        if self.is_atomic:
            return self.operands[0]
        
        if self.operator == ModalOperator.NECESSARY:
            return f"â–¡({self.operands[0]})"
        elif self.operator == ModalOperator.POSSIBLE:
            return f"â—‡({self.operands[0]})"
        elif self.operator == LogicalOperator.NOT:
            return f"Â¬({self.operands[0]})"
        elif self.operator == LogicalOperator.AND:
            return f"({' âˆ§ '.join(str(op) for op in self.operands)})"
        elif self.operator == LogicalOperator.OR:
            return f"({' âˆ¨ '.join(str(op) for op in self.operands)})"
        elif self.operator == LogicalOperator.IMPLIES:
            return f"({self.operands[0]} â†’ {self.operands[1]})"
        elif self.operator == LogicalOperator.EQUIVALENT:
            return f"({self.operands[0]} â†” {self.operands[1]})"
        
        return str(self.operands)

class ModalLogic:
    """æ¨¡æ€é€»è¾‘ç³»ç»Ÿ"""
    
    def __init__(self):
        self.model: Optional[KripkeModel] = None
    
    def set_model(self, model: KripkeModel) -> None:
        """è®¾ç½®æ¨¡å‹"""
        self.model = model
    
    def create_atomic(self, proposition: str) -> ModalFormula:
        """åˆ›å»ºåŸå­å…¬å¼"""
        return ModalFormula(None, [proposition], is_atomic=True)
    
    def create_not(self, formula: ModalFormula) -> ModalFormula:
        """åˆ›å»ºå¦å®š"""
        return ModalFormula(LogicalOperator.NOT, [formula])
    
    def create_and(self, formulas: List[ModalFormula]) -> ModalFormula:
        """åˆ›å»ºåˆå–"""
        return ModalFormula(LogicalOperator.AND, formulas)
    
    def create_or(self, formulas: List[ModalFormula]) -> ModalFormula:
        """åˆ›å»ºæå–"""
        return ModalFormula(LogicalOperator.OR, formulas)
    
    def create_implies(self, antecedent: ModalFormula, 
                      consequent: ModalFormula) -> ModalFormula:
        """åˆ›å»ºè•´å«"""
        return ModalFormula(LogicalOperator.IMPLIES, [antecedent, consequent])
    
    def create_necessary(self, formula: ModalFormula) -> ModalFormula:
        """åˆ›å»ºå¿…ç„¶"""
        return ModalFormula(ModalOperator.NECESSARY, [formula])
    
    def create_possible(self, formula: ModalFormula) -> ModalFormula:
        """åˆ›å»ºå¯èƒ½"""
        return ModalFormula(ModalOperator.POSSIBLE, [formula])
    
    def evaluate(self, formula: ModalFormula, world_name: str) -> bool:
        """åœ¨æŒ‡å®šä¸–ç•Œä¸­è¯„ä¼°å…¬å¼"""
        if self.model is None:
            raise ValueError("æ¨¡å‹æœªè®¾ç½®")
        
        world = self._get_world(world_name)
        if world is None:
            raise ValueError(f"ä¸–ç•Œ {world_name} ä¸å­˜åœ¨")
        
        return self._evaluate_in_world(formula, world)
    
    def _get_world(self, world_name: str) -> Optional[World]:
        """è·å–ä¸–ç•Œ"""
        for world in self.model.worlds:
            if world.name == world_name:
                return world
        return None
    
    def _evaluate_in_world(self, formula: ModalFormula, world: World) -> bool:
        """åœ¨ä¸–ç•Œä¸­è¯„ä¼°å…¬å¼"""
        if formula.is_atomic:
            proposition = formula.operands[0]
            return world.propositions.get(proposition, False)
        
        if formula.operator == ModalOperator.NECESSARY:
            subformula = formula.operands[0]
            accessible_worlds = self.model.get_accessible_worlds(world.name)
            
            for accessible_world_name in accessible_worlds:
                accessible_world = self._get_world(accessible_world_name)
                if accessible_world and not self._evaluate_in_world(subformula, accessible_world):
                    return False
            return True
        
        elif formula.operator == ModalOperator.POSSIBLE:
            subformula = formula.operands[0]
            accessible_worlds = self.model.get_accessible_worlds(world.name)
            
            for accessible_world_name in accessible_worlds:
                accessible_world = self._get_world(accessible_world_name)
                if accessible_world and self._evaluate_in_world(subformula, accessible_world):
                    return True
            return False
        
        elif formula.operator == LogicalOperator.NOT:
            return not self._evaluate_in_world(formula.operands[0], world)
        
        elif formula.operator == LogicalOperator.AND:
            return all(self._evaluate_in_world(op, world) for op in formula.operands)
        
        elif formula.operator == LogicalOperator.OR:
            return any(self._evaluate_in_world(op, world) for op in formula.operands)
        
        elif formula.operator == LogicalOperator.IMPLIES:
            antecedent = self._evaluate_in_world(formula.operands[0], world)
            consequent = self._evaluate_in_world(formula.operands[1], world)
            return not antecedent or consequent
        
        elif formula.operator == LogicalOperator.EQUIVALENT:
            left = self._evaluate_in_world(formula.operands[0], world)
            right = self._evaluate_in_world(formula.operands[1], world)
            return left == right
        
        return False
    
    def is_valid(self, formula: ModalFormula) -> bool:
        """åˆ¤æ–­å…¬å¼æ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸­éƒ½æœ‰æ•ˆ"""
        if self.model is None:
            return False
        
        for world in self.model.worlds:
            if not self._evaluate_in_world(formula, world):
                return False
        return True
    
    def is_satisfiable(self, formula: ModalFormula) -> bool:
        """åˆ¤æ–­å…¬å¼æ˜¯å¦å¯æ»¡è¶³"""
        if self.model is None:
            return False
        
        for world in self.model.worlds:
            if self._evaluate_in_world(formula, world):
                return True
        return False

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_modal_logic():
    """æ¼”ç¤ºæ¨¡æ€é€»è¾‘"""
    print("=== æ¨¡æ€é€»è¾‘æ¼”ç¤º ===")
    
    logic = ModalLogic()
    
    # åˆ›å»ºå…‹é‡Œæ™®å…‹æ¨¡å‹
    model = KripkeModel([], {})
    
    # åˆ›å»ºä¸–ç•Œ
    world1 = World("w1", {"p": True, "q": False})
    world2 = World("w2", {"p": False, "q": True})
    world3 = World("w3", {"p": True, "q": True})
    
    model.add_world(world1)
    model.add_world(world2)
    model.add_world(world3)
    
    # è®¾ç½®å¯è¾¾å…³ç³»
    model.add_accessibility("w1", "w2")
    model.add_accessibility("w1", "w3")
    model.add_accessibility("w2", "w3")
    model.add_accessibility("w3", "w3")  # è‡ªå
    
    logic.set_model(model)
    
    # åˆ›å»ºå…¬å¼
    p = logic.create_atomic("p")
    q = logic.create_atomic("q")
    
    necessary_p = logic.create_necessary(p)  # â–¡p
    possible_q = logic.create_possible(q)    # â—‡q
    necessary_possible_p = logic.create_necessary(logic.create_possible(p))  # â–¡â—‡p
    
    print(f"å…¬å¼1: {necessary_p}")
    print(f"å…¬å¼2: {possible_q}")
    print(f"å…¬å¼3: {necessary_possible_p}")
    
    # åœ¨ä¸åŒä¸–ç•Œä¸­è¯„ä¼°
    print(f"\nåœ¨ä¸–ç•Œw1ä¸­:")
    print(f"â–¡p: {logic.evaluate(necessary_p, 'w1')}")
    print(f"â—‡q: {logic.evaluate(possible_q, 'w1')}")
    print(f"â–¡â—‡p: {logic.evaluate(necessary_possible_p, 'w1')}")
    
    print(f"\nåœ¨ä¸–ç•Œw2ä¸­:")
    print(f"â–¡p: {logic.evaluate(necessary_p, 'w2')}")
    print(f"â—‡q: {logic.evaluate(possible_q, 'w2')}")
    print(f"â–¡â—‡p: {logic.evaluate(necessary_possible_p, 'w2')}")
    
    # æœ‰æ•ˆæ€§æ£€æŸ¥
    print(f"\nâ–¡påœ¨æ‰€æœ‰ä¸–ç•Œä¸­æœ‰æ•ˆ: {logic.is_valid(necessary_p)}")
    print(f"â—‡qå¯æ»¡è¶³: {logic.is_satisfiable(possible_q)}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [01-01-æ•°å­¦åŸºç¡€](./01-01-æ•°å­¦åŸºç¡€.md)
- [01-03-é›†åˆè®ºåŸºç¡€](./01-03-é›†åˆè®ºåŸºç¡€.md)
- [02-01-ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Enderton, H. B. (2001). A mathematical introduction to logic.
2. Mendelson, E. (2015). Introduction to mathematical logic.
3. Blackburn, P., de Rijke, M., & Venema, Y. (2001). Modal logic.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
