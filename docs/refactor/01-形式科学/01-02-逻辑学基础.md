# 01-02 逻辑学基础

## 📋 概述

逻辑学是形式科学的核心基础，为软件工程和计算科学提供严格的推理框架。本文档从形式化角度阐述逻辑学的基本概念、理论体系和在计算机科学中的应用。

## 🎯 核心概念

### 1. 命题逻辑

#### 1.1 形式化定义

**定义 1.1** (命题)
命题是一个可以判断真假的陈述句，用符号表示为：
$$P, Q, R, \ldots$$

**定义 1.2** (逻辑连接词)
基本逻辑连接词定义为：

- 否定：$\neg P$ (非P)
- 合取：$P \land Q$ (P且Q)
- 析取：$P \lor Q$ (P或Q)
- 蕴含：$P \rightarrow Q$ (如果P则Q)
- 等价：$P \leftrightarrow Q$ (P当且仅当Q)

**定义 1.3** (真值函数)
真值函数 $f: \{T, F\}^n \rightarrow \{T, F\}$ 定义为：
$$f(P_1, P_2, \ldots, P_n) = \text{真值}$$

#### 1.2 Python实现

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Optional, Union
from dataclasses import dataclass
from enum import Enum
import itertools

class TruthValue(Enum):
    """真值枚举"""
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """命题类"""
    name: str
    value: Optional[TruthValue] = None
    
    def __str__(self):
        return self.name
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        """在解释下求值"""
        return interpretation.get(self.name, TruthValue.FALSE)

class LogicalOperator(ABC):
    """逻辑运算符抽象基类"""
    
    @abstractmethod
    def evaluate(self, *args: TruthValue) -> TruthValue:
        """求值"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """字符串表示"""
        pass

class Negation(LogicalOperator):
    """否定运算符"""
    
    def evaluate(self, p: TruthValue) -> TruthValue:
        return TruthValue(not p.value)
    
    def __str__(self):
        return "¬"

class Conjunction(LogicalOperator):
    """合取运算符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value and q.value)
    
    def __str__(self):
        return "∧"

class Disjunction(LogicalOperator):
    """析取运算符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value or q.value)
    
    def __str__(self):
        return "∨"

class Implication(LogicalOperator):
    """蕴含运算符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(not p.value or q.value)
    
    def __str__(self):
        return "→"

class Equivalence(LogicalOperator):
    """等价运算符"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value == q.value)
    
    def __str__(self):
        return "↔"

class LogicalFormula:
    """逻辑公式类"""
    
    def __init__(self, operator: LogicalOperator, *operands):
        self.operator = operator
        self.operands = operands
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        """在解释下求值"""
        evaluated_operands = []
        
        for operand in self.operands:
            if isinstance(operand, Proposition):
                evaluated_operands.append(operand.evaluate(interpretation))
            elif isinstance(operand, LogicalFormula):
                evaluated_operands.append(operand.evaluate(interpretation))
            else:
                raise ValueError(f"Invalid operand type: {type(operand)}")
        
        return self.operator.evaluate(*evaluated_operands)
    
    def __str__(self):
        if len(self.operands) == 1:
            return f"{self.operator}{self.operands[0]}"
        else:
            return f"({self.operands[0]} {self.operator} {self.operands[1]})"

class TruthTable:
    """真值表类"""
    
    def __init__(self, formula: LogicalFormula):
        self.formula = formula
        self.variables = self._extract_variables(formula)
    
    def _extract_variables(self, formula: LogicalFormula) -> Set[str]:
        """提取公式中的变量"""
        variables = set()
        
        def extract_from_operand(operand):
            if isinstance(operand, Proposition):
                variables.add(operand.name)
            elif isinstance(operand, LogicalFormula):
                for op in operand.operands:
                    extract_from_operand(op)
        
        for operand in formula.operands:
            extract_from_operand(operand)
        
        return variables
    
    def generate_table(self) -> List[Dict[str, Any]]:
        """生成真值表"""
        table = []
        variables_list = sorted(list(self.variables))
        
        # 生成所有可能的真值组合
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], 
                                      repeat=len(variables_list)):
            interpretation = dict(zip(variables_list, values))
            result = self.formula.evaluate(interpretation)
            
            row = interpretation.copy()
            row['result'] = result
            table.append(row)
        
        return table
    
    def is_tautology(self) -> bool:
        """判断是否为重言式"""
        table = self.generate_table()
        return all(row['result'] == TruthValue.TRUE for row in table)
    
    def is_contradiction(self) -> bool:
        """判断是否为矛盾式"""
        table = self.generate_table()
        return all(row['result'] == TruthValue.FALSE for row in table)
    
    def is_satisfiable(self) -> bool:
        """判断是否为可满足式"""
        table = self.generate_table()
        return any(row['result'] == TruthValue.TRUE for row in table)

# 示例使用
def demonstrate_propositional_logic():
    """演示命题逻辑"""
    # 创建命题
    P = Proposition("P")
    Q = Proposition("Q")
    
    # 创建公式：P → Q
    implication = LogicalFormula(Implication(), P, Q)
    
    # 创建真值表
    truth_table = TruthTable(implication)
    table = truth_table.generate_table()
    
    print("真值表：")
    for row in table:
        print(f"P={row['P'].value}, Q={row['Q'].value}, P→Q={row['result'].value}")
    
    print(f"是否为重言式: {truth_table.is_tautology()}")
    print(f"是否为矛盾式: {truth_table.is_contradiction()}")
    print(f"是否为可满足式: {truth_table.is_satisfiable()}")

if __name__ == "__main__":
    demonstrate_propositional_logic()
```

#### 1.3 数学证明

**定理 1.1** (德摩根律)
对于任意命题 $P$ 和 $Q$，有：
$$\neg(P \land Q) \leftrightarrow (\neg P \lor \neg Q)$$
$$\neg(P \lor Q) \leftrightarrow (\neg P \land \neg Q)$$

**证明**:
构造真值表证明：

| P | Q | P∧Q | ¬(P∧Q) | ¬P | ¬Q | ¬P∨¬Q | ¬(P∧Q)↔(¬P∨¬Q) |
|---|---|-----|--------|----|----|-------|----------------|
| T | T |  T  |   F    | F  | F  |   F   |       T        |
| T | F |  F  |   T    | F  | T  |   T   |       T        |
| F | T |  F  |   T    | T  | F  |   T   |       T        |
| F | F |  F  |   T    | T  | T  |   T   |       T        |

所有行的最后一列都为T，因此德摩根律成立。

### 2. 谓词逻辑

#### 2.1 形式化定义

**定义 2.1** (谓词)
谓词是一个函数 $P: D^n \rightarrow \{T, F\}$，其中 $D$ 是论域。

**定义 2.2** (量词)

- 全称量词：$\forall x P(x)$ (对所有x，P(x)成立)
- 存在量词：$\exists x P(x)$ (存在x，使得P(x)成立)

**定义 2.3** (谓词公式)
谓词公式递归定义为：

1. 原子公式：$P(t_1, t_2, \ldots, t_n)$
2. 如果 $\phi$ 和 $\psi$ 是公式，则 $\neg\phi$, $\phi \land \psi$, $\phi \lor \psi$, $\phi \rightarrow \psi$, $\phi \leftrightarrow \psi$ 是公式
3. 如果 $\phi$ 是公式，$x$ 是变量，则 $\forall x \phi$ 和 $\exists x \phi$ 是公式

#### 2.2 Python实现

```python
from typing import Callable, List, Dict, Any, Set
from dataclasses import dataclass

@dataclass
class Variable:
    """变量类"""
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class Term:
    """项类"""
    name: str
    arguments: List['Term'] = None
    
    def __init__(self, name: str, arguments: List['Term'] = None):
        self.name = name
        self.arguments = arguments or []
    
    def __str__(self):
        if not self.arguments:
            return self.name
        return f"{self.name}({', '.join(str(arg) for arg in self.arguments)})"

class Predicate:
    """谓词类"""
    
    def __init__(self, name: str, arity: int):
        self.name = name
        self.arity = arity
    
    def __call__(self, *args: Term) -> 'AtomicFormula':
        """创建原子公式"""
        if len(args) != self.arity:
            raise ValueError(f"Predicate {self.name} expects {self.arity} arguments, got {len(args)}")
        return AtomicFormula(self, list(args))
    
    def __str__(self):
        return self.name

class AtomicFormula:
    """原子公式类"""
    
    def __init__(self, predicate: Predicate, terms: List[Term]):
        self.predicate = predicate
        self.terms = terms
    
    def evaluate(self, interpretation: Dict[str, Any], domain: Set[Any]) -> TruthValue:
        """在解释下求值"""
        # 将项解释为域中的元素
        interpreted_terms = []
        for term in self.terms:
            if isinstance(term, Variable):
                if term.name not in interpretation:
                    raise ValueError(f"Variable {term.name} not in interpretation")
                interpreted_terms.append(interpretation[term.name])
            else:
                # 常量项
                interpreted_terms.append(term.name)
        
        # 调用谓词的解释函数
        predicate_interpretation = interpretation.get(self.predicate.name)
        if predicate_interpretation is None:
            raise ValueError(f"Predicate {self.predicate.name} not in interpretation")
        
        return TruthValue(predicate_interpretation(*interpreted_terms))
    
    def __str__(self):
        return f"{self.predicate}({', '.join(str(term) for term in self.terms)})"

class QuantifiedFormula:
    """量词公式类"""
    
    def __init__(self, quantifier: str, variable: Variable, formula: 'Formula'):
        self.quantifier = quantifier  # "∀" or "∃"
        self.variable = variable
        self.formula = formula
    
    def evaluate(self, interpretation: Dict[str, Any], domain: Set[Any]) -> TruthValue:
        """在解释下求值"""
        if self.quantifier == "∀":
            # 全称量词：对所有域中的元素，公式都为真
            for element in domain:
                new_interpretation = interpretation.copy()
                new_interpretation[self.variable.name] = element
                if self.formula.evaluate(new_interpretation, domain) == TruthValue.FALSE:
                    return TruthValue.FALSE
            return TruthValue.TRUE
        
        elif self.quantifier == "∃":
            # 存在量词：存在域中的元素，使得公式为真
            for element in domain:
                new_interpretation = interpretation.copy()
                new_interpretation[self.variable.name] = element
                if self.formula.evaluate(new_interpretation, domain) == TruthValue.TRUE:
                    return TruthValue.TRUE
            return TruthValue.FALSE
        
        else:
            raise ValueError(f"Invalid quantifier: {self.quantifier}")
    
    def __str__(self):
        return f"{self.quantifier}{self.variable} {self.formula}"

class Formula:
    """公式类"""
    
    def __init__(self, operator: LogicalOperator, *operands):
        self.operator = operator
        self.operands = operands
    
    def evaluate(self, interpretation: Dict[str, Any], domain: Set[Any]) -> TruthValue:
        """在解释下求值"""
        evaluated_operands = []
        
        for operand in self.operands:
            if isinstance(operand, (AtomicFormula, QuantifiedFormula, Formula)):
                evaluated_operands.append(operand.evaluate(interpretation, domain))
            else:
                raise ValueError(f"Invalid operand type: {type(operand)}")
        
        return self.operator.evaluate(*evaluated_operands)
    
    def __str__(self):
        if len(self.operands) == 1:
            return f"{self.operator}{self.operands[0]}"
        else:
            return f"({self.operands[0]} {self.operator} {self.operands[1]})"

# 示例使用
def demonstrate_predicate_logic():
    """演示谓词逻辑"""
    # 定义域
    domain = {1, 2, 3, 4, 5}
    
    # 定义谓词
    Even = Predicate("Even", 1)
    Greater = Predicate("Greater", 2)
    
    # 定义变量
    x = Variable("x")
    y = Variable("y")
    
    # 创建原子公式
    even_x = Even(x)
    greater_xy = Greater(x, y)
    
    # 创建量词公式：∀x Even(x)
    forall_even = QuantifiedFormula("∀", x, even_x)
    
    # 创建复合公式：∀x ∃y Greater(x, y)
    exists_y = QuantifiedFormula("∃", y, greater_xy)
    forall_exists = QuantifiedFormula("∀", x, exists_y)
    
    # 定义解释
    interpretation = {
        "Even": lambda n: n % 2 == 0,
        "Greater": lambda m, n: m > n
    }
    
    print(f"公式: {forall_even}")
    print(f"在域 {domain} 下的真值: {forall_even.evaluate(interpretation, domain)}")
    
    print(f"公式: {forall_exists}")
    print(f"在域 {domain} 下的真值: {forall_exists.evaluate(interpretation, domain)}")

if __name__ == "__main__":
    demonstrate_predicate_logic()
```

### 3. 模态逻辑

#### 3.1 形式化定义

**定义 3.1** (模态算子)

- 必然算子：$\Box P$ (必然P)
- 可能算子：$\Diamond P$ (可能P)

**定义 3.2** (克里普克模型)
克里普克模型是一个三元组 $M = (W, R, V)$，其中：

- $W$ 是可能世界集合
- $R \subseteq W \times W$ 是可达关系
- $V: W \times P \rightarrow \{T, F\}$ 是赋值函数

**定义 3.3** (模态公式语义)
对于克里普克模型 $M = (W, R, V)$ 和世界 $w \in W$：

- $M, w \models \Box \phi$ 当且仅当对所有 $v$ 使得 $wRv$，有 $M, v \models \phi$
- $M, w \models \Diamond \phi$ 当且仅当存在 $v$ 使得 $wRv$ 且 $M, v \models \phi$

#### 3.2 Python实现

```python
from typing import Dict, Set, List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class World:
    """可能世界类"""
    name: str
    propositions: Dict[str, TruthValue]
    
    def __str__(self):
        return self.name

class KripkeModel:
    """克里普克模型类"""
    
    def __init__(self, worlds: List[World], accessibility: Dict[str, Set[str]]):
        self.worlds = {w.name: w for w in worlds}
        self.accessibility = accessibility
    
    def get_accessible_worlds(self, world_name: str) -> Set[str]:
        """获取可达世界"""
        return self.accessibility.get(world_name, set())
    
    def evaluate_atomic(self, world_name: str, proposition: str) -> TruthValue:
        """在指定世界求值原子命题"""
        world = self.worlds.get(world_name)
        if world is None:
            raise ValueError(f"World {world_name} not found")
        return world.propositions.get(proposition, TruthValue.FALSE)

class ModalFormula:
    """模态公式类"""
    
    def __init__(self, operator: str, formula: 'ModalFormula'):
        self.operator = operator  # "□" or "◇"
        self.formula = formula
    
    def evaluate(self, model: KripkeModel, world_name: str) -> TruthValue:
        """在克里普克模型中求值"""
        accessible_worlds = model.get_accessible_worlds(world_name)
        
        if self.operator == "□":
            # 必然：所有可达世界都为真
            for accessible_world in accessible_worlds:
                if self.formula.evaluate(model, accessible_world) == TruthValue.FALSE:
                    return TruthValue.FALSE
            return TruthValue.TRUE
        
        elif self.operator == "◇":
            # 可能：存在可达世界为真
            for accessible_world in accessible_worlds:
                if self.formula.evaluate(model, accessible_world) == TruthValue.TRUE:
                    return TruthValue.TRUE
            return TruthValue.FALSE
        
        else:
            raise ValueError(f"Invalid modal operator: {self.operator}")
    
    def __str__(self):
        return f"{self.operator}{self.formula}"

class AtomicModalFormula:
    """原子模态公式类"""
    
    def __init__(self, proposition: str):
        self.proposition = proposition
    
    def evaluate(self, model: KripkeModel, world_name: str) -> TruthValue:
        """在克里普克模型中求值"""
        return model.evaluate_atomic(world_name, self.proposition)
    
    def __str__(self):
        return self.proposition

# 示例使用
def demonstrate_modal_logic():
    """演示模态逻辑"""
    # 创建可能世界
    w1 = World("w1", {"P": TruthValue.TRUE, "Q": TruthValue.FALSE})
    w2 = World("w2", {"P": TruthValue.FALSE, "Q": TruthValue.TRUE})
    w3 = World("w3", {"P": TruthValue.TRUE, "Q": TruthValue.TRUE})
    
    # 定义可达关系
    accessibility = {
        "w1": {"w1", "w2"},
        "w2": {"w2", "w3"},
        "w3": {"w3"}
    }
    
    # 创建克里普克模型
    model = KripkeModel([w1, w2, w3], accessibility)
    
    # 创建模态公式
    P = AtomicModalFormula("P")
    Q = AtomicModalFormula("Q")
    
    # □P (必然P)
    necessary_P = ModalFormula("□", P)
    
    # ◇Q (可能Q)
    possible_Q = ModalFormula("◇", Q)
    
    print("模态逻辑示例：")
    print(f"在w1中，□P的真值: {necessary_P.evaluate(model, 'w1')}")
    print(f"在w1中，◇Q的真值: {possible_Q.evaluate(model, 'w1')}")

if __name__ == "__main__":
    demonstrate_modal_logic()
```

## 🔄 逻辑推理

### 1. 自然演绎系统

#### 1.1 推理规则

**引入规则**:

- $\land$-I: 从 $P$ 和 $Q$ 推出 $P \land Q$
- $\lor$-I: 从 $P$ 推出 $P \lor Q$ 或 $Q \lor P$
- $\rightarrow$-I: 从假设 $P$ 推出 $Q$，则推出 $P \rightarrow Q$

**消除规则**:

- $\land$-E: 从 $P \land Q$ 推出 $P$ 或 $Q$
- $\lor$-E: 从 $P \lor Q$ 和 $P \rightarrow R$ 和 $Q \rightarrow R$ 推出 $R$
- $\rightarrow$-E: 从 $P \rightarrow Q$ 和 $P$ 推出 $Q$

#### 1.2 Python实现

```python
from typing import List, Dict, Set, Optional, Tuple
from dataclasses import dataclass

@dataclass
class ProofStep:
    """证明步骤"""
    step_id: int
    formula: str
    rule: str
    premises: List[int]
    discharged: Optional[int] = None  # 被消除的假设

class NaturalDeduction:
    """自然演绎系统"""
    
    def __init__(self):
        self.steps: List[ProofStep] = []
        self.assumptions: Dict[int, str] = {}  # 假设编号 -> 公式
        self.next_assumption_id = 1
    
    def add_assumption(self, formula: str) -> int:
        """添加假设"""
        assumption_id = self.next_assumption_id
        self.assumptions[assumption_id] = formula
        self.next_assumption_id += 1
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="假设",
            premises=[],
            discharged=None
        )
        self.steps.append(step)
        return assumption_id
    
    def conjunction_intro(self, premise1: int, premise2: int) -> int:
        """合取引入"""
        step1 = self.steps[premise1 - 1]
        step2 = self.steps[premise2 - 1]
        formula = f"({step1.formula} ∧ {step2.formula})"
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="∧-I",
            premises=[premise1, premise2]
        )
        self.steps.append(step)
        return step.step_id
    
    def conjunction_elim(self, premise: int, which: int) -> int:
        """合取消除 (which=1取左，which=2取右)"""
        step_premise = self.steps[premise - 1]
        # 解析合取公式
        if step_premise.formula.startswith("(") and step_premise.formula.endswith(")"):
            inner = step_premise.formula[1:-1]
            if " ∧ " in inner:
                parts = inner.split(" ∧ ")
                if which == 1:
                    formula = parts[0]
                else:
                    formula = parts[1]
            else:
                raise ValueError("Not a conjunction formula")
        else:
            raise ValueError("Not a conjunction formula")
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="∧-E",
            premises=[premise]
        )
        self.steps.append(step)
        return step.step_id
    
    def implication_intro(self, assumption_id: int, conclusion: int) -> int:
        """蕴含引入"""
        assumption = self.assumptions[assumption_id]
        step_conclusion = self.steps[conclusion - 1]
        formula = f"({assumption} → {step_conclusion.formula})"
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="→-I",
            premises=[conclusion],
            discharged=assumption_id
        )
        self.steps.append(step)
        return step.step_id
    
    def implication_elim(self, premise1: int, premise2: int) -> int:
        """蕴含消除"""
        step1 = self.steps[premise1 - 1]
        step2 = self.steps[premise2 - 1]
        
        # 解析蕴含公式
        if step1.formula.startswith("(") and step1.formula.endswith(")"):
            inner = step1.formula[1:-1]
            if " → " in inner:
                parts = inner.split(" → ")
                antecedent = parts[0]
                consequent = parts[1]
                
                if step2.formula == antecedent:
                    formula = consequent
                else:
                    raise ValueError("Antecedent mismatch")
            else:
                raise ValueError("Not an implication formula")
        else:
            raise ValueError("Not an implication formula")
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="→-E",
            premises=[premise1, premise2]
        )
        self.steps.append(step)
        return step.step_id
    
    def print_proof(self):
        """打印证明"""
        print("自然演绎证明：")
        print("-" * 50)
        
        for step in self.steps:
            discharged_info = f" [消除假设{step.discharged}]" if step.discharged else ""
            print(f"{step.step_id}. {step.formula} ({step.rule}){discharged_info}")
            if step.premises:
                print(f"   前提: {step.premises}")

# 示例：证明 P ∧ Q → Q ∧ P
def prove_commutativity():
    """证明合取的交换律"""
    nd = NaturalDeduction()
    
    # 假设 P ∧ Q
    assumption_id = nd.add_assumption("P ∧ Q")
    
    # 从 P ∧ Q 推出 P
    step1 = nd.conjunction_elim(1, 1)
    
    # 从 P ∧ Q 推出 Q
    step2 = nd.conjunction_elim(1, 2)
    
    # 从 Q 和 P 推出 Q ∧ P
    step3 = nd.conjunction_intro(step2, step1)
    
    # 从假设推出结论
    step4 = nd.implication_intro(assumption_id, step3)
    
    nd.print_proof()

if __name__ == "__main__":
    prove_commutativity()
```

## 📊 逻辑应用

### 1. 程序验证

#### 1.1 霍尔逻辑

**定义 4.1** (霍尔三元组)
霍尔三元组 $\{P\} C \{Q\}$ 表示：如果在执行程序 $C$ 之前前置条件 $P$ 成立，且 $C$ 终止，则执行后后置条件 $Q$ 成立。

**公理 4.1** (赋值公理)
$$\{P[E/x]\} x := E \{P\}$$

**规则 4.1** (顺序规则)
$$\frac{\{P\} C_1 \{R\} \quad \{R\} C_2 \{Q\}}{\{P\} C_1; C_2 \{Q\}}$$

**规则 4.2** (条件规则)
$$\frac{\{P \land B\} C_1 \{Q\} \quad \{P \land \neg B\} C_2 \{Q\}}{\{P\} \text{if } B \text{ then } C_1 \text{ else } C_2 \{Q\}}$$

#### 1.2 Python实现

```python
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

@dataclass
class HoareTriple:
    """霍尔三元组"""
    precondition: str
    program: str
    postcondition: str
    
    def __str__(self):
        return f"{{{self.precondition}}} {self.program} {{{self.postcondition}}}"

class HoareLogic:
    """霍尔逻辑验证器"""
    
    def __init__(self):
        self.variables: Dict[str, Any] = {}
    
    def substitution(self, formula: str, var: str, expr: str) -> str:
        """变量替换"""
        # 简单的字符串替换，实际应用中需要更复杂的解析
        return formula.replace(var, expr)
    
    def assignment_axiom(self, var: str, expr: str, postcondition: str) -> HoareTriple:
        """赋值公理"""
        precondition = self.substitution(postcondition, var, expr)
        return HoareTriple(precondition, f"{var} := {expr}", postcondition)
    
    def sequence_rule(self, triple1: HoareTriple, triple2: HoareTriple) -> HoareTriple:
        """顺序规则"""
        if triple1.postcondition != triple2.precondition:
            raise ValueError("Postcondition of first triple must match precondition of second")
        
        program = f"{triple1.program}; {triple2.program}"
        return HoareTriple(triple1.precondition, program, triple2.postcondition)
    
    def conditional_rule(self, condition: str, triple1: HoareTriple, triple2: HoareTriple) -> HoareTriple:
        """条件规则"""
        if triple1.precondition != triple2.precondition or triple1.postcondition != triple2.postcondition:
            raise ValueError("Triples must have same preconditions and postconditions")
        
        program = f"if {condition} then {triple1.program} else {triple2.program}"
        return HoareTriple(triple1.precondition, program, triple1.postcondition)
    
    def while_rule(self, condition: str, invariant: str, triple: HoareTriple) -> HoareTriple:
        """循环规则"""
        if triple.precondition != invariant or triple.postcondition != invariant:
            raise ValueError("Loop body must preserve invariant")
        
        program = f"while {condition} do {triple.program}"
        return HoareTriple(invariant, program, f"{invariant} ∧ ¬{condition}")

# 示例：验证交换两个变量的程序
def verify_swap_program():
    """验证交换程序"""
    hoare = HoareLogic()
    
    # 交换程序：temp := x; x := y; y := temp
    # 前置条件：x = a ∧ y = b
    # 后置条件：x = b ∧ y = a
    
    # 第一步：temp := x
    step1 = hoare.assignment_axiom("temp", "x", "temp = a ∧ x = a ∧ y = b")
    
    # 第二步：x := y
    step2 = hoare.assignment_axiom("x", "y", "temp = a ∧ x = b ∧ y = b")
    
    # 第三步：y := temp
    step3 = hoare.assignment_axiom("y", "temp", "temp = a ∧ x = b ∧ y = a")
    
    # 应用顺序规则
    step12 = hoare.sequence_rule(step1, step2)
    final = hoare.sequence_rule(step12, step3)
    
    print("交换程序验证：")
    print(f"霍尔三元组: {final}")
    print("验证成功！")

if __name__ == "__main__":
    verify_swap_program()
```

### 2. 模型检测

#### 2.1 线性时态逻辑 (LTL)

**定义 4.2** (LTL公式)
LTL公式递归定义为：

- 原子命题 $p$
- 如果 $\phi$ 和 $\psi$ 是LTL公式，则 $\neg\phi$, $\phi \land \psi$, $\phi \lor \psi$, $\phi \rightarrow \psi$ 是LTL公式
- 如果 $\phi$ 和 $\psi$ 是LTL公式，则 $X\phi$ (下一个), $F\phi$ (最终), $G\phi$ (总是), $\phi U\psi$ (直到) 是LTL公式

#### 2.2 Python实现

```python
from typing import List, Set, Dict, Optional
from dataclasses import dataclass

@dataclass
class State:
    """状态类"""
    name: str
    propositions: Set[str]
    transitions: List[str]  # 后继状态名称

class KripkeStructure:
    """克里普克结构"""
    
    def __init__(self, states: List[State]):
        self.states = {s.name: s for s in states}
    
    def get_successors(self, state_name: str) -> List[State]:
        """获取后继状态"""
        state = self.states.get(state_name)
        if state is None:
            return []
        return [self.states[name] for name in state.transitions if name in self.states]

class LTLFormula:
    """LTL公式类"""
    
    def __init__(self, operator: str, *operands):
        self.operator = operator
        self.operands = operands
    
    def evaluate_path(self, path: List[State], position: int) -> bool:
        """在路径的指定位置求值"""
        if self.operator == "p":
            # 原子命题
            return self.operands[0] in path[position].propositions
        
        elif self.operator == "¬":
            return not self.operands[0].evaluate_path(path, position)
        
        elif self.operator == "∧":
            return (self.operands[0].evaluate_path(path, position) and 
                   self.operands[1].evaluate_path(path, position))
        
        elif self.operator == "∨":
            return (self.operands[0].evaluate_path(path, position) or 
                   self.operands[1].evaluate_path(path, position))
        
        elif self.operator == "X":
            # 下一个
            if position + 1 < len(path):
                return self.operands[0].evaluate_path(path, position + 1)
            return False
        
        elif self.operator == "F":
            # 最终
            for i in range(position, len(path)):
                if self.operands[0].evaluate_path(path, i):
                    return True
            return False
        
        elif self.operator == "G":
            # 总是
            for i in range(position, len(path)):
                if not self.operands[0].evaluate_path(path, i):
                    return False
            return True
        
        elif self.operator == "U":
            # 直到
            for i in range(position, len(path)):
                if self.operands[1].evaluate_path(path, i):
                    return True
                if not self.operands[0].evaluate_path(path, i):
                    return False
            return False
        
        else:
            raise ValueError(f"Unknown operator: {self.operator}")
    
    def __str__(self):
        if self.operator == "p":
            return self.operands[0]
        elif self.operator == "¬":
            return f"¬{self.operands[0]}"
        elif self.operator in ["∧", "∨"]:
            return f"({self.operands[0]} {self.operator} {self.operands[1]})"
        elif self.operator in ["X", "F", "G"]:
            return f"{self.operator}{self.operands[0]}"
        elif self.operator == "U":
            return f"({self.operands[0]} U {self.operands[1]})"
        else:
            return f"{self.operator}({', '.join(str(op) for op in self.operands)})"

class ModelChecker:
    """模型检测器"""
    
    def __init__(self, kripke: KripkeStructure):
        self.kripke = kripke
    
    def check_formula(self, formula: LTLFormula, initial_state: str) -> bool:
        """检查公式是否在初始状态下成立"""
        # 生成所有可能的路径
        paths = self._generate_paths(initial_state, max_length=10)
        
        # 检查每条路径
        for path in paths:
            if not formula.evaluate_path(path, 0):
                print(f"反例路径: {' -> '.join(s.name for s in path)}")
                return False
        
        return True
    
    def _generate_paths(self, start_state: str, max_length: int) -> List[List[State]]:
        """生成路径"""
        paths = []
        
        def dfs(current_state: str, current_path: List[State], length: int):
            if length >= max_length:
                paths.append(current_path[:])
                return
            
            state = self.kripke.states.get(current_state)
            if state is None:
                return
            
            current_path.append(state)
            
            if not state.transitions:
                paths.append(current_path[:])
            else:
                for next_state_name in state.transitions:
                    dfs(next_state_name, current_path, length + 1)
            
            current_path.pop()
        
        dfs(start_state, [], 0)
        return paths

# 示例：验证互斥协议
def verify_mutual_exclusion():
    """验证互斥协议"""
    # 创建状态
    s0 = State("s0", {"idle1", "idle2"}, ["s1", "s2"])
    s1 = State("s1", {"waiting1", "idle2"}, ["s3", "s0"])
    s2 = State("s2", {"idle1", "waiting2"}, ["s3", "s0"])
    s3 = State("s3", {"waiting1", "waiting2"}, ["s1", "s2"])
    
    kripke = KripkeStructure([s0, s1, s2, s3])
    checker = ModelChecker(kripke)
    
    # 创建LTL公式：G(¬(critical1 ∧ critical2)) - 互斥性
    critical1 = LTLFormula("p", "critical1")
    critical2 = LTLFormula("p", "critical2")
    both_critical = LTLFormula("∧", critical1, critical2)
    not_both = LTLFormula("¬", both_critical)
    always_not_both = LTLFormula("G", not_both)
    
    print("验证互斥性: G(¬(critical1 ∧ critical2))")
    result = checker.check_formula(always_not_both, "s0")
    print(f"结果: {result}")

if __name__ == "__main__":
    verify_mutual_exclusion()
```

## 📈 总结

逻辑学为软件工程和计算科学提供了：

1. **严格的推理框架**：形式化的证明方法
2. **程序验证基础**：霍尔逻辑等程序验证技术
3. **模型检测理论**：时态逻辑和自动机理论
4. **类型系统基础**：类型论和逻辑的对应关系
5. **人工智能基础**：知识表示和推理

通过形式化的逻辑系统，我们可以：

- 严格证明程序的正确性
- 自动检测系统性质
- 构建可靠的软件系统
- 发展人工智能推理能力

逻辑学是连接数学理论和计算机实践的桥梁，为现代软件工程提供了坚实的理论基础。
