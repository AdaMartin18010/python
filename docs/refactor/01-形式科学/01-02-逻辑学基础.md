# 01-02 é€»è¾‘å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

é€»è¾‘å­¦æ˜¯å½¢å¼ç§‘å­¦çš„æ ¸å¿ƒåŸºç¡€ï¼Œä¸ºè½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦æä¾›ä¸¥æ ¼çš„æ¨ç†æ¡†æ¶ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°é€»è¾‘å­¦çš„åŸºæœ¬æ¦‚å¿µã€ç†è®ºä½“ç³»å’Œåœ¨è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å‘½é¢˜é€»è¾‘

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (å‘½é¢˜)
å‘½é¢˜æ˜¯ä¸€ä¸ªå¯ä»¥åˆ¤æ–­çœŸå‡çš„é™ˆè¿°å¥ï¼Œç”¨ç¬¦å·è¡¨ç¤ºä¸ºï¼š
$$P, Q, R, \ldots$$

**å®šä¹‰ 1.2** (é€»è¾‘è¿æ¥è¯)
åŸºæœ¬é€»è¾‘è¿æ¥è¯å®šä¹‰ä¸ºï¼š

- å¦å®šï¼š$\neg P$ (éP)
- åˆå–ï¼š$P \land Q$ (Pä¸”Q)
- æå–ï¼š$P \lor Q$ (Pæˆ–Q)
- è•´å«ï¼š$P \rightarrow Q$ (å¦‚æœPåˆ™Q)
- ç­‰ä»·ï¼š$P \leftrightarrow Q$ (På½“ä¸”ä»…å½“Q)

**å®šä¹‰ 1.3** (çœŸå€¼å‡½æ•°)
çœŸå€¼å‡½æ•° $f: \{T, F\}^n \rightarrow \{T, F\}$ å®šä¹‰ä¸ºï¼š
$$f(P_1, P_2, \ldots, P_n) = \text{çœŸå€¼}$$

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Any, Optional, Union
from dataclasses import dataclass
from enum import Enum
import itertools

class TruthValue(Enum):
    """çœŸå€¼æšä¸¾"""
    TRUE = True
    FALSE = False

@dataclass
class Proposition:
    """å‘½é¢˜ç±»"""
    name: str
    value: Optional[TruthValue] = None
    
    def __str__(self):
        return self.name
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        """åœ¨è§£é‡Šä¸‹æ±‚å€¼"""
        return interpretation.get(self.name, TruthValue.FALSE)

class LogicalOperator(ABC):
    """é€»è¾‘è¿ç®—ç¬¦æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def evaluate(self, *args: TruthValue) -> TruthValue:
        """æ±‚å€¼"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        pass

class Negation(LogicalOperator):
    """å¦å®šè¿ç®—ç¬¦"""
    
    def evaluate(self, p: TruthValue) -> TruthValue:
        return TruthValue(not p.value)
    
    def __str__(self):
        return "Â¬"

class Conjunction(LogicalOperator):
    """åˆå–è¿ç®—ç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value and q.value)
    
    def __str__(self):
        return "âˆ§"

class Disjunction(LogicalOperator):
    """æå–è¿ç®—ç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value or q.value)
    
    def __str__(self):
        return "âˆ¨"

class Implication(LogicalOperator):
    """è•´å«è¿ç®—ç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(not p.value or q.value)
    
    def __str__(self):
        return "â†’"

class Equivalence(LogicalOperator):
    """ç­‰ä»·è¿ç®—ç¬¦"""
    
    def evaluate(self, p: TruthValue, q: TruthValue) -> TruthValue:
        return TruthValue(p.value == q.value)
    
    def __str__(self):
        return "â†”"

class LogicalFormula:
    """é€»è¾‘å…¬å¼ç±»"""
    
    def __init__(self, operator: LogicalOperator, *operands):
        self.operator = operator
        self.operands = operands
    
    def evaluate(self, interpretation: Dict[str, TruthValue]) -> TruthValue:
        """åœ¨è§£é‡Šä¸‹æ±‚å€¼"""
        evaluated_operands = []
        
        for operand in self.operands:
            if isinstance(operand, Proposition):
                evaluated_operands.append(operand.evaluate(interpretation))
            elif isinstance(operand, LogicalFormula):
                evaluated_operands.append(operand.evaluate(interpretation))
            else:
                raise ValueError(f"Invalid operand type: {type(operand)}")
        
        return self.operator.evaluate(*evaluated_operands)
    
    def __str__(self):
        if len(self.operands) == 1:
            return f"{self.operator}{self.operands[0]}"
        else:
            return f"({self.operands[0]} {self.operator} {self.operands[1]})"

class TruthTable:
    """çœŸå€¼è¡¨ç±»"""
    
    def __init__(self, formula: LogicalFormula):
        self.formula = formula
        self.variables = self._extract_variables(formula)
    
    def _extract_variables(self, formula: LogicalFormula) -> Set[str]:
        """æå–å…¬å¼ä¸­çš„å˜é‡"""
        variables = set()
        
        def extract_from_operand(operand):
            if isinstance(operand, Proposition):
                variables.add(operand.name)
            elif isinstance(operand, LogicalFormula):
                for op in operand.operands:
                    extract_from_operand(op)
        
        for operand in formula.operands:
            extract_from_operand(operand)
        
        return variables
    
    def generate_table(self) -> List[Dict[str, Any]]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        table = []
        variables_list = sorted(list(self.variables))
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„çœŸå€¼ç»„åˆ
        for values in itertools.product([TruthValue.TRUE, TruthValue.FALSE], 
                                      repeat=len(variables_list)):
            interpretation = dict(zip(variables_list, values))
            result = self.formula.evaluate(interpretation)
            
            row = interpretation.copy()
            row['result'] = result
            table.append(row)
        
        return table
    
    def is_tautology(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºé‡è¨€å¼"""
        table = self.generate_table()
        return all(row['result'] == TruthValue.TRUE for row in table)
    
    def is_contradiction(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        table = self.generate_table()
        return all(row['result'] == TruthValue.FALSE for row in table)
    
    def is_satisfiable(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼"""
        table = self.generate_table()
        return any(row['result'] == TruthValue.TRUE for row in table)

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_propositional_logic():
    """æ¼”ç¤ºå‘½é¢˜é€»è¾‘"""
    # åˆ›å»ºå‘½é¢˜
    P = Proposition("P")
    Q = Proposition("Q")
    
    # åˆ›å»ºå…¬å¼ï¼šP â†’ Q
    implication = LogicalFormula(Implication(), P, Q)
    
    # åˆ›å»ºçœŸå€¼è¡¨
    truth_table = TruthTable(implication)
    table = truth_table.generate_table()
    
    print("çœŸå€¼è¡¨ï¼š")
    for row in table:
        print(f"P={row['P'].value}, Q={row['Q'].value}, Pâ†’Q={row['result'].value}")
    
    print(f"æ˜¯å¦ä¸ºé‡è¨€å¼: {truth_table.is_tautology()}")
    print(f"æ˜¯å¦ä¸ºçŸ›ç›¾å¼: {truth_table.is_contradiction()}")
    print(f"æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼: {truth_table.is_satisfiable()}")

if __name__ == "__main__":
    demonstrate_propositional_logic()
```

#### 1.3 æ•°å­¦è¯æ˜

**å®šç† 1.1** (å¾·æ‘©æ ¹å¾‹)
å¯¹äºä»»æ„å‘½é¢˜ $P$ å’Œ $Q$ï¼Œæœ‰ï¼š
$$\neg(P \land Q) \leftrightarrow (\neg P \lor \neg Q)$$
$$\neg(P \lor Q) \leftrightarrow (\neg P \land \neg Q)$$

**è¯æ˜**:
æ„é€ çœŸå€¼è¡¨è¯æ˜ï¼š

| P | Q | Pâˆ§Q | Â¬(Pâˆ§Q) | Â¬P | Â¬Q | Â¬Pâˆ¨Â¬Q | Â¬(Pâˆ§Q)â†”(Â¬Pâˆ¨Â¬Q) |
|---|---|-----|--------|----|----|-------|----------------|
| T | T |  T  |   F    | F  | F  |   F   |       T        |
| T | F |  F  |   T    | F  | T  |   T   |       T        |
| F | T |  F  |   T    | T  | F  |   T   |       T        |
| F | F |  F  |   T    | T  | T  |   T   |       T        |

æ‰€æœ‰è¡Œçš„æœ€åä¸€åˆ—éƒ½ä¸ºTï¼Œå› æ­¤å¾·æ‘©æ ¹å¾‹æˆç«‹ã€‚

### 2. è°“è¯é€»è¾‘

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1** (è°“è¯)
è°“è¯æ˜¯ä¸€ä¸ªå‡½æ•° $P: D^n \rightarrow \{T, F\}$ï¼Œå…¶ä¸­ $D$ æ˜¯è®ºåŸŸã€‚

**å®šä¹‰ 2.2** (é‡è¯)

- å…¨ç§°é‡è¯ï¼š$\forall x P(x)$ (å¯¹æ‰€æœ‰xï¼ŒP(x)æˆç«‹)
- å­˜åœ¨é‡è¯ï¼š$\exists x P(x)$ (å­˜åœ¨xï¼Œä½¿å¾—P(x)æˆç«‹)

**å®šä¹‰ 2.3** (è°“è¯å…¬å¼)
è°“è¯å…¬å¼é€’å½’å®šä¹‰ä¸ºï¼š

1. åŸå­å…¬å¼ï¼š$P(t_1, t_2, \ldots, t_n)$
2. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\phi$, $\phi \land \psi$, $\phi \lor \psi$, $\phi \rightarrow \psi$, $\phi \leftrightarrow \psi$ æ˜¯å…¬å¼
3. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œ$x$ æ˜¯å˜é‡ï¼Œåˆ™ $\forall x \phi$ å’Œ $\exists x \phi$ æ˜¯å…¬å¼

#### 2.2 Pythonå®ç°

```python
from typing import Callable, List, Dict, Any, Set
from dataclasses import dataclass

@dataclass
class Variable:
    """å˜é‡ç±»"""
    name: str
    
    def __str__(self):
        return self.name

@dataclass
class Term:
    """é¡¹ç±»"""
    name: str
    arguments: List['Term'] = None
    
    def __init__(self, name: str, arguments: List['Term'] = None):
        self.name = name
        self.arguments = arguments or []
    
    def __str__(self):
        if not self.arguments:
            return self.name
        return f"{self.name}({', '.join(str(arg) for arg in self.arguments)})"

class Predicate:
    """è°“è¯ç±»"""
    
    def __init__(self, name: str, arity: int):
        self.name = name
        self.arity = arity
    
    def __call__(self, *args: Term) -> 'AtomicFormula':
        """åˆ›å»ºåŸå­å…¬å¼"""
        if len(args) != self.arity:
            raise ValueError(f"Predicate {self.name} expects {self.arity} arguments, got {len(args)}")
        return AtomicFormula(self, list(args))
    
    def __str__(self):
        return self.name

class AtomicFormula:
    """åŸå­å…¬å¼ç±»"""
    
    def __init__(self, predicate: Predicate, terms: List[Term]):
        self.predicate = predicate
        self.terms = terms
    
    def evaluate(self, interpretation: Dict[str, Any], domain: Set[Any]) -> TruthValue:
        """åœ¨è§£é‡Šä¸‹æ±‚å€¼"""
        # å°†é¡¹è§£é‡Šä¸ºåŸŸä¸­çš„å…ƒç´ 
        interpreted_terms = []
        for term in self.terms:
            if isinstance(term, Variable):
                if term.name not in interpretation:
                    raise ValueError(f"Variable {term.name} not in interpretation")
                interpreted_terms.append(interpretation[term.name])
            else:
                # å¸¸é‡é¡¹
                interpreted_terms.append(term.name)
        
        # è°ƒç”¨è°“è¯çš„è§£é‡Šå‡½æ•°
        predicate_interpretation = interpretation.get(self.predicate.name)
        if predicate_interpretation is None:
            raise ValueError(f"Predicate {self.predicate.name} not in interpretation")
        
        return TruthValue(predicate_interpretation(*interpreted_terms))
    
    def __str__(self):
        return f"{self.predicate}({', '.join(str(term) for term in self.terms)})"

class QuantifiedFormula:
    """é‡è¯å…¬å¼ç±»"""
    
    def __init__(self, quantifier: str, variable: Variable, formula: 'Formula'):
        self.quantifier = quantifier  # "âˆ€" or "âˆƒ"
        self.variable = variable
        self.formula = formula
    
    def evaluate(self, interpretation: Dict[str, Any], domain: Set[Any]) -> TruthValue:
        """åœ¨è§£é‡Šä¸‹æ±‚å€¼"""
        if self.quantifier == "âˆ€":
            # å…¨ç§°é‡è¯ï¼šå¯¹æ‰€æœ‰åŸŸä¸­çš„å…ƒç´ ï¼Œå…¬å¼éƒ½ä¸ºçœŸ
            for element in domain:
                new_interpretation = interpretation.copy()
                new_interpretation[self.variable.name] = element
                if self.formula.evaluate(new_interpretation, domain) == TruthValue.FALSE:
                    return TruthValue.FALSE
            return TruthValue.TRUE
        
        elif self.quantifier == "âˆƒ":
            # å­˜åœ¨é‡è¯ï¼šå­˜åœ¨åŸŸä¸­çš„å…ƒç´ ï¼Œä½¿å¾—å…¬å¼ä¸ºçœŸ
            for element in domain:
                new_interpretation = interpretation.copy()
                new_interpretation[self.variable.name] = element
                if self.formula.evaluate(new_interpretation, domain) == TruthValue.TRUE:
                    return TruthValue.TRUE
            return TruthValue.FALSE
        
        else:
            raise ValueError(f"Invalid quantifier: {self.quantifier}")
    
    def __str__(self):
        return f"{self.quantifier}{self.variable} {self.formula}"

class Formula:
    """å…¬å¼ç±»"""
    
    def __init__(self, operator: LogicalOperator, *operands):
        self.operator = operator
        self.operands = operands
    
    def evaluate(self, interpretation: Dict[str, Any], domain: Set[Any]) -> TruthValue:
        """åœ¨è§£é‡Šä¸‹æ±‚å€¼"""
        evaluated_operands = []
        
        for operand in self.operands:
            if isinstance(operand, (AtomicFormula, QuantifiedFormula, Formula)):
                evaluated_operands.append(operand.evaluate(interpretation, domain))
            else:
                raise ValueError(f"Invalid operand type: {type(operand)}")
        
        return self.operator.evaluate(*evaluated_operands)
    
    def __str__(self):
        if len(self.operands) == 1:
            return f"{self.operator}{self.operands[0]}"
        else:
            return f"({self.operands[0]} {self.operator} {self.operands[1]})"

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_predicate_logic():
    """æ¼”ç¤ºè°“è¯é€»è¾‘"""
    # å®šä¹‰åŸŸ
    domain = {1, 2, 3, 4, 5}
    
    # å®šä¹‰è°“è¯
    Even = Predicate("Even", 1)
    Greater = Predicate("Greater", 2)
    
    # å®šä¹‰å˜é‡
    x = Variable("x")
    y = Variable("y")
    
    # åˆ›å»ºåŸå­å…¬å¼
    even_x = Even(x)
    greater_xy = Greater(x, y)
    
    # åˆ›å»ºé‡è¯å…¬å¼ï¼šâˆ€x Even(x)
    forall_even = QuantifiedFormula("âˆ€", x, even_x)
    
    # åˆ›å»ºå¤åˆå…¬å¼ï¼šâˆ€x âˆƒy Greater(x, y)
    exists_y = QuantifiedFormula("âˆƒ", y, greater_xy)
    forall_exists = QuantifiedFormula("âˆ€", x, exists_y)
    
    # å®šä¹‰è§£é‡Š
    interpretation = {
        "Even": lambda n: n % 2 == 0,
        "Greater": lambda m, n: m > n
    }
    
    print(f"å…¬å¼: {forall_even}")
    print(f"åœ¨åŸŸ {domain} ä¸‹çš„çœŸå€¼: {forall_even.evaluate(interpretation, domain)}")
    
    print(f"å…¬å¼: {forall_exists}")
    print(f"åœ¨åŸŸ {domain} ä¸‹çš„çœŸå€¼: {forall_exists.evaluate(interpretation, domain)}")

if __name__ == "__main__":
    demonstrate_predicate_logic()
```

### 3. æ¨¡æ€é€»è¾‘

#### 3.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 3.1** (æ¨¡æ€ç®—å­)

- å¿…ç„¶ç®—å­ï¼š$\Box P$ (å¿…ç„¶P)
- å¯èƒ½ç®—å­ï¼š$\Diamond P$ (å¯èƒ½P)

**å®šä¹‰ 3.2** (å…‹é‡Œæ™®å…‹æ¨¡å‹)
å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $M = (W, R, V)$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯å¯èƒ½ä¸–ç•Œé›†åˆ
- $R \subseteq W \times W$ æ˜¯å¯è¾¾å…³ç³»
- $V: W \times P \rightarrow \{T, F\}$ æ˜¯èµ‹å€¼å‡½æ•°

**å®šä¹‰ 3.3** (æ¨¡æ€å…¬å¼è¯­ä¹‰)
å¯¹äºå…‹é‡Œæ™®å…‹æ¨¡å‹ $M = (W, R, V)$ å’Œä¸–ç•Œ $w \in W$ï¼š

- $M, w \models \Box \phi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $M, v \models \phi$
- $M, w \models \Diamond \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $M, v \models \phi$

#### 3.2 Pythonå®ç°

```python
from typing import Dict, Set, List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class World:
    """å¯èƒ½ä¸–ç•Œç±»"""
    name: str
    propositions: Dict[str, TruthValue]
    
    def __str__(self):
        return self.name

class KripkeModel:
    """å…‹é‡Œæ™®å…‹æ¨¡å‹ç±»"""
    
    def __init__(self, worlds: List[World], accessibility: Dict[str, Set[str]]):
        self.worlds = {w.name: w for w in worlds}
        self.accessibility = accessibility
    
    def get_accessible_worlds(self, world_name: str) -> Set[str]:
        """è·å–å¯è¾¾ä¸–ç•Œ"""
        return self.accessibility.get(world_name, set())
    
    def evaluate_atomic(self, world_name: str, proposition: str) -> TruthValue:
        """åœ¨æŒ‡å®šä¸–ç•Œæ±‚å€¼åŸå­å‘½é¢˜"""
        world = self.worlds.get(world_name)
        if world is None:
            raise ValueError(f"World {world_name} not found")
        return world.propositions.get(proposition, TruthValue.FALSE)

class ModalFormula:
    """æ¨¡æ€å…¬å¼ç±»"""
    
    def __init__(self, operator: str, formula: 'ModalFormula'):
        self.operator = operator  # "â–¡" or "â—‡"
        self.formula = formula
    
    def evaluate(self, model: KripkeModel, world_name: str) -> TruthValue:
        """åœ¨å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æ±‚å€¼"""
        accessible_worlds = model.get_accessible_worlds(world_name)
        
        if self.operator == "â–¡":
            # å¿…ç„¶ï¼šæ‰€æœ‰å¯è¾¾ä¸–ç•Œéƒ½ä¸ºçœŸ
            for accessible_world in accessible_worlds:
                if self.formula.evaluate(model, accessible_world) == TruthValue.FALSE:
                    return TruthValue.FALSE
            return TruthValue.TRUE
        
        elif self.operator == "â—‡":
            # å¯èƒ½ï¼šå­˜åœ¨å¯è¾¾ä¸–ç•Œä¸ºçœŸ
            for accessible_world in accessible_worlds:
                if self.formula.evaluate(model, accessible_world) == TruthValue.TRUE:
                    return TruthValue.TRUE
            return TruthValue.FALSE
        
        else:
            raise ValueError(f"Invalid modal operator: {self.operator}")
    
    def __str__(self):
        return f"{self.operator}{self.formula}"

class AtomicModalFormula:
    """åŸå­æ¨¡æ€å…¬å¼ç±»"""
    
    def __init__(self, proposition: str):
        self.proposition = proposition
    
    def evaluate(self, model: KripkeModel, world_name: str) -> TruthValue:
        """åœ¨å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æ±‚å€¼"""
        return model.evaluate_atomic(world_name, self.proposition)
    
    def __str__(self):
        return self.proposition

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_modal_logic():
    """æ¼”ç¤ºæ¨¡æ€é€»è¾‘"""
    # åˆ›å»ºå¯èƒ½ä¸–ç•Œ
    w1 = World("w1", {"P": TruthValue.TRUE, "Q": TruthValue.FALSE})
    w2 = World("w2", {"P": TruthValue.FALSE, "Q": TruthValue.TRUE})
    w3 = World("w3", {"P": TruthValue.TRUE, "Q": TruthValue.TRUE})
    
    # å®šä¹‰å¯è¾¾å…³ç³»
    accessibility = {
        "w1": {"w1", "w2"},
        "w2": {"w2", "w3"},
        "w3": {"w3"}
    }
    
    # åˆ›å»ºå…‹é‡Œæ™®å…‹æ¨¡å‹
    model = KripkeModel([w1, w2, w3], accessibility)
    
    # åˆ›å»ºæ¨¡æ€å…¬å¼
    P = AtomicModalFormula("P")
    Q = AtomicModalFormula("Q")
    
    # â–¡P (å¿…ç„¶P)
    necessary_P = ModalFormula("â–¡", P)
    
    # â—‡Q (å¯èƒ½Q)
    possible_Q = ModalFormula("â—‡", Q)
    
    print("æ¨¡æ€é€»è¾‘ç¤ºä¾‹ï¼š")
    print(f"åœ¨w1ä¸­ï¼Œâ–¡Pçš„çœŸå€¼: {necessary_P.evaluate(model, 'w1')}")
    print(f"åœ¨w1ä¸­ï¼Œâ—‡Qçš„çœŸå€¼: {possible_Q.evaluate(model, 'w1')}")

if __name__ == "__main__":
    demonstrate_modal_logic()
```

## ğŸ”„ é€»è¾‘æ¨ç†

### 1. è‡ªç„¶æ¼”ç»ç³»ç»Ÿ

#### 1.1 æ¨ç†è§„åˆ™

**å¼•å…¥è§„åˆ™**:

- $\land$-I: ä» $P$ å’Œ $Q$ æ¨å‡º $P \land Q$
- $\lor$-I: ä» $P$ æ¨å‡º $P \lor Q$ æˆ– $Q \lor P$
- $\rightarrow$-I: ä»å‡è®¾ $P$ æ¨å‡º $Q$ï¼Œåˆ™æ¨å‡º $P \rightarrow Q$

**æ¶ˆé™¤è§„åˆ™**:

- $\land$-E: ä» $P \land Q$ æ¨å‡º $P$ æˆ– $Q$
- $\lor$-E: ä» $P \lor Q$ å’Œ $P \rightarrow R$ å’Œ $Q \rightarrow R$ æ¨å‡º $R$
- $\rightarrow$-E: ä» $P \rightarrow Q$ å’Œ $P$ æ¨å‡º $Q$

#### 1.2 Pythonå®ç°

```python
from typing import List, Dict, Set, Optional, Tuple
from dataclasses import dataclass

@dataclass
class ProofStep:
    """è¯æ˜æ­¥éª¤"""
    step_id: int
    formula: str
    rule: str
    premises: List[int]
    discharged: Optional[int] = None  # è¢«æ¶ˆé™¤çš„å‡è®¾

class NaturalDeduction:
    """è‡ªç„¶æ¼”ç»ç³»ç»Ÿ"""
    
    def __init__(self):
        self.steps: List[ProofStep] = []
        self.assumptions: Dict[int, str] = {}  # å‡è®¾ç¼–å· -> å…¬å¼
        self.next_assumption_id = 1
    
    def add_assumption(self, formula: str) -> int:
        """æ·»åŠ å‡è®¾"""
        assumption_id = self.next_assumption_id
        self.assumptions[assumption_id] = formula
        self.next_assumption_id += 1
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="å‡è®¾",
            premises=[],
            discharged=None
        )
        self.steps.append(step)
        return assumption_id
    
    def conjunction_intro(self, premise1: int, premise2: int) -> int:
        """åˆå–å¼•å…¥"""
        step1 = self.steps[premise1 - 1]
        step2 = self.steps[premise2 - 1]
        formula = f"({step1.formula} âˆ§ {step2.formula})"
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="âˆ§-I",
            premises=[premise1, premise2]
        )
        self.steps.append(step)
        return step.step_id
    
    def conjunction_elim(self, premise: int, which: int) -> int:
        """åˆå–æ¶ˆé™¤ (which=1å–å·¦ï¼Œwhich=2å–å³)"""
        step_premise = self.steps[premise - 1]
        # è§£æåˆå–å…¬å¼
        if step_premise.formula.startswith("(") and step_premise.formula.endswith(")"):
            inner = step_premise.formula[1:-1]
            if " âˆ§ " in inner:
                parts = inner.split(" âˆ§ ")
                if which == 1:
                    formula = parts[0]
                else:
                    formula = parts[1]
            else:
                raise ValueError("Not a conjunction formula")
        else:
            raise ValueError("Not a conjunction formula")
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="âˆ§-E",
            premises=[premise]
        )
        self.steps.append(step)
        return step.step_id
    
    def implication_intro(self, assumption_id: int, conclusion: int) -> int:
        """è•´å«å¼•å…¥"""
        assumption = self.assumptions[assumption_id]
        step_conclusion = self.steps[conclusion - 1]
        formula = f"({assumption} â†’ {step_conclusion.formula})"
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="â†’-I",
            premises=[conclusion],
            discharged=assumption_id
        )
        self.steps.append(step)
        return step.step_id
    
    def implication_elim(self, premise1: int, premise2: int) -> int:
        """è•´å«æ¶ˆé™¤"""
        step1 = self.steps[premise1 - 1]
        step2 = self.steps[premise2 - 1]
        
        # è§£æè•´å«å…¬å¼
        if step1.formula.startswith("(") and step1.formula.endswith(")"):
            inner = step1.formula[1:-1]
            if " â†’ " in inner:
                parts = inner.split(" â†’ ")
                antecedent = parts[0]
                consequent = parts[1]
                
                if step2.formula == antecedent:
                    formula = consequent
                else:
                    raise ValueError("Antecedent mismatch")
            else:
                raise ValueError("Not an implication formula")
        else:
            raise ValueError("Not an implication formula")
        
        step = ProofStep(
            step_id=len(self.steps) + 1,
            formula=formula,
            rule="â†’-E",
            premises=[premise1, premise2]
        )
        self.steps.append(step)
        return step.step_id
    
    def print_proof(self):
        """æ‰“å°è¯æ˜"""
        print("è‡ªç„¶æ¼”ç»è¯æ˜ï¼š")
        print("-" * 50)
        
        for step in self.steps:
            discharged_info = f" [æ¶ˆé™¤å‡è®¾{step.discharged}]" if step.discharged else ""
            print(f"{step.step_id}. {step.formula} ({step.rule}){discharged_info}")
            if step.premises:
                print(f"   å‰æ: {step.premises}")

# ç¤ºä¾‹ï¼šè¯æ˜ P âˆ§ Q â†’ Q âˆ§ P
def prove_commutativity():
    """è¯æ˜åˆå–çš„äº¤æ¢å¾‹"""
    nd = NaturalDeduction()
    
    # å‡è®¾ P âˆ§ Q
    assumption_id = nd.add_assumption("P âˆ§ Q")
    
    # ä» P âˆ§ Q æ¨å‡º P
    step1 = nd.conjunction_elim(1, 1)
    
    # ä» P âˆ§ Q æ¨å‡º Q
    step2 = nd.conjunction_elim(1, 2)
    
    # ä» Q å’Œ P æ¨å‡º Q âˆ§ P
    step3 = nd.conjunction_intro(step2, step1)
    
    # ä»å‡è®¾æ¨å‡ºç»“è®º
    step4 = nd.implication_intro(assumption_id, step3)
    
    nd.print_proof()

if __name__ == "__main__":
    prove_commutativity()
```

## ğŸ“Š é€»è¾‘åº”ç”¨

### 1. ç¨‹åºéªŒè¯

#### 1.1 éœå°”é€»è¾‘

**å®šä¹‰ 4.1** (éœå°”ä¸‰å…ƒç»„)
éœå°”ä¸‰å…ƒç»„ $\{P\} C \{Q\}$ è¡¨ç¤ºï¼šå¦‚æœåœ¨æ‰§è¡Œç¨‹åº $C$ ä¹‹å‰å‰ç½®æ¡ä»¶ $P$ æˆç«‹ï¼Œä¸” $C$ ç»ˆæ­¢ï¼Œåˆ™æ‰§è¡Œååç½®æ¡ä»¶ $Q$ æˆç«‹ã€‚

**å…¬ç† 4.1** (èµ‹å€¼å…¬ç†)
$$\{P[E/x]\} x := E \{P\}$$

**è§„åˆ™ 4.1** (é¡ºåºè§„åˆ™)
$$\frac{\{P\} C_1 \{R\} \quad \{R\} C_2 \{Q\}}{\{P\} C_1; C_2 \{Q\}}$$

**è§„åˆ™ 4.2** (æ¡ä»¶è§„åˆ™)
$$\frac{\{P \land B\} C_1 \{Q\} \quad \{P \land \neg B\} C_2 \{Q\}}{\{P\} \text{if } B \text{ then } C_1 \text{ else } C_2 \{Q\}}$$

#### 1.2 Pythonå®ç°

```python
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

@dataclass
class HoareTriple:
    """éœå°”ä¸‰å…ƒç»„"""
    precondition: str
    program: str
    postcondition: str
    
    def __str__(self):
        return f"{{{self.precondition}}} {self.program} {{{self.postcondition}}}"

class HoareLogic:
    """éœå°”é€»è¾‘éªŒè¯å™¨"""
    
    def __init__(self):
        self.variables: Dict[str, Any] = {}
    
    def substitution(self, formula: str, var: str, expr: str) -> str:
        """å˜é‡æ›¿æ¢"""
        # ç®€å•çš„å­—ç¬¦ä¸²æ›¿æ¢ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„è§£æ
        return formula.replace(var, expr)
    
    def assignment_axiom(self, var: str, expr: str, postcondition: str) -> HoareTriple:
        """èµ‹å€¼å…¬ç†"""
        precondition = self.substitution(postcondition, var, expr)
        return HoareTriple(precondition, f"{var} := {expr}", postcondition)
    
    def sequence_rule(self, triple1: HoareTriple, triple2: HoareTriple) -> HoareTriple:
        """é¡ºåºè§„åˆ™"""
        if triple1.postcondition != triple2.precondition:
            raise ValueError("Postcondition of first triple must match precondition of second")
        
        program = f"{triple1.program}; {triple2.program}"
        return HoareTriple(triple1.precondition, program, triple2.postcondition)
    
    def conditional_rule(self, condition: str, triple1: HoareTriple, triple2: HoareTriple) -> HoareTriple:
        """æ¡ä»¶è§„åˆ™"""
        if triple1.precondition != triple2.precondition or triple1.postcondition != triple2.postcondition:
            raise ValueError("Triples must have same preconditions and postconditions")
        
        program = f"if {condition} then {triple1.program} else {triple2.program}"
        return HoareTriple(triple1.precondition, program, triple1.postcondition)
    
    def while_rule(self, condition: str, invariant: str, triple: HoareTriple) -> HoareTriple:
        """å¾ªç¯è§„åˆ™"""
        if triple.precondition != invariant or triple.postcondition != invariant:
            raise ValueError("Loop body must preserve invariant")
        
        program = f"while {condition} do {triple.program}"
        return HoareTriple(invariant, program, f"{invariant} âˆ§ Â¬{condition}")

# ç¤ºä¾‹ï¼šéªŒè¯äº¤æ¢ä¸¤ä¸ªå˜é‡çš„ç¨‹åº
def verify_swap_program():
    """éªŒè¯äº¤æ¢ç¨‹åº"""
    hoare = HoareLogic()
    
    # äº¤æ¢ç¨‹åºï¼štemp := x; x := y; y := temp
    # å‰ç½®æ¡ä»¶ï¼šx = a âˆ§ y = b
    # åç½®æ¡ä»¶ï¼šx = b âˆ§ y = a
    
    # ç¬¬ä¸€æ­¥ï¼štemp := x
    step1 = hoare.assignment_axiom("temp", "x", "temp = a âˆ§ x = a âˆ§ y = b")
    
    # ç¬¬äºŒæ­¥ï¼šx := y
    step2 = hoare.assignment_axiom("x", "y", "temp = a âˆ§ x = b âˆ§ y = b")
    
    # ç¬¬ä¸‰æ­¥ï¼šy := temp
    step3 = hoare.assignment_axiom("y", "temp", "temp = a âˆ§ x = b âˆ§ y = a")
    
    # åº”ç”¨é¡ºåºè§„åˆ™
    step12 = hoare.sequence_rule(step1, step2)
    final = hoare.sequence_rule(step12, step3)
    
    print("äº¤æ¢ç¨‹åºéªŒè¯ï¼š")
    print(f"éœå°”ä¸‰å…ƒç»„: {final}")
    print("éªŒè¯æˆåŠŸï¼")

if __name__ == "__main__":
    verify_swap_program()
```

### 2. æ¨¡å‹æ£€æµ‹

#### 2.1 çº¿æ€§æ—¶æ€é€»è¾‘ (LTL)

**å®šä¹‰ 4.2** (LTLå…¬å¼)
LTLå…¬å¼é€’å½’å®šä¹‰ä¸ºï¼š

- åŸå­å‘½é¢˜ $p$
- å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯LTLå…¬å¼ï¼Œåˆ™ $\neg\phi$, $\phi \land \psi$, $\phi \lor \psi$, $\phi \rightarrow \psi$ æ˜¯LTLå…¬å¼
- å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯LTLå…¬å¼ï¼Œåˆ™ $X\phi$ (ä¸‹ä¸€ä¸ª), $F\phi$ (æœ€ç»ˆ), $G\phi$ (æ€»æ˜¯), $\phi U\psi$ (ç›´åˆ°) æ˜¯LTLå…¬å¼

#### 2.2 Pythonå®ç°

```python
from typing import List, Set, Dict, Optional
from dataclasses import dataclass

@dataclass
class State:
    """çŠ¶æ€ç±»"""
    name: str
    propositions: Set[str]
    transitions: List[str]  # åç»§çŠ¶æ€åç§°

class KripkeStructure:
    """å…‹é‡Œæ™®å…‹ç»“æ„"""
    
    def __init__(self, states: List[State]):
        self.states = {s.name: s for s in states}
    
    def get_successors(self, state_name: str) -> List[State]:
        """è·å–åç»§çŠ¶æ€"""
        state = self.states.get(state_name)
        if state is None:
            return []
        return [self.states[name] for name in state.transitions if name in self.states]

class LTLFormula:
    """LTLå…¬å¼ç±»"""
    
    def __init__(self, operator: str, *operands):
        self.operator = operator
        self.operands = operands
    
    def evaluate_path(self, path: List[State], position: int) -> bool:
        """åœ¨è·¯å¾„çš„æŒ‡å®šä½ç½®æ±‚å€¼"""
        if self.operator == "p":
            # åŸå­å‘½é¢˜
            return self.operands[0] in path[position].propositions
        
        elif self.operator == "Â¬":
            return not self.operands[0].evaluate_path(path, position)
        
        elif self.operator == "âˆ§":
            return (self.operands[0].evaluate_path(path, position) and 
                   self.operands[1].evaluate_path(path, position))
        
        elif self.operator == "âˆ¨":
            return (self.operands[0].evaluate_path(path, position) or 
                   self.operands[1].evaluate_path(path, position))
        
        elif self.operator == "X":
            # ä¸‹ä¸€ä¸ª
            if position + 1 < len(path):
                return self.operands[0].evaluate_path(path, position + 1)
            return False
        
        elif self.operator == "F":
            # æœ€ç»ˆ
            for i in range(position, len(path)):
                if self.operands[0].evaluate_path(path, i):
                    return True
            return False
        
        elif self.operator == "G":
            # æ€»æ˜¯
            for i in range(position, len(path)):
                if not self.operands[0].evaluate_path(path, i):
                    return False
            return True
        
        elif self.operator == "U":
            # ç›´åˆ°
            for i in range(position, len(path)):
                if self.operands[1].evaluate_path(path, i):
                    return True
                if not self.operands[0].evaluate_path(path, i):
                    return False
            return False
        
        else:
            raise ValueError(f"Unknown operator: {self.operator}")
    
    def __str__(self):
        if self.operator == "p":
            return self.operands[0]
        elif self.operator == "Â¬":
            return f"Â¬{self.operands[0]}"
        elif self.operator in ["âˆ§", "âˆ¨"]:
            return f"({self.operands[0]} {self.operator} {self.operands[1]})"
        elif self.operator in ["X", "F", "G"]:
            return f"{self.operator}{self.operands[0]}"
        elif self.operator == "U":
            return f"({self.operands[0]} U {self.operands[1]})"
        else:
            return f"{self.operator}({', '.join(str(op) for op in self.operands)})"

class ModelChecker:
    """æ¨¡å‹æ£€æµ‹å™¨"""
    
    def __init__(self, kripke: KripkeStructure):
        self.kripke = kripke
    
    def check_formula(self, formula: LTLFormula, initial_state: str) -> bool:
        """æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨åˆå§‹çŠ¶æ€ä¸‹æˆç«‹"""
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è·¯å¾„
        paths = self._generate_paths(initial_state, max_length=10)
        
        # æ£€æŸ¥æ¯æ¡è·¯å¾„
        for path in paths:
            if not formula.evaluate_path(path, 0):
                print(f"åä¾‹è·¯å¾„: {' -> '.join(s.name for s in path)}")
                return False
        
        return True
    
    def _generate_paths(self, start_state: str, max_length: int) -> List[List[State]]:
        """ç”Ÿæˆè·¯å¾„"""
        paths = []
        
        def dfs(current_state: str, current_path: List[State], length: int):
            if length >= max_length:
                paths.append(current_path[:])
                return
            
            state = self.kripke.states.get(current_state)
            if state is None:
                return
            
            current_path.append(state)
            
            if not state.transitions:
                paths.append(current_path[:])
            else:
                for next_state_name in state.transitions:
                    dfs(next_state_name, current_path, length + 1)
            
            current_path.pop()
        
        dfs(start_state, [], 0)
        return paths

# ç¤ºä¾‹ï¼šéªŒè¯äº’æ–¥åè®®
def verify_mutual_exclusion():
    """éªŒè¯äº’æ–¥åè®®"""
    # åˆ›å»ºçŠ¶æ€
    s0 = State("s0", {"idle1", "idle2"}, ["s1", "s2"])
    s1 = State("s1", {"waiting1", "idle2"}, ["s3", "s0"])
    s2 = State("s2", {"idle1", "waiting2"}, ["s3", "s0"])
    s3 = State("s3", {"waiting1", "waiting2"}, ["s1", "s2"])
    
    kripke = KripkeStructure([s0, s1, s2, s3])
    checker = ModelChecker(kripke)
    
    # åˆ›å»ºLTLå…¬å¼ï¼šG(Â¬(critical1 âˆ§ critical2)) - äº’æ–¥æ€§
    critical1 = LTLFormula("p", "critical1")
    critical2 = LTLFormula("p", "critical2")
    both_critical = LTLFormula("âˆ§", critical1, critical2)
    not_both = LTLFormula("Â¬", both_critical)
    always_not_both = LTLFormula("G", not_both)
    
    print("éªŒè¯äº’æ–¥æ€§: G(Â¬(critical1 âˆ§ critical2))")
    result = checker.check_formula(always_not_both, "s0")
    print(f"ç»“æœ: {result}")

if __name__ == "__main__":
    verify_mutual_exclusion()
```

## ğŸ“ˆ æ€»ç»“

é€»è¾‘å­¦ä¸ºè½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦æä¾›äº†ï¼š

1. **ä¸¥æ ¼çš„æ¨ç†æ¡†æ¶**ï¼šå½¢å¼åŒ–çš„è¯æ˜æ–¹æ³•
2. **ç¨‹åºéªŒè¯åŸºç¡€**ï¼šéœå°”é€»è¾‘ç­‰ç¨‹åºéªŒè¯æŠ€æœ¯
3. **æ¨¡å‹æ£€æµ‹ç†è®º**ï¼šæ—¶æ€é€»è¾‘å’Œè‡ªåŠ¨æœºç†è®º
4. **ç±»å‹ç³»ç»ŸåŸºç¡€**ï¼šç±»å‹è®ºå’Œé€»è¾‘çš„å¯¹åº”å…³ç³»
5. **äººå·¥æ™ºèƒ½åŸºç¡€**ï¼šçŸ¥è¯†è¡¨ç¤ºå’Œæ¨ç†

é€šè¿‡å½¢å¼åŒ–çš„é€»è¾‘ç³»ç»Ÿï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

- ä¸¥æ ¼è¯æ˜ç¨‹åºçš„æ­£ç¡®æ€§
- è‡ªåŠ¨æ£€æµ‹ç³»ç»Ÿæ€§è´¨
- æ„å»ºå¯é çš„è½¯ä»¶ç³»ç»Ÿ
- å‘å±•äººå·¥æ™ºèƒ½æ¨ç†èƒ½åŠ›

é€»è¾‘å­¦æ˜¯è¿æ¥æ•°å­¦ç†è®ºå’Œè®¡ç®—æœºå®è·µçš„æ¡¥æ¢ï¼Œä¸ºç°ä»£è½¯ä»¶å·¥ç¨‹æä¾›äº†åšå®çš„ç†è®ºåŸºç¡€ã€‚
