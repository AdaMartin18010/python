# 01. 集合论基础

## 概述

集合论是数学的基础理论，也是计算机科学的重要数学工具。本章将从严格的数学定义出发，通过Python实现来阐述集合论的核心概念，为软件架构科学提供坚实的数学基础。

## 1. 集合的基本概念

### 1.1 集合的定义

**定义 1.1.1 (集合)** 集合是一些确定的不同对象的整体，这些对象称为该集合的元素。

**形式化定义**：
设 $A$ 为集合，$x$ 为元素，则：

$$x \in A \text{ 表示 } x \text{ 属于 } A$$
$$x \notin A \text{ 表示 } x \text{ 不属于 } A$$

**Python实现**：

```python
from typing import TypeVar, Generic, Iterator, Any, Set as PySet
from abc import ABC, abstractmethod
from dataclasses import dataclass
import math

T = TypeVar('T')

class Set(ABC, Generic[T]):
    """集合抽象基类"""
    
    @abstractmethod
    def contains(self, element: T) -> bool:
        """判断元素是否属于集合"""
        pass
    
    @abstractmethod
    def add(self, element: T) -> None:
        """添加元素到集合"""
        pass
    
    @abstractmethod
    def remove(self, element: T) -> None:
        """从集合中移除元素"""
        pass
    
    @abstractmethod
    def size(self) -> int:
        """返回集合的大小"""
        pass
    
    @abstractmethod
    def is_empty(self) -> bool:
        """判断集合是否为空"""
        pass
    
    @abstractmethod
    def iterator(self) -> Iterator[T]:
        """返回集合的迭代器"""
        pass

class FiniteSet(Set[T]):
    """有限集合"""
    
    def __init__(self):
        self._elements: PySet[T] = set()
    
    def contains(self, element: T) -> bool:
        """判断元素是否属于集合"""
        return element in self._elements
    
    def add(self, element: T) -> None:
        """添加元素到集合"""
        self._elements.add(element)
    
    def remove(self, element: T) -> None:
        """从集合中移除元素"""
        self._elements.discard(element)
    
    def size(self) -> int:
        """返回集合的大小"""
        return len(self._elements)
    
    def is_empty(self) -> bool:
        """判断集合是否为空"""
        return len(self._elements) == 0
    
    def iterator(self) -> Iterator[T]:
        """返回集合的迭代器"""
        return iter(self._elements)
    
    def __str__(self) -> str:
        return f"{{{', '.join(map(str, self._elements))}}}"
    
    def __repr__(self) -> str:
        return f"FiniteSet({self._elements})"

class InfiniteSet(Set[T]):
    """无限集合"""
    
    def __init__(self, predicate: callable):
        self.predicate = predicate
    
    def contains(self, element: T) -> bool:
        """判断元素是否属于集合"""
        return self.predicate(element)
    
    def add(self, element: T) -> None:
        """无限集合不支持添加元素"""
        raise NotImplementedError("Infinite sets do not support adding elements")
    
    def remove(self, element: T) -> None:
        """无限集合不支持移除元素"""
        raise NotImplementedError("Infinite sets do not support removing elements")
    
    def size(self) -> int:
        """返回集合的大小（无限）"""
        return float('inf')
    
    def is_empty(self) -> bool:
        """判断集合是否为空"""
        # 这是一个不可判定问题，简化处理
        return False
    
    def iterator(self) -> Iterator[T]:
        """返回集合的迭代器（可能无限）"""
        # 这是一个复杂问题，简化处理
        raise NotImplementedError("Infinite sets do not support iteration")

# 使用示例
def demonstrate_basic_sets():
    """演示基本集合操作"""
    # 创建有限集合
    finite_set = FiniteSet[int]()
    
    # 添加元素
    finite_set.add(1)
    finite_set.add(2)
    finite_set.add(3)
    
    print(f"集合: {finite_set}")
    print(f"大小: {finite_set.size()}")
    print(f"包含 2: {finite_set.contains(2)}")
    print(f"包含 4: {finite_set.contains(4)}")
    
    # 移除元素
    finite_set.remove(2)
    print(f"移除 2 后: {finite_set}")
    
    # 创建无限集合（偶数集合）
    even_numbers = InfiniteSet[int](lambda x: x % 2 == 0)
    print(f"4 是偶数: {even_numbers.contains(4)}")
    print(f"3 是偶数: {even_numbers.contains(3)}")

if __name__ == "__main__":
    demonstrate_basic_sets()
```

### 1.2 集合的表示方法

**定义 1.1.2 (集合表示)** 集合可以通过以下方式表示：

1. **列举法**: $A = \{a_1, a_2, ..., a_n\}$
2. **描述法**: $A = \{x | P(x)\}$，其中 $P(x)$ 是谓词
3. **递归法**: 通过递归定义集合

**Python实现**：

```python
from typing import List, Callable, Any

class SetBuilder:
    """集合构造器"""
    
    @staticmethod
    def from_elements(*elements: T) -> FiniteSet[T]:
        """从元素列表构造集合"""
        set_obj = FiniteSet[T]()
        for element in elements:
            set_obj.add(element)
        return set_obj
    
    @staticmethod
    def from_predicate(predicate: Callable[[T], bool]) -> InfiniteSet[T]:
        """从谓词构造集合"""
        return InfiniteSet[T](predicate)
    
    @staticmethod
    def from_list(elements: List[T]) -> FiniteSet[T]:
        """从列表构造集合"""
        set_obj = FiniteSet[T]()
        for element in elements:
            set_obj.add(element)
        return set_obj
    
    @staticmethod
    def range(start: int, end: int, step: int = 1) -> FiniteSet[int]:
        """构造整数范围集合"""
        set_obj = FiniteSet[int]()
        for i in range(start, end, step):
            set_obj.add(i)
        return set_obj

# 使用示例
def demonstrate_set_representation():
    """演示集合表示方法"""
    # 列举法
    set1 = SetBuilder.from_elements(1, 2, 3, 4, 5)
    print(f"列举法: {set1}")
    
    # 描述法
    even_set = SetBuilder.from_predicate(lambda x: x % 2 == 0)
    print(f"偶数集合包含 4: {even_set.contains(4)}")
    
    # 从列表构造
    list_set = SetBuilder.from_list([1, 2, 3, 4, 5])
    print(f"从列表构造: {list_set}")
    
    # 范围集合
    range_set = SetBuilder.range(1, 10, 2)
    print(f"范围集合: {range_set}")

if __name__ == "__main__":
    demonstrate_set_representation()
```

## 2. 集合运算

### 2.1 基本运算

**定义 2.1.1 (并集)** 集合 $A$ 和 $B$ 的并集定义为：

$$A \cup B = \{x | x \in A \text{ 或 } x \in B\}$$

**定义 2.1.2 (交集)** 集合 $A$ 和 $B$ 的交集定义为：

$$A \cap B = \{x | x \in A \text{ 且 } x \in B\}$$

**定义 2.1.3 (差集)** 集合 $A$ 和 $B$ 的差集定义为：

$$A - B = \{x | x \in A \text{ 且 } x \notin B\}$$

**定义 2.1.4 (补集)** 集合 $A$ 在全集 $U$ 中的补集定义为：

$$A' = U - A = \{x | x \in U \text{ 且 } x \notin A\}$$

**Python实现**：

```python
class SetOperations:
    """集合运算"""
    
    @staticmethod
    def union(set_a: Set[T], set_b: Set[T]) -> FiniteSet[T]:
        """并集运算"""
        result = FiniteSet[T]()
        
        # 添加集合A的元素
        for element in set_a.iterator():
            result.add(element)
        
        # 添加集合B的元素
        for element in set_b.iterator():
            result.add(element)
        
        return result
    
    @staticmethod
    def intersection(set_a: Set[T], set_b: Set[T]) -> FiniteSet[T]:
        """交集运算"""
        result = FiniteSet[T]()
        
        # 检查集合A中的每个元素是否也在集合B中
        for element in set_a.iterator():
            if set_b.contains(element):
                result.add(element)
        
        return result
    
    @staticmethod
    def difference(set_a: Set[T], set_b: Set[T]) -> FiniteSet[T]:
        """差集运算"""
        result = FiniteSet[T]()
        
        # 添加在A中但不在B中的元素
        for element in set_a.iterator():
            if not set_b.contains(element):
                result.add(element)
        
        return result
    
    @staticmethod
    def complement(set_a: Set[T], universe: Set[T]) -> FiniteSet[T]:
        """补集运算"""
        return SetOperations.difference(universe, set_a)
    
    @staticmethod
    def symmetric_difference(set_a: Set[T], set_b: Set[T]) -> FiniteSet[T]:
        """对称差集运算"""
        union_result = SetOperations.union(set_a, set_b)
        intersection_result = SetOperations.intersection(set_a, set_b)
        return SetOperations.difference(union_result, intersection_result)

# 使用示例
def demonstrate_set_operations():
    """演示集合运算"""
    # 创建测试集合
    set_a = SetBuilder.from_elements(1, 2, 3, 4, 5)
    set_b = SetBuilder.from_elements(4, 5, 6, 7, 8)
    
    print(f"集合 A: {set_a}")
    print(f"集合 B: {set_b}")
    
    # 并集
    union_result = SetOperations.union(set_a, set_b)
    print(f"A ∪ B: {union_result}")
    
    # 交集
    intersection_result = SetOperations.intersection(set_a, set_b)
    print(f"A ∩ B: {intersection_result}")
    
    # 差集
    difference_result = SetOperations.difference(set_a, set_b)
    print(f"A - B: {difference_result}")
    
    # 对称差集
    symmetric_diff_result = SetOperations.symmetric_difference(set_a, set_b)
    print(f"A △ B: {symmetric_diff_result}")
    
    # 补集
    universe = SetBuilder.range(1, 10)
    complement_result = SetOperations.complement(set_a, universe)
    print(f"A' (在全集 {universe} 中): {complement_result}")

if __name__ == "__main__":
    demonstrate_set_operations()
```

### 2.2 集合关系

**定义 2.2.1 (包含关系)** 如果集合 $A$ 的每个元素都属于集合 $B$，则称 $A$ 是 $B$ 的子集，记作：

$$A \subseteq B \Leftrightarrow \forall x (x \in A \rightarrow x \in B)$$

**定义 2.2.2 (真包含关系)** 如果 $A \subseteq B$ 且 $A \neq B$，则称 $A$ 是 $B$ 的真子集，记作：

$$A \subset B \Leftrightarrow A \subseteq B \land A \neq B$$

**定义 2.2.3 (相等关系)** 两个集合相等当且仅当它们包含相同的元素：

$$A = B \Leftrightarrow A \subseteq B \land B \subseteq A$$

**Python实现**：

```python
class SetRelations:
    """集合关系"""
    
    @staticmethod
    def is_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断A是否是B的子集"""
        for element in set_a.iterator():
            if not set_b.contains(element):
                return False
        return True
    
    @staticmethod
    def is_proper_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断A是否是B的真子集"""
        return (SetRelations.is_subset(set_a, set_b) and 
                not SetRelations.is_subset(set_b, set_a))
    
    @staticmethod
    def is_equal(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断两个集合是否相等"""
        return (SetRelations.is_subset(set_a, set_b) and 
                SetRelations.is_subset(set_b, set_a))
    
    @staticmethod
    def is_disjoint(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断两个集合是否不相交"""
        for element in set_a.iterator():
            if set_b.contains(element):
                return False
        return True

# 使用示例
def demonstrate_set_relations():
    """演示集合关系"""
    # 创建测试集合
    set_a = SetBuilder.from_elements(1, 2, 3)
    set_b = SetBuilder.from_elements(1, 2, 3, 4, 5)
    set_c = SetBuilder.from_elements(1, 2, 3)
    set_d = SetBuilder.from_elements(6, 7, 8)
    
    print(f"集合 A: {set_a}")
    print(f"集合 B: {set_b}")
    print(f"集合 C: {set_c}")
    print(f"集合 D: {set_d}")
    
    # 子集关系
    print(f"A ⊆ B: {SetRelations.is_subset(set_a, set_b)}")
    print(f"B ⊆ A: {SetRelations.is_subset(set_b, set_a)}")
    
    # 真子集关系
    print(f"A ⊂ B: {SetRelations.is_proper_subset(set_a, set_b)}")
    print(f"A ⊂ C: {SetRelations.is_proper_subset(set_a, set_c)}")
    
    # 相等关系
    print(f"A = C: {SetRelations.is_equal(set_a, set_c)}")
    print(f"A = B: {SetRelations.is_equal(set_a, set_b)}")
    
    # 不相交关系
    print(f"A 与 D 不相交: {SetRelations.is_disjoint(set_a, set_d)}")
    print(f"A 与 B 不相交: {SetRelations.is_disjoint(set_a, set_b)}")

if __name__ == "__main__":
    demonstrate_set_relations()
```

## 3. 关系与函数

### 3.1 笛卡尔积

**定义 3.1.1 (笛卡尔积)** 集合 $A$ 和 $B$ 的笛卡尔积定义为：

$$A \times B = \{(a, b) | a \in A \land b \in B\}$$

**Python实现**：

```python
from typing import Tuple

@dataclass
class CartesianProduct:
    """笛卡尔积"""
    
    @staticmethod
    def product(set_a: Set[T], set_b: Set[T]) -> FiniteSet[Tuple[T, T]]:
        """计算两个集合的笛卡尔积"""
        result = FiniteSet[Tuple[T, T]]()
        
        for a in set_a.iterator():
            for b in set_b.iterator():
                result.add((a, b))
        
        return result
    
    @staticmethod
    def power(set_a: Set[T], n: int) -> FiniteSet[Tuple[T, ...]]:
        """计算集合的n次幂"""
        if n == 0:
            return FiniteSet[Tuple[T, ...]]()
        elif n == 1:
            result = FiniteSet[Tuple[T, ...]]()
            for element in set_a.iterator():
                result.add((element,))
            return result
        else:
            result = FiniteSet[Tuple[T, ...]]()
            prev_power = CartesianProduct.power(set_a, n - 1)
            
            for prev_tuple in prev_power.iterator():
                for element in set_a.iterator():
                    new_tuple = prev_tuple + (element,)
                    result.add(new_tuple)
            
            return result

# 使用示例
def demonstrate_cartesian_product():
    """演示笛卡尔积"""
    set_a = SetBuilder.from_elements(1, 2)
    set_b = SetBuilder.from_elements('a', 'b')
    
    print(f"集合 A: {set_a}")
    print(f"集合 B: {set_b}")
    
    # 笛卡尔积
    product = CartesianProduct.product(set_a, set_b)
    print(f"A × B: {product}")
    
    # 幂集
    power_2 = CartesianProduct.power(set_a, 2)
    print(f"A²: {power_2}")

if __name__ == "__main__":
    demonstrate_cartesian_product()
```

### 3.2 关系

**定义 3.2.1 (关系)** 集合 $A$ 到集合 $B$ 的关系是 $A \times B$ 的子集。

**定义 3.2.2 (关系的性质)** 设 $R$ 是集合 $A$ 上的关系：

1. **自反性**: $\forall x \in A, (x, x) \in R$
2. **对称性**: $\forall x, y \in A, (x, y) \in R \rightarrow (y, x) \in R$
3. **传递性**: $\forall x, y, z \in A, (x, y) \in R \land (y, z) \in R \rightarrow (x, z) \in R$
4. **反对称性**: $\forall x, y \in A, (x, y) \in R \land (y, x) \in R \rightarrow x = y$

**Python实现**：

```python
@dataclass
class Relation:
    """关系"""
    domain: Set[T]
    codomain: Set[T]
    pairs: FiniteSet[Tuple[T, T]]
    
    def is_reflexive(self) -> bool:
        """判断是否自反"""
        for element in self.domain.iterator():
            if not self.pairs.contains((element, element)):
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """判断是否对称"""
        for pair in self.pairs.iterator():
            x, y = pair
            if not self.pairs.contains((y, x)):
                return False
        return True
    
    def is_transitive(self) -> bool:
        """判断是否传递"""
        for pair1 in self.pairs.iterator():
            for pair2 in self.pairs.iterator():
                x1, y1 = pair1
                x2, y2 = pair2
                if y1 == x2 and not self.pairs.contains((x1, y2)):
                    return False
        return True
    
    def is_antisymmetric(self) -> bool:
        """判断是否反对称"""
        for pair1 in self.pairs.iterator():
            for pair2 in self.pairs.iterator():
                x1, y1 = pair1
                x2, y2 = pair2
                if x1 == y2 and y1 == x2 and x1 != y1:
                    return False
        return True
    
    def is_equivalence(self) -> bool:
        """判断是否是等价关系"""
        return (self.is_reflexive() and 
                self.is_symmetric() and 
                self.is_transitive())
    
    def is_partial_order(self) -> bool:
        """判断是否是偏序关系"""
        return (self.is_reflexive() and 
                self.is_antisymmetric() and 
                self.is_transitive())

# 使用示例
def demonstrate_relations():
    """演示关系"""
    # 创建集合
    set_a = SetBuilder.from_elements(1, 2, 3)
    
    # 相等关系
    equality_pairs = FiniteSet[Tuple[int, int]]()
    for x in set_a.iterator():
        for y in set_a.iterator():
            if x == y:
                equality_pairs.add((x, y))
    
    equality_relation = Relation(set_a, set_a, equality_pairs)
    
    print("相等关系的性质:")
    print(f"  自反性: {equality_relation.is_reflexive()}")
    print(f"  对称性: {equality_relation.is_symmetric()}")
    print(f"  传递性: {equality_relation.is_transitive()}")
    print(f"  等价关系: {equality_relation.is_equivalence()}")
    
    # 小于等于关系
    leq_pairs = FiniteSet[Tuple[int, int]]()
    for x in set_a.iterator():
        for y in set_a.iterator():
            if x <= y:
                leq_pairs.add((x, y))
    
    leq_relation = Relation(set_a, set_a, leq_pairs)
    
    print("\n小于等于关系的性质:")
    print(f"  自反性: {leq_relation.is_reflexive()}")
    print(f"  反对称性: {leq_relation.is_antisymmetric()}")
    print(f"  传递性: {leq_relation.is_transitive()}")
    print(f"  偏序关系: {leq_relation.is_partial_order()}")

if __name__ == "__main__":
    demonstrate_relations()
```

### 3.3 函数

**定义 3.3.1 (函数)** 函数是从集合 $A$ 到集合 $B$ 的关系 $f$，满足：

$$\forall x \in A, \exists! y \in B, (x, y) \in f$$

**Python实现**：

```python
from typing import Dict, Optional

@dataclass
class Function:
    """函数"""
    domain: Set[T]
    codomain: Set[T]
    mapping: Dict[T, T]
    
    def apply(self, x: T) -> Optional[T]:
        """函数应用"""
        return self.mapping.get(x)
    
    def is_injective(self) -> bool:
        """判断是否是单射"""
        seen_values = set()
        for value in self.mapping.values():
            if value in seen_values:
                return False
            seen_values.add(value)
        return True
    
    def is_surjective(self) -> bool:
        """判断是否是满射"""
        for y in self.codomain.iterator():
            found = False
            for x in self.domain.iterator():
                if self.apply(x) == y:
                    found = True
                    break
            if not found:
                return False
        return True
    
    def is_bijective(self) -> bool:
        """判断是否是双射"""
        return self.is_injective() and self.is_surjective()
    
    def compose(self, other: 'Function') -> 'Function':
        """函数复合"""
        if self.codomain != other.domain:
            raise ValueError("Cannot compose functions with incompatible domains/codomains")
        
        new_mapping = {}
        for x in self.domain.iterator():
            y = self.apply(x)
            if y is not None:
                z = other.apply(y)
                if z is not None:
                    new_mapping[x] = z
        
        return Function(self.domain, other.codomain, new_mapping)

# 使用示例
def demonstrate_functions():
    """演示函数"""
    # 创建集合
    domain = SetBuilder.from_elements(1, 2, 3)
    codomain = SetBuilder.from_elements('a', 'b', 'c')
    
    # 创建函数
    mapping = {1: 'a', 2: 'b', 3: 'c'}
    function = Function(domain, codomain, mapping)
    
    print("函数性质:")
    print(f"  f(1) = {function.apply(1)}")
    print(f"  f(2) = {function.apply(2)}")
    print(f"  f(3) = {function.apply(3)}")
    print(f"  单射: {function.is_injective()}")
    print(f"  满射: {function.is_surjective()}")
    print(f"  双射: {function.is_bijective()}")
    
    # 函数复合
    domain2 = SetBuilder.from_elements('a', 'b', 'c')
    codomain2 = SetBuilder.from_elements('x', 'y', 'z')
    mapping2 = {'a': 'x', 'b': 'y', 'c': 'z'}
    function2 = Function(domain2, codomain2, mapping2)
    
    composed = function.compose(function2)
    print(f"\n复合函数 f∘g:")
    print(f"  (f∘g)(1) = {composed.apply(1)}")
    print(f"  (f∘g)(2) = {composed.apply(2)}")
    print(f"  (f∘g)(3) = {composed.apply(3)}")

if __name__ == "__main__":
    demonstrate_functions()
```

## 4. 基数与序数

### 4.1 基数

**定义 4.1.1 (基数)** 集合的基数是衡量集合大小的数。

**定义 4.1.2 (等势)** 两个集合等势当且仅当存在它们之间的双射。

**Python实现**：

```python
@dataclass
class Cardinality:
    """基数"""
    
    @staticmethod
    def is_equipotent(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断两个集合是否等势"""
        # 对于有限集合，检查大小是否相等
        if isinstance(set_a, FiniteSet) and isinstance(set_b, FiniteSet):
            return set_a.size() == set_b.size()
        
        # 对于无限集合，这是一个复杂问题
        # 这里简化处理
        return False
    
    @staticmethod
    def is_countable(set_obj: Set[T]) -> bool:
        """判断集合是否可数"""
        if isinstance(set_obj, FiniteSet):
            return True
        
        # 对于无限集合，检查是否可以与自然数建立双射
        # 这里简化处理
        return False
    
    @staticmethod
    def power_set(set_obj: Set[T]) -> FiniteSet[FiniteSet[T]]:
        """计算幂集"""
        if not isinstance(set_obj, FiniteSet):
            raise ValueError("Power set is only defined for finite sets")
        
        elements = list(set_obj.iterator())
        n = len(elements)
        power_set = FiniteSet[FiniteSet[T]]()
        
        # 使用二进制表示生成所有子集
        for i in range(2**n):
            subset = FiniteSet[T]()
            for j in range(n):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(subset)
        
        return power_set

# 使用示例
def demonstrate_cardinality():
    """演示基数"""
    # 创建测试集合
    set_a = SetBuilder.from_elements(1, 2, 3)
    set_b = SetBuilder.from_elements('a', 'b', 'c')
    set_c = SetBuilder.from_elements(1, 2)
    
    print(f"集合 A: {set_a}, 大小: {set_a.size()}")
    print(f"集合 B: {set_b}, 大小: {set_b.size()}")
    print(f"集合 C: {set_c}, 大小: {set_c.size()}")
    
    # 等势关系
    print(f"A 与 B 等势: {Cardinality.is_equipotent(set_a, set_b)}")
    print(f"A 与 C 等势: {Cardinality.is_equipotent(set_a, set_c)}")
    
    # 可数性
    print(f"A 可数: {Cardinality.is_countable(set_a)}")
    print(f"B 可数: {Cardinality.is_countable(set_b)}")
    
    # 幂集
    power_set_a = Cardinality.power_set(set_a)
    print(f"A 的幂集: {power_set_a}")
    print(f"幂集大小: {power_set_a.size()}")

if __name__ == "__main__":
    demonstrate_cardinality()
```

## 总结

本章从严格的数学定义出发，阐述了集合论的核心概念：集合的基本概念、集合运算、关系与函数、基数与序数。通过Python实现，我们验证了这些概念的理论基础和实践应用。

### 关键要点

1. **集合定义**: 集合是一些确定的不同对象的整体
2. **集合运算**: 并集、交集、差集、补集等基本运算
3. **集合关系**: 包含关系、相等关系等
4. **关系与函数**: 笛卡尔积、关系的性质、函数的定义
5. **基数**: 集合大小的度量

### 数学形式化

- 集合定义: $A = \{x | P(x)\}$
- 并集: $A \cup B = \{x | x \in A \text{ 或 } x \in B\}$
- 交集: $A \cap B = \{x | x \in A \text{ 且 } x \in B\}$
- 笛卡尔积: $A \times B = \{(a, b) | a \in A \land b \in B\}$
- 函数: $\forall x \in A, \exists! y \in B, (x, y) \in f$

这些数学形式化为集合论提供了严格的理论基础，确保概念的一致性和可验证性。
