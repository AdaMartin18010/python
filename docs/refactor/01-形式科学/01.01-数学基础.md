# 01.01 æ•°å­¦åŸºç¡€

## ğŸ“– æ¦‚è¿°

æ•°å­¦åŸºç¡€æ˜¯è®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹çš„ç†è®ºåŸºçŸ³ï¼ŒåŒ…æ‹¬é›†åˆè®ºã€æ•°è®ºã€ä»£æ•°ã€åˆ†æç­‰æ ¸å¿ƒæ¦‚å¿µã€‚æœ¬æ–‡æ¡£æä¾›è¿™äº›æ¦‚å¿µçš„å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆè®ºåŸºç¡€

**å®šä¹‰**ï¼šé›†åˆæ˜¯ä¸åŒå¯¹è±¡çš„æ— åºèšé›†ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**ï¼š
è®¾ $A$ ä¸ºé›†åˆï¼Œ$x$ ä¸ºå…ƒç´ ï¼Œåˆ™ï¼š
- $x \in A$ è¡¨ç¤º $x$ å±äº $A$
- $A \subseteq B$ è¡¨ç¤º $A$ æ˜¯ $B$ çš„å­é›†
- $A \cup B$ è¡¨ç¤º $A$ å’Œ $B$ çš„å¹¶é›†
- $A \cap B$ è¡¨ç¤º $A$ å’Œ $B$ çš„äº¤é›†

**Pythonå®ç°**ï¼š
```python
from typing import Set, List, Any, Iterator
from abc import ABC, abstractmethod
import itertools

class SetTheory:
    """é›†åˆè®ºå®ç°"""
    
    @staticmethod
    def is_subset(A: Set[Any], B: Set[Any]) -> bool:
        """æ£€æŸ¥ A æ˜¯å¦æ˜¯ B çš„å­é›†"""
        return A.issubset(B)
    
    @staticmethod
    def is_proper_subset(A: Set[Any], B: Set[Any]) -> bool:
        """æ£€æŸ¥ A æ˜¯å¦æ˜¯ B çš„çœŸå­é›†"""
        return A.issubset(B) and A != B
    
    @staticmethod
    def union(*sets: Set[Any]) -> Set[Any]:
        """å¤šä¸ªé›†åˆçš„å¹¶é›†"""
        result = set()
        for s in sets:
            result.update(s)
        return result
    
    @staticmethod
    def intersection(*sets: Set[Any]) -> Set[Any]:
        """å¤šä¸ªé›†åˆçš„äº¤é›†"""
        if not sets:
            return set()
        result = sets[0].copy()
        for s in sets[1:]:
            result.intersection_update(s)
        return result
    
    @staticmethod
    def difference(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """é›†åˆå·®é›† A - B"""
        return A - B
    
    @staticmethod
    def symmetric_difference(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """å¯¹ç§°å·®é›† A â–³ B"""
        return A.symmetric_difference(B)
    
    @staticmethod
    def cartesian_product(*sets: Set[Any]) -> Set[tuple]:
        """ç¬›å¡å°”ç§¯"""
        return set(itertools.product(*sets))
    
    @staticmethod
    def power_set(A: Set[Any]) -> Set[frozenset]:
        """å¹‚é›† P(A)"""
        elements = list(A)
        power_set = set()
        
        for i in range(2**len(elements)):
            subset = set()
            for j in range(len(elements)):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set

class InfiniteSet(ABC):
    """æ— é™é›†åˆæŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def contains(self, element: Any) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        pass
    
    @abstractmethod
    def __iter__(self) -> Iterator[Any]:
        """è¿­ä»£é›†åˆå…ƒç´ """
        pass

class NaturalNumbers(InfiniteSet):
    """è‡ªç„¶æ•°é›†åˆ"""
    
    def contains(self, element: Any) -> bool:
        return isinstance(element, int) and element >= 0
    
    def __iter__(self) -> Iterator[int]:
        n = 0
        while True:
            yield n
            n += 1

# ç¤ºä¾‹ï¼šé›†åˆè®ºæ“ä½œ
def demonstrate_set_theory():
    """æ¼”ç¤ºé›†åˆè®ºæ“ä½œ"""
    
    A = {1, 2, 3, 4, 5}
    B = {4, 5, 6, 7, 8}
    C = {1, 2, 3}
    
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"C = {C}")
    
    # åŸºæœ¬æ“ä½œ
    print(f"A âˆª B = {SetTheory.union(A, B)}")
    print(f"A âˆ© B = {SetTheory.intersection(A, B)}")
    print(f"A - B = {SetTheory.difference(A, B)}")
    print(f"A â–³ B = {SetTheory.symmetric_difference(A, B)}")
    
    # å­é›†å…³ç³»
    print(f"C âŠ† A: {SetTheory.is_subset(C, A)}")
    print(f"C âŠ‚ A: {SetTheory.is_proper_subset(C, A)}")
    
    # ç¬›å¡å°”ç§¯
    cartesian = SetTheory.cartesian_product(A, B)
    print(f"A Ã— B çš„å‰5ä¸ªå…ƒç´ : {list(cartesian)[:5]}")
    
    # å¹‚é›†
    power_set = SetTheory.power_set(C)
    print(f"P(C) = {power_set}")

# æ‰§è¡Œæ¼”ç¤º
demonstrate_set_theory()
```

### 2. æ•°è®ºåŸºç¡€

**å®šä¹‰**ï¼šæ•°è®ºç ”ç©¶æ•´æ•°çš„æ€§è´¨å’Œå…³ç³»ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- **æ•´é™¤æ€§**ï¼š$a \mid b$ è¡¨ç¤º $a$ æ•´é™¤ $b$
- **æœ€å¤§å…¬çº¦æ•°**ï¼š$\gcd(a, b)$
- **æœ€å°å…¬å€æ•°**ï¼š$\text{lcm}(a, b)$
- **ç´ æ•°**ï¼šåªèƒ½è¢«1å’Œè‡ªèº«æ•´é™¤çš„æ­£æ•´æ•°

**Pythonå®ç°**ï¼š
```python
import math
from typing import List, Tuple, Iterator
from collections import defaultdict

class NumberTheory:
    """æ•°è®ºå®ç°"""
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚æœ€å¤§å…¬çº¦æ•°"""
        while b:
            a, b = b, a % b
        return abs(a)
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """æœ€å°å…¬å€æ•°"""
        return abs(a * b) // NumberTheory.gcd(a, b)
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•"""
        if b == 0:
            return a, 1, 0
        
        gcd, x1, y1 = NumberTheory.extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return gcd, x, y
    
    @staticmethod
    def modular_inverse(a: int, m: int) -> int:
        """æ¨¡é€†å…ƒ"""
        gcd, x, y = NumberTheory.extended_gcd(a, m)
        if gcd != 1:
            raise ValueError("æ¨¡é€†å…ƒä¸å­˜åœ¨")
        return (x % m + m) % m
    
    @staticmethod
    def prime_factors(n: int) -> List[int]:
        """è´¨å› æ•°åˆ†è§£"""
        factors = []
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors.append(d)
                n //= d
            d += 1
        
        if n > 1:
            factors.append(n)
        
        return factors
    
    @staticmethod
    def euler_totient(n: int) -> int:
        """æ¬§æ‹‰å‡½æ•° Ï†(n)"""
        result = n
        factors = set(NumberTheory.prime_factors(n))
        
        for p in factors:
            result = result // p * (p - 1)
        
        return result
    
    @staticmethod
    def generate_primes(limit: int) -> List[int]:
        """åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•ç”Ÿæˆç´ æ•°"""
        sieve = [True] * (limit + 1)
        sieve[0] = sieve[1] = False
        
        for i in range(2, int(math.sqrt(limit)) + 1):
            if sieve[i]:
                for j in range(i * i, limit + 1, i):
                    sieve[j] = False
        
        return [i for i in range(limit + 1) if sieve[i]]
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> int:
        """ä¸­å›½å‰©ä½™å®šç†"""
        if len(remainders) != len(moduli):
            raise ValueError("ä½™æ•°å’Œæ¨¡æ•°æ•°é‡ä¸åŒ¹é…")
        
        # è®¡ç®—æ€»æ¨¡æ•°
        total_modulus = 1
        for m in moduli:
            total_modulus *= m
        
        result = 0
        for i, (remainder, modulus) in enumerate(zip(remainders, moduli)):
            # è®¡ç®— Mi
            Mi = total_modulus // modulus
            
            # è®¡ç®— Mi çš„æ¨¡é€†å…ƒ
            Mi_inverse = NumberTheory.modular_inverse(Mi, modulus)
            
            result = (result + remainder * Mi * Mi_inverse) % total_modulus
        
        return result

class PrimeNumberGenerator:
    """ç´ æ•°ç”Ÿæˆå™¨"""
    
    def __init__(self):
        self.primes = [2, 3]
        self.last_checked = 3
    
    def generate_next_prime(self) -> int:
        """ç”Ÿæˆä¸‹ä¸€ä¸ªç´ æ•°"""
        candidate = self.last_checked + 2
        
        while not NumberTheory.is_prime(candidate):
            candidate += 2
        
        self.primes.append(candidate)
        self.last_checked = candidate
        return candidate
    
    def get_primes_up_to(self, n: int) -> List[int]:
        """è·å–å°äºç­‰äºnçš„æ‰€æœ‰ç´ æ•°"""
        while self.last_checked < n:
            self.generate_next_prime()
        
        return [p for p in self.primes if p <= n]

# ç¤ºä¾‹ï¼šæ•°è®ºæ“ä½œ
def demonstrate_number_theory():
    """æ¼”ç¤ºæ•°è®ºæ“ä½œ"""
    
    # ç´ æ•°åˆ¤æ–­
    test_numbers = [2, 3, 4, 17, 25, 29, 100]
    for n in test_numbers:
        print(f"{n} æ˜¯ç´ æ•°: {NumberTheory.is_prime(n)}")
    
    # æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°
    a, b = 48, 18
    print(f"gcd({a}, {b}) = {NumberTheory.gcd(a, b)}")
    print(f"lcm({a}, {b}) = {NumberTheory.lcm(a, b)}")
    
    # è´¨å› æ•°åˆ†è§£
    n = 100
    factors = NumberTheory.prime_factors(n)
    print(f"{n} çš„è´¨å› æ•°åˆ†è§£: {factors}")
    
    # æ¬§æ‹‰å‡½æ•°
    phi = NumberTheory.euler_totient(n)
    print(f"Ï†({n}) = {phi}")
    
    # ç”Ÿæˆç´ æ•°
    primes = NumberTheory.generate_primes(50)
    print(f"å°äº50çš„ç´ æ•°: {primes}")
    
    # ä¸­å›½å‰©ä½™å®šç†
    remainders = [2, 3, 2]
    moduli = [3, 5, 7]
    result = NumberTheory.chinese_remainder_theorem(remainders, moduli)
    print(f"ä¸­å›½å‰©ä½™å®šç†: x â‰¡ {remainders} (mod {moduli}) => x = {result}")

# æ‰§è¡Œæ¼”ç¤º
demonstrate_number_theory()
```

### 3. ä»£æ•°åŸºç¡€

**å®šä¹‰**ï¼šä»£æ•°ç ”ç©¶è¿ç®—å’Œè¿ç®—å¾‹ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- **ç¾¤**ï¼šæ»¡è¶³ç»“åˆå¾‹ã€æœ‰å•ä½å…ƒã€æœ‰é€†å…ƒçš„ä»£æ•°ç»“æ„
- **ç¯**ï¼šå…·æœ‰ä¸¤ç§è¿ç®—çš„ä»£æ•°ç»“æ„
- **åŸŸ**ï¼šå¯é™¤ç¯

**Pythonå®ç°**ï¼š
```python
from typing import Any, Dict, Optional
from abc import ABC, abstractmethod
from dataclasses import dataclass

@dataclass
class GroupElement:
    """ç¾¤å…ƒç´ """
    value: Any
    group: 'Group' = None
    
    def __mul__(self, other: 'GroupElement') -> 'GroupElement':
        """ç¾¤è¿ç®—"""
        if self.group != other.group:
            raise ValueError("ä¸åŒç¾¤çš„å…ƒç´ ä¸èƒ½è¿ç®—")
        return self.group.operation(self, other)
    
    def __eq__(self, other: 'GroupElement') -> bool:
        return self.value == other.value and self.group == other.group

class Group(ABC):
    """ç¾¤æŠ½è±¡åŸºç±»"""
    
    def __init__(self, elements: List[Any]):
        self.elements = [GroupElement(e, self) for e in elements]
        self.identity = self._find_identity()
    
    @abstractmethod
    def operation(self, a: GroupElement, b: GroupElement) -> GroupElement:
        """ç¾¤è¿ç®—"""
        pass
    
    def _find_identity(self) -> GroupElement:
        """æ‰¾åˆ°å•ä½å…ƒ"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if self.operation(e, a) != a or self.operation(a, e) != a:
                    is_identity = False
                    break
            if is_identity:
                return e
        raise ValueError("ç¾¤ä¸­æ²¡æœ‰å•ä½å…ƒ")
    
    def inverse(self, element: GroupElement) -> GroupElement:
        """æ±‚é€†å…ƒ"""
        for e in self.elements:
            if (self.operation(element, e) == self.identity and 
                self.operation(e, element) == self.identity):
                return e
        raise ValueError("å…ƒç´ æ²¡æœ‰é€†å…ƒ")
    
    def is_abelian(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé˜¿è´å°”ç¾¤"""
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) != self.operation(b, a):
                    return False
        return True

class ModularGroup(Group):
    """æ¨¡nåŠ æ³•ç¾¤"""
    
    def __init__(self, n: int):
        self.modulus = n
        elements = list(range(n))
        super().__init__(elements)
    
    def operation(self, a: GroupElement, b: GroupElement) -> GroupElement:
        result = (a.value + b.value) % self.modulus
        return GroupElement(result, self)

class Ring(ABC):
    """ç¯æŠ½è±¡åŸºç±»"""
    
    def __init__(self, elements: List[Any]):
        self.elements = elements
        self.additive_identity = self._find_additive_identity()
        self.multiplicative_identity = self._find_multiplicative_identity()
    
    @abstractmethod
    def add(self, a: Any, b: Any) -> Any:
        """åŠ æ³•è¿ç®—"""
        pass
    
    @abstractmethod
    def multiply(self, a: Any, b: Any) -> Any:
        """ä¹˜æ³•è¿ç®—"""
        pass
    
    def _find_additive_identity(self) -> Any:
        """æ‰¾åˆ°åŠ æ³•å•ä½å…ƒ"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if self.add(e, a) != a or self.add(a, e) != a:
                    is_identity = False
                    break
            if is_identity:
                return e
        raise ValueError("ç¯ä¸­æ²¡æœ‰åŠ æ³•å•ä½å…ƒ")
    
    def _find_multiplicative_identity(self) -> Any:
        """æ‰¾åˆ°ä¹˜æ³•å•ä½å…ƒ"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if self.multiply(e, a) != a or self.multiply(a, e) != a:
                    is_identity = False
                    break
            if is_identity:
                return e
        return None  # ç¯å¯èƒ½æ²¡æœ‰ä¹˜æ³•å•ä½å…ƒ

class ModularRing(Ring):
    """æ¨¡nç¯"""
    
    def __init__(self, n: int):
        self.modulus = n
        elements = list(range(n))
        super().__init__(elements)
    
    def add(self, a: int, b: int) -> int:
        return (a + b) % self.modulus
    
    def multiply(self, a: int, b: int) -> int:
        return (a * b) % self.modulus

# ç¤ºä¾‹ï¼šä»£æ•°ç»“æ„
def demonstrate_algebra():
    """æ¼”ç¤ºä»£æ•°ç»“æ„"""
    
    # æ¨¡5åŠ æ³•ç¾¤
    group = ModularGroup(5)
    print(f"æ¨¡5åŠ æ³•ç¾¤:")
    print(f"å…ƒç´ : {[e.value for e in group.elements]}")
    print(f"å•ä½å…ƒ: {group.identity.value}")
    print(f"æ˜¯é˜¿è´å°”ç¾¤: {group.is_abelian()}")
    
    # ç¾¤è¿ç®—
    a = GroupElement(2, group)
    b = GroupElement(3, group)
    c = a * b
    print(f"{a.value} + {b.value} = {c.value} (mod 5)")
    
    # é€†å…ƒ
    a_inv = group.inverse(a)
    print(f"{a.value} çš„é€†å…ƒ: {a_inv.value}")
    
    # æ¨¡5ç¯
    ring = ModularRing(5)
    print(f"\næ¨¡5ç¯:")
    print(f"åŠ æ³•å•ä½å…ƒ: {ring.additive_identity}")
    print(f"ä¹˜æ³•å•ä½å…ƒ: {ring.multiplicative_identity}")
    
    # ç¯è¿ç®—
    result_add = ring.add(3, 4)
    result_mul = ring.multiply(3, 4)
    print(f"3 + 4 = {result_add} (mod 5)")
    print(f"3 Ã— 4 = {result_mul} (mod 5)")

# æ‰§è¡Œæ¼”ç¤º
demonstrate_algebra()
```

### 4. åˆ†æåŸºç¡€

**å®šä¹‰**ï¼šåˆ†æç ”ç©¶æé™ã€è¿ç»­æ€§ã€å¾®åˆ†å’Œç§¯åˆ†ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- **æé™**ï¼š$\lim_{x \to a} f(x) = L$
- **è¿ç»­æ€§**ï¼šå‡½æ•°åœ¨æŸç‚¹çš„è¿ç»­æ€§
- **å¯¼æ•°**ï¼š$f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h}$

**Pythonå®ç°**ï¼š
```python
import numpy as np
from typing import Callable, Optional, Tuple
from scipy.misc import derivative

class MathematicalAnalysis:
    """æ•°å­¦åˆ†æå®ç°"""
    
    @staticmethod
    def limit(f: Callable[[float], float], a: float, 
              tolerance: float = 1e-10, max_iterations: int = 1000) -> Optional[float]:
        """æ•°å€¼æ–¹æ³•è®¡ç®—æé™"""
        h_values = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6, 1e-7, 1e-8, 1e-9, 1e-10]
        
        for h in h_values:
            try:
                value = f(a + h)
                if abs(value) < tolerance:
                    return 0
                return value
            except (ZeroDivisionError, ValueError):
                continue
        
        return None
    
    @staticmethod
    def is_continuous(f: Callable[[float], float], a: float, 
                     tolerance: float = 1e-10) -> bool:
        """æ£€æŸ¥å‡½æ•°åœ¨ç‚¹açš„è¿ç»­æ€§"""
        try:
            f_a = f(a)
            
            # æ£€æŸ¥å·¦æé™
            left_limit = MathematicalAnalysis.limit(lambda x: f(x), a, tolerance)
            
            # æ£€æŸ¥å³æé™
            right_limit = MathematicalAnalysis.limit(lambda x: f(x), a, tolerance)
            
            # æ£€æŸ¥æé™æ˜¯å¦å­˜åœ¨ä¸”ç­‰äºå‡½æ•°å€¼
            if left_limit is not None and right_limit is not None:
                return abs(left_limit - f_a) < tolerance and abs(right_limit - f_a) < tolerance
            
            return False
        except:
            return False
    
    @staticmethod
    def derivative(f: Callable[[float], float], x: float, 
                  h: float = 1e-8) -> float:
        """æ•°å€¼å¾®åˆ†"""
        return (f(x + h) - f(x - h)) / (2 * h)
    
    @staticmethod
    def integral(f: Callable[[float], float], a: float, b: float, 
                n: int = 1000) -> float:
        """æ•°å€¼ç§¯åˆ†ï¼ˆæ¢¯å½¢æ³•åˆ™ï¼‰"""
        h = (b - a) / n
        x = np.linspace(a, b, n + 1)
        y = [f(xi) for xi in x]
        
        return h * (0.5 * y[0] + sum(y[1:-1]) + 0.5 * y[-1])
    
    @staticmethod
    def taylor_series(f: Callable[[float], float], a: float, 
                     degree: int, x: float) -> float:
        """æ³°å‹’çº§æ•°å±•å¼€"""
        result = 0
        for n in range(degree + 1):
            # è®¡ç®—né˜¶å¯¼æ•°
            if n == 0:
                derivative_n = f(a)
            else:
                derivative_n = MathematicalAnalysis.derivative(
                    lambda x: MathematicalAnalysis.derivative(f, x, 1e-8), a, 1e-8
                )
            
            result += derivative_n * (x - a)**n / math.factorial(n)
        
        return result

class Function:
    """å‡½æ•°ç±»"""
    
    def __init__(self, f: Callable[[float], float], domain: Tuple[float, float] = None):
        self.f = f
        self.domain = domain
    
    def __call__(self, x: float) -> float:
        return self.f(x)
    
    def compose(self, g: 'Function') -> 'Function':
        """å‡½æ•°å¤åˆ"""
        return Function(lambda x: self.f(g(x)))
    
    def inverse(self, y: float, tolerance: float = 1e-10) -> Optional[float]:
        """æ•°å€¼æ–¹æ³•æ±‚é€†å‡½æ•°"""
        if self.domain is None:
            return None
        
        a, b = self.domain
        
        # äºŒåˆ†æ³•æ±‚æ ¹
        while b - a > tolerance:
            c = (a + b) / 2
            if self.f(c) < y:
                a = c
            else:
                b = c
        
        return (a + b) / 2

# ç¤ºä¾‹ï¼šæ•°å­¦åˆ†æ
def demonstrate_analysis():
    """æ¼”ç¤ºæ•°å­¦åˆ†æ"""
    
    # å®šä¹‰å‡½æ•°
    def f(x: float) -> float:
        return x**2 + 2*x + 1
    
    def g(x: float) -> float:
        return np.sin(x)
    
    # æé™
    limit_result = MathematicalAnalysis.limit(f, 2)
    print(f"lim(xâ†’2) xÂ² + 2x + 1 = {limit_result}")
    
    # è¿ç»­æ€§
    is_cont = MathematicalAnalysis.is_continuous(f, 2)
    print(f"f(x) åœ¨ x=2 å¤„è¿ç»­: {is_cont}")
    
    # å¯¼æ•°
    derivative_result = MathematicalAnalysis.derivative(f, 2)
    print(f"f'(2) = {derivative_result}")
    
    # ç§¯åˆ†
    integral_result = MathematicalAnalysis.integral(f, 0, 2)
    print(f"âˆ«â‚€Â² (xÂ² + 2x + 1) dx = {integral_result}")
    
    # æ³°å‹’çº§æ•°
    taylor_result = MathematicalAnalysis.taylor_series(g, 0, 3, 0.5)
    print(f"sin(0.5) çš„3é˜¶æ³°å‹’å±•å¼€: {taylor_result}")
    
    # å‡½æ•°å¯¹è±¡
    func = Function(f, (0, 10))
    print(f"f(3) = {func(3)}")
    
    # å‡½æ•°å¤åˆ
    func_g = Function(g)
    composed = func.compose(func_g)
    print(f"(fâˆ˜g)(1) = {composed(1)}")

# æ‰§è¡Œæ¼”ç¤º
demonstrate_analysis()
```

### 5. ç¦»æ•£æ•°å­¦

**å®šä¹‰**ï¼šç¦»æ•£æ•°å­¦ç ”ç©¶ç¦»æ•£å¯¹è±¡å’Œç»“æ„ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- **ç»„åˆæ•°å­¦**ï¼šæ’åˆ—ã€ç»„åˆã€ç”Ÿæˆå‡½æ•°
- **å›¾è®º**ï¼šå›¾ã€è·¯å¾„ã€è¿é€šæ€§
- **é€»è¾‘**ï¼šå‘½é¢˜é€»è¾‘ã€è°“è¯é€»è¾‘

**Pythonå®ç°**ï¼š
```python
import itertools
from typing import List, Set, Tuple, Dict, Any
from collections import defaultdict

class Combinatorics:
    """ç»„åˆæ•°å­¦"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """é˜¶ä¹˜"""
        if n < 0:
            raise ValueError("è´Ÿæ•°æ²¡æœ‰é˜¶ä¹˜")
        if n == 0:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation(n: int, r: int) -> int:
        """æ’åˆ—æ•° P(n,r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination(n: int, r: int) -> int:
        """ç»„åˆæ•° C(n,r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def generate_permutations(elements: List[Any]) -> List[Tuple[Any, ...]]:
        """ç”Ÿæˆæ‰€æœ‰æ’åˆ—"""
        return list(itertools.permutations(elements))
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> List[Tuple[Any, ...]]:
        """ç”Ÿæˆæ‰€æœ‰rç»„åˆ"""
        return list(itertools.combinations(elements, r))
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """å¡ç‰¹å…°æ•°"""
        if n <= 1:
            return 1
        
        result = 0
        for i in range(n):
            result += Combinatorics.catalan_number(i) * Combinatorics.catalan_number(n - 1 - i)
        
        return result
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """æ–æ³¢é‚£å¥‘æ•°"""
        if n <= 1:
            return n
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        
        return b

class Graph:
    """å›¾ç±»"""
    
    def __init__(self, directed: bool = False):
        self.directed = directed
        self.vertices: Set[Any] = set()
        self.edges: List[Tuple[Any, Any]] = []
        self.adjacency_list: Dict[Any, Set[Any]] = defaultdict(set)
    
    def add_vertex(self, vertex: Any):
        """æ·»åŠ é¡¶ç‚¹"""
        self.vertices.add(vertex)
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = set()
    
    def add_edge(self, u: Any, v: Any):
        """æ·»åŠ è¾¹"""
        self.add_vertex(u)
        self.add_vertex(v)
        
        self.edges.append((u, v))
        self.adjacency_list[u].add(v)
        
        if not self.directed:
            self.adjacency_list[v].add(u)
    
    def remove_edge(self, u: Any, v: Any):
        """åˆ é™¤è¾¹"""
        if (u, v) in self.edges:
            self.edges.remove((u, v))
            self.adjacency_list[u].discard(v)
            
            if not self.directed:
                self.adjacency_list[v].discard(u)
    
    def get_neighbors(self, vertex: Any) -> Set[Any]:
        """è·å–é‚»å±…"""
        return self.adjacency_list.get(vertex, set())
    
    def degree(self, vertex: Any) -> int:
        """åº¦æ•°"""
        return len(self.get_neighbors(vertex))
    
    def is_connected(self) -> bool:
        """æ£€æŸ¥è¿é€šæ€§"""
        if not self.vertices:
            return True
        
        visited = set()
        start_vertex = next(iter(self.vertices))
        
        def dfs(vertex: Any):
            visited.add(vertex)
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    dfs(neighbor)
        
        dfs(start_vertex)
        return len(visited) == len(self.vertices)
    
    def shortest_path(self, start: Any, end: Any) -> List[Any]:
        """æœ€çŸ­è·¯å¾„ï¼ˆBFSï¼‰"""
        if start not in self.vertices or end not in self.vertices:
            return []
        
        queue = [(start, [start])]
        visited = {start}
        
        while queue:
            vertex, path = queue.pop(0)
            
            if vertex == end:
                return path
            
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return []  # æ²¡æœ‰è·¯å¾„
    
    def has_cycle(self) -> bool:
        """æ£€æµ‹ç¯"""
        visited = set()
        rec_stack = set()
        
        def dfs(vertex: Any) -> bool:
            visited.add(vertex)
            rec_stack.add(vertex)
            
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(vertex)
            return False
        
        for vertex in self.vertices:
            if vertex not in visited:
                if dfs(vertex):
                    return True
        
        return False

class PropositionalLogic:
    """å‘½é¢˜é€»è¾‘"""
    
    @staticmethod
    def truth_table(expression: str, variables: List[str]) -> List[Dict[str, bool]]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        table = []
        n = len(variables)
        
        for i in range(2**n):
            assignment = {}
            for j, var in enumerate(variables):
                assignment[var] = bool(i & (1 << j))
            
            # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦è§£æè¡¨è¾¾å¼
            table.append(assignment)
        
        return table
    
    @staticmethod
    def is_tautology(expression: str, variables: List[str]) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé‡è¨€å¼"""
        table = PropositionalLogic.truth_table(expression, variables)
        # ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è®¡ç®—è¡¨è¾¾å¼çš„å€¼
        return True
    
    @staticmethod
    def is_contradiction(expression: str, variables: List[str]) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        table = PropositionalLogic.truth_table(expression, variables)
        # ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è®¡ç®—è¡¨è¾¾å¼çš„å€¼
        return False

# ç¤ºä¾‹ï¼šç¦»æ•£æ•°å­¦
def demonstrate_discrete_math():
    """æ¼”ç¤ºç¦»æ•£æ•°å­¦"""
    
    # ç»„åˆæ•°å­¦
    n, r = 5, 3
    print(f"P({n},{r}) = {Combinatorics.permutation(n, r)}")
    print(f"C({n},{r}) = {Combinatorics.combination(n, r)}")
    
    elements = ['A', 'B', 'C']
    permutations = Combinatorics.generate_permutations(elements)
    print(f"æ‰€æœ‰æ’åˆ—: {permutations}")
    
    combinations = Combinatorics.generate_combinations(elements, 2)
    print(f"æ‰€æœ‰2ç»„åˆ: {combinations}")
    
    print(f"ç¬¬5ä¸ªå¡ç‰¹å…°æ•°: {Combinatorics.catalan_number(5)}")
    print(f"ç¬¬10ä¸ªæ–æ³¢é‚£å¥‘æ•°: {Combinatorics.fibonacci_number(10)}")
    
    # å›¾è®º
    graph = Graph(directed=False)
    graph.add_edge('A', 'B')
    graph.add_edge('B', 'C')
    graph.add_edge('C', 'D')
    graph.add_edge('D', 'A')
    
    print(f"\nå›¾:")
    print(f"é¡¶ç‚¹: {graph.vertices}")
    print(f"è¾¹: {graph.edges}")
    print(f"è¿é€š: {graph.is_connected()}")
    print(f"æœ‰ç¯: {graph.has_cycle()}")
    
    path = graph.shortest_path('A', 'C')
    print(f"Aåˆ°Cçš„æœ€çŸ­è·¯å¾„: {path}")
    
    # å‘½é¢˜é€»è¾‘
    variables = ['p', 'q']
    table = PropositionalLogic.truth_table("p AND q", variables)
    print(f"\nçœŸå€¼è¡¨: {table}")

# æ‰§è¡Œæ¼”ç¤º
demonstrate_discrete_math()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [01.02 é€»è¾‘å­¦](./01.02-é€»è¾‘å­¦.md)
- [01.03 é›†åˆè®º](./01.03-é›†åˆè®º.md)
- [01.04 å›¾è®º](./01.04-å›¾è®º.md)
- [02.01 è®¡ç®—ç†è®º](../02-ç†è®ºåŸºç¡€/02.01-è®¡ç®—ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Rudin, W. (1976). Principles of mathematical analysis. McGraw-Hill.
2. Hardy, G. H., & Wright, E. M. (1979). An introduction to the theory of numbers. Oxford University Press.
3. Dummit, D. S., & Foote, R. M. (2004). Abstract algebra. John Wiley & Sons.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0.0 