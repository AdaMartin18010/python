# 01.01 数学基础

## 📋 概述

数学基础是软件工程的形式科学基础，为算法设计、数据结构、复杂度分析等提供理论支撑。本文档涵盖软件工程中常用的数学概念、定理和证明。

## 🎯 核心概念

### 1. 集合论基础

**定义 1.1 (集合)**：
集合是不同对象的无序聚集，记作 $A = \{a_1, a_2, ..., a_n\}$。

**基本运算**：
- 并集：$A \cup B = \{x | x \in A \text{ 或 } x \in B\}$
- 交集：$A \cap B = \{x | x \in A \text{ 且 } x \in B\}$
- 差集：$A - B = \{x | x \in A \text{ 且 } x \notin B\}$
- 补集：$\overline{A} = \{x | x \notin A\}$

**Python实现**：

```python
from typing import Set, TypeVar, Generic, Iterator
from abc import ABC, abstractmethod
from dataclasses import dataclass

T = TypeVar('T')

class SetTheory:
    """集合论实现"""
    
    @staticmethod
    def union(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """并集运算"""
        return set_a | set_b
    
    @staticmethod
    def intersection(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """交集运算"""
        return set_a & set_b
    
    @staticmethod
    def difference(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """差集运算"""
        return set_a - set_b
    
    @staticmethod
    def complement(universal_set: Set[T], set_a: Set[T]) -> Set[T]:
        """补集运算"""
        return universal_set - set_a
    
    @staticmethod
    def is_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断子集关系"""
        return set_a.issubset(set_b)
    
    @staticmethod
    def is_proper_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """判断真子集关系"""
        return set_a.issubset(set_b) and set_a != set_b
    
    @staticmethod
    def power_set(set_a: Set[T]) -> Set[Set[T]]:
        """幂集运算"""
        from itertools import combinations
        
        elements = list(set_a)
        power_set = set()
        
        for i in range(len(elements) + 1):
            for combo in combinations(elements, i):
                power_set.add(frozenset(combo))
        
        return power_set

# 示例：集合运算
def set_operations_example():
    """集合运算示例"""
    A = {1, 2, 3, 4, 5}
    B = {4, 5, 6, 7, 8}
    universal = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    print(f"集合 A: {A}")
    print(f"集合 B: {B}")
    print(f"并集 A ∪ B: {SetTheory.union(A, B)}")
    print(f"交集 A ∩ B: {SetTheory.intersection(A, B)}")
    print(f"差集 A - B: {SetTheory.difference(A, B)}")
    print(f"补集 A̅: {SetTheory.complement(universal, A)}")
    print(f"A 是 B 的子集: {SetTheory.is_subset(A, B)}")
    
    # 幂集示例（小集合）
    small_set = {1, 2}
    power_set = SetTheory.power_set(small_set)
    print(f"集合 {small_set} 的幂集: {power_set}")
    
    return A, B

set_a, set_b = set_operations_example()
```

### 2. 关系与函数

**定义 1.2 (关系)**：
从集合 $A$ 到集合 $B$ 的关系是 $A \times B$ 的子集，记作 $R \subseteq A \times B$。

**定义 1.3 (函数)**：
函数是从集合 $A$ 到集合 $B$ 的特殊关系，满足：
1. 定义域覆盖：$\forall a \in A, \exists b \in B: (a, b) \in f$
2. 单值性：$(a, b_1) \in f \land (a, b_2) \in f \Rightarrow b_1 = b_2$

**Python实现**：

```python
from typing import Dict, List, Tuple, Any, Callable, Optional
from dataclasses import dataclass
from enum import Enum

class RelationType(Enum):
    """关系类型"""
    REFLEXIVE = "reflexive"
    SYMMETRIC = "symmetric"
    TRANSITIVE = "transitive"
    EQUIVALENCE = "equivalence"
    PARTIAL_ORDER = "partial_order"

@dataclass
class Relation:
    """关系定义"""
    domain: Set[Any]
    codomain: Set[Any]
    pairs: Set[Tuple[Any, Any]]
    
    def is_function(self) -> bool:
        """判断是否为函数"""
        # 检查定义域覆盖
        domain_elements = {pair[0] for pair in self.pairs}
        if domain_elements != self.domain:
            return False
        
        # 检查单值性
        domain_to_codomain = {}
        for pair in self.pairs:
            if pair[0] in domain_to_codomain:
                if domain_to_codomain[pair[0]] != pair[1]:
                    return False
            else:
                domain_to_codomain[pair[0]] = pair[1]
        
        return True
    
    def is_reflexive(self) -> bool:
        """判断是否自反"""
        for element in self.domain:
            if (element, element) not in self.pairs:
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """判断是否对称"""
        for pair in self.pairs:
            if (pair[1], pair[0]) not in self.pairs:
                return False
        return True
    
    def is_transitive(self) -> bool:
        """判断是否传递"""
        for pair1 in self.pairs:
            for pair2 in self.pairs:
                if pair1[1] == pair2[0]:
                    if (pair1[0], pair2[1]) not in self.pairs:
                        return False
        return True
    
    def is_equivalence(self) -> bool:
        """判断是否为等价关系"""
        return (self.is_reflexive() and 
                self.is_symmetric() and 
                self.is_transitive())
    
    def equivalence_classes(self) -> List[Set[Any]]:
        """计算等价类"""
        if not self.is_equivalence():
            raise ValueError("关系必须是等价关系")
        
        classes = []
        processed = set()
        
        for element in self.domain:
            if element in processed:
                continue
            
            # 找到包含element的等价类
            equivalence_class = {element}
            for pair in self.pairs:
                if pair[0] == element:
                    equivalence_class.add(pair[1])
                elif pair[1] == element:
                    equivalence_class.add(pair[0])
            
            classes.append(equivalence_class)
            processed.update(equivalence_class)
        
        return classes

class Function:
    """函数定义"""
    
    def __init__(self, domain: Set[Any], codomain: Set[Any], mapping: Dict[Any, Any]):
        self.domain = domain
        self.codomain = codomain
        self.mapping = mapping
        
        # 验证函数性质
        if not self._is_valid_function():
            raise ValueError("Invalid function definition")
    
    def _is_valid_function(self) -> bool:
        """验证函数定义的有效性"""
        # 检查定义域覆盖
        if set(self.mapping.keys()) != self.domain:
            return False
        
        # 检查值域包含
        if not set(self.mapping.values()).issubset(self.codomain):
            return False
        
        return True
    
    def apply(self, x: Any) -> Any:
        """应用函数"""
        if x not in self.domain:
            raise ValueError(f"Element {x} not in domain")
        return self.mapping[x]
    
    def compose(self, other: 'Function') -> 'Function':
        """函数复合"""
        if self.codomain != other.domain:
            raise ValueError("Codomain of first function must equal domain of second")
        
        new_mapping = {}
        for x in self.domain:
            new_mapping[x] = other.apply(self.apply(x))
        
        return Function(self.domain, other.codomain, new_mapping)
    
    def is_injective(self) -> bool:
        """判断是否为单射"""
        return len(self.mapping.values()) == len(set(self.mapping.values()))
    
    def is_surjective(self) -> bool:
        """判断是否为满射"""
        return set(self.mapping.values()) == self.codomain
    
    def is_bijective(self) -> bool:
        """判断是否为双射"""
        return self.is_injective() and self.is_surjective()

# 示例：关系和函数
def relation_function_example():
    """关系和函数示例"""
    # 关系示例：模3同余关系
    domain = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    codomain = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    
    # 模3同余关系：a ≡ b (mod 3)
    pairs = set()
    for a in domain:
        for b in codomain:
            if a % 3 == b % 3:
                pairs.add((a, b))
    
    relation = Relation(domain, codomain, pairs)
    
    print(f"关系性质:")
    print(f"  自反性: {relation.is_reflexive()}")
    print(f"  对称性: {relation.is_symmetric()}")
    print(f"  传递性: {relation.is_transitive()}")
    print(f"  等价关系: {relation.is_equivalence()}")
    
    if relation.is_equivalence():
        classes = relation.equivalence_classes()
        print(f"等价类: {classes}")
    
    # 函数示例：平方函数
    square_mapping = {x: x**2 for x in range(5)}
    square_function = Function(set(range(5)), set(range(25)), square_mapping)
    
    print(f"\n函数示例:")
    print(f"  f(2) = {square_function.apply(2)}")
    print(f"  单射: {square_function.is_injective()}")
    print(f"  满射: {square_function.is_surjective()}")
    print(f"  双射: {square_function.is_bijective()}")
    
    return relation, square_function

relation, square_func = relation_function_example()
```

### 3. 图论基础

**定义 1.4 (图)**：
图 $G = (V, E)$ 由顶点集 $V$ 和边集 $E$ 组成，其中 $E \subseteq V \times V$。

**基本概念**：
- 度：顶点 $v$ 的度 $deg(v)$ 是与 $v$ 相邻的边数
- 路径：顶点序列 $v_1, v_2, ..., v_n$ 使得 $(v_i, v_{i+1}) \in E$
- 连通性：图中任意两顶点间存在路径

**Python实现**：

```python
from typing import Dict, List, Set, Tuple, Optional
from dataclasses import dataclass
from collections import defaultdict, deque
from enum import Enum

class GraphType(Enum):
    """图类型"""
    UNDIRECTED = "undirected"
    DIRECTED = "directed"
    WEIGHTED = "weighted"

@dataclass
class Edge:
    """边定义"""
    source: Any
    target: Any
    weight: Optional[float] = None
    
    def __post_init__(self):
        if self.weight is None:
            self.weight = 1.0

class Graph:
    """图实现"""
    
    def __init__(self, graph_type: GraphType = GraphType.UNDIRECTED):
        self.graph_type = graph_type
        self.vertices: Set[Any] = set()
        self.edges: List[Edge] = []
        self.adjacency_list: Dict[Any, List[Edge]] = defaultdict(list)
    
    def add_vertex(self, vertex: Any) -> None:
        """添加顶点"""
        self.vertices.add(vertex)
    
    def add_edge(self, source: Any, target: Any, weight: Optional[float] = None) -> None:
        """添加边"""
        edge = Edge(source, target, weight)
        self.edges.append(edge)
        self.adjacency_list[source].append(edge)
        
        # 无向图需要添加反向边
        if self.graph_type == GraphType.UNDIRECTED:
            reverse_edge = Edge(target, source, weight)
            self.adjacency_list[target].append(reverse_edge)
    
    def get_degree(self, vertex: Any) -> int:
        """获取顶点度数"""
        return len(self.adjacency_list[vertex])
    
    def get_neighbors(self, vertex: Any) -> List[Any]:
        """获取邻居顶点"""
        return [edge.target for edge in self.adjacency_list[vertex]]
    
    def bfs(self, start: Any) -> List[Any]:
        """广度优先搜索"""
        visited = set()
        queue = deque([start])
        traversal = []
        
        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                traversal.append(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return traversal
    
    def dfs(self, start: Any) -> List[Any]:
        """深度优先搜索"""
        visited = set()
        traversal = []
        
        def dfs_recursive(vertex: Any) -> None:
            if vertex not in visited:
                visited.add(vertex)
                traversal.append(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    dfs_recursive(neighbor)
        
        dfs_recursive(start)
        return traversal
    
    def is_connected(self) -> bool:
        """判断是否连通"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        reachable = set(self.bfs(start_vertex))
        return reachable == self.vertices
    
    def shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """最短路径（Dijkstra算法）"""
        if self.graph_type != GraphType.WEIGHTED:
            # 对于无权图，使用BFS
            return self._bfs_shortest_path(start, end)
        
        # Dijkstra算法
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[start] = 0
        previous = {}
        unvisited = set(self.vertices)
        
        while unvisited:
            # 找到距离最小的未访问顶点
            current = min(unvisited, key=lambda v: distances[v])
            
            if current == end:
                break
            
            unvisited.remove(current)
            
            for edge in self.adjacency_list[current]:
                neighbor = edge.target
                if neighbor in unvisited:
                    new_distance = distances[current] + edge.weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        previous[neighbor] = current
        
        # 重建路径
        if distances[end] == float('infinity'):
            return None
        
        path = []
        current = end
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        return path[::-1]
    
    def _bfs_shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """BFS最短路径（无权图）"""
        queue = deque([(start, [start])])
        visited = set()
        
        while queue:
            vertex, path = queue.popleft()
            
            if vertex == end:
                return path
            
            if vertex not in visited:
                visited.add(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    if neighbor not in visited:
                        queue.append((neighbor, path + [neighbor]))
        
        return None

# 示例：图论应用
def graph_example():
    """图论示例"""
    # 创建无向图
    graph = Graph(GraphType.UNDIRECTED)
    
    # 添加顶点
    for i in range(6):
        graph.add_vertex(i)
    
    # 添加边
    edges = [(0, 1), (0, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5), (4, 5)]
    for source, target in edges:
        graph.add_edge(source, target)
    
    print(f"图的基本信息:")
    print(f"  顶点数: {len(graph.vertices)}")
    print(f"  边数: {len(graph.edges)}")
    print(f"  连通性: {graph.is_connected()}")
    
    print(f"\n顶点度数:")
    for vertex in sorted(graph.vertices):
        print(f"  deg({vertex}) = {graph.get_degree(vertex)}")
    
    print(f"\n遍历结果:")
    print(f"  BFS(0): {graph.bfs(0)}")
    print(f"  DFS(0): {graph.dfs(0)}")
    
    print(f"\n最短路径:")
    path = graph.shortest_path(0, 5)
    print(f"  0 -> 5: {path}")
    
    return graph

graph = graph_example()
```

### 4. 组合数学

**定义 1.5 (排列)**：
从 $n$ 个元素中取 $r$ 个元素的排列数为 $P(n, r) = \frac{n!}{(n-r)!}$。

**定义 1.6 (组合)**：
从 $n$ 个元素中取 $r$ 个元素的组合数为 $C(n, r) = \frac{n!}{r!(n-r)!}$。

**Python实现**：

```python
from typing import List, Iterator, Tuple
from itertools import permutations, combinations
import math

class Combinatorics:
    """组合数学"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """阶乘"""
        if n < 0:
            raise ValueError("Factorial not defined for negative numbers")
        if n == 0 or n == 1:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation_count(n: int, r: int) -> int:
        """排列数 P(n, r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination_count(n: int, r: int) -> int:
        """组合数 C(n, r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def generate_permutations(elements: List[Any], r: Optional[int] = None) -> Iterator[Tuple[Any, ...]]:
        """生成排列"""
        if r is None:
            r = len(elements)
        return permutations(elements, r)
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> Iterator[Tuple[Any, ...]]:
        """生成组合"""
        return combinations(elements, r)
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """卡特兰数 C_n = (1/(n+1)) * C(2n, n)"""
        if n < 0:
            return 0
        if n == 0:
            return 1
        return Combinatorics.combination_count(2*n, n) // (n + 1)
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """斐波那契数"""
        if n <= 0:
            return 0
        if n == 1:
            return 1
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    
    @staticmethod
    def stirling_number_second(n: int, k: int) -> int:
        """第二类斯特林数 S(n, k)"""
        if k == 0:
            return 1 if n == 0 else 0
        if k == 1:
            return 1
        if k == n:
            return 1
        if k > n:
            return 0
        
        # 递归公式：S(n, k) = k * S(n-1, k) + S(n-1, k-1)
        return k * Combinatorics.stirling_number_second(n-1, k) + Combinatorics.stirling_number_second(n-1, k-1)

# 示例：组合数学应用
def combinatorics_example():
    """组合数学示例"""
    elements = ['A', 'B', 'C', 'D']
    
    print(f"组合数学示例:")
    print(f"  元素集: {elements}")
    
    # 排列和组合数
    n, r = 4, 2
    print(f"  P({n}, {r}) = {Combinatorics.permutation_count(n, r)}")
    print(f"  C({n}, {r}) = {Combinatorics.combination_count(n, r)}")
    
    # 生成排列
    print(f"  排列 P({n}, {r}):")
    for perm in Combinatorics.generate_permutations(elements, r):
        print(f"    {perm}")
    
    # 生成组合
    print(f"  组合 C({n}, {r}):")
    for comb in Combinatorics.generate_combinations(elements, r):
        print(f"    {comb}")
    
    # 特殊数列
    print(f"  卡特兰数 C_4 = {Combinatorics.catalan_number(4)}")
    print(f"  斐波那契数 F_10 = {Combinatorics.fibonacci_number(10)}")
    print(f"  第二类斯特林数 S(4, 2) = {Combinatorics.stirling_number_second(4, 2)}")
    
    return elements

combo_elements = combinatorics_example()
```

## 🔗 相关链接

- [01.02 逻辑学](./01.02-逻辑学.md)
- [01.03 形式化方法](./01.03-形式化方法.md)
- [01.04 集合论与关系](./01.04-集合论与关系.md)
- [02.01 算法理论](../02-理论基础/02.01-算法理论.md)
- [02.02 数据结构](../02-理论基础/02.02-数据结构.md)

---

**最后更新**: 2024-01-XX  
**版本**: 1.0.0  
**维护者**: AI Assistant
