# 01.01 数学基础

## 📖 概述

数学基础为软件工程和计算科学提供了形式化的语言和推理工具。本章涵盖集合论、逻辑、代数、图论等核心数学概念，为后续的理论基础提供数学支撑。

## 🎯 核心概念

### 1. 集合论基础

**定义**：集合是不同对象的无序聚集。

**形式化表示**：
设 $A$ 为集合，$x$ 为元素，则：

- $x \in A$ 表示 $x$ 属于 $A$
- $A \subseteq B$ 表示 $A$ 是 $B$ 的子集
- $A \cup B$ 表示 $A$ 和 $B$ 的并集
- $A \cap B$ 表示 $A$ 和 $B$ 的交集

**Python实现**：

```python
from typing import Set, List, Any, Iterator
from abc import ABC, abstractmethod
import itertools

class SetTheory:
    """集合论实现"""
    
    @staticmethod
    def is_subset(A: Set[Any], B: Set[Any]) -> bool:
        """检查 A 是否是 B 的子集"""
        return A.issubset(B)
    
    @staticmethod
    def is_proper_subset(A: Set[Any], B: Set[Any]) -> bool:
        """检查 A 是否是 B 的真子集"""
        return A.issubset(B) and A != B
    
    @staticmethod
    def union(*sets: Set[Any]) -> Set[Any]:
        """多个集合的并集"""
        result = set()
        for s in sets:
            result.update(s)
        return result
    
    @staticmethod
    def intersection(*sets: Set[Any]) -> Set[Any]:
        """多个集合的交集"""
        if not sets:
            return set()
        result = sets[0].copy()
        for s in sets[1:]:
            result.intersection_update(s)
        return result
    
    @staticmethod
    def difference(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """集合差集 A - B"""
        return A - B
    
    @staticmethod
    def symmetric_difference(A: Set[Any], B: Set[Any]) -> Set[Any]:
        """对称差集 A △ B"""
        return A.symmetric_difference(B)
    
    @staticmethod
    def cartesian_product(*sets: Set[Any]) -> Set[tuple]:
        """笛卡尔积"""
        return set(itertools.product(*sets))
    
    @staticmethod
    def power_set(A: Set[Any]) -> Set[frozenset]:
        """幂集 P(A)"""
        elements = list(A)
        power_set = set()
        
        for i in range(2**len(elements)):
            subset = set()
            for j in range(len(elements)):
                if i & (1 << j):
                    subset.add(elements[j])
            power_set.add(frozenset(subset))
        
        return power_set

class InfiniteSet(ABC):
    """无限集合抽象基类"""
    
    @abstractmethod
    def contains(self, element: Any) -> bool:
        """检查元素是否属于集合"""
        pass
    
    @abstractmethod
    def __iter__(self) -> Iterator[Any]:
        """迭代集合元素"""
        pass

class NaturalNumbers(InfiniteSet):
    """自然数集合"""
    
    def contains(self, element: Any) -> bool:
        return isinstance(element, int) and element >= 0
    
    def __iter__(self) -> Iterator[int]:
        n = 0
        while True:
            yield n
            n += 1

# 示例：集合论操作
def demonstrate_set_theory():
    """演示集合论操作"""
    
    A = {1, 2, 3, 4, 5}
    B = {4, 5, 6, 7, 8}
    C = {1, 2, 3}
    
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"C = {C}")
    
    # 基本操作
    print(f"A ∪ B = {SetTheory.union(A, B)}")
    print(f"A ∩ B = {SetTheory.intersection(A, B)}")
    print(f"A - B = {SetTheory.difference(A, B)}")
    print(f"A △ B = {SetTheory.symmetric_difference(A, B)}")
    
    # 子集关系
    print(f"C ⊆ A: {SetTheory.is_subset(C, A)}")
    print(f"C ⊂ A: {SetTheory.is_proper_subset(C, A)}")
    
    # 笛卡尔积
    cartesian = SetTheory.cartesian_product(A, B)
    print(f"A × B 的前5个元素: {list(cartesian)[:5]}")
    
    # 幂集
    power_set = SetTheory.power_set(C)
    print(f"P(C) = {power_set}")

# 执行演示
demonstrate_set_theory()
```

### 2. 逻辑基础

**定义**：逻辑研究命题和推理。

**核心概念**：

- **命题**：陈述句，有真假之分
- **逻辑连接词**：¬, ∧, ∨, →, ↔
- **真值表**：列出所有可能的命题组合及其真值

**Python实现**：

```python
from enum import Enum
from typing import Dict, List, Set

class TruthValue(Enum):
    """真值枚举"""
    TRUE = True
    FALSE = False

class PropositionalLogic:
    """命题逻辑的形式化实现"""
    
    @staticmethod
    def negation(p: bool) -> bool:
        """否定: ¬p"""
        return not p
    
    @staticmethod
    def conjunction(p: bool, q: bool) -> bool:
        """合取: p ∧ q"""
        return p and q
    
    @staticmethod
    def disjunction(p: bool, q: bool) -> bool:
        """析取: p ∨ q"""
        return p or q
    
    @staticmethod
    def implication(p: bool, q: bool) -> bool:
        """蕴含: p → q"""
        return not p or q
    
    @staticmethod
    def equivalence(p: bool, q: bool) -> bool:
        """等价: p ↔ q"""
        return p == q
    
    @staticmethod
    def truth_table(proposition: str, variables: List[str]) -> Dict[tuple, bool]:
        """生成真值表"""
        from itertools import product
        
        truth_table = {}
        for values in product([True, False], repeat=len(variables)):
            assignment = dict(zip(variables, values))
            result = PropositionalLogic.evaluate(proposition, assignment)
            truth_table[values] = result
        
        return truth_table
    
    @staticmethod
    def evaluate(proposition: str, assignment: Dict[str, bool]) -> bool:
        """评估命题在给定赋值下的真值"""
        # 简化示例，实际实现需要完整的解析器
        if proposition == "p":
            return assignment.get("p", False)
        elif proposition == "q":
            return assignment.get("q", False)
        elif "¬" in proposition:
            return not PropositionalLogic.evaluate(proposition[1:], assignment)
        elif "∧" in proposition:
            parts = proposition.split("∧")
            return all(PropositionalLogic.evaluate(part.strip(), assignment) 
                      for part in parts)
        elif "∨" in proposition:
            parts = proposition.split("∨")
            return any(PropositionalLogic.evaluate(part.strip(), assignment) 
                      for part in parts)
        elif "→" in proposition:
            antecedent, consequent = proposition.split("→")
            p = PropositionalLogic.evaluate(antecedent.strip(), assignment)
            q = PropositionalLogic.evaluate(consequent.strip(), assignment)
            return PropositionalLogic.implication(p, q)
        else:
            return assignment.get(proposition, False)

# 示例：命题逻辑
print("命题逻辑示例:")
print(f"¬True = {PropositionalLogic.negation(True)}")
print(f"True ∧ False = {PropositionalLogic.conjunction(True, False)}")
print(f"True ∨ False = {PropositionalLogic.disjunction(True, False)}")
print(f"True → False = {PropositionalLogic.implication(True, False)}")
print(f"True ↔ True = {PropositionalLogic.equivalence(True, True)}")

# 真值表示例
truth_table = PropositionalLogic.truth_table("p∧q", ["p", "q"])
print(f"p∧q 的真值表: {truth_table}")
```

### 3. 代数基础

**定义**：代数研究运算和运算律。

**核心概念**：

- **群**：满足结合律、有单位元、有逆元的代数结构
- **环**：具有两种运算的代数结构
- **域**：可除环

**Python实现**：

```python
from typing import Any, Dict, Optional
from abc import ABC, abstractmethod
from dataclasses import dataclass

@dataclass
class GroupElement:
    """群元素"""
    value: Any
    group: 'Group' = None
    
    def __mul__(self, other: 'GroupElement') -> 'GroupElement':
        """群运算"""
        if self.group != other.group:
            raise ValueError("不同群的元素不能运算")
        return self.group.operation(self, other)
    
    def __eq__(self, other: 'GroupElement') -> bool:
        return self.value == other.value and self.group == other.group

class Group(ABC):
    """群抽象基类"""
    
    def __init__(self, elements: List[Any]):
        self.elements = [GroupElement(e, self) for e in elements]
        self.identity = self._find_identity()
    
    @abstractmethod
    def operation(self, a: GroupElement, b: GroupElement) -> GroupElement:
        """群运算"""
        pass
    
    def _find_identity(self) -> GroupElement:
        """找到单位元"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if self.operation(e, a) != a or self.operation(a, e) != a:
                    is_identity = False
                    break
            if is_identity:
                return e
        raise ValueError("群中没有单位元")
    
    def inverse(self, element: GroupElement) -> GroupElement:
        """求逆元"""
        for e in self.elements:
            if (self.operation(element, e) == self.identity and 
                self.operation(e, element) == self.identity):
                return e
        raise ValueError("元素没有逆元")
    
    def is_abelian(self) -> bool:
        """检查是否为阿贝尔群"""
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) != self.operation(b, a):
                    return False
        return True

class ModularGroup(Group):
    """模n加法群"""
    
    def __init__(self, n: int):
        self.modulus = n
        elements = list(range(n))
        super().__init__(elements)
    
    def operation(self, a: GroupElement, b: GroupElement) -> GroupElement:
        result = (a.value + b.value) % self.modulus
        return GroupElement(result, self)

class Ring(ABC):
    """环抽象基类"""
    
    def __init__(self, elements: List[Any]):
        self.elements = elements
        self.additive_identity = self._find_additive_identity()
        self.multiplicative_identity = self._find_multiplicative_identity()
    
    @abstractmethod
    def add(self, a: Any, b: Any) -> Any:
        """加法运算"""
        pass
    
    @abstractmethod
    def multiply(self, a: Any, b: Any) -> Any:
        """乘法运算"""
        pass
    
    def _find_additive_identity(self) -> Any:
        """找到加法单位元"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if self.add(e, a) != a or self.add(a, e) != a:
                    is_identity = False
                    break
            if is_identity:
                return e
        raise ValueError("环中没有加法单位元")
    
    def _find_multiplicative_identity(self) -> Any:
        """找到乘法单位元"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if self.multiply(e, a) != a or self.multiply(a, e) != a:
                    is_identity = False
                    break
            if is_identity:
                return e
        return None  # 环可能没有乘法单位元

class ModularRing(Ring):
    """模n环"""
    
    def __init__(self, n: int):
        self.modulus = n
        elements = list(range(n))
        super().__init__(elements)
    
    def add(self, a: int, b: int) -> int:
        return (a + b) % self.modulus
    
    def multiply(self, a: int, b: int) -> int:
        return (a * b) % self.modulus

# 示例：代数结构
def demonstrate_algebra():
    """演示代数结构"""
    
    # 模5加法群
    group = ModularGroup(5)
    print(f"模5加法群:")
    print(f"元素: {[e.value for e in group.elements]}")
    print(f"单位元: {group.identity.value}")
    print(f"是阿贝尔群: {group.is_abelian()}")
    
    # 群运算
    a = GroupElement(2, group)
    b = GroupElement(3, group)
    c = a * b
    print(f"{a.value} + {b.value} = {c.value} (mod 5)")
    
    # 逆元
    a_inv = group.inverse(a)
    print(f"{a.value} 的逆元: {a_inv.value}")
    
    # 模5环
    ring = ModularRing(5)
    print(f"\n模5环:")
    print(f"加法单位元: {ring.additive_identity}")
    print(f"乘法单位元: {ring.multiplicative_identity}")
    
    # 环运算
    result_add = ring.add(3, 4)
    result_mul = ring.multiply(3, 4)
    print(f"3 + 4 = {result_add} (mod 5)")
    print(f"3 × 4 = {result_mul} (mod 5)")

# 执行演示
demonstrate_algebra()
```

### 4. 分析基础

**定义**：分析研究极限、连续性、微分和积分。

**核心概念**：

- **极限**：$\lim_{x \to a} f(x) = L$
- **连续性**：函数在某点的连续性
- **导数**：$f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h}$

**Python实现**：

```python
import numpy as np
from typing import Callable, Optional, Tuple
from scipy.misc import derivative

class MathematicalAnalysis:
    """数学分析实现"""
    
    @staticmethod
    def limit(f: Callable[[float], float], a: float, 
              tolerance: float = 1e-10, max_iterations: int = 1000) -> Optional[float]:
        """数值方法计算极限"""
        h_values = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6, 1e-7, 1e-8, 1e-9, 1e-10]
        
        for h in h_values:
            try:
                value = f(a + h)
                if abs(value) < tolerance:
                    return 0
                return value
            except (ZeroDivisionError, ValueError):
                continue
        
        return None
    
    @staticmethod
    def is_continuous(f: Callable[[float], float], a: float, 
                     tolerance: float = 1e-10) -> bool:
        """检查函数在点a的连续性"""
        try:
            f_a = f(a)
            
            # 检查左极限
            left_limit = MathematicalAnalysis.limit(lambda x: f(x), a, tolerance)
            
            # 检查右极限
            right_limit = MathematicalAnalysis.limit(lambda x: f(x), a, tolerance)
            
            # 检查极限是否存在且等于函数值
            if left_limit is not None and right_limit is not None:
                return abs(left_limit - f_a) < tolerance and abs(right_limit - f_a) < tolerance
            
            return False
        except:
            return False
    
    @staticmethod
    def derivative(f: Callable[[float], float], x: float, 
                  h: float = 1e-8) -> float:
        """数值微分"""
        return (f(x + h) - f(x - h)) / (2 * h)
    
    @staticmethod
    def integral(f: Callable[[float], float], a: float, b: float, 
                n: int = 1000) -> float:
        """数值积分（梯形法则）"""
        h = (b - a) / n
        x = np.linspace(a, b, n + 1)
        y = [f(xi) for xi in x]
        
        return h * (0.5 * y[0] + sum(y[1:-1]) + 0.5 * y[-1])
    
    @staticmethod
    def taylor_series(f: Callable[[float], float], a: float, 
                     degree: int, x: float) -> float:
        """泰勒级数展开"""
        result = 0
        for n in range(degree + 1):
            # 计算n阶导数
            if n == 0:
                derivative_n = f(a)
            else:
                derivative_n = MathematicalAnalysis.derivative(
                    lambda x: MathematicalAnalysis.derivative(f, x, 1e-8), a, 1e-8
                )
            
            result += derivative_n * (x - a)**n / math.factorial(n)
        
        return result

class Function:
    """函数类"""
    
    def __init__(self, f: Callable[[float], float], domain: Tuple[float, float] = None):
        self.f = f
        self.domain = domain
    
    def __call__(self, x: float) -> float:
        return self.f(x)
    
    def compose(self, g: 'Function') -> 'Function':
        """函数复合"""
        return Function(lambda x: self.f(g(x)))
    
    def inverse(self, y: float, tolerance: float = 1e-10) -> Optional[float]:
        """数值方法求逆函数"""
        if self.domain is None:
            return None
        
        a, b = self.domain
        
        # 二分法求根
        while b - a > tolerance:
            c = (a + b) / 2
            if self.f(c) < y:
                a = c
            else:
                b = c
        
        return (a + b) / 2

# 示例：数学分析
def demonstrate_analysis():
    """演示数学分析"""
    
    # 定义函数
    def f(x: float) -> float:
        return x**2 + 2*x + 1
    
    def g(x: float) -> float:
        return np.sin(x)
    
    # 极限
    limit_result = MathematicalAnalysis.limit(f, 2)
    print(f"lim(x→2) x² + 2x + 1 = {limit_result}")
    
    # 连续性
    is_cont = MathematicalAnalysis.is_continuous(f, 2)
    print(f"f(x) 在 x=2 处连续: {is_cont}")
    
    # 导数
    derivative_result = MathematicalAnalysis.derivative(f, 2)
    print(f"f'(2) = {derivative_result}")
    
    # 积分
    integral_result = MathematicalAnalysis.integral(f, 0, 2)
    print(f"∫₀² (x² + 2x + 1) dx = {integral_result}")
    
    # 泰勒级数
    taylor_result = MathematicalAnalysis.taylor_series(g, 0, 3, 0.5)
    print(f"sin(0.5) 的3阶泰勒展开: {taylor_result}")
    
    # 函数对象
    func = Function(f, (0, 10))
    print(f"f(3) = {func(3)}")
    
    # 函数复合
    func_g = Function(g)
    composed = func.compose(func_g)
    print(f"(f∘g)(1) = {composed(1)}")

# 执行演示
demonstrate_analysis()
```

### 5. 离散数学

**定义**：离散数学研究离散对象和结构。

**核心概念**：

- **组合数学**：排列、组合、生成函数
- **图论**：图、路径、连通性
- **逻辑**：命题逻辑、谓词逻辑

**Python实现**：

```python
import itertools
from typing import List, Set, Tuple, Dict, Any
from collections import defaultdict

class Combinatorics:
    """组合数学"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """阶乘"""
        if n < 0:
            raise ValueError("负数没有阶乘")
        if n == 0:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation(n: int, r: int) -> int:
        """排列数 P(n,r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination(n: int, r: int) -> int:
        """组合数 C(n,r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def generate_permutations(elements: List[Any]) -> List[Tuple[Any, ...]]:
        """生成所有排列"""
        return list(itertools.permutations(elements))
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> List[Tuple[Any, ...]]:
        """生成所有r组合"""
        return list(itertools.combinations(elements, r))
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """卡特兰数"""
        if n <= 1:
            return 1
        
        result = 0
        for i in range(n):
            result += Combinatorics.catalan_number(i) * Combinatorics.catalan_number(n - 1 - i)
        
        return result
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """斐波那契数"""
        if n <= 1:
            return n
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        
        return b

class Graph:
    """图类"""
    
    def __init__(self, directed: bool = False):
        self.directed = directed
        self.vertices: Set[Any] = set()
        self.edges: List[Tuple[Any, Any]] = []
        self.adjacency_list: Dict[Any, Set[Any]] = defaultdict(set)
    
    def add_vertex(self, vertex: Any):
        """添加顶点"""
        self.vertices.add(vertex)
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = set()
    
    def add_edge(self, u: Any, v: Any):
        """添加边"""
        self.add_vertex(u)
        self.add_vertex(v)
        
        self.edges.append((u, v))
        self.adjacency_list[u].add(v)
        
        if not self.directed:
            self.adjacency_list[v].add(u)
    
    def remove_edge(self, u: Any, v: Any):
        """删除边"""
        if (u, v) in self.edges:
            self.edges.remove((u, v))
            self.adjacency_list[u].discard(v)
            
            if not self.directed:
                self.adjacency_list[v].discard(u)
    
    def get_neighbors(self, vertex: Any) -> Set[Any]:
        """获取邻居"""
        return self.adjacency_list.get(vertex, set())
    
    def degree(self, vertex: Any) -> int:
        """度数"""
        return len(self.get_neighbors(vertex))
    
    def is_connected(self) -> bool:
        """检查连通性"""
        if not self.vertices:
            return True
        
        visited = set()
        start_vertex = next(iter(self.vertices))
        
        def dfs(vertex: Any):
            visited.add(vertex)
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    dfs(neighbor)
        
        dfs(start_vertex)
        return len(visited) == len(self.vertices)
    
    def shortest_path(self, start: Any, end: Any) -> List[Any]:
        """最短路径（BFS）"""
        if start not in self.vertices or end not in self.vertices:
            return []
        
        queue = [(start, [start])]
        visited = {start}
        
        while queue:
            vertex, path = queue.pop(0)
            
            if vertex == end:
                return path
            
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return []  # 没有路径
    
    def has_cycle(self) -> bool:
        """检测环"""
        visited = set()
        rec_stack = set()
        
        def dfs(vertex: Any) -> bool:
            visited.add(vertex)
            rec_stack.add(vertex)
            
            for neighbor in self.get_neighbors(vertex):
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(vertex)
            return False
        
        for vertex in self.vertices:
            if vertex not in visited:
                if dfs(vertex):
                    return True
        
        return False

class PropositionalLogic:
    """命题逻辑"""
    
    @staticmethod
    def truth_table(expression: str, variables: List[str]) -> List[Dict[str, bool]]:
        """生成真值表"""
        table = []
        n = len(variables)
        
        for i in range(2**n):
            assignment = {}
            for j, var in enumerate(variables):
                assignment[var] = bool(i & (1 << j))
            
            # 这里简化处理，实际需要解析表达式
            table.append(assignment)
        
        return table
    
    @staticmethod
    def is_tautology(expression: str, variables: List[str]) -> bool:
        """检查是否为重言式"""
        table = PropositionalLogic.truth_table(expression, variables)
        # 简化实现，实际需要计算表达式的值
        return True
    
    @staticmethod
    def is_contradiction(expression: str, variables: List[str]) -> bool:
        """检查是否为矛盾式"""
        table = PropositionalLogic.truth_table(expression, variables)
        # 简化实现，实际需要计算表达式的值
        return False

# 示例：离散数学
def demonstrate_discrete_math():
    """演示离散数学"""
    
    # 组合数学
    n, r = 5, 3
    print(f"P({n},{r}) = {Combinatorics.permutation(n, r)}")
    print(f"C({n},{r}) = {Combinatorics.combination(n, r)}")
    
    elements = ['A', 'B', 'C']
    permutations = Combinatorics.generate_permutations(elements)
    print(f"所有排列: {permutations}")
    
    combinations = Combinatorics.generate_combinations(elements, 2)
    print(f"所有2组合: {combinations}")
    
    print(f"第5个卡特兰数: {Combinatorics.catalan_number(5)}")
    print(f"第10个斐波那契数: {Combinatorics.fibonacci_number(10)}")
    
    # 图论
    graph = Graph(directed=False)
    graph.add_edge('A', 'B')
    graph.add_edge('B', 'C')
    graph.add_edge('C', 'D')
    graph.add_edge('D', 'A')
    
    print(f"\n图:")
    print(f"顶点: {graph.vertices}")
    print(f"边: {graph.edges}")
    print(f"连通: {graph.is_connected()}")
    print(f"有环: {graph.has_cycle()}")
    
    path = graph.shortest_path('A', 'C')
    print(f"A到C的最短路径: {path}")
    
    # 命题逻辑
    variables = ['p', 'q']
    table = PropositionalLogic.truth_table("p AND q", variables)
    print(f"\n真值表: {table}")

# 执行演示
demonstrate_discrete_math()
```

## 🔗 相关链接

- [01.02 逻辑学](./01.02-逻辑学.md)
- [01.03 集合论](./01.03-集合论.md)
- [01.04 图论](./01.04-图论.md)
- [02.01 计算理论](../02-理论基础/02.01-计算理论.md)

## 📚 参考文献

1. Rudin, W. (1976). Principles of mathematical analysis. McGraw-Hill.
2. Hardy, G. H., & Wright, E. M. (1979). An introduction to the theory of numbers. Oxford University Press.
3. Dummit, D. S., & Foote, R. M. (2004). Abstract algebra. John Wiley & Sons.

---

**最后更新**: 2024年12月
**版本**: v1.0.0
