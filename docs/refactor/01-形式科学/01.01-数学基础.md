# 01.01 æ•°å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°å­¦åŸºç¡€æ˜¯è½¯ä»¶å·¥ç¨‹çš„å½¢å¼ç§‘å­¦åŸºç¡€ï¼Œä¸ºç®—æ³•è®¾è®¡ã€æ•°æ®ç»“æ„ã€å¤æ‚åº¦åˆ†æç­‰æä¾›ç†è®ºæ”¯æ’‘ã€‚æœ¬æ–‡æ¡£æ¶µç›–è½¯ä»¶å·¥ç¨‹ä¸­å¸¸ç”¨çš„æ•°å­¦æ¦‚å¿µã€å®šç†å’Œè¯æ˜ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆè®ºåŸºç¡€

**å®šä¹‰ 1.1 (é›†åˆ)**ï¼š
é›†åˆæ˜¯ä¸åŒå¯¹è±¡çš„æ— åºèšé›†ï¼Œè®°ä½œ $A = \{a_1, a_2, ..., a_n\}$ã€‚

**åŸºæœ¬è¿ç®—**ï¼š
- å¹¶é›†ï¼š$A \cup B = \{x | x \in A \text{ æˆ– } x \in B\}$
- äº¤é›†ï¼š$A \cap B = \{x | x \in A \text{ ä¸” } x \in B\}$
- å·®é›†ï¼š$A - B = \{x | x \in A \text{ ä¸” } x \notin B\}$
- è¡¥é›†ï¼š$\overline{A} = \{x | x \notin A\}$

**Pythonå®ç°**ï¼š

```python
from typing import Set, TypeVar, Generic, Iterator
from abc import ABC, abstractmethod
from dataclasses import dataclass

T = TypeVar('T')

class SetTheory:
    """é›†åˆè®ºå®ç°"""
    
    @staticmethod
    def union(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """å¹¶é›†è¿ç®—"""
        return set_a | set_b
    
    @staticmethod
    def intersection(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """äº¤é›†è¿ç®—"""
        return set_a & set_b
    
    @staticmethod
    def difference(set_a: Set[T], set_b: Set[T]) -> Set[T]:
        """å·®é›†è¿ç®—"""
        return set_a - set_b
    
    @staticmethod
    def complement(universal_set: Set[T], set_a: Set[T]) -> Set[T]:
        """è¡¥é›†è¿ç®—"""
        return universal_set - set_a
    
    @staticmethod
    def is_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """åˆ¤æ–­å­é›†å…³ç³»"""
        return set_a.issubset(set_b)
    
    @staticmethod
    def is_proper_subset(set_a: Set[T], set_b: Set[T]) -> bool:
        """åˆ¤æ–­çœŸå­é›†å…³ç³»"""
        return set_a.issubset(set_b) and set_a != set_b
    
    @staticmethod
    def power_set(set_a: Set[T]) -> Set[Set[T]]:
        """å¹‚é›†è¿ç®—"""
        from itertools import combinations
        
        elements = list(set_a)
        power_set = set()
        
        for i in range(len(elements) + 1):
            for combo in combinations(elements, i):
                power_set.add(frozenset(combo))
        
        return power_set

# ç¤ºä¾‹ï¼šé›†åˆè¿ç®—
def set_operations_example():
    """é›†åˆè¿ç®—ç¤ºä¾‹"""
    A = {1, 2, 3, 4, 5}
    B = {4, 5, 6, 7, 8}
    universal = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    print(f"é›†åˆ A: {A}")
    print(f"é›†åˆ B: {B}")
    print(f"å¹¶é›† A âˆª B: {SetTheory.union(A, B)}")
    print(f"äº¤é›† A âˆ© B: {SetTheory.intersection(A, B)}")
    print(f"å·®é›† A - B: {SetTheory.difference(A, B)}")
    print(f"è¡¥é›† AÌ…: {SetTheory.complement(universal, A)}")
    print(f"A æ˜¯ B çš„å­é›†: {SetTheory.is_subset(A, B)}")
    
    # å¹‚é›†ç¤ºä¾‹ï¼ˆå°é›†åˆï¼‰
    small_set = {1, 2}
    power_set = SetTheory.power_set(small_set)
    print(f"é›†åˆ {small_set} çš„å¹‚é›†: {power_set}")
    
    return A, B

set_a, set_b = set_operations_example()
```

### 2. å…³ç³»ä¸å‡½æ•°

**å®šä¹‰ 1.2 (å…³ç³»)**ï¼š
ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„å…³ç³»æ˜¯ $A \times B$ çš„å­é›†ï¼Œè®°ä½œ $R \subseteq A \times B$ã€‚

**å®šä¹‰ 1.3 (å‡½æ•°)**ï¼š
å‡½æ•°æ˜¯ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„ç‰¹æ®Šå…³ç³»ï¼Œæ»¡è¶³ï¼š
1. å®šä¹‰åŸŸè¦†ç›–ï¼š$\forall a \in A, \exists b \in B: (a, b) \in f$
2. å•å€¼æ€§ï¼š$(a, b_1) \in f \land (a, b_2) \in f \Rightarrow b_1 = b_2$

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Tuple, Any, Callable, Optional
from dataclasses import dataclass
from enum import Enum

class RelationType(Enum):
    """å…³ç³»ç±»å‹"""
    REFLEXIVE = "reflexive"
    SYMMETRIC = "symmetric"
    TRANSITIVE = "transitive"
    EQUIVALENCE = "equivalence"
    PARTIAL_ORDER = "partial_order"

@dataclass
class Relation:
    """å…³ç³»å®šä¹‰"""
    domain: Set[Any]
    codomain: Set[Any]
    pairs: Set[Tuple[Any, Any]]
    
    def is_function(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå‡½æ•°"""
        # æ£€æŸ¥å®šä¹‰åŸŸè¦†ç›–
        domain_elements = {pair[0] for pair in self.pairs}
        if domain_elements != self.domain:
            return False
        
        # æ£€æŸ¥å•å€¼æ€§
        domain_to_codomain = {}
        for pair in self.pairs:
            if pair[0] in domain_to_codomain:
                if domain_to_codomain[pair[0]] != pair[1]:
                    return False
            else:
                domain_to_codomain[pair[0]] = pair[1]
        
        return True
    
    def is_reflexive(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦è‡ªå"""
        for element in self.domain:
            if (element, element) not in self.pairs:
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦å¯¹ç§°"""
        for pair in self.pairs:
            if (pair[1], pair[0]) not in self.pairs:
                return False
        return True
    
    def is_transitive(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¼ é€’"""
        for pair1 in self.pairs:
            for pair2 in self.pairs:
                if pair1[1] == pair2[0]:
                    if (pair1[0], pair2[1]) not in self.pairs:
                        return False
        return True
    
    def is_equivalence(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç­‰ä»·å…³ç³»"""
        return (self.is_reflexive() and 
                self.is_symmetric() and 
                self.is_transitive())
    
    def equivalence_classes(self) -> List[Set[Any]]:
        """è®¡ç®—ç­‰ä»·ç±»"""
        if not self.is_equivalence():
            raise ValueError("å…³ç³»å¿…é¡»æ˜¯ç­‰ä»·å…³ç³»")
        
        classes = []
        processed = set()
        
        for element in self.domain:
            if element in processed:
                continue
            
            # æ‰¾åˆ°åŒ…å«elementçš„ç­‰ä»·ç±»
            equivalence_class = {element}
            for pair in self.pairs:
                if pair[0] == element:
                    equivalence_class.add(pair[1])
                elif pair[1] == element:
                    equivalence_class.add(pair[0])
            
            classes.append(equivalence_class)
            processed.update(equivalence_class)
        
        return classes

class Function:
    """å‡½æ•°å®šä¹‰"""
    
    def __init__(self, domain: Set[Any], codomain: Set[Any], mapping: Dict[Any, Any]):
        self.domain = domain
        self.codomain = codomain
        self.mapping = mapping
        
        # éªŒè¯å‡½æ•°æ€§è´¨
        if not self._is_valid_function():
            raise ValueError("Invalid function definition")
    
    def _is_valid_function(self) -> bool:
        """éªŒè¯å‡½æ•°å®šä¹‰çš„æœ‰æ•ˆæ€§"""
        # æ£€æŸ¥å®šä¹‰åŸŸè¦†ç›–
        if set(self.mapping.keys()) != self.domain:
            return False
        
        # æ£€æŸ¥å€¼åŸŸåŒ…å«
        if not set(self.mapping.values()).issubset(self.codomain):
            return False
        
        return True
    
    def apply(self, x: Any) -> Any:
        """åº”ç”¨å‡½æ•°"""
        if x not in self.domain:
            raise ValueError(f"Element {x} not in domain")
        return self.mapping[x]
    
    def compose(self, other: 'Function') -> 'Function':
        """å‡½æ•°å¤åˆ"""
        if self.codomain != other.domain:
            raise ValueError("Codomain of first function must equal domain of second")
        
        new_mapping = {}
        for x in self.domain:
            new_mapping[x] = other.apply(self.apply(x))
        
        return Function(self.domain, other.codomain, new_mapping)
    
    def is_injective(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå•å°„"""
        return len(self.mapping.values()) == len(set(self.mapping.values()))
    
    def is_surjective(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡å°„"""
        return set(self.mapping.values()) == self.codomain
    
    def is_bijective(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºåŒå°„"""
        return self.is_injective() and self.is_surjective()

# ç¤ºä¾‹ï¼šå…³ç³»å’Œå‡½æ•°
def relation_function_example():
    """å…³ç³»å’Œå‡½æ•°ç¤ºä¾‹"""
    # å…³ç³»ç¤ºä¾‹ï¼šæ¨¡3åŒä½™å…³ç³»
    domain = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    codomain = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    
    # æ¨¡3åŒä½™å…³ç³»ï¼ša â‰¡ b (mod 3)
    pairs = set()
    for a in domain:
        for b in codomain:
            if a % 3 == b % 3:
                pairs.add((a, b))
    
    relation = Relation(domain, codomain, pairs)
    
    print(f"å…³ç³»æ€§è´¨:")
    print(f"  è‡ªåæ€§: {relation.is_reflexive()}")
    print(f"  å¯¹ç§°æ€§: {relation.is_symmetric()}")
    print(f"  ä¼ é€’æ€§: {relation.is_transitive()}")
    print(f"  ç­‰ä»·å…³ç³»: {relation.is_equivalence()}")
    
    if relation.is_equivalence():
        classes = relation.equivalence_classes()
        print(f"ç­‰ä»·ç±»: {classes}")
    
    # å‡½æ•°ç¤ºä¾‹ï¼šå¹³æ–¹å‡½æ•°
    square_mapping = {x: x**2 for x in range(5)}
    square_function = Function(set(range(5)), set(range(25)), square_mapping)
    
    print(f"\nå‡½æ•°ç¤ºä¾‹:")
    print(f"  f(2) = {square_function.apply(2)}")
    print(f"  å•å°„: {square_function.is_injective()}")
    print(f"  æ»¡å°„: {square_function.is_surjective()}")
    print(f"  åŒå°„: {square_function.is_bijective()}")
    
    return relation, square_function

relation, square_func = relation_function_example()
```

### 3. å›¾è®ºåŸºç¡€

**å®šä¹‰ 1.4 (å›¾)**ï¼š
å›¾ $G = (V, E)$ ç”±é¡¶ç‚¹é›† $V$ å’Œè¾¹é›† $E$ ç»„æˆï¼Œå…¶ä¸­ $E \subseteq V \times V$ã€‚

**åŸºæœ¬æ¦‚å¿µ**ï¼š
- åº¦ï¼šé¡¶ç‚¹ $v$ çš„åº¦ $deg(v)$ æ˜¯ä¸ $v$ ç›¸é‚»çš„è¾¹æ•°
- è·¯å¾„ï¼šé¡¶ç‚¹åºåˆ— $v_1, v_2, ..., v_n$ ä½¿å¾— $(v_i, v_{i+1}) \in E$
- è¿é€šæ€§ï¼šå›¾ä¸­ä»»æ„ä¸¤é¡¶ç‚¹é—´å­˜åœ¨è·¯å¾„

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Set, Tuple, Optional
from dataclasses import dataclass
from collections import defaultdict, deque
from enum import Enum

class GraphType(Enum):
    """å›¾ç±»å‹"""
    UNDIRECTED = "undirected"
    DIRECTED = "directed"
    WEIGHTED = "weighted"

@dataclass
class Edge:
    """è¾¹å®šä¹‰"""
    source: Any
    target: Any
    weight: Optional[float] = None
    
    def __post_init__(self):
        if self.weight is None:
            self.weight = 1.0

class Graph:
    """å›¾å®ç°"""
    
    def __init__(self, graph_type: GraphType = GraphType.UNDIRECTED):
        self.graph_type = graph_type
        self.vertices: Set[Any] = set()
        self.edges: List[Edge] = []
        self.adjacency_list: Dict[Any, List[Edge]] = defaultdict(list)
    
    def add_vertex(self, vertex: Any) -> None:
        """æ·»åŠ é¡¶ç‚¹"""
        self.vertices.add(vertex)
    
    def add_edge(self, source: Any, target: Any, weight: Optional[float] = None) -> None:
        """æ·»åŠ è¾¹"""
        edge = Edge(source, target, weight)
        self.edges.append(edge)
        self.adjacency_list[source].append(edge)
        
        # æ— å‘å›¾éœ€è¦æ·»åŠ åå‘è¾¹
        if self.graph_type == GraphType.UNDIRECTED:
            reverse_edge = Edge(target, source, weight)
            self.adjacency_list[target].append(reverse_edge)
    
    def get_degree(self, vertex: Any) -> int:
        """è·å–é¡¶ç‚¹åº¦æ•°"""
        return len(self.adjacency_list[vertex])
    
    def get_neighbors(self, vertex: Any) -> List[Any]:
        """è·å–é‚»å±…é¡¶ç‚¹"""
        return [edge.target for edge in self.adjacency_list[vertex]]
    
    def bfs(self, start: Any) -> List[Any]:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        queue = deque([start])
        traversal = []
        
        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                traversal.append(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return traversal
    
    def dfs(self, start: Any) -> List[Any]:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        traversal = []
        
        def dfs_recursive(vertex: Any) -> None:
            if vertex not in visited:
                visited.add(vertex)
                traversal.append(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    dfs_recursive(neighbor)
        
        dfs_recursive(start)
        return traversal
    
    def is_connected(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦è¿é€š"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        reachable = set(self.bfs(start_vertex))
        return reachable == self.vertices
    
    def shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """æœ€çŸ­è·¯å¾„ï¼ˆDijkstraç®—æ³•ï¼‰"""
        if self.graph_type != GraphType.WEIGHTED:
            # å¯¹äºæ— æƒå›¾ï¼Œä½¿ç”¨BFS
            return self._bfs_shortest_path(start, end)
        
        # Dijkstraç®—æ³•
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[start] = 0
        previous = {}
        unvisited = set(self.vertices)
        
        while unvisited:
            # æ‰¾åˆ°è·ç¦»æœ€å°çš„æœªè®¿é—®é¡¶ç‚¹
            current = min(unvisited, key=lambda v: distances[v])
            
            if current == end:
                break
            
            unvisited.remove(current)
            
            for edge in self.adjacency_list[current]:
                neighbor = edge.target
                if neighbor in unvisited:
                    new_distance = distances[current] + edge.weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        previous[neighbor] = current
        
        # é‡å»ºè·¯å¾„
        if distances[end] == float('infinity'):
            return None
        
        path = []
        current = end
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        return path[::-1]
    
    def _bfs_shortest_path(self, start: Any, end: Any) -> Optional[List[Any]]:
        """BFSæœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰"""
        queue = deque([(start, [start])])
        visited = set()
        
        while queue:
            vertex, path = queue.popleft()
            
            if vertex == end:
                return path
            
            if vertex not in visited:
                visited.add(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    if neighbor not in visited:
                        queue.append((neighbor, path + [neighbor]))
        
        return None

# ç¤ºä¾‹ï¼šå›¾è®ºåº”ç”¨
def graph_example():
    """å›¾è®ºç¤ºä¾‹"""
    # åˆ›å»ºæ— å‘å›¾
    graph = Graph(GraphType.UNDIRECTED)
    
    # æ·»åŠ é¡¶ç‚¹
    for i in range(6):
        graph.add_vertex(i)
    
    # æ·»åŠ è¾¹
    edges = [(0, 1), (0, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5), (4, 5)]
    for source, target in edges:
        graph.add_edge(source, target)
    
    print(f"å›¾çš„åŸºæœ¬ä¿¡æ¯:")
    print(f"  é¡¶ç‚¹æ•°: {len(graph.vertices)}")
    print(f"  è¾¹æ•°: {len(graph.edges)}")
    print(f"  è¿é€šæ€§: {graph.is_connected()}")
    
    print(f"\né¡¶ç‚¹åº¦æ•°:")
    for vertex in sorted(graph.vertices):
        print(f"  deg({vertex}) = {graph.get_degree(vertex)}")
    
    print(f"\néå†ç»“æœ:")
    print(f"  BFS(0): {graph.bfs(0)}")
    print(f"  DFS(0): {graph.dfs(0)}")
    
    print(f"\næœ€çŸ­è·¯å¾„:")
    path = graph.shortest_path(0, 5)
    print(f"  0 -> 5: {path}")
    
    return graph

graph = graph_example()
```

### 4. ç»„åˆæ•°å­¦

**å®šä¹‰ 1.5 (æ’åˆ—)**ï¼š
ä» $n$ ä¸ªå…ƒç´ ä¸­å– $r$ ä¸ªå…ƒç´ çš„æ’åˆ—æ•°ä¸º $P(n, r) = \frac{n!}{(n-r)!}$ã€‚

**å®šä¹‰ 1.6 (ç»„åˆ)**ï¼š
ä» $n$ ä¸ªå…ƒç´ ä¸­å– $r$ ä¸ªå…ƒç´ çš„ç»„åˆæ•°ä¸º $C(n, r) = \frac{n!}{r!(n-r)!}$ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import List, Iterator, Tuple
from itertools import permutations, combinations
import math

class Combinatorics:
    """ç»„åˆæ•°å­¦"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """é˜¶ä¹˜"""
        if n < 0:
            raise ValueError("Factorial not defined for negative numbers")
        if n == 0 or n == 1:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation_count(n: int, r: int) -> int:
        """æ’åˆ—æ•° P(n, r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination_count(n: int, r: int) -> int:
        """ç»„åˆæ•° C(n, r)"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def generate_permutations(elements: List[Any], r: Optional[int] = None) -> Iterator[Tuple[Any, ...]]:
        """ç”Ÿæˆæ’åˆ—"""
        if r is None:
            r = len(elements)
        return permutations(elements, r)
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> Iterator[Tuple[Any, ...]]:
        """ç”Ÿæˆç»„åˆ"""
        return combinations(elements, r)
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """å¡ç‰¹å…°æ•° C_n = (1/(n+1)) * C(2n, n)"""
        if n < 0:
            return 0
        if n == 0:
            return 1
        return Combinatorics.combination_count(2*n, n) // (n + 1)
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """æ–æ³¢é‚£å¥‘æ•°"""
        if n <= 0:
            return 0
        if n == 1:
            return 1
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    
    @staticmethod
    def stirling_number_second(n: int, k: int) -> int:
        """ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° S(n, k)"""
        if k == 0:
            return 1 if n == 0 else 0
        if k == 1:
            return 1
        if k == n:
            return 1
        if k > n:
            return 0
        
        # é€’å½’å…¬å¼ï¼šS(n, k) = k * S(n-1, k) + S(n-1, k-1)
        return k * Combinatorics.stirling_number_second(n-1, k) + Combinatorics.stirling_number_second(n-1, k-1)

# ç¤ºä¾‹ï¼šç»„åˆæ•°å­¦åº”ç”¨
def combinatorics_example():
    """ç»„åˆæ•°å­¦ç¤ºä¾‹"""
    elements = ['A', 'B', 'C', 'D']
    
    print(f"ç»„åˆæ•°å­¦ç¤ºä¾‹:")
    print(f"  å…ƒç´ é›†: {elements}")
    
    # æ’åˆ—å’Œç»„åˆæ•°
    n, r = 4, 2
    print(f"  P({n}, {r}) = {Combinatorics.permutation_count(n, r)}")
    print(f"  C({n}, {r}) = {Combinatorics.combination_count(n, r)}")
    
    # ç”Ÿæˆæ’åˆ—
    print(f"  æ’åˆ— P({n}, {r}):")
    for perm in Combinatorics.generate_permutations(elements, r):
        print(f"    {perm}")
    
    # ç”Ÿæˆç»„åˆ
    print(f"  ç»„åˆ C({n}, {r}):")
    for comb in Combinatorics.generate_combinations(elements, r):
        print(f"    {comb}")
    
    # ç‰¹æ®Šæ•°åˆ—
    print(f"  å¡ç‰¹å…°æ•° C_4 = {Combinatorics.catalan_number(4)}")
    print(f"  æ–æ³¢é‚£å¥‘æ•° F_10 = {Combinatorics.fibonacci_number(10)}")
    print(f"  ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° S(4, 2) = {Combinatorics.stirling_number_second(4, 2)}")
    
    return elements

combo_elements = combinatorics_example()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [01.02 é€»è¾‘å­¦](./01.02-é€»è¾‘å­¦.md)
- [01.03 å½¢å¼åŒ–æ–¹æ³•](./01.03-å½¢å¼åŒ–æ–¹æ³•.md)
- [01.04 é›†åˆè®ºä¸å…³ç³»](./01.04-é›†åˆè®ºä¸å…³ç³».md)
- [02.01 ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02.01-ç®—æ³•ç†è®º.md)
- [02.02 æ•°æ®ç»“æ„](../02-ç†è®ºåŸºç¡€/02.02-æ•°æ®ç»“æ„.md)

---

**æœ€åæ›´æ–°**: 2024-01-XX  
**ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: AI Assistant
