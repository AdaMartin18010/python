# 01.01 æ•°å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°å­¦åŸºç¡€æ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£æä¾›æ ¸å¿ƒæ•°å­¦æ¦‚å¿µçš„å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ï¼Œä¸ºåç»­çš„ç®—æ³•ç†è®ºã€æ•°æ®ç»“æ„ç­‰æä¾›æ•°å­¦æ”¯æ’‘ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆè®ºåŸºç¡€

#### 1.1 é›†åˆçš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
é›†åˆæ˜¯ä¸€ä¸ªæ— åºçš„ã€ä¸é‡å¤çš„å…ƒç´ é›†åˆã€‚è®¾ $A$ ä¸ºé›†åˆï¼Œåˆ™ï¼š
$$A = \{x \mid P(x)\}$$
å…¶ä¸­ $P(x)$ æ˜¯å®šä¹‰é›†åˆå…ƒç´ çš„æ€§è´¨ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Set, List, Any, Callable, TypeVar, Generic
from abc import ABC, abstractmethod
from dataclasses import dataclass
import math

T = TypeVar('T')

class Set(ABC):
    """é›†åˆæŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def contains(self, element: T) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­"""
        pass
    
    @abstractmethod
    def add(self, element: T) -> None:
        """æ·»åŠ å…ƒç´ åˆ°é›†åˆ"""
        pass
    
    @abstractmethod
    def remove(self, element: T) -> None:
        """ä»é›†åˆä¸­ç§»é™¤å…ƒç´ """
        pass
    
    @abstractmethod
    def size(self) -> int:
        """è¿”å›é›†åˆå¤§å°"""
        pass
    
    @abstractmethod
    def is_empty(self) -> bool:
        """æ£€æŸ¥é›†åˆæ˜¯å¦ä¸ºç©º"""
        pass

class FiniteSet(Set[T]):
    """æœ‰é™é›†åˆå®ç°"""
    
    def __init__(self, elements: List[T] = None):
        self._elements: Set[T] = set(elements) if elements else set()
    
    def contains(self, element: T) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­"""
        return element in self._elements
    
    def add(self, element: T) -> None:
        """æ·»åŠ å…ƒç´ åˆ°é›†åˆ"""
        self._elements.add(element)
    
    def remove(self, element: T) -> None:
        """ä»é›†åˆä¸­ç§»é™¤å…ƒç´ """
        self._elements.discard(element)
    
    def size(self) -> int:
        """è¿”å›é›†åˆå¤§å°"""
        return len(self._elements)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥é›†åˆæ˜¯å¦ä¸ºç©º"""
        return len(self._elements) == 0
    
    def union(self, other: 'FiniteSet[T]') -> 'FiniteSet[T]':
        """é›†åˆå¹¶é›†"""
        return FiniteSet(list(self._elements.union(other._elements)))
    
    def intersection(self, other: 'FiniteSet[T]') -> 'FiniteSet[T]':
        """é›†åˆäº¤é›†"""
        return FiniteSet(list(self._elements.intersection(other._elements)))
    
    def difference(self, other: 'FiniteSet[T]') -> 'FiniteSet[T]':
        """é›†åˆå·®é›†"""
        return FiniteSet(list(self._elements.difference(other._elements)))
    
    def is_subset(self, other: 'FiniteSet[T]') -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå­é›†"""
        return self._elements.issubset(other._elements)
    
    def is_superset(self, other: 'FiniteSet[T]') -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºè¶…é›†"""
        return self._elements.issuperset(other._elements)
    
    def __str__(self) -> str:
        return f"{{{', '.join(map(str, self._elements))}}}"
    
    def __repr__(self) -> str:
        return f"FiniteSet({list(self._elements)})"

# ä½¿ç”¨ç¤ºä¾‹
def set_operations_example():
    """é›†åˆæ“ä½œç¤ºä¾‹"""
    # åˆ›å»ºé›†åˆ
    A = FiniteSet([1, 2, 3, 4, 5])
    B = FiniteSet([4, 5, 6, 7, 8])
    
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"A âˆª B = {A.union(B)}")
    print(f"A âˆ© B = {A.intersection(B)}")
    print(f"A - B = {A.difference(B)}")
    print(f"A âŠ† B: {A.is_subset(B)}")
    print(f"|A| = {A.size()}")
    
    return A, B

#### 1.2 é›†åˆçš„åŸºæ•°

**æ•°å­¦å®šä¹‰**ï¼š
é›†åˆ $A$ çš„åŸºæ•°ï¼ˆåŠ¿ï¼‰å®šä¹‰ä¸ºï¼š
$$|A| = \text{card}(A) = \text{é›†åˆä¸­å…ƒç´ çš„æ•°é‡}$$

å¯¹äºæœ‰é™é›†åˆï¼ŒåŸºæ•°æ˜¯è‡ªç„¶æ•°ï¼›å¯¹äºæ— é™é›†åˆï¼ŒåŸºæ•°ç”¨é˜¿åˆ—å¤«æ•°è¡¨ç¤ºã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Union, Dict, Any
from enum import Enum

class Cardinality(Enum):
    """åŸºæ•°ç±»å‹"""
    FINITE = "finite"
    COUNTABLE = "countable"
    UNCOUNTABLE = "uncountable"

@dataclass
class SetCardinality:
    """é›†åˆåŸºæ•°"""
    cardinality_type: Cardinality
    value: Union[int, str]
    
    def __str__(self) -> str:
        if self.cardinality_type == Cardinality.FINITE:
            return str(self.value)
        elif self.cardinality_type == Cardinality.COUNTABLE:
            return "â„µâ‚€"
        else:
            return "â„µâ‚"

class CardinalityAnalyzer:
    """åŸºæ•°åˆ†æå™¨"""
    
    @staticmethod
    def analyze_cardinality(elements: List[Any]) -> SetCardinality:
        """åˆ†æé›†åˆåŸºæ•°"""
        size = len(elements)
        
        if size < float('inf'):
            return SetCardinality(Cardinality.FINITE, size)
        else:
            # ç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
            return SetCardinality(Cardinality.COUNTABLE, "â„µâ‚€")
    
    @staticmethod
    def compare_cardinality(set1: SetCardinality, set2: SetCardinality) -> str:
        """æ¯”è¾ƒä¸¤ä¸ªé›†åˆçš„åŸºæ•°"""
        if set1.cardinality_type == set2.cardinality_type:
            if set1.cardinality_type == Cardinality.FINITE:
                if set1.value < set2.value:
                    return "|A| < |B|"
                elif set1.value > set2.value:
                    return "|A| > |B|"
                else:
                    return "|A| = |B|"
            else:
                return "|A| = |B| (åŒä¸ºæ— é™é›†)"
        else:
            if set1.cardinality_type == Cardinality.FINITE:
                return "|A| < |B|"
            else:
                return "|A| > |B|"
```

### 2. å‡½æ•°è®ºåŸºç¡€

#### 2.1 å‡½æ•°çš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å‡½æ•° $f$ æ˜¯ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„æ˜ å°„ï¼š
$$f: A \rightarrow B$$
æ»¡è¶³ï¼š$\forall x \in A, \exists! y \in B: f(x) = y$

**Pythonå®ç°**ï¼š

```python
from typing import Callable, Dict, Any, Optional, List
from dataclasses import dataclass

@dataclass
class Function:
    """å‡½æ•°å®šä¹‰"""
    domain: Set[Any]
    codomain: Set[Any]
    mapping: Callable[[Any], Any]
    name: str = "f"
    
    def apply(self, x: Any) -> Any:
        """åº”ç”¨å‡½æ•°"""
        if not self.domain.contains(x):
            raise ValueError(f"å…ƒç´  {x} ä¸åœ¨å®šä¹‰åŸŸä¸­")
        
        result = self.mapping(x)
        if not self.codomain.contains(result):
            raise ValueError(f"å‡½æ•°å€¼ {result} ä¸åœ¨å€¼åŸŸä¸­")
        
        return result
    
    def is_injective(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå•å°„"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ£€æŸ¥æ‰€æœ‰å…ƒç´ 
        return True
    
    def is_surjective(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ»¡å°„"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ£€æŸ¥æ‰€æœ‰å…ƒç´ 
        return True
    
    def is_bijective(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºåŒå°„"""
        return self.is_injective() and self.is_surjective()
    
    def compose(self, other: 'Function') -> 'Function':
        """å‡½æ•°å¤åˆ"""
        if not self.domain == other.codomain:
            raise ValueError("å‡½æ•°å¤åˆéœ€è¦åŒ¹é…çš„å®šä¹‰åŸŸå’Œå€¼åŸŸ")
        
        def composed(x: Any) -> Any:
            return self.apply(other.apply(x))
        
        return Function(
            domain=other.domain,
            codomain=self.codomain,
            mapping=composed,
            name=f"{self.name}âˆ˜{other.name}"
        )

class FunctionBuilder:
    """å‡½æ•°æ„å»ºå™¨"""
    
    @staticmethod
    def create_identity_function(domain: Set[Any]) -> Function:
        """åˆ›å»ºæ’ç­‰å‡½æ•°"""
        return Function(
            domain=domain,
            codomain=domain,
            mapping=lambda x: x,
            name="id"
        )
    
    @staticmethod
    def create_constant_function(domain: Set[Any], codomain: Set[Any], value: Any) -> Function:
        """åˆ›å»ºå¸¸å‡½æ•°"""
        return Function(
            domain=domain,
            codomain=codomain,
            mapping=lambda x: value,
            name=f"const_{value}"
        )
    
    @staticmethod
    def create_polynomial_function(coefficients: List[float]) -> Function:
        """åˆ›å»ºå¤šé¡¹å¼å‡½æ•°"""
        def polynomial(x: float) -> float:
            result = 0.0
            for i, coef in enumerate(coefficients):
                result += coef * (x ** i)
            return result
        
        return Function(
            domain=FiniteSet([x for x in range(-10, 11)]),  # ç®€åŒ–å®šä¹‰åŸŸ
            codomain=FiniteSet([x for x in range(-100, 101)]),  # ç®€åŒ–å€¼åŸŸ
            mapping=polynomial,
            name="polynomial"
        )

# ä½¿ç”¨ç¤ºä¾‹
def function_example():
    """å‡½æ•°ç¤ºä¾‹"""
    # åˆ›å»ºå®šä¹‰åŸŸå’Œå€¼åŸŸ
    domain = FiniteSet([1, 2, 3, 4, 5])
    codomain = FiniteSet([1, 4, 9, 16, 25])
    
    # åˆ›å»ºå¹³æ–¹å‡½æ•°
    square_function = Function(
        domain=domain,
        codomain=codomain,
        mapping=lambda x: x ** 2,
        name="square"
    )
    
    # åº”ç”¨å‡½æ•°
    for x in [1, 2, 3, 4, 5]:
        result = square_function.apply(x)
        print(f"f({x}) = {result}")
    
    # åˆ›å»ºæ’ç­‰å‡½æ•°
    identity = FunctionBuilder.create_identity_function(domain)
    
    # å‡½æ•°å¤åˆ
    composed = square_function.compose(identity)
    print(f"å¤åˆå‡½æ•°: {composed.name}")
    
    return square_function, identity, composed

### 3. å…³ç³»è®ºåŸºç¡€

#### 3.1 å…³ç³»çš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å…³ç³» $R$ æ˜¯é›†åˆ $A$ å’Œ $B$ çš„ç¬›å¡å°”ç§¯çš„å­é›†ï¼š
$$R \subseteq A \times B$$

**Pythonå®ç°**ï¼š

```python
from typing import Tuple, List, Set

@dataclass
class Relation:
    """å…³ç³»å®šä¹‰"""
    domain: Set[Any]
    codomain: Set[Any]
    pairs: Set[Tuple[Any, Any]]
    name: str = "R"
    
    def contains(self, pair: Tuple[Any, Any]) -> bool:
        """æ£€æŸ¥å…³ç³»æ˜¯å¦åŒ…å«æŸä¸ªåºå¯¹"""
        return pair in self.pairs
    
    def is_reflexive(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªåå…³ç³»"""
        if self.domain != self.codomain:
            return False
        
        for x in self.domain._elements:
            if (x, x) not in self.pairs:
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå¯¹ç§°å…³ç³»"""
        if self.domain != self.codomain:
            return False
        
        for (x, y) in self.pairs:
            if (y, x) not in self.pairs:
                return False
        return True
    
    def is_transitive(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºä¼ é€’å…³ç³»"""
        if self.domain != self.codomain:
            return False
        
        for (x, y) in self.pairs:
            for (y2, z) in self.pairs:
                if y == y2 and (x, z) not in self.pairs:
                    return False
        return True
    
    def is_equivalence(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç­‰ä»·å…³ç³»"""
        return (self.is_reflexive() and 
                self.is_symmetric() and 
                self.is_transitive())
    
    def get_equivalence_classes(self) -> List[Set[Any]]:
        """è·å–ç­‰ä»·ç±»"""
        if not self.is_equivalence():
            raise ValueError("å…³ç³»ä¸æ˜¯ç­‰ä»·å…³ç³»")
        
        classes = []
        processed = set()
        
        for x in self.domain._elements:
            if x in processed:
                continue
            
            # æ‰¾åˆ°åŒ…å«xçš„ç­‰ä»·ç±»
            equivalence_class = set()
            for (a, b) in self.pairs:
                if a == x:
                    equivalence_class.add(b)
                    processed.add(b)
            
            classes.append(FiniteSet(list(equivalence_class)))
        
        return classes

class RelationBuilder:
    """å…³ç³»æ„å»ºå™¨"""
    
    @staticmethod
    def create_equality_relation(domain: Set[Any]) -> Relation:
        """åˆ›å»ºç›¸ç­‰å…³ç³»"""
        pairs = {(x, x) for x in domain._elements}
        return Relation(
            domain=domain,
            codomain=domain,
            pairs=pairs,
            name="="
        )
    
    @staticmethod
    def create_less_than_relation(domain: Set[int]) -> Relation:
        """åˆ›å»ºå°äºå…³ç³»"""
        pairs = set()
        for x in domain._elements:
            for y in domain._elements:
                if x < y:
                    pairs.add((x, y))
        
        return Relation(
            domain=domain,
            codomain=domain,
            pairs=pairs,
            name="<"
        )

# ä½¿ç”¨ç¤ºä¾‹
def relation_example():
    """å…³ç³»ç¤ºä¾‹"""
    # åˆ›å»ºé›†åˆ
    domain = FiniteSet([1, 2, 3, 4])
    
    # åˆ›å»ºç›¸ç­‰å…³ç³»
    equality = RelationBuilder.create_equality_relation(domain)
    print(f"ç›¸ç­‰å…³ç³»æ˜¯ç­‰ä»·å…³ç³»: {equality.is_equivalence()}")
    
    # åˆ›å»ºå°äºå…³ç³»
    less_than = RelationBuilder.create_less_than_relation(domain)
    print(f"å°äºå…³ç³»æ˜¯è‡ªåçš„: {less_than.is_reflexive()}")
    print(f"å°äºå…³ç³»æ˜¯å¯¹ç§°çš„: {less_than.is_symmetric()}")
    print(f"å°äºå…³ç³»æ˜¯ä¼ é€’çš„: {less_than.is_transitive()}")
    
    # è·å–ç­‰ä»·ç±»
    equivalence_classes = equality.get_equivalence_classes()
    print(f"ç›¸ç­‰å…³ç³»çš„ç­‰ä»·ç±»: {equivalence_classes}")
    
    return equality, less_than

### 4. æ•°å­¦å½’çº³æ³•

#### 4.1 æ•°å­¦å½’çº³æ³•çš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
æ•°å­¦å½’çº³æ³•åŸç†ï¼šè®¾ $P(n)$ æ˜¯å…³äºè‡ªç„¶æ•° $n$ çš„å‘½é¢˜ï¼Œå¦‚æœï¼š
1. $P(0)$ ä¸ºçœŸï¼ˆåŸºç¡€æ­¥éª¤ï¼‰
2. å¯¹äºä»»æ„ $k \geq 0$ï¼Œå¦‚æœ $P(k)$ ä¸ºçœŸï¼Œåˆ™ $P(k+1)$ ä¸ºçœŸï¼ˆå½’çº³æ­¥éª¤ï¼‰

é‚£ä¹ˆå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $n$ï¼Œ$P(n)$ ä¸ºçœŸã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Callable, Any
import time

class MathematicalInduction:
    """æ•°å­¦å½’çº³æ³•å®ç°"""
    
    @staticmethod
    def prove_by_induction(
        base_case: Callable[[], bool],
        inductive_step: Callable[[int], bool],
        max_n: int = 100
    ) -> bool:
        """ä½¿ç”¨æ•°å­¦å½’çº³æ³•è¯æ˜å‘½é¢˜"""
        
        # åŸºç¡€æ­¥éª¤
        if not base_case():
            print("åŸºç¡€æ­¥éª¤å¤±è´¥")
            return False
        
        # å½’çº³æ­¥éª¤
        for n in range(max_n):
            if not inductive_step(n):
                print(f"å½’çº³æ­¥éª¤åœ¨ n={n} æ—¶å¤±è´¥")
                return False
        
        print("æ•°å­¦å½’çº³æ³•è¯æ˜æˆåŠŸ")
        return True
    
    @staticmethod
    def prove_sum_formula():
        """è¯æ˜æ±‚å’Œå…¬å¼ï¼š1 + 2 + ... + n = n(n+1)/2"""
        
        def base_case() -> bool:
            """åŸºç¡€æ­¥éª¤ï¼šP(0)"""
            return 0 == 0 * (0 + 1) / 2
        
        def inductive_step(n: int) -> bool:
            """å½’çº³æ­¥éª¤ï¼šP(n) => P(n+1)"""
            # å‡è®¾ P(n): 1 + 2 + ... + n = n(n+1)/2
            # è¯æ˜ P(n+1): 1 + 2 + ... + n + (n+1) = (n+1)(n+2)/2
            
            left_side = n * (n + 1) / 2 + (n + 1)  # æ ¹æ®å½’çº³å‡è®¾
            right_side = (n + 1) * (n + 2) / 2
            
            return abs(left_side - right_side) < 1e-10
        
        return MathematicalInduction.prove_by_induction(base_case, inductive_step)
    
    @staticmethod
    def prove_fibonacci_formula():
        """è¯æ˜æ–æ³¢é‚£å¥‘æ•°åˆ—çš„é—­å¼å…¬å¼"""
        
        def fibonacci(n: int) -> int:
            """è®¡ç®—æ–æ³¢é‚£å¥‘æ•°"""
            if n <= 1:
                return n
            return fibonacci(n-1) + fibonacci(n-2)
        
        def base_case() -> bool:
            """åŸºç¡€æ­¥éª¤"""
            return fibonacci(0) == 0 and fibonacci(1) == 1
        
        def inductive_step(n: int) -> bool:
            """å½’çº³æ­¥éª¤ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰"""
            if n < 2:
                return True
            
            # éªŒè¯é€’æ¨å…³ç³»
            return fibonacci(n) == fibonacci(n-1) + fibonacci(n-2)
        
        return MathematicalInduction.prove_by_induction(base_case, inductive_step, max_n=10)

# ä½¿ç”¨ç¤ºä¾‹
def induction_example():
    """æ•°å­¦å½’çº³æ³•ç¤ºä¾‹"""
    print("è¯æ˜æ±‚å’Œå…¬å¼:")
    MathematicalInduction.prove_sum_formula()
    
    print("\nè¯æ˜æ–æ³¢é‚£å¥‘æ•°åˆ—:")
    MathematicalInduction.prove_fibonacci_formula()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [é€»è¾‘å­¦åŸºç¡€](../01.02-é€»è¾‘å­¦.md)
- [é›†åˆè®ºæ·±å…¥](../01.03-é›†åˆè®º.md)
- [å›¾è®ºåŸºç¡€](../01.04-å›¾è®º.md)
- [ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02.01-ç®—æ³•ç†è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. ç¦»æ•£æ•°å­¦åŠå…¶åº”ç”¨ (Kenneth H. Rosen)
2. é›†åˆè®ºåŸºç¡€ (Georg Cantor)
3. æ•°å­¦åˆ†æåŸç† (Walter Rudin)

---

**æ³¨æ„**: æœ¬æ–‡æ¡£æä¾›äº†æ•°å­¦åŸºç¡€çš„æ ¸å¿ƒæ¦‚å¿µå’ŒPythonå®ç°ï¼Œä¸ºåç»­çš„ç®—æ³•ç†è®ºã€æ•°æ®ç»“æ„ç­‰æä¾›æ•°å­¦æ”¯æ’‘ã€‚
