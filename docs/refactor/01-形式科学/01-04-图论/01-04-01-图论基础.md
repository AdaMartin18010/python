# å›¾è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

å›¾è®ºæ˜¯ç ”ç©¶å›¾çš„ç»“æ„å’Œæ€§è´¨çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨è®¡ç®—æœºç§‘å­¦ã€ç½‘ç»œåˆ†æã€ç®—æ³•è®¾è®¡ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°å›¾è®ºçš„ç†è®ºåŸºç¡€ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å›¾çš„å®šä¹‰

**å®šä¹‰ 1.1** (å›¾)
å›¾ $G = (V, E)$ ç”±é¡¶ç‚¹é›† $V$ å’Œè¾¹é›† $E$ ç»„æˆï¼Œå…¶ä¸­ $E \subseteq V \times V$ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{Graph} = \{(V, E) \mid V \text{ is a set}, E \subseteq V \times V\}$$

**å®šä¹‰ 1.2** (æœ‰å‘å›¾)
æœ‰å‘å›¾ $G = (V, E)$ ä¸­ï¼Œè¾¹æ˜¯æœ‰åºå¯¹ $(u, v) \in V \times V$ã€‚

**å®šä¹‰ 1.3** (æ— å‘å›¾)
æ— å‘å›¾ $G = (V, E)$ ä¸­ï¼Œè¾¹æ˜¯æ— åºå¯¹ $\{u, v\} \subseteq V$ã€‚

### 1.2 å›¾çš„åŸºæœ¬æ€§è´¨

**å®šä¹‰ 1.4** (åº¦æ•°)
é¡¶ç‚¹ $v$ çš„åº¦æ•° $deg(v)$ æ˜¯ä¸ $v$ ç›¸é‚»çš„è¾¹æ•°ã€‚

**å®šä¹‰ 1.5** (è·¯å¾„)
è·¯å¾„æ˜¯é¡¶ç‚¹åºåˆ— $v_1, v_2, \ldots, v_k$ï¼Œå…¶ä¸­ $(v_i, v_{i+1}) \in E$ã€‚

**å®šä¹‰ 1.6** (è¿é€šæ€§)
å›¾æ˜¯è¿é€šçš„ï¼Œå½“ä¸”ä»…å½“ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹é—´å­˜åœ¨è·¯å¾„ã€‚

## 2. Pythonå®ç°

### 2.1 åŸºæœ¬æ•°æ®ç»“æ„

```python
from typing import Dict, List, Set, Tuple, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
from abc import ABC, abstractmethod
import heapq
from collections import defaultdict, deque

class GraphType(Enum):
    """å›¾ç±»å‹"""
    DIRECTED = "directed"
    UNDIRECTED = "undirected"
    WEIGHTED = "weighted"

@dataclass
class Edge:
    """è¾¹ç±»"""
    source: Any
    target: Any
    weight: float = 1.0
    
    def __str__(self) -> str:
        if self.weight == 1.0:
            return f"({self.source} -> {self.target})"
        return f"({self.source} -> {self.target}, w={self.weight})"

@dataclass
class Vertex:
    """é¡¶ç‚¹ç±»"""
    id: Any
    data: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        return str(self.id)

class Graph:
    """å›¾ç±»"""
    
    def __init__(self, graph_type: GraphType = GraphType.UNDIRECTED):
        self.graph_type = graph_type
        self.vertices: Dict[Any, Vertex] = {}
        self.edges: List[Edge] = []
        self.adjacency_list: Dict[Any, List[Tuple[Any, float]]] = defaultdict(list)
        self.adjacency_matrix: Optional[List[List[float]]] = None
        self._matrix_updated = False
    
    def add_vertex(self, vertex_id: Any, **kwargs) -> Vertex:
        """æ·»åŠ é¡¶ç‚¹"""
        if vertex_id not in self.vertices:
            vertex = Vertex(vertex_id, kwargs)
            self.vertices[vertex_id] = vertex
        return self.vertices[vertex_id]
    
    def add_edge(self, source: Any, target: Any, weight: float = 1.0) -> Edge:
        """æ·»åŠ è¾¹"""
        # ç¡®ä¿é¡¶ç‚¹å­˜åœ¨
        if source not in self.vertices:
            self.add_vertex(source)
        if target not in self.vertices:
            self.add_vertex(target)
        
        # åˆ›å»ºè¾¹
        edge = Edge(source, target, weight)
        self.edges.append(edge)
        
        # æ›´æ–°é‚»æ¥è¡¨
        self.adjacency_list[source].append((target, weight))
        if self.graph_type == GraphType.UNDIRECTED:
            self.adjacency_list[target].append((source, weight))
        
        # æ ‡è®°çŸ©é˜µéœ€è¦æ›´æ–°
        self._matrix_updated = False
        
        return edge
    
    def remove_edge(self, source: Any, target: Any) -> bool:
        """åˆ é™¤è¾¹"""
        # ä»è¾¹åˆ—è¡¨ä¸­åˆ é™¤
        self.edges = [e for e in self.edges 
                     if not (e.source == source and e.target == target)]
        
        # ä»é‚»æ¥è¡¨ä¸­åˆ é™¤
        if source in self.adjacency_list:
            self.adjacency_list[source] = [
                (t, w) for t, w in self.adjacency_list[source] if t != target
            ]
        
        if self.graph_type == GraphType.UNDIRECTED and target in self.adjacency_list:
            self.adjacency_list[target] = [
                (s, w) for s, w in self.adjacency_list[target] if s != source
            ]
        
        self._matrix_updated = False
        return True
    
    def get_degree(self, vertex_id: Any) -> int:
        """è·å–é¡¶ç‚¹åº¦æ•°"""
        if vertex_id not in self.adjacency_list:
            return 0
        return len(self.adjacency_list[vertex_id])
    
    def get_neighbors(self, vertex_id: Any) -> List[Tuple[Any, float]]:
        """è·å–é‚»å±…"""
        return self.adjacency_list.get(vertex_id, [])
    
    def build_adjacency_matrix(self) -> List[List[float]]:
        """æ„å»ºé‚»æ¥çŸ©é˜µ"""
        if self.adjacency_matrix is not None and self._matrix_updated:
            return self.adjacency_matrix
        
        vertex_ids = list(self.vertices.keys())
        n = len(vertex_ids)
        vertex_to_index = {vid: i for i, vid in enumerate(vertex_ids)}
        
        # åˆå§‹åŒ–çŸ©é˜µ
        matrix = [[0.0] * n for _ in range(n)]
        
        # å¡«å……çŸ©é˜µ
        for edge in self.edges:
            i = vertex_to_index[edge.source]
            j = vertex_to_index[edge.target]
            matrix[i][j] = edge.weight
            
            if self.graph_type == GraphType.UNDIRECTED:
                matrix[j][i] = edge.weight
        
        self.adjacency_matrix = matrix
        self._matrix_updated = True
        return matrix
    
    def is_connected(self) -> bool:
        """æ£€æŸ¥å›¾æ˜¯å¦è¿é€š"""
        if not self.vertices:
            return True
        
        # ä½¿ç”¨DFSæ£€æŸ¥è¿é€šæ€§
        visited = set()
        start_vertex = next(iter(self.vertices.keys()))
        
        def dfs(vertex_id: Any):
            visited.add(vertex_id)
            for neighbor, _ in self.get_neighbors(vertex_id):
                if neighbor not in visited:
                    dfs(neighbor)
        
        dfs(start_vertex)
        return len(visited) == len(self.vertices)
    
    def get_connected_components(self) -> List[Set[Any]]:
        """è·å–è¿é€šåˆ†é‡"""
        visited = set()
        components = []
        
        def dfs(vertex_id: Any, component: Set[Any]):
            visited.add(vertex_id)
            component.add(vertex_id)
            for neighbor, _ in self.get_neighbors(vertex_id):
                if neighbor not in visited:
                    dfs(neighbor, component)
        
        for vertex_id in self.vertices:
            if vertex_id not in visited:
                component = set()
                dfs(vertex_id, component)
                components.append(component)
        
        return components
    
    def __str__(self) -> str:
        result = f"Graph ({self.graph_type.value}):\n"
        result += f"Vertices: {list(self.vertices.keys())}\n"
        result += f"Edges: {[str(edge) for edge in self.edges]}\n"
        return result

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_basic_graph():
    """æ¼”ç¤ºåŸºæœ¬å›¾æ“ä½œ"""
    print("=== åŸºæœ¬å›¾æ“ä½œæ¼”ç¤º ===\n")
    
    # åˆ›å»ºæ— å‘å›¾
    g = Graph(GraphType.UNDIRECTED)
    
    # æ·»åŠ é¡¶ç‚¹
    g.add_vertex("A")
    g.add_vertex("B")
    g.add_vertex("C")
    g.add_vertex("D")
    
    # æ·»åŠ è¾¹
    g.add_edge("A", "B", 2.0)
    g.add_edge("B", "C", 3.0)
    g.add_edge("C", "D", 1.0)
    g.add_edge("A", "D", 4.0)
    
    print(g)
    
    # æ£€æŸ¥è¿é€šæ€§
    print(f"å›¾æ˜¯å¦è¿é€š: {g.is_connected()}")
    
    # è·å–è¿é€šåˆ†é‡
    components = g.get_connected_components()
    print(f"è¿é€šåˆ†é‡: {components}")
    
    # è·å–åº¦æ•°
    for vertex_id in g.vertices:
        degree = g.get_degree(vertex_id)
        print(f"é¡¶ç‚¹ {vertex_id} çš„åº¦æ•°: {degree}")
    
    # æ„å»ºé‚»æ¥çŸ©é˜µ
    matrix = g.build_adjacency_matrix()
    print(f"\né‚»æ¥çŸ©é˜µ:")
    for row in matrix:
        print(row)

if __name__ == "__main__":
    demonstrate_basic_graph()
```

## 3. å›¾çš„éå†ç®—æ³•

### 3.1 æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)

**å®šä¹‰ 3.1** (æ·±åº¦ä¼˜å…ˆæœç´¢)
æ·±åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸€ç§å›¾éå†ç®—æ³•ï¼Œä¼˜å…ˆè®¿é—®æ·±å±‚èŠ‚ç‚¹ã€‚

**ç®—æ³•æè¿°**:

1. ä»èµ·å§‹é¡¶ç‚¹å¼€å§‹
2. è®¿é—®å½“å‰é¡¶ç‚¹
3. é€’å½’è®¿é—®æœªè®¿é—®çš„é‚»å±…
4. å›æº¯åˆ°ä¸Šä¸€ä¸ªé¡¶ç‚¹

### 3.2 å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)

**å®šä¹‰ 3.2** (å¹¿åº¦ä¼˜å…ˆæœç´¢)
å¹¿åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸€ç§å›¾éå†ç®—æ³•ï¼Œä¼˜å…ˆè®¿é—®è¿‘é‚»èŠ‚ç‚¹ã€‚

**ç®—æ³•æè¿°**:

1. ä»èµ·å§‹é¡¶ç‚¹å¼€å§‹
2. è®¿é—®å½“å‰é¡¶ç‚¹
3. å°†æ‰€æœ‰æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—
4. ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸‹ä¸€ä¸ªé¡¶ç‚¹

### 3.3 Pythonå®ç°

```python
class GraphTraversal:
    """å›¾éå†ç®—æ³•"""
    
    @staticmethod
    def dfs(graph: Graph, start_vertex: Any) -> List[Any]:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        traversal_order = []
        
        def dfs_recursive(vertex_id: Any):
            visited.add(vertex_id)
            traversal_order.append(vertex_id)
            
            for neighbor, _ in graph.get_neighbors(vertex_id):
                if neighbor not in visited:
                    dfs_recursive(neighbor)
        
        dfs_recursive(start_vertex)
        return traversal_order
    
    @staticmethod
    def bfs(graph: Graph, start_vertex: Any) -> List[Any]:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        traversal_order = []
        queue = deque([start_vertex])
        visited.add(start_vertex)
        
        while queue:
            vertex_id = queue.popleft()
            traversal_order.append(vertex_id)
            
            for neighbor, _ in graph.get_neighbors(vertex_id):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return traversal_order
    
    @staticmethod
    def dfs_iterative(graph: Graph, start_vertex: Any) -> List[Any]:
        """è¿­ä»£å¼æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        traversal_order = []
        stack = [start_vertex]
        
        while stack:
            vertex_id = stack.pop()
            
            if vertex_id not in visited:
                visited.add(vertex_id)
                traversal_order.append(vertex_id)
                
                # å°†é‚»å±…æŒ‰ç›¸åé¡ºåºå‹å…¥æ ˆä¸­
                neighbors = [n for n, _ in graph.get_neighbors(vertex_id)]
                for neighbor in reversed(neighbors):
                    if neighbor not in visited:
                        stack.append(neighbor)
        
        return traversal_order

def demonstrate_traversal():
    """æ¼”ç¤ºå›¾éå†"""
    print("=== å›¾éå†ç®—æ³•æ¼”ç¤º ===\n")
    
    # åˆ›å»ºå›¾
    g = Graph(GraphType.UNDIRECTED)
    
    # æ·»åŠ é¡¶ç‚¹å’Œè¾¹
    vertices = ["A", "B", "C", "D", "E", "F"]
    for v in vertices:
        g.add_vertex(v)
    
    edges = [
        ("A", "B"), ("A", "C"), ("B", "D"), 
        ("B", "E"), ("C", "F"), ("E", "F")
    ]
    
    for source, target in edges:
        g.add_edge(source, target)
    
    print("å›¾ç»“æ„:")
    print(g)
    
    # æ·±åº¦ä¼˜å…ˆæœç´¢
    dfs_order = GraphTraversal.dfs(g, "A")
    print(f"DFSéå†é¡ºåº: {dfs_order}")
    
    # å¹¿åº¦ä¼˜å…ˆæœç´¢
    bfs_order = GraphTraversal.bfs(g, "A")
    print(f"BFSéå†é¡ºåº: {bfs_order}")
    
    # è¿­ä»£å¼DFS
    dfs_iter_order = GraphTraversal.dfs_iterative(g, "A")
    print(f"è¿­ä»£å¼DFSéå†é¡ºåº: {dfs_iter_order}")

if __name__ == "__main__":
    demonstrate_traversal()
```

## 4. æœ€çŸ­è·¯å¾„ç®—æ³•

### 4.1 Dijkstraç®—æ³•

**å®šä¹‰ 4.1** (Dijkstraç®—æ³•)
Dijkstraç®—æ³•ç”¨äºåœ¨å¸¦æƒå›¾ä¸­æ‰¾åˆ°ä»èµ·å§‹é¡¶ç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

**ç®—æ³•æè¿°**:

1. åˆå§‹åŒ–è·ç¦»æ•°ç»„ï¼Œèµ·å§‹é¡¶ç‚¹è·ç¦»ä¸º0ï¼Œå…¶ä»–ä¸ºæ— ç©·å¤§
2. é€‰æ‹©è·ç¦»æœ€å°çš„æœªè®¿é—®é¡¶ç‚¹
3. æ›´æ–°é€šè¿‡è¯¥é¡¶ç‚¹åˆ°è¾¾å…¶ä»–é¡¶ç‚¹çš„è·ç¦»
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®

### 4.2 Floyd-Warshallç®—æ³•

**å®šä¹‰ 4.2** (Floyd-Warshallç®—æ³•)
Floyd-Warshallç®—æ³•ç”¨äºæ‰¾åˆ°å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚

**ç®—æ³•æè¿°**:

1. åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
2. å¯¹äºæ¯ä¸ªä¸­é—´é¡¶ç‚¹k
3. å¯¹äºæ¯å¯¹é¡¶ç‚¹(i,j)
4. æ›´æ–°è·ç¦»ï¼š`d[i][j] = min(d[i][j], d[i][k] + d[k][j])`

### 4.3 Pythonå®ç°

```python
class ShortestPath:
    """æœ€çŸ­è·¯å¾„ç®—æ³•"""
    
    @staticmethod
    def dijkstra(graph: Graph, start_vertex: Any) -> Dict[Any, float]:
        """Dijkstraç®—æ³•"""
        if start_vertex not in graph.vertices:
            return {}
        
        # åˆå§‹åŒ–è·ç¦»
        distances = {vertex: float('inf') for vertex in graph.vertices}
        distances[start_vertex] = 0
        
        # ä¼˜å…ˆé˜Ÿåˆ—
        pq = [(0, start_vertex)]
        visited = set()
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_vertex in visited:
                continue
            
            visited.add(current_vertex)
            
            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor, weight in graph.get_neighbors(current_vertex):
                if neighbor not in visited:
                    new_distance = current_distance + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        heapq.heappush(pq, (new_distance, neighbor))
        
        return distances
    
    @staticmethod
    def floyd_warshall(graph: Graph) -> Dict[Tuple[Any, Any], float]:
        """Floyd-Warshallç®—æ³•"""
        vertex_ids = list(graph.vertices.keys())
        n = len(vertex_ids)
        vertex_to_index = {vid: i for i, vid in enumerate(vertex_ids)}
        
        # åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
        dist = [[float('inf')] * n for _ in range(n)]
        
        # è®¾ç½®å¯¹è§’çº¿ä¸º0
        for i in range(n):
            dist[i][i] = 0
        
        # è®¾ç½®åˆå§‹è¾¹æƒé‡
        for edge in graph.edges:
            i = vertex_to_index[edge.source]
            j = vertex_to_index[edge.target]
            dist[i][j] = edge.weight
            
            if graph.graph_type == GraphType.UNDIRECTED:
                dist[j][i] = edge.weight
        
        # Floyd-Warshallä¸»å¾ªç¯
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dist[i][k] != float('inf') and dist[k][j] != float('inf'):
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
        
        # è½¬æ¢ä¸ºå­—å…¸æ ¼å¼
        result = {}
        for i in range(n):
            for j in range(n):
                if dist[i][j] != float('inf'):
                    result[(vertex_ids[i], vertex_ids[j])] = dist[i][j]
        
        return result
    
    @staticmethod
    def bellman_ford(graph: Graph, start_vertex: Any) -> Dict[Any, float]:
        """Bellman-Fordç®—æ³•ï¼ˆå¤„ç†è´Ÿæƒè¾¹ï¼‰"""
        if start_vertex not in graph.vertices:
            return {}
        
        # åˆå§‹åŒ–è·ç¦»
        distances = {vertex: float('inf') for vertex in graph.vertices}
        distances[start_vertex] = 0
        
        # æ¾å¼›æ“ä½œ
        for _ in range(len(graph.vertices) - 1):
            for edge in graph.edges:
                if distances[edge.source] != float('inf'):
                    new_distance = distances[edge.source] + edge.weight
                    if new_distance < distances[edge.target]:
                        distances[edge.target] = new_distance
        
        # æ£€æŸ¥è´Ÿç¯
        for edge in graph.edges:
            if distances[edge.source] != float('inf'):
                if distances[edge.source] + edge.weight < distances[edge.target]:
                    raise ValueError("å›¾ä¸­å­˜åœ¨è´Ÿç¯")
        
        return distances

def demonstrate_shortest_path():
    """æ¼”ç¤ºæœ€çŸ­è·¯å¾„ç®—æ³•"""
    print("=== æœ€çŸ­è·¯å¾„ç®—æ³•æ¼”ç¤º ===\n")
    
    # åˆ›å»ºå¸¦æƒå›¾
    g = Graph(GraphType.WEIGHTED)
    
    # æ·»åŠ é¡¶ç‚¹
    vertices = ["A", "B", "C", "D", "E"]
    for v in vertices:
        g.add_vertex(v)
    
    # æ·»åŠ å¸¦æƒè¾¹
    edges = [
        ("A", "B", 4), ("A", "C", 2), ("B", "C", 1),
        ("B", "D", 5), ("C", "D", 8), ("C", "E", 10),
        ("D", "E", 2)
    ]
    
    for source, target, weight in edges:
        g.add_edge(source, target, weight)
    
    print("å¸¦æƒå›¾:")
    print(g)
    
    # Dijkstraç®—æ³•
    start_vertex = "A"
    dijkstra_distances = ShortestPath.dijkstra(g, start_vertex)
    print(f"\nDijkstraç®—æ³•ç»“æœ (ä»{start_vertex}å¼€å§‹):")
    for vertex, distance in dijkstra_distances.items():
        print(f"åˆ°{vertex}çš„æœ€çŸ­è·ç¦»: {distance}")
    
    # Floyd-Warshallç®—æ³•
    floyd_distances = ShortestPath.floyd_warshall(g)
    print(f"\nFloyd-Warshallç®—æ³•ç»“æœ:")
    for (source, target), distance in floyd_distances.items():
        if source != target:
            print(f"ä»{source}åˆ°{target}çš„æœ€çŸ­è·ç¦»: {distance}")

if __name__ == "__main__":
    demonstrate_shortest_path()
```

## 5. æœ€å°ç”Ÿæˆæ ‘ç®—æ³•

### 5.1 Kruskalç®—æ³•

**å®šä¹‰ 5.1** (Kruskalç®—æ³•)
Kruskalç®—æ³•ç”¨äºåœ¨è¿é€šæ— å‘å›¾ä¸­æ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘ã€‚

**ç®—æ³•æè¿°**:

1. å°†æ‰€æœ‰è¾¹æŒ‰æƒé‡æ’åº
2. åˆå§‹åŒ–ç©ºçš„æœ€å°ç”Ÿæˆæ ‘
3. ä¾æ¬¡é€‰æ‹©æƒé‡æœ€å°çš„è¾¹
4. å¦‚æœè¾¹ä¸ä¼šå½¢æˆç¯ï¼Œåˆ™åŠ å…¥æœ€å°ç”Ÿæˆæ ‘
5. é‡å¤æ­¥éª¤3-4ç›´åˆ°é€‰æ‹©n-1æ¡è¾¹

### 5.2 Primç®—æ³•

**å®šä¹‰ 5.2** (Primç®—æ³•)
Primç®—æ³•ä»å•ä¸ªé¡¶ç‚¹å¼€å§‹æ„å»ºæœ€å°ç”Ÿæˆæ ‘ã€‚

**ç®—æ³•æè¿°**:

1. é€‰æ‹©èµ·å§‹é¡¶ç‚¹
2. é€‰æ‹©è¿æ¥å·²è®¿é—®é¡¶ç‚¹å’Œæœªè®¿é—®é¡¶ç‚¹çš„æœ€å°æƒé‡è¾¹
3. å°†æ–°é¡¶ç‚¹åŠ å…¥å·²è®¿é—®é›†åˆ
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®

### 5.3 Pythonå®ç°

```python
class UnionFind:
    """å¹¶æŸ¥é›†"""
    
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: int, y: int) -> bool:
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        
        if self.rank[px] < self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] > self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[py] = px
            self.rank[px] += 1
        return True

class MinimumSpanningTree:
    """æœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    
    @staticmethod
    def kruskal(graph: Graph) -> List[Edge]:
        """Kruskalç®—æ³•"""
        if not graph.vertices:
            return []
        
        # åˆ›å»ºé¡¶ç‚¹åˆ°ç´¢å¼•çš„æ˜ å°„
        vertex_to_index = {vid: i for i, vid in enumerate(graph.vertices.keys())}
        
        # æ’åºè¾¹
        sorted_edges = sorted(graph.edges, key=lambda e: e.weight)
        
        # åˆå§‹åŒ–å¹¶æŸ¥é›†
        uf = UnionFind(len(graph.vertices))
        
        mst_edges = []
        
        for edge in sorted_edges:
            source_idx = vertex_to_index[edge.source]
            target_idx = vertex_to_index[edge.target]
            
            if uf.union(source_idx, target_idx):
                mst_edges.append(edge)
                
                if len(mst_edges) == len(graph.vertices) - 1:
                    break
        
        return mst_edges
    
    @staticmethod
    def prim(graph: Graph, start_vertex: Any = None) -> List[Edge]:
        """Primç®—æ³•"""
        if not graph.vertices:
            return []
        
        if start_vertex is None:
            start_vertex = next(iter(graph.vertices.keys()))
        
        visited = {start_vertex}
        mst_edges = []
        
        while len(visited) < len(graph.vertices):
            min_edge = None
            min_weight = float('inf')
            
            # æ‰¾åˆ°è¿æ¥å·²è®¿é—®å’Œæœªè®¿é—®é¡¶ç‚¹çš„æœ€å°æƒé‡è¾¹
            for edge in graph.edges:
                if ((edge.source in visited and edge.target not in visited) or
                    (edge.target in visited and edge.source not in visited)):
                    if edge.weight < min_weight:
                        min_weight = edge.weight
                        min_edge = edge
            
            if min_edge is None:
                break
            
            # æ·»åŠ è¾¹åˆ°MST
            mst_edges.append(min_edge)
            
            # æ·»åŠ æ–°é¡¶ç‚¹åˆ°å·²è®¿é—®é›†åˆ
            if min_edge.source in visited:
                visited.add(min_edge.target)
            else:
                visited.add(min_edge.source)
        
        return mst_edges

def demonstrate_mst():
    """æ¼”ç¤ºæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    print("=== æœ€å°ç”Ÿæˆæ ‘ç®—æ³•æ¼”ç¤º ===\n")
    
    # åˆ›å»ºå¸¦æƒæ— å‘å›¾
    g = Graph(GraphType.UNDIRECTED)
    
    # æ·»åŠ é¡¶ç‚¹
    vertices = ["A", "B", "C", "D", "E", "F"]
    for v in vertices:
        g.add_vertex(v)
    
    # æ·»åŠ å¸¦æƒè¾¹
    edges = [
        ("A", "B", 4), ("A", "C", 2), ("B", "C", 1),
        ("B", "D", 5), ("C", "D", 8), ("C", "E", 10),
        ("D", "E", 2), ("D", "F", 6), ("E", "F", 3)
    ]
    
    for source, target, weight in edges:
        g.add_edge(source, target, weight)
    
    print("åŸå›¾:")
    print(g)
    
    # Kruskalç®—æ³•
    kruskal_mst = MinimumSpanningTree.kruskal(g)
    print(f"\nKruskalç®—æ³•MST:")
    total_weight = sum(edge.weight for edge in kruskal_mst)
    for edge in kruskal_mst:
        print(f"  {edge}")
    print(f"æ€»æƒé‡: {total_weight}")
    
    # Primç®—æ³•
    prim_mst = MinimumSpanningTree.prim(g, "A")
    print(f"\nPrimç®—æ³•MST:")
    total_weight = sum(edge.weight for edge in prim_mst)
    for edge in prim_mst:
        print(f"  {edge}")
    print(f"æ€»æƒé‡: {total_weight}")

if __name__ == "__main__":
    demonstrate_mst()
```

## 6. ç†è®ºè¯æ˜

### 6.1 å›¾çš„åŸºæœ¬å®šç†

**å®šç† 6.1** (æ¡æ‰‹å®šç†)
åœ¨ä»»ä½•å›¾ä¸­ï¼Œæ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°ä¹‹å’Œç­‰äºè¾¹æ•°çš„ä¸¤å€ã€‚

**è¯æ˜**:
$$\sum_{v \in V} deg(v) = 2|E|$$

æ¯æ¡è¾¹è´¡çŒ®ç»™ä¸¤ä¸ªé¡¶ç‚¹çš„åº¦æ•°ï¼Œå› æ­¤æ€»åº¦æ•°æ˜¯è¾¹æ•°çš„ä¸¤å€ã€‚

**å®šç† 6.2** (æ¬§æ‹‰å®šç†)
åœ¨è¿é€šå›¾ä¸­ï¼Œæ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°éƒ½æ˜¯å¶æ•°çš„å……è¦æ¡ä»¶æ˜¯å­˜åœ¨æ¬§æ‹‰å›è·¯ã€‚

**è¯æ˜**:

1. å¿…è¦æ€§ï¼šæ¬§æ‹‰å›è·¯ç»è¿‡æ¯æ¡è¾¹æ°å¥½ä¸€æ¬¡ï¼Œæ¯ä¸ªé¡¶ç‚¹è¢«è¿›å…¥å’Œç¦»å¼€çš„æ¬¡æ•°ç›¸ç­‰
2. å……åˆ†æ€§ï¼šé€šè¿‡æ„é€ ç®—æ³•å¯ä»¥æ‰¾åˆ°æ¬§æ‹‰å›è·¯

### 6.2 ç®—æ³•æ­£ç¡®æ€§è¯æ˜

**å®šç† 6.3** (Dijkstraç®—æ³•æ­£ç¡®æ€§)
Dijkstraç®—æ³•èƒ½å¤Ÿæ­£ç¡®æ‰¾åˆ°ä»èµ·å§‹é¡¶ç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

**è¯æ˜**:

1. ç®—æ³•ç»´æŠ¤è·ç¦»æ•°ç»„ï¼Œåˆå§‹æ—¶èµ·å§‹é¡¶ç‚¹è·ç¦»ä¸º0ï¼Œå…¶ä»–ä¸ºæ— ç©·å¤§
2. æ¯æ¬¡é€‰æ‹©è·ç¦»æœ€å°çš„æœªè®¿é—®é¡¶ç‚¹ï¼Œè¯¥è·ç¦»å°±æ˜¯æœ€çŸ­è·ç¦»
3. é€šè¿‡è¯¥é¡¶ç‚¹æ›´æ–°å…¶ä»–é¡¶ç‚¹çš„è·ç¦»
4. å½’çº³æ³•è¯æ˜ç®—æ³•æ­£ç¡®æ€§

## 7. åº”ç”¨å®ä¾‹

### 7.1 ç½‘ç»œè·¯ç”±

å›¾è®ºåœ¨ç½‘ç»œè·¯ç”±ä¸­çš„åº”ç”¨ï¼š

```python
class NetworkRouter:
    """ç½‘ç»œè·¯ç”±å™¨"""
    
    def __init__(self):
        self.network = Graph(GraphType.WEIGHTED)
        self.routing_table = {}
    
    def add_node(self, node_id: str, **kwargs):
        """æ·»åŠ ç½‘ç»œèŠ‚ç‚¹"""
        return self.network.add_vertex(node_id, **kwargs)
    
    def add_link(self, source: str, target: str, bandwidth: float, delay: float):
        """æ·»åŠ ç½‘ç»œé“¾è·¯"""
        # æƒé‡å¯ä»¥æ˜¯å»¶è¿Ÿæˆ–å¸¦å®½çš„å€’æ•°
        weight = delay
        return self.network.add_edge(source, target, weight)
    
    def compute_routes(self, source: str):
        """è®¡ç®—è·¯ç”±è¡¨"""
        distances = ShortestPath.dijkstra(self.network, source)
        self.routing_table[source] = distances
    
    def get_route(self, source: str, destination: str) -> Optional[float]:
        """è·å–è·¯ç”±ä¿¡æ¯"""
        if source in self.routing_table:
            return self.routing_table[source].get(destination)
        return None

def demonstrate_network_routing():
    """æ¼”ç¤ºç½‘ç»œè·¯ç”±"""
    print("=== ç½‘ç»œè·¯ç”±åº”ç”¨ ===\n")
    
    router = NetworkRouter()
    
    # æ·»åŠ ç½‘ç»œèŠ‚ç‚¹
    nodes = ["Router1", "Router2", "Router3", "Router4", "Router5"]
    for node in nodes:
        router.add_node(node)
    
    # æ·»åŠ ç½‘ç»œé“¾è·¯
    links = [
        ("Router1", "Router2", 100, 5),
        ("Router1", "Router3", 50, 10),
        ("Router2", "Router3", 80, 3),
        ("Router2", "Router4", 120, 8),
        ("Router3", "Router4", 60, 4),
        ("Router3", "Router5", 90, 6),
        ("Router4", "Router5", 70, 7)
    ]
    
    for source, target, bandwidth, delay in links:
        router.add_link(source, target, bandwidth, delay)
    
    # è®¡ç®—è·¯ç”±è¡¨
    router.compute_routes("Router1")
    
    print("ä»Router1åˆ°å„èŠ‚ç‚¹çš„æœ€çŸ­å»¶è¿Ÿ:")
    for node in nodes:
        delay = router.get_route("Router1", node)
        if delay is not None:
            print(f"åˆ°{node}: {delay}ms")

if __name__ == "__main__":
    demonstrate_network_routing()
```

### 7.2 ç¤¾äº¤ç½‘ç»œåˆ†æ

å›¾è®ºåœ¨ç¤¾äº¤ç½‘ç»œåˆ†æä¸­çš„åº”ç”¨ï¼š

```python
class SocialNetwork:
    """ç¤¾äº¤ç½‘ç»œåˆ†æ"""
    
    def __init__(self):
        self.network = Graph(GraphType.UNDIRECTED)
        self.user_profiles = {}
    
    def add_user(self, user_id: str, name: str, **kwargs):
        """æ·»åŠ ç”¨æˆ·"""
        self.user_profiles[user_id] = {"name": name, **kwargs}
        return self.network.add_vertex(user_id, name=name, **kwargs)
    
    def add_friendship(self, user1: str, user2: str, strength: float = 1.0):
        """æ·»åŠ å¥½å‹å…³ç³»"""
        return self.network.add_edge(user1, user2, strength)
    
    def get_friends(self, user_id: str) -> List[str]:
        """è·å–å¥½å‹åˆ—è¡¨"""
        neighbors = self.network.get_neighbors(user_id)
        return [neighbor for neighbor, _ in neighbors]
    
    def get_degree_centrality(self, user_id: str) -> float:
        """è®¡ç®—åº¦ä¸­å¿ƒæ€§"""
        if not self.network.vertices:
            return 0.0
        degree = self.network.get_degree(user_id)
        return degree / (len(self.network.vertices) - 1)
    
    def get_closeness_centrality(self, user_id: str) -> float:
        """è®¡ç®—æ¥è¿‘ä¸­å¿ƒæ€§"""
        if user_id not in self.network.vertices:
            return 0.0
        
        distances = ShortestPath.dijkstra(self.network, user_id)
        total_distance = sum(d for d in distances.values() if d != float('inf'))
        
        if total_distance == 0:
            return 0.0
        
        return (len(self.network.vertices) - 1) / total_distance
    
    def find_communities(self) -> List[Set[str]]:
        """å‘ç°ç¤¾åŒº"""
        return self.network.get_connected_components()

def demonstrate_social_network():
    """æ¼”ç¤ºç¤¾äº¤ç½‘ç»œåˆ†æ"""
    print("=== ç¤¾äº¤ç½‘ç»œåˆ†æåº”ç”¨ ===\n")
    
    social_net = SocialNetwork()
    
    # æ·»åŠ ç”¨æˆ·
    users = [
        ("Alice", "Alice Johnson"),
        ("Bob", "Bob Smith"),
        ("Charlie", "Charlie Brown"),
        ("Diana", "Diana Prince"),
        ("Eve", "Eve Wilson")
    ]
    
    for user_id, name in users:
        social_net.add_user(user_id, name)
    
    # æ·»åŠ å¥½å‹å…³ç³»
    friendships = [
        ("Alice", "Bob"), ("Alice", "Charlie"), ("Bob", "Charlie"),
        ("Bob", "Diana"), ("Charlie", "Diana"), ("Charlie", "Eve"),
        ("Diana", "Eve")
    ]
    
    for user1, user2 in friendships:
        social_net.add_friendship(user1, user2)
    
    print("ç¤¾äº¤ç½‘ç»œåˆ†æç»“æœ:")
    
    # åˆ†ææ¯ä¸ªç”¨æˆ·
    for user_id, name in users:
        friends = social_net.get_friends(user_id)
        degree_cent = social_net.get_degree_centrality(user_id)
        closeness_cent = social_net.get_closeness_centrality(user_id)
        
        print(f"\n{name} ({user_id}):")
        print(f"  å¥½å‹: {friends}")
        print(f"  åº¦ä¸­å¿ƒæ€§: {degree_cent:.3f}")
        print(f"  æ¥è¿‘ä¸­å¿ƒæ€§: {closeness_cent:.3f}")
    
    # å‘ç°ç¤¾åŒº
    communities = social_net.find_communities()
    print(f"\nå‘ç°çš„ç¤¾åŒº: {communities}")

if __name__ == "__main__":
    demonstrate_social_network()
```

## 8. æ€§èƒ½åˆ†æ

### 8.1 æ—¶é—´å¤æ‚åº¦

- **å›¾çš„è¡¨ç¤º**:
  - é‚»æ¥è¡¨: $O(|V| + |E|)$ ç©ºé—´
  - é‚»æ¥çŸ©é˜µ: $O(|V|^2)$ ç©ºé—´
- **éå†ç®—æ³•**:
  - DFS/BFS: $O(|V| + |E|)$
- **æœ€çŸ­è·¯å¾„**:
  - Dijkstra: $O((|V| + |E|) \log |V|)$ (ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—)
  - Floyd-Warshall: $O(|V|^3)$
  - Bellman-Ford: $O(|V| \times |E|)$
- **æœ€å°ç”Ÿæˆæ ‘**:
  - Kruskal: $O(|E| \log |E|)$
  - Prim: $O((|V| + |E|) \log |V|)$

### 8.2 ç©ºé—´å¤æ‚åº¦

- **å›¾å­˜å‚¨**: $O(|V| + |E|)$
- **ç®—æ³•å·¥ä½œç©ºé—´**: $O(|V|)$ åˆ° $O(|V|^2)$

## 9. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°äº†å›¾è®ºçš„ç†è®ºåŸºç¡€ï¼ŒåŒ…æ‹¬ï¼š

1. **åŸºæœ¬æ¦‚å¿µ**: å›¾çš„å®šä¹‰ã€åŸºæœ¬æ€§è´¨ã€å›¾çš„ç±»å‹
2. **éå†ç®—æ³•**: DFSã€BFSåŠå…¶å˜ä½“
3. **æœ€çŸ­è·¯å¾„**: Dijkstraã€Floyd-Warshallã€Bellman-Fordç®—æ³•
4. **æœ€å°ç”Ÿæˆæ ‘**: Kruskalã€Primç®—æ³•
5. **ç†è®ºè¯æ˜**: åŸºæœ¬å®šç†å’Œç®—æ³•æ­£ç¡®æ€§
6. **åº”ç”¨å®ä¾‹**: ç½‘ç»œè·¯ç”±ã€ç¤¾äº¤ç½‘ç»œåˆ†æ

æ‰€æœ‰æ¦‚å¿µéƒ½æœ‰å®Œæ•´çš„Pythonå®ç°ï¼ŒåŒ…æ‹¬ï¼š

- å›¾çš„æ•°æ®ç»“æ„å’ŒåŸºæœ¬æ“ä½œ
- å„ç§å›¾ç®—æ³•çš„å®ç°
- å®é™…åº”ç”¨ç¤ºä¾‹
- æ€§èƒ½åˆ†æå’Œä¼˜åŒ–

å›¾è®ºä¸ºè®¡ç®—æœºç§‘å­¦ã€ç½‘ç»œåˆ†æã€ç®—æ³•è®¾è®¡ç­‰é¢†åŸŸæä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€å’Œå®ç”¨å·¥å…·ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*ä¸‹æ¬¡æ›´æ–°: å®Œæˆç½‘ç»œç†è®ºæ–‡æ¡£å*
