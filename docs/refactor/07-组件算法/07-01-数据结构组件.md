# 数据结构组件

## 7.1 数据结构组件

### 概念与原理

数据结构是计算机存储、组织数据的方式，是算法设计的基础。良好的数据结构选择能够显著提高程序的执行效率。

#### 核心特征

1. **逻辑结构**：数据元素之间的逻辑关系
2. **物理结构**：数据在计算机中的存储方式
3. **操作接口**：对数据结构的操作方法
4. **性能特征**：时间复杂度和空间复杂度

### 线性数据结构

#### 1. 动态数组

```python
class DynamicArray:
    def __init__(self, initial_capacity=10):
        self.capacity = initial_capacity
        self.size = 0
        self.data = [None] * initial_capacity
    
    def append(self, element):
        """添加元素到末尾"""
        if self.size >= self.capacity:
            self._resize(2 * self.capacity)
        
        self.data[self.size] = element
        self.size += 1
    
    def insert(self, index, element):
        """在指定位置插入元素"""
        if index < 0 or index > self.size:
            raise IndexError("索引超出范围")
        
        if self.size >= self.capacity:
            self._resize(2 * self.capacity)
        
        # 移动元素
        for i in range(self.size, index, -1):
            self.data[i] = self.data[i - 1]
        
        self.data[index] = element
        self.size += 1
    
    def remove(self, index):
        """删除指定位置的元素"""
        if index < 0 or index >= self.size:
            raise IndexError("索引超出范围")
        
        # 移动元素
        for i in range(index, self.size - 1):
            self.data[i] = self.data[i + 1]
        
        self.size -= 1
        
        # 如果使用率低于25%，缩小容量
        if self.size < self.capacity // 4:
            self._resize(self.capacity // 2)
    
    def get(self, index):
        """获取指定位置的元素"""
        if index < 0 or index >= self.size:
            raise IndexError("索引超出范围")
        return self.data[index]
    
    def set(self, index, element):
        """设置指定位置的元素"""
        if index < 0 or index >= self.size:
            raise IndexError("索引超出范围")
        self.data[index] = element
    
    def _resize(self, new_capacity):
        """调整数组容量"""
        new_data = [None] * new_capacity
        for i in range(self.size):
            new_data[i] = self.data[i]
        self.data = new_data
        self.capacity = new_capacity
    
    def __len__(self):
        return self.size
    
    def __str__(self):
        return str(self.data[:self.size])

def dynamic_array_example():
    """动态数组示例"""
    arr = DynamicArray(5)
    
    # 添加元素
    for i in range(10):
        arr.append(i)
        print(f"添加 {i}, 大小: {len(arr)}, 容量: {arr.capacity}")
    
    # 插入元素
    arr.insert(5, 100)
    print(f"在索引5插入100: {arr}")
    
    # 删除元素
    arr.remove(3)
    print(f"删除索引3: {arr}")
    
    return arr
```

#### 2. 链表

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    
    def append(self, data):
        """在末尾添加节点"""
        new_node = Node(data)
        
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        
        self.size += 1
    
    def prepend(self, data):
        """在开头添加节点"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    def insert(self, index, data):
        """在指定位置插入节点"""
        if index < 0 or index > self.size:
            raise IndexError("索引超出范围")
        
        if index == 0:
            self.prepend(data)
            return
        
        new_node = Node(data)
        current = self.head
        
        for i in range(index - 1):
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
        self.size += 1
    
    def remove(self, index):
        """删除指定位置的节点"""
        if index < 0 or index >= self.size:
            raise IndexError("索引超出范围")
        
        if index == 0:
            self.head = self.head.next
        else:
            current = self.head
            for i in range(index - 1):
                current = current.next
            current.next = current.next.next
        
        self.size -= 1
    
    def get(self, index):
        """获取指定位置的节点数据"""
        if index < 0 or index >= self.size:
            raise IndexError("索引超出范围")
        
        current = self.head
        for i in range(index):
            current = current.next
        
        return current.data
    
    def reverse(self):
        """反转链表"""
        prev = None
        current = self.head
        
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        
        self.head = prev
    
    def __len__(self):
        return self.size
    
    def __str__(self):
        result = []
        current = self.head
        while current:
            result.append(str(current.data))
            current = current.next
        return " -> ".join(result)

def linked_list_example():
    """链表示例"""
    linked_list = LinkedList()
    
    # 添加元素
    for i in range(5):
        linked_list.append(i)
    
    print(f"链表: {linked_list}")
    
    # 在开头添加
    linked_list.prepend(100)
    print(f"在开头添加100: {linked_list}")
    
    # 在中间插入
    linked_list.insert(3, 200)
    print(f"在索引3插入200: {linked_list}")
    
    # 反转
    linked_list.reverse()
    print(f"反转后: {linked_list}")
    
    return linked_list
```

#### 3. 栈

```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """入栈"""
        self.items.append(item)
    
    def pop(self):
        """出栈"""
        if self.is_empty():
            raise IndexError("栈为空")
        return self.items.pop()
    
    def peek(self):
        """查看栈顶元素"""
        if self.is_empty():
            raise IndexError("栈为空")
        return self.items[-1]
    
    def is_empty(self):
        """检查栈是否为空"""
        return len(self.items) == 0
    
    def size(self):
        """获取栈的大小"""
        return len(self.items)
    
    def __str__(self):
        return str(self.items)

def stack_example():
    """栈示例"""
    stack = Stack()
    
    # 入栈
    for i in range(5):
        stack.push(i)
        print(f"入栈 {i}: {stack}")
    
    # 出栈
    while not stack.is_empty():
        item = stack.pop()
        print(f"出栈 {item}: {stack}")
    
    return stack
```

#### 4. 队列

```python
from collections import deque

class Queue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        """入队"""
        self.items.append(item)
    
    def dequeue(self):
        """出队"""
        if self.is_empty():
            raise IndexError("队列为空")
        return self.items.popleft()
    
    def front(self):
        """查看队首元素"""
        if self.is_empty():
            raise IndexError("队列为空")
        return self.items[0]
    
    def is_empty(self):
        """检查队列是否为空"""
        return len(self.items) == 0
    
    def size(self):
        """获取队列的大小"""
        return len(self.items)
    
    def __str__(self):
        return str(list(self.items))

class PriorityQueue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item, priority):
        """入队（带优先级）"""
        self.items.append((priority, item))
        self.items.sort(reverse=True)  # 优先级高的在前
    
    def dequeue(self):
        """出队"""
        if self.is_empty():
            raise IndexError("优先队列为空")
        return self.items.pop()[1]
    
    def is_empty(self):
        """检查优先队列是否为空"""
        return len(self.items) == 0
    
    def size(self):
        """获取优先队列的大小"""
        return len(self.items)

def queue_example():
    """队列示例"""
    queue = Queue()
    
    # 入队
    for i in range(5):
        queue.enqueue(i)
        print(f"入队 {i}: {queue}")
    
    # 出队
    while not queue.is_empty():
        item = queue.dequeue()
        print(f"出队 {item}: {queue}")
    
    # 优先队列
    pq = PriorityQueue()
    pq.enqueue("任务1", 3)
    pq.enqueue("任务2", 1)
    pq.enqueue("任务3", 5)
    
    print("优先队列:")
    while not pq.is_empty():
        task = pq.dequeue()
        print(f"执行任务: {task}")
    
    return queue, pq
```

### 树形数据结构

#### 1. 二叉树

```python
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinaryTree:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        """插入节点"""
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self._insert_recursive(self.root, data)
    
    def _insert_recursive(self, node, data):
        """递归插入"""
        if data < node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self._insert_recursive(node.left, data)
        else:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self._insert_recursive(node.right, data)
    
    def inorder_traversal(self):
        """中序遍历"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        """递归中序遍历"""
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.data)
            self._inorder_recursive(node.right, result)
    
    def preorder_traversal(self):
        """前序遍历"""
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node, result):
        """递归前序遍历"""
        if node:
            result.append(node.data)
            self._preorder_recursive(node.left, result)
            self._preorder_recursive(node.right, result)
    
    def postorder_traversal(self):
        """后序遍历"""
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node, result):
        """递归后序遍历"""
        if node:
            self._postorder_recursive(node.left, result)
            self._postorder_recursive(node.right, result)
            result.append(node.data)
    
    def level_order_traversal(self):
        """层序遍历"""
        if self.root is None:
            return []
        
        result = []
        queue = [self.root]
        
        while queue:
            level = []
            level_size = len(queue)
            
            for i in range(level_size):
                node = queue.pop(0)
                level.append(node.data)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(level)
        
        return result
    
    def height(self):
        """计算树的高度"""
        return self._height_recursive(self.root)
    
    def _height_recursive(self, node):
        """递归计算高度"""
        if node is None:
            return 0
        return max(self._height_recursive(node.left), 
                  self._height_recursive(node.right)) + 1

def binary_tree_example():
    """二叉树示例"""
    tree = BinaryTree()
    
    # 插入节点
    values = [5, 3, 7, 2, 4, 6, 8]
    for value in values:
        tree.insert(value)
    
    print(f"中序遍历: {tree.inorder_traversal()}")
    print(f"前序遍历: {tree.preorder_traversal()}")
    print(f"后序遍历: {tree.postorder_traversal()}")
    print(f"层序遍历: {tree.level_order_traversal()}")
    print(f"树的高度: {tree.height()}")
    
    return tree
```

#### 2. 堆

```python
class MinHeap:
    def __init__(self):
        self.heap = []
    
    def parent(self, index):
        """获取父节点索引"""
        return (index - 1) // 2
    
    def left_child(self, index):
        """获取左子节点索引"""
        return 2 * index + 1
    
    def right_child(self, index):
        """获取右子节点索引"""
        return 2 * index + 2
    
    def has_parent(self, index):
        """检查是否有父节点"""
        return self.parent(index) >= 0
    
    def has_left_child(self, index):
        """检查是否有左子节点"""
        return self.left_child(index) < len(self.heap)
    
    def has_right_child(self, index):
        """检查是否有右子节点"""
        return self.right_child(index) < len(self.heap)
    
    def swap(self, index1, index2):
        """交换两个元素"""
        self.heap[index1], self.heap[index2] = self.heap[index2], self.heap[index1]
    
    def peek(self):
        """查看堆顶元素"""
        if len(self.heap) == 0:
            raise IndexError("堆为空")
        return self.heap[0]
    
    def push(self, value):
        """添加元素"""
        self.heap.append(value)
        self._heapify_up()
    
    def pop(self):
        """删除堆顶元素"""
        if len(self.heap) == 0:
            raise IndexError("堆为空")
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        item = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down()
        
        return item
    
    def _heapify_up(self):
        """向上调整"""
        index = len(self.heap) - 1
        while self.has_parent(index) and self.heap[self.parent(index)] > self.heap[index]:
            self.swap(self.parent(index), index)
            index = self.parent(index)
    
    def _heapify_down(self):
        """向下调整"""
        index = 0
        while self.has_left_child(index):
            smaller_child_index = self.left_child(index)
            if (self.has_right_child(index) and 
                self.heap[self.right_child(index)] < self.heap[self.left_child(index)]):
                smaller_child_index = self.right_child(index)
            
            if self.heap[index] < self.heap[smaller_child_index]:
                break
            else:
                self.swap(index, smaller_child_index)
            index = smaller_child_index
    
    def size(self):
        """获取堆的大小"""
        return len(self.heap)
    
    def is_empty(self):
        """检查堆是否为空"""
        return len(self.heap) == 0

def heap_example():
    """堆示例"""
    heap = MinHeap()
    
    # 添加元素
    values = [5, 3, 7, 2, 4, 6, 8]
    for value in values:
        heap.push(value)
        print(f"添加 {value}, 堆: {heap.heap}")
    
    # 删除元素
    print("删除堆顶元素:")
    while not heap.is_empty():
        item = heap.pop()
        print(f"删除 {item}, 堆: {heap.heap}")
    
    return heap
```

### 图数据结构

#### 1. 邻接表表示

```python
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
        self.vertices = set()
    
    def add_edge(self, u, v, weight=1):
        """添加边"""
        self.graph[u].append((v, weight))
        self.vertices.add(u)
        self.vertices.add(v)
    
    def remove_edge(self, u, v):
        """删除边"""
        if u in self.graph:
            self.graph[u] = [(vertex, weight) for vertex, weight in self.graph[u] if vertex != v]
    
    def get_neighbors(self, vertex):
        """获取邻居节点"""
        return self.graph[vertex]
    
    def get_vertices(self):
        """获取所有顶点"""
        return list(self.vertices)
    
    def get_edges(self):
        """获取所有边"""
        edges = []
        for vertex in self.graph:
            for neighbor, weight in self.graph[vertex]:
                edges.append((vertex, neighbor, weight))
        return edges
    
    def dfs(self, start_vertex):
        """深度优先搜索"""
        visited = set()
        result = []
        
        def dfs_recursive(vertex):
            visited.add(vertex)
            result.append(vertex)
            
            for neighbor, _ in self.graph[vertex]:
                if neighbor not in visited:
                    dfs_recursive(neighbor)
        
        if start_vertex in self.vertices:
            dfs_recursive(start_vertex)
        
        return result
    
    def bfs(self, start_vertex):
        """广度优先搜索"""
        visited = set()
        result = []
        queue = [start_vertex]
        visited.add(start_vertex)
        
        while queue:
            vertex = queue.pop(0)
            result.append(vertex)
            
            for neighbor, _ in self.graph[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return result
    
    def has_cycle(self):
        """检测是否有环"""
        visited = set()
        rec_stack = set()
        
        def has_cycle_recursive(vertex):
            visited.add(vertex)
            rec_stack.add(vertex)
            
            for neighbor, _ in self.graph[vertex]:
                if neighbor not in visited:
                    if has_cycle_recursive(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(vertex)
            return False
        
        for vertex in self.vertices:
            if vertex not in visited:
                if has_cycle_recursive(vertex):
                    return True
        
        return False

def graph_example():
    """图示例"""
    graph = Graph()
    
    # 添加边
    edges = [(0, 1), (0, 2), (1, 3), (2, 3), (2, 4), (3, 4)]
    for u, v in edges:
        graph.add_edge(u, v)
    
    print(f"顶点: {graph.get_vertices()}")
    print(f"边: {graph.get_edges()}")
    print(f"DFS遍历: {graph.dfs(0)}")
    print(f"BFS遍历: {graph.bfs(0)}")
    print(f"是否有环: {graph.has_cycle()}")
    
    return graph
```

### 哈希表

#### 1. 哈希表实现

```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
        self.count = 0
    
    def _hash(self, key):
        """哈希函数"""
        return hash(key) % self.size
    
    def put(self, key, value):
        """插入键值对"""
        hash_value = self._hash(key)
        
        # 检查是否已存在相同的键
        for i, (k, v) in enumerate(self.table[hash_value]):
            if k == key:
                self.table[hash_value][i] = (key, value)
                return
        
        # 添加新的键值对
        self.table[hash_value].append((key, value))
        self.count += 1
        
        # 如果负载因子超过0.7，进行扩容
        if self.count / self.size > 0.7:
            self._resize(2 * self.size)
    
    def get(self, key):
        """获取值"""
        hash_value = self._hash(key)
        
        for k, v in self.table[hash_value]:
            if k == key:
                return v
        
        raise KeyError(f"键 '{key}' 不存在")
    
    def remove(self, key):
        """删除键值对"""
        hash_value = self._hash(key)
        
        for i, (k, v) in enumerate(self.table[hash_value]):
            if k == key:
                del self.table[hash_value][i]
                self.count -= 1
                return
        
        raise KeyError(f"键 '{key}' 不存在")
    
    def contains(self, key):
        """检查是否包含键"""
        hash_value = self._hash(key)
        
        for k, v in self.table[hash_value]:
            if k == key:
                return True
        
        return False
    
    def _resize(self, new_size):
        """调整哈希表大小"""
        old_table = self.table
        self.table = [[] for _ in range(new_size)]
        self.size = new_size
        self.count = 0
        
        for bucket in old_table:
            for key, value in bucket:
                self.put(key, value)
    
    def __len__(self):
        return self.count
    
    def __str__(self):
        result = []
        for i, bucket in enumerate(self.table):
            if bucket:
                result.append(f"桶 {i}: {bucket}")
        return "\n".join(result)

def hash_table_example():
    """哈希表示例"""
    ht = HashTable(5)
    
    # 插入键值对
    data = [("apple", 1), ("banana", 2), ("cherry", 3), ("date", 4)]
    for key, value in data:
        ht.put(key, value)
        print(f"插入 ({key}, {value})")
        print(f"哈希表:\n{ht}\n")
    
    # 获取值
    print(f"获取 'banana': {ht.get('banana')}")
    print(f"包含 'apple': {ht.contains('apple')}")
    
    # 删除键值对
    ht.remove("cherry")
    print(f"删除 'cherry' 后:\n{ht}")
    
    return ht
```

### 性能分析

#### 1. 时间复杂度对比

```python
def performance_analysis():
    """性能分析"""
    import time
    
    # 测试动态数组
    print("=== 动态数组性能测试 ===")
    arr = DynamicArray()
    
    start_time = time.time()
    for i in range(10000):
        arr.append(i)
    end_time = time.time()
    print(f"动态数组插入10000个元素: {end_time - start_time:.4f}秒")
    
    start_time = time.time()
    for i in range(1000):
        arr.get(i)
    end_time = time.time()
    print(f"动态数组访问1000次: {end_time - start_time:.4f}秒")
    
    # 测试链表
    print("\n=== 链表性能测试 ===")
    linked_list = LinkedList()
    
    start_time = time.time()
    for i in range(10000):
        linked_list.append(i)
    end_time = time.time()
    print(f"链表插入10000个元素: {end_time - start_time:.4f}秒")
    
    start_time = time.time()
    for i in range(1000):
        linked_list.get(i)
    end_time = time.time()
    print(f"链表访问1000次: {end_time - start_time:.4f}秒")
    
    # 测试哈希表
    print("\n=== 哈希表性能测试 ===")
    ht = HashTable()
    
    start_time = time.time()
    for i in range(10000):
        ht.put(f"key{i}", i)
    end_time = time.time()
    print(f"哈希表插入10000个元素: {end_time - start_time:.4f}秒")
    
    start_time = time.time()
    for i in range(1000):
        ht.get(f"key{i}")
    end_time = time.time()
    print(f"哈希表访问1000次: {end_time - start_time:.4f}秒")

# 运行示例
if __name__ == "__main__":
    print("=== 数据结构组件实战示例 ===")
    
    # 动态数组
    print("\n1. 动态数组")
    arr = dynamic_array_example()
    
    # 链表
    print("\n2. 链表")
    linked_list = linked_list_example()
    
    # 栈
    print("\n3. 栈")
    stack = stack_example()
    
    # 队列
    print("\n4. 队列")
    queue, pq = queue_example()
    
    # 二叉树
    print("\n5. 二叉树")
    tree = binary_tree_example()
    
    # 堆
    print("\n6. 堆")
    heap = heap_example()
    
    # 图
    print("\n7. 图")
    graph = graph_example()
    
    # 哈希表
    print("\n8. 哈希表")
    ht = hash_table_example()
    
    # 性能分析
    print("\n9. 性能分析")
    performance_analysis()
    
    print("\n数据结构组件实战完成！")
```

### 理论总结

数据结构是算法设计的基础，不同的数据结构适用于不同的应用场景。动态数组适合随机访问，链表适合频繁插入删除，栈和队列适合特定操作模式，树适合层次结构，图适合复杂关系，哈希表适合快速查找。合理选择数据结构能够显著提高程序的执行效率。
