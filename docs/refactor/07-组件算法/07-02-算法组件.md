# 算法组件

## 7.2 算法组件

### 概念与原理

算法是解决特定问题的一系列步骤，是计算机科学的核心。良好的算法设计能够高效地解决复杂问题。

#### 核心特征
1. **正确性**：算法能够正确解决问题
2. **效率**：算法的时间和空间复杂度
3. **可读性**：算法的可理解和可维护性
4. **健壮性**：算法对异常情况的处理能力

### 排序算法

#### 1. 冒泡排序
```python
def bubble_sort(arr):
    """冒泡排序"""
    n = len(arr)
    for i in range(n):
        # 标记是否发生交换
        swapped = False
        
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # 如果没有发生交换，说明已经有序
        if not swapped:
            break
    
    return arr

def bubble_sort_optimized(arr):
    """优化的冒泡排序"""
    n = len(arr)
    last_swap = n - 1
    
    for i in range(n):
        swapped = False
        current_last_swap = 0
        
        for j in range(last_swap):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
                current_last_swap = j
        
        last_swap = current_last_swap
        
        if not swapped:
            break
    
    return arr
```

#### 2. 选择排序
```python
def selection_sort(arr):
    """选择排序"""
    n = len(arr)
    
    for i in range(n):
        # 找到最小元素的索引
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 交换元素
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```

#### 3. 插入排序
```python
def insertion_sort(arr):
    """插入排序"""
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        # 将比key大的元素向后移动
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr

def binary_insertion_sort(arr):
    """二分插入排序"""
    for i in range(1, len(arr)):
        key = arr[i]
        
        # 使用二分查找找到插入位置
        left, right = 0, i
        while left < right:
            mid = (left + right) // 2
            if arr[mid] <= key:
                left = mid + 1
            else:
                right = mid
        
        # 移动元素
        for j in range(i, left, -1):
            arr[j] = arr[j - 1]
        
        arr[left] = key
    
    return arr
```

#### 4. 归并排序
```python
def merge_sort(arr):
    """归并排序"""
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    """合并两个有序数组"""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

def merge_sort_inplace(arr, left=0, right=None):
    """原地归并排序"""
    if right is None:
        right = len(arr) - 1
    
    if left < right:
        mid = (left + right) // 2
        merge_sort_inplace(arr, left, mid)
        merge_sort_inplace(arr, mid + 1, right)
        merge_inplace(arr, left, mid, right)

def merge_inplace(arr, left, mid, right):
    """原地合并"""
    # 创建临时数组
    temp = arr[left:right + 1]
    
    i = 0  # 左半部分索引
    j = mid - left + 1  # 右半部分索引
    k = left  # 原数组索引
    
    while i <= mid - left and j <= right - left:
        if temp[i] <= temp[j]:
            arr[k] = temp[i]
            i += 1
        else:
            arr[k] = temp[j]
            j += 1
        k += 1
    
    # 复制剩余元素
    while i <= mid - left:
        arr[k] = temp[i]
        i += 1
        k += 1
    
    while j <= right - left:
        arr[k] = temp[j]
        j += 1
        k += 1
```

#### 5. 快速排序
```python
def quick_sort(arr):
    """快速排序"""
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

def quick_sort_inplace(arr, low=0, high=None):
    """原地快速排序"""
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        pivot_index = partition(arr, low, high)
        quick_sort_inplace(arr, low, pivot_index - 1)
        quick_sort_inplace(arr, pivot_index + 1, high)

def partition(arr, low, high):
    """分区函数"""
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quick_sort_three_way(arr, low=0, high=None):
    """三路快速排序"""
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        lt, gt = partition_three_way(arr, low, high)
        quick_sort_three_way(arr, low, lt - 1)
        quick_sort_three_way(arr, gt + 1, high)

def partition_three_way(arr, low, high):
    """三路分区"""
    pivot = arr[low]
    lt = low
    gt = high
    i = low + 1
    
    while i <= gt:
        if arr[i] < pivot:
            arr[lt], arr[i] = arr[i], arr[lt]
            lt += 1
            i += 1
        elif arr[i] > pivot:
            arr[gt], arr[i] = arr[i], arr[gt]
            gt -= 1
        else:
            i += 1
    
    return lt, gt
```

#### 6. 堆排序
```python
def heap_sort(arr):
    """堆排序"""
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 逐个提取堆顶元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, n, i):
    """维护堆性质"""
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

### 搜索算法

#### 1. 线性搜索
```python
def linear_search(arr, target):
    """线性搜索"""
    for i, element in enumerate(arr):
        if element == target:
            return i
    return -1

def linear_search_sentinel(arr, target):
    """哨兵线性搜索"""
    n = len(arr)
    last = arr[n - 1]
    arr[n - 1] = target
    
    i = 0
    while arr[i] != target:
        i += 1
    
    arr[n - 1] = last
    
    if i < n - 1 or arr[n - 1] == target:
        return i
    else:
        return -1
```

#### 2. 二分搜索
```python
def binary_search(arr, target):
    """二分搜索（迭代）"""
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

def binary_search_recursive(arr, target, left=0, right=None):
    """二分搜索（递归）"""
    if right is None:
        right = len(arr) - 1
    
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

def binary_search_first(arr, target):
    """查找第一个等于目标值的元素"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid
            right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

def binary_search_last(arr, target):
    """查找最后一个等于目标值的元素"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result
```

#### 3. 深度优先搜索（DFS）
```python
def dfs_recursive(graph, start, visited=None):
    """递归深度优先搜索"""
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=" ")
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

def dfs_iterative(graph, start):
    """迭代深度优先搜索"""
    visited = set()
    stack = [start]
    
    while stack:
        vertex = stack.pop()
        
        if vertex not in visited:
            visited.add(vertex)
            print(vertex, end=" ")
            
            # 将未访问的邻居压入栈中
            for neighbor in reversed(graph[vertex]):
                if neighbor not in visited:
                    stack.append(neighbor)
```

#### 4. 广度优先搜索（BFS）
```python
from collections import deque

def bfs(graph, start):
    """广度优先搜索"""
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=" ")
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

def bfs_shortest_path(graph, start, end):
    """BFS求最短路径"""
    if start == end:
        return [start]
    
    visited = set()
    queue = deque([(start, [start])])
    visited.add(start)
    
    while queue:
        vertex, path = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor == end:
                return path + [neighbor]
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None
```

### 图算法

#### 1. Dijkstra最短路径算法
```python
import heapq

def dijkstra(graph, start):
    """Dijkstra最短路径算法"""
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    pq = [(0, start)]
    previous = {}
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)
        
        if current_distance > distances[current_vertex]:
            continue
        
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(pq, (distance, neighbor))
    
    return distances, previous

def get_shortest_path(previous, start, end):
    """获取最短路径"""
    path = []
    current = end
    
    while current is not None:
        path.append(current)
        current = previous.get(current)
    
    path.reverse()
    
    if path[0] == start:
        return path
    else:
        return None
```

#### 2. Floyd-Warshall算法
```python
def floyd_warshall(graph):
    """Floyd-Warshall算法"""
    vertices = list(graph.keys())
    n = len(vertices)
    
    # 初始化距离矩阵
    dist = [[float('infinity')] * n for _ in range(n)]
    for i in range(n):
        dist[i][i] = 0
    
    # 填充初始距离
    for u in vertices:
        for v, weight in graph[u].items():
            i, j = vertices.index(u), vertices.index(v)
            dist[i][j] = weight
    
    # Floyd-Warshall核心算法
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist
```

#### 3. 拓扑排序
```python
def topological_sort(graph):
    """拓扑排序"""
    in_degree = {vertex: 0 for vertex in graph}
    
    # 计算入度
    for vertex in graph:
        for neighbor in graph[vertex]:
            in_degree[neighbor] += 1
    
    # 使用队列进行拓扑排序
    queue = deque([vertex for vertex in graph if in_degree[vertex] == 0])
    result = []
    
    while queue:
        vertex = queue.popleft()
        result.append(vertex)
        
        for neighbor in graph[vertex]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    if len(result) != len(graph):
        return None  # 存在环
    
    return result
```

### 动态规划

#### 1. 斐波那契数列
```python
def fibonacci_recursive(n):
    """递归斐波那契"""
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

def fibonacci_dp(n):
    """动态规划斐波那契"""
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]

def fibonacci_optimized(n):
    """优化的斐波那契"""
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b
```

#### 2. 最长公共子序列（LCS）
```python
def lcs_recursive(text1, text2, i, j):
    """递归LCS"""
    if i == 0 or j == 0:
        return 0
    
    if text1[i - 1] == text2[j - 1]:
        return 1 + lcs_recursive(text1, text2, i - 1, j - 1)
    else:
        return max(lcs_recursive(text1, text2, i - 1, j),
                  lcs_recursive(text1, text2, i, j - 1))

def lcs_dp(text1, text2):
    """动态规划LCS"""
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]

def lcs_optimized(text1, text2):
    """优化的LCS"""
    m, n = len(text1), len(text2)
    
    if m < n:
        text1, text2 = text2, text1
        m, n = n, m
    
    dp = [0] * (n + 1)
    
    for i in range(1, m + 1):
        prev = 0
        for j in range(1, n + 1):
            temp = dp[j]
            if text1[i - 1] == text2[j - 1]:
                dp[j] = prev + 1
            else:
                dp[j] = max(dp[j], dp[j - 1])
            prev = temp
    
    return dp[n]
```

#### 3. 背包问题
```python
def knapsack_01(weights, values, capacity):
    """0-1背包问题"""
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w],
                              dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]
    
    return dp[n][capacity]

def knapsack_01_optimized(weights, values, capacity):
    """优化的0-1背包问题"""
    n = len(weights)
    dp = [0] * (capacity + 1)
    
    for i in range(n):
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]
```

### 贪心算法

#### 1. 活动选择问题
```python
def activity_selection(start_times, finish_times):
    """活动选择问题"""
    n = len(start_times)
    
    # 按结束时间排序
    activities = list(zip(start_times, finish_times))
    activities.sort(key=lambda x: x[1])
    
    selected = [0]  # 选择第一个活动
    last_finish = activities[0][1]
    
    for i in range(1, n):
        if activities[i][0] >= last_finish:
            selected.append(i)
            last_finish = activities[i][1]
    
    return selected
```

#### 2. Huffman编码
```python
import heapq

class HuffmanNode:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None
    
    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(char_freq):
    """构建Huffman树"""
    heap = [HuffmanNode(char, freq) for char, freq in char_freq.items()]
    heapq.heapify(heap)
    
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        
        internal = HuffmanNode(None, left.freq + right.freq)
        internal.left = left
        internal.right = right
        
        heapq.heappush(heap, internal)
    
    return heap[0]

def generate_huffman_codes(root, code="", codes=None):
    """生成Huffman编码"""
    if codes is None:
        codes = {}
    
    if root is None:
        return
    
    if root.char is not None:
        codes[root.char] = code
    
    generate_huffman_codes(root.left, code + "0", codes)
    generate_huffman_codes(root.right, code + "1", codes)
    
    return codes
```

### 分治算法

#### 1. 归并排序（已实现）
#### 2. 快速排序（已实现）
#### 3. 最近点对问题
```python
import math

def closest_pair(points):
    """最近点对问题"""
    n = len(points)
    
    if n <= 3:
        return brute_force_closest_pair(points)
    
    # 按x坐标排序
    points.sort(key=lambda p: p[0])
    
    mid = n // 2
    left_points = points[:mid]
    right_points = points[mid:]
    
    # 递归求解左右两边的最近点对
    left_min = closest_pair(left_points)
    right_min = closest_pair(right_points)
    
    min_distance = min(left_min, right_min)
    
    # 检查跨越中线的点对
    strip_min = closest_pair_strip(points, mid, min_distance)
    
    return min(min_distance, strip_min)

def brute_force_closest_pair(points):
    """暴力求解最近点对"""
    min_distance = float('infinity')
    
    for i in range(len(points)):
        for j in range(i + 1, len(points)):
            distance = math.sqrt((points[i][0] - points[j][0])**2 + 
                               (points[i][1] - points[j][1])**2)
            min_distance = min(min_distance, distance)
    
    return min_distance

def closest_pair_strip(points, mid, min_distance):
    """检查跨越中线的最近点对"""
    mid_x = points[mid][0]
    strip = []
    
    for point in points:
        if abs(point[0] - mid_x) < min_distance:
            strip.append(point)
    
    # 按y坐标排序
    strip.sort(key=lambda p: p[1])
    
    strip_min = min_distance
    
    for i in range(len(strip)):
        for j in range(i + 1, min(i + 7, len(strip))):
            distance = math.sqrt((strip[i][0] - strip[j][0])**2 + 
                               (strip[i][1] - strip[j][1])**2)
            strip_min = min(strip_min, distance)
    
    return strip_min
```

### 性能测试与比较

```python
import time
import random

def performance_test():
    """算法性能测试"""
    # 生成测试数据
    sizes = [100, 1000, 10000]
    
    for size in sizes:
        print(f"\n=== 测试数据大小: {size} ===")
        
        # 生成随机数组
        arr = [random.randint(1, 1000) for _ in range(size)]
        
        # 测试排序算法
        sorting_algorithms = [
            ("冒泡排序", lambda x: bubble_sort(x.copy())),
            ("选择排序", lambda x: selection_sort(x.copy())),
            ("插入排序", lambda x: insertion_sort(x.copy())),
            ("归并排序", lambda x: merge_sort(x.copy())),
            ("快速排序", lambda x: quick_sort(x.copy())),
            ("堆排序", lambda x: heap_sort(x.copy())),
        ]
        
        for name, algorithm in sorting_algorithms:
            start_time = time.time()
            algorithm(arr)
            end_time = time.time()
            print(f"{name}: {end_time - start_time:.4f}秒")
        
        # 测试搜索算法
        sorted_arr = sorted(arr)
        target = random.choice(sorted_arr)
        
        search_algorithms = [
            ("线性搜索", lambda x, t: linear_search(x, t)),
            ("二分搜索", lambda x, t: binary_search(x, t)),
        ]
        
        for name, algorithm in search_algorithms:
            start_time = time.time()
            algorithm(sorted_arr, target)
            end_time = time.time()
            print(f"{name}: {end_time - start_time:.6f}秒")

# 运行示例
if __name__ == "__main__":
    print("=== 算法组件实战示例 ===")
    
    # 排序算法测试
    test_arr = [64, 34, 25, 12, 22, 11, 90]
    print(f"原始数组: {test_arr}")
    
    print(f"冒泡排序: {bubble_sort(test_arr.copy())}")
    print(f"选择排序: {selection_sort(test_arr.copy())}")
    print(f"插入排序: {insertion_sort(test_arr.copy())}")
    print(f"归并排序: {merge_sort(test_arr.copy())}")
    print(f"快速排序: {quick_sort(test_arr.copy())}")
    print(f"堆排序: {heap_sort(test_arr.copy())}")
    
    # 搜索算法测试
    sorted_arr = sorted(test_arr)
    target = 22
    print(f"\n在 {sorted_arr} 中搜索 {target}")
    print(f"线性搜索索引: {linear_search(sorted_arr, target)}")
    print(f"二分搜索索引: {binary_search(sorted_arr, target)}")
    
    # 图算法测试
    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }
    
    print(f"\n图: {graph}")
    print("DFS遍历:", end=" ")
    dfs_recursive(graph, 'A')
    print()
    
    print("BFS遍历:", end=" ")
    bfs(graph, 'A')
    print()
    
    # 动态规划测试
    n = 10
    print(f"\n斐波那契数列第{n}项:")
    print(f"递归: {fibonacci_recursive(n)}")
    print(f"动态规划: {fibonacci_dp(n)}")
    print(f"优化版本: {fibonacci_optimized(n)}")
    
    # 性能测试
    print("\n=== 性能测试 ===")
    performance_test()
    
    print("\n算法组件实战完成！")
```

### 理论总结

算法是计算机科学的核心，不同的算法适用于不同的问题场景。排序算法中，快速排序和归并排序是高效的通用排序算法；搜索算法中，二分搜索在有序数据上表现优异；图算法能够解决复杂的网络和路径问题；动态规划适用于具有重叠子问题的问题；贪心算法适用于具有贪心选择性质的问题；分治算法能够将复杂问题分解为简单子问题。合理选择算法能够显著提高程序的执行效率。 