# 电子商务领域架构设计

## 目录

1. [领域概述](#1-领域概述)
2. [核心架构模式](#2-核心架构模式)
3. [业务建模](#3-业务建模)
4. [数据建模](#4-数据建模)
5. [技术实现](#5-技术实现)
6. [质量属性](#6-质量属性)
7. [最佳实践](#7-最佳实践)

## 1. 领域概述

### 1.1 电子商务定义

电子商务系统是一个复杂的分布式系统，涉及商品管理、订单处理、支付结算、库存管理等多个业务领域。

**形式化定义**：

```python
from typing import Set, Dict, List, Optional, Protocol
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
import uuid

@dataclass
class ECommerceDomain:
    """电子商务领域模型"""
    
    # 核心实体集合
    products: Set['Product']
    customers: Set['Customer'] 
    orders: Set['Order']
    payments: Set['Payment']
    inventory: Set['InventoryItem']
    
    # 业务规则
    business_rules: Set['BusinessRule']
    
    # 约束条件
    constraints: Set['Constraint']
    
    def validate_domain_integrity(self) -> bool:
        """验证领域完整性"""
        return all(
            rule.validate(self) 
            for rule in self.business_rules
        )

class BusinessRule(Protocol):
    """业务规则接口"""
    def validate(self, domain: ECommerceDomain) -> bool: ...
```

### 1.2 核心概念

**商品管理**：
```python
@dataclass
class Product:
    """商品实体"""
    id: str
    name: str
    description: str
    price: Decimal
    category: str
    attributes: Dict[str, str]
    status: 'ProductStatus'
    created_at: datetime
    updated_at: datetime
    
    def is_available(self) -> bool:
        """检查商品是否可售"""
        return self.status == ProductStatus.ACTIVE
    
    def update_price(self, new_price: Decimal) -> None:
        """更新价格"""
        if new_price <= 0:
            raise ValueError("价格必须大于0")
        self.price = new_price
        self.updated_at = datetime.now()

class ProductStatus:
    """商品状态枚举"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    OUT_OF_STOCK = "out_of_stock"
    DISCONTINUED = "discontinued"
```

**订单处理**：
```python
@dataclass
class Order:
    """订单实体"""
    id: str
    customer_id: str
    items: List['OrderItem']
    total_amount: Decimal
    status: 'OrderStatus'
    payment_status: 'PaymentStatus'
    shipping_address: 'Address'
    created_at: datetime
    updated_at: datetime
    
    def calculate_total(self) -> Decimal:
        """计算订单总额"""
        return sum(item.subtotal for item in self.items)
    
    def can_cancel(self) -> bool:
        """检查订单是否可以取消"""
        return self.status in [OrderStatus.PENDING, OrderStatus.CONFIRMED]
    
    def apply_discount(self, discount: 'Discount') -> None:
        """应用折扣"""
        if discount.is_valid():
            self.total_amount = discount.apply(self.total_amount)
            self.updated_at = datetime.now()

@dataclass
class OrderItem:
    """订单项"""
    product_id: str
    quantity: int
    unit_price: Decimal
    subtotal: Decimal
    
    def __post_init__(self):
        """初始化后计算小计"""
        self.subtotal = self.quantity * self.unit_price
```

## 2. 核心架构模式

### 2.1 微服务架构

**服务分解策略**：

```python
from enum import Enum
from typing import List, Dict, Any

class ServiceBoundary(Enum):
    """服务边界定义"""
    PRODUCT_CATALOG = "product-catalog"
    ORDER_MANAGEMENT = "order-management"
    PAYMENT_PROCESSING = "payment-processing"
    INVENTORY_MANAGEMENT = "inventory-management"
    USER_MANAGEMENT = "user-management"
    NOTIFICATION = "notification"

@dataclass
class MicroserviceArchitecture:
    """微服务架构模型"""
    
    services: Dict[ServiceBoundary, 'Service']
    api_gateway: 'APIGateway'
    service_registry: 'ServiceRegistry'
    message_broker: 'MessageBroker'
    
    def get_service_dependencies(self) -> Dict[str, List[str]]:
        """获取服务依赖关系"""
        dependencies = {}
        for service_name, service in self.services.items():
            dependencies[service_name.value] = [
                dep.value for dep in service.dependencies
            ]
        return dependencies
    
    def validate_architecture(self) -> bool:
        """验证架构设计"""
        # 检查循环依赖
        return not self._has_circular_dependencies()
    
    def _has_circular_dependencies(self) -> bool:
        """检查是否存在循环依赖"""
        visited = set()
        rec_stack = set()
        
        def dfs(service_name: str) -> bool:
            visited.add(service_name)
            rec_stack.add(service_name)
            
            for dep in self.services[ServiceBoundary(service_name)].dependencies:
                if dep.value not in visited:
                    if dfs(dep.value):
                        return True
                elif dep.value in rec_stack:
                    return True
            
            rec_stack.remove(service_name)
            return False
        
        for service_name in self.services:
            if service_name.value not in visited:
                if dfs(service_name.value):
                    return True
        return False

@dataclass
class Service:
    """微服务定义"""
    name: str
    boundary: ServiceBoundary
    responsibilities: List[str]
    dependencies: List[ServiceBoundary]
    api_endpoints: List['APIEndpoint']
    data_stores: List['DataStore']
    
    def get_coupling_score(self) -> float:
        """计算服务耦合度"""
        return len(self.dependencies) / len(ServiceBoundary)
    
    def get_cohesion_score(self) -> float:
        """计算服务内聚度"""
        # 基于职责相似性计算内聚度
        return self._calculate_responsibility_similarity()
    
    def _calculate_responsibility_similarity(self) -> float:
        """计算职责相似性"""
        # 简化的相似性计算
        return 1.0 / (1 + len(self.responsibilities))
```

### 2.2 事件驱动架构

**事件模型**：

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List

@dataclass
class DomainEvent:
    """领域事件基类"""
    event_id: str
    event_type: str
    aggregate_id: str
    version: int
    timestamp: datetime
    data: Dict[str, Any]
    
    def __post_init__(self):
        if not self.event_id:
            self.event_id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = datetime.now()

class OrderCreatedEvent(DomainEvent):
    """订单创建事件"""
    def __init__(self, order_id: str, customer_id: str, total_amount: Decimal):
        super().__init__(
            event_id="",
            event_type="OrderCreated",
            aggregate_id=order_id,
            version=1,
            timestamp=datetime.now(),
            data={
                "customer_id": customer_id,
                "total_amount": str(total_amount)
            }
        )

class PaymentProcessedEvent(DomainEvent):
    """支付处理事件"""
    def __init__(self, payment_id: str, order_id: str, amount: Decimal, status: str):
        super().__init__(
            event_id="",
            event_type="PaymentProcessed",
            aggregate_id=payment_id,
            version=1,
            timestamp=datetime.now(),
            data={
                "order_id": order_id,
                "amount": str(amount),
                "status": status
            }
        )

class EventHandler(ABC):
    """事件处理器接口"""
    
    @abstractmethod
    def handle(self, event: DomainEvent) -> None:
        """处理事件"""
        pass

class OrderEventHandler(EventHandler):
    """订单事件处理器"""
    
    def __init__(self, inventory_service: 'InventoryService'):
        self.inventory_service = inventory_service
    
    def handle(self, event: DomainEvent) -> None:
        if isinstance(event, OrderCreatedEvent):
            self._handle_order_created(event)
        elif isinstance(event, PaymentProcessedEvent):
            self._handle_payment_processed(event)
    
    def _handle_order_created(self, event: OrderCreatedEvent) -> None:
        """处理订单创建事件"""
        # 更新库存
        self.inventory_service.reserve_inventory(
            event.aggregate_id,
            event.data["items"]
        )
    
    def _handle_payment_processed(self, event: PaymentProcessedEvent) -> None:
        """处理支付完成事件"""
        if event.data["status"] == "completed":
            # 确认库存扣减
            self.inventory_service.confirm_inventory_reduction(
                event.data["order_id"]
            )

class EventBus:
    """事件总线"""
    
    def __init__(self):
        self.handlers: Dict[str, List[EventHandler]] = {}
    
    def subscribe(self, event_type: str, handler: EventHandler) -> None:
        """订阅事件"""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        self.handlers[event_type].append(handler)
    
    def publish(self, event: DomainEvent) -> None:
        """发布事件"""
        if event.event_type in self.handlers:
            for handler in self.handlers[event.event_type]:
                handler.handle(event)
```

## 3. 业务建模

### 3.1 业务流程建模

**订单处理流程**：

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class BusinessProcess(Protocol):
    """业务流程接口"""
    def execute(self, context: Dict[str, Any]) -> Dict[str, Any]: ...

class OrderProcessingWorkflow:
    """订单处理工作流"""
    
    def __init__(self):
        self.steps: List[BusinessProcess] = [
            OrderValidation(),
            InventoryCheck(),
            PaymentProcessing(),
            OrderConfirmation(),
            InventoryUpdate(),
            Notification()
        ]
    
    def execute(self, order: Order) -> Dict[str, Any]:
        """执行订单处理流程"""
        context = {"order": order, "status": "processing"}
        
        for step in self.steps:
            try:
                result = step.execute(context)
                context.update(result)
            except Exception as e:
                context["error"] = str(e)
                context["status"] = "failed"
                break
        
        return context

class OrderValidation(BusinessProcess):
    """订单验证"""
    
    def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        order = context["order"]
        
        # 验证订单项
        for item in order.items:
            if item.quantity <= 0:
                raise ValueError(f"商品 {item.product_id} 数量必须大于0")
        
        # 验证总金额
        if order.total_amount <= 0:
            raise ValueError("订单总金额必须大于0")
        
        return {"validation": "passed"}

class InventoryCheck(BusinessProcess):
    """库存检查"""
    
    def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        order = context["order"]
        
        # 检查库存可用性
        for item in order.items:
            available = self._check_inventory(item.product_id, item.quantity)
            if not available:
                raise ValueError(f"商品 {item.product_id} 库存不足")
        
        return {"inventory_check": "passed"}

class PaymentProcessing(BusinessProcess):
    """支付处理"""
    
    def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        order = context["order"]
        
        # 处理支付
        payment_result = self._process_payment(order)
        
        if payment_result["status"] == "success":
            return {"payment": "completed"}
        else:
            raise ValueError(f"支付失败: {payment_result['message']}")
    
    def _process_payment(self, order: Order) -> Dict[str, Any]:
        """处理支付逻辑"""
        # 模拟支付处理
        return {"status": "success", "transaction_id": str(uuid.uuid4())}
```

### 3.2 业务规则引擎

**规则引擎实现**：

```python
from typing import Callable, Any

class BusinessRuleEngine:
    """业务规则引擎"""
    
    def __init__(self):
        self.rules: Dict[str, Callable] = {}
    
    def register_rule(self, rule_name: str, rule_func: Callable) -> None:
        """注册业务规则"""
        self.rules[rule_name] = rule_func
    
    def execute_rules(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """执行所有规则"""
        results = {}
        
        for rule_name, rule_func in self.rules.items():
            try:
                result = rule_func(context)
                results[rule_name] = result
            except Exception as e:
                results[rule_name] = {"error": str(e)}
        
        return results

# 业务规则定义
def minimum_order_amount_rule(context: Dict[str, Any]) -> Dict[str, Any]:
    """最小订单金额规则"""
    order = context["order"]
    min_amount = Decimal("10.00")
    
    if order.total_amount < min_amount:
        return {
            "valid": False,
            "message": f"订单金额必须大于 {min_amount}"
        }
    
    return {"valid": True}

def customer_credit_check_rule(context: Dict[str, Any]) -> Dict[str, Any]:
    """客户信用检查规则"""
    customer_id = context["order"].customer_id
    
    # 模拟信用检查
    credit_score = get_customer_credit_score(customer_id)
    
    if credit_score < 600:
        return {
            "valid": False,
            "message": "客户信用评分不足"
        }
    
    return {"valid": True, "credit_score": credit_score}

def get_customer_credit_score(customer_id: str) -> int:
    """获取客户信用评分"""
    # 模拟实现
    return 750
```

## 4. 数据建模

### 4.1 数据模型设计

**实体关系模型**：

```python
from sqlalchemy import Column, String, Integer, Decimal, DateTime, ForeignKey, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class ProductModel(Base):
    """商品数据模型"""
    __tablename__ = 'products'
    
    id = Column(String(36), primary_key=True)
    name = Column(String(255), nullable=False)
    description = Column(String(1000))
    price = Column(Decimal(10, 2), nullable=False)
    category = Column(String(100), nullable=False)
    status = Column(Enum(ProductStatus), nullable=False)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime, nullable=False)
    
    # 关系
    order_items = relationship("OrderItemModel", back_populates="product")
    inventory_items = relationship("InventoryItemModel", back_populates="product")

class CustomerModel(Base):
    """客户数据模型"""
    __tablename__ = 'customers'
    
    id = Column(String(36), primary_key=True)
    email = Column(String(255), unique=True, nullable=False)
    name = Column(String(255), nullable=False)
    phone = Column(String(20))
    address = Column(String(500))
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime, nullable=False)
    
    # 关系
    orders = relationship("OrderModel", back_populates="customer")

class OrderModel(Base):
    """订单数据模型"""
    __tablename__ = 'orders'
    
    id = Column(String(36), primary_key=True)
    customer_id = Column(String(36), ForeignKey('customers.id'), nullable=False)
    total_amount = Column(Decimal(10, 2), nullable=False)
    status = Column(Enum(OrderStatus), nullable=False)
    payment_status = Column(Enum(PaymentStatus), nullable=False)
    created_at = Column(DateTime, nullable=False)
    updated_at = Column(DateTime, nullable=False)
    
    # 关系
    customer = relationship("CustomerModel", back_populates="orders")
    items = relationship("OrderItemModel", back_populates="order")
    payments = relationship("PaymentModel", back_populates="order")

class OrderItemModel(Base):
    """订单项数据模型"""
    __tablename__ = 'order_items'
    
    id = Column(String(36), primary_key=True)
    order_id = Column(String(36), ForeignKey('orders.id'), nullable=False)
    product_id = Column(String(36), ForeignKey('products.id'), nullable=False)
    quantity = Column(Integer, nullable=False)
    unit_price = Column(Decimal(10, 2), nullable=False)
    subtotal = Column(Decimal(10, 2), nullable=False)
    
    # 关系
    order = relationship("OrderModel", back_populates="items")
    product = relationship("ProductModel", back_populates="order_items")
```

### 4.2 数据访问层

**仓储模式实现**：

```python
from abc import ABC, abstractmethod
from typing import List, Optional, TypeVar, Generic
from sqlalchemy.orm import Session

T = TypeVar('T')

class Repository(ABC, Generic[T]):
    """仓储接口"""
    
    @abstractmethod
    def save(self, entity: T) -> T:
        """保存实体"""
        pass
    
    @abstractmethod
    def find_by_id(self, id: str) -> Optional[T]:
        """根据ID查找"""
        pass
    
    @abstractmethod
    def find_all(self) -> List[T]:
        """查找所有"""
        pass
    
    @abstractmethod
    def delete(self, id: str) -> bool:
        """删除实体"""
        pass

class ProductRepository(Repository[Product]):
    """商品仓储实现"""
    
    def __init__(self, session: Session):
        self.session = session
    
    def save(self, product: Product) -> Product:
        """保存商品"""
        product_model = ProductModel(
            id=product.id,
            name=product.name,
            description=product.description,
            price=product.price,
            category=product.category,
            status=product.status,
            created_at=product.created_at,
            updated_at=product.updated_at
        )
        
        self.session.add(product_model)
        self.session.commit()
        return product
    
    def find_by_id(self, id: str) -> Optional[Product]:
        """根据ID查找商品"""
        product_model = self.session.query(ProductModel).filter_by(id=id).first()
        
        if product_model:
            return Product(
                id=product_model.id,
                name=product_model.name,
                description=product_model.description,
                price=product_model.price,
                category=product_model.category,
                status=product_model.status,
                attributes={},
                created_at=product_model.created_at,
                updated_at=product_model.updated_at
            )
        return None
    
    def find_all(self) -> List[Product]:
        """查找所有商品"""
        product_models = self.session.query(ProductModel).all()
        
        return [
            Product(
                id=model.id,
                name=model.name,
                description=model.description,
                price=model.price,
                category=model.category,
                status=model.status,
                attributes={},
                created_at=model.created_at,
                updated_at=model.updated_at
            )
            for model in product_models
        ]
    
    def delete(self, id: str) -> bool:
        """删除商品"""
        product_model = self.session.query(ProductModel).filter_by(id=id).first()
        if product_model:
            self.session.delete(product_model)
            self.session.commit()
            return True
        return False
```

## 5. 技术实现

### 5.1 API设计

**RESTful API实现**：

```python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI(title="E-Commerce API", version="1.0.0")

# CORS中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic模型
class ProductCreate(BaseModel):
    name: str
    description: str
    price: Decimal
    category: str
    attributes: Dict[str, str] = {}

class ProductResponse(BaseModel):
    id: str
    name: str
    description: str
    price: Decimal
    category: str
    status: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class OrderCreate(BaseModel):
    customer_id: str
    items: List[Dict[str, Any]]
    shipping_address: Dict[str, str]

# API端点
@app.post("/products", response_model=ProductResponse)
async def create_product(product: ProductCreate):
    """创建商品"""
    try:
        new_product = Product(
            id=str(uuid.uuid4()),
            name=product.name,
            description=product.description,
            price=product.price,
            category=product.category,
            attributes=product.attributes,
            status=ProductStatus.ACTIVE,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        # 保存到数据库
        product_repo = ProductRepository(get_db_session())
        saved_product = product_repo.save(new_product)
        
        return ProductResponse.from_orm(saved_product)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/products", response_model=List[ProductResponse])
async def get_products(
    category: Optional[str] = None,
    status: Optional[str] = None,
    page: int = 1,
    size: int = 20
):
    """获取商品列表"""
    try:
        product_repo = ProductRepository(get_db_session())
        products = product_repo.find_all()
        
        # 过滤
        if category:
            products = [p for p in products if p.category == category]
        if status:
            products = [p for p in products if p.status.value == status]
        
        # 分页
        start = (page - 1) * size
        end = start + size
        paginated_products = products[start:end]
        
        return [ProductResponse.from_orm(p) for p in paginated_products]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/products/{product_id}", response_model=ProductResponse)
async def get_product(product_id: str):
    """获取商品详情"""
    try:
        product_repo = ProductRepository(get_db_session())
        product = product_repo.find_by_id(product_id)
        
        if not product:
            raise HTTPException(status_code=404, detail="商品不存在")
        
        return ProductResponse.from_orm(product)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/orders")
async def create_order(order: OrderCreate):
    """创建订单"""
    try:
        # 订单处理工作流
        workflow = OrderProcessingWorkflow()
        
        # 构建订单对象
        order_obj = Order(
            id=str(uuid.uuid4()),
            customer_id=order.customer_id,
            items=[],  # 需要从items构建OrderItem
            total_amount=Decimal("0"),
            status=OrderStatus.PENDING,
            payment_status=PaymentStatus.PENDING,
            shipping_address=Address(**order.shipping_address),
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        # 执行工作流
        result = workflow.execute(order_obj)
        
        if result["status"] == "failed":
            raise HTTPException(status_code=400, detail=result.get("error", "订单创建失败"))
        
        return {"order_id": order_obj.id, "status": "created"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

def get_db_session():
    """获取数据库会话"""
    # 这里应该返回实际的数据库会话
    pass
```

### 5.2 缓存策略

**多级缓存实现**：

```python
import redis
from typing import Optional, Any
import json

class CacheStrategy:
    """缓存策略"""
    
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        self.local_cache = {}
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        # 先查本地缓存
        if key in self.local_cache:
            return self.local_cache[key]
        
        # 再查Redis缓存
        value = self.redis_client.get(key)
        if value:
            parsed_value = json.loads(value)
            # 更新本地缓存
            self.local_cache[key] = parsed_value
            return parsed_value
        
        return None
    
    def set(self, key: str, value: Any, ttl: int = 3600) -> None:
        """设置缓存"""
        # 设置本地缓存
        self.local_cache[key] = value
        
        # 设置Redis缓存
        self.redis_client.setex(
            key,
            ttl,
            json.dumps(value, default=str)
        )
    
    def delete(self, key: str) -> None:
        """删除缓存"""
        if key in self.local_cache:
            del self.local_cache[key]
        
        self.redis_client.delete(key)
    
    def clear(self) -> None:
        """清空缓存"""
        self.local_cache.clear()
        self.redis_client.flushdb()

class ProductCacheService:
    """商品缓存服务"""
    
    def __init__(self):
        self.cache = CacheStrategy()
        self.product_repo = ProductRepository(get_db_session())
    
    def get_product(self, product_id: str) -> Optional[Product]:
        """获取商品（带缓存）"""
        cache_key = f"product:{product_id}"
        
        # 尝试从缓存获取
        cached_product = self.cache.get(cache_key)
        if cached_product:
            return Product(**cached_product)
        
        # 从数据库获取
        product = self.product_repo.find_by_id(product_id)
        if product:
            # 缓存商品信息
            self.cache.set(cache_key, product.__dict__, ttl=1800)  # 30分钟
        
        return product
    
    def invalidate_product(self, product_id: str) -> None:
        """使商品缓存失效"""
        cache_key = f"product:{product_id}"
        self.cache.delete(cache_key)
    
    def get_products_by_category(self, category: str) -> List[Product]:
        """根据分类获取商品（带缓存）"""
        cache_key = f"products:category:{category}"
        
        # 尝试从缓存获取
        cached_products = self.cache.get(cache_key)
        if cached_products:
            return [Product(**p) for p in cached_products]
        
        # 从数据库获取
        products = self.product_repo.find_by_category(category)
        
        # 缓存结果
        if products:
            self.cache.set(cache_key, [p.__dict__ for p in products], ttl=900)  # 15分钟
        
        return products
```

## 6. 质量属性

### 6.1 性能优化

**性能模型**：

```python
import time
from typing import Dict, List, Tuple

class PerformanceModel:
    """性能模型"""
    
    def __init__(self):
        self.metrics: Dict[str, List[float]] = {
            "response_time": [],
            "throughput": [],
            "error_rate": []
        }
    
    def measure_response_time(self, func):
        """测量响应时间装饰器"""
        def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = func(*args, **kwargs)
                end_time = time.time()
                response_time = end_time - start_time
                
                self.metrics["response_time"].append(response_time)
                return result
            except Exception as e:
                self.metrics["error_rate"].append(1.0)
                raise e
        
        return wrapper
    
    def get_average_response_time(self) -> float:
        """获取平均响应时间"""
        if not self.metrics["response_time"]:
            return 0.0
        return sum(self.metrics["response_time"]) / len(self.metrics["response_time"])
    
    def get_error_rate(self) -> float:
        """获取错误率"""
        total_requests = len(self.metrics["response_time"]) + len(self.metrics["error_rate"])
        if total_requests == 0:
            return 0.0
        return len(self.metrics["error_rate"]) / total_requests

class DatabaseOptimization:
    """数据库优化"""
    
    def __init__(self):
        self.indexes: List[str] = []
        self.query_cache: Dict[str, Any] = {}
    
    def create_indexes(self) -> None:
        """创建索引"""
        indexes = [
            "CREATE INDEX idx_products_category ON products(category)",
            "CREATE INDEX idx_products_status ON products(status)",
            "CREATE INDEX idx_orders_customer_id ON orders(customer_id)",
            "CREATE INDEX idx_orders_status ON orders(status)",
            "CREATE INDEX idx_order_items_order_id ON order_items(order_id)",
            "CREATE INDEX idx_order_items_product_id ON order_items(product_id)"
        ]
        
        for index_sql in indexes:
            self.indexes.append(index_sql)
    
    def optimize_queries(self) -> Dict[str, str]:
        """查询优化建议"""
        return {
            "product_search": "使用全文索引优化商品搜索",
            "order_analysis": "使用分区表优化大表查询",
            "inventory_check": "使用缓存减少库存查询",
            "payment_processing": "使用异步处理提高响应速度"
        }
```

### 6.2 可扩展性设计

**水平扩展策略**：

```python
from typing import List, Dict, Any
import hashlib

class LoadBalancer:
    """负载均衡器"""
    
    def __init__(self, strategy: str = "round_robin"):
        self.strategy = strategy
        self.servers: List[str] = []
        self.current_index = 0
    
    def add_server(self, server: str) -> None:
        """添加服务器"""
        self.servers.append(server)
    
    def get_next_server(self, request_id: str = None) -> str:
        """获取下一个服务器"""
        if not self.servers:
            raise ValueError("没有可用的服务器")
        
        if self.strategy == "round_robin":
            server = self.servers[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.servers)
            return server
        elif self.strategy == "consistent_hashing":
            return self._consistent_hash(request_id)
        else:
            return self.servers[0]
    
    def _consistent_hash(self, request_id: str) -> str:
        """一致性哈希"""
        if not request_id:
            request_id = str(uuid.uuid4())
        
        hash_value = int(hashlib.md5(request_id.encode()).hexdigest(), 16)
        server_index = hash_value % len(self.servers)
        return self.servers[server_index]

class DatabaseSharding:
    """数据库分片"""
    
    def __init__(self, shard_count: int = 4):
        self.shard_count = shard_count
        self.shards: Dict[int, str] = {}
    
    def get_shard_key(self, entity_id: str) -> int:
        """获取分片键"""
        hash_value = int(hashlib.md5(entity_id.encode()).hexdigest(), 16)
        return hash_value % self.shard_count
    
    def get_shard_connection(self, entity_id: str) -> str:
        """获取分片连接"""
        shard_key = self.get_shard_key(entity_id)
        return self.shards.get(shard_key, "default")
    
    def setup_shards(self) -> None:
        """设置分片"""
        for i in range(self.shard_count):
            self.shards[i] = f"shard_{i}_connection"
```

## 7. 最佳实践

### 7.1 安全实践

**安全模型**：

```python
import jwt
from passlib.context import CryptContext
from typing import Optional, Dict, Any

class SecurityModel:
    """安全模型"""
    
    def __init__(self):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.secret_key = "your-secret-key"
    
    def hash_password(self, password: str) -> str:
        """密码哈希"""
        return self.pwd_context.hash(password)
    
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """验证密码"""
        return self.pwd_context.verify(plain_password, hashed_password)
    
    def create_access_token(self, data: Dict[str, Any]) -> str:
        """创建访问令牌"""
        return jwt.encode(data, self.secret_key, algorithm="HS256")
    
    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:
        """验证令牌"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            return payload
        except jwt.PyJWTError:
            return None

class InputValidation:
    """输入验证"""
    
    @staticmethod
    def validate_email(email: str) -> bool:
        """验证邮箱格式"""
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    @staticmethod
    def validate_phone(phone: str) -> bool:
        """验证手机号格式"""
        import re
        pattern = r'^1[3-9]\d{9}$'
        return re.match(pattern, phone) is not None
    
    @staticmethod
    def sanitize_input(input_str: str) -> str:
        """输入净化"""
        import html
        return html.escape(input_str.strip())
```

### 7.2 监控和日志

**监控系统**：

```python
import logging
from datetime import datetime
from typing import Dict, Any

class MonitoringSystem:
    """监控系统"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.metrics: Dict[str, Any] = {}
    
    def log_event(self, event_type: str, details: Dict[str, Any]) -> None:
        """记录事件"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            "details": details
        }
        
        self.logger.info(f"Event: {log_entry}")
    
    def record_metric(self, metric_name: str, value: float) -> None:
        """记录指标"""
        if metric_name not in self.metrics:
            self.metrics[metric_name] = []
        
        self.metrics[metric_name].append({
            "timestamp": datetime.now(),
            "value": value
        })
    
    def get_metric_summary(self, metric_name: str) -> Dict[str, float]:
        """获取指标摘要"""
        if metric_name not in self.metrics:
            return {}
        
        values = [m["value"] for m in self.metrics[metric_name]]
        
        return {
            "count": len(values),
            "min": min(values) if values else 0,
            "max": max(values) if values else 0,
            "avg": sum(values) / len(values) if values else 0
        }

# 使用示例
monitoring = MonitoringSystem()

@app.middleware("http")
async def monitor_requests(request, call_next):
    """请求监控中间件"""
    start_time = time.time()
    
    response = await call_next(request)
    
    response_time = time.time() - start_time
    monitoring.record_metric("response_time", response_time)
    
    monitoring.log_event("http_request", {
        "method": request.method,
        "path": request.url.path,
        "status_code": response.status_code,
        "response_time": response_time
    })
    
    return response
```

---

## 总结

本文档提供了电子商务领域的完整架构设计，包括：

1. **领域建模**：定义了核心实体和业务规则
2. **架构模式**：实现了微服务和事件驱动架构
3. **业务建模**：设计了工作流和规则引擎
4. **数据建模**：提供了数据模型和访问层实现
5. **技术实现**：包含了API设计和缓存策略
6. **质量属性**：涵盖了性能和可扩展性优化
7. **最佳实践**：提供了安全和监控方案

所有内容都采用了数学形式化表达和Python代码示例，确保理论与实践的结合。这个架构设计可以作为电子商务系统开发的基础框架，支持高并发、高可用的业务需求。