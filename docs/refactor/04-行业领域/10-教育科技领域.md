# 教育科技领域架构设计

## 1. 概述

### 1.1 教育科技基础

教育科技（EdTech）是将技术与教育相结合，通过数字化手段提升学习效果和教育管理效率的领域。

**定义 1.1.1 (教育科技系统)**
教育科技系统是一个多层次的数字化教育平台：

$$\text{EdTech} = (U, C, A, L, R)$$

其中：

- $U$ 是用户集合
- $C$ 是课程集合
- $A$ 是评估系统
- $L$ 是学习分析
- $R$ 是推荐系统

### 1.2 核心特性

**定义 1.1.2 (教育科技特性)**
教育科技系统具有以下核心特性：

1. **个性化学习**：$\forall u \in U, \text{Personalize}(u) \rightarrow \text{Curriculum}(u)$
2. **实时反馈**：$\text{Feedback}(u, t) \rightarrow \text{Immediate}$
3. **数据分析**：$\text{LearningData}(u) \rightarrow \text{Insights}$
4. **自适应评估**：$\text{Assessment}(u) \rightarrow \text{Adaptive}$

## 2. 学习管理系统

### 2.1 用户管理

**定义 2.1.1 (用户角色)**
教育系统中的用户角色定义为：

$$\text{UserRole} = \{\text{Student}, \text{Teacher}, \text{Administrator}, \text{Parent}\}$$

**Python实现**：

```python
from enum import Enum
from typing import List, Optional, Dict, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import uuid

class UserRole(Enum):
    """用户角色"""
    STUDENT = "student"
    TEACHER = "teacher"
    ADMINISTRATOR = "administrator"
    PARENT = "parent"

@dataclass
class UserProfile:
    """用户档案"""
    first_name: str
    last_name: str
    email: str
    avatar_url: Optional[str] = None
    bio: Optional[str] = None
    grade_level: Optional[str] = None
    subjects: List[str] = field(default_factory=list)
    learning_goals: List[str] = field(default_factory=list)

@dataclass
class User:
    """用户实体"""
    id: str
    username: str
    role: UserRole
    profile: UserProfile
    preferences: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

class UserManagementSystem:
    """用户管理系统"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.sessions: Dict[str, Dict[str, Any]] = {}
    
    def create_user(self, username: str, role: UserRole, profile: UserProfile) -> User:
        """创建用户"""
        user = User(
            id=str(uuid.uuid4()),
            username=username,
            role=role,
            profile=profile
        )
        self.users[user.id] = user
        return user
    
    def get_user(self, user_id: str) -> Optional[User]:
        """获取用户"""
        return self.users.get(user_id)
    
    def update_user_profile(self, user_id: str, profile: UserProfile) -> bool:
        """更新用户档案"""
        if user_id not in self.users:
            return False
        
        user = self.users[user_id]
        user.profile = profile
        user.updated_at = datetime.now()
        return True
    
    def authenticate_user(self, username: str, password: str) -> Optional[str]:
        """用户认证（简化实现）"""
        for user in self.users.values():
            if user.username == username:
                # 实际实现应该验证密码哈希
                session_id = str(uuid.uuid4())
                self.sessions[session_id] = {
                    "user_id": user.id,
                    "created_at": datetime.now(),
                    "expires_at": datetime.now() + timedelta(hours=24)
                }
                return session_id
        return None
    
    def validate_session(self, session_id: str) -> Optional[User]:
        """验证会话"""
        if session_id not in self.sessions:
            return None
        
        session = self.sessions[session_id]
        if session["expires_at"] < datetime.now():
            del self.sessions[session_id]
            return None
        
        return self.get_user(session["user_id"])
```

### 2.2 课程管理

**定义 2.1.2 (课程结构)**
课程是一个层次化的学习内容组织：

$$\text{Course} = (M_1, M_2, ..., M_n) \text{ where } M_i = (L_1, L_2, ..., L_m)$$

其中 $M_i$ 是模块，$L_j$ 是课程。

**Python实现**：

```python
from typing import List, Optional, Dict, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta

@dataclass
class Lesson:
    """课程"""
    id: str
    title: str
    content: str
    media_urls: List[str] = field(default_factory=list)
    estimated_duration: timedelta = timedelta(minutes=30)
    difficulty: str = "intermediate"
    prerequisites: List[str] = field(default_factory=list)

@dataclass
class Module:
    """模块"""
    id: str
    title: str
    description: str
    order: int
    lessons: List[Lesson] = field(default_factory=list)
    assessments: List[str] = field(default_factory=list)
    estimated_duration: timedelta = timedelta(hours=2)

@dataclass
class Course:
    """课程"""
    id: str
    title: str
    description: str
    instructor_id: str
    category: str
    level: str
    modules: List[Module] = field(default_factory=list)
    prerequisites: List[str] = field(default_factory=list)
    learning_objectives: List[str] = field(default_factory=list)
    status: str = "draft"
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

class CourseManagementSystem:
    """课程管理系统"""
    
    def __init__(self):
        self.courses: Dict[str, Course] = {}
        self.enrollments: Dict[str, List[str]] = {}  # course_id -> [user_ids]
    
    def create_course(self, title: str, description: str, instructor_id: str, 
                     category: str, level: str) -> Course:
        """创建课程"""
        course = Course(
            id=str(uuid.uuid4()),
            title=title,
            description=description,
            instructor_id=instructor_id,
            category=category,
            level=level
        )
        self.courses[course.id] = course
        return course
    
    def add_module(self, course_id: str, title: str, description: str, order: int) -> Optional[Module]:
        """添加模块"""
        if course_id not in self.courses:
            return None
        
        module = Module(
            id=str(uuid.uuid4()),
            title=title,
            description=description,
            order=order
        )
        
        course = self.courses[course_id]
        course.modules.append(module)
        course.updated_at = datetime.now()
        
        return module
    
    def add_lesson(self, module_id: str, title: str, content: str) -> Optional[Lesson]:
        """添加课程"""
        lesson = Lesson(
            id=str(uuid.uuid4()),
            title=title,
            content=content
        )
        
        # 查找模块并添加课程
        for course in self.courses.values():
            for module in course.modules:
                if module.id == module_id:
                    module.lessons.append(lesson)
                    course.updated_at = datetime.now()
                    return lesson
        
        return None
    
    def enroll_student(self, course_id: str, user_id: str) -> bool:
        """学生选课"""
        if course_id not in self.courses:
            return False
        
        if course_id not in self.enrollments:
            self.enrollments[course_id] = []
        
        if user_id not in self.enrollments[course_id]:
            self.enrollments[course_id].append(user_id)
        
        return True
    
    def get_course_progress(self, course_id: str, user_id: str) -> Dict[str, Any]:
        """获取课程进度"""
        if course_id not in self.courses or course_id not in self.enrollments:
            return {"error": "Course not found or user not enrolled"}
        
        if user_id not in self.enrollments[course_id]:
            return {"error": "User not enrolled"}
        
        course = self.courses[course_id]
        total_lessons = sum(len(module.lessons) for module in course.modules)
        
        # 简化实现，实际应该从学习记录中获取
        completed_lessons = 0  # 从学习记录系统获取
        
        progress = (completed_lessons / total_lessons * 100) if total_lessons > 0 else 0
        
        return {
            "course_id": course_id,
            "user_id": user_id,
            "total_lessons": total_lessons,
            "completed_lessons": completed_lessons,
            "progress_percentage": progress
        }
```

## 3. 智能评估系统

### 3.1 自适应评估

**定义 3.1.1 (自适应评估)**
自适应评估根据学生表现动态调整题目难度：

$$\text{AdaptiveAssessment} = \text{IRT}(\theta, a, b, c)$$

其中 $\theta$ 是学生能力，$a, b, c$ 是题目参数。

**Python实现**：

```python
import numpy as np
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Question:
    """题目"""
    id: str
    text: str
    question_type: str
    difficulty: float  # 0-1之间
    discrimination: float  # 区分度
    guessing: float  # 猜测参数
    options: List[str] = None
    correct_answer: str = None

@dataclass
class AssessmentSession:
    """评估会话"""
    id: str
    user_id: str
    assessment_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    answers: List[Dict[str, Any]] = None
    score: Optional[float] = None
    status: str = "in_progress"
    
    def __post_init__(self):
        if self.answers is None:
            self.answers = []

class ItemResponseTheory:
    """项目反应理论"""
    
    @staticmethod
    def three_parameter_model(theta: float, a: float, b: float, c: float) -> float:
        """三参数模型"""
        return c + (1 - c) / (1 + np.exp(-a * (theta - b)))
    
    @staticmethod
    def estimate_ability(responses: List[bool], difficulties: List[float], 
                        discriminations: List[float], guessings: List[float]) -> float:
        """估计学生能力"""
        # 使用最大似然估计
        def likelihood(theta):
            prob = 1.0
            for i, response in enumerate(responses):
                p = ItemResponseTheory.three_parameter_model(
                    theta, discriminations[i], difficulties[i], guessings[i]
                )
                if response:
                    prob *= p
                else:
                    prob *= (1 - p)
            return prob
        
        # 简化实现：使用网格搜索
        theta_range = np.linspace(-3, 3, 100)
        max_likelihood = -np.inf
        best_theta = 0.0
        
        for theta in theta_range:
            like = likelihood(theta)
            if like > max_likelihood:
                max_likelihood = like
                best_theta = theta
        
        return best_theta

class AdaptiveAssessmentEngine:
    """自适应评估引擎"""
    
    def __init__(self):
        self.question_bank: Dict[str, Question] = {}
        self.sessions: Dict[str, AssessmentSession] = {}
    
    def add_question(self, question: Question):
        """添加题目"""
        self.question_bank[question.id] = question
    
    def start_assessment(self, user_id: str, subject: str) -> str:
        """开始评估"""
        session_id = str(uuid.uuid4())
        
        # 选择初始题目（中等难度）
        initial_questions = self._select_questions_by_difficulty(0.5, 5)
        
        session = AssessmentSession(
            id=session_id,
            user_id=user_id,
            assessment_id=f"assessment_{subject}_{datetime.now().strftime('%Y%m%d')}",
            start_time=datetime.now()
        )
        
        self.sessions[session_id] = session
        return session_id
    
    def submit_answer(self, session_id: str, question_id: str, answer: str) -> Dict[str, Any]:
        """提交答案"""
        if session_id not in self.sessions:
            return {"error": "Session not found"}
        
        session = self.sessions[session_id]
        question = self.question_bank.get(question_id)
        
        if not question:
            return {"error": "Question not found"}
        
        # 判断答案正确性
        is_correct = answer == question.correct_answer
        
        # 记录答案
        session.answers.append({
            "question_id": question_id,
            "answer": answer,
            "is_correct": is_correct,
            "timestamp": datetime.now()
        })
        
        # 估计当前能力
        if len(session.answers) >= 3:
            responses = [ans["is_correct"] for ans in session.answers]
            difficulties = [self.question_bank[ans["question_id"]].difficulty 
                          for ans in session.answers]
            discriminations = [self.question_bank[ans["question_id"]].discrimination 
                             for ans in session.answers]
            guessings = [self.question_bank[ans["question_id"]].guessing 
                        for ans in session.answers]
            
            estimated_ability = ItemResponseTheory.estimate_ability(
                responses, difficulties, discriminations, guessings
            )
            
            # 选择下一题
            next_question = self._select_next_question(estimated_ability, session.answers)
            
            return {
                "is_correct": is_correct,
                "estimated_ability": estimated_ability,
                "next_question": next_question,
                "session_complete": len(session.answers) >= 10
            }
        
        return {
            "is_correct": is_correct,
            "next_question": self._select_next_question(0.5, session.answers)
        }
    
    def _select_questions_by_difficulty(self, target_difficulty: float, count: int) -> List[Question]:
        """根据难度选择题目"""
        questions = list(self.question_bank.values())
        # 按难度排序并选择最接近目标难度的题目
        questions.sort(key=lambda q: abs(q.difficulty - target_difficulty))
        return questions[:count]
    
    def _select_next_question(self, estimated_ability: float, answered_questions: List[Dict]) -> Optional[Question]:
        """选择下一题"""
        answered_ids = {ans["question_id"] for ans in answered_questions}
        available_questions = [q for q in self.question_bank.values() 
                             if q.id not in answered_ids]
        
        if not available_questions:
            return None
        
        # 选择难度最接近当前能力的题目
        best_question = min(available_questions, 
                          key=lambda q: abs(q.difficulty - estimated_ability))
        return best_question
    
    def complete_assessment(self, session_id: str) -> Dict[str, Any]:
        """完成评估"""
        if session_id not in self.sessions:
            return {"error": "Session not found"}
        
        session = self.sessions[session_id]
        session.end_time = datetime.now()
        session.status = "completed"
        
        # 计算最终分数
        correct_answers = sum(1 for ans in session.answers if ans["is_correct"])
        total_questions = len(session.answers)
        score = (correct_answers / total_questions * 100) if total_questions > 0 else 0
        
        session.score = score
        
        return {
            "session_id": session_id,
            "score": score,
            "total_questions": total_questions,
            "correct_answers": correct_answers,
            "duration": session.end_time - session.start_time
        }

# 测试自适应评估
def test_adaptive_assessment():
    """测试自适应评估"""
    engine = AdaptiveAssessmentEngine()
    
    # 添加题目
    questions = [
        Question("q1", "1+1=?", "multiple_choice", 0.1, 0.8, 0.25, 
                ["1", "2", "3", "4"], "2"),
        Question("q2", "2*3=?", "multiple_choice", 0.3, 0.7, 0.2, 
                ["4", "5", "6", "7"], "6"),
        Question("q3", "10/2=?", "multiple_choice", 0.5, 0.6, 0.15, 
                ["3", "4", "5", "6"], "5"),
        Question("q4", "15-7=?", "multiple_choice", 0.7, 0.5, 0.1, 
                ["6", "7", "8", "9"], "8"),
        Question("q5", "3^2=?", "multiple_choice", 0.9, 0.4, 0.05, 
                ["6", "7", "8", "9"], "9"),
    ]
    
    for question in questions:
        engine.add_question(question)
    
    # 开始评估
    session_id = engine.start_assessment("user1", "math")
    print(f"开始评估，会话ID: {session_id}")
    
    # 提交答案
    answers = ["2", "6", "5", "8", "9"]  # 全部正确
    for i, answer in enumerate(answers):
        result = engine.submit_answer(session_id, f"q{i+1}", answer)
        print(f"题目 {i+1} 结果: {result}")
    
    # 完成评估
    final_result = engine.complete_assessment(session_id)
    print(f"最终结果: {final_result}")

if __name__ == "__main__":
    test_adaptive_assessment()
```

## 4. 学习分析系统

### 4.1 学习行为分析

**定义 4.1.1 (学习行为)**
学习行为是学生在学习过程中的各种活动记录：

$$\text{LearningBehavior} = \{(t_i, a_i, c_i)\}_{i=1}^{n}$$

其中 $t_i$ 是时间戳，$a_i$ 是行为类型，$c_i$ 是上下文信息。

**Python实现**：

```python
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import numpy as np
from collections import defaultdict

@dataclass
class LearningEvent:
    """学习事件"""
    id: str
    user_id: str
    event_type: str
    course_id: Optional[str] = None
    lesson_id: Optional[str] = None
    timestamp: datetime = None
    duration: Optional[timedelta] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}

class LearningAnalyticsEngine:
    """学习分析引擎"""
    
    def __init__(self):
        self.events: List[LearningEvent] = []
        self.user_profiles: Dict[str, Dict[str, Any]] = {}
    
    def record_event(self, event: LearningEvent):
        """记录学习事件"""
        self.events.append(event)
    
    def analyze_learning_patterns(self, user_id: str, 
                                start_date: datetime, 
                                end_date: datetime) -> Dict[str, Any]:
        """分析学习模式"""
        user_events = [e for e in self.events 
                      if e.user_id == user_id 
                      and start_date <= e.timestamp <= end_date]
        
        if not user_events:
            return {"error": "No events found"}
        
        # 按日期分组
        daily_events = defaultdict(list)
        for event in user_events:
            date_key = event.timestamp.date()
            daily_events[date_key].append(event)
        
        # 计算学习时间
        total_duration = timedelta()
        for event in user_events:
            if event.duration:
                total_duration += event.duration
        
        # 计算活跃天数
        active_days = len(daily_events)
        
        # 计算学习频率
        date_range = (end_date - start_date).days
        learning_frequency = active_days / date_range if date_range > 0 else 0
        
        # 分析学习时间分布
        hourly_distribution = defaultdict(int)
        for event in user_events:
            hour = event.timestamp.hour
            hourly_distribution[hour] += 1
        
        # 分析事件类型分布
        event_type_distribution = defaultdict(int)
        for event in user_events:
            event_type_distribution[event.event_type] += 1
        
        return {
            "user_id": user_id,
            "total_events": len(user_events),
            "total_duration": str(total_duration),
            "active_days": active_days,
            "learning_frequency": learning_frequency,
            "hourly_distribution": dict(hourly_distribution),
            "event_type_distribution": dict(event_type_distribution),
            "average_events_per_day": len(user_events) / active_days if active_days > 0 else 0
        }
    
    def calculate_engagement_score(self, user_id: str, 
                                 course_id: str, 
                                 time_window: timedelta = timedelta(days=30)) -> float:
        """计算参与度分数"""
        end_date = datetime.now()
        start_date = end_date - time_window
        
        user_events = [e for e in self.events 
                      if e.user_id == user_id 
                      and e.course_id == course_id
                      and start_date <= e.timestamp <= end_date]
        
        if not user_events:
            return 0.0
        
        # 参与度指标
        total_events = len(user_events)
        total_duration = sum(e.duration.total_seconds() for e in user_events if e.duration)
        
        # 事件类型权重
        event_weights = {
            "login": 1,
            "lesson_start": 2,
            "lesson_complete": 5,
            "quiz_attempt": 3,
            "quiz_complete": 4,
            "assignment_submit": 6,
            "discussion_post": 2
        }
        
        weighted_score = sum(event_weights.get(e.event_type, 1) for e in user_events)
        
        # 时间权重
        time_weight = min(total_duration / (time_window.total_seconds() * 0.1), 1.0)
        
        # 综合分数
        engagement_score = (weighted_score * 0.7 + time_weight * 100 * 0.3) / 10
        return min(engagement_score, 100.0)
    
    def predict_completion_probability(self, user_id: str, course_id: str) -> float:
        """预测完成概率"""
        # 获取用户在该课程的所有事件
        course_events = [e for e in self.events 
                        if e.user_id == user_id and e.course_id == course_id]
        
        if not course_events:
            return 0.0
        
        # 计算参与度分数
        engagement_score = self.calculate_engagement_score(user_id, course_id)
        
        # 计算学习一致性
        event_timestamps = [e.timestamp for e in course_events]
        if len(event_timestamps) > 1:
            intervals = []
            sorted_timestamps = sorted(event_timestamps)
            for i in range(1, len(sorted_timestamps)):
                interval = (sorted_timestamps[i] - sorted_timestamps[i-1]).total_seconds()
                intervals.append(interval)
            
            consistency_score = 1.0 / (1.0 + np.std(intervals) / 86400)  # 标准化到天
        else:
            consistency_score = 0.5
        
        # 计算完成概率
        completion_probability = (engagement_score * 0.6 + consistency_score * 100 * 0.4) / 100
        return min(completion_probability, 1.0)
    
    def generate_learning_insights(self, user_id: str) -> Dict[str, Any]:
        """生成学习洞察"""
        # 获取用户最近30天的学习数据
        end_date = datetime.now()
        start_date = end_date - timedelta(days=30)
        
        patterns = self.analyze_learning_patterns(user_id, start_date, end_date)
        
        if "error" in patterns:
            return patterns
        
        insights = {
            "user_id": user_id,
            "learning_strength": self._analyze_learning_strength(patterns),
            "improvement_areas": self._identify_improvement_areas(patterns),
            "recommendations": self._generate_recommendations(patterns),
            "progress_summary": patterns
        }
        
        return insights
    
    def _analyze_learning_strength(self, patterns: Dict[str, Any]) -> List[str]:
        """分析学习优势"""
        strengths = []
        
        if patterns["learning_frequency"] > 0.7:
            strengths.append("学习频率高，保持良好")
        
        if patterns["total_events"] > 100:
            strengths.append("学习活动丰富")
        
        if patterns["active_days"] > 20:
            strengths.append("学习持续性良好")
        
        return strengths
    
    def _identify_improvement_areas(self, patterns: Dict[str, Any]) -> List[str]:
        """识别改进领域"""
        areas = []
        
        if patterns["learning_frequency"] < 0.3:
            areas.append("建议增加学习频率")
        
        if patterns["average_events_per_day"] < 5:
            areas.append("建议增加每日学习活动")
        
        return areas
    
    def _generate_recommendations(self, patterns: Dict[str, Any]) -> List[str]:
        """生成建议"""
        recommendations = []
        
        if patterns["learning_frequency"] < 0.5:
            recommendations.append("建议制定每日学习计划")
        
        if patterns["total_events"] < 50:
            recommendations.append("建议参与更多学习活动")
        
        return recommendations

# 测试学习分析
def test_learning_analytics():
    """测试学习分析"""
    analytics = LearningAnalyticsEngine()
    
    # 模拟学习事件
    user_id = "user1"
    course_id = "course1"
    
    # 记录一些学习事件
    events = [
        LearningEvent("e1", user_id, "login", course_id, duration=timedelta(minutes=5)),
        LearningEvent("e2", user_id, "lesson_start", course_id, duration=timedelta(minutes=30)),
        LearningEvent("e3", user_id, "lesson_complete", course_id, duration=timedelta(minutes=30)),
        LearningEvent("e4", user_id, "quiz_attempt", course_id, duration=timedelta(minutes=15)),
        LearningEvent("e5", user_id, "quiz_complete", course_id, duration=timedelta(minutes=15)),
    ]
    
    for event in events:
        analytics.record_event(event)
    
    # 分析学习模式
    patterns = analytics.analyze_learning_patterns(
        user_id, 
        datetime.now() - timedelta(days=7), 
        datetime.now()
    )
    print(f"学习模式分析: {patterns}")
    
    # 计算参与度分数
    engagement = analytics.calculate_engagement_score(user_id, course_id)
    print(f"参与度分数: {engagement}")
    
    # 预测完成概率
    completion_prob = analytics.predict_completion_probability(user_id, course_id)
    print(f"完成概率: {completion_prob}")
    
    # 生成学习洞察
    insights = analytics.generate_learning_insights(user_id)
    print(f"学习洞察: {insights}")

if __name__ == "__main__":
    test_learning_analytics()
```

## 5. 推荐系统

### 5.1 个性化推荐

**定义 5.1.1 (推荐系统)**
推荐系统基于用户行为和偏好推荐学习内容：

$$\text{Recommendation} = \arg\max_{c \in C} \text{Score}(u, c)$$

其中 $\text{Score}(u, c)$ 是用户 $u$ 对内容 $c$ 的偏好分数。

**Python实现**：

```python
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer

@dataclass
class LearningItem:
    """学习项目"""
    id: str
    title: str
    description: str
    category: str
    tags: List[str]
    difficulty: float
    duration: int  # 分钟
    rating: float = 0.0
    view_count: int = 0

@dataclass
class UserPreference:
    """用户偏好"""
    user_id: str
    preferred_categories: List[str]
    preferred_difficulty: float
    preferred_duration: int
    interests: List[str]
    learning_goals: List[str]

class RecommendationEngine:
    """推荐引擎"""
    
    def __init__(self):
        self.items: Dict[str, LearningItem] = {}
        self.user_preferences: Dict[str, UserPreference] = {}
        self.user_ratings: Dict[Tuple[str, str], float] = {}  # (user_id, item_id) -> rating
        self.user_interactions: Dict[Tuple[str, str], int] = {}  # (user_id, item_id) -> interaction_count
    
    def add_item(self, item: LearningItem):
        """添加学习项目"""
        self.items[item.id] = item
    
    def add_user_preference(self, preference: UserPreference):
        """添加用户偏好"""
        self.user_preferences[preference.user_id] = preference
    
    def record_rating(self, user_id: str, item_id: str, rating: float):
        """记录用户评分"""
        self.user_ratings[(user_id, item_id)] = rating
    
    def record_interaction(self, user_id: str, item_id: str):
        """记录用户交互"""
        key = (user_id, item_id)
        self.user_interactions[key] = self.user_interactions.get(key, 0) + 1
    
    def content_based_recommendation(self, user_id: str, top_k: int = 5) -> List[LearningItem]:
        """基于内容的推荐"""
        if user_id not in self.user_preferences:
            return []
        
        preference = self.user_preferences[user_id]
        
        # 计算每个项目的推荐分数
        item_scores = []
        for item in self.items.values():
            score = self._calculate_content_score(item, preference)
            item_scores.append((item, score))
        
        # 排序并返回top_k
        item_scores.sort(key=lambda x: x[1], reverse=True)
        return [item for item, score in item_scores[:top_k]]
    
    def _calculate_content_score(self, item: LearningItem, preference: UserPreference) -> float:
        """计算内容匹配分数"""
        score = 0.0
        
        # 类别匹配
        if item.category in preference.preferred_categories:
            score += 0.3
        
        # 难度匹配
        difficulty_diff = abs(item.difficulty - preference.preferred_difficulty)
        score += 0.2 * (1.0 - min(difficulty_diff, 1.0))
        
        # 时长匹配
        duration_diff = abs(item.duration - preference.preferred_duration)
        score += 0.2 * (1.0 - min(duration_diff / 60, 1.0))  # 标准化到小时
        
        # 兴趣匹配
        interest_overlap = len(set(item.tags) & set(preference.interests))
        score += 0.2 * (interest_overlap / max(len(item.tags), 1))
        
        # 目标匹配
        goal_overlap = len(set(item.tags) & set(preference.learning_goals))
        score += 0.1 * (goal_overlap / max(len(preference.learning_goals), 1))
        
        return score
    
    def collaborative_filtering_recommendation(self, user_id: str, top_k: int = 5) -> List[LearningItem]:
        """协同过滤推荐"""
        # 构建用户-项目评分矩阵
        users = list(set(uid for uid, _ in self.user_ratings.keys()))
        items = list(self.items.keys())
        
        if not users or not items:
            return []
        
        # 创建评分矩阵
        rating_matrix = np.zeros((len(users), len(items)))
        user_to_idx = {uid: idx for idx, uid in enumerate(users)}
        item_to_idx = {iid: idx for idx, iid in enumerate(items)}
        
        for (uid, iid), rating in self.user_ratings.items():
            if uid in user_to_idx and iid in item_to_idx:
                rating_matrix[user_to_idx[uid]][item_to_idx[iid]] = rating
        
        # 计算用户相似度
        if user_id not in user_to_idx:
            return []
        
        user_idx = user_to_idx[user_id]
        user_similarities = cosine_similarity([rating_matrix[user_idx]], rating_matrix)[0]
        
        # 找到最相似的用户
        similar_users = []
        for i, similarity in enumerate(user_similarities):
            if i != user_idx and similarity > 0:
                similar_users.append((users[i], similarity))
        
        similar_users.sort(key=lambda x: x[1], reverse=True)
        
        # 基于相似用户的评分预测
        item_scores = {}
        for similar_user_id, similarity in similar_users[:5]:  # 取前5个相似用户
            similar_user_idx = user_to_idx[similar_user_id]
            
            for item_id in items:
                item_idx = item_to_idx[item_id]
                rating = rating_matrix[similar_user_idx][item_idx]
                
                if rating > 0:  # 用户对该项目有评分
                    if item_id not in item_scores:
                        item_scores[item_id] = []
                    item_scores[item_id].append(rating * similarity)
        
        # 计算加权平均分数
        final_scores = []
        for item_id, scores in item_scores.items():
            avg_score = sum(scores) / len(scores)
            final_scores.append((self.items[item_id], avg_score))
        
        final_scores.sort(key=lambda x: x[1], reverse=True)
        return [item for item, score in final_scores[:top_k]]
    
    def hybrid_recommendation(self, user_id: str, top_k: int = 5) -> List[LearningItem]:
        """混合推荐"""
        content_items = self.content_based_recommendation(user_id, top_k * 2)
        collaborative_items = self.collaborative_filtering_recommendation(user_id, top_k * 2)
        
        # 合并推荐结果
        all_items = {}
        
        # 内容推荐权重
        for i, item in enumerate(content_items):
            score = 0.6 * (1.0 - i / len(content_items))  # 递减权重
            if item.id in all_items:
                all_items[item.id] += score
            else:
                all_items[item.id] = score
        
        # 协同过滤推荐权重
        for i, item in enumerate(collaborative_items):
            score = 0.4 * (1.0 - i / len(collaborative_items))  # 递减权重
            if item.id in all_items:
                all_items[item.id] += score
            else:
                all_items[item.id] = score
        
        # 排序并返回top_k
        sorted_items = sorted(all_items.items(), key=lambda x: x[1], reverse=True)
        return [self.items[item_id] for item_id, _ in sorted_items[:top_k]]
    
    def get_personalized_recommendations(self, user_id: str, 
                                       recommendation_type: str = "hybrid",
                                       top_k: int = 5) -> List[LearningItem]:
        """获取个性化推荐"""
        if recommendation_type == "content":
            return self.content_based_recommendation(user_id, top_k)
        elif recommendation_type == "collaborative":
            return self.collaborative_filtering_recommendation(user_id, top_k)
        else:
            return self.hybrid_recommendation(user_id, top_k)

# 测试推荐系统
def test_recommendation_system():
    """测试推荐系统"""
    engine = RecommendationEngine()
    
    # 添加学习项目
    items = [
        LearningItem("item1", "Python基础", "Python编程入门", "programming", 
                    ["python", "beginner"], 0.2, 120),
        LearningItem("item2", "机器学习", "机器学习算法", "ai", 
                    ["ml", "ai", "intermediate"], 0.6, 180),
        LearningItem("item3", "数据结构", "计算机数据结构", "cs", 
                    ["data-structures", "algorithms"], 0.5, 150),
        LearningItem("item4", "深度学习", "深度学习基础", "ai", 
                    ["deep-learning", "neural-networks"], 0.8, 240),
        LearningItem("item5", "Web开发", "Web应用开发", "programming", 
                    ["web", "javascript", "html"], 0.4, 200),
    ]
    
    for item in items:
        engine.add_item(item)
    
    # 添加用户偏好
    preference = UserPreference(
        user_id="user1",
        preferred_categories=["programming", "ai"],
        preferred_difficulty=0.5,
        preferred_duration=180,
        interests=["python", "ml", "web"],
        learning_goals=["become_developer", "learn_ai"]
    )
    engine.add_user_preference(preference)
    
    # 记录一些用户评分
    engine.record_rating("user1", "item1", 4.5)
    engine.record_rating("user1", "item2", 4.0)
    engine.record_rating("user2", "item1", 4.0)
    engine.record_rating("user2", "item3", 4.5)
    engine.record_rating("user3", "item2", 3.5)
    engine.record_rating("user3", "item4", 4.5)
    
    # 获取推荐
    content_recs = engine.get_personalized_recommendations("user1", "content", 3)
    print(f"基于内容的推荐: {[item.title for item in content_recs]}")
    
    collaborative_recs = engine.get_personalized_recommendations("user1", "collaborative", 3)
    print(f"协同过滤推荐: {[item.title for item in collaborative_recs]}")
    
    hybrid_recs = engine.get_personalized_recommendations("user1", "hybrid", 3)
    print(f"混合推荐: {[item.title for item in hybrid_recs]}")

if __name__ == "__main__":
    test_recommendation_system()
```

## 6. 总结

教育科技领域通过数字化手段提升教育效果，本章涵盖了：

1. **学习管理系统**：用户管理、课程管理
2. **智能评估系统**：自适应评估、项目反应理论
3. **学习分析系统**：行为分析、参与度计算
4. **推荐系统**：个性化推荐、混合推荐算法

这些技术共同构建了一个智能化、个性化的教育平台，为学习者提供更好的学习体验。
