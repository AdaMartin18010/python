# 云计算领域 - 架构设计与实现

## 1. 概述

### 1.1 云计算基础理论

**定义 1.1.1 (云计算)**
云计算是一种通过互联网按需提供计算资源、存储资源和网络资源的服务模式，具有按需自服务、广泛的网络访问、资源池化、快速弹性、可测量的服务等特征。

**定理 1.1.1 (云服务层次定理)**
云服务可以形式化为三个层次：基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)，满足层次包含关系：
$$IaaS \subseteq PaaS \subseteq SaaS$$

*证明*：设 $S_{IaaS}$ 为基础设施服务集合，$S_{PaaS}$ 为平台服务集合，$S_{SaaS}$ 为软件服务集合。
对于任意 $x \in S_{IaaS}$，存在 $y \in S_{PaaS}$ 使得 $x$ 是 $y$ 的基础设施组件，因此 $x \in S_{PaaS}$。
同理，对于任意 $y \in S_{PaaS}$，存在 $z \in S_{SaaS}$ 使得 $y$ 是 $z$ 的平台组件，因此 $y \in S_{SaaS}$。
因此 $S_{IaaS} \subseteq S_{PaaS} \subseteq S_{SaaS}$。

### 1.2 云原生架构原则

**定义 1.1.2 (云原生应用)**
云原生应用是专为云环境设计的应用程序，具有以下特征：

- 微服务架构
- 容器化部署
- 动态编排
- 自动化运维
- 弹性扩展

## 2. 容器化技术

### 2.1 容器基础理论

**定义 2.1.1 (容器)**
容器是轻量级的、可移植的、自包含的软件包，包含运行应用程序所需的所有依赖项。

**定理 2.1.1 (容器隔离性定理)**
容器通过命名空间和cgroups实现进程隔离，满足：
$$\forall p_1, p_2 \in P, p_1 \neq p_2 \Rightarrow NS(p_1) \cap NS(p_2) = \emptyset$$
其中 $P$ 为进程集合，$NS(p)$ 为进程 $p$ 的命名空间。

**Python实现**：

```python
from dataclasses import dataclass
from typing import Dict, List, Optional, Set
import asyncio
import json
from enum import Enum
import uuid
from datetime import datetime

class ContainerState(Enum):
    CREATED = "created"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    REMOVED = "removed"

@dataclass
class ContainerConfig:
    """容器配置类"""
    image: str
    command: List[str]
    environment: Dict[str, str]
    ports: Dict[int, int]
    volumes: Dict[str, str]
    memory_limit: str
    cpu_limit: str
    
    def to_dict(self) -> Dict:
        return {
            "image": self.image,
            "command": self.command,
            "environment": self.environment,
            "ports": self.ports,
            "volumes": self.volumes,
            "memory_limit": self.memory_limit,
            "cpu_limit": self.cpu_limit
        }

class Container:
    """容器类"""
    
    def __init__(self, container_id: str, config: ContainerConfig):
        self.container_id = container_id
        self.config = config
        self.state = ContainerState.CREATED
        self.created_at = datetime.now()
        self.started_at: Optional[datetime] = None
        self.stopped_at: Optional[datetime] = None
        self.namespace_id = str(uuid.uuid4())
        self.cgroup_id = str(uuid.uuid4())
        
    async def start(self) -> bool:
        """启动容器"""
        try:
            # 创建命名空间
            await self._create_namespace()
            # 创建cgroup
            await self._create_cgroup()
            # 启动进程
            await self._start_process()
            
            self.state = ContainerState.RUNNING
            self.started_at = datetime.now()
            return True
        except Exception as e:
            print(f"启动容器失败: {e}")
            return False
    
    async def stop(self) -> bool:
        """停止容器"""
        try:
            await self._stop_process()
            await self._cleanup_cgroup()
            await self._cleanup_namespace()
            
            self.state = ContainerState.STOPPED
            self.stopped_at = datetime.now()
            return True
        except Exception as e:
            print(f"停止容器失败: {e}")
            return False
    
    async def _create_namespace(self):
        """创建命名空间"""
        # 模拟创建命名空间
        print(f"创建命名空间: {self.namespace_id}")
        await asyncio.sleep(0.1)
    
    async def _create_cgroup(self):
        """创建cgroup"""
        # 模拟创建cgroup
        print(f"创建cgroup: {self.cgroup_id}")
        await asyncio.sleep(0.1)
    
    async def _start_process(self):
        """启动进程"""
        # 模拟启动进程
        print(f"启动进程: {self.config.command}")
        await asyncio.sleep(0.1)
    
    async def _stop_process(self):
        """停止进程"""
        # 模拟停止进程
        print(f"停止进程: {self.container_id}")
        await asyncio.sleep(0.1)
    
    async def _cleanup_cgroup(self):
        """清理cgroup"""
        print(f"清理cgroup: {self.cgroup_id}")
        await asyncio.sleep(0.1)
    
    async def _cleanup_namespace(self):
        """清理命名空间"""
        print(f"清理命名空间: {self.namespace_id}")
        await asyncio.sleep(0.1)
    
    def get_status(self) -> Dict:
        """获取容器状态"""
        return {
            "container_id": self.container_id,
            "state": self.state.value,
            "created_at": self.created_at.isoformat(),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "stopped_at": self.stopped_at.isoformat() if self.stopped_at else None,
            "config": self.config.to_dict()
        }

class ContainerEngine:
    """容器引擎"""
    
    def __init__(self):
        self.containers: Dict[str, Container] = {}
        self.images: Set[str] = set()
    
    async def create_container(self, config: ContainerConfig) -> str:
        """创建容器"""
        container_id = str(uuid.uuid4())
        container = Container(container_id, config)
        self.containers[container_id] = container
        return container_id
    
    async def start_container(self, container_id: str) -> bool:
        """启动容器"""
        if container_id not in self.containers:
            return False
        return await self.containers[container_id].start()
    
    async def stop_container(self, container_id: str) -> bool:
        """停止容器"""
        if container_id not in self.containers:
            return False
        return await self.containers[container_id].stop()
    
    def list_containers(self) -> List[Dict]:
        """列出所有容器"""
        return [container.get_status() for container in self.containers.values()]
    
    async def remove_container(self, container_id: str) -> bool:
        """删除容器"""
        if container_id not in self.containers:
            return False
        
        container = self.containers[container_id]
        if container.state == ContainerState.RUNNING:
            await container.stop()
        
        del self.containers[container_id]
        return True

# 使用示例
async def container_demo():
    """容器使用演示"""
    engine = ContainerEngine()
    
    # 创建容器配置
    config = ContainerConfig(
        image="python:3.9",
        command=["python", "-m", "http.server", "8000"],
        environment={"PYTHONPATH": "/app"},
        ports={8000: 8000},
        volumes={"/app": "/app"},
        memory_limit="512m",
        cpu_limit="0.5"
    )
    
    # 创建并启动容器
    container_id = await engine.create_container(config)
    print(f"创建容器: {container_id}")
    
    success = await engine.start_container(container_id)
    print(f"启动容器: {'成功' if success else '失败'}")
    
    # 列出容器
    containers = engine.list_containers()
    print(f"容器列表: {json.dumps(containers, indent=2, ensure_ascii=False)}")
    
    # 停止并删除容器
    await engine.stop_container(container_id)
    await engine.remove_container(container_id)
    print("容器已删除")

if __name__ == "__main__":
    asyncio.run(container_demo())
```

### 2.2 容器编排理论

**定义 2.2.1 (容器编排)**
容器编排是自动化容器的部署、扩展、负载均衡、网络配置和资源分配的过程。

**定理 2.2.1 (编排调度定理)**
对于容器编排系统，存在最优调度策略使得资源利用率最大化：
$$\max \sum_{i=1}^{n} \frac{R_i}{C_i}$$
其中 $R_i$ 为容器 $i$ 的资源需求，$C_i$ 为节点 $i$ 的资源容量。

## 3. 微服务架构

### 3.1 微服务基础理论

**定义 3.1.1 (微服务)**
微服务是一种将应用程序构建为一组小型自治服务的架构风格，每个服务运行在自己的进程中，通过轻量级机制进行通信。

**定理 3.1.1 (微服务独立性定理)**
微服务架构中，服务间的耦合度满足：
$$C_{ij} = \frac{|D_i \cap D_j|}{|D_i \cup D_j|} < \epsilon$$
其中 $C_{ij}$ 为服务 $i$ 和 $j$ 的耦合度，$D_i$ 为服务 $i$ 的依赖集合，$\epsilon$ 为耦合度阈值。

**Python实现**：

```python
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any
import asyncio
import json
from enum import Enum
import uuid
from datetime import datetime
import aiohttp
from abc import ABC, abstractmethod

class ServiceState(Enum):
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    STARTING = "starting"
    STOPPED = "stopped"

@dataclass
class ServiceConfig:
    """服务配置"""
    name: str
    version: str
    port: int
    dependencies: List[str] = field(default_factory=list)
    environment: Dict[str, str] = field(default_factory=dict)
    health_check_path: str = "/health"
    timeout: int = 30
    
    def to_dict(self) -> Dict:
        return {
            "name": self.name,
            "version": self.version,
            "port": self.port,
            "dependencies": self.dependencies,
            "environment": self.environment,
            "health_check_path": self.health_check_path,
            "timeout": self.timeout
        }

class ServiceRegistry:
    """服务注册中心"""
    
    def __init__(self):
        self.services: Dict[str, Dict] = {}
        self.health_checks: Dict[str, bool] = {}
    
    async def register_service(self, service_id: str, config: ServiceConfig, 
                             host: str, port: int) -> bool:
        """注册服务"""
        try:
            self.services[service_id] = {
                "service_id": service_id,
                "config": config.to_dict(),
                "host": host,
                "port": port,
                "registered_at": datetime.now().isoformat(),
                "last_heartbeat": datetime.now().isoformat()
            }
            self.health_checks[service_id] = True
            return True
        except Exception as e:
            print(f"注册服务失败: {e}")
            return False
    
    async def deregister_service(self, service_id: str) -> bool:
        """注销服务"""
        if service_id in self.services:
            del self.services[service_id]
            del self.health_checks[service_id]
            return True
        return False
    
    async def update_heartbeat(self, service_id: str) -> bool:
        """更新心跳"""
        if service_id in self.services:
            self.services[service_id]["last_heartbeat"] = datetime.now().isoformat()
            return True
        return False
    
    def get_service(self, service_id: str) -> Optional[Dict]:
        """获取服务信息"""
        return self.services.get(service_id)
    
    def list_services(self) -> List[Dict]:
        """列出所有服务"""
        return list(self.services.values())
    
    def discover_service(self, service_name: str) -> List[Dict]:
        """服务发现"""
        return [
            service for service in self.services.values()
            if service["config"]["name"] == service_name
        ]

class Microservice:
    """微服务基类"""
    
    def __init__(self, service_id: str, config: ServiceConfig, 
                 registry: ServiceRegistry):
        self.service_id = service_id
        self.config = config
        self.registry = registry
        self.state = ServiceState.STOPPED
        self.start_time: Optional[datetime] = None
        
    async def start(self, host: str = "localhost") -> bool:
        """启动服务"""
        try:
            # 注册到服务注册中心
            success = await self.registry.register_service(
                self.service_id, self.config, host, self.config.port
            )
            if not success:
                return False
            
            # 启动服务
            await self._start_server(host, self.config.port)
            
            self.state = ServiceState.HEALTHY
            self.start_time = datetime.now()
            
            # 启动心跳
            asyncio.create_task(self._heartbeat_loop())
            
            return True
        except Exception as e:
            print(f"启动服务失败: {e}")
            return False
    
    async def stop(self) -> bool:
        """停止服务"""
        try:
            # 注销服务
            await self.registry.deregister_service(self.service_id)
            
            # 停止服务器
            await self._stop_server()
            
            self.state = ServiceState.STOPPED
            return True
        except Exception as e:
            print(f"停止服务失败: {e}")
            return False
    
    async def _start_server(self, host: str, port: int):
        """启动服务器"""
        # 模拟启动HTTP服务器
        print(f"启动服务 {self.config.name} 在 {host}:{port}")
        await asyncio.sleep(0.1)
    
    async def _stop_server(self):
        """停止服务器"""
        print(f"停止服务 {self.config.name}")
        await asyncio.sleep(0.1)
    
    async def _heartbeat_loop(self):
        """心跳循环"""
        while self.state == ServiceState.HEALTHY:
            try:
                await self.registry.update_heartbeat(self.service_id)
                await asyncio.sleep(30)  # 30秒心跳间隔
            except Exception as e:
                print(f"心跳更新失败: {e}")
                break
    
    async def health_check(self) -> bool:
        """健康检查"""
        try:
            # 模拟健康检查
            return True
        except Exception:
            return False

class ServiceMesh:
    """服务网格"""
    
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.routing_rules: Dict[str, List[str]] = {}
        self.circuit_breakers: Dict[str, bool] = {}
    
    async def route_request(self, service_name: str, request_data: Dict) -> Optional[Dict]:
        """路由请求"""
        # 服务发现
        services = self.registry.discover_service(service_name)
        if not services:
            return None
        
        # 负载均衡
        selected_service = self._load_balance(services)
        
        # 熔断器检查
        if self.circuit_breakers.get(selected_service["service_id"], False):
            return None
        
        # 发送请求
        try:
            response = await self._send_request(selected_service, request_data)
            return response
        except Exception as e:
            # 触发熔断器
            self.circuit_breakers[selected_service["service_id"]] = True
            print(f"请求失败，触发熔断器: {e}")
            return None
    
    def _load_balance(self, services: List[Dict]) -> Dict:
        """负载均衡"""
        # 简单的轮询负载均衡
        return services[0]  # 简化实现
    
    async def _send_request(self, service: Dict, request_data: Dict) -> Dict:
        """发送请求"""
        # 模拟HTTP请求
        url = f"http://{service['host']}:{service['port']}/api"
        print(f"发送请求到: {url}")
        await asyncio.sleep(0.1)
        return {"status": "success", "data": request_data}

# 使用示例
async def microservice_demo():
    """微服务演示"""
    registry = ServiceRegistry()
    mesh = ServiceMesh(registry)
    
    # 创建用户服务
    user_config = ServiceConfig(
        name="user-service",
        version="1.0.0",
        port=8081,
        dependencies=[],
        environment={"DB_URL": "postgresql://localhost/users"}
    )
    
    user_service = Microservice("user-1", user_config, registry)
    
    # 创建订单服务
    order_config = ServiceConfig(
        name="order-service",
        version="1.0.0",
        port=8082,
        dependencies=["user-service"],
        environment={"DB_URL": "postgresql://localhost/orders"}
    )
    
    order_service = Microservice("order-1", order_config, registry)
    
    # 启动服务
    await user_service.start()
    await order_service.start()
    
    # 服务发现
    services = registry.list_services()
    print(f"注册的服务: {json.dumps(services, indent=2, ensure_ascii=False)}")
    
    # 服务调用
    response = await mesh.route_request("user-service", {"action": "get_user", "id": 1})
    print(f"服务调用结果: {response}")
    
    # 停止服务
    await user_service.stop()
    await order_service.stop()

if __name__ == "__main__":
    asyncio.run(microservice_demo())
```

## 4. 分布式存储

### 4.1 分布式存储理论

**定义 4.1.1 (分布式存储)**
分布式存储是将数据分散存储在多个物理节点上的存储系统，提供高可用性、可扩展性和容错性。

**定理 4.1.1 (CAP定理)**
在分布式系统中，一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)三者最多只能同时满足两个。

**Python实现**：

```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Tuple
import asyncio
import json
from enum import Enum
import uuid
from datetime import datetime
import hashlib
from abc import ABC, abstractmethod

class ConsistencyLevel(Enum):
    STRONG = "strong"
    EVENTUAL = "eventual"
    READ_YOUR_WRITES = "read_your_writes"

@dataclass
class StorageNode:
    """存储节点"""
    node_id: str
    host: str
    port: int
    capacity: int  # 存储容量
    used_space: int = 0
    is_available: bool = True
    last_heartbeat: datetime = field(default_factory=datetime.now)
    
    def get_available_space(self) -> int:
        """获取可用空间"""
        return self.capacity - self.used_space
    
    def can_store(self, size: int) -> bool:
        """检查是否可以存储指定大小的数据"""
        return self.is_available and self.get_available_space() >= size

class DataShard:
    """数据分片"""
    
    def __init__(self, shard_id: str, data: bytes, replica_count: int = 3):
        self.shard_id = shard_id
        self.data = data
        self.size = len(data)
        self.replica_count = replica_count
        self.replicas: List[str] = []  # 存储节点ID列表
        self.created_at = datetime.now()
        self.checksum = self._calculate_checksum()
    
    def _calculate_checksum(self) -> str:
        """计算校验和"""
        return hashlib.md5(self.data).hexdigest()
    
    def verify_integrity(self) -> bool:
        """验证数据完整性"""
        return self._calculate_checksum() == self.checksum

class DistributedStorage:
    """分布式存储系统"""
    
    def __init__(self, consistency_level: ConsistencyLevel = ConsistencyLevel.EVENTUAL):
        self.nodes: Dict[str, StorageNode] = {}
        self.shards: Dict[str, DataShard] = {}
        self.consistency_level = consistency_level
        self.replication_factor = 3
    
    async def add_node(self, node_id: str, host: str, port: int, capacity: int) -> bool:
        """添加存储节点"""
        try:
            node = StorageNode(node_id, host, port, capacity)
            self.nodes[node_id] = node
            print(f"添加存储节点: {node_id} ({host}:{port})")
            return True
        except Exception as e:
            print(f"添加节点失败: {e}")
            return False
    
    async def remove_node(self, node_id: str) -> bool:
        """移除存储节点"""
        if node_id not in self.nodes:
            return False
        
        # 重新分配该节点上的数据
        await self._redistribute_data(node_id)
        
        del self.nodes[node_id]
        print(f"移除存储节点: {node_id}")
        return True
    
    async def store_data(self, key: str, data: bytes) -> bool:
        """存储数据"""
        try:
            # 创建数据分片
            shard_id = str(uuid.uuid4())
            shard = DataShard(shard_id, data, self.replication_factor)
            
            # 选择存储节点
            selected_nodes = self._select_storage_nodes(shard.size)
            if len(selected_nodes) < self.replication_factor:
                print("没有足够的可用存储节点")
                return False
            
            # 存储数据到多个节点
            success_count = 0
            for node_id in selected_nodes:
                if await self._store_shard_to_node(node_id, shard):
                    shard.replicas.append(node_id)
                    success_count += 1
            
            # 检查是否达到复制因子
            if success_count >= self.replication_factor:
                self.shards[shard_id] = shard
                print(f"数据存储成功: {key} -> {shard_id}")
                return True
            else:
                print(f"数据存储失败，只有 {success_count} 个副本")
                return False
                
        except Exception as e:
            print(f"存储数据失败: {e}")
            return False
    
    async def retrieve_data(self, key: str) -> Optional[bytes]:
        """检索数据"""
        try:
            # 查找数据分片
            shard_id = self._find_shard_id(key)
            if not shard_id or shard_id not in self.shards:
                return None
            
            shard = self.shards[shard_id]
            
            # 从可用副本中读取数据
            for node_id in shard.replicas:
                if node_id in self.nodes and self.nodes[node_id].is_available:
                    data = await self._retrieve_shard_from_node(node_id, shard_id)
                    if data and data.verify_integrity():
                        return data.data
            
            print("无法从任何副本读取数据")
            return None
            
        except Exception as e:
            print(f"检索数据失败: {e}")
            return None
    
    def _select_storage_nodes(self, data_size: int) -> List[str]:
        """选择存储节点"""
        available_nodes = [
            node_id for node_id, node in self.nodes.items()
            if node.can_store(data_size)
        ]
        
        # 按可用空间排序，选择空间最大的节点
        available_nodes.sort(
            key=lambda x: self.nodes[x].get_available_space(),
            reverse=True
        )
        
        return available_nodes[:self.replication_factor]
    
    async def _store_shard_to_node(self, node_id: str, shard: DataShard) -> bool:
        """将分片存储到节点"""
        try:
            node = self.nodes[node_id]
            if not node.can_store(shard.size):
                return False
            
            # 模拟存储操作
            print(f"存储分片 {shard.shard_id} 到节点 {node_id}")
            node.used_space += shard.size
            await asyncio.sleep(0.1)
            return True
        except Exception as e:
            print(f"存储到节点失败: {e}")
            return False
    
    async def _retrieve_shard_from_node(self, node_id: str, shard_id: str) -> Optional[DataShard]:
        """从节点检索分片"""
        try:
            # 模拟检索操作
            print(f"从节点 {node_id} 检索分片 {shard_id}")
            await asyncio.sleep(0.1)
            
            # 返回模拟数据
            return DataShard(shard_id, b"retrieved_data", 1)
        except Exception as e:
            print(f"从节点检索失败: {e}")
            return None
    
    def _find_shard_id(self, key: str) -> Optional[str]:
        """查找分片ID"""
        # 简化的键到分片映射
        for shard_id, shard in self.shards.items():
            if key in shard_id:  # 简化实现
                return shard_id
        return None
    
    async def _redistribute_data(self, node_id: str):
        """重新分配数据"""
        print(f"重新分配节点 {node_id} 上的数据")
        # 实现数据重新分配逻辑
        await asyncio.sleep(0.1)
    
    def get_cluster_status(self) -> Dict:
        """获取集群状态"""
        total_capacity = sum(node.capacity for node in self.nodes.values())
        total_used = sum(node.used_space for node in self.nodes.values())
        
        return {
            "node_count": len(self.nodes),
            "total_capacity": total_capacity,
            "total_used": total_used,
            "utilization_rate": total_used / total_capacity if total_capacity > 0 else 0,
            "shard_count": len(self.shards),
            "consistency_level": self.consistency_level.value
        }

# 使用示例
async def distributed_storage_demo():
    """分布式存储演示"""
    storage = DistributedStorage(ConsistencyLevel.EVENTUAL)
    
    # 添加存储节点
    await storage.add_node("node-1", "192.168.1.10", 9001, 1000)
    await storage.add_node("node-2", "192.168.1.11", 9002, 1000)
    await storage.add_node("node-3", "192.168.1.12", 9003, 1000)
    await storage.add_node("node-4", "192.168.1.13", 9004, 1000)
    
    # 存储数据
    test_data = b"Hello, Distributed Storage!"
    success = await storage.store_data("test-key", test_data)
    print(f"存储结果: {'成功' if success else '失败'}")
    
    # 检索数据
    retrieved_data = await storage.retrieve_data("test-key")
    if retrieved_data:
        print(f"检索到的数据: {retrieved_data.decode()}")
    else:
        print("数据检索失败")
    
    # 查看集群状态
    status = storage.get_cluster_status()
    print(f"集群状态: {json.dumps(status, indent=2, ensure_ascii=False)}")

if __name__ == "__main__":
    asyncio.run(distributed_storage_demo())
```

## 5. 服务网格

### 5.1 服务网格理论

**定义 5.1.1 (服务网格)**
服务网格是一个基础设施层，用于处理服务间通信，通常由数据平面和控制平面组成。

**定理 5.1.1 (服务网格可观测性定理)**
服务网格提供的可观测性满足：
$$O = M \cup L \cup T$$
其中 $O$ 为可观测性，$M$ 为指标，$L$ 为日志，$T$ 为追踪。

## 6. 云原生应用最佳实践

### 6.1 十二要素应用

**定义 6.1.1 (十二要素应用)**
十二要素应用是一种构建软件即服务应用的现代方法，包含：

1. 代码库
2. 依赖
3. 配置
4. 后端服务
5. 构建、发布、运行
6. 进程
7. 端口绑定
8. 并发
9. 易处理
10. 开发/生产环境等价
11. 日志
12. 管理进程

### 6.2 云原生安全

**定义 6.2.1 (云原生安全)**
云原生安全是在云环境中保护应用程序、数据和基础设施的安全实践。

**Python实现**：

```python
from dataclasses import dataclass
from typing import Dict, List, Optional, Any
import asyncio
import json
from enum import Enum
import uuid
from datetime import datetime
import hashlib
import hmac
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class SecurityLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class SecurityPolicy:
    """安全策略"""
    name: str
    level: SecurityLevel
    encryption_required: bool = True
    authentication_required: bool = True
    authorization_required: bool = True
    audit_logging: bool = True
    rate_limiting: bool = True
    
    def to_dict(self) -> Dict:
        return {
            "name": self.name,
            "level": self.level.value,
            "encryption_required": self.encryption_required,
            "authentication_required": self.authentication_required,
            "authorization_required": self.authorization_required,
            "audit_logging": self.audit_logging,
            "rate_limiting": self.rate_limiting
        }

class CloudNativeSecurity:
    """云原生安全系统"""
    
    def __init__(self):
        self.policies: Dict[str, SecurityPolicy] = {}
        self.encryption_keys: Dict[str, bytes] = {}
        self.access_tokens: Dict[str, Dict] = {}
        self.audit_logs: List[Dict] = []
        self.rate_limiters: Dict[str, Dict] = {}
    
    def create_policy(self, policy: SecurityPolicy) -> str:
        """创建安全策略"""
        policy_id = str(uuid.uuid4())
        self.policies[policy_id] = policy
        print(f"创建安全策略: {policy.name}")
        return policy_id
    
    def generate_encryption_key(self) -> str:
        """生成加密密钥"""
        key = Fernet.generate_key()
        key_id = str(uuid.uuid4())
        self.encryption_keys[key_id] = key
        return key_id
    
    async def encrypt_data(self, data: bytes, key_id: str) -> Optional[bytes]:
        """加密数据"""
        try:
            if key_id not in self.encryption_keys:
                return None
            
            key = self.encryption_keys[key_id]
            f = Fernet(key)
            encrypted_data = f.encrypt(data)
            
            # 记录审计日志
            self._log_audit("encrypt", "data_encrypted", {"key_id": key_id})
            
            return encrypted_data
        except Exception as e:
            print(f"加密失败: {e}")
            return None
    
    async def decrypt_data(self, encrypted_data: bytes, key_id: str) -> Optional[bytes]:
        """解密数据"""
        try:
            if key_id not in self.encryption_keys:
                return None
            
            key = self.encryption_keys[key_id]
            f = Fernet(key)
            decrypted_data = f.decrypt(encrypted_data)
            
            # 记录审计日志
            self._log_audit("decrypt", "data_decrypted", {"key_id": key_id})
            
            return decrypted_data
        except Exception as e:
            print(f"解密失败: {e}")
            return None
    
    async def authenticate_user(self, username: str, password: str) -> Optional[str]:
        """用户认证"""
        try:
            # 简化的认证逻辑
            if username == "admin" and password == "password":
                token = self._generate_access_token(username)
                self.access_tokens[token] = {
                    "username": username,
                    "created_at": datetime.now(),
                    "expires_at": datetime.now().timestamp() + 3600
                }
                
                self._log_audit("auth", "user_authenticated", {"username": username})
                return token
            else:
                self._log_audit("auth", "authentication_failed", {"username": username})
                return None
        except Exception as e:
            print(f"认证失败: {e}")
            return None
    
    async def authorize_access(self, token: str, resource: str, action: str) -> bool:
        """访问授权"""
        try:
            if token not in self.access_tokens:
                return False
            
            token_data = self.access_tokens[token]
            if token_data["expires_at"] < datetime.now().timestamp():
                del self.access_tokens[token]
                return False
            
            # 简化的授权逻辑
            if token_data["username"] == "admin":
                self._log_audit("auth", "access_authorized", {
                    "username": token_data["username"],
                    "resource": resource,
                    "action": action
                })
                return True
            else:
                self._log_audit("auth", "access_denied", {
                    "username": token_data["username"],
                    "resource": resource,
                    "action": action
                })
                return False
        except Exception as e:
            print(f"授权失败: {e}")
            return False
    
    async def check_rate_limit(self, client_id: str, limit: int = 100) -> bool:
        """速率限制检查"""
        try:
            if client_id not in self.rate_limiters:
                self.rate_limiters[client_id] = {
                    "count": 0,
                    "reset_time": datetime.now().timestamp() + 3600
                }
            
            limiter = self.rate_limiters[client_id]
            
            # 检查是否需要重置计数器
            if limiter["reset_time"] < datetime.now().timestamp():
                limiter["count"] = 0
                limiter["reset_time"] = datetime.now().timestamp() + 3600
            
            if limiter["count"] >= limit:
                self._log_audit("rate_limit", "rate_limit_exceeded", {"client_id": client_id})
                return False
            
            limiter["count"] += 1
            return True
        except Exception as e:
            print(f"速率限制检查失败: {e}")
            return False
    
    def _generate_access_token(self, username: str) -> str:
        """生成访问令牌"""
        timestamp = str(datetime.now().timestamp())
        data = f"{username}:{timestamp}"
        return base64.b64encode(data.encode()).decode()
    
    def _log_audit(self, action: str, event: str, details: Dict):
        """记录审计日志"""
        log_entry = {
            "id": str(uuid.uuid4()),
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "event": event,
            "details": details
        }
        self.audit_logs.append(log_entry)
    
    def get_audit_logs(self, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit_logs[-limit:]
    
    def get_security_status(self) -> Dict:
        """获取安全状态"""
        return {
            "policy_count": len(self.policies),
            "active_tokens": len(self.access_tokens),
            "audit_log_count": len(self.audit_logs),
            "rate_limiters_count": len(self.rate_limiters)
        }

# 使用示例
async def security_demo():
    """安全演示"""
    security = CloudNativeSecurity()
    
    # 创建安全策略
    policy = SecurityPolicy(
        name="production_policy",
        level=SecurityLevel.HIGH,
        encryption_required=True,
        authentication_required=True,
        authorization_required=True,
        audit_logging=True,
        rate_limiting=True
    )
    
    policy_id = security.create_policy(policy)
    
    # 生成加密密钥
    key_id = security.generate_encryption_key()
    
    # 加密数据
    original_data = b"Sensitive data that needs encryption"
    encrypted_data = await security.encrypt_data(original_data, key_id)
    print(f"加密数据: {encrypted_data[:20]}...")
    
    # 解密数据
    decrypted_data = await security.decrypt_data(encrypted_data, key_id)
    print(f"解密数据: {decrypted_data.decode()}")
    
    # 用户认证
    token = await security.authenticate_user("admin", "password")
    print(f"认证令牌: {token}")
    
    # 访问授权
    authorized = await security.authorize_access(token, "/api/users", "GET")
    print(f"访问授权: {'成功' if authorized else '失败'}")
    
    # 速率限制
    for i in range(5):
        allowed = await security.check_rate_limit("client-1", limit=3)
        print(f"请求 {i+1}: {'允许' if allowed else '拒绝'}")
    
    # 查看审计日志
    logs = security.get_audit_logs()
    print(f"审计日志: {json.dumps(logs, indent=2, ensure_ascii=False)}")
    
    # 查看安全状态
    status = security.get_security_status()
    print(f"安全状态: {json.dumps(status, indent=2, ensure_ascii=False)}")

if __name__ == "__main__":
    asyncio.run(security_demo())
```

## 7. 总结

### 7.1 云计算架构核心原则

1. **弹性扩展**: 根据负载自动调整资源
2. **高可用性**: 通过冗余和故障转移保证服务可用
3. **安全性**: 多层次安全防护
4. **可观测性**: 全面的监控和日志
5. **自动化**: 减少人工干预

### 7.2 技术栈选择

- **容器化**: Docker, containerd
- **编排**: Kubernetes, Docker Swarm
- **服务网格**: Istio, Linkerd
- **存储**: Ceph, GlusterFS
- **网络**: Calico, Flannel
- **监控**: Prometheus, Grafana

### 7.3 最佳实践

1. **微服务设计**: 服务拆分、API设计、数据一致性
2. **容器化部署**: 镜像优化、资源限制、安全配置
3. **自动化运维**: CI/CD、配置管理、故障恢复
4. **安全防护**: 身份认证、访问控制、数据加密
5. **性能优化**: 负载均衡、缓存策略、资源调度

---

*本文档提供了云计算领域的完整架构设计和实现方案，包含理论证明、数学形式化表达和可运行的Python代码示例。*
