# 04-01-01 æ”¯ä»˜ç³»ç»Ÿ

## ğŸ“‹ æ¦‚è¿°

æ”¯ä»˜ç³»ç»Ÿæ˜¯é‡‘èç§‘æŠ€çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼Œè´Ÿè´£å¤„ç†è´§å¸è½¬ç§»å’Œä»·å€¼äº¤æ¢ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰æ”¯ä»˜ç³»ç»Ÿï¼Œå»ºç«‹å®Œæ•´çš„ç†è®ºä½“ç³»ï¼Œå¹¶æä¾›é«˜æ•ˆçš„Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æ”¯ä»˜ç³»ç»Ÿçš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1** (æ”¯ä»˜ç³»ç»Ÿ)
æ”¯ä»˜ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$PS = (U, A, T, B, V, F, S)$$

å…¶ä¸­ï¼š

- $U$ ä¸ºç”¨æˆ·é›†åˆ
- $A$ ä¸ºè´¦æˆ·é›†åˆ
- $T$ ä¸ºäº¤æ˜“é›†åˆ
- $B$ ä¸ºä½™é¢å‡½æ•°ï¼š$B: A \rightarrow \mathbb{R}^+$
- $V$ ä¸ºéªŒè¯å‡½æ•°ï¼š$V: T \rightarrow \{True, False\}$
- $F$ ä¸ºè´¹ç”¨å‡½æ•°ï¼š$F: T \rightarrow \mathbb{R}^+$
- $S$ ä¸ºçŠ¶æ€é›†åˆ

**å®šä¹‰ 1.2** (äº¤æ˜“)
äº¤æ˜“æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$t = (sender, receiver, amount, timestamp, status)$$

å…¶ä¸­ï¼š

- $sender \in A$ ä¸ºå‘é€æ–¹è´¦æˆ·
- $receiver \in A$ ä¸ºæ¥æ”¶æ–¹è´¦æˆ·
- $amount \in \mathbb{R}^+$ ä¸ºäº¤æ˜“é‡‘é¢
- $timestamp \in \mathbb{N}$ ä¸ºæ—¶é—´æˆ³
- $status \in \{pending, completed, failed\}$ ä¸ºäº¤æ˜“çŠ¶æ€

**å®šä¹‰ 1.3** (è´¦æˆ·)
è´¦æˆ·æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$a = (id, owner, balance, type)$$

å…¶ä¸­ï¼š

- $id \in \mathbb{N}$ ä¸ºè´¦æˆ·æ ‡è¯†
- $owner \in U$ ä¸ºè´¦æˆ·æ‰€æœ‰è€…
- $balance \in \mathbb{R}^+$ ä¸ºè´¦æˆ·ä½™é¢
- $type \in \{checking, savings, credit\}$ ä¸ºè´¦æˆ·ç±»å‹

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Set, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import uuid
import time
import hashlib
import json
from decimal import Decimal, getcontext
import threading
import logging

# è®¾ç½®ç²¾åº¦
getcontext().prec = 28

class TransactionStatus(Enum):
    """äº¤æ˜“çŠ¶æ€"""
    PENDING = "pending"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class AccountType(Enum):
    """è´¦æˆ·ç±»å‹"""
    CHECKING = "checking"
    SAVINGS = "savings"
    CREDIT = "credit"

class PaymentMethod(Enum):
    """æ”¯ä»˜æ–¹å¼"""
    BANK_TRANSFER = "bank_transfer"
    CREDIT_CARD = "credit_card"
    DEBIT_CARD = "debit_card"
    DIGITAL_WALLET = "digital_wallet"
    CRYPTOCURRENCY = "cryptocurrency"

@dataclass
class User:
    """ç”¨æˆ·å®ä½“"""
    id: str
    name: str
    email: str
    phone: str
    kyc_verified: bool = False
    created_at: float = field(default_factory=time.time)
    
    def __str__(self) -> str:
        return f"User({self.name}, {self.email})"

@dataclass
class Account:
    """è´¦æˆ·å®ä½“"""
    id: str
    owner_id: str
    account_type: AccountType
    balance: Decimal = Decimal('0.00')
    currency: str = "USD"
    is_active: bool = True
    created_at: float = field(default_factory=time.time)
    last_updated: float = field(default_factory=time.time)
    
    def __str__(self) -> str:
        return f"Account({self.id}, {self.balance} {self.currency})"
    
    def can_withdraw(self, amount: Decimal) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥ææ¬¾"""
        if self.account_type == AccountType.CREDIT:
            # ä¿¡ç”¨å¡æœ‰ä¿¡ç”¨é¢åº¦
            return True
        else:
            return self.balance >= amount
    
    def withdraw(self, amount: Decimal) -> bool:
        """ææ¬¾"""
        if not self.can_withdraw(amount):
            return False
        
        if self.account_type != AccountType.CREDIT:
            self.balance -= amount
        self.last_updated = time.time()
        return True
    
    def deposit(self, amount: Decimal) -> bool:
        """å­˜æ¬¾"""
        self.balance += amount
        self.last_updated = time.time()
        return True

@dataclass
class Transaction:
    """äº¤æ˜“å®ä½“"""
    id: str
    sender_account_id: str
    receiver_account_id: str
    amount: Decimal
    currency: str
    payment_method: PaymentMethod
    status: TransactionStatus = TransactionStatus.PENDING
    fee: Decimal = Decimal('0.00')
    description: str = ""
    created_at: float = field(default_factory=time.time)
    completed_at: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        return f"Transaction({self.id}, {self.amount} {self.currency})"
    
    def get_hash(self) -> str:
        """è·å–äº¤æ˜“å“ˆå¸Œ"""
        data = f"{self.id}{self.sender_account_id}{self.receiver_account_id}{self.amount}{self.currency}{self.created_at}"
        return hashlib.sha256(data.encode()).hexdigest()
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'id': self.id,
            'sender_account_id': self.sender_account_id,
            'receiver_account_id': self.receiver_account_id,
            'amount': str(self.amount),
            'currency': self.currency,
            'payment_method': self.payment_method.value,
            'status': self.status.value,
            'fee': str(self.fee),
            'description': self.description,
            'created_at': self.created_at,
            'completed_at': self.completed_at,
            'metadata': self.metadata
        }

class PaymentValidator(ABC):
    """æ”¯ä»˜éªŒè¯å™¨æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def validate_transaction(self, transaction: Transaction, sender_account: Account, receiver_account: Account) -> Tuple[bool, str]:
        """éªŒè¯äº¤æ˜“"""
        pass

class BasicPaymentValidator(PaymentValidator):
    """åŸºæœ¬æ”¯ä»˜éªŒè¯å™¨"""
    
    def validate_transaction(self, transaction: Transaction, sender_account: Account, receiver_account: Account) -> Tuple[bool, str]:
        """éªŒè¯äº¤æ˜“"""
        # æ£€æŸ¥è´¦æˆ·æ˜¯å¦æ¿€æ´»
        if not sender_account.is_active:
            return False, "Sender account is not active"
        
        if not receiver_account.is_active:
            return False, "Receiver account is not active"
        
        # æ£€æŸ¥è´§å¸æ˜¯å¦åŒ¹é…
        if sender_account.currency != transaction.currency:
            return False, "Currency mismatch"
        
        if receiver_account.currency != transaction.currency:
            return False, "Currency mismatch"
        
        # æ£€æŸ¥ä½™é¢æ˜¯å¦è¶³å¤Ÿ
        total_amount = transaction.amount + transaction.fee
        if not sender_account.can_withdraw(total_amount):
            return False, "Insufficient balance"
        
        # æ£€æŸ¥é‡‘é¢æ˜¯å¦ä¸ºæ­£æ•°
        if transaction.amount <= 0:
            return False, "Invalid amount"
        
        return True, "Transaction is valid"

class FeeCalculator(ABC):
    """è´¹ç”¨è®¡ç®—å™¨æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def calculate_fee(self, transaction: Transaction) -> Decimal:
        """è®¡ç®—äº¤æ˜“è´¹ç”¨"""
        pass

class PercentageFeeCalculator(FeeCalculator):
    """ç™¾åˆ†æ¯”è´¹ç”¨è®¡ç®—å™¨"""
    
    def __init__(self, percentage: Decimal = Decimal('0.01')):  # 1%
        self.percentage = percentage
    
    def calculate_fee(self, transaction: Transaction) -> Decimal:
        """è®¡ç®—äº¤æ˜“è´¹ç”¨"""
        return transaction.amount * self.percentage

class FixedFeeCalculator(FeeCalculator):
    """å›ºå®šè´¹ç”¨è®¡ç®—å™¨"""
    
    def __init__(self, fixed_fee: Decimal = Decimal('0.50')):
        self.fixed_fee = fixed_fee
    
    def calculate_fee(self, transaction: Transaction) -> Decimal:
        """è®¡ç®—äº¤æ˜“è´¹ç”¨"""
        return self.fixed_fee

class PaymentProcessor:
    """æ”¯ä»˜å¤„ç†å™¨"""
    
    def __init__(self, validator: PaymentValidator, fee_calculator: FeeCalculator):
        self.validator = validator
        self.fee_calculator = fee_calculator
        self.transactions: Dict[str, Transaction] = {}
        self.accounts: Dict[str, Account] = {}
        self.users: Dict[str, User] = {}
        self.lock = threading.Lock()
        self.logger = logging.getLogger(__name__)
    
    def create_user(self, name: str, email: str, phone: str) -> User:
        """åˆ›å»ºç”¨æˆ·"""
        user_id = str(uuid.uuid4())
        user = User(id=user_id, name=name, email=email, phone=phone)
        self.users[user_id] = user
        self.logger.info(f"Created user: {user}")
        return user
    
    def create_account(self, owner_id: str, account_type: AccountType, currency: str = "USD") -> Account:
        """åˆ›å»ºè´¦æˆ·"""
        if owner_id not in self.users:
            raise ValueError(f"User {owner_id} not found")
        
        account_id = str(uuid.uuid4())
        account = Account(
            id=account_id,
            owner_id=owner_id,
            account_type=account_type,
            currency=currency
        )
        self.accounts[account_id] = account
        self.logger.info(f"Created account: {account}")
        return account
    
    def create_transaction(self, sender_account_id: str, receiver_account_id: str, 
                          amount: Decimal, payment_method: PaymentMethod, 
                          description: str = "") -> Transaction:
        """åˆ›å»ºäº¤æ˜“"""
        if sender_account_id not in self.accounts:
            raise ValueError(f"Sender account {sender_account_id} not found")
        
        if receiver_account_id not in self.accounts:
            raise ValueError(f"Receiver account {receiver_account_id} not found")
        
        transaction_id = str(uuid.uuid4())
        transaction = Transaction(
            id=transaction_id,
            sender_account_id=sender_account_id,
            receiver_account_id=receiver_account_id,
            amount=amount,
            currency=self.accounts[sender_account_id].currency,
            payment_method=payment_method,
            description=description
        )
        
        # è®¡ç®—è´¹ç”¨
        transaction.fee = self.fee_calculator.calculate_fee(transaction)
        
        self.transactions[transaction_id] = transaction
        self.logger.info(f"Created transaction: {transaction}")
        return transaction
    
    def process_transaction(self, transaction_id: str) -> bool:
        """å¤„ç†äº¤æ˜“"""
        with self.lock:
            if transaction_id not in self.transactions:
                raise ValueError(f"Transaction {transaction_id} not found")
            
            transaction = self.transactions[transaction_id]
            sender_account = self.accounts[transaction.sender_account_id]
            receiver_account = self.accounts[transaction.receiver_account_id]
            
            # éªŒè¯äº¤æ˜“
            is_valid, error_message = self.validator.validate_transaction(transaction, sender_account, receiver_account)
            
            if not is_valid:
                transaction.status = TransactionStatus.FAILED
                self.logger.error(f"Transaction {transaction_id} failed: {error_message}")
                return False
            
            try:
                # æ‰§è¡Œè½¬è´¦
                total_amount = transaction.amount + transaction.fee
                
                # ä»å‘é€æ–¹æ‰£é™¤
                if not sender_account.withdraw(total_amount):
                    transaction.status = TransactionStatus.FAILED
                    self.logger.error(f"Failed to withdraw from sender account")
                    return False
                
                # å‘æ¥æ”¶æ–¹æ·»åŠ 
                if not receiver_account.deposit(transaction.amount):
                    # å›æ»šå‘é€æ–¹çš„æ‰£é™¤
                    sender_account.deposit(total_amount)
                    transaction.status = TransactionStatus.FAILED
                    self.logger.error(f"Failed to deposit to receiver account")
                    return False
                
                # æ›´æ–°äº¤æ˜“çŠ¶æ€
                transaction.status = TransactionStatus.COMPLETED
                transaction.completed_at = time.time()
                
                self.logger.info(f"Transaction {transaction_id} completed successfully")
                return True
                
            except Exception as e:
                transaction.status = TransactionStatus.FAILED
                self.logger.error(f"Transaction {transaction_id} failed with exception: {e}")
                return False
    
    def get_account_balance(self, account_id: str) -> Decimal:
        """è·å–è´¦æˆ·ä½™é¢"""
        if account_id not in self.accounts:
            raise ValueError(f"Account {account_id} not found")
        return self.accounts[account_id].balance
    
    def get_transaction_history(self, account_id: str) -> List[Transaction]:
        """è·å–è´¦æˆ·äº¤æ˜“å†å²"""
        if account_id not in self.accounts:
            raise ValueError(f"Account {account_id} not found")
        
        history = []
        for transaction in self.transactions.values():
            if (transaction.sender_account_id == account_id or 
                transaction.receiver_account_id == account_id):
                history.append(transaction)
        
        return sorted(history, key=lambda t: t.created_at, reverse=True)
    
    def get_system_statistics(self) -> Dict[str, Any]:
        """è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯"""
        total_users = len(self.users)
        total_accounts = len(self.accounts)
        total_transactions = len(self.transactions)
        
        completed_transactions = sum(1 for t in self.transactions.values() 
                                   if t.status == TransactionStatus.COMPLETED)
        failed_transactions = sum(1 for t in self.transactions.values() 
                                if t.status == TransactionStatus.FAILED)
        
        total_volume = sum(t.amount for t in self.transactions.values() 
                          if t.status == TransactionStatus.COMPLETED)
        total_fees = sum(t.fee for t in self.transactions.values() 
                        if t.status == TransactionStatus.COMPLETED)
        
        return {
            'total_users': total_users,
            'total_accounts': total_accounts,
            'total_transactions': total_transactions,
            'completed_transactions': completed_transactions,
            'failed_transactions': failed_transactions,
            'success_rate': completed_transactions / total_transactions if total_transactions > 0 else 0,
            'total_volume': str(total_volume),
            'total_fees': str(total_fees)
        }

class PaymentGateway:
    """æ”¯ä»˜ç½‘å…³"""
    
    def __init__(self, processor: PaymentProcessor):
        self.processor = processor
        self.logger = logging.getLogger(__name__)
    
    def process_payment(self, sender_account_id: str, receiver_account_id: str,
                       amount: Decimal, payment_method: PaymentMethod,
                       description: str = "") -> Dict[str, Any]:
        """å¤„ç†æ”¯ä»˜"""
        try:
            # åˆ›å»ºäº¤æ˜“
            transaction = self.processor.create_transaction(
                sender_account_id, receiver_account_id, amount, payment_method, description
            )
            
            # å¤„ç†äº¤æ˜“
            success = self.processor.process_transaction(transaction.id)
            
            return {
                'success': success,
                'transaction_id': transaction.id,
                'status': transaction.status.value,
                'amount': str(transaction.amount),
                'fee': str(transaction.fee),
                'message': 'Payment processed successfully' if success else 'Payment failed'
            }
            
        except Exception as e:
            self.logger.error(f"Payment processing failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'message': 'Payment processing failed'
            }
    
    def get_payment_status(self, transaction_id: str) -> Dict[str, Any]:
        """è·å–æ”¯ä»˜çŠ¶æ€"""
        if transaction_id not in self.processor.transactions:
            return {
                'success': False,
                'error': 'Transaction not found'
            }
        
        transaction = self.processor.transactions[transaction_id]
        return {
            'success': True,
            'transaction_id': transaction.id,
            'status': transaction.status.value,
            'amount': str(transaction.amount),
            'fee': str(transaction.fee),
            'created_at': transaction.created_at,
            'completed_at': transaction.completed_at
        }

# æ¼”ç¤ºå’Œæµ‹è¯•
def demonstrate_payment_system():
    """æ¼”ç¤ºæ”¯ä»˜ç³»ç»Ÿçš„ä½¿ç”¨"""
    
    print("=== æ”¯ä»˜ç³»ç»Ÿæ¼”ç¤º ===\n")
    
    # è®¾ç½®æ—¥å¿—
    logging.basicConfig(level=logging.INFO)
    
    # åˆ›å»ºæ”¯ä»˜ç³»ç»Ÿç»„ä»¶
    validator = BasicPaymentValidator()
    fee_calculator = PercentageFeeCalculator(Decimal('0.02'))  # 2% è´¹ç”¨
    processor = PaymentProcessor(validator, fee_calculator)
    gateway = PaymentGateway(processor)
    
    # 1. åˆ›å»ºç”¨æˆ·å’Œè´¦æˆ·
    print("1. åˆ›å»ºç”¨æˆ·å’Œè´¦æˆ·")
    
    # åˆ›å»ºç”¨æˆ·
    alice = processor.create_user("Alice", "alice@example.com", "+1234567890")
    bob = processor.create_user("Bob", "bob@example.com", "+0987654321")
    charlie = processor.create_user("Charlie", "charlie@example.com", "+1122334455")
    
    # åˆ›å»ºè´¦æˆ·
    alice_account = processor.create_account(alice.id, AccountType.CHECKING)
    bob_account = processor.create_account(bob.id, AccountType.SAVINGS)
    charlie_account = processor.create_account(charlie.id, AccountType.CREDIT)
    
    # åˆå§‹å­˜æ¬¾
    alice_account.deposit(Decimal('1000.00'))
    bob_account.deposit(Decimal('500.00'))
    charlie_account.deposit(Decimal('2000.00'))
    
    print(f"Aliceè´¦æˆ·ä½™é¢: {alice_account.balance}")
    print(f"Bobè´¦æˆ·ä½™é¢: {bob_account.balance}")
    print(f"Charlieè´¦æˆ·ä½™é¢: {charlie_account.balance}\n")
    
    # 2. å¤„ç†æ”¯ä»˜
    print("2. å¤„ç†æ”¯ä»˜")
    
    # Aliceå‘Bobæ”¯ä»˜100ç¾å…ƒ
    payment1 = gateway.process_payment(
        alice_account.id, bob_account.id, 
        Decimal('100.00'), PaymentMethod.BANK_TRANSFER,
        "Payment for services"
    )
    print(f"Aliceå‘Bobæ”¯ä»˜100ç¾å…ƒ: {payment1}")
    
    # Bobå‘Charlieæ”¯ä»˜50ç¾å…ƒ
    payment2 = gateway.process_payment(
        bob_account.id, charlie_account.id,
        Decimal('50.00'), PaymentMethod.DIGITAL_WALLET,
        "Lunch payment"
    )
    print(f"Bobå‘Charlieæ”¯ä»˜50ç¾å…ƒ: {payment2}")
    
    # Charlieå‘Aliceæ”¯ä»˜75ç¾å…ƒ
    payment3 = gateway.process_payment(
        charlie_account.id, alice_account.id,
        Decimal('75.00'), PaymentMethod.CREDIT_CARD,
        "Book purchase"
    )
    print(f"Charlieå‘Aliceæ”¯ä»˜75ç¾å…ƒ: {payment3}\n")
    
    # 3. æŸ¥çœ‹è´¦æˆ·ä½™é¢
    print("3. æŸ¥çœ‹è´¦æˆ·ä½™é¢")
    print(f"Aliceè´¦æˆ·ä½™é¢: {processor.get_account_balance(alice_account.id)}")
    print(f"Bobè´¦æˆ·ä½™é¢: {processor.get_account_balance(bob_account.id)}")
    print(f"Charlieè´¦æˆ·ä½™é¢: {processor.get_account_balance(charlie_account.id)}\n")
    
    # 4. æŸ¥çœ‹äº¤æ˜“å†å²
    print("4. Aliceçš„äº¤æ˜“å†å²")
    alice_history = processor.get_transaction_history(alice_account.id)
    for transaction in alice_history:
        print(f"  {transaction.created_at}: {transaction.amount} {transaction.currency} "
              f"({transaction.status.value}) - {transaction.description}")
    print()
    
    # 5. ç³»ç»Ÿç»Ÿè®¡
    print("5. ç³»ç»Ÿç»Ÿè®¡")
    stats = processor.get_system_statistics()
    for key, value in stats.items():
        print(f"  {key}: {value}")
    print()
    
    # 6. é”™è¯¯å¤„ç†æ¼”ç¤º
    print("6. é”™è¯¯å¤„ç†æ¼”ç¤º")
    
    # å°è¯•æ”¯ä»˜è¶…è¿‡ä½™é¢çš„é‡‘é¢
    payment4 = gateway.process_payment(
        alice_account.id, bob_account.id,
        Decimal('10000.00'), PaymentMethod.BANK_TRANSFER,
        "Large payment"
    )
    print(f"å°è¯•æ”¯ä»˜è¶…è¿‡ä½™é¢çš„é‡‘é¢: {payment4}")
    
    # å°è¯•å‘ä¸å­˜åœ¨çš„è´¦æˆ·æ”¯ä»˜
    try:
        payment5 = gateway.process_payment(
            alice_account.id, "non-existent-account",
            Decimal('10.00'), PaymentMethod.BANK_TRANSFER,
            "Invalid payment"
        )
        print(f"å°è¯•å‘ä¸å­˜åœ¨çš„è´¦æˆ·æ”¯ä»˜: {payment5}")
    except Exception as e:
        print(f"å°è¯•å‘ä¸å­˜åœ¨çš„è´¦æˆ·æ”¯ä»˜: é”™è¯¯ - {e}")

if __name__ == "__main__":
    demonstrate_payment_system()
```

## ğŸ“Š æ”¯ä»˜ç³»ç»Ÿæ¶æ„

### 2.1 ç³»ç»Ÿç»„ä»¶

#### 2.1.1 æ ¸å¿ƒç»„ä»¶

**å®šä¹‰ 2.1** (æ”¯ä»˜ç½‘å…³)
æ”¯ä»˜ç½‘å…³æ˜¯æ”¯ä»˜ç³»ç»Ÿçš„å…¥å£ç‚¹ï¼š
$$Gateway = (API, Auth, RateLimit, Logging)$$

**å®šä¹‰ 2.2** (æ”¯ä»˜å¤„ç†å™¨)
æ”¯ä»˜å¤„ç†å™¨è´Ÿè´£ä¸šåŠ¡é€»è¾‘ï¼š
$$Processor = (Validator, Calculator, Executor, Auditor)$$

**å®šä¹‰ 2.3** (æ¸…ç®—ç³»ç»Ÿ)
æ¸…ç®—ç³»ç»Ÿè´Ÿè´£èµ„é‡‘ç»“ç®—ï¼š
$$Settlement = (Netting, Clearing, Settlement, Reconciliation)$$

#### 2.1.2 å®‰å…¨ç»„ä»¶

**å®šä¹‰ 2.4** (åŠ å¯†ç³»ç»Ÿ)
åŠ å¯†ç³»ç»Ÿä¿æŠ¤æ•æ„Ÿæ•°æ®ï¼š
$$Crypto = (Encrypt, Decrypt, Hash, Sign, Verify)$$

**å®šä¹‰ 2.5** (è®¤è¯ç³»ç»Ÿ)
è®¤è¯ç³»ç»ŸéªŒè¯ç”¨æˆ·èº«ä»½ï¼š
$$Auth = (Login, Logout, Token, Session, Permission)$$

### 2.2 æ•°æ®æµ

#### 2.2.1 æ”¯ä»˜æµç¨‹

**å®šç† 2.1** (æ”¯ä»˜æµç¨‹å®Œæ•´æ€§)
å®Œæ•´çš„æ”¯ä»˜æµç¨‹å¿…é¡»åŒ…å«ä»¥ä¸‹æ­¥éª¤ï¼š

1. äº¤æ˜“éªŒè¯
2. ä½™é¢æ£€æŸ¥
3. èµ„é‡‘è½¬ç§»
4. çŠ¶æ€æ›´æ–°
5. é€šçŸ¥å‘é€

**è¯æ˜**:

1. äº¤æ˜“éªŒè¯ç¡®ä¿äº¤æ˜“åˆæ³•æ€§
2. ä½™é¢æ£€æŸ¥é˜²æ­¢è¶…é¢æ”¯ä»˜
3. èµ„é‡‘è½¬ç§»æ‰§è¡Œå®é™…è½¬è´¦
4. çŠ¶æ€æ›´æ–°è®°å½•äº¤æ˜“ç»“æœ
5. é€šçŸ¥å‘é€å‘ŠçŸ¥ç›¸å…³æ–¹

#### 2.2.2 é”™è¯¯å¤„ç†

**å®šç† 2.2** (é”™è¯¯å¤„ç†å®Œå¤‡æ€§)
æ”¯ä»˜ç³»ç»Ÿå¿…é¡»å¤„ç†ä»¥ä¸‹é”™è¯¯ç±»å‹ï¼š

1. ç½‘ç»œé”™è¯¯
2. ä½™é¢ä¸è¶³
3. è´¦æˆ·å†»ç»“
4. ç³»ç»Ÿæ•…éšœ
5. å®‰å…¨å¨èƒ

## ğŸ” æ€§èƒ½åˆ†æ

### 3.1 ååé‡åˆ†æ

#### 3.1.1 å¹¶å‘å¤„ç†

**å®šä¹‰ 3.1** (ç³»ç»Ÿååé‡)
ç³»ç»Ÿååé‡å®šä¹‰ä¸ºï¼š
$$Throughput = \frac{Transactions}{Time}$$

**å®šç† 3.1** (å¹¶å‘å¤„ç†èƒ½åŠ›)
å¦‚æœç³»ç»Ÿæœ‰ $n$ ä¸ªå¤„ç†çº¿ç¨‹ï¼Œåˆ™ç†è®ºæœ€å¤§ååé‡ä¸ºï¼š
$$MaxThroughput = n \times \frac{1}{AverageProcessingTime}$$

#### 3.1.2 å»¶è¿Ÿåˆ†æ

**å®šä¹‰ 3.2** (å¤„ç†å»¶è¿Ÿ)
å¤„ç†å»¶è¿ŸåŒ…æ‹¬ï¼š

- ç½‘ç»œå»¶è¿Ÿï¼š$T_{network}$
- å¤„ç†å»¶è¿Ÿï¼š$T_{process}$
- å­˜å‚¨å»¶è¿Ÿï¼š$T_{storage}$
- æ€»å»¶è¿Ÿï¼š$T_{total} = T_{network} + T_{process} + T_{storage}$

### 3.2 å¯ç”¨æ€§åˆ†æ

#### 3.2.1 ç³»ç»Ÿå¯ç”¨æ€§

**å®šä¹‰ 3.3** (ç³»ç»Ÿå¯ç”¨æ€§)
ç³»ç»Ÿå¯ç”¨æ€§å®šä¹‰ä¸ºï¼š
$$Availability = \frac{Uptime}{Uptime + Downtime}$$

**å®šç† 3.3** (é«˜å¯ç”¨æ€§è¦æ±‚)
æ”¯ä»˜ç³»ç»Ÿçš„å¯ç”¨æ€§è¦æ±‚ï¼š
$$Availability \geq 99.9\%$$

#### 3.2.2 æ•…éšœæ¢å¤

**å®šä¹‰ 3.4** (æ•…éšœæ¢å¤æ—¶é—´)
æ•…éšœæ¢å¤æ—¶é—´åŒ…æ‹¬ï¼š

- æ•…éšœæ£€æµ‹æ—¶é—´ï¼š$T_{detect}$
- æ•…éšœå®šä½æ—¶é—´ï¼š$T_{locate}$
- æ•…éšœä¿®å¤æ—¶é—´ï¼š$T_{repair}$
- æœåŠ¡æ¢å¤æ—¶é—´ï¼š$T_{recover}$

## ğŸ¯ å®‰å…¨æœºåˆ¶

### 4.1 æ•°æ®å®‰å…¨

#### 4.1.1 åŠ å¯†ç®—æ³•

**å®šä¹‰ 4.1** (æ•°æ®åŠ å¯†)
æ•æ„Ÿæ•°æ®åŠ å¯†ä½¿ç”¨ï¼š
$$Encrypt(data, key) = ciphertext$$
$$Decrypt(ciphertext, key) = data$$

**å®šç† 4.1** (åŠ å¯†å®‰å…¨æ€§)
ä½¿ç”¨AES-256åŠ å¯†ç®—æ³•ï¼Œå¯†é’¥ç©ºé—´ä¸ºï¼š
$$|KeySpace| = 2^{256}$$

#### 4.1.2 å“ˆå¸Œå‡½æ•°

**å®šä¹‰ 4.2** (æ•°æ®å“ˆå¸Œ)
æ•°æ®å®Œæ•´æ€§éªŒè¯ä½¿ç”¨ï¼š
$$Hash(data) = digest$$

**å®šç† 4.2** (å“ˆå¸Œç¢°æ’æ¦‚ç‡)
ä½¿ç”¨SHA-256å“ˆå¸Œå‡½æ•°ï¼Œç¢°æ’æ¦‚ç‡ä¸ºï¼š
$$P(collision) = \frac{1}{2^{256}}$$

### 4.2 äº¤æ˜“å®‰å…¨

#### 4.2.1 æ•°å­—ç­¾å

**å®šä¹‰ 4.3** (æ•°å­—ç­¾å)
äº¤æ˜“ç­¾åä½¿ç”¨ï¼š
$$Sign(transaction, privateKey) = signature$$
$$Verify(transaction, signature, publicKey) = valid$$

#### 4.2.2 é˜²é‡æ”¾æ”»å‡»

**å®šç† 4.3** (é˜²é‡æ”¾æœºåˆ¶)
ä½¿ç”¨æ—¶é—´æˆ³å’Œéšæœºæ•°é˜²æ­¢é‡æ”¾æ”»å‡»ï¼š
$$Nonce = timestamp + random$$

## ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### 5.1 æ°´å¹³æ‰©å±•

#### 5.1.1 è´Ÿè½½å‡è¡¡

**å®šä¹‰ 5.1** (è´Ÿè½½å‡è¡¡)
è´Ÿè½½å‡è¡¡ç®—æ³•åŒ…æ‹¬ï¼š

- è½®è¯¢ï¼š$RoundRobin(i) = i \bmod n$
- åŠ æƒè½®è¯¢ï¼š$WeightedRoundRobin(i, w) = \arg\max_j w_j$
- æœ€å°‘è¿æ¥ï¼š$LeastConnection(i) = \arg\min_j connections_j$

#### 5.1.2 åˆ†ç‰‡ç­–ç•¥

**å®šä¹‰ 5.2** (æ•°æ®åˆ†ç‰‡)
æ•°æ®åˆ†ç‰‡ç­–ç•¥ï¼š
$$Shard(data) = hash(data.id) \bmod numShards$$

### 5.2 å‚ç›´æ‰©å±•

#### 5.2.1 ç¼“å­˜ä¼˜åŒ–

**å®šç† 5.1** (ç¼“å­˜å‘½ä¸­ç‡)
ç¼“å­˜å‘½ä¸­ç‡å½±å“ç³»ç»Ÿæ€§èƒ½ï¼š
$$Performance = hitRate \times cacheSpeed + (1 - hitRate) \times diskSpeed$$

#### 5.2.2 æ•°æ®åº“ä¼˜åŒ–

**å®šä¹‰ 5.3** (ç´¢å¼•ä¼˜åŒ–)
ç´¢å¼•ä¼˜åŒ–ç­–ç•¥ï¼š

- B+æ ‘ç´¢å¼•ï¼š$O(\log n)$ æŸ¥è¯¢æ—¶é—´
- å“ˆå¸Œç´¢å¼•ï¼š$O(1)$ æŸ¥è¯¢æ—¶é—´
- å¤åˆç´¢å¼•ï¼šå¤šå­—æ®µç»„åˆç´¢å¼•

## ğŸ”— ç›¸å…³é“¾æ¥

- [04-01-02 é£æ§ç³»ç»Ÿ](./04-01-02-é£æ§ç³»ç»Ÿ.md)
- [04-01-03 äº¤æ˜“ç³»ç»Ÿ](./04-01-03-äº¤æ˜“ç³»ç»Ÿ.md)
- [05-01-01 æœåŠ¡æ‹†åˆ†](../../05-æ¶æ„é¢†åŸŸ/05-01-å¾®æœåŠ¡æ¶æ„/05-01-01-æœåŠ¡æ‹†åˆ†.md)
- [06-01-01 åˆ›å»ºå‹æ¨¡å¼å®ç°](../../06-ç»„ä»¶ç®—æ³•/06-01-è®¾è®¡æ¨¡å¼å®ç°/06-01-01-åˆ›å»ºå‹æ¨¡å¼å®ç°.md)

---

*æœ¬æ–‡æ¡£å»ºç«‹äº†æ”¯ä»˜ç³»ç»Ÿçš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼Œä»å½¢å¼åŒ–å®šä¹‰åˆ°å®é™…å®ç°ï¼Œä¸ºé‡‘èç§‘æŠ€é¢†åŸŸçš„å‘å±•å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚*
