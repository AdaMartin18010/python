# 04-01-01 支付系统

## 概述

支付系统是金融科技的核心基础设施，负责处理资金转移、交易验证和结算。本文档从技术角度系统介绍现代支付系统的架构设计、安全机制和实现方案。

## 系统架构

### 支付系统分层架构

```text
┌─────────────────────────────────────┐
│           用户界面层                │
├─────────────────────────────────────┤
│           业务逻辑层                │
├─────────────────────────────────────┤
│           支付处理层                │
├─────────────────────────────────────┤
│           安全认证层                │
├─────────────────────────────────────┤
│           数据存储层                │
└─────────────────────────────────────┘
```

### 核心组件

1. **支付网关**: 处理支付请求和响应
2. **风控引擎**: 实时风险评估和决策
3. **清算系统**: 处理资金结算和对账
4. **安全模块**: 加密、认证和防欺诈
5. **监控系统**: 实时监控和告警

## Python实现

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import hashlib
import hmac
import json
import time
import uuid
from decimal import Decimal
import asyncio
import logging

class PaymentStatus(Enum):
    """支付状态枚举"""
    PENDING = "pending"
    PROCESSING = "processing"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"

class PaymentMethod(Enum):
    """支付方式枚举"""
    CREDIT_CARD = "credit_card"
    DEBIT_CARD = "debit_card"
    BANK_TRANSFER = "bank_transfer"
    DIGITAL_WALLET = "digital_wallet"
    CRYPTO = "crypto"

@dataclass
class PaymentRequest:
    """支付请求"""
    id: str
    amount: Decimal
    currency: str
    method: PaymentMethod
    merchant_id: str
    customer_id: str
    description: str
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

@dataclass
class PaymentResponse:
    """支付响应"""
    request_id: str
    status: PaymentStatus
    transaction_id: str
    amount: Decimal
    currency: str
    timestamp: float
    message: str
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class PaymentProcessor(ABC):
    """支付处理器抽象基类"""
    
    @abstractmethod
    async def process_payment(self, request: PaymentRequest) -> PaymentResponse:
        """处理支付请求"""
        pass
    
    @abstractmethod
    async def verify_payment(self, transaction_id: str) -> PaymentResponse:
        """验证支付状态"""
        pass
    
    @abstractmethod
    async def refund_payment(self, transaction_id: str, amount: Decimal) -> PaymentResponse:
        """退款处理"""
        pass

class CreditCardProcessor(PaymentProcessor):
    """信用卡支付处理器"""
    
    def __init__(self, api_key: str, secret_key: str):
        self.api_key = api_key
        self.secret_key = secret_key
        self.logger = logging.getLogger(__name__)
    
    async def process_payment(self, request: PaymentRequest) -> PaymentResponse:
        """处理信用卡支付"""
        try:
            # 验证请求
            self._validate_request(request)
            
            # 风险评估
            risk_score = await self._assess_risk(request)
            if risk_score > 0.8:
                return PaymentResponse(
                    request_id=request.id,
                    status=PaymentStatus.FAILED,
                    transaction_id="",
                    amount=request.amount,
                    currency=request.currency,
                    timestamp=time.time(),
                    message="Risk assessment failed"
                )
            
            # 处理支付
            transaction_id = self._generate_transaction_id()
            
            # 模拟支付处理
            await asyncio.sleep(0.1)
            
            return PaymentResponse(
                request_id=request.id,
                status=PaymentStatus.SUCCESS,
                transaction_id=transaction_id,
                amount=request.amount,
                currency=request.currency,
                timestamp=time.time(),
                message="Payment processed successfully"
            )
            
        except Exception as e:
            self.logger.error(f"Payment processing failed: {e}")
            return PaymentResponse(
                request_id=request.id,
                status=PaymentStatus.FAILED,
                transaction_id="",
                amount=request.amount,
                currency=request.currency,
                timestamp=time.time(),
                message=str(e)
            )
    
    async def verify_payment(self, transaction_id: str) -> PaymentResponse:
        """验证支付状态"""
        # 模拟验证过程
        await asyncio.sleep(0.05)
        
        return PaymentResponse(
            request_id="",
            status=PaymentStatus.SUCCESS,
            transaction_id=transaction_id,
            amount=Decimal("0"),
            currency="USD",
            timestamp=time.time(),
            message="Payment verified"
        )
    
    async def refund_payment(self, transaction_id: str, amount: Decimal) -> PaymentResponse:
        """退款处理"""
        # 模拟退款过程
        await asyncio.sleep(0.1)
        
        return PaymentResponse(
            request_id="",
            status=PaymentStatus.SUCCESS,
            transaction_id=transaction_id,
            amount=amount,
            currency="USD",
            timestamp=time.time(),
            message="Refund processed successfully"
        )
    
    def _validate_request(self, request: PaymentRequest):
        """验证支付请求"""
        if request.amount <= 0:
            raise ValueError("Amount must be positive")
        
        if not request.currency:
            raise ValueError("Currency is required")
        
        if not request.merchant_id:
            raise ValueError("Merchant ID is required")
    
    async def _assess_risk(self, request: PaymentRequest) -> float:
        """风险评估"""
        # 简化的风险评估逻辑
        risk_factors = []
        
        # 金额风险
        if request.amount > 10000:
            risk_factors.append(0.3)
        
        # 频率风险
        # 这里应该查询历史交易记录
        
        # 地理位置风险
        # 这里应该检查IP地址
        
        return sum(risk_factors) if risk_factors else 0.1
    
    def _generate_transaction_id(self) -> str:
        """生成交易ID"""
        return f"txn_{uuid.uuid4().hex[:16]}"

class RiskEngine:
    """风控引擎"""
    
    def __init__(self):
        self.rules = []
        self.logger = logging.getLogger(__name__)
    
    def add_rule(self, rule: callable):
        """添加风控规则"""
        self.rules.append(rule)
    
    async def evaluate_risk(self, request: PaymentRequest) -> Dict[str, Any]:
        """评估风险"""
        risk_score = 0.0
        risk_factors = []
        
        for rule in self.rules:
            try:
                factor = await rule(request)
                risk_factors.append(factor)
                risk_score += factor['score']
            except Exception as e:
                self.logger.error(f"Risk rule evaluation failed: {e}")
        
        return {
            'risk_score': min(risk_score, 1.0),
            'risk_factors': risk_factors,
            'recommendation': 'approve' if risk_score < 0.7 else 'review'
        }

class SecurityModule:
    """安全模块"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key.encode('utf-8')
    
    def encrypt_data(self, data: str) -> str:
        """加密数据"""
        # 使用HMAC进行数据完整性验证
        h = hmac.new(self.secret_key, data.encode('utf-8'), hashlib.sha256)
        return h.hexdigest()
    
    def verify_signature(self, data: str, signature: str) -> bool:
        """验证签名"""
        expected_signature = self.encrypt_data(data)
        return hmac.compare_digest(signature, expected_signature)
    
    def generate_token(self, user_id: str, expiry: int = 3600) -> str:
        """生成访问令牌"""
        payload = {
            'user_id': user_id,
            'exp': int(time.time()) + expiry
        }
        
        # 简化的JWT实现
        header = {'alg': 'HS256', 'typ': 'JWT'}
        header_b64 = self._base64_encode(json.dumps(header))
        payload_b64 = self._base64_encode(json.dumps(payload))
        
        signature = self.encrypt_data(f"{header_b64}.{payload_b64}")
        
        return f"{header_b64}.{payload_b64}.{signature}"
    
    def _base64_encode(self, data: str) -> str:
        """Base64编码"""
        import base64
        return base64.urlsafe_b64encode(data.encode('utf-8')).decode('utf-8').rstrip('=')

class PaymentGateway:
    """支付网关"""
    
    def __init__(self):
        self.processors: Dict[PaymentMethod, PaymentProcessor] = {}
        self.risk_engine = RiskEngine()
        self.security = SecurityModule("your-secret-key")
        self.logger = logging.getLogger(__name__)
        
        # 初始化风控规则
        self._initialize_risk_rules()
    
    def register_processor(self, method: PaymentMethod, processor: PaymentProcessor):
        """注册支付处理器"""
        self.processors[method] = processor
    
    async def process_payment(self, request: PaymentRequest) -> PaymentResponse:
        """处理支付"""
        try:
            # 验证请求
            self._validate_request(request)
            
            # 风险评估
            risk_result = await self.risk_engine.evaluate_risk(request)
            if risk_result['recommendation'] == 'review':
                return PaymentResponse(
                    request_id=request.id,
                    status=PaymentStatus.PENDING,
                    transaction_id="",
                    amount=request.amount,
                    currency=request.currency,
                    timestamp=time.time(),
                    message="Payment under review"
                )
            
            # 获取处理器
            processor = self.processors.get(request.method)
            if not processor:
                raise ValueError(f"Unsupported payment method: {request.method}")
            
            # 处理支付
            response = await processor.process_payment(request)
            
            # 记录日志
            self.logger.info(f"Payment processed: {request.id} -> {response.status}")
            
            return response
            
        except Exception as e:
            self.logger.error(f"Payment processing failed: {e}")
            return PaymentResponse(
                request_id=request.id,
                status=PaymentStatus.FAILED,
                transaction_id="",
                amount=request.amount,
                currency=request.currency,
                timestamp=time.time(),
                message=str(e)
            )
    
    def _validate_request(self, request: PaymentRequest):
        """验证请求"""
        if not request.id:
            raise ValueError("Request ID is required")
        
        if request.amount <= 0:
            raise ValueError("Amount must be positive")
        
        if not request.currency:
            raise ValueError("Currency is required")
    
    def _initialize_risk_rules(self):
        """初始化风控规则"""
        
        async def amount_rule(request: PaymentRequest) -> Dict[str, Any]:
            """金额规则"""
            if request.amount > 10000:
                return {'type': 'amount', 'score': 0.3, 'reason': 'High amount'}
            return {'type': 'amount', 'score': 0.0, 'reason': 'Normal amount'}
        
        async def frequency_rule(request: PaymentRequest) -> Dict[str, Any]:
            """频率规则"""
            # 这里应该查询数据库
            return {'type': 'frequency', 'score': 0.1, 'reason': 'Normal frequency'}
        
        self.risk_engine.add_rule(amount_rule)
        self.risk_engine.add_rule(frequency_rule)

class PaymentMonitor:
    """支付监控系统"""
    
    def __init__(self):
        self.metrics = {
            'total_transactions': 0,
            'successful_transactions': 0,
            'failed_transactions': 0,
            'total_amount': Decimal('0'),
            'average_amount': Decimal('0')
        }
        self.alerts = []
        self.logger = logging.getLogger(__name__)
    
    def record_transaction(self, response: PaymentResponse):
        """记录交易"""
        self.metrics['total_transactions'] += 1
        self.metrics['total_amount'] += response.amount
        
        if response.status == PaymentStatus.SUCCESS:
            self.metrics['successful_transactions'] += 1
        elif response.status == PaymentStatus.FAILED:
            self.metrics['failed_transactions'] += 1
        
        # 计算平均金额
        if self.metrics['total_transactions'] > 0:
            self.metrics['average_amount'] = (
                self.metrics['total_amount'] / self.metrics['total_transactions']
            )
        
        # 检查告警条件
        self._check_alerts(response)
    
    def _check_alerts(self, response: PaymentResponse):
        """检查告警条件"""
        # 失败率告警
        if self.metrics['total_transactions'] > 0:
            failure_rate = self.metrics['failed_transactions'] / self.metrics['total_transactions']
            if failure_rate > 0.1:  # 失败率超过10%
                alert = {
                    'type': 'high_failure_rate',
                    'message': f'Failure rate is {failure_rate:.2%}',
                    'timestamp': time.time()
                }
                self.alerts.append(alert)
                self.logger.warning(f"High failure rate alert: {failure_rate:.2%}")
        
        # 大额交易告警
        if response.amount > 50000:
            alert = {
                'type': 'large_transaction',
                'message': f'Large transaction: {response.amount}',
                'timestamp': time.time()
            }
            self.alerts.append(alert)
            self.logger.warning(f"Large transaction alert: {response.amount}")
    
    def get_metrics(self) -> Dict[str, Any]:
        """获取指标"""
        return self.metrics.copy()
    
    def get_alerts(self) -> List[Dict[str, Any]]:
        """获取告警"""
        return self.alerts.copy()

# 使用示例
async def demonstrate_payment_system():
    """演示支付系统"""
    
    # 创建支付网关
    gateway = PaymentGateway()
    
    # 注册支付处理器
    credit_card_processor = CreditCardProcessor("api_key", "secret_key")
    gateway.register_processor(PaymentMethod.CREDIT_CARD, credit_card_processor)
    
    # 创建监控系统
    monitor = PaymentMonitor()
    
    # 创建支付请求
    requests = [
        PaymentRequest(
            id=f"req_{i}",
            amount=Decimal("100.00"),
            currency="USD",
            method=PaymentMethod.CREDIT_CARD,
            merchant_id="merchant_001",
            customer_id="customer_001",
            description=f"Payment {i}"
        )
        for i in range(5)
    ]
    
    print("处理支付请求:")
    print("-" * 50)
    
    for request in requests:
        print(f"处理请求: {request.id}")
        
        # 处理支付
        response = await gateway.process_payment(request)
        
        # 记录监控
        monitor.record_transaction(response)
        
        print(f"  状态: {response.status.value}")
        print(f"  交易ID: {response.transaction_id}")
        print(f"  消息: {response.message}")
        print()
    
    # 显示监控指标
    print("监控指标:")
    print("-" * 50)
    metrics = monitor.get_metrics()
    for key, value in metrics.items():
        print(f"{key}: {value}")
    
    # 显示告警
    print("\n告警信息:")
    print("-" * 50)
    alerts = monitor.get_alerts()
    for alert in alerts:
        print(f"类型: {alert['type']}")
        print(f"消息: {alert['message']}")
        print(f"时间: {alert['timestamp']}")
        print()

if __name__ == "__main__":
    asyncio.run(demonstrate_payment_system())
```

## 安全机制

### 1. 数据加密

- **传输加密**: 使用TLS/SSL加密传输数据
- **存储加密**: 敏感数据使用AES加密存储
- **密钥管理**: 使用硬件安全模块(HSM)管理密钥

### 2. 身份认证

- **多因子认证**: 密码、短信验证码、生物识别
- **OAuth 2.0**: 第三方身份认证
- **JWT令牌**: 无状态的身份验证

### 3. 风控系统

- **实时监控**: 监控异常交易行为
- **机器学习**: 使用ML模型识别欺诈
- **规则引擎**: 基于规则的实时决策

## 性能优化

### 1. 高并发处理

- **异步处理**: 使用异步编程处理并发请求
- **连接池**: 数据库连接池优化
- **缓存策略**: Redis缓存热点数据

### 2. 分布式架构

- **微服务**: 服务拆分和独立部署
- **负载均衡**: 请求分发和故障转移
- **数据分片**: 数据库水平分片

## 总结

支付系统是金融科技的核心基础设施，需要：

1. **高可用性**: 7x24小时稳定运行
2. **高安全性**: 多重安全防护机制
3. **高性能**: 支持高并发交易处理
4. **可扩展性**: 支持业务快速增长
5. **合规性**: 符合金融监管要求

现代支付系统将继续向智能化、去中心化和全球化方向发展。
