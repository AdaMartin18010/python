# 网络安全基础理论

## 📋 概述

网络安全是保护计算机系统、网络和数据免受未经授权访问、使用、披露、中断、修改或破坏的技术和实践。本文档从形式化理论角度阐述网络安全的基础概念、加密算法和安全机制。

## 1. 形式化定义

### 1.1 安全系统定义

**定义 1.1** (安全系统)
安全系统是一个五元组：
$$\text{SecuritySystem} = (U, R, P, A, C)$$

其中：
- $U$ 是用户集合
- $R$ 是资源集合
- $P$ 是权限集合
- $A$ 是访问控制矩阵
- $C$ 是约束条件

### 1.2 加密系统定义

**定义 1.2** (加密系统)
加密系统是一个三元组：
$$\text{CryptoSystem} = (K, E, D)$$

其中：
- $K$ 是密钥空间
- $E: M \times K \rightarrow C$ 是加密函数
- $D: C \times K \rightarrow M$ 是解密函数

### 1.3 访问控制定义

**定义 1.3** (访问控制)
访问控制是一个函数：
$$\text{AccessControl}: U \times R \times P \rightarrow \{\text{Allow}, \text{Deny}\}$$

## 2. 核心概念

### 2.1 密码学基础

**定义 2.1** (对称加密)
对称加密满足：
$$D(E(m, k), k) = m$$

**定义 2.2** (非对称加密)
非对称加密满足：
$$D(E(m, k_{pub}), k_{priv}) = m$$

**算法 2.1** (RSA加密)
```python
def rsa_encrypt(message: int, public_key: Tuple[int, int]) -> int:
    """
    RSA加密算法
    
    参数:
        message: 明文消息
        public_key: 公钥 (e, n)
        
    返回:
        密文
    """
    e, n = public_key
    return pow(message, e, n)

def rsa_decrypt(ciphertext: int, private_key: Tuple[int, int]) -> int:
    """
    RSA解密算法
    
    参数:
        ciphertext: 密文
        private_key: 私钥 (d, n)
        
    返回:
        明文
    """
    d, n = private_key
    return pow(ciphertext, d, n)
```

### 2.2 哈希函数

**定义 2.3** (哈希函数)
哈希函数：
$$H: \{0,1\}^* \rightarrow \{0,1\}^{n}$$

**性质 2.1** (哈希函数性质)
1. **确定性**: $H(x) = H(x)$
2. **雪崩效应**: 输入的微小变化导致输出的巨大变化
3. **单向性**: 从 $H(x)$ 难以计算 $x$
4. **抗碰撞性**: 难以找到 $x \neq y$ 使得 $H(x) = H(y)$

## 3. Python实现

### 3.1 加密系统实现

```python
from typing import Tuple, List, Dict, Optional, Any
from dataclasses import dataclass
from abc import ABC, abstractmethod
import hashlib
import hmac
import secrets
import base64
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

@dataclass
class User:
    """用户"""
    user_id: str
    username: str
    password_hash: str
    salt: str
    permissions: List[str]
    
    def verify_password(self, password: str) -> bool:
        """验证密码"""
        return hash_password(password, self.salt) == self.password_hash

@dataclass
class Resource:
    """资源"""
    resource_id: str
    name: str
    type: str
    owner: str
    permissions: Dict[str, List[str]]  # 权限 -> 用户列表

class CryptoSystem:
    """加密系统"""
    
    def __init__(self):
        self.backend = default_backend()
    
    def generate_rsa_keys(self, key_size: int = 2048) -> Tuple[rsa.RSAPrivateKey, rsa.RSAPublicKey]:
        """生成RSA密钥对"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=self.backend
        )
        public_key = private_key.public_key()
        return private_key, public_key
    
    def rsa_encrypt(self, message: bytes, public_key: rsa.RSAPublicKey) -> bytes:
        """RSA加密"""
        ciphertext = public_key.encrypt(
            message,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return ciphertext
    
    def rsa_decrypt(self, ciphertext: bytes, private_key: rsa.RSAPrivateKey) -> bytes:
        """RSA解密"""
        plaintext = private_key.decrypt(
            ciphertext,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return plaintext
    
    def generate_aes_key(self, key_size: int = 256) -> bytes:
        """生成AES密钥"""
        return secrets.token_bytes(key_size // 8)
    
    def aes_encrypt(self, message: bytes, key: bytes) -> Tuple[bytes, bytes]:
        """AES加密"""
        iv = secrets.token_bytes(16)
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=self.backend
        )
        encryptor = cipher.encryptor()
        
        # PKCS7填充
        padded_message = self._pad_message(message)
        ciphertext = encryptor.update(padded_message) + encryptor.finalize()
        
        return ciphertext, iv
    
    def aes_decrypt(self, ciphertext: bytes, key: bytes, iv: bytes) -> bytes:
        """AES解密"""
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=self.backend
        )
        decryptor = cipher.decryptor()
        
        padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        plaintext = self._unpad_message(padded_plaintext)
        
        return plaintext
    
    def _pad_message(self, message: bytes) -> bytes:
        """PKCS7填充"""
        block_size = 16
        padding_length = block_size - (len(message) % block_size)
        padding = bytes([padding_length] * padding_length)
        return message + padding
    
    def _unpad_message(self, padded_message: bytes) -> bytes:
        """PKCS7去填充"""
        padding_length = padded_message[-1]
        return padded_message[:-padding_length]

class HashFunction:
    """哈希函数"""
    
    @staticmethod
    def sha256(data: bytes) -> str:
        """SHA256哈希"""
        return hashlib.sha256(data).hexdigest()
    
    @staticmethod
    def sha512(data: bytes) -> str:
        """SHA512哈希"""
        return hashlib.sha512(data).hexdigest()
    
    @staticmethod
    def md5(data: bytes) -> str:
        """MD5哈希（不推荐用于安全用途）"""
        return hashlib.md5(data).hexdigest()
    
    @staticmethod
    def hmac_sha256(data: bytes, key: bytes) -> str:
        """HMAC-SHA256"""
        return hmac.new(key, data, hashlib.sha256).hexdigest()

def hash_password(password: str, salt: str) -> str:
    """哈希密码"""
    return HashFunction.sha256((password + salt).encode())

def generate_salt() -> str:
    """生成盐值"""
    return secrets.token_hex(16)

class AccessControlSystem:
    """访问控制系统"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.resources: Dict[str, Resource] = {}
        self.access_matrix: Dict[Tuple[str, str], List[str]] = {}
    
    def add_user(self, user: User):
        """添加用户"""
        self.users[user.user_id] = user
    
    def add_resource(self, resource: Resource):
        """添加资源"""
        self.resources[resource.resource_id] = resource
    
    def grant_permission(self, user_id: str, resource_id: str, permission: str):
        """授予权限"""
        key = (user_id, resource_id)
        if key not in self.access_matrix:
            self.access_matrix[key] = []
        self.access_matrix[key].append(permission)
    
    def revoke_permission(self, user_id: str, resource_id: str, permission: str):
        """撤销权限"""
        key = (user_id, resource_id)
        if key in self.access_matrix and permission in self.access_matrix[key]:
            self.access_matrix[key].remove(permission)
    
    def check_permission(self, user_id: str, resource_id: str, permission: str) -> bool:
        """检查权限"""
        # 检查用户是否存在
        if user_id not in self.users:
            return False
        
        # 检查资源是否存在
        if resource_id not in self.resources:
            return False
        
        # 检查访问矩阵
        key = (user_id, resource_id)
        if key in self.access_matrix:
            return permission in self.access_matrix[key]
        
        # 检查资源所有者
        resource = self.resources[resource_id]
        if resource.owner == user_id:
            return True
        
        return False
    
    def authenticate_user(self, username: str, password: str) -> Optional[User]:
        """用户认证"""
        for user in self.users.values():
            if user.username == username and user.verify_password(password):
                return user
        return None

class Firewall:
    """防火墙"""
    
    def __init__(self):
        self.rules: List[FirewallRule] = []
        self.blocked_ips: Set[str] = set()
        self.allowed_ips: Set[str] = set()
    
    def add_rule(self, rule: 'FirewallRule'):
        """添加规则"""
        self.rules.append(rule)
    
    def block_ip(self, ip: str):
        """阻止IP"""
        self.blocked_ips.add(ip)
    
    def allow_ip(self, ip: str):
        """允许IP"""
        self.allowed_ips.add(ip)
    
    def check_packet(self, packet: 'NetworkPacket') -> bool:
        """检查数据包"""
        # 检查IP黑名单
        if packet.source_ip in self.blocked_ips:
            return False
        
        # 检查IP白名单
        if self.allowed_ips and packet.source_ip not in self.allowed_ips:
            return False
        
        # 检查规则
        for rule in self.rules:
            if rule.matches(packet):
                return rule.action == "allow"
        
        # 默认拒绝
        return False

@dataclass
class FirewallRule:
    """防火墙规则"""
    source_ip: Optional[str]
    dest_ip: Optional[str]
    source_port: Optional[int]
    dest_port: Optional[int]
    protocol: Optional[str]
    action: str  # "allow" or "deny"
    
    def matches(self, packet: 'NetworkPacket') -> bool:
        """检查是否匹配"""
        if self.source_ip and packet.source_ip != self.source_ip:
            return False
        if self.dest_ip and packet.dest_ip != self.dest_ip:
            return False
        if self.source_port and packet.source_port != self.source_port:
            return False
        if self.dest_port and packet.dest_port != self.dest_port:
            return False
        if self.protocol and packet.protocol != self.protocol:
            return False
        return True

@dataclass
class NetworkPacket:
    """网络数据包"""
    source_ip: str
    dest_ip: str
    source_port: int
    dest_port: int
    protocol: str
    data: bytes

class IntrusionDetectionSystem:
    """入侵检测系统"""
    
    def __init__(self):
        self.signatures: List[str] = []
        self.anomaly_threshold = 0.8
        self.attack_patterns: Dict[str, List[str]] = {}
        self.alerts: List[Alert] = []
    
    def add_signature(self, signature: str):
        """添加攻击特征"""
        self.signatures.append(signature)
    
    def add_attack_pattern(self, attack_type: str, patterns: List[str]):
        """添加攻击模式"""
        self.attack_patterns[attack_type] = patterns
    
    def analyze_packet(self, packet: NetworkPacket) -> Optional[Alert]:
        """分析数据包"""
        # 特征检测
        for signature in self.signatures:
            if signature in packet.data.decode('utf-8', errors='ignore'):
                alert = Alert(
                    alert_type="signature_match",
                    severity="high",
                    description=f"检测到攻击特征: {signature}",
                    source_ip=packet.source_ip,
                    timestamp=time.time()
                )
                self.alerts.append(alert)
                return alert
        
        # 异常检测
        anomaly_score = self.calculate_anomaly_score(packet)
        if anomaly_score > self.anomaly_threshold:
            alert = Alert(
                alert_type="anomaly_detected",
                severity="medium",
                description=f"检测到异常行为，分数: {anomaly_score:.2f}",
                source_ip=packet.source_ip,
                timestamp=time.time()
            )
            self.alerts.append(alert)
            return alert
        
        return None
    
    def calculate_anomaly_score(self, packet: NetworkPacket) -> float:
        """计算异常分数"""
        # 简化的异常检测算法
        score = 0.0
        
        # 检查端口扫描
        if packet.dest_port < 1024:
            score += 0.3
        
        # 检查数据包大小
        if len(packet.data) > 1500:
            score += 0.2
        
        # 检查协议异常
        if packet.protocol not in ["TCP", "UDP", "ICMP"]:
            score += 0.5
        
        return min(score, 1.0)

@dataclass
class Alert:
    """安全告警"""
    alert_type: str
    severity: str
    description: str
    source_ip: str
    timestamp: float
    acknowledged: bool = False

class SecurityManager:
    """安全管理器"""
    
    def __init__(self):
        self.crypto_system = CryptoSystem()
        self.access_control = AccessControlSystem()
        self.firewall = Firewall()
        self.ids = IntrusionDetectionSystem()
        self.audit_log: List[AuditEntry] = []
    
    def authenticate_user(self, username: str, password: str) -> Optional[User]:
        """用户认证"""
        user = self.access_control.authenticate_user(username, password)
        if user:
            self.log_audit("login_success", username, f"用户 {username} 登录成功")
        else:
            self.log_audit("login_failure", username, f"用户 {username} 登录失败")
        return user
    
    def access_resource(self, user_id: str, resource_id: str, permission: str) -> bool:
        """访问资源"""
        allowed = self.access_control.check_permission(user_id, resource_id, permission)
        
        if allowed:
            self.log_audit("access_granted", user_id, 
                          f"用户 {user_id} 访问资源 {resource_id}")
        else:
            self.log_audit("access_denied", user_id, 
                          f"用户 {user_id} 被拒绝访问资源 {resource_id}")
        
        return allowed
    
    def process_network_packet(self, packet: NetworkPacket) -> bool:
        """处理网络数据包"""
        # 防火墙检查
        if not self.firewall.check_packet(packet):
            self.log_audit("packet_blocked", packet.source_ip, 
                          f"数据包被防火墙阻止")
            return False
        
        # 入侵检测
        alert = self.ids.analyze_packet(packet)
        if alert:
            self.log_audit("intrusion_detected", packet.source_ip, 
                          f"检测到入侵: {alert.description}")
        
        return True
    
    def encrypt_data(self, data: bytes, public_key: rsa.RSAPublicKey) -> bytes:
        """加密数据"""
        return self.crypto_system.rsa_encrypt(data, public_key)
    
    def decrypt_data(self, ciphertext: bytes, private_key: rsa.RSAPrivateKey) -> bytes:
        """解密数据"""
        return self.crypto_system.rsa_decrypt(ciphertext, private_key)
    
    def log_audit(self, event_type: str, user_id: str, description: str):
        """记录审计日志"""
        entry = AuditEntry(
            event_type=event_type,
            user_id=user_id,
            description=description,
            timestamp=time.time()
        )
        self.audit_log.append(entry)

@dataclass
class AuditEntry:
    """审计日志条目"""
    event_type: str
    user_id: str
    description: str
    timestamp: float
```

### 3.2 安全工具实现

```python
class PasswordStrengthChecker:
    """密码强度检查器"""
    
    def __init__(self):
        self.min_length = 8
        self.require_uppercase = True
        self.require_lowercase = True
        self.require_digits = True
        self.require_special = True
    
    def check_strength(self, password: str) -> Dict[str, Any]:
        """检查密码强度"""
        score = 0
        feedback = []
        
        # 长度检查
        if len(password) >= self.min_length:
            score += 1
        else:
            feedback.append(f"密码长度至少需要 {self.min_length} 个字符")
        
        # 大写字母检查
        if any(c.isupper() for c in password):
            score += 1
        else:
            feedback.append("需要包含大写字母")
        
        # 小写字母检查
        if any(c.islower() for c in password):
            score += 1
        else:
            feedback.append("需要包含小写字母")
        
        # 数字检查
        if any(c.isdigit() for c in password):
            score += 1
        else:
            feedback.append("需要包含数字")
        
        # 特殊字符检查
        special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
        if any(c in special_chars for c in password):
            score += 1
        else:
            feedback.append("需要包含特殊字符")
        
        # 确定强度等级
        if score <= 2:
            strength = "weak"
        elif score <= 4:
            strength = "medium"
        else:
            strength = "strong"
        
        return {
            "score": score,
            "strength": strength,
            "feedback": feedback,
            "is_acceptable": score >= 4
        }

class SSLCertificate:
    """SSL证书"""
    
    def __init__(self, domain: str, public_key: rsa.RSAPublicKey):
        self.domain = domain
        self.public_key = public_key
        self.issued_date = time.time()
        self.expiry_date = self.issued_date + (365 * 24 * 60 * 60)  # 1年
        self.certificate_data = self._generate_certificate_data()
    
    def _generate_certificate_data(self) -> str:
        """生成证书数据"""
        cert_data = {
            "domain": self.domain,
            "issued_date": self.issued_date,
            "expiry_date": self.expiry_date,
            "public_key": self.public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            ).decode()
        }
        return base64.b64encode(json.dumps(cert_data).encode()).decode()
    
    def is_valid(self) -> bool:
        """检查证书是否有效"""
        return time.time() < self.expiry_date
    
    def verify_domain(self, domain: str) -> bool:
        """验证域名"""
        return domain == self.domain

class SecurityScanner:
    """安全扫描器"""
    
    def __init__(self):
        self.vulnerabilities: List[Vulnerability] = []
        self.scan_results: Dict[str, Any] = {}
    
    def scan_port(self, host: str, port: int) -> bool:
        """端口扫描"""
        try:
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def scan_host(self, host: str) -> Dict[str, Any]:
        """主机扫描"""
        open_ports = []
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995]
        
        for port in common_ports:
            if self.scan_port(host, port):
                open_ports.append(port)
        
        return {
            "host": host,
            "open_ports": open_ports,
            "scan_time": time.time()
        }
    
    def check_vulnerability(self, host: str, port: int, service: str) -> List[Vulnerability]:
        """检查漏洞"""
        vulnerabilities = []
        
        # 检查常见漏洞
        if service == "SSH" and port == 22:
            # 检查SSH版本
            if self._check_ssh_version(host, port):
                vulnerabilities.append(Vulnerability(
                    host=host,
                    port=port,
                    service=service,
                    vulnerability_type="weak_ssh_config",
                    severity="medium",
                    description="SSH配置可能不安全"
                ))
        
        elif service == "HTTP" and port == 80:
            # 检查HTTP安全头
            if not self._check_http_security_headers(host, port):
                vulnerabilities.append(Vulnerability(
                    host=host,
                    port=port,
                    service=service,
                    vulnerability_type="missing_security_headers",
                    severity="low",
                    description="缺少安全响应头"
                ))
        
        return vulnerabilities
    
    def _check_ssh_version(self, host: str, port: int) -> bool:
        """检查SSH版本"""
        # 简化的SSH版本检查
        return True
    
    def _check_http_security_headers(self, host: str, port: int) -> bool:
        """检查HTTP安全头"""
        # 简化的安全头检查
        return False

@dataclass
class Vulnerability:
    """漏洞"""
    host: str
    port: int
    service: str
    vulnerability_type: str
    severity: str
    description: str
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()
```

## 4. 理论证明

### 4.1 RSA算法正确性

**定理 4.1** (RSA算法正确性)
RSA算法满足：$D(E(m, k_{pub}), k_{priv}) = m$

**证明**:
1. **加密**: $c = m^e \bmod n$
2. **解密**: $m = c^d \bmod n = (m^e)^d \bmod n = m^{ed} \bmod n$
3. **密钥关系**: $ed \equiv 1 \pmod{\phi(n)}$
4. **欧拉定理**: $m^{\phi(n)} \equiv 1 \pmod{n}$
5. **结论**: $m^{ed} \equiv m \pmod{n}$

### 4.2 访问控制安全性

**定理 4.2** (访问控制安全性)
在正确的访问控制矩阵下，未授权用户无法访问受保护资源。

**证明**:
1. **完整性**: 所有访问请求都经过权限检查
2. **隔离性**: 不同用户之间的权限相互隔离
3. **最小权限**: 用户只能访问被明确授权的资源
4. **结论**: 系统满足访问控制安全要求

## 5. 性能分析

### 5.1 时间复杂度

- **RSA加密/解密**: $O(\log^3 n)$ 其中 $n$ 是密钥长度
- **AES加密/解密**: $O(n)$ 其中 $n$ 是数据长度
- **哈希计算**: $O(n)$ 其中 $n$ 是数据长度
- **访问控制检查**: $O(1)$ 哈希表查找

### 5.2 空间复杂度

- **密钥存储**: $O(k)$ 其中 $k$ 是密钥长度
- **访问矩阵**: $O(u \times r)$ 其中 $u$ 是用户数，$r$ 是资源数
- **审计日志**: $O(n)$ 其中 $n$ 是日志条目数

## 6. 应用示例

### 6.1 安全通信系统

```python
def secure_communication_example():
    """安全通信示例"""
    # 创建加密系统
    crypto = CryptoSystem()
    
    # 生成密钥对
    private_key, public_key = crypto.generate_rsa_keys()
    
    # 生成AES密钥
    aes_key = crypto.generate_aes_key()
    
    # 加密AES密钥
    encrypted_aes_key = crypto.rsa_encrypt(aes_key, public_key)
    
    # 加密消息
    message = b"Hello, secure world!"
    encrypted_message, iv = crypto.aes_encrypt(message, aes_key)
    
    # 解密AES密钥
    decrypted_aes_key = crypto.rsa_decrypt(encrypted_aes_key, private_key)
    
    # 解密消息
    decrypted_message = crypto.aes_decrypt(encrypted_message, decrypted_aes_key, iv)
    
    print(f"原始消息: {message.decode()}")
    print(f"解密消息: {decrypted_message.decode()}")
    print(f"消息匹配: {message == decrypted_message}")

if __name__ == "__main__":
    secure_communication_example()
```

### 6.2 访问控制系统

```python
def access_control_example():
    """访问控制示例"""
    # 创建安全管理器
    security_manager = SecurityManager()
    
    # 创建用户
    salt = generate_salt()
    password_hash = hash_password("secure_password", salt)
    alice = User("alice", "alice", password_hash, salt, ["read", "write"])
    bob = User("bob", "bob", password_hash, salt, ["read"])
    
    security_manager.access_control.add_user(alice)
    security_manager.access_control.add_user(bob)
    
    # 创建资源
    document = Resource("doc1", "重要文档", "file", "alice", {})
    security_manager.access_control.add_resource(document)
    
    # 设置权限
    security_manager.access_control.grant_permission("alice", "doc1", "read")
    security_manager.access_control.grant_permission("alice", "doc1", "write")
    security_manager.access_control.grant_permission("bob", "doc1", "read")
    
    # 测试访问控制
    print(f"Alice读取权限: {security_manager.access_resource('alice', 'doc1', 'read')}")
    print(f"Alice写入权限: {security_manager.access_resource('alice', 'doc1', 'write')}")
    print(f"Bob读取权限: {security_manager.access_resource('bob', 'doc1', 'read')}")
    print(f"Bob写入权限: {security_manager.access_resource('bob', 'doc1', 'write')}")

if __name__ == "__main__":
    access_control_example()
```

## 7. 总结

本文档从形式化理论角度阐述了网络安全的核心概念：

1. **形式化定义**: 安全系统、加密系统、访问控制的形式化定义
2. **核心概念**: 密码学基础、哈希函数、访问控制
3. **Python实现**: 完整的加密系统、访问控制、防火墙、入侵检测实现
4. **理论证明**: RSA算法正确性和访问控制安全性
5. **应用示例**: 安全通信和访问控制系统

网络安全技术为保护信息系统和数据安全提供了全面的解决方案，通过多层次的安全机制确保系统的机密性、完整性和可用性。

---

*本文档是软件工程与计算科学知识体系重构项目的一部分，遵循严格的形式化规范和学术标准。* 