# ç½‘ç»œå®‰å…¨åŸºç¡€ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç½‘ç»œå®‰å…¨æ˜¯ä¿æŠ¤è®¡ç®—æœºç³»ç»Ÿã€ç½‘ç»œå’Œæ•°æ®å…å—æœªç»æˆæƒè®¿é—®ã€ä½¿ç”¨ã€æŠ«éœ²ã€ä¸­æ–­ã€ä¿®æ”¹æˆ–ç ´åçš„æŠ€æœ¯å’Œå®è·µã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°ç½‘ç»œå®‰å…¨çš„åŸºç¡€æ¦‚å¿µã€åŠ å¯†ç®—æ³•å’Œå®‰å…¨æœºåˆ¶ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 å®‰å…¨ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (å®‰å…¨ç³»ç»Ÿ)
å®‰å…¨ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\text{SecuritySystem} = (U, R, P, A, C)$$

å…¶ä¸­ï¼š
- $U$ æ˜¯ç”¨æˆ·é›†åˆ
- $R$ æ˜¯èµ„æºé›†åˆ
- $P$ æ˜¯æƒé™é›†åˆ
- $A$ æ˜¯è®¿é—®æ§åˆ¶çŸ©é˜µ
- $C$ æ˜¯çº¦æŸæ¡ä»¶

### 1.2 åŠ å¯†ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.2** (åŠ å¯†ç³»ç»Ÿ)
åŠ å¯†ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$\text{CryptoSystem} = (K, E, D)$$

å…¶ä¸­ï¼š
- $K$ æ˜¯å¯†é’¥ç©ºé—´
- $E: M \times K \rightarrow C$ æ˜¯åŠ å¯†å‡½æ•°
- $D: C \times K \rightarrow M$ æ˜¯è§£å¯†å‡½æ•°

### 1.3 è®¿é—®æ§åˆ¶å®šä¹‰

**å®šä¹‰ 1.3** (è®¿é—®æ§åˆ¶)
è®¿é—®æ§åˆ¶æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$\text{AccessControl}: U \times R \times P \rightarrow \{\text{Allow}, \text{Deny}\}$$

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 å¯†ç å­¦åŸºç¡€

**å®šä¹‰ 2.1** (å¯¹ç§°åŠ å¯†)
å¯¹ç§°åŠ å¯†æ»¡è¶³ï¼š
$$D(E(m, k), k) = m$$

**å®šä¹‰ 2.2** (éå¯¹ç§°åŠ å¯†)
éå¯¹ç§°åŠ å¯†æ»¡è¶³ï¼š
$$D(E(m, k_{pub}), k_{priv}) = m$$

**ç®—æ³• 2.1** (RSAåŠ å¯†)
```python
def rsa_encrypt(message: int, public_key: Tuple[int, int]) -> int:
    """
    RSAåŠ å¯†ç®—æ³•
    
    å‚æ•°:
        message: æ˜æ–‡æ¶ˆæ¯
        public_key: å…¬é’¥ (e, n)
        
    è¿”å›:
        å¯†æ–‡
    """
    e, n = public_key
    return pow(message, e, n)

def rsa_decrypt(ciphertext: int, private_key: Tuple[int, int]) -> int:
    """
    RSAè§£å¯†ç®—æ³•
    
    å‚æ•°:
        ciphertext: å¯†æ–‡
        private_key: ç§é’¥ (d, n)
        
    è¿”å›:
        æ˜æ–‡
    """
    d, n = private_key
    return pow(ciphertext, d, n)
```

### 2.2 å“ˆå¸Œå‡½æ•°

**å®šä¹‰ 2.3** (å“ˆå¸Œå‡½æ•°)
å“ˆå¸Œå‡½æ•°ï¼š
$$H: \{0,1\}^* \rightarrow \{0,1\}^{n}$$

**æ€§è´¨ 2.1** (å“ˆå¸Œå‡½æ•°æ€§è´¨)
1. **ç¡®å®šæ€§**: $H(x) = H(x)$
2. **é›ªå´©æ•ˆåº”**: è¾“å…¥çš„å¾®å°å˜åŒ–å¯¼è‡´è¾“å‡ºçš„å·¨å¤§å˜åŒ–
3. **å•å‘æ€§**: ä» $H(x)$ éš¾ä»¥è®¡ç®— $x$
4. **æŠ—ç¢°æ’æ€§**: éš¾ä»¥æ‰¾åˆ° $x \neq y$ ä½¿å¾— $H(x) = H(y)$

## 3. Pythonå®ç°

### 3.1 åŠ å¯†ç³»ç»Ÿå®ç°

```python
from typing import Tuple, List, Dict, Optional, Any
from dataclasses import dataclass
from abc import ABC, abstractmethod
import hashlib
import hmac
import secrets
import base64
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

@dataclass
class User:
    """ç”¨æˆ·"""
    user_id: str
    username: str
    password_hash: str
    salt: str
    permissions: List[str]
    
    def verify_password(self, password: str) -> bool:
        """éªŒè¯å¯†ç """
        return hash_password(password, self.salt) == self.password_hash

@dataclass
class Resource:
    """èµ„æº"""
    resource_id: str
    name: str
    type: str
    owner: str
    permissions: Dict[str, List[str]]  # æƒé™ -> ç”¨æˆ·åˆ—è¡¨

class CryptoSystem:
    """åŠ å¯†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.backend = default_backend()
    
    def generate_rsa_keys(self, key_size: int = 2048) -> Tuple[rsa.RSAPrivateKey, rsa.RSAPublicKey]:
        """ç”ŸæˆRSAå¯†é’¥å¯¹"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=self.backend
        )
        public_key = private_key.public_key()
        return private_key, public_key
    
    def rsa_encrypt(self, message: bytes, public_key: rsa.RSAPublicKey) -> bytes:
        """RSAåŠ å¯†"""
        ciphertext = public_key.encrypt(
            message,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return ciphertext
    
    def rsa_decrypt(self, ciphertext: bytes, private_key: rsa.RSAPrivateKey) -> bytes:
        """RSAè§£å¯†"""
        plaintext = private_key.decrypt(
            ciphertext,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return plaintext
    
    def generate_aes_key(self, key_size: int = 256) -> bytes:
        """ç”ŸæˆAESå¯†é’¥"""
        return secrets.token_bytes(key_size // 8)
    
    def aes_encrypt(self, message: bytes, key: bytes) -> Tuple[bytes, bytes]:
        """AESåŠ å¯†"""
        iv = secrets.token_bytes(16)
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=self.backend
        )
        encryptor = cipher.encryptor()
        
        # PKCS7å¡«å……
        padded_message = self._pad_message(message)
        ciphertext = encryptor.update(padded_message) + encryptor.finalize()
        
        return ciphertext, iv
    
    def aes_decrypt(self, ciphertext: bytes, key: bytes, iv: bytes) -> bytes:
        """AESè§£å¯†"""
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=self.backend
        )
        decryptor = cipher.decryptor()
        
        padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        plaintext = self._unpad_message(padded_plaintext)
        
        return plaintext
    
    def _pad_message(self, message: bytes) -> bytes:
        """PKCS7å¡«å……"""
        block_size = 16
        padding_length = block_size - (len(message) % block_size)
        padding = bytes([padding_length] * padding_length)
        return message + padding
    
    def _unpad_message(self, padded_message: bytes) -> bytes:
        """PKCS7å»å¡«å……"""
        padding_length = padded_message[-1]
        return padded_message[:-padding_length]

class HashFunction:
    """å“ˆå¸Œå‡½æ•°"""
    
    @staticmethod
    def sha256(data: bytes) -> str:
        """SHA256å“ˆå¸Œ"""
        return hashlib.sha256(data).hexdigest()
    
    @staticmethod
    def sha512(data: bytes) -> str:
        """SHA512å“ˆå¸Œ"""
        return hashlib.sha512(data).hexdigest()
    
    @staticmethod
    def md5(data: bytes) -> str:
        """MD5å“ˆå¸Œï¼ˆä¸æ¨èç”¨äºå®‰å…¨ç”¨é€”ï¼‰"""
        return hashlib.md5(data).hexdigest()
    
    @staticmethod
    def hmac_sha256(data: bytes, key: bytes) -> str:
        """HMAC-SHA256"""
        return hmac.new(key, data, hashlib.sha256).hexdigest()

def hash_password(password: str, salt: str) -> str:
    """å“ˆå¸Œå¯†ç """
    return HashFunction.sha256((password + salt).encode())

def generate_salt() -> str:
    """ç”Ÿæˆç›å€¼"""
    return secrets.token_hex(16)

class AccessControlSystem:
    """è®¿é—®æ§åˆ¶ç³»ç»Ÿ"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.resources: Dict[str, Resource] = {}
        self.access_matrix: Dict[Tuple[str, str], List[str]] = {}
    
    def add_user(self, user: User):
        """æ·»åŠ ç”¨æˆ·"""
        self.users[user.user_id] = user
    
    def add_resource(self, resource: Resource):
        """æ·»åŠ èµ„æº"""
        self.resources[resource.resource_id] = resource
    
    def grant_permission(self, user_id: str, resource_id: str, permission: str):
        """æˆäºˆæƒé™"""
        key = (user_id, resource_id)
        if key not in self.access_matrix:
            self.access_matrix[key] = []
        self.access_matrix[key].append(permission)
    
    def revoke_permission(self, user_id: str, resource_id: str, permission: str):
        """æ’¤é”€æƒé™"""
        key = (user_id, resource_id)
        if key in self.access_matrix and permission in self.access_matrix[key]:
            self.access_matrix[key].remove(permission)
    
    def check_permission(self, user_id: str, resource_id: str, permission: str) -> bool:
        """æ£€æŸ¥æƒé™"""
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
        if user_id not in self.users:
            return False
        
        # æ£€æŸ¥èµ„æºæ˜¯å¦å­˜åœ¨
        if resource_id not in self.resources:
            return False
        
        # æ£€æŸ¥è®¿é—®çŸ©é˜µ
        key = (user_id, resource_id)
        if key in self.access_matrix:
            return permission in self.access_matrix[key]
        
        # æ£€æŸ¥èµ„æºæ‰€æœ‰è€…
        resource = self.resources[resource_id]
        if resource.owner == user_id:
            return True
        
        return False
    
    def authenticate_user(self, username: str, password: str) -> Optional[User]:
        """ç”¨æˆ·è®¤è¯"""
        for user in self.users.values():
            if user.username == username and user.verify_password(password):
                return user
        return None

class Firewall:
    """é˜²ç«å¢™"""
    
    def __init__(self):
        self.rules: List[FirewallRule] = []
        self.blocked_ips: Set[str] = set()
        self.allowed_ips: Set[str] = set()
    
    def add_rule(self, rule: 'FirewallRule'):
        """æ·»åŠ è§„åˆ™"""
        self.rules.append(rule)
    
    def block_ip(self, ip: str):
        """é˜»æ­¢IP"""
        self.blocked_ips.add(ip)
    
    def allow_ip(self, ip: str):
        """å…è®¸IP"""
        self.allowed_ips.add(ip)
    
    def check_packet(self, packet: 'NetworkPacket') -> bool:
        """æ£€æŸ¥æ•°æ®åŒ…"""
        # æ£€æŸ¥IPé»‘åå•
        if packet.source_ip in self.blocked_ips:
            return False
        
        # æ£€æŸ¥IPç™½åå•
        if self.allowed_ips and packet.source_ip not in self.allowed_ips:
            return False
        
        # æ£€æŸ¥è§„åˆ™
        for rule in self.rules:
            if rule.matches(packet):
                return rule.action == "allow"
        
        # é»˜è®¤æ‹’ç»
        return False

@dataclass
class FirewallRule:
    """é˜²ç«å¢™è§„åˆ™"""
    source_ip: Optional[str]
    dest_ip: Optional[str]
    source_port: Optional[int]
    dest_port: Optional[int]
    protocol: Optional[str]
    action: str  # "allow" or "deny"
    
    def matches(self, packet: 'NetworkPacket') -> bool:
        """æ£€æŸ¥æ˜¯å¦åŒ¹é…"""
        if self.source_ip and packet.source_ip != self.source_ip:
            return False
        if self.dest_ip and packet.dest_ip != self.dest_ip:
            return False
        if self.source_port and packet.source_port != self.source_port:
            return False
        if self.dest_port and packet.dest_port != self.dest_port:
            return False
        if self.protocol and packet.protocol != self.protocol:
            return False
        return True

@dataclass
class NetworkPacket:
    """ç½‘ç»œæ•°æ®åŒ…"""
    source_ip: str
    dest_ip: str
    source_port: int
    dest_port: int
    protocol: str
    data: bytes

class IntrusionDetectionSystem:
    """å…¥ä¾µæ£€æµ‹ç³»ç»Ÿ"""
    
    def __init__(self):
        self.signatures: List[str] = []
        self.anomaly_threshold = 0.8
        self.attack_patterns: Dict[str, List[str]] = {}
        self.alerts: List[Alert] = []
    
    def add_signature(self, signature: str):
        """æ·»åŠ æ”»å‡»ç‰¹å¾"""
        self.signatures.append(signature)
    
    def add_attack_pattern(self, attack_type: str, patterns: List[str]):
        """æ·»åŠ æ”»å‡»æ¨¡å¼"""
        self.attack_patterns[attack_type] = patterns
    
    def analyze_packet(self, packet: NetworkPacket) -> Optional[Alert]:
        """åˆ†ææ•°æ®åŒ…"""
        # ç‰¹å¾æ£€æµ‹
        for signature in self.signatures:
            if signature in packet.data.decode('utf-8', errors='ignore'):
                alert = Alert(
                    alert_type="signature_match",
                    severity="high",
                    description=f"æ£€æµ‹åˆ°æ”»å‡»ç‰¹å¾: {signature}",
                    source_ip=packet.source_ip,
                    timestamp=time.time()
                )
                self.alerts.append(alert)
                return alert
        
        # å¼‚å¸¸æ£€æµ‹
        anomaly_score = self.calculate_anomaly_score(packet)
        if anomaly_score > self.anomaly_threshold:
            alert = Alert(
                alert_type="anomaly_detected",
                severity="medium",
                description=f"æ£€æµ‹åˆ°å¼‚å¸¸è¡Œä¸ºï¼Œåˆ†æ•°: {anomaly_score:.2f}",
                source_ip=packet.source_ip,
                timestamp=time.time()
            )
            self.alerts.append(alert)
            return alert
        
        return None
    
    def calculate_anomaly_score(self, packet: NetworkPacket) -> float:
        """è®¡ç®—å¼‚å¸¸åˆ†æ•°"""
        # ç®€åŒ–çš„å¼‚å¸¸æ£€æµ‹ç®—æ³•
        score = 0.0
        
        # æ£€æŸ¥ç«¯å£æ‰«æ
        if packet.dest_port < 1024:
            score += 0.3
        
        # æ£€æŸ¥æ•°æ®åŒ…å¤§å°
        if len(packet.data) > 1500:
            score += 0.2
        
        # æ£€æŸ¥åè®®å¼‚å¸¸
        if packet.protocol not in ["TCP", "UDP", "ICMP"]:
            score += 0.5
        
        return min(score, 1.0)

@dataclass
class Alert:
    """å®‰å…¨å‘Šè­¦"""
    alert_type: str
    severity: str
    description: str
    source_ip: str
    timestamp: float
    acknowledged: bool = False

class SecurityManager:
    """å®‰å…¨ç®¡ç†å™¨"""
    
    def __init__(self):
        self.crypto_system = CryptoSystem()
        self.access_control = AccessControlSystem()
        self.firewall = Firewall()
        self.ids = IntrusionDetectionSystem()
        self.audit_log: List[AuditEntry] = []
    
    def authenticate_user(self, username: str, password: str) -> Optional[User]:
        """ç”¨æˆ·è®¤è¯"""
        user = self.access_control.authenticate_user(username, password)
        if user:
            self.log_audit("login_success", username, f"ç”¨æˆ· {username} ç™»å½•æˆåŠŸ")
        else:
            self.log_audit("login_failure", username, f"ç”¨æˆ· {username} ç™»å½•å¤±è´¥")
        return user
    
    def access_resource(self, user_id: str, resource_id: str, permission: str) -> bool:
        """è®¿é—®èµ„æº"""
        allowed = self.access_control.check_permission(user_id, resource_id, permission)
        
        if allowed:
            self.log_audit("access_granted", user_id, 
                          f"ç”¨æˆ· {user_id} è®¿é—®èµ„æº {resource_id}")
        else:
            self.log_audit("access_denied", user_id, 
                          f"ç”¨æˆ· {user_id} è¢«æ‹’ç»è®¿é—®èµ„æº {resource_id}")
        
        return allowed
    
    def process_network_packet(self, packet: NetworkPacket) -> bool:
        """å¤„ç†ç½‘ç»œæ•°æ®åŒ…"""
        # é˜²ç«å¢™æ£€æŸ¥
        if not self.firewall.check_packet(packet):
            self.log_audit("packet_blocked", packet.source_ip, 
                          f"æ•°æ®åŒ…è¢«é˜²ç«å¢™é˜»æ­¢")
            return False
        
        # å…¥ä¾µæ£€æµ‹
        alert = self.ids.analyze_packet(packet)
        if alert:
            self.log_audit("intrusion_detected", packet.source_ip, 
                          f"æ£€æµ‹åˆ°å…¥ä¾µ: {alert.description}")
        
        return True
    
    def encrypt_data(self, data: bytes, public_key: rsa.RSAPublicKey) -> bytes:
        """åŠ å¯†æ•°æ®"""
        return self.crypto_system.rsa_encrypt(data, public_key)
    
    def decrypt_data(self, ciphertext: bytes, private_key: rsa.RSAPrivateKey) -> bytes:
        """è§£å¯†æ•°æ®"""
        return self.crypto_system.rsa_decrypt(ciphertext, private_key)
    
    def log_audit(self, event_type: str, user_id: str, description: str):
        """è®°å½•å®¡è®¡æ—¥å¿—"""
        entry = AuditEntry(
            event_type=event_type,
            user_id=user_id,
            description=description,
            timestamp=time.time()
        )
        self.audit_log.append(entry)

@dataclass
class AuditEntry:
    """å®¡è®¡æ—¥å¿—æ¡ç›®"""
    event_type: str
    user_id: str
    description: str
    timestamp: float
```

### 3.2 å®‰å…¨å·¥å…·å®ç°

```python
class PasswordStrengthChecker:
    """å¯†ç å¼ºåº¦æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.min_length = 8
        self.require_uppercase = True
        self.require_lowercase = True
        self.require_digits = True
        self.require_special = True
    
    def check_strength(self, password: str) -> Dict[str, Any]:
        """æ£€æŸ¥å¯†ç å¼ºåº¦"""
        score = 0
        feedback = []
        
        # é•¿åº¦æ£€æŸ¥
        if len(password) >= self.min_length:
            score += 1
        else:
            feedback.append(f"å¯†ç é•¿åº¦è‡³å°‘éœ€è¦ {self.min_length} ä¸ªå­—ç¬¦")
        
        # å¤§å†™å­—æ¯æ£€æŸ¥
        if any(c.isupper() for c in password):
            score += 1
        else:
            feedback.append("éœ€è¦åŒ…å«å¤§å†™å­—æ¯")
        
        # å°å†™å­—æ¯æ£€æŸ¥
        if any(c.islower() for c in password):
            score += 1
        else:
            feedback.append("éœ€è¦åŒ…å«å°å†™å­—æ¯")
        
        # æ•°å­—æ£€æŸ¥
        if any(c.isdigit() for c in password):
            score += 1
        else:
            feedback.append("éœ€è¦åŒ…å«æ•°å­—")
        
        # ç‰¹æ®Šå­—ç¬¦æ£€æŸ¥
        special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
        if any(c in special_chars for c in password):
            score += 1
        else:
            feedback.append("éœ€è¦åŒ…å«ç‰¹æ®Šå­—ç¬¦")
        
        # ç¡®å®šå¼ºåº¦ç­‰çº§
        if score <= 2:
            strength = "weak"
        elif score <= 4:
            strength = "medium"
        else:
            strength = "strong"
        
        return {
            "score": score,
            "strength": strength,
            "feedback": feedback,
            "is_acceptable": score >= 4
        }

class SSLCertificate:
    """SSLè¯ä¹¦"""
    
    def __init__(self, domain: str, public_key: rsa.RSAPublicKey):
        self.domain = domain
        self.public_key = public_key
        self.issued_date = time.time()
        self.expiry_date = self.issued_date + (365 * 24 * 60 * 60)  # 1å¹´
        self.certificate_data = self._generate_certificate_data()
    
    def _generate_certificate_data(self) -> str:
        """ç”Ÿæˆè¯ä¹¦æ•°æ®"""
        cert_data = {
            "domain": self.domain,
            "issued_date": self.issued_date,
            "expiry_date": self.expiry_date,
            "public_key": self.public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            ).decode()
        }
        return base64.b64encode(json.dumps(cert_data).encode()).decode()
    
    def is_valid(self) -> bool:
        """æ£€æŸ¥è¯ä¹¦æ˜¯å¦æœ‰æ•ˆ"""
        return time.time() < self.expiry_date
    
    def verify_domain(self, domain: str) -> bool:
        """éªŒè¯åŸŸå"""
        return domain == self.domain

class SecurityScanner:
    """å®‰å…¨æ‰«æå™¨"""
    
    def __init__(self):
        self.vulnerabilities: List[Vulnerability] = []
        self.scan_results: Dict[str, Any] = {}
    
    def scan_port(self, host: str, port: int) -> bool:
        """ç«¯å£æ‰«æ"""
        try:
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def scan_host(self, host: str) -> Dict[str, Any]:
        """ä¸»æœºæ‰«æ"""
        open_ports = []
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995]
        
        for port in common_ports:
            if self.scan_port(host, port):
                open_ports.append(port)
        
        return {
            "host": host,
            "open_ports": open_ports,
            "scan_time": time.time()
        }
    
    def check_vulnerability(self, host: str, port: int, service: str) -> List[Vulnerability]:
        """æ£€æŸ¥æ¼æ´"""
        vulnerabilities = []
        
        # æ£€æŸ¥å¸¸è§æ¼æ´
        if service == "SSH" and port == 22:
            # æ£€æŸ¥SSHç‰ˆæœ¬
            if self._check_ssh_version(host, port):
                vulnerabilities.append(Vulnerability(
                    host=host,
                    port=port,
                    service=service,
                    vulnerability_type="weak_ssh_config",
                    severity="medium",
                    description="SSHé…ç½®å¯èƒ½ä¸å®‰å…¨"
                ))
        
        elif service == "HTTP" and port == 80:
            # æ£€æŸ¥HTTPå®‰å…¨å¤´
            if not self._check_http_security_headers(host, port):
                vulnerabilities.append(Vulnerability(
                    host=host,
                    port=port,
                    service=service,
                    vulnerability_type="missing_security_headers",
                    severity="low",
                    description="ç¼ºå°‘å®‰å…¨å“åº”å¤´"
                ))
        
        return vulnerabilities
    
    def _check_ssh_version(self, host: str, port: int) -> bool:
        """æ£€æŸ¥SSHç‰ˆæœ¬"""
        # ç®€åŒ–çš„SSHç‰ˆæœ¬æ£€æŸ¥
        return True
    
    def _check_http_security_headers(self, host: str, port: int) -> bool:
        """æ£€æŸ¥HTTPå®‰å…¨å¤´"""
        # ç®€åŒ–çš„å®‰å…¨å¤´æ£€æŸ¥
        return False

@dataclass
class Vulnerability:
    """æ¼æ´"""
    host: str
    port: int
    service: str
    vulnerability_type: str
    severity: str
    description: str
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()
```

## 4. ç†è®ºè¯æ˜

### 4.1 RSAç®—æ³•æ­£ç¡®æ€§

**å®šç† 4.1** (RSAç®—æ³•æ­£ç¡®æ€§)
RSAç®—æ³•æ»¡è¶³ï¼š$D(E(m, k_{pub}), k_{priv}) = m$

**è¯æ˜**:
1. **åŠ å¯†**: $c = m^e \bmod n$
2. **è§£å¯†**: $m = c^d \bmod n = (m^e)^d \bmod n = m^{ed} \bmod n$
3. **å¯†é’¥å…³ç³»**: $ed \equiv 1 \pmod{\phi(n)}$
4. **æ¬§æ‹‰å®šç†**: $m^{\phi(n)} \equiv 1 \pmod{n}$
5. **ç»“è®º**: $m^{ed} \equiv m \pmod{n}$

### 4.2 è®¿é—®æ§åˆ¶å®‰å…¨æ€§

**å®šç† 4.2** (è®¿é—®æ§åˆ¶å®‰å…¨æ€§)
åœ¨æ­£ç¡®çš„è®¿é—®æ§åˆ¶çŸ©é˜µä¸‹ï¼Œæœªæˆæƒç”¨æˆ·æ— æ³•è®¿é—®å—ä¿æŠ¤èµ„æºã€‚

**è¯æ˜**:
1. **å®Œæ•´æ€§**: æ‰€æœ‰è®¿é—®è¯·æ±‚éƒ½ç»è¿‡æƒé™æ£€æŸ¥
2. **éš”ç¦»æ€§**: ä¸åŒç”¨æˆ·ä¹‹é—´çš„æƒé™ç›¸äº’éš”ç¦»
3. **æœ€å°æƒé™**: ç”¨æˆ·åªèƒ½è®¿é—®è¢«æ˜ç¡®æˆæƒçš„èµ„æº
4. **ç»“è®º**: ç³»ç»Ÿæ»¡è¶³è®¿é—®æ§åˆ¶å®‰å…¨è¦æ±‚

## 5. æ€§èƒ½åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦

- **RSAåŠ å¯†/è§£å¯†**: $O(\log^3 n)$ å…¶ä¸­ $n$ æ˜¯å¯†é’¥é•¿åº¦
- **AESåŠ å¯†/è§£å¯†**: $O(n)$ å…¶ä¸­ $n$ æ˜¯æ•°æ®é•¿åº¦
- **å“ˆå¸Œè®¡ç®—**: $O(n)$ å…¶ä¸­ $n$ æ˜¯æ•°æ®é•¿åº¦
- **è®¿é—®æ§åˆ¶æ£€æŸ¥**: $O(1)$ å“ˆå¸Œè¡¨æŸ¥æ‰¾

### 5.2 ç©ºé—´å¤æ‚åº¦

- **å¯†é’¥å­˜å‚¨**: $O(k)$ å…¶ä¸­ $k$ æ˜¯å¯†é’¥é•¿åº¦
- **è®¿é—®çŸ©é˜µ**: $O(u \times r)$ å…¶ä¸­ $u$ æ˜¯ç”¨æˆ·æ•°ï¼Œ$r$ æ˜¯èµ„æºæ•°
- **å®¡è®¡æ—¥å¿—**: $O(n)$ å…¶ä¸­ $n$ æ˜¯æ—¥å¿—æ¡ç›®æ•°

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 å®‰å…¨é€šä¿¡ç³»ç»Ÿ

```python
def secure_communication_example():
    """å®‰å…¨é€šä¿¡ç¤ºä¾‹"""
    # åˆ›å»ºåŠ å¯†ç³»ç»Ÿ
    crypto = CryptoSystem()
    
    # ç”Ÿæˆå¯†é’¥å¯¹
    private_key, public_key = crypto.generate_rsa_keys()
    
    # ç”ŸæˆAESå¯†é’¥
    aes_key = crypto.generate_aes_key()
    
    # åŠ å¯†AESå¯†é’¥
    encrypted_aes_key = crypto.rsa_encrypt(aes_key, public_key)
    
    # åŠ å¯†æ¶ˆæ¯
    message = b"Hello, secure world!"
    encrypted_message, iv = crypto.aes_encrypt(message, aes_key)
    
    # è§£å¯†AESå¯†é’¥
    decrypted_aes_key = crypto.rsa_decrypt(encrypted_aes_key, private_key)
    
    # è§£å¯†æ¶ˆæ¯
    decrypted_message = crypto.aes_decrypt(encrypted_message, decrypted_aes_key, iv)
    
    print(f"åŸå§‹æ¶ˆæ¯: {message.decode()}")
    print(f"è§£å¯†æ¶ˆæ¯: {decrypted_message.decode()}")
    print(f"æ¶ˆæ¯åŒ¹é…: {message == decrypted_message}")

if __name__ == "__main__":
    secure_communication_example()
```

### 6.2 è®¿é—®æ§åˆ¶ç³»ç»Ÿ

```python
def access_control_example():
    """è®¿é—®æ§åˆ¶ç¤ºä¾‹"""
    # åˆ›å»ºå®‰å…¨ç®¡ç†å™¨
    security_manager = SecurityManager()
    
    # åˆ›å»ºç”¨æˆ·
    salt = generate_salt()
    password_hash = hash_password("secure_password", salt)
    alice = User("alice", "alice", password_hash, salt, ["read", "write"])
    bob = User("bob", "bob", password_hash, salt, ["read"])
    
    security_manager.access_control.add_user(alice)
    security_manager.access_control.add_user(bob)
    
    # åˆ›å»ºèµ„æº
    document = Resource("doc1", "é‡è¦æ–‡æ¡£", "file", "alice", {})
    security_manager.access_control.add_resource(document)
    
    # è®¾ç½®æƒé™
    security_manager.access_control.grant_permission("alice", "doc1", "read")
    security_manager.access_control.grant_permission("alice", "doc1", "write")
    security_manager.access_control.grant_permission("bob", "doc1", "read")
    
    # æµ‹è¯•è®¿é—®æ§åˆ¶
    print(f"Aliceè¯»å–æƒé™: {security_manager.access_resource('alice', 'doc1', 'read')}")
    print(f"Aliceå†™å…¥æƒé™: {security_manager.access_resource('alice', 'doc1', 'write')}")
    print(f"Bobè¯»å–æƒé™: {security_manager.access_resource('bob', 'doc1', 'read')}")
    print(f"Bobå†™å…¥æƒé™: {security_manager.access_resource('bob', 'doc1', 'write')}")

if __name__ == "__main__":
    access_control_example()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°äº†ç½‘ç»œå®‰å…¨çš„æ ¸å¿ƒæ¦‚å¿µï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: å®‰å…¨ç³»ç»Ÿã€åŠ å¯†ç³»ç»Ÿã€è®¿é—®æ§åˆ¶çš„å½¢å¼åŒ–å®šä¹‰
2. **æ ¸å¿ƒæ¦‚å¿µ**: å¯†ç å­¦åŸºç¡€ã€å“ˆå¸Œå‡½æ•°ã€è®¿é—®æ§åˆ¶
3. **Pythonå®ç°**: å®Œæ•´çš„åŠ å¯†ç³»ç»Ÿã€è®¿é—®æ§åˆ¶ã€é˜²ç«å¢™ã€å…¥ä¾µæ£€æµ‹å®ç°
4. **ç†è®ºè¯æ˜**: RSAç®—æ³•æ­£ç¡®æ€§å’Œè®¿é—®æ§åˆ¶å®‰å…¨æ€§
5. **åº”ç”¨ç¤ºä¾‹**: å®‰å…¨é€šä¿¡å’Œè®¿é—®æ§åˆ¶ç³»ç»Ÿ

ç½‘ç»œå®‰å…¨æŠ€æœ¯ä¸ºä¿æŠ¤ä¿¡æ¯ç³»ç»Ÿå’Œæ•°æ®å®‰å…¨æä¾›äº†å…¨é¢çš„è§£å†³æ–¹æ¡ˆï¼Œé€šè¿‡å¤šå±‚æ¬¡çš„å®‰å…¨æœºåˆ¶ç¡®ä¿ç³»ç»Ÿçš„æœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§ã€‚

---

*æœ¬æ–‡æ¡£æ˜¯è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®—ç§‘å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„å½¢å¼åŒ–è§„èŒƒå’Œå­¦æœ¯æ ‡å‡†ã€‚* 