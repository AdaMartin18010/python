# 01. 金融科技

## 概述

金融科技(FinTech)是金融与技术的融合，涉及支付系统、银行核心系统、风控系统等多个领域。本章将从数学形式化和Python实现的角度，阐述金融科技系统的核心概念和架构设计。

## 1. 支付系统架构

### 1.1 支付流程模型

**定义 1.1.1 (支付流程)** 支付流程是一个五元组：

$$P = (I, O, S, T, F)$$

其中：

- $I$ 是输入集合（支付请求）
- $O$ 是输出集合（支付结果）
- $S$ 是状态集合
- $T$ 是转换函数
- $F$ 是验证函数

**Python实现**：

```python
from typing import TypeVar, Generic, Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import uuid
import hashlib

T = TypeVar('T')

class PaymentStatus(Enum):
    """支付状态"""
    PENDING = "pending"
    PROCESSING = "processing"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"

class PaymentType(Enum):
    """支付类型"""
    CREDIT_CARD = "credit_card"
    DEBIT_CARD = "debit_card"
    BANK_TRANSFER = "bank_transfer"
    DIGITAL_WALLET = "digital_wallet"
    CRYPTOCURRENCY = "cryptocurrency"

@dataclass
class PaymentRequest:
    """支付请求"""
    id: str
    amount: float
    currency: str
    payment_type: PaymentType
    merchant_id: str
    customer_id: str
    timestamp: datetime
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class PaymentResult:
    """支付结果"""
    request_id: str
    status: PaymentStatus
    transaction_id: str
    timestamp: datetime
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

class PaymentProcessor(Generic[T]):
    """支付处理器"""
    
    def __init__(self):
        self.payment_gateways: Dict[PaymentType, 'PaymentGateway'] = {}
        self.validation_rules: List[callable] = []
        self.fraud_detection: 'FraudDetectionSystem' = None
    
    def register_gateway(self, payment_type: PaymentType, gateway: 'PaymentGateway') -> None:
        """注册支付网关"""
        self.payment_gateways[payment_type] = gateway
    
    def add_validation_rule(self, rule: callable) -> None:
        """添加验证规则"""
        self.validation_rules.append(rule)
    
    def process_payment(self, request: PaymentRequest) -> PaymentResult:
        """处理支付"""
        # 1. 验证请求
        if not self._validate_request(request):
            return PaymentResult(
                request_id=request.id,
                status=PaymentStatus.FAILED,
                transaction_id="",
                timestamp=datetime.now(),
                error_message="Validation failed"
            )
        
        # 2. 欺诈检测
        if self.fraud_detection and self.fraud_detection.is_suspicious(request):
            return PaymentResult(
                request_id=request.id,
                status=PaymentStatus.FAILED,
                transaction_id="",
                timestamp=datetime.now(),
                error_message="Fraud detected"
            )
        
        # 3. 路由到相应的支付网关
        gateway = self.payment_gateways.get(request.payment_type)
        if not gateway:
            return PaymentResult(
                request_id=request.id,
                status=PaymentStatus.FAILED,
                transaction_id="",
                timestamp=datetime.now(),
                error_message="Payment gateway not found"
            )
        
        # 4. 执行支付
        return gateway.process(request)
    
    def _validate_request(self, request: PaymentRequest) -> bool:
        """验证支付请求"""
        for rule in self.validation_rules:
            if not rule(request):
                return False
        return True

class PaymentGateway(ABC):
    """支付网关抽象基类"""
    
    @abstractmethod
    def process(self, request: PaymentRequest) -> PaymentResult:
        """处理支付"""
        pass
    
    @abstractmethod
    def get_supported_currencies(self) -> List[str]:
        """获取支持的货币"""
        pass

class CreditCardGateway(PaymentGateway):
    """信用卡支付网关"""
    
    def __init__(self):
        self.supported_currencies = ["USD", "EUR", "GBP", "JPY"]
    
    def process(self, request: PaymentRequest) -> PaymentResult:
        """处理信用卡支付"""
        # 模拟信用卡支付处理
        if request.currency not in self.supported_currencies:
            return PaymentResult(
                request_id=request.id,
                status=PaymentStatus.FAILED,
                transaction_id="",
                timestamp=datetime.now(),
                error_message="Unsupported currency"
            )
        
        # 模拟支付成功
        transaction_id = f"CC_{uuid.uuid4().hex[:8].upper()}"
        return PaymentResult(
            request_id=request.id,
            status=PaymentStatus.SUCCESS,
            transaction_id=transaction_id,
            timestamp=datetime.now()
        )
    
    def get_supported_currencies(self) -> List[str]:
        return self.supported_currencies

# 使用示例
def demonstrate_payment_system():
    """演示支付系统"""
    # 创建支付处理器
    processor = PaymentProcessor()
    
    # 注册支付网关
    credit_gateway = CreditCardGateway()
    processor.register_gateway(PaymentType.CREDIT_CARD, credit_gateway)
    
    # 添加验证规则
    def validate_amount(request: PaymentRequest) -> bool:
        return request.amount > 0 and request.amount <= 10000
    
    def validate_currency(request: PaymentRequest) -> bool:
        return request.currency in ["USD", "EUR", "GBP"]
    
    processor.add_validation_rule(validate_amount)
    processor.add_validation_rule(validate_currency)
    
    # 创建支付请求
    request = PaymentRequest(
        id="",
        amount=100.50,
        currency="USD",
        payment_type=PaymentType.CREDIT_CARD,
        merchant_id="MERCHANT_001",
        customer_id="CUSTOMER_001",
        timestamp=datetime.now()
    )
    
    # 处理支付
    result = processor.process_payment(request)
    print(f"支付结果: {result}")

if __name__ == "__main__":
    demonstrate_payment_system()
```

### 1.2 支付安全模型

**定义 1.1.2 (支付安全)** 支付安全是一个三元组：

$$S = (E, V, M)$$

其中：

- $E$ 是加密函数集合
- $V$ 是验证函数集合
- $M$ 是监控函数集合

**Python实现**：

```python
from abc import ABC, abstractmethod
import hashlib
import hmac
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class SecurityModel:
    """安全模型"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key.encode()
        self.fernet = Fernet(base64.urlsafe_b64encode(
            PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=b'payment_salt',
                iterations=100000,
            ).derive(self.secret_key)
        ))
    
    def encrypt_data(self, data: str) -> str:
        """加密数据"""
        return self.fernet.encrypt(data.encode()).decode()
    
    def decrypt_data(self, encrypted_data: str) -> str:
        """解密数据"""
        return self.fernet.decrypt(encrypted_data.encode()).decode()
    
    def generate_signature(self, data: str) -> str:
        """生成数字签名"""
        return hmac.new(
            self.secret_key,
            data.encode(),
            hashlib.sha256
        ).hexdigest()
    
    def verify_signature(self, data: str, signature: str) -> bool:
        """验证数字签名"""
        expected_signature = self.generate_signature(data)
        return hmac.compare_digest(expected_signature, signature)
    
    def hash_sensitive_data(self, data: str) -> str:
        """哈希敏感数据"""
        return hashlib.sha256(data.encode()).hexdigest()

class SecurePaymentProcessor(PaymentProcessor):
    """安全支付处理器"""
    
    def __init__(self, secret_key: str):
        super().__init__()
        self.security_model = SecurityModel(secret_key)
    
    def process_payment(self, request: PaymentRequest) -> PaymentResult:
        """安全处理支付"""
        # 1. 验证数字签名
        if 'signature' in request.metadata:
            if not self.security_model.verify_signature(
                f"{request.amount}{request.currency}{request.merchant_id}",
                request.metadata['signature']
            ):
                return PaymentResult(
                    request_id=request.id,
                    status=PaymentStatus.FAILED,
                    transaction_id="",
                    timestamp=datetime.now(),
                    error_message="Invalid signature"
                )
        
        # 2. 加密敏感数据
        encrypted_customer_id = self.security_model.encrypt_data(request.customer_id)
        request.metadata['encrypted_customer_id'] = encrypted_customer_id
        
        # 3. 哈希敏感数据用于存储
        hashed_customer_id = self.security_model.hash_sensitive_data(request.customer_id)
        request.metadata['hashed_customer_id'] = hashed_customer_id
        
        # 4. 调用父类处理逻辑
        return super().process_payment(request)

# 使用示例
def demonstrate_payment_security():
    """演示支付安全"""
    # 创建安全支付处理器
    secret_key = "my_secret_key_12345"
    secure_processor = SecurePaymentProcessor(secret_key)
    
    # 注册支付网关
    credit_gateway = CreditCardGateway()
    secure_processor.register_gateway(PaymentType.CREDIT_CARD, credit_gateway)
    
    # 创建带签名的支付请求
    request = PaymentRequest(
        id="",
        amount=100.50,
        currency="USD",
        payment_type=PaymentType.CREDIT_CARD,
        merchant_id="MERCHANT_001",
        customer_id="CUSTOMER_001",
        timestamp=datetime.now()
    )
    
    # 添加数字签名
    signature = secure_processor.security_model.generate_signature(
        f"{request.amount}{request.currency}{request.merchant_id}"
    )
    request.metadata['signature'] = signature
    
    # 处理支付
    result = secure_processor.process_payment(request)
    print(f"安全支付结果: {result}")
    print(f"加密的客户ID: {request.metadata.get('encrypted_customer_id')}")
    print(f"哈希的客户ID: {request.metadata.get('hashed_customer_id')}")

if __name__ == "__main__":
    demonstrate_payment_security()
```

## 2. 银行核心系统

### 2.1 账户模型

**定义 2.1.1 (银行账户)** 银行账户是一个六元组：

$$A = (ID, B, T, L, R, H)$$

其中：

- $ID$ 是账户标识符
- $B$ 是余额
- $T$ 是账户类型
- $L$ 是限制条件
- $R$ 是利率
- $H$ 是交易历史

**Python实现**：

```python
from decimal import Decimal, ROUND_HALF_UP
from typing import List, Optional
from datetime import datetime, timedelta

class AccountType(Enum):
    """账户类型"""
    CHECKING = "checking"
    SAVINGS = "savings"
    CREDIT = "credit"
    INVESTMENT = "investment"

class TransactionType(Enum):
    """交易类型"""
    DEPOSIT = "deposit"
    WITHDRAWAL = "withdrawal"
    TRANSFER = "transfer"
    INTEREST = "interest"
    FEE = "fee"

@dataclass
class Transaction:
    """交易记录"""
    id: str
    account_id: str
    type: TransactionType
    amount: Decimal
    balance_after: Decimal
    timestamp: datetime
    description: str
    reference_id: Optional[str] = None
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class AccountLimits:
    """账户限制"""
    daily_withdrawal_limit: Decimal
    monthly_transfer_limit: Decimal
    minimum_balance: Decimal
    maximum_overdraft: Decimal

class BankAccount:
    """银行账户"""
    
    def __init__(self, account_id: str, account_type: AccountType, 
                 initial_balance: Decimal = Decimal('0')):
        self.account_id = account_id
        self.account_type = account_type
        self.balance = initial_balance
        self.interest_rate = self._get_default_interest_rate()
        self.limits = self._get_default_limits()
        self.transaction_history: List[Transaction] = []
        self.created_at = datetime.now()
        self.last_activity = datetime.now()
    
    def _get_default_interest_rate(self) -> Decimal:
        """获取默认利率"""
        rates = {
            AccountType.CHECKING: Decimal('0.01'),
            AccountType.SAVINGS: Decimal('0.025'),
            AccountType.CREDIT: Decimal('0.15'),
            AccountType.INVESTMENT: Decimal('0.05')
        }
        return rates.get(self.account_type, Decimal('0'))
    
    def _get_default_limits(self) -> AccountLimits:
        """获取默认限制"""
        if self.account_type == AccountType.CHECKING:
            return AccountLimits(
                daily_withdrawal_limit=Decimal('1000'),
                monthly_transfer_limit=Decimal('5000'),
                minimum_balance=Decimal('0'),
                maximum_overdraft=Decimal('500')
            )
        elif self.account_type == AccountType.SAVINGS:
            return AccountLimits(
                daily_withdrawal_limit=Decimal('500'),
                monthly_transfer_limit=Decimal('2000'),
                minimum_balance=Decimal('100'),
                maximum_overdraft=Decimal('0')
            )
        else:
            return AccountLimits(
                daily_withdrawal_limit=Decimal('0'),
                monthly_transfer_limit=Decimal('0'),
                minimum_balance=Decimal('0'),
                maximum_overdraft=Decimal('0')
            )
    
    def deposit(self, amount: Decimal, description: str = "Deposit") -> bool:
        """存款"""
        if amount <= 0:
            return False
        
        self.balance += amount
        self._record_transaction(TransactionType.DEPOSIT, amount, description)
        return True
    
    def withdraw(self, amount: Decimal, description: str = "Withdrawal") -> bool:
        """取款"""
        if amount <= 0:
            return False
        
        # 检查取款限制
        if not self._check_withdrawal_limit(amount):
            return False
        
        # 检查余额
        if self.balance - amount < -self.limits.maximum_overdraft:
            return False
        
        self.balance -= amount
        self._record_transaction(TransactionType.WITHDRAWAL, amount, description)
        return True
    
    def transfer(self, target_account: 'BankAccount', amount: Decimal, 
                 description: str = "Transfer") -> bool:
        """转账"""
        if amount <= 0:
            return False
        
        # 检查转账限制
        if not self._check_transfer_limit(amount):
            return False
        
        # 执行转账
        if self.withdraw(amount, f"Transfer to {target_account.account_id}"):
            if target_account.deposit(amount, f"Transfer from {self.account_id}"):
                return True
            else:
                # 回滚
                self.deposit(amount, "Transfer rollback")
                return False
        return False
    
    def calculate_interest(self) -> Decimal:
        """计算利息"""
        if self.balance <= 0:
            return Decimal('0')
        
        # 简化的利息计算
        days_since_last_activity = (datetime.now() - self.last_activity).days
        interest = self.balance * self.interest_rate * Decimal(days_since_last_activity) / Decimal('365')
        return interest.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
    
    def apply_interest(self) -> bool:
        """应用利息"""
        interest = self.calculate_interest()
        if interest > 0:
            self.balance += interest
            self._record_transaction(TransactionType.INTEREST, interest, "Interest payment")
            return True
        return False
    
    def _check_withdrawal_limit(self, amount: Decimal) -> bool:
        """检查取款限制"""
        today = datetime.now().date()
        today_withdrawals = sum(
            t.amount for t in self.transaction_history
            if t.type == TransactionType.WITHDRAWAL and 
            t.timestamp.date() == today
        )
        return today_withdrawals + amount <= self.limits.daily_withdrawal_limit
    
    def _check_transfer_limit(self, amount: Decimal) -> bool:
        """检查转账限制"""
        current_month = datetime.now().replace(day=1)
        month_transfers = sum(
            t.amount for t in self.transaction_history
            if t.type == TransactionType.TRANSFER and 
            t.timestamp >= current_month
        )
        return month_transfers + amount <= self.limits.monthly_transfer_limit
    
    def _record_transaction(self, transaction_type: TransactionType, 
                           amount: Decimal, description: str) -> None:
        """记录交易"""
        transaction = Transaction(
            id="",
            account_id=self.account_id,
            type=transaction_type,
            amount=amount,
            balance_after=self.balance,
            timestamp=datetime.now(),
            description=description
        )
        self.transaction_history.append(transaction)
        self.last_activity = datetime.now()
    
    def get_balance(self) -> Decimal:
        """获取余额"""
        return self.balance
    
    def get_transaction_history(self, limit: int = 10) -> List[Transaction]:
        """获取交易历史"""
        return sorted(
            self.transaction_history,
            key=lambda x: x.timestamp,
            reverse=True
        )[:limit]

# 使用示例
def demonstrate_bank_account():
    """演示银行账户"""
    # 创建账户
    checking_account = BankAccount("ACC001", AccountType.CHECKING, Decimal('1000'))
    savings_account = BankAccount("ACC002", AccountType.SAVINGS, Decimal('5000'))
    
    print(f"支票账户余额: ${checking_account.get_balance()}")
    print(f"储蓄账户余额: ${savings_account.get_balance()}")
    
    # 存款
    checking_account.deposit(Decimal('500'), "Salary deposit")
    print(f"存款后支票账户余额: ${checking_account.get_balance()}")
    
    # 取款
    if checking_account.withdraw(Decimal('200'), "ATM withdrawal"):
        print(f"取款后支票账户余额: ${checking_account.get_balance()}")
    
    # 转账
    if checking_account.transfer(savings_account, Decimal('300'), "Monthly savings"):
        print(f"转账后支票账户余额: ${checking_account.get_balance()}")
        print(f"转账后储蓄账户余额: ${savings_account.get_balance()}")
    
    # 计算利息
    interest = savings_account.calculate_interest()
    print(f"储蓄账户利息: ${interest}")
    
    # 查看交易历史
    print(f"\n支票账户最近交易:")
    for transaction in checking_account.get_transaction_history(5):
        print(f"  {transaction.timestamp}: {transaction.type.value} ${transaction.amount} - {transaction.description}")

if __name__ == "__main__":
    demonstrate_bank_account()
```

### 2.2 银行核心系统架构

**定义 2.2.1 (银行核心系统)** 银行核心系统是一个四元组：

$$C = (A, T, R, S)$$

其中：

- $A$ 是账户管理系统
- $T$ 是交易处理系统
- $R$ 是风险管理系统
- $S$ 是结算系统

**Python实现**：

```python
from typing import Dict, Set, Optional
from concurrent.futures import ThreadPoolExecutor
import threading
import time

class CoreBankingSystem:
    """银行核心系统"""
    
    def __init__(self):
        self.accounts: Dict[str, BankAccount] = {}
        self.transaction_queue: List[Transaction] = []
        self.risk_manager = RiskManager()
        self.settlement_system = SettlementSystem()
        self.lock = threading.Lock()
        self.executor = ThreadPoolExecutor(max_workers=4)
    
    def create_account(self, account_type: AccountType, 
                      initial_balance: Decimal = Decimal('0')) -> str:
        """创建账户"""
        with self.lock:
            account_id = f"ACC_{len(self.accounts) + 1:06d}"
            account = BankAccount(account_id, account_type, initial_balance)
            self.accounts[account_id] = account
            return account_id
    
    def get_account(self, account_id: str) -> Optional[BankAccount]:
        """获取账户"""
        return self.accounts.get(account_id)
    
    def process_transaction(self, transaction: Transaction) -> bool:
        """处理交易"""
        # 1. 风险检查
        if not self.risk_manager.check_transaction(transaction):
            return False
        
        # 2. 执行交易
        account = self.accounts.get(transaction.account_id)
        if not account:
            return False
        
        success = False
        if transaction.type == TransactionType.DEPOSIT:
            success = account.deposit(transaction.amount, transaction.description)
        elif transaction.type == TransactionType.WITHDRAWAL:
            success = account.withdraw(transaction.amount, transaction.description)
        
        # 3. 结算
        if success:
            self.settlement_system.settle_transaction(transaction)
        
        return success
    
    def batch_process_transactions(self, transactions: List[Transaction]) -> List[bool]:
        """批量处理交易"""
        futures = []
        for transaction in transactions:
            future = self.executor.submit(self.process_transaction, transaction)
            futures.append(future)
        
        results = []
        for future in futures:
            results.append(future.result())
        
        return results
    
    def get_system_summary(self) -> Dict[str, Any]:
        """获取系统摘要"""
        total_balance = sum(account.get_balance() for account in self.accounts.values())
        account_count = len(self.accounts)
        
        account_types = {}
        for account in self.accounts.values():
            account_type = account.account_type.value
            account_types[account_type] = account_types.get(account_type, 0) + 1
        
        return {
            "total_balance": total_balance,
            "account_count": account_count,
            "account_types": account_types,
            "pending_transactions": len(self.transaction_queue)
        }

class RiskManager:
    """风险管理器"""
    
    def __init__(self):
        self.risk_rules: List[callable] = []
        self.suspicious_patterns: Set[str] = set()
    
    def add_risk_rule(self, rule: callable) -> None:
        """添加风险规则"""
        self.risk_rules.append(rule)
    
    def check_transaction(self, transaction: Transaction) -> bool:
        """检查交易风险"""
        for rule in self.risk_rules:
            if not rule(transaction):
                return False
        return True
    
    def mark_suspicious(self, account_id: str) -> None:
        """标记可疑账户"""
        self.suspicious_patterns.add(account_id)
    
    def is_suspicious(self, account_id: str) -> bool:
        """检查是否可疑"""
        return account_id in self.suspicious_patterns

class SettlementSystem:
    """结算系统"""
    
    def __init__(self):
        self.settled_transactions: List[Transaction] = []
        self.settlement_batch: List[Transaction] = []
    
    def settle_transaction(self, transaction: Transaction) -> None:
        """结算交易"""
        self.settlement_batch.append(transaction)
        
        # 当批次达到一定大小时进行批量结算
        if len(self.settlement_batch) >= 100:
            self._batch_settle()
    
    def _batch_settle(self) -> None:
        """批量结算"""
        # 模拟批量结算过程
        for transaction in self.settlement_batch:
            transaction.reference_id = f"SETTLE_{uuid.uuid4().hex[:8].upper()}"
            self.settled_transactions.append(transaction)
        
        self.settlement_batch.clear()
    
    def get_settlement_summary(self) -> Dict[str, Any]:
        """获取结算摘要"""
        return {
            "settled_transactions": len(self.settled_transactions),
            "pending_batch": len(self.settlement_batch),
            "total_settled_amount": sum(t.amount for t in self.settled_transactions)
        }

# 使用示例
def demonstrate_core_banking():
    """演示银行核心系统"""
    # 创建核心系统
    core_system = CoreBankingSystem()
    
    # 添加风险规则
    def check_large_transaction(transaction: Transaction) -> bool:
        return transaction.amount <= Decimal('10000')
    
    def check_frequency(transaction: Transaction) -> bool:
        # 简化的频率检查
        return True
    
    core_system.risk_manager.add_risk_rule(check_large_transaction)
    core_system.risk_manager.add_risk_rule(check_frequency)
    
    # 创建账户
    account1_id = core_system.create_account(AccountType.CHECKING, Decimal('5000'))
    account2_id = core_system.create_account(AccountType.SAVINGS, Decimal('10000'))
    
    # 处理交易
    transactions = [
        Transaction("", account1_id, TransactionType.DEPOSIT, Decimal('1000'), Decimal('0'), datetime.now(), "Deposit"),
        Transaction("", account1_id, TransactionType.WITHDRAWAL, Decimal('500'), Decimal('0'), datetime.now(), "Withdrawal"),
        Transaction("", account2_id, TransactionType.DEPOSIT, Decimal('2000'), Decimal('0'), datetime.now(), "Deposit")
    ]
    
    # 批量处理交易
    results = core_system.batch_process_transactions(transactions)
    print(f"交易处理结果: {results}")
    
    # 获取系统摘要
    summary = core_system.get_system_summary()
    print(f"系统摘要: {summary}")
    
    # 获取结算摘要
    settlement_summary = core_system.settlement_system.get_settlement_summary()
    print(f"结算摘要: {settlement_summary}")

if __name__ == "__main__":
    demonstrate_core_banking()
```

## 3. 风控系统

### 3.1 风险评估模型

**定义 3.1.1 (风险评估)** 风险评估是一个三元组：

$$R = (F, W, S)$$

其中：

- $F$ 是特征向量
- $W$ 是权重向量
- $S$ 是评分函数

**Python实现**：

```python
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

@dataclass
class RiskFeatures:
    """风险特征"""
    transaction_amount: float
    transaction_frequency: float
    account_age: float
    balance_ratio: float
    location_risk: float
    device_risk: float
    time_risk: float
    
    def to_vector(self) -> np.ndarray:
        """转换为特征向量"""
        return np.array([
            self.transaction_amount,
            self.transaction_frequency,
            self.account_age,
            self.balance_ratio,
            self.location_risk,
            self.device_risk,
            self.time_risk
        ])

class RiskAssessmentModel:
    """风险评估模型"""
    
    def __init__(self):
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.scaler = StandardScaler()
        self.is_trained = False
    
    def train(self, features: List[RiskFeatures], labels: List[bool]) -> None:
        """训练模型"""
        X = np.array([f.to_vector() for f in features])
        y = np.array(labels)
        
        # 数据标准化
        X_scaled = self.scaler.fit_transform(X)
        
        # 训练模型
        self.model.fit(X_scaled, y)
        self.is_trained = True
    
    def predict_risk(self, features: RiskFeatures) -> float:
        """预测风险分数"""
        if not self.is_trained:
            raise ValueError("Model not trained")
        
        X = features.to_vector().reshape(1, -1)
        X_scaled = self.scaler.transform(X)
        
        # 获取风险概率
        risk_probability = self.model.predict_proba(X_scaled)[0][1]
        return risk_probability
    
    def is_high_risk(self, features: RiskFeatures, threshold: float = 0.7) -> bool:
        """判断是否高风险"""
        risk_score = self.predict_risk(features)
        return risk_score > threshold

class FraudDetectionSystem:
    """欺诈检测系统"""
    
    def __init__(self):
        self.risk_model = RiskAssessmentModel()
        self.rule_engine = RuleEngine()
        self.anomaly_detector = AnomalyDetector()
        self.blacklist = set()
        self.whitelist = set()
    
    def is_suspicious(self, request: PaymentRequest) -> bool:
        """判断是否可疑"""
        # 1. 检查黑名单
        if request.customer_id in self.blacklist:
            return True
        
        # 2. 检查白名单
        if request.customer_id in self.whitelist:
            return False
        
        # 3. 规则引擎检查
        if self.rule_engine.check_rules(request):
            return True
        
        # 4. 异常检测
        if self.anomaly_detector.detect_anomaly(request):
            return True
        
        # 5. 机器学习模型评估
        features = self._extract_features(request)
        if self.risk_model.is_high_risk(features):
            return True
        
        return False
    
    def _extract_features(self, request: PaymentRequest) -> RiskFeatures:
        """提取特征"""
        # 简化的特征提取
        return RiskFeatures(
            transaction_amount=float(request.amount),
            transaction_frequency=1.0,  # 简化
            account_age=1.0,  # 简化
            balance_ratio=1.0,  # 简化
            location_risk=0.1,  # 简化
            device_risk=0.1,  # 简化
            time_risk=0.1  # 简化
        )
    
    def add_to_blacklist(self, customer_id: str) -> None:
        """添加到黑名单"""
        self.blacklist.add(customer_id)
    
    def add_to_whitelist(self, customer_id: str) -> None:
        """添加到白名单"""
        self.whitelist.add(customer_id)

class RuleEngine:
    """规则引擎"""
    
    def __init__(self):
        self.rules: List[callable] = []
    
    def add_rule(self, rule: callable) -> None:
        """添加规则"""
        self.rules.append(rule)
    
    def check_rules(self, request: PaymentRequest) -> bool:
        """检查规则"""
        for rule in self.rules:
            if rule(request):
                return True
        return False

class AnomalyDetector:
    """异常检测器"""
    
    def __init__(self):
        self.transaction_history: List[PaymentRequest] = []
    
    def detect_anomaly(self, request: PaymentRequest) -> bool:
        """检测异常"""
        # 简化的异常检测
        if len(self.transaction_history) > 0:
            avg_amount = sum(t.amount for t in self.transaction_history) / len(self.transaction_history)
            if request.amount > avg_amount * 5:  # 金额异常
                return True
        
        self.transaction_history.append(request)
        return False

# 使用示例
def demonstrate_risk_management():
    """演示风险管理"""
    # 创建欺诈检测系统
    fraud_system = FraudDetectionSystem()
    
    # 添加规则
    def large_amount_rule(request: PaymentRequest) -> bool:
        return request.amount > 5000
    
    def unusual_time_rule(request: PaymentRequest) -> bool:
        hour = request.timestamp.hour
        return hour < 6 or hour > 22
    
    fraud_system.rule_engine.add_rule(large_amount_rule)
    fraud_system.rule_engine.add_rule(unusual_time_rule)
    
    # 训练风险模型（使用模拟数据）
    features = [
        RiskFeatures(100, 1, 1, 1, 0.1, 0.1, 0.1),
        RiskFeatures(5000, 10, 1, 1, 0.9, 0.9, 0.9),
        RiskFeatures(50, 1, 1, 1, 0.1, 0.1, 0.1),
        RiskFeatures(10000, 20, 1, 1, 0.9, 0.9, 0.9)
    ]
    labels = [False, True, False, True]
    
    fraud_system.risk_model.train(features, labels)
    
    # 测试支付请求
    test_requests = [
        PaymentRequest("", 100, "USD", PaymentType.CREDIT_CARD, "MERCHANT_001", "CUSTOMER_001", datetime.now()),
        PaymentRequest("", 6000, "USD", PaymentType.CREDIT_CARD, "MERCHANT_001", "CUSTOMER_002", datetime.now()),
        PaymentRequest("", 200, "USD", PaymentType.CREDIT_CARD, "MERCHANT_001", "CUSTOMER_003", datetime.now())
    ]
    
    for request in test_requests:
        is_suspicious = fraud_system.is_suspicious(request)
        print(f"支付请求 {request.amount} USD: {'可疑' if is_suspicious else '正常'}")

if __name__ == "__main__":
    demonstrate_risk_management()
```

## 总结

本章从数学形式化和Python实现的角度，阐述了金融科技系统的核心概念：支付系统、银行核心系统、风控系统。
通过严格的数学定义和完整的代码实现，我们验证了这些概念的理论基础和实践应用。

### 关键要点

1. **支付系统**: 支付流程模型、安全模型、支付网关
2. **银行核心系统**: 账户模型、交易处理、风险管理、结算系统
3. **风控系统**: 风险评估、欺诈检测、规则引擎、异常检测

### 数学形式化

- 支付流程: $P = (I, O, S, T, F)$
- 支付安全: $S = (E, V, M)$
- 银行账户: $A = (ID, B, T, L, R, H)$
- 银行核心系统: $C = (A, T, R, S)$
- 风险评估: $R = (F, W, S)$

这些数学形式化为金融科技系统提供了严格的理论基础，确保概念的一致性和可验证性。
