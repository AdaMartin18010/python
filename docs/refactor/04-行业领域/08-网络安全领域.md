# 网络安全领域架构设计

## 1. 概述

### 1.1 网络安全定义

**定义 1.1.1 (网络安全)**
网络安全是指保护网络系统、网络服务和网络数据免受未经授权的访问、使用、披露、中断、修改或破坏的技术、政策和实践。

**定义 1.1.2 (安全威胁模型)**
安全威胁模型是一个三元组 $T = (A, R, P)$，其中：

- $A$ 是攻击者集合
- $R$ 是资源集合  
- $P$ 是攻击路径集合

**定义 1.1.3 (安全风险)**
安全风险定义为：
$$Risk = Threat \times Vulnerability \times Impact$$

### 1.2 安全原则

**定理 1.2.1 (深度防御原则)**
多层安全防护比单层防护更有效：
$$P_{multi-layer} = 1 - \prod_{i=1}^{n} (1 - P_i) > \max_{i} P_i$$

*证明*：设每层防护成功概率为 $P_i$，则多层防护失败概率为：
$$\prod_{i=1}^{n} (1 - P_i) < \min_{i} (1 - P_i) = 1 - \max_{i} P_i$$
因此：
$$P_{multi-layer} = 1 - \prod_{i=1}^{n} (1 - P_i) > \max_{i} P_i$$

## 2. 加密系统

### 2.1 对称加密

**定义 2.1.1 (对称加密)**
对称加密是一个三元组 $(G, E, D)$，其中：

- $G$ 是密钥生成算法
- $E$ 是加密算法：$E_k(m) = c$
- $D$ 是解密算法：$D_k(c) = m$

**定理 2.1.1 (对称加密正确性)**
对于任意明文 $m$ 和密钥 $k$：
$$D_k(E_k(m)) = m$$

```python
from typing import Optional, Tuple
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class SymmetricEncryption:
    """对称加密系统"""
    
    def __init__(self):
        self.fernet = None
    
    def generate_key(self, password: str, salt: Optional[bytes] = None) -> bytes:
        """生成密钥"""
        if salt is None:
            salt = os.urandom(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        self.fernet = Fernet(key)
        return key
    
    def encrypt(self, message: str) -> Tuple[bytes, bytes]:
        """加密消息"""
        if self.fernet is None:
            raise ValueError("请先生成密钥")
        
        encrypted_data = self.fernet.encrypt(message.encode())
        return encrypted_data, self.fernet._encryption_key
    
    def decrypt(self, encrypted_data: bytes) -> str:
        """解密消息"""
        if self.fernet is None:
            raise ValueError("请先生成密钥")
        
        decrypted_data = self.fernet.decrypt(encrypted_data)
        return decrypted_data.decode()

class AESEncryption:
    """AES加密实现"""
    
    def __init__(self, key_size: int = 256):
        self.key_size = key_size
    
    def generate_key(self) -> bytes:
        """生成AES密钥"""
        return os.urandom(self.key_size // 8)
    
    def encrypt(self, key: bytes, plaintext: bytes) -> Tuple[bytes, bytes]:
        """AES加密"""
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        
        iv = os.urandom(16)  # 初始化向量
        cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
        encryptor = cipher.encryptor()
        
        # PKCS7填充
        padded_data = self._pad(plaintext)
        ciphertext = encryptor.update(padded_data) + encryptor.finalize()
        
        return ciphertext, iv
    
    def decrypt(self, key: bytes, ciphertext: bytes, iv: bytes) -> bytes:
        """AES解密"""
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        
        cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
        decryptor = cipher.decryptor()
        
        padded_data = decryptor.update(ciphertext) + decryptor.finalize()
        plaintext = self._unpad(padded_data)
        
        return plaintext
    
    def _pad(self, data: bytes) -> bytes:
        """PKCS7填充"""
        block_size = 16
        padding_length = block_size - (len(data) % block_size)
        padding = bytes([padding_length] * padding_length)
        return data + padding
    
    def _unpad(self, data: bytes) -> bytes:
        """PKCS7去填充"""
        padding_length = data[-1]
        return data[:-padding_length]
```

### 2.2 非对称加密

**定义 2.2.1 (非对称加密)**
非对称加密是一个五元组 $(G, E, D, S, V)$，其中：

- $G$ 是密钥对生成算法
- $E$ 是加密算法：$E_{pk}(m) = c$
- $D$ 是解密算法：$D_{sk}(c) = m$
- $S$ 是签名算法：$S_{sk}(m) = \sigma$
- $V$ 是验证算法：$V_{pk}(m, \sigma) = \{0, 1\}$

**定理 2.2.1 (RSA安全性)**
RSA的安全性基于大整数分解问题的困难性：
$$c = m^e \bmod n$$
$$m = c^d \bmod n$$
其中 $n = pq$，$ed \equiv 1 \pmod{\phi(n)}$

```python
from typing import Tuple, Optional
import random
import math

class RSAEncryption:
    """RSA加密系统"""
    
    def __init__(self, key_size: int = 2048):
        self.key_size = key_size
    
    def generate_key_pair(self) -> Tuple[int, int, int]:
        """生成RSA密钥对"""
        # 生成两个大素数
        p = self._generate_prime(self.key_size // 2)
        q = self._generate_prime(self.key_size // 2)
        
        n = p * q
        phi_n = (p - 1) * (q - 1)
        
        # 选择公钥指数
        e = 65537  # 常用值
        
        # 计算私钥指数
        d = self._mod_inverse(e, phi_n)
        
        return (e, n), (d, n)  # (public_key, private_key)
    
    def _generate_prime(self, bits: int) -> int:
        """生成指定位数的素数"""
        while True:
            # 生成随机奇数
            n = random.getrandbits(bits)
            n |= 1  # 确保是奇数
            n |= (1 << (bits - 1))  # 确保指定位数
            
            if self._is_prime(n):
                return n
    
    def _is_prime(self, n: int) -> bool:
        """Miller-Rabin素性测试"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        # 将n-1写成2^r * d的形式
        r, d = 0, n - 1
        while d % 2 == 0:
            r += 1
            d //= 2
        
        # 进行k次测试
        for _ in range(5):
            a = random.randint(2, n - 2)
            x = pow(a, d, n)
            
            if x == 1 or x == n - 1:
                continue
            
            for _ in range(r - 1):
                x = (x * x) % n
                if x == n - 1:
                    break
            else:
                return False
        
        return True
    
    def _mod_inverse(self, a: int, m: int) -> int:
        """计算模逆元"""
        def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
            if a == 0:
                return b, 0, 1
            gcd, x1, y1 = extended_gcd(b % a, a)
            x = y1 - (b // a) * x1
            y = x1
            return gcd, x, y
        
        gcd, x, _ = extended_gcd(a, m)
        if gcd != 1:
            raise ValueError("模逆元不存在")
        
        return (x % m + m) % m
    
    def encrypt(self, public_key: Tuple[int, int], message: int) -> int:
        """RSA加密"""
        e, n = public_key
        return pow(message, e, n)
    
    def decrypt(self, private_key: Tuple[int, int], ciphertext: int) -> int:
        """RSA解密"""
        d, n = private_key
        return pow(ciphertext, d, n)
    
    def sign(self, private_key: Tuple[int, int], message: int) -> int:
        """RSA签名"""
        d, n = private_key
        return pow(message, d, n)
    
    def verify(self, public_key: Tuple[int, int], message: int, signature: int) -> bool:
        """RSA验证"""
        e, n = public_key
        decrypted = pow(signature, e, n)
        return decrypted == message

class DigitalSignature:
    """数字签名系统"""
    
    def __init__(self):
        self.rsa = RSAEncryption()
    
    def generate_key_pair(self) -> Tuple[Tuple[int, int], Tuple[int, int]]:
        """生成签名密钥对"""
        return self.rsa.generate_key_pair()
    
    def sign(self, private_key: Tuple[int, int], message: str) -> int:
        """数字签名"""
        # 计算消息哈希
        message_hash = self._hash_message(message)
        return self.rsa.sign(private_key, message_hash)
    
    def verify(self, public_key: Tuple[int, int], message: str, signature: int) -> bool:
        """验证数字签名"""
        message_hash = self._hash_message(message)
        return self.rsa.verify(public_key, message_hash, signature)
    
    def _hash_message(self, message: str) -> int:
        """计算消息哈希"""
        import hashlib
        hash_obj = hashlib.sha256(message.encode())
        return int(hash_obj.hexdigest(), 16) % (2**256)
```

## 3. 身份认证与授权

### 3.1 身份认证

**定义 3.1.1 (身份认证)**
身份认证是验证用户身份的过程，通常基于以下因素：

- 知识因素：密码、PIN码
- 持有因素：智能卡、令牌
- 生物因素：指纹、虹膜

**定义 3.1.2 (多因素认证)**
多因素认证(MFA)要求用户提供多个不同类型的认证因素：
$$P_{MFA} = 1 - \prod_{i=1}^{n} (1 - P_i)$$

```python
from typing import Dict, List, Optional
from enum import Enum
import hashlib
import time
import secrets

class AuthFactor(Enum):
    """认证因素类型"""
    PASSWORD = "password"
    TOKEN = "token"
    BIOMETRIC = "biometric"
    SMS = "sms"

class User:
    """用户模型"""
    
    def __init__(self, username: str):
        self.username = username
        self.password_hash: Optional[str] = None
        self.two_factor_secret: Optional[str] = None
        self.failed_attempts = 0
        self.locked_until: Optional[float] = None
    
    def set_password(self, password: str) -> None:
        """设置密码"""
        salt = secrets.token_hex(16)
        password_hash = self._hash_password(password, salt)
        self.password_hash = f"{salt}:{password_hash}"
    
    def verify_password(self, password: str) -> bool:
        """验证密码"""
        if self.password_hash is None:
            return False
        
        salt, stored_hash = self.password_hash.split(":")
        computed_hash = self._hash_password(password, salt)
        return secrets.compare_digest(stored_hash, computed_hash)
    
    def _hash_password(self, password: str, salt: str) -> str:
        """哈希密码"""
        return hashlib.pbkdf2_hmac(
            'sha256', 
            password.encode(), 
            salt.encode(), 
            100000
        ).hex()
    
    def generate_two_factor_secret(self) -> str:
        """生成双因素认证密钥"""
        self.two_factor_secret = secrets.token_hex(16)
        return self.two_factor_secret
    
    def verify_two_factor_code(self, code: str) -> bool:
        """验证双因素认证码"""
        if self.two_factor_secret is None:
            return False
        
        # 简化的TOTP实现
        current_time = int(time.time() // 30)
        expected_code = self._generate_totp(current_time)
        return code == expected_code
    
    def _generate_totp(self, timestamp: int) -> str:
        """生成TOTP码"""
        import hmac
        import struct
        
        # 使用HMAC-SHA1生成TOTP
        key = self.two_factor_secret.encode()
        message = struct.pack(">Q", timestamp)
        hmac_obj = hmac.new(key, message, hashlib.sha1)
        hmac_result = hmac_obj.digest()
        
        # 提取4位数字码
        offset = hmac_result[-1] & 0x0F
        code = struct.unpack(">I", hmac_result[offset:offset+4])[0]
        code = code & 0x7FFFFFFF
        code = code % 10000
        
        return f"{code:04d}"

class AuthenticationSystem:
    """认证系统"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.sessions: Dict[str, Dict] = {}
    
    def register_user(self, username: str, password: str) -> bool:
        """注册用户"""
        if username in self.users:
            return False
        
        user = User(username)
        user.set_password(password)
        self.users[username] = user
        return True
    
    def authenticate(self, username: str, password: str, 
                    two_factor_code: Optional[str] = None) -> Optional[str]:
        """用户认证"""
        if username not in self.users:
            return None
        
        user = self.users[username]
        
        # 检查账户锁定
        if user.locked_until and time.time() < user.locked_until:
            return None
        
        # 验证密码
        if not user.verify_password(password):
            user.failed_attempts += 1
            if user.failed_attempts >= 5:
                user.locked_until = time.time() + 300  # 锁定5分钟
            return None
        
        # 验证双因素认证
        if user.two_factor_secret and two_factor_code:
            if not user.verify_two_factor_code(two_factor_code):
                return None
        
        # 重置失败次数
        user.failed_attempts = 0
        user.locked_until = None
        
        # 生成会话令牌
        session_token = secrets.token_urlsafe(32)
        self.sessions[session_token] = {
            "username": username,
            "created_at": time.time(),
            "expires_at": time.time() + 3600  # 1小时过期
        }
        
        return session_token
    
    def verify_session(self, session_token: str) -> Optional[str]:
        """验证会话"""
        if session_token not in self.sessions:
            return None
        
        session = self.sessions[session_token]
        if time.time() > session["expires_at"]:
            del self.sessions[session_token]
            return None
        
        return session["username"]
    
    def logout(self, session_token: str) -> bool:
        """登出"""
        if session_token in self.sessions:
            del self.sessions[session_token]
            return True
        return False
```

### 3.2 访问控制

**定义 3.2.1 (访问控制矩阵)**
访问控制矩阵 $A$ 是一个 $m \times n$ 矩阵，其中 $A[i,j]$ 表示主体 $i$ 对客体 $j$ 的权限。

**定义 3.2.2 (RBAC模型)**
基于角色的访问控制(RBAC)包含：

- 用户集合 $U$
- 角色集合 $R$
- 权限集合 $P$
- 用户-角色分配 $UA \subseteq U \times R$
- 角色-权限分配 $PA \subseteq R \times P$

```python
from typing import Set, Dict, List
from enum import Enum

class Permission(Enum):
    """权限类型"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    EXECUTE = "execute"

class Role:
    """角色定义"""
    
    def __init__(self, name: str):
        self.name = name
        self.permissions: Set[Permission] = set()
        self.inherited_roles: Set[str] = set()
    
    def add_permission(self, permission: Permission) -> None:
        """添加权限"""
        self.permissions.add(permission)
    
    def remove_permission(self, permission: Permission) -> None:
        """移除权限"""
        self.permissions.discard(permission)
    
    def has_permission(self, permission: Permission) -> bool:
        """检查权限"""
        return permission in self.permissions
    
    def inherit_role(self, role_name: str) -> None:
        """继承角色"""
        self.inherited_roles.add(role_name)

class RBACSystem:
    """RBAC系统"""
    
    def __init__(self):
        self.users: Dict[str, Set[str]] = {}  # 用户 -> 角色集合
        self.roles: Dict[str, Role] = {}  # 角色名 -> 角色对象
        self.resources: Dict[str, Set[Permission]] = {}  # 资源 -> 所需权限
    
    def create_role(self, role_name: str) -> bool:
        """创建角色"""
        if role_name in self.roles:
            return False
        
        self.roles[role_name] = Role(role_name)
        return True
    
    def assign_user_to_role(self, username: str, role_name: str) -> bool:
        """分配用户到角色"""
        if role_name not in self.roles:
            return False
        
        if username not in self.users:
            self.users[username] = set()
        
        self.users[username].add(role_name)
        return True
    
    def assign_permission_to_role(self, role_name: str, permission: Permission) -> bool:
        """分配权限到角色"""
        if role_name not in self.roles:
            return False
        
        self.roles[role_name].add_permission(permission)
        return True
    
    def check_permission(self, username: str, resource: str, 
                        permission: Permission) -> bool:
        """检查用户对资源的权限"""
        if username not in self.users:
            return False
        
        if resource not in self.resources:
            return False
        
        # 检查资源是否需要该权限
        if permission not in self.resources[resource]:
            return False
        
        # 检查用户角色是否有该权限
        user_roles = self.users[username]
        for role_name in user_roles:
            if self._role_has_permission(role_name, permission):
                return True
        
        return False
    
    def _role_has_permission(self, role_name: str, permission: Permission) -> bool:
        """检查角色是否有权限（包括继承）"""
        if role_name not in self.roles:
            return False
        
        role = self.roles[role_name]
        
        # 直接权限
        if role.has_permission(permission):
            return True
        
        # 继承权限
        for inherited_role_name in role.inherited_roles:
            if self._role_has_permission(inherited_role_name, permission):
                return True
        
        return False
    
    def add_resource(self, resource_name: str, required_permissions: Set[Permission]) -> None:
        """添加资源"""
        self.resources[resource_name] = required_permissions
    
    def get_user_permissions(self, username: str) -> Set[Permission]:
        """获取用户所有权限"""
        if username not in self.users:
            return set()
        
        permissions = set()
        for role_name in self.users[username]:
            role = self.roles.get(role_name)
            if role:
                permissions.update(role.permissions)
        
        return permissions
```

## 4. 入侵检测系统

### 4.1 异常检测

**定义 4.1.1 (异常检测)**
异常检测是识别与正常模式显著不同的行为或事件的过程。

**定义 4.1.2 (统计异常)**
对于特征向量 $x$，统计异常分数定义为：
$$A(x) = \frac{|x - \mu|}{\sigma}$$
其中 $\mu$ 是均值，$\sigma$ 是标准差。

```python
from typing import List, Dict, Any, Optional
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import json
import time

class NetworkEvent:
    """网络事件"""
    
    def __init__(self, timestamp: float, source_ip: str, dest_ip: str,
                 source_port: int, dest_port: int, protocol: str,
                 packet_size: int, duration: float):
        self.timestamp = timestamp
        self.source_ip = source_ip
        self.dest_ip = dest_ip
        self.source_port = source_port
        self.dest_port = dest_port
        self.protocol = protocol
        self.packet_size = packet_size
        self.duration = duration
    
    def to_features(self) -> List[float]:
        """转换为特征向量"""
        return [
            self.timestamp,
            self._ip_to_int(self.source_ip),
            self._ip_to_int(self.dest_ip),
            self.source_port,
            self.dest_port,
            self._protocol_to_int(self.protocol),
            self.packet_size,
            self.duration
        ]
    
    def _ip_to_int(self, ip: str) -> int:
        """IP地址转换为整数"""
        parts = ip.split('.')
        return sum(int(part) << (24 - 8 * i) for i, part in enumerate(parts))
    
    def _protocol_to_int(self, protocol: str) -> int:
        """协议转换为整数"""
        protocol_map = {'TCP': 1, 'UDP': 2, 'ICMP': 3}
        return protocol_map.get(protocol.upper(), 0)

class AnomalyDetector:
    """异常检测器"""
    
    def __init__(self, contamination: float = 0.1):
        self.contamination = contamination
        self.isolation_forest = IsolationForest(
            contamination=contamination,
            random_state=42
        )
        self.scaler = StandardScaler()
        self.is_trained = False
    
    def train(self, events: List[NetworkEvent]) -> None:
        """训练异常检测模型"""
        if not events:
            return
        
        # 提取特征
        features = np.array([event.to_features() for event in events])
        
        # 标准化特征
        features_scaled = self.scaler.fit_transform(features)
        
        # 训练模型
        self.isolation_forest.fit(features_scaled)
        self.is_trained = True
    
    def detect_anomaly(self, event: NetworkEvent) -> bool:
        """检测单个事件是否异常"""
        if not self.is_trained:
            return False
        
        features = np.array([event.to_features()])
        features_scaled = self.scaler.transform(features)
        
        # 预测是否为异常
        prediction = self.isolation_forest.predict(features_scaled)
        return prediction[0] == -1  # -1表示异常
    
    def get_anomaly_score(self, event: NetworkEvent) -> float:
        """获取异常分数"""
        if not self.is_trained:
            return 0.0
        
        features = np.array([event.to_features()])
        features_scaled = self.scaler.transform(features)
        
        # 获取异常分数
        score = self.isolation_forest.decision_function(features_scaled)
        return score[0]

class IntrusionDetectionSystem:
    """入侵检测系统"""
    
    def __init__(self):
        self.anomaly_detector = AnomalyDetector()
        self.rule_engine = RuleEngine()
        self.alerts: List[Dict] = []
        self.event_history: List[NetworkEvent] = []
    
    def process_event(self, event: NetworkEvent) -> List[Dict]:
        """处理网络事件"""
        alerts = []
        
        # 添加到历史记录
        self.event_history.append(event)
        
        # 规则检测
        rule_alerts = self.rule_engine.check_rules(event)
        alerts.extend(rule_alerts)
        
        # 异常检测
        if self.anomaly_detector.is_trained:
            if self.anomaly_detector.detect_anomaly(event):
                anomaly_score = self.anomaly_detector.get_anomaly_score(event)
                alert = {
                    "type": "anomaly",
                    "timestamp": event.timestamp,
                    "source_ip": event.source_ip,
                    "dest_ip": event.dest_ip,
                    "score": anomaly_score,
                    "description": f"异常行为检测，分数: {anomaly_score:.3f}"
                }
                alerts.append(alert)
        
        # 记录告警
        self.alerts.extend(alerts)
        
        return alerts
    
    def train_model(self, training_events: List[NetworkEvent]) -> None:
        """训练异常检测模型"""
        self.anomaly_detector.train(training_events)
    
    def get_statistics(self) -> Dict[str, Any]:
        """获取统计信息"""
        return {
            "total_events": len(self.event_history),
            "total_alerts": len(self.alerts),
            "model_trained": self.anomaly_detector.is_trained,
            "recent_alerts": self.alerts[-10:] if self.alerts else []
        }

class RuleEngine:
    """规则引擎"""
    
    def __init__(self):
        self.rules: List[Dict] = []
        self._initialize_default_rules()
    
    def _initialize_default_rules(self) -> None:
        """初始化默认规则"""
        self.rules = [
            {
                "name": "端口扫描检测",
                "condition": lambda event: event.dest_port < 1024 and event.packet_size < 100,
                "threshold": 10,
                "time_window": 60,
                "description": "检测端口扫描行为"
            },
            {
                "name": "大流量检测",
                "condition": lambda event: event.packet_size > 10000,
                "threshold": 1,
                "time_window": 60,
                "description": "检测大流量传输"
            },
            {
                "name": "异常协议检测",
                "condition": lambda event: event.protocol not in ['TCP', 'UDP', 'ICMP'],
                "threshold": 1,
                "time_window": 60,
                "description": "检测异常协议"
            }
        ]
    
    def check_rules(self, event: NetworkEvent) -> List[Dict]:
        """检查规则"""
        alerts = []
        
        for rule in self.rules:
            if rule["condition"](event):
                alert = {
                    "type": "rule",
                    "timestamp": event.timestamp,
                    "source_ip": event.source_ip,
                    "dest_ip": event.dest_ip,
                    "rule_name": rule["name"],
                    "description": rule["description"]
                }
                alerts.append(alert)
        
        return alerts
    
    def add_rule(self, name: str, condition, threshold: int, 
                 time_window: int, description: str) -> None:
        """添加自定义规则"""
        rule = {
            "name": name,
            "condition": condition,
            "threshold": threshold,
            "time_window": time_window,
            "description": description
        }
        self.rules.append(rule)
```

## 5. 安全监控与响应

### 5.1 安全事件管理

**定义 5.1.1 (安全事件)**
安全事件是可能影响系统安全性的任何事件，包括：

- 未授权访问
- 数据泄露
- 系统故障
- 恶意软件感染

**定义 5.1.2 (事件严重性)**
事件严重性定义为：
$$Severity = Impact \times Urgency \times Probability$$

```python
from typing import Dict, List, Optional
from enum import Enum
import asyncio
import json

class EventSeverity(Enum):
    """事件严重性级别"""
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

class EventStatus(Enum):
    """事件状态"""
    OPEN = "open"
    INVESTIGATING = "investigating"
    RESOLVED = "resolved"
    CLOSED = "closed"

class SecurityEvent:
    """安全事件"""
    
    def __init__(self, event_id: str, event_type: str, description: str,
                 severity: EventSeverity, source_ip: str, timestamp: float):
        self.event_id = event_id
        self.event_type = event_type
        self.description = description
        self.severity = severity
        self.source_ip = source_ip
        self.timestamp = timestamp
        self.status = EventStatus.OPEN
        self.assignee: Optional[str] = None
        self.notes: List[str] = []
        self.resolution: Optional[str] = None
    
    def add_note(self, note: str) -> None:
        """添加备注"""
        self.notes.append(note)
    
    def assign_to(self, assignee: str) -> None:
        """分配给处理人员"""
        self.assignee = assignee
        self.status = EventStatus.INVESTIGATING
    
    def resolve(self, resolution: str) -> None:
        """解决事件"""
        self.resolution = resolution
        self.status = EventStatus.RESOLVED
    
    def close(self) -> None:
        """关闭事件"""
        self.status = EventStatus.CLOSED

class SecurityEventManager:
    """安全事件管理器"""
    
    def __init__(self):
        self.events: Dict[str, SecurityEvent] = {}
        self.event_counter = 0
        self.response_playbooks: Dict[str, List[str]] = {}
        self._initialize_playbooks()
    
    def _initialize_playbooks(self) -> None:
        """初始化响应剧本"""
        self.response_playbooks = {
            "port_scan": [
                "1. 确认扫描源IP",
                "2. 检查目标系统状态",
                "3. 更新防火墙规则",
                "4. 监控后续活动"
            ],
            "brute_force": [
                "1. 立即阻止攻击源IP",
                "2. 检查账户安全状态",
                "3. 重置受影响密码",
                "4. 启用双因素认证"
            ],
            "data_exfiltration": [
                "1. 立即断开网络连接",
                "2. 备份系统状态",
                "3. 分析数据泄露范围",
                "4. 通知相关方"
            ]
        }
    
    def create_event(self, event_type: str, description: str,
                    severity: EventSeverity, source_ip: str) -> str:
        """创建安全事件"""
        self.event_counter += 1
        event_id = f"SEC-{self.event_counter:06d}"
        
        event = SecurityEvent(
            event_id=event_id,
            event_type=event_type,
            description=description,
            severity=severity,
            source_ip=source_ip,
            timestamp=time.time()
        )
        
        self.events[event_id] = event
        return event_id
    
    def get_event(self, event_id: str) -> Optional[SecurityEvent]:
        """获取事件"""
        return self.events.get(event_id)
    
    def list_events(self, status: Optional[EventStatus] = None) -> List[SecurityEvent]:
        """列出事件"""
        events = list(self.events.values())
        if status:
            events = [e for e in events if e.status == status]
        return sorted(events, key=lambda e: e.timestamp, reverse=True)
    
    def get_playbook(self, event_type: str) -> List[str]:
        """获取响应剧本"""
        return self.response_playbooks.get(event_type, [])
    
    def add_playbook(self, event_type: str, steps: List[str]) -> None:
        """添加响应剧本"""
        self.response_playbooks[event_type] = steps
    
    def get_statistics(self) -> Dict[str, Any]:
        """获取统计信息"""
        total_events = len(self.events)
        open_events = len([e for e in self.events.values() if e.status == EventStatus.OPEN])
        critical_events = len([e for e in self.events.values() if e.severity == EventSeverity.CRITICAL])
        
        return {
            "total_events": total_events,
            "open_events": open_events,
            "critical_events": critical_events,
            "resolution_rate": (total_events - open_events) / total_events if total_events > 0 else 0
        }

class IncidentResponse:
    """事件响应系统"""
    
    def __init__(self, event_manager: SecurityEventManager):
        self.event_manager = event_manager
        self.response_team: List[str] = []
        self.escalation_rules: Dict[EventSeverity, int] = {
            EventSeverity.LOW: 24,      # 24小时
            EventSeverity.MEDIUM: 8,    # 8小时
            EventSeverity.HIGH: 2,      # 2小时
            EventSeverity.CRITICAL: 1   # 1小时
        }
    
    def add_response_team_member(self, member: str) -> None:
        """添加响应团队成员"""
        self.response_team.append(member)
    
    def assign_event(self, event_id: str, assignee: str) -> bool:
        """分配事件"""
        event = self.event_manager.get_event(event_id)
        if event and assignee in self.response_team:
            event.assign_to(assignee)
            return True
        return False
    
    def escalate_event(self, event_id: str) -> bool:
        """升级事件"""
        event = self.event_manager.get_event(event_id)
        if not event:
            return False
        
        # 提升严重性级别
        if event.severity == EventSeverity.LOW:
            event.severity = EventSeverity.MEDIUM
        elif event.severity == EventSeverity.MEDIUM:
            event.severity = EventSeverity.HIGH
        elif event.severity == EventSeverity.HIGH:
            event.severity = EventSeverity.CRITICAL
        
        event.add_note(f"事件已升级到 {event.severity.name}")
        return True
    
    def check_escalation(self) -> List[str]:
        """检查需要升级的事件"""
        current_time = time.time()
        escalated_events = []
        
        for event in self.event_manager.events.values():
            if event.status == EventStatus.OPEN:
                time_elapsed = current_time - event.timestamp
                escalation_time = self.escalation_rules[event.severity] * 3600  # 转换为秒
                
                if time_elapsed > escalation_time:
                    escalated_events.append(event.event_id)
        
        return escalated_events
    
    def generate_report(self, start_time: float, end_time: float) -> Dict[str, Any]:
        """生成响应报告"""
        events_in_period = [
            e for e in self.event_manager.events.values()
            if start_time <= e.timestamp <= end_time
        ]
        
        severity_counts = {}
        for severity in EventSeverity:
            severity_counts[severity.name] = len([
                e for e in events_in_period if e.severity == severity
            ])
        
        status_counts = {}
        for status in EventStatus:
            status_counts[status.value] = len([
                e for e in events_in_period if e.status == status
            ])
        
        return {
            "period": {
                "start": start_time,
                "end": end_time
            },
            "total_events": len(events_in_period),
            "severity_distribution": severity_counts,
            "status_distribution": status_counts,
            "response_time_avg": self._calculate_avg_response_time(events_in_period)
        }
    
    def _calculate_avg_response_time(self, events: List[SecurityEvent]) -> float:
        """计算平均响应时间"""
        response_times = []
        for event in events:
            if event.assignee and event.status != EventStatus.OPEN:
                # 简化计算，实际应该记录分配时间
                response_times.append(1.0)  # 假设1小时
        
        return sum(response_times) / len(response_times) if response_times else 0.0
```

## 6. 总结

本章系统地介绍了网络安全领域的架构设计，包括：

1. **理论基础**：网络安全定义、威胁模型、安全原则的数学形式化
2. **加密系统**：对称加密、非对称加密、数字签名的完整实现
3. **身份认证**：多因素认证、RBAC访问控制的系统设计
4. **入侵检测**：异常检测、规则引擎的智能监控系统
5. **事件响应**：安全事件管理、响应剧本的自动化处理

所有内容都提供了严格的数学定义、形式化证明和完整的Python代码实现，确保理论与实践的统一，为构建安全的网络系统提供了全面的技术基础。
