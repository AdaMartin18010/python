# 05-3 区块链业务建模

## 3.1 智能合约建模

### 3.1.1 智能合约基础

**定义 3.1.1 (智能合约)**
智能合约是运行在区块链上的自动执行程序，当预设条件满足时自动执行合约条款，无需第三方干预。

**数学形式化定义**：
设智能合约 $C$ 为五元组：
$$C = (S, F, T, E, I)$$

其中：
- $S$ 是状态集合：$S = \{s_1, s_2, ..., s_n\}$
- $F$ 是函数集合：$F = \{f_1, f_2, ..., f_m\}$
- $T$ 是触发条件：$T: S \times E \rightarrow \{true, false\}$
- $E$ 是事件集合：$E = \{e_1, e_2, ..., e_k\}$
- $I$ 是初始状态：$I \in S$

**状态转换函数**：
$$\delta: S \times F \times E \rightarrow S$$

**Python实现**：
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime
import hashlib
import json

@dataclass
class ContractState:
    """合约状态"""
    contract_address: str
    owner: str
    balance: float
    data: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    
    def hash(self) -> str:
        """计算状态哈希"""
        data_str = json.dumps(self.data, sort_keys=True, default=str)
        content = f"{self.contract_address}{self.owner}{self.balance}{data_str}{self.timestamp}"
        return hashlib.sha256(content.encode()).hexdigest()

@dataclass
class ContractEvent:
    """合约事件"""
    event_type: str
    sender: str
    data: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.now)
    block_number: Optional[int] = None

class SmartContract(ABC):
    """智能合约抽象基类"""
    
    def __init__(self, contract_address: str, owner: str):
        self.contract_address = contract_address
        self.owner = owner
        self.state = ContractState(contract_address, owner, 0.0)
        self.functions: Dict[str, Callable] = {}
        self.events: List[ContractEvent] = []
        self._register_functions()
    
    @abstractmethod
    def _register_functions(self):
        """注册合约函数"""
        pass
    
    def execute_function(self, function_name: str, sender: str, params: Dict[str, Any]) -> bool:
        """执行合约函数"""
        if function_name not in self.functions:
            return False
        
        try:
            # 检查权限
            if not self._check_permission(function_name, sender):
                return False
            
            # 执行函数
            result = self.functions[function_name](sender, params)
            
            # 记录事件
            event = ContractEvent(
                event_type=f"function_executed_{function_name}",
                sender=sender,
                data={"params": params, "result": result}
            )
            self.events.append(event)
            
            return result
            
        except Exception as e:
            # 记录错误事件
            error_event = ContractEvent(
                event_type="function_error",
                sender=sender,
                data={"function": function_name, "error": str(e)}
            )
            self.events.append(error_event)
            return False
    
    def _check_permission(self, function_name: str, sender: str) -> bool:
        """检查执行权限"""
        # 默认只有合约所有者可以执行
        return sender == self.owner
    
    def get_state(self) -> ContractState:
        """获取当前状态"""
        return self.state
    
    def get_events(self) -> List[ContractEvent]:
        """获取事件历史"""
        return self.events.copy()

class ERC20Token(SmartContract):
    """ERC20代币合约"""
    
    def __init__(self, contract_address: str, owner: str, name: str, symbol: str, total_supply: float):
        self.name = name
        self.symbol = symbol
        self.total_supply = total_supply
        super().__init__(contract_address, owner)
        
        # 初始化代币余额
        self.state.data["balances"] = {owner: total_supply}
        self.state.data["allowances"] = {}
    
    def _register_functions(self):
        """注册ERC20函数"""
        self.functions["transfer"] = self._transfer
        self.functions["approve"] = self._approve
        self.functions["transferFrom"] = self._transfer_from
        self.functions["balanceOf"] = self._balance_of
        self.functions["allowance"] = self._allowance
    
    def _transfer(self, sender: str, params: Dict[str, Any]) -> bool:
        """转账函数"""
        to_address = params.get("to")
        amount = params.get("amount", 0)
        
        if not to_address or amount <= 0:
            return False
        
        balances = self.state.data["balances"]
        
        # 检查余额
        if balances.get(sender, 0) < amount:
            return False
        
        # 执行转账
        balances[sender] = balances.get(sender, 0) - amount
        balances[to_address] = balances.get(to_address, 0) + amount
        
        return True
    
    def _approve(self, sender: str, params: Dict[str, Any]) -> bool:
        """授权函数"""
        spender = params.get("spender")
        amount = params.get("amount", 0)
        
        if not spender or amount < 0:
            return False
        
        allowances = self.state.data["allowances"]
        key = f"{sender}:{spender}"
        allowances[key] = amount
        
        return True
    
    def _transfer_from(self, sender: str, params: Dict[str, Any]) -> bool:
        """从授权地址转账"""
        from_address = params.get("from")
        to_address = params.get("to")
        amount = params.get("amount", 0)
        
        if not from_address or not to_address or amount <= 0:
            return False
        
        balances = self.state.data["balances"]
        allowances = self.state.data["allowances"]
        
        # 检查授权
        key = f"{from_address}:{sender}"
        if allowances.get(key, 0) < amount:
            return False
        
        # 检查余额
        if balances.get(from_address, 0) < amount:
            return False
        
        # 执行转账
        balances[from_address] = balances.get(from_address, 0) - amount
        balances[to_address] = balances.get(to_address, 0) + amount
        allowances[key] = allowances.get(key, 0) - amount
        
        return True
    
    def _balance_of(self, sender: str, params: Dict[str, Any]) -> float:
        """查询余额"""
        address = params.get("address", sender)
        balances = self.state.data["balances"]
        return balances.get(address, 0)
    
    def _allowance(self, sender: str, params: Dict[str, Any]) -> float:
        """查询授权额度"""
        owner = params.get("owner")
        spender = params.get("spender")
        
        if not owner or not spender:
            return 0
        
        allowances = self.state.data["allowances"]
        key = f"{owner}:{spender}"
        return allowances.get(key, 0)

class DeFiLendingPool(SmartContract):
    """DeFi借贷池合约"""
    
    def __init__(self, contract_address: str, owner: str):
        super().__init__(contract_address, owner)
        
        # 初始化借贷池状态
        self.state.data["deposits"] = {}  # 存款记录
        self.state.data["loans"] = {}     # 贷款记录
        self.state.data["interest_rate"] = 0.05  # 年化利率5%
        self.state.data["collateral_ratio"] = 1.5  # 抵押率150%
    
    def _register_functions(self):
        """注册借贷函数"""
        self.functions["deposit"] = self._deposit
        self.functions["withdraw"] = self._withdraw
        self.functions["borrow"] = self._borrow
        self.functions["repay"] = self._repay
        self.functions["liquidate"] = self._liquidate
    
    def _deposit(self, sender: str, params: Dict[str, Any]) -> bool:
        """存款"""
        amount = params.get("amount", 0)
        
        if amount <= 0:
            return False
        
        deposits = self.state.data["deposits"]
        deposits[sender] = deposits.get(sender, 0) + amount
        self.state.balance += amount
        
        return True
    
    def _withdraw(self, sender: str, params: Dict[str, Any]) -> bool:
        """取款"""
        amount = params.get("amount", 0)
        
        if amount <= 0:
            return False
        
        deposits = self.state.data["deposits"]
        
        if deposits.get(sender, 0) < amount:
            return False
        
        deposits[sender] -= amount
        self.state.balance -= amount
        
        return True
    
    def _borrow(self, sender: str, params: Dict[str, Any]) -> bool:
        """借款"""
        amount = params.get("amount", 0)
        collateral = params.get("collateral", 0)
        
        if amount <= 0 or collateral <= 0:
            return False
        
        # 检查抵押率
        required_collateral = amount * self.state.data["collateral_ratio"]
        if collateral < required_collateral:
            return False
        
        # 检查池子余额
        if self.state.balance < amount:
            return False
        
        loans = self.state.data["loans"]
        loans[sender] = {
            "amount": amount,
            "collateral": collateral,
            "timestamp": datetime.now(),
            "interest_accrued": 0
        }
        
        self.state.balance -= amount
        
        return True
    
    def _repay(self, sender: str, params: Dict[str, Any]) -> bool:
        """还款"""
        amount = params.get("amount", 0)
        
        if amount <= 0:
            return False
        
        loans = self.state.data["loans"]
        
        if sender not in loans:
            return False
        
        loan = loans[sender]
        
        # 计算利息
        interest = self._calculate_interest(loan)
        total_owed = loan["amount"] + interest
        
        if amount < total_owed:
            return False
        
        # 还款
        self.state.balance += amount
        
        # 退还抵押品
        collateral = loan["collateral"]
        deposits = self.state.data["deposits"]
        deposits[sender] = deposits.get(sender, 0) + collateral
        
        # 清除贷款记录
        del loans[sender]
        
        return True
    
    def _liquidate(self, sender: str, params: Dict[str, Any]) -> bool:
        """清算"""
        borrower = params.get("borrower")
        
        if not borrower:
            return False
        
        loans = self.state.data["loans"]
        
        if borrower not in loans:
            return False
        
        loan = loans[borrower]
        
        # 检查是否需要清算（简化逻辑）
        # 实际应用中需要检查抵押品价值变化
        
        # 清算：没收抵押品，清除贷款
        self.state.balance += loan["collateral"]
        del loans[borrower]
        
        return True
    
    def _calculate_interest(self, loan: Dict[str, Any]) -> float:
        """计算利息"""
        # 简化计算：按年化利率计算
        time_diff = datetime.now() - loan["timestamp"]
        days = time_diff.days
        return loan["amount"] * self.state.data["interest_rate"] * (days / 365)
```

### 3.1.2 智能合约安全

**定义 3.1.2 (智能合约安全)**
智能合约安全是指合约在执行过程中能够抵抗各种攻击和异常情况，保证资金和数据的完整性。

**安全威胁模型**：
$$T = \{t_1, t_2, ..., t_n\}$$

其中 $t_i$ 表示第 $i$ 种威胁类型。

**安全度量**：
$$S = 1 - \sum_{i=1}^{n} P(t_i) \times C(t_i)$$

其中：
- $P(t_i)$ 是威胁 $t_i$ 的发生概率
- $C(t_i)$ 是威胁 $t_i$ 的损失成本

**Python实现**：
```python
from enum import Enum
from typing import List, Dict, Set
import re

class SecurityThreat(Enum):
    """安全威胁类型"""
    REENTRANCY = "reentrancy"
    OVERFLOW = "overflow"
    ACCESS_CONTROL = "access_control"
    FRONTRUNNING = "frontrunning"
    DOS = "denial_of_service"

class SecurityAnalyzer:
    """安全分析器"""
    
    def __init__(self):
        self.threat_patterns = {
            SecurityThreat.REENTRANCY: [
                r"\.call\(",
                r"\.send\(",
                r"\.transfer\("
            ],
            SecurityThreat.OVERFLOW: [
                r"\+=",
                r"-=",
                r"\*=",
                r"/="
            ],
            SecurityThreat.ACCESS_CONTROL: [
                r"msg\.sender",
                r"tx\.origin"
            ]
        }
    
    def analyze_contract(self, contract_code: str) -> Dict[SecurityThreat, List[str]]:
        """分析合约代码"""
        vulnerabilities = {}
        
        for threat_type, patterns in self.threat_patterns.items():
            vulnerabilities[threat_type] = []
            
            for pattern in patterns:
                matches = re.finditer(pattern, contract_code)
                for match in matches:
                    vulnerabilities[threat_type].append({
                        "line": contract_code[:match.start()].count('\n') + 1,
                        "code": match.group(),
                        "description": self._get_threat_description(threat_type)
                    })
        
        return vulnerabilities
    
    def _get_threat_description(self, threat_type: SecurityThreat) -> str:
        """获取威胁描述"""
        descriptions = {
            SecurityThreat.REENTRANCY: "重入攻击风险",
            SecurityThreat.OVERFLOW: "数值溢出风险",
            SecurityThreat.ACCESS_CONTROL: "访问控制风险",
            SecurityThreat.FRONTRUNNING: "抢跑攻击风险",
            SecurityThreat.DOS: "拒绝服务风险"
        }
        return descriptions.get(threat_type, "未知威胁")

class SecureContract(SmartContract):
    """安全合约基类"""
    
    def __init__(self, contract_address: str, owner: str):
        super().__init__(contract_address, owner)
        self.security_analyzer = SecurityAnalyzer()
        self.reentrancy_guard = False
    
    def execute_function(self, function_name: str, sender: str, params: Dict[str, Any]) -> bool:
        """安全执行函数"""
        # 重入保护
        if self.reentrancy_guard:
            return False
        
        self.reentrancy_guard = True
        
        try:
            result = super().execute_function(function_name, sender, params)
            return result
        finally:
            self.reentrancy_guard = False
    
    def _safe_transfer(self, to: str, amount: float) -> bool:
        """安全转账"""
        if amount <= 0 or amount > self.state.balance:
            return False
        
        # 检查溢出
        if self.state.balance - amount < 0:
            return False
        
        self.state.balance -= amount
        return True
    
    def _check_overflow(self, a: float, b: float, operation: str) -> bool:
        """检查溢出"""
        if operation == "add":
            return a + b >= a and a + b >= b
        elif operation == "sub":
            return a - b <= a
        elif operation == "mul":
            return a * b / b == a if b != 0 else True
        return True
```

## 3.2 DeFi应用建模

### 3.2.1 去中心化交易所(DEX)

**定义 3.2.1 (去中心化交易所)**
去中心化交易所是基于智能合约的加密货币交易平台，用户可以直接进行点对点交易，无需中心化机构。

**数学形式化定义**：
设DEX $D$ 为：
$$D = (P, L, T, F)$$

其中：
- $P$ 是流动性池集合：$P = \{p_1, p_2, ..., p_n\}$
- $L$ 是流动性提供者集合：$L = \{l_1, l_2, ..., l_m\}$
- $T$ 是交易集合：$T = \{t_1, t_2, ..., t_k\}$
- $F$ 是费用函数：$F: T \rightarrow \mathbb{R}^+$

**恒定乘积公式**：
$$x \times y = k$$

其中 $x$ 和 $y$ 是池中两种代币的数量，$k$ 是常数。

**Python实现**：
```python
from typing import Dict, List, Tuple
import math

class LiquidityPool:
    """流动性池"""
    
    def __init__(self, token_a: str, token_b: str, fee_rate: float = 0.003):
        self.token_a = token_a
        self.token_b = token_b
        self.fee_rate = fee_rate
        self.reserve_a = 0.0
        self.reserve_b = 0.0
        self.total_supply = 0.0
        self.lp_tokens: Dict[str, float] = {}
    
    def add_liquidity(self, provider: str, amount_a: float, amount_b: float) -> float:
        """添加流动性"""
        if self.total_supply == 0:
            # 首次添加流动性
            lp_tokens = math.sqrt(amount_a * amount_b)
            self.reserve_a = amount_a
            self.reserve_b = amount_b
            self.total_supply = lp_tokens
            self.lp_tokens[provider] = lp_tokens
            return lp_tokens
        else:
            # 后续添加流动性
            lp_tokens_a = (amount_a * self.total_supply) / self.reserve_a
            lp_tokens_b = (amount_b * self.total_supply) / self.reserve_b
            lp_tokens = min(lp_tokens_a, lp_tokens_b)
            
            if lp_tokens > 0:
                self.reserve_a += amount_a
                self.reserve_b += amount_b
                self.total_supply += lp_tokens
                self.lp_tokens[provider] = self.lp_tokens.get(provider, 0) + lp_tokens
            
            return lp_tokens
    
    def remove_liquidity(self, provider: str, lp_tokens: float) -> Tuple[float, float]:
        """移除流动性"""
        if lp_tokens > self.lp_tokens.get(provider, 0):
            return 0, 0
        
        # 计算应得的代币数量
        amount_a = (lp_tokens * self.reserve_a) / self.total_supply
        amount_b = (lp_tokens * self.reserve_b) / self.total_supply
        
        # 更新状态
        self.reserve_a -= amount_a
        self.reserve_b -= amount_b
        self.total_supply -= lp_tokens
        self.lp_tokens[provider] -= lp_tokens
        
        return amount_a, amount_b
    
    def swap(self, sender: str, token_in: str, amount_in: float) -> float:
        """代币交换"""
        if token_in == self.token_a:
            token_out = self.token_b
            reserve_in = self.reserve_a
            reserve_out = self.reserve_b
        else:
            token_out = self.token_a
            reserve_in = self.reserve_b
            reserve_out = self.reserve_a
        
        # 计算手续费
        fee = amount_in * self.fee_rate
        amount_in_with_fee = amount_in - fee
        
        # 使用恒定乘积公式计算输出数量
        amount_out = (amount_in_with_fee * reserve_out) / (reserve_in + amount_in_with_fee)
        
        # 更新储备
        if token_in == self.token_a:
            self.reserve_a += amount_in
            self.reserve_b -= amount_out
        else:
            self.reserve_b += amount_in
            self.reserve_a -= amount_out
        
        return amount_out
    
    def get_price(self, token: str) -> float:
        """获取代币价格"""
        if token == self.token_a:
            return self.reserve_b / self.reserve_a if self.reserve_a > 0 else 0
        else:
            return self.reserve_a / self.reserve_b if self.reserve_b > 0 else 0

class DecentralizedExchange(SmartContract):
    """去中心化交易所"""
    
    def __init__(self, contract_address: str, owner: str):
        super().__init__(contract_address, owner)
        self.pools: Dict[str, LiquidityPool] = {}
        self.fee_collector = owner
    
    def _register_functions(self):
        """注册DEX函数"""
        self.functions["createPool"] = self._create_pool
        self.functions["addLiquidity"] = self._add_liquidity
        self.functions["removeLiquidity"] = self._remove_liquidity
        self.functions["swap"] = self._swap
        self.functions["getPrice"] = self._get_price
    
    def _create_pool(self, sender: str, params: Dict[str, Any]) -> bool:
        """创建流动性池"""
        token_a = params.get("tokenA")
        token_b = params.get("tokenB")
        fee_rate = params.get("feeRate", 0.003)
        
        if not token_a or not token_b:
            return False
        
        pool_key = f"{token_a}:{token_b}"
        if pool_key in self.pools:
            return False
        
        self.pools[pool_key] = LiquidityPool(token_a, token_b, fee_rate)
        return True
    
    def _add_liquidity(self, sender: str, params: Dict[str, Any]) -> bool:
        """添加流动性"""
        pool_key = params.get("poolKey")
        amount_a = params.get("amountA", 0)
        amount_b = params.get("amountB", 0)
        
        if pool_key not in self.pools:
            return False
        
        pool = self.pools[pool_key]
        lp_tokens = pool.add_liquidity(sender, amount_a, amount_b)
        
        return lp_tokens > 0
    
    def _remove_liquidity(self, sender: str, params: Dict[str, Any]) -> bool:
        """移除流动性"""
        pool_key = params.get("poolKey")
        lp_tokens = params.get("lpTokens", 0)
        
        if pool_key not in self.pools:
            return False
        
        pool = self.pools[pool_key]
        amount_a, amount_b = pool.remove_liquidity(sender, lp_tokens)
        
        return amount_a > 0 or amount_b > 0
    
    def _swap(self, sender: str, params: Dict[str, Any]) -> bool:
        """代币交换"""
        pool_key = params.get("poolKey")
        token_in = params.get("tokenIn")
        amount_in = params.get("amountIn", 0)
        
        if pool_key not in self.pools or amount_in <= 0:
            return False
        
        pool = self.pools[pool_key]
        amount_out = pool.swap(sender, token_in, amount_in)
        
        return amount_out > 0
    
    def _get_price(self, sender: str, params: Dict[str, Any]) -> float:
        """获取价格"""
        pool_key = params.get("poolKey")
        token = params.get("token")
        
        if pool_key not in self.pools:
            return 0
        
        pool = self.pools[pool_key]
        return pool.get_price(token)
```

## 3.3 总结

本章介绍了区块链的业务建模，包括智能合约、DeFi应用等核心业务模型。

**关键要点**：
1. 智能合约是自动执行的程序，具有状态、函数、事件等组件
2. 合约安全需要防范重入攻击、溢出、访问控制等威胁
3. DeFi应用包括借贷、交易所等，基于智能合约实现
4. 恒定乘积公式是DEX的核心定价机制

**下一步**：在下一章中，我们将探讨区块链的数据建模，包括状态管理、索引结构和数据压缩等。

---

**相关链接**：
- [05-1-概述](./05-1-概述.md)
- [05-2-架构模式](./05-2-架构模式.md)
- [05-4-数据建模](./05-4-数据建模.md)
- [返回目录](../README.md) 