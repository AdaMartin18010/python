# 05-2 区块链架构模式

## 2.1 节点架构模式

### 2.1.1 全节点架构

**定义 2.1.1 (全节点)**
全节点是区块链网络中存储完整区块链数据并参与共识的节点，具有验证交易、创建区块和同步网络的功能。

**数学形式化定义**：
设全节点 $N$ 包含以下组件：

- 共识引擎：$C = (S, V, F)$
- 网络层：$L = (P, M, R)$
- 存储层：$S = (B, T, I)$
- 交易池：$P = \{tx_1, tx_2, ..., tx_n\}$

其中：

- $S$ 是状态机
- $V$ 是验证函数
- $F$ 是最终化函数
- $P$ 是P2P网络
- $M$ 是消息处理
- $R$ 是路由算法

**Python实现**：

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Set
import asyncio
import threading
from datetime import datetime
from dataclasses import dataclass

@dataclass
class NodeConfig:
    """节点配置"""
    node_id: str
    port: int
    max_connections: int
    sync_mode: str = "full"  # full, light, archive
    enable_mining: bool = True

class ConsensusEngine:
    """共识引擎"""
    
    def __init__(self, consensus_type: str = "pow"):
        self.consensus_type = consensus_type
        self.current_state = "idle"
        self.validators: Set[str] = set()
        self.block_height = 0
    
    async def propose_block(self, transactions: List[Transaction]) -> Optional[Block]:
        """提议新区块"""
        if self.consensus_type == "pow":
            return await self._pow_mining(transactions)
        elif self.consensus_type == "pos":
            return await self._pos_validation(transactions)
        else:
            raise ValueError(f"Unsupported consensus type: {self.consensus_type}")
    
    async def _pow_mining(self, transactions: List[Transaction]) -> Block:
        """工作量证明挖矿"""
        # 创建区块头
        header = BlockHeader(
            previous_hash="",  # 需要从区块链获取
            timestamp=datetime.now(),
            merkle_root="",
            difficulty=4,
            nonce=0
        )
        
        block = Block(header, transactions)
        
        # 挖矿循环
        while True:
            block.header.merkle_root = block._calculate_merkle_root()
            block_hash = block.header.hash()
            
            if block_hash.startswith("0000"):  # 4个零开头
                block.block_hash = block_hash
                return block
            
            block.header.nonce += 1
    
    async def _pos_validation(self, transactions: List[Transaction]) -> Block:
        """权益证明验证"""
        # 选择验证者
        validator = self._select_validator()
        
        header = BlockHeader(
            previous_hash="",
            timestamp=datetime.now(),
            merkle_root="",
            difficulty=0,
            nonce=0
        )
        
        block = Block(header, transactions)
        block.header.merkle_root = block._calculate_merkle_root()
        block.block_hash = block.header.hash()
        
        return block
    
    def _select_validator(self) -> str:
        """选择验证者"""
        import random
        if self.validators:
            return random.choice(list(self.validators))
        return "default_validator"

class NetworkLayer:
    """网络层"""
    
    def __init__(self, node_id: str, port: int):
        self.node_id = node_id
        self.port = port
        self.peers: Dict[str, 'Peer'] = {}
        self.message_queue = asyncio.Queue()
        self.running = False
    
    async def start(self):
        """启动网络层"""
        self.running = True
        # 启动消息处理循环
        asyncio.create_task(self._message_loop())
        # 启动P2P服务器
        asyncio.create_task(self._start_server())
    
    async def _message_loop(self):
        """消息处理循环"""
        while self.running:
            try:
                message = await asyncio.wait_for(self.message_queue.get(), timeout=1.0)
                await self._handle_message(message)
            except asyncio.TimeoutError:
                continue
    
    async def _handle_message(self, message: Dict):
        """处理消息"""
        msg_type = message.get("type")
        
        if msg_type == "new_block":
            await self._handle_new_block(message)
        elif msg_type == "new_transaction":
            await self._handle_new_transaction(message)
        elif msg_type == "sync_request":
            await self._handle_sync_request(message)
    
    async def _handle_new_block(self, message: Dict):
        """处理新区块消息"""
        # 验证区块
        block_data = message.get("block")
        # 转发给其他节点
        await self._broadcast_message(message)
    
    async def _handle_new_transaction(self, message: Dict):
        """处理新交易消息"""
        # 验证交易
        tx_data = message.get("transaction")
        # 添加到交易池
        # 转发给其他节点
        await self._broadcast_message(message)
    
    async def _broadcast_message(self, message: Dict):
        """广播消息"""
        for peer in self.peers.values():
            await peer.send_message(message)
    
    async def _start_server(self):
        """启动P2P服务器"""
        # 这里简化实现，实际需要完整的P2P协议
        pass

class StorageLayer:
    """存储层"""
    
    def __init__(self, storage_type: str = "memory"):
        self.storage_type = storage_type
        self.blocks: Dict[str, Block] = {}
        self.transactions: Dict[str, Transaction] = {}
        self.state: Dict[str, float] = {}  # 地址余额
    
    async def store_block(self, block: Block) -> bool:
        """存储区块"""
        self.blocks[block.block_hash] = block
        
        # 更新状态
        for tx in block.transactions:
            self.transactions[tx.tx_id] = tx
            self.state[tx.sender] = self.state.get(tx.sender, 0) - tx.amount
            self.state[tx.receiver] = self.state.get(tx.receiver, 0) + tx.amount
        
        return True
    
    async def get_block(self, block_hash: str) -> Optional[Block]:
        """获取区块"""
        return self.blocks.get(block_hash)
    
    async def get_latest_block(self) -> Optional[Block]:
        """获取最新区块"""
        if not self.blocks:
            return None
        
        # 找到最新的区块（简化实现）
        latest_block = None
        for block in self.blocks.values():
            if latest_block is None or block.header.timestamp > latest_block.header.timestamp:
                latest_block = block
        
        return latest_block
    
    async def get_balance(self, address: str) -> float:
        """获取地址余额"""
        return self.state.get(address, 0.0)

class TransactionPool:
    """交易池"""
    
    def __init__(self, max_size: int = 10000):
        self.max_size = max_size
        self.transactions: Dict[str, Transaction] = {}
        self.pending_transactions: List[Transaction] = []
    
    async def add_transaction(self, transaction: Transaction) -> bool:
        """添加交易到池"""
        if len(self.transactions) >= self.max_size:
            return False
        
        # 验证交易
        if not self._validate_transaction(transaction):
            return False
        
        self.transactions[transaction.tx_id] = transaction
        self.pending_transactions.append(transaction)
        return True
    
    def _validate_transaction(self, transaction: Transaction) -> bool:
        """验证交易"""
        # 检查交易格式
        if not transaction.tx_id or not transaction.sender or not transaction.receiver:
            return False
        
        # 检查金额
        if transaction.amount <= 0:
            return False
        
        # 检查签名（简化实现）
        return True
    
    async def get_transactions(self, limit: int = 100) -> List[Transaction]:
        """获取待处理交易"""
        return self.pending_transactions[:limit]
    
    async def remove_transactions(self, transactions: List[Transaction]):
        """移除已处理的交易"""
        for tx in transactions:
            if tx.tx_id in self.transactions:
                del self.transactions[tx.tx_id]
            if tx in self.pending_transactions:
                self.pending_transactions.remove(tx)

class FullNode:
    """全节点"""
    
    def __init__(self, config: NodeConfig):
        self.config = config
        self.consensus_engine = ConsensusEngine()
        self.network_layer = NetworkLayer(config.node_id, config.port)
        self.storage_layer = StorageLayer()
        self.transaction_pool = TransactionPool()
        self.running = False
    
    async def start(self):
        """启动节点"""
        self.running = True
        
        # 启动网络层
        await self.network_layer.start()
        
        # 启动共识引擎
        if self.config.enable_mining:
            asyncio.create_task(self._mining_loop())
        
        # 启动同步
        asyncio.create_task(self._sync_loop())
    
    async def _mining_loop(self):
        """挖矿循环"""
        while self.running:
            try:
                # 获取待处理交易
                transactions = await self.transaction_pool.get_transactions(limit=100)
                
                if transactions:
                    # 创建新区块
                    new_block = await self.consensus_engine.propose_block(transactions)
                    
                    if new_block:
                        # 存储区块
                        await self.storage_layer.store_block(new_block)
                        
                        # 从交易池移除已处理的交易
                        await self.transaction_pool.remove_transactions(transactions)
                        
                        # 广播新区块
                        await self._broadcast_new_block(new_block)
                
                await asyncio.sleep(1)  # 挖矿间隔
                
            except Exception as e:
                print(f"Mining error: {e}")
                await asyncio.sleep(1)
    
    async def _sync_loop(self):
        """同步循环"""
        while self.running:
            try:
                # 检查是否需要同步
                latest_block = await self.storage_layer.get_latest_block()
                
                # 向其他节点请求最新区块
                # 这里简化实现
                
                await asyncio.sleep(10)  # 同步间隔
                
            except Exception as e:
                print(f"Sync error: {e}")
                await asyncio.sleep(10)
    
    async def _broadcast_new_block(self, block: Block):
        """广播新区块"""
        message = {
            "type": "new_block",
            "block": block,
            "timestamp": datetime.now().isoformat()
        }
        await self.network_layer._broadcast_message(message)
    
    async def submit_transaction(self, transaction: Transaction) -> bool:
        """提交交易"""
        return await self.transaction_pool.add_transaction(transaction)
    
    async def get_balance(self, address: str) -> float:
        """获取余额"""
        return await self.storage_layer.get_balance(address)
    
    async def stop(self):
        """停止节点"""
        self.running = False
        await self.network_layer._start_server()  # 停止网络服务
```

### 2.1.2 轻节点架构

**定义 2.1.2 (轻节点)**
轻节点只存储区块头信息，不存储完整的区块链数据，通过向全节点请求验证交易。

**Python实现**：

```python
class LightNode:
    """轻节点"""
    
    def __init__(self, config: NodeConfig):
        self.config = config
        self.block_headers: Dict[int, BlockHeader] = {}  # 只存储区块头
        self.network_layer = NetworkLayer(config.node_id, config.port)
        self.trusted_nodes: List[str] = []  # 信任的全节点
        self.running = False
    
    async def start(self):
        """启动轻节点"""
        self.running = True
        await self.network_layer.start()
        asyncio.create_task(self._sync_headers_loop())
    
    async def _sync_headers_loop(self):
        """同步区块头循环"""
        while self.running:
            try:
                # 向信任节点请求最新区块头
                for trusted_node in self.trusted_nodes:
                    await self._request_headers(trusted_node)
                
                await asyncio.sleep(30)  # 30秒同步一次
                
            except Exception as e:
                print(f"Header sync error: {e}")
                await asyncio.sleep(30)
    
    async def _request_headers(self, node_id: str):
        """请求区块头"""
        message = {
            "type": "headers_request",
            "from_height": len(self.block_headers),
            "timestamp": datetime.now().isoformat()
        }
        # 发送请求到指定节点
        pass
    
    async def verify_transaction(self, transaction: Transaction, block_hash: str) -> bool:
        """验证交易（通过默克尔证明）"""
        # 向全节点请求默克尔证明
        proof = await self._request_merkle_proof(transaction.tx_id, block_hash)
        
        # 验证默克尔证明
        return self._verify_merkle_proof(transaction, proof, block_hash)
    
    def _verify_merkle_proof(self, transaction: Transaction, proof: List[str], block_hash: str) -> bool:
        """验证默克尔证明"""
        # 计算交易哈希
        tx_hash = transaction.hash()
        
        # 使用证明路径重建默克尔根
        current_hash = tx_hash
        for proof_hash in proof:
            # 根据位置决定拼接顺序
            if current_hash < proof_hash:
                combined = current_hash + proof_hash
            else:
                combined = proof_hash + current_hash
            current_hash = hashlib.sha256(combined.encode()).hexdigest()
        
        # 检查是否匹配区块头中的默克尔根
        block_header = self._get_block_header_by_hash(block_hash)
        return current_hash == block_header.merkle_root if block_header else False
```

## 2.2 网络架构模式

### 2.2.1 P2P网络架构

**定义 2.2.1 (P2P网络)**
区块链网络采用对等网络架构，所有节点地位平等，直接通信，没有中心化服务器。

**网络拓扑结构**：

```text
    节点A -------- 节点B
    /  \          /  \
   /    \        /    \
节点C   节点D   节点E   节点F
   \    /        \    /
    \  /          \  /
    节点G -------- 节点H
```

**Python实现**：

```python
import socket
import json
import threading
from typing import Dict, List, Set

class Peer:
    """对等节点"""
    
    def __init__(self, node_id: str, host: str, port: int):
        self.node_id = node_id
        self.host = host
        self.port = port
        self.connections: Dict[str, 'Connection'] = {}
        self.known_peers: Set[str] = set()
        self.running = False
    
    async def start(self):
        """启动对等节点"""
        self.running = True
        
        # 启动监听服务器
        server = await asyncio.start_server(
            self._handle_connection, self.host, self.port
        )
        
        print(f"P2P node {self.node_id} listening on {self.host}:{self.port}")
        
        async with server:
            await server.serve_forever()
    
    async def _handle_connection(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter):
        """处理新连接"""
        addr = writer.get_extra_info('peername')
        connection_id = f"{addr[0]}:{addr[1]}"
        
        connection = Connection(reader, writer, connection_id)
        self.connections[connection_id] = connection
        
        try:
            await self._handle_messages(connection)
        except Exception as e:
            print(f"Connection error: {e}")
        finally:
            if connection_id in self.connections:
                del self.connections[connection_id]
            writer.close()
            await writer.wait_closed()
    
    async def _handle_messages(self, connection: 'Connection'):
        """处理消息"""
        while self.running:
            try:
                # 读取消息
                data = await connection.reader.read(1024)
                if not data:
                    break
                
                message = json.loads(data.decode())
                await self._process_message(message, connection)
                
            except Exception as e:
                print(f"Message handling error: {e}")
                break
    
    async def _process_message(self, message: Dict, connection: 'Connection'):
        """处理消息"""
        msg_type = message.get("type")
        
        if msg_type == "ping":
            await self._handle_ping(message, connection)
        elif msg_type == "pong":
            await self._handle_pong(message, connection)
        elif msg_type == "get_peers":
            await self._handle_get_peers(message, connection)
        elif msg_type == "peers":
            await self._handle_peers(message, connection)
        elif msg_type == "new_block":
            await self._handle_new_block(message, connection)
        elif msg_type == "new_transaction":
            await self._handle_new_transaction(message, connection)
    
    async def _handle_ping(self, message: Dict, connection: 'Connection'):
        """处理ping消息"""
        response = {
            "type": "pong",
            "timestamp": datetime.now().isoformat()
        }
        await connection.send_message(response)
    
    async def _handle_get_peers(self, message: Dict, connection: 'Connection'):
        """处理获取节点列表请求"""
        response = {
            "type": "peers",
            "peers": list(self.known_peers),
            "timestamp": datetime.now().isoformat()
        }
        await connection.send_message(response)
    
    async def connect_to_peer(self, host: str, port: int) -> bool:
        """连接到对等节点"""
        try:
            reader, writer = await asyncio.open_connection(host, port)
            connection_id = f"{host}:{port}"
            
            connection = Connection(reader, writer, connection_id)
            self.connections[connection_id] = connection
            
            # 发送ping消息
            ping_message = {
                "type": "ping",
                "node_id": self.node_id,
                "timestamp": datetime.now().isoformat()
            }
            await connection.send_message(ping_message)
            
            # 启动消息处理
            asyncio.create_task(self._handle_messages(connection))
            
            return True
            
        except Exception as e:
            print(f"Failed to connect to {host}:{port}: {e}")
            return False
    
    async def broadcast_message(self, message: Dict):
        """广播消息到所有连接"""
        for connection in self.connections.values():
            try:
                await connection.send_message(message)
            except Exception as e:
                print(f"Failed to send message to {connection.connection_id}: {e}")

class Connection:
    """连接类"""
    
    def __init__(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter, connection_id: str):
        self.reader = reader
        self.writer = writer
        self.connection_id = connection_id
    
    async def send_message(self, message: Dict):
        """发送消息"""
        data = json.dumps(message).encode()
        self.writer.write(data)
        await self.writer.drain()
```

### 2.2.2 网络发现机制

**定义 2.2.2 (网络发现)**
网络发现机制用于新节点加入网络时找到其他节点并建立连接。

**Python实现**：

```python
class NetworkDiscovery:
    """网络发现"""
    
    def __init__(self, bootstrap_nodes: List[str]):
        self.bootstrap_nodes = bootstrap_nodes
        self.discovered_peers: Set[str] = set()
        self.running = False
    
    async def start_discovery(self):
        """开始网络发现"""
        self.running = True
        
        # 从引导节点开始发现
        for bootstrap_node in self.bootstrap_nodes:
            await self._discover_from_node(bootstrap_node)
        
        # 定期重新发现
        asyncio.create_task(self._periodic_discovery())
    
    async def _discover_from_node(self, node_address: str):
        """从指定节点发现其他节点"""
        try:
            host, port = node_address.split(":")
            port = int(port)
            
            # 连接到节点
            reader, writer = await asyncio.open_connection(host, port)
            
            # 发送获取节点列表请求
            message = {
                "type": "get_peers",
                "timestamp": datetime.now().isoformat()
            }
            
            data = json.dumps(message).encode()
            writer.write(data)
            await writer.drain()
            
            # 读取响应
            response_data = await reader.read(1024)
            response = json.loads(response_data.decode())
            
            if response.get("type") == "peers":
                peers = response.get("peers", [])
                for peer in peers:
                    self.discovered_peers.add(peer)
            
            writer.close()
            await writer.wait_closed()
            
        except Exception as e:
            print(f"Discovery from {node_address} failed: {e}")
    
    async def _periodic_discovery(self):
        """定期网络发现"""
        while self.running:
            try:
                # 从已发现的节点中随机选择进行发现
                if self.discovered_peers:
                    random_peer = random.choice(list(self.discovered_peers))
                    await self._discover_from_node(random_peer)
                
                await asyncio.sleep(300)  # 5分钟发现一次
                
            except Exception as e:
                print(f"Periodic discovery error: {e}")
                await asyncio.sleep(300)
    
    def get_discovered_peers(self) -> List[str]:
        """获取发现的节点列表"""
        return list(self.discovered_peers)
```

## 2.3 存储架构模式

### 2.3.1 分层存储架构

**定义 2.3.1 (分层存储)**
区块链存储采用分层架构，包括内存层、磁盘层和归档层，以平衡性能和存储成本。

**存储层次结构**：

```text
┌─────────────────┐
│   内存层 (RAM)   │ ← 热数据，快速访问
├─────────────────┤
│   磁盘层 (SSD)   │ ← 温数据，中等访问
├─────────────────┤
│  归档层 (HDD)    │ ← 冷数据，慢速访问
└─────────────────┘
```

**Python实现**：

```python
from abc import ABC, abstractmethod
import sqlite3
import pickle
import os
from typing import Optional, List, Dict, Any

class StorageLayer(ABC):
    """存储层抽象基类"""
    
    @abstractmethod
    async def store(self, key: str, value: Any) -> bool:
        """存储数据"""
        pass
    
    @abstractmethod
    async def retrieve(self, key: str) -> Optional[Any]:
        """检索数据"""
        pass
    
    @abstractmethod
    async def delete(self, key: str) -> bool:
        """删除数据"""
        pass

class MemoryStorage(StorageLayer):
    """内存存储层"""
    
    def __init__(self, max_size: int = 10000):
        self.max_size = max_size
        self.data: Dict[str, Any] = {}
        self.access_count: Dict[str, int] = {}
    
    async def store(self, key: str, value: Any) -> bool:
        """存储到内存"""
        if len(self.data) >= self.max_size:
            # 移除最少访问的数据
            await self._evict_lru()
        
        self.data[key] = value
        self.access_count[key] = 0
        return True
    
    async def retrieve(self, key: str) -> Optional[Any]:
        """从内存检索"""
        if key in self.data:
            self.access_count[key] += 1
            return self.data[key]
        return None
    
    async def delete(self, key: str) -> bool:
        """从内存删除"""
        if key in self.data:
            del self.data[key]
            del self.access_count[key]
            return True
        return False
    
    async def _evict_lru(self):
        """移除最少最近使用的数据"""
        if not self.access_count:
            return
        
        # 找到访问次数最少的键
        lru_key = min(self.access_count.keys(), key=lambda k: self.access_count[k])
        await self.delete(lru_key)

class DiskStorage(StorageLayer):
    """磁盘存储层"""
    
    def __init__(self, db_path: str = "blockchain.db"):
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """初始化数据库"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # 创建区块表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS blocks (
                hash TEXT PRIMARY KEY,
                height INTEGER,
                data BLOB,
                timestamp DATETIME
            )
        ''')
        
        # 创建交易表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS transactions (
                tx_id TEXT PRIMARY KEY,
                block_hash TEXT,
                data BLOB,
                timestamp DATETIME,
                FOREIGN KEY (block_hash) REFERENCES blocks (hash)
            )
        ''')
        
        # 创建状态表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS state (
                address TEXT PRIMARY KEY,
                balance REAL,
                nonce INTEGER,
                timestamp DATETIME
            )
        ''')
        
        conn.commit()
        conn.close()
    
    async def store(self, key: str, value: Any) -> bool:
        """存储到磁盘"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # 序列化数据
            data = pickle.dumps(value)
            
            # 根据键的类型决定存储位置
            if key.startswith("block:"):
                block_hash = key[6:]  # 移除 "block:" 前缀
                cursor.execute(
                    "INSERT OR REPLACE INTO blocks (hash, data, timestamp) VALUES (?, ?, ?)",
                    (block_hash, data, datetime.now())
                )
            elif key.startswith("tx:"):
                tx_id = key[3:]  # 移除 "tx:" 前缀
                cursor.execute(
                    "INSERT OR REPLACE INTO transactions (tx_id, data, timestamp) VALUES (?, ?, ?)",
                    (tx_id, data, datetime.now())
                )
            elif key.startswith("state:"):
                address = key[6:]  # 移除 "state:" 前缀
                cursor.execute(
                    "INSERT OR REPLACE INTO state (address, data, timestamp) VALUES (?, ?, ?)",
                    (address, data, datetime.now())
                )
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            print(f"Disk storage error: {e}")
            return False
    
    async def retrieve(self, key: str) -> Optional[Any]:
        """从磁盘检索"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if key.startswith("block:"):
                block_hash = key[6:]
                cursor.execute("SELECT data FROM blocks WHERE hash = ?", (block_hash,))
            elif key.startswith("tx:"):
                tx_id = key[3:]
                cursor.execute("SELECT data FROM transactions WHERE tx_id = ?", (tx_id,))
            elif key.startswith("state:"):
                address = key[6:]
                cursor.execute("SELECT data FROM state WHERE address = ?", (address,))
            else:
                conn.close()
                return None
            
            result = cursor.fetchone()
            conn.close()
            
            if result:
                return pickle.loads(result[0])
            return None
            
        except Exception as e:
            print(f"Disk retrieval error: {e}")
            return None
    
    async def delete(self, key: str) -> bool:
        """从磁盘删除"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if key.startswith("block:"):
                block_hash = key[6:]
                cursor.execute("DELETE FROM blocks WHERE hash = ?", (block_hash,))
            elif key.startswith("tx:"):
                tx_id = key[3:]
                cursor.execute("DELETE FROM transactions WHERE tx_id = ?", (tx_id,))
            elif key.startswith("state:"):
                address = key[6:]
                cursor.execute("DELETE FROM state WHERE address = ?", (address,))
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            print(f"Disk deletion error: {e}")
            return False

class HierarchicalStorage:
    """分层存储管理器"""
    
    def __init__(self):
        self.memory_storage = MemoryStorage()
        self.disk_storage = DiskStorage()
        self.access_patterns: Dict[str, int] = {}  # 访问模式统计
    
    async def store(self, key: str, value: Any, priority: str = "normal") -> bool:
        """存储数据"""
        # 根据优先级决定存储位置
        if priority == "high" or self._is_hot_data(key):
            # 高优先级或热数据存储在内存
            success = await self.memory_storage.store(key, value)
            if success:
                await self.disk_storage.store(key, value)  # 备份到磁盘
            return success
        else:
            # 普通数据存储在磁盘
            return await self.disk_storage.store(key, value)
    
    async def retrieve(self, key: str) -> Optional[Any]:
        """检索数据"""
        # 首先从内存检索
        value = await self.memory_storage.retrieve(key)
        if value is not None:
            self._update_access_pattern(key)
            return value
        
        # 从磁盘检索
        value = await self.disk_storage.retrieve(key)
        if value is not None:
            self._update_access_pattern(key)
            
            # 如果是热数据，提升到内存
            if self._is_hot_data(key):
                await self.memory_storage.store(key, value)
            
            return value
        
        return None
    
    def _update_access_pattern(self, key: str):
        """更新访问模式"""
        self.access_patterns[key] = self.access_patterns.get(key, 0) + 1
    
    def _is_hot_data(self, key: str) -> bool:
        """判断是否为热数据"""
        access_count = self.access_patterns.get(key, 0)
        return access_count > 10  # 访问次数超过10次认为是热数据
    
    async def migrate_data(self):
        """数据迁移"""
        # 将冷数据从内存迁移到磁盘
        # 将热数据从磁盘迁移到内存
        pass
```

## 2.4 总结

本章介绍了区块链的架构模式，包括节点架构、网络架构和存储架构。

**关键要点**：

1. 全节点存储完整数据并参与共识，轻节点只存储区块头
2. P2P网络采用对等架构，所有节点地位平等
3. 分层存储平衡性能和成本，热数据存储在内存，冷数据存储在磁盘
4. 网络发现机制帮助新节点加入网络

**下一步**：在下一章中，我们将探讨区块链的业务建模，包括智能合约、DeFi应用和NFT系统等。

---

**相关链接**：

- [05-1-概述](./05-1-概述.md)
- [05-3-业务建模](./05-3-业务建模.md)
- [05-4-数据建模](./05-4-数据建模.md)
- [返回目录](../README.md)
