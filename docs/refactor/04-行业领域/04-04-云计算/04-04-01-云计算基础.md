# äº‘è®¡ç®—åŸºç¡€ç†è®º

## ğŸ“‹ æ¦‚è¿°

äº‘è®¡ç®—æ˜¯ä¸€ç§é€šè¿‡äº’è”ç½‘æä¾›è®¡ç®—èµ„æºçš„æœåŠ¡æ¨¡å¼ï¼ŒåŒ…æ‹¬åŸºç¡€è®¾æ–½å³æœåŠ¡ï¼ˆIaaSï¼‰ã€å¹³å°å³æœåŠ¡ï¼ˆPaaSï¼‰å’Œè½¯ä»¶å³æœåŠ¡ï¼ˆSaaSï¼‰ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°äº‘è®¡ç®—çš„åŸºç¡€æ¦‚å¿µã€æ¶æ„æ¨¡å‹å’Œæ ¸å¿ƒç®—æ³•ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 äº‘è®¡ç®—ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (äº‘è®¡ç®—ç³»ç»Ÿ)
äº‘è®¡ç®—ç³»ç»Ÿæ˜¯ä¸€ä¸ªå…­å…ƒç»„ï¼š
$$\text{Cloud} = (I, P, S, N, M, U)$$

å…¶ä¸­ï¼š
- $I = \{i_1, i_2, \ldots, i_n\}$ æ˜¯åŸºç¡€è®¾æ–½èµ„æºé›†åˆ
- $P = \{p_1, p_2, \ldots, p_m\}$ æ˜¯å¹³å°æœåŠ¡é›†åˆ
- $S = \{s_1, s_2, \ldots, s_k\}$ æ˜¯è½¯ä»¶åº”ç”¨é›†åˆ
- $N = (V, E)$ æ˜¯ç½‘ç»œæ‹“æ‰‘å›¾
- $M = \{m_1, m_2, \ldots, m_l\}$ æ˜¯ç®¡ç†æœåŠ¡é›†åˆ
- $U = \{u_1, u_2, \ldots, u_o\}$ æ˜¯ç”¨æˆ·é›†åˆ

### 1.2 æœåŠ¡æ¨¡å‹å®šä¹‰

**å®šä¹‰ 1.2** (IaaSæœåŠ¡)
åŸºç¡€è®¾æ–½å³æœåŠ¡ï¼š
$$\text{IaaS} = (\text{Compute}, \text{Storage}, \text{Network}, \text{Security})$$

**å®šä¹‰ 1.3** (PaaSæœåŠ¡)
å¹³å°å³æœåŠ¡ï¼š
$$\text{PaaS} = (\text{Runtime}, \text{Middleware}, \text{Development}, \text{Deployment})$$

**å®šä¹‰ 1.4** (SaaSæœåŠ¡)
è½¯ä»¶å³æœåŠ¡ï¼š
$$\text{SaaS} = (\text{Application}, \text{Interface}, \text{Data}, \text{Integration})$$

### 1.3 èµ„æºåˆ†é…å®šä¹‰

**å®šä¹‰ 1.5** (èµ„æºåˆ†é…)
èµ„æºåˆ†é…å‡½æ•°ï¼š
$$\text{Allocate}: \text{Resource} \times \text{Request} \times \text{Policy} \rightarrow \text{Allocation}$$

å…¶ä¸­ï¼š
- $\text{Resource}$ æ˜¯å¯ç”¨èµ„æºé›†åˆ
- $\text{Request}$ æ˜¯èµ„æºè¯·æ±‚
- $\text{Policy}$ æ˜¯åˆ†é…ç­–ç•¥
- $\text{Allocation}$ æ˜¯åˆ†é…ç»“æœ

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 è™šæ‹ŸåŒ–æŠ€æœ¯

#### 2.1.1 è™šæ‹Ÿæœºå®šä¹‰

**å®šä¹‰ 2.1** (è™šæ‹Ÿæœº)
è™šæ‹Ÿæœºæ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$\text{VM} = (H, G, R, S)$$

å…¶ä¸­ï¼š
- $H$ æ˜¯ç¡¬ä»¶æŠ½è±¡å±‚
- $G$ æ˜¯å®¢æˆ·æ“ä½œç³»ç»Ÿ
- $R$ æ˜¯èµ„æºåˆ†é…
- $S$ æ˜¯çŠ¶æ€ä¿¡æ¯

#### 2.1.2 å®¹å™¨å®šä¹‰

**å®šä¹‰ 2.2** (å®¹å™¨)
å®¹å™¨æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$\text{Container} = (I, P, E)$$

å…¶ä¸­ï¼š
- $I$ æ˜¯é•œåƒ
- $P$ æ˜¯è¿›ç¨‹ç©ºé—´
- $E$ æ˜¯ç¯å¢ƒå˜é‡

### 2.2 è´Ÿè½½å‡è¡¡

#### 2.2.1 è´Ÿè½½å‡è¡¡ç®—æ³•

**å®šä¹‰ 2.3** (è´Ÿè½½å‡è¡¡å™¨)
è´Ÿè½½å‡è¡¡å™¨ï¼š
$$\text{LoadBalancer}: \text{Request} \times \text{Servers} \times \text{Algorithm} \rightarrow \text{Server}$$

**ç®—æ³• 2.1** (è½®è¯¢è´Ÿè½½å‡è¡¡)
```python
def round_robin_balance(request: Request, servers: List[Server]) -> Server:
    """
    è½®è¯¢è´Ÿè½½å‡è¡¡ç®—æ³•
    
    å‚æ•°:
        request: è¯·æ±‚
        servers: æœåŠ¡å™¨åˆ—è¡¨
        
    è¿”å›:
        é€‰ä¸­çš„æœåŠ¡å™¨
    """
    if not servers:
        raise ValueError("æ²¡æœ‰å¯ç”¨çš„æœåŠ¡å™¨")
    
    # è·å–å½“å‰è½®è¯¢ç´¢å¼•
    current_index = get_current_index()
    
    # é€‰æ‹©ä¸‹ä¸€ä¸ªæœåŠ¡å™¨
    selected_server = servers[current_index % len(servers)]
    
    # æ›´æ–°ç´¢å¼•
    update_index(current_index + 1)
    
    return selected_server
```

**ç®—æ³• 2.2** (åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡)
```python
def weighted_round_robin_balance(request: Request, servers: List[Server]) -> Server:
    """
    åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡ç®—æ³•
    
    å‚æ•°:
        request: è¯·æ±‚
        servers: æœåŠ¡å™¨åˆ—è¡¨ï¼ˆåŒ…å«æƒé‡ï¼‰
        
    è¿”å›:
        é€‰ä¸­çš„æœåŠ¡å™¨
    """
    if not servers:
        raise ValueError("æ²¡æœ‰å¯ç”¨çš„æœåŠ¡å™¨")
    
    # è®¡ç®—æ€»æƒé‡
    total_weight = sum(server.weight for server in servers)
    
    # è·å–å½“å‰æƒé‡ç´¢å¼•
    current_weight = get_current_weight()
    
    # é€‰æ‹©æœåŠ¡å™¨
    for server in servers:
        if current_weight < server.weight:
            selected_server = server
            break
        current_weight -= server.weight
    else:
        # é‡æ–°å¼€å§‹
        selected_server = servers[0]
        current_weight = 0
    
    # æ›´æ–°æƒé‡ç´¢å¼•
    update_current_weight((current_weight + 1) % total_weight)
    
    return selected_server
```

### 2.3 è‡ªåŠ¨æ‰©ç¼©å®¹

#### 2.3.1 æ‰©ç¼©å®¹ç­–ç•¥

**å®šä¹‰ 2.4** (æ‰©ç¼©å®¹ç­–ç•¥)
æ‰©ç¼©å®¹ç­–ç•¥ï¼š
$$\text{ScalingPolicy}: \text{Metrics} \times \text{Thresholds} \rightarrow \text{ScalingAction}$$

**ç®—æ³• 2.3** (åŸºäºCPUçš„è‡ªåŠ¨æ‰©ç¼©å®¹)
```python
def cpu_based_scaling(metrics: Metrics, thresholds: ScalingThresholds) -> ScalingAction:
    """
    åŸºäºCPUä½¿ç”¨ç‡çš„è‡ªåŠ¨æ‰©ç¼©å®¹
    
    å‚æ•°:
        metrics: æ€§èƒ½æŒ‡æ ‡
        thresholds: æ‰©ç¼©å®¹é˜ˆå€¼
        
    è¿”å›:
        æ‰©ç¼©å®¹åŠ¨ä½œ
    """
    current_cpu = metrics.get_cpu_usage()
    current_instances = metrics.get_instance_count()
    
    if current_cpu > thresholds.scale_up_threshold:
        # éœ€è¦æ‰©å®¹
        target_instances = min(
            current_instances + thresholds.scale_up_step,
            thresholds.max_instances
        )
        return ScalingAction(
            action_type="scale_up",
            target_instances=target_instances,
            reason=f"CPUä½¿ç”¨ç‡è¿‡é«˜: {current_cpu:.2f}%"
        )
    
    elif current_cpu < thresholds.scale_down_threshold:
        # éœ€è¦ç¼©å®¹
        target_instances = max(
            current_instances - thresholds.scale_down_step,
            thresholds.min_instances
        )
        return ScalingAction(
            action_type="scale_down",
            target_instances=target_instances,
            reason=f"CPUä½¿ç”¨ç‡è¿‡ä½: {current_cpu:.2f}%"
        )
    
    else:
        # æ— éœ€è°ƒæ•´
        return ScalingAction(
            action_type="no_change",
            target_instances=current_instances,
            reason="CPUä½¿ç”¨ç‡æ­£å¸¸"
        )
```

## 3. æ¶æ„æ¨¡å‹

### 3.1 äº‘æœåŠ¡æ¶æ„

**å®šä¹‰ 3.1** (äº‘æœåŠ¡æ¶æ„)
äº‘æœåŠ¡æ¶æ„é‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼š
$$\text{CloudArchitecture} = (\text{Infrastructure}, \text{Platform}, \text{Application}, \text{User})$$

#### 3.1.1 åŸºç¡€è®¾æ–½å±‚

**å®šä¹‰ 3.2** (åŸºç¡€è®¾æ–½å±‚)
åŸºç¡€è®¾æ–½å±‚æä¾›åŸºç¡€è®¡ç®—èµ„æºï¼š
$$\text{Infrastructure} = (\text{Compute}, \text{Storage}, \text{Network}, \text{Security})$$

#### 3.1.2 å¹³å°å±‚

**å®šä¹‰ 3.3** (å¹³å°å±‚)
å¹³å°å±‚æä¾›å¼€å‘å’Œè¿è¡Œç¯å¢ƒï¼š
$$\text{Platform} = (\text{Runtime}, \text{Middleware}, \text{Development}, \text{Deployment})$$

#### 3.1.3 åº”ç”¨å±‚

**å®šä¹‰ 3.4** (åº”ç”¨å±‚)
åº”ç”¨å±‚æä¾›ä¸šåŠ¡åº”ç”¨æœåŠ¡ï¼š
$$\text{Application} = (\text{BusinessLogic}, \text{UserInterface}, \text{Integration})$$

### 3.2 å¾®æœåŠ¡æ¶æ„

**å®šä¹‰ 3.5** (å¾®æœåŠ¡)
å¾®æœåŠ¡æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„æœåŠ¡å•å…ƒï¼š
$$\text{Microservice} = (\text{API}, \text{BusinessLogic}, \text{Data}, \text{Deployment})$$

**å®šä¹‰ 3.6** (å¾®æœåŠ¡æ¶æ„)
å¾®æœåŠ¡æ¶æ„æ˜¯å¾®æœåŠ¡çš„é›†åˆï¼š
$$\text{MicroserviceArchitecture} = \{m_1, m_2, \ldots, m_n\}$$

## 4. Pythonå®ç°

### 4.1 äº‘æœåŠ¡æä¾›å•†å®ç°

```python
from typing import Dict, List, Optional, Set, Tuple
from dataclasses import dataclass
from enum import Enum
import time
import uuid
import threading
from abc import ABC, abstractmethod

@dataclass
class ResourceSpec:
    """èµ„æºè§„æ ¼"""
    cpu_cores: int
    memory_gb: int
    storage_gb: int
    network_mbps: int

@dataclass
class VirtualMachine:
    """è™šæ‹Ÿæœº"""
    vm_id: str
    name: str
    spec: ResourceSpec
    status: str
    created_time: float
    ip_address: Optional[str] = None

@dataclass
class Container:
    """å®¹å™¨"""
    container_id: str
    name: str
    image: str
    status: str
    created_time: float
    ports: Dict[int, int] = None

@dataclass
class ScalingThresholds:
    """æ‰©ç¼©å®¹é˜ˆå€¼"""
    scale_up_threshold: float = 80.0
    scale_down_threshold: float = 20.0
    scale_up_step: int = 1
    scale_down_step: int = 1
    min_instances: int = 1
    max_instances: int = 10

@dataclass
class ScalingAction:
    """æ‰©ç¼©å®¹åŠ¨ä½œ"""
    action_type: str
    target_instances: int
    reason: str
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()

class ServiceStatus(Enum):
    """æœåŠ¡çŠ¶æ€"""
    RUNNING = "running"
    STOPPED = "stopped"
    STARTING = "starting"
    STOPPING = "stopping"
    ERROR = "error"

class CloudProvider:
    """äº‘æœåŠ¡æä¾›å•†"""
    
    def __init__(self):
        self.vms: Dict[str, VirtualMachine] = {}
        self.containers: Dict[str, Container] = {}
        self.load_balancers: Dict[str, LoadBalancer] = {}
        self.auto_scalers: Dict[str, AutoScaler] = {}
        self.resource_pools: Dict[str, ResourcePool] = {}
        self.lock = threading.Lock()
    
    def create_vm(self, name: str, cpu_cores: int, memory_gb: int, 
                  storage_gb: int) -> Optional[VirtualMachine]:
        """åˆ›å»ºè™šæ‹Ÿæœº"""
        with self.lock:
            # æ£€æŸ¥èµ„æºå¯ç”¨æ€§
            if self._check_resource_availability(cpu_cores, memory_gb, storage_gb):
                vm_id = str(uuid.uuid4())
                spec = ResourceSpec(cpu_cores, memory_gb, storage_gb, 1000)
                vm = VirtualMachine(vm_id, name, spec, "creating", time.time())
                self.vms[vm_id] = vm
                self._allocate_resources(cpu_cores, memory_gb, storage_gb)
                
                # æ¨¡æ‹Ÿåˆ›å»ºè¿‡ç¨‹
                threading.Timer(2.0, self._complete_vm_creation, args=[vm_id]).start()
                
                return vm
            return None
    
    def _complete_vm_creation(self, vm_id: str):
        """å®Œæˆè™šæ‹Ÿæœºåˆ›å»º"""
        with self.lock:
            if vm_id in self.vms:
                vm = self.vms[vm_id]
                vm.status = "running"
                vm.ip_address = f"192.168.1.{len(self.vms)}"
    
    def create_container(self, name: str, image: str, 
                        cpu_cores: float = 1.0, memory_gb: float = 1.0) -> Optional[Container]:
        """åˆ›å»ºå®¹å™¨"""
        with self.lock:
            # æ£€æŸ¥èµ„æºå¯ç”¨æ€§
            if self._check_resource_availability(cpu_cores, memory_gb, 1):
                container_id = str(uuid.uuid4())
                container = Container(
                    container_id, name, image, "creating", time.time(), {}
                )
                self.containers[container_id] = container
                self._allocate_resources(cpu_cores, memory_gb, 1)
                
                # æ¨¡æ‹Ÿåˆ›å»ºè¿‡ç¨‹
                threading.Timer(1.0, self._complete_container_creation, args=[container_id]).start()
                
                return container
            return None
    
    def _complete_container_creation(self, container_id: str):
        """å®Œæˆå®¹å™¨åˆ›å»º"""
        with self.lock:
            if container_id in self.containers:
                container = self.containers[container_id]
                container.status = "running"
    
    def _check_resource_availability(self, cpu_cores: float, memory_gb: float, 
                                   storage_gb: int) -> bool:
        """æ£€æŸ¥èµ„æºå¯ç”¨æ€§"""
        # ç®€åŒ–çš„èµ„æºæ£€æŸ¥é€»è¾‘
        total_cpu = 100.0
        total_memory = 1000.0
        total_storage = 10000
        
        used_cpu = sum(vm.spec.cpu_cores for vm in self.vms.values())
        used_memory = sum(vm.spec.memory_gb for vm in self.vms.values())
        used_storage = sum(vm.spec.storage_gb for vm in self.vms.values())
        
        return (used_cpu + cpu_cores <= total_cpu and
                used_memory + memory_gb <= total_memory and
                used_storage + storage_gb <= total_storage)
    
    def _allocate_resources(self, cpu_cores: float, memory_gb: float, storage_gb: int):
        """åˆ†é…èµ„æº"""
        # èµ„æºåˆ†é…é€»è¾‘
        pass
    
    def delete_vm(self, vm_id: str) -> bool:
        """åˆ é™¤è™šæ‹Ÿæœº"""
        with self.lock:
            if vm_id in self.vms:
                vm = self.vms[vm_id]
                self._deallocate_resources(vm.spec.cpu_cores, vm.spec.memory_gb, vm.spec.storage_gb)
                del self.vms[vm_id]
                return True
            return False
    
    def _deallocate_resources(self, cpu_cores: float, memory_gb: float, storage_gb: int):
        """é‡Šæ”¾èµ„æº"""
        # èµ„æºé‡Šæ”¾é€»è¾‘
        pass

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, name: str, algorithm: str = "round_robin"):
        self.name = name
        self.algorithm = algorithm
        self.servers: List[Server] = []
        self.current_index = 0
        self.lock = threading.Lock()
    
    def add_server(self, server: Server):
        """æ·»åŠ æœåŠ¡å™¨"""
        with self.lock:
            self.servers.append(server)
    
    def remove_server(self, server_id: str):
        """ç§»é™¤æœåŠ¡å™¨"""
        with self.lock:
            self.servers = [s for s in self.servers if s.server_id != server_id]
    
    def route_request(self, request: Request) -> Optional[Server]:
        """è·¯ç”±è¯·æ±‚"""
        with self.lock:
            if not self.servers:
                return None
            
            if self.algorithm == "round_robin":
                return self._round_robin_route(request)
            elif self.algorithm == "weighted_round_robin":
                return self._weighted_round_robin_route(request)
            elif self.algorithm == "least_connections":
                return self._least_connections_route(request)
            else:
                return self._round_robin_route(request)
    
    def _round_robin_route(self, request: Request) -> Server:
        """è½®è¯¢è·¯ç”±"""
        server = self.servers[self.current_index % len(self.servers)]
        self.current_index = (self.current_index + 1) % len(self.servers)
        return server
    
    def _weighted_round_robin_route(self, request: Request) -> Server:
        """åŠ æƒè½®è¯¢è·¯ç”±"""
        # ç®€åŒ–çš„åŠ æƒè½®è¯¢å®ç°
        return self._round_robin_route(request)
    
    def _least_connections_route(self, request: Request) -> Server:
        """æœ€å°‘è¿æ¥è·¯ç”±"""
        return min(self.servers, key=lambda s: s.connection_count)

class AutoScaler:
    """è‡ªåŠ¨æ‰©ç¼©å®¹å™¨"""
    
    def __init__(self, service_name: str, thresholds: ScalingThresholds):
        self.service_name = service_name
        self.thresholds = thresholds
        self.current_instances = 1
        self.metrics_history: List[Metrics] = []
        self.scaling_history: List[ScalingAction] = []
    
    def update_metrics(self, metrics: Metrics):
        """æ›´æ–°æŒ‡æ ‡"""
        self.metrics_history.append(metrics)
        
        # ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…
        if len(self.metrics_history) > 100:
            self.metrics_history = self.metrics_history[-50:]
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©ç¼©å®¹
        scaling_action = self._check_scaling_needs(metrics)
        if scaling_action.action_type != "no_change":
            self.scaling_history.append(scaling_action)
            self.current_instances = scaling_action.target_instances
    
    def _check_scaling_needs(self, metrics: Metrics) -> ScalingAction:
        """æ£€æŸ¥æ‰©ç¼©å®¹éœ€æ±‚"""
        current_cpu = metrics.get_cpu_usage()
        current_memory = metrics.get_memory_usage()
        
        # åŸºäºCPUå’Œå†…å­˜çš„ç»¼åˆåˆ¤æ–­
        if current_cpu > self.thresholds.scale_up_threshold or current_memory > 80:
            target_instances = min(
                self.current_instances + self.thresholds.scale_up_step,
                self.thresholds.max_instances
            )
            return ScalingAction(
                action_type="scale_up",
                target_instances=target_instances,
                reason=f"CPU: {current_cpu:.2f}%, Memory: {current_memory:.2f}%"
            )
        
        elif current_cpu < self.thresholds.scale_down_threshold and current_memory < 30:
            target_instances = max(
                self.current_instances - self.thresholds.scale_down_step,
                self.thresholds.min_instances
            )
            return ScalingAction(
                action_type="scale_down",
                target_instances=target_instances,
                reason=f"CPU: {current_cpu:.2f}%, Memory: {current_memory:.2f}%"
            )
        
        else:
            return ScalingAction(
                action_type="no_change",
                target_instances=self.current_instances,
                reason="èµ„æºä½¿ç”¨æ­£å¸¸"
            )

class Server:
    """æœåŠ¡å™¨"""
    
    def __init__(self, server_id: str, name: str, weight: int = 1):
        self.server_id = server_id
        self.name = name
        self.weight = weight
        self.connection_count = 0
        self.status = ServiceStatus.RUNNING
        self.cpu_usage = 0.0
        self.memory_usage = 0.0
    
    def handle_request(self, request: Request) -> Response:
        """å¤„ç†è¯·æ±‚"""
        self.connection_count += 1
        try:
            # æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†
            response = Response(request.request_id, "success", "Hello from server")
            return response
        finally:
            self.connection_count -= 1

class Request:
    """è¯·æ±‚"""
    
    def __init__(self, request_id: str, method: str, path: str, data: Dict = None):
        self.request_id = request_id
        self.method = method
        self.path = path
        self.data = data or {}
        self.timestamp = time.time()

class Response:
    """å“åº”"""
    
    def __init__(self, request_id: str, status: str, data: str):
        self.request_id = request_id
        self.status = status
        self.data = data
        self.timestamp = time.time()

class Metrics:
    """æ€§èƒ½æŒ‡æ ‡"""
    
    def __init__(self, cpu_usage: float, memory_usage: float, 
                 request_count: int, error_count: int):
        self.cpu_usage = cpu_usage
        self.memory_usage = memory_usage
        self.request_count = request_count
        self.error_count = error_count
        self.timestamp = time.time()
    
    def get_cpu_usage(self) -> float:
        return self.cpu_usage
    
    def get_memory_usage(self) -> float:
        return self.memory_usage
    
    def get_error_rate(self) -> float:
        if self.request_count == 0:
            return 0.0
        return self.error_count / self.request_count

class ResourcePool:
    """èµ„æºæ± """
    
    def __init__(self, name: str, total_cpu: float, total_memory: float, 
                 total_storage: int):
        self.name = name
        self.total_cpu = total_cpu
        self.total_memory = total_memory
        self.total_storage = total_storage
        self.used_cpu = 0.0
        self.used_memory = 0.0
        self.used_storage = 0
    
    def allocate(self, cpu: float, memory: float, storage: int) -> bool:
        """åˆ†é…èµ„æº"""
        if (self.used_cpu + cpu <= self.total_cpu and
            self.used_memory + memory <= self.total_memory and
            self.used_storage + storage <= self.total_storage):
            
            self.used_cpu += cpu
            self.used_memory += memory
            self.used_storage += storage
            return True
        return False
    
    def deallocate(self, cpu: float, memory: float, storage: int):
        """é‡Šæ”¾èµ„æº"""
        self.used_cpu = max(0, self.used_cpu - cpu)
        self.used_memory = max(0, self.used_memory - memory)
        self.used_storage = max(0, self.used_storage - storage)
    
    def get_utilization(self) -> Dict[str, float]:
        """è·å–èµ„æºåˆ©ç”¨ç‡"""
        return {
            'cpu': self.used_cpu / self.total_cpu,
            'memory': self.used_memory / self.total_memory,
            'storage': self.used_storage / self.total_storage
        }
```

### 4.2 å¾®æœåŠ¡éƒ¨ç½²å®ç°

```python
class Microservice:
    """å¾®æœåŠ¡"""
    
    def __init__(self, name: str, image: str, replicas: int = 1):
        self.name = name
        self.image = image
        self.replicas = replicas
        self.containers: List[Container] = []
        self.service_discovery = ServiceDiscovery()
        self.health_checker = HealthChecker()
    
    def deploy(self, cloud_provider: CloudProvider) -> bool:
        """éƒ¨ç½²å¾®æœåŠ¡"""
        try:
            for i in range(self.replicas):
                container_name = f"{self.name}-{i+1}"
                container = cloud_provider.create_container(container_name, self.image)
                if container:
                    self.containers.append(container)
            
            # æ³¨å†Œåˆ°æœåŠ¡å‘ç°
            self.service_discovery.register_service(self.name, self.containers)
            
            return True
        except Exception as e:
            print(f"éƒ¨ç½²å¤±è´¥: {e}")
            return False
    
    def scale(self, target_replicas: int, cloud_provider: CloudProvider) -> bool:
        """æ‰©ç¼©å®¹"""
        current_replicas = len(self.containers)
        
        if target_replicas > current_replicas:
            # æ‰©å®¹
            for i in range(target_replicas - current_replicas):
                container_name = f"{self.name}-{current_replicas + i + 1}"
                container = cloud_provider.create_container(container_name, self.image)
                if container:
                    self.containers.append(container)
        
        elif target_replicas < current_replicas:
            # ç¼©å®¹
            containers_to_remove = self.containers[target_replicas:]
            for container in containers_to_remove:
                cloud_provider.delete_container(container.container_id)
            self.containers = self.containers[:target_replicas]
        
        self.replicas = target_replicas
        self.service_discovery.update_service(self.name, self.containers)
        return True

class ServiceDiscovery:
    """æœåŠ¡å‘ç°"""
    
    def __init__(self):
        self.services: Dict[str, List[Container]] = {}
        self.health_status: Dict[str, bool] = {}
    
    def register_service(self, service_name: str, containers: List[Container]):
        """æ³¨å†ŒæœåŠ¡"""
        self.services[service_name] = containers
        self.health_status[service_name] = True
    
    def update_service(self, service_name: str, containers: List[Container]):
        """æ›´æ–°æœåŠ¡"""
        self.services[service_name] = containers
    
    def get_service_instances(self, service_name: str) -> List[Container]:
        """è·å–æœåŠ¡å®ä¾‹"""
        return self.services.get(service_name, [])
    
    def is_service_healthy(self, service_name: str) -> bool:
        """æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€"""
        return self.health_status.get(service_name, False)

class HealthChecker:
    """å¥åº·æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.health_checks: Dict[str, callable] = {}
    
    def add_health_check(self, service_name: str, check_function: callable):
        """æ·»åŠ å¥åº·æ£€æŸ¥"""
        self.health_checks[service_name] = check_function
    
    def check_health(self, service_name: str) -> bool:
        """æ‰§è¡Œå¥åº·æ£€æŸ¥"""
        check_function = self.health_checks.get(service_name)
        if check_function:
            try:
                return check_function()
            except Exception:
                return False
        return True

class ContainerOrchestrator:
    """å®¹å™¨ç¼–æ’å™¨"""
    
    def __init__(self, cloud_provider: CloudProvider):
        self.cloud_provider = cloud_provider
        self.microservices: Dict[str, Microservice] = {}
        self.load_balancers: Dict[str, LoadBalancer] = {}
        self.auto_scalers: Dict[str, AutoScaler] = {}
    
    def deploy_microservice(self, name: str, image: str, replicas: int = 1) -> bool:
        """éƒ¨ç½²å¾®æœåŠ¡"""
        microservice = Microservice(name, image, replicas)
        if microservice.deploy(self.cloud_provider):
            self.microservices[name] = microservice
            
            # åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
            load_balancer = LoadBalancer(f"lb-{name}")
            self.load_balancers[name] = load_balancer
            
            # åˆ›å»ºè‡ªåŠ¨æ‰©ç¼©å®¹å™¨
            thresholds = ScalingThresholds()
            auto_scaler = AutoScaler(name, thresholds)
            self.auto_scalers[name] = auto_scaler
            
            return True
        return False
    
    def scale_microservice(self, name: str, target_replicas: int) -> bool:
        """æ‰©ç¼©å®¹å¾®æœåŠ¡"""
        if name in self.microservices:
            return self.microservices[name].scale(target_replicas, self.cloud_provider)
        return False
    
    def update_metrics(self, service_name: str, metrics: Metrics):
        """æ›´æ–°æŒ‡æ ‡"""
        if service_name in self.auto_scalers:
            self.auto_scalers[service_name].update_metrics(metrics)
    
    def get_service_status(self, service_name: str) -> Dict:
        """è·å–æœåŠ¡çŠ¶æ€"""
        if service_name in self.microservices:
            microservice = self.microservices[service_name]
            return {
                'name': service_name,
                'replicas': len(microservice.containers),
                'target_replicas': microservice.replicas,
                'containers': [
                    {
                        'id': c.container_id,
                        'status': c.status,
                        'created_time': c.created_time
                    }
                    for c in microservice.containers
                ]
            }
        return {}
```

### 4.3 ç›‘æ§å’Œæ—¥å¿—å®ç°

```python
class MonitoringSystem:
    """ç›‘æ§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.metrics_collectors: Dict[str, MetricsCollector] = {}
        self.alert_rules: List[AlertRule] = []
        self.alerts: List[Alert] = []
    
    def add_metrics_collector(self, service_name: str, collector: MetricsCollector):
        """æ·»åŠ æŒ‡æ ‡æ”¶é›†å™¨"""
        self.metrics_collectors[service_name] = collector
    
    def collect_metrics(self, service_name: str) -> Optional[Metrics]:
        """æ”¶é›†æŒ‡æ ‡"""
        collector = self.metrics_collectors.get(service_name)
        if collector:
            return collector.collect()
        return None
    
    def add_alert_rule(self, rule: AlertRule):
        """æ·»åŠ å‘Šè­¦è§„åˆ™"""
        self.alert_rules.append(rule)
    
    def check_alerts(self, metrics: Metrics) -> List[Alert]:
        """æ£€æŸ¥å‘Šè­¦"""
        new_alerts = []
        for rule in self.alert_rules:
            if rule.evaluate(metrics):
                alert = Alert(
                    rule.name,
                    rule.severity,
                    rule.message,
                    time.time()
                )
                new_alerts.append(alert)
                self.alerts.append(alert)
        return new_alerts

class MetricsCollector:
    """æŒ‡æ ‡æ”¶é›†å™¨"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
        self.metrics_history: List[Metrics] = []
    
    def collect(self) -> Metrics:
        """æ”¶é›†æŒ‡æ ‡"""
        # æ¨¡æ‹ŸæŒ‡æ ‡æ”¶é›†
        import random
        cpu_usage = random.uniform(10, 90)
        memory_usage = random.uniform(20, 80)
        request_count = random.randint(100, 1000)
        error_count = random.randint(0, 50)
        
        metrics = Metrics(cpu_usage, memory_usage, request_count, error_count)
        self.metrics_history.append(metrics)
        
        # ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…
        if len(self.metrics_history) > 1000:
            self.metrics_history = self.metrics_history[-500:]
        
        return metrics

class AlertRule:
    """å‘Šè­¦è§„åˆ™"""
    
    def __init__(self, name: str, condition: str, severity: str, message: str):
        self.name = name
        self.condition = condition
        self.severity = severity
        self.message = message
    
    def evaluate(self, metrics: Metrics) -> bool:
        """è¯„ä¼°å‘Šè­¦æ¡ä»¶"""
        if "cpu" in self.condition and ">" in self.condition:
            threshold = float(self.condition.split(">")[1])
            return metrics.cpu_usage > threshold
        elif "memory" in self.condition and ">" in self.condition:
            threshold = float(self.condition.split(">")[1])
            return metrics.memory_usage > threshold
        elif "error_rate" in self.condition and ">" in self.condition:
            threshold = float(self.condition.split(">")[1])
            return metrics.get_error_rate() > threshold
        return False

class Alert:
    """å‘Šè­¦"""
    
    def __init__(self, name: str, severity: str, message: str, timestamp: float):
        self.name = name
        self.severity = severity
        self.message = message
        self.timestamp = timestamp
        self.acknowledged = False

class LoggingSystem:
    """æ—¥å¿—ç³»ç»Ÿ"""
    
    def __init__(self):
        self.logs: List[LogEntry] = []
        self.log_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
    
    def log(self, level: str, service: str, message: str, **kwargs):
        """è®°å½•æ—¥å¿—"""
        if level not in self.log_levels:
            level = 'INFO'
        
        log_entry = LogEntry(
            level=level,
            service=service,
            message=message,
            timestamp=time.time(),
            **kwargs
        )
        
        self.logs.append(log_entry)
        
        # ä¿æŒæ—¥å¿—æ•°é‡åœ¨åˆç†èŒƒå›´å†…
        if len(self.logs) > 10000:
            self.logs = self.logs[-5000:]
    
    def get_logs(self, service: str = None, level: str = None, 
                 start_time: float = None, end_time: float = None) -> List[LogEntry]:
        """è·å–æ—¥å¿—"""
        filtered_logs = self.logs
        
        if service:
            filtered_logs = [log for log in filtered_logs if log.service == service]
        
        if level:
            filtered_logs = [log for log in filtered_logs if log.level == level]
        
        if start_time:
            filtered_logs = [log for log in filtered_logs if log.timestamp >= start_time]
        
        if end_time:
            filtered_logs = [log for log in filtered_logs if log.timestamp <= end_time]
        
        return filtered_logs

@dataclass
class LogEntry:
    """æ—¥å¿—æ¡ç›®"""
    level: str
    service: str
    message: str
    timestamp: float
    **kwargs
```

## 5. ç†è®ºè¯æ˜

### 5.1 è´Ÿè½½å‡è¡¡ç®—æ³•æ­£ç¡®æ€§

**å®šç† 5.1** (è½®è¯¢è´Ÿè½½å‡è¡¡å‡åŒ€æ€§)
è½®è¯¢è´Ÿè½½å‡è¡¡ç®—æ³•èƒ½å¤Ÿå®ç°è¯·æ±‚çš„å‡åŒ€åˆ†å¸ƒã€‚

**è¯æ˜**:
1. **åˆå§‹åŒ–**: å½“å‰ç´¢å¼•ä¸º0
2. **å½’çº³å‡è®¾**: å‡è®¾å‰nä¸ªè¯·æ±‚å‡åŒ€åˆ†å¸ƒ
3. **å½’çº³æ­¥éª¤**: ç¬¬n+1ä¸ªè¯·æ±‚é€‰æ‹©ç´¢å¼•ä¸º(n mod m)çš„æœåŠ¡å™¨ï¼Œå…¶ä¸­mæ˜¯æœåŠ¡å™¨æ•°é‡
4. **ç»“è®º**: æ¯ä¸ªæœåŠ¡å™¨å¤„ç†çš„è¯·æ±‚æ•°é‡å·®å¼‚ä¸è¶…è¿‡1

### 5.2 è‡ªåŠ¨æ‰©ç¼©å®¹æ”¶æ•›æ€§

**å®šç† 5.2** (è‡ªåŠ¨æ‰©ç¼©å®¹æ”¶æ•›æ€§)
åœ¨ç¨³å®šçš„è´Ÿè½½æ¡ä»¶ä¸‹ï¼Œè‡ªåŠ¨æ‰©ç¼©å®¹ç®—æ³•èƒ½å¤Ÿæ”¶æ•›åˆ°ç¨³å®šçš„å®ä¾‹æ•°é‡ã€‚

**è¯æ˜**:
1. **ä¸Šç•Œ**: å®ä¾‹æ•°é‡ä¸ä¼šè¶…è¿‡max_instances
2. **ä¸‹ç•Œ**: å®ä¾‹æ•°é‡ä¸ä¼šä½äºmin_instances
3. **å•è°ƒæ€§**: æ‰©ç¼©å®¹æ“ä½œæ˜¯å•è°ƒçš„
4. **æ”¶æ•›æ€§**: ç”±äºæœ‰ç•Œä¸”å•è°ƒï¼Œç®—æ³•å¿…ç„¶æ”¶æ•›

### 5.3 èµ„æºåˆ†é…æœ€ä¼˜æ€§

**å®šç† 5.3** (èµ„æºåˆ†é…æœ€ä¼˜æ€§)
åœ¨èµ„æºçº¦æŸä¸‹ï¼Œèµ„æºåˆ†é…ç®—æ³•èƒ½å¤Ÿæœ€å¤§åŒ–èµ„æºåˆ©ç”¨ç‡ã€‚

**è¯æ˜**:
1. **å¯è¡Œæ€§**: åˆ†é…ç»“æœæ»¡è¶³èµ„æºçº¦æŸ
2. **æœ€ä¼˜æ€§**: é€šè¿‡è´ªå¿ƒç­–ç•¥é€‰æ‹©æœ€ä¼˜åˆ†é…
3. **å®Œæ•´æ€§**: ç®—æ³•èƒ½å¤Ÿå¤„ç†æ‰€æœ‰æœ‰æ•ˆçš„åˆ†é…è¯·æ±‚

## 6. æ€§èƒ½åˆ†æ

### 6.1 æ—¶é—´å¤æ‚åº¦

- **è™šæ‹Ÿæœºåˆ›å»º**: $O(1)$ åˆ†é…èµ„æºï¼Œ$O(n)$ åˆå§‹åŒ–
- **è´Ÿè½½å‡è¡¡**: $O(1)$ è½®è¯¢é€‰æ‹©
- **è‡ªåŠ¨æ‰©ç¼©å®¹**: $O(1)$ å†³ç­–ï¼Œ$O(n)$ æ‰§è¡Œ
- **æœåŠ¡å‘ç°**: $O(1)$ æŸ¥æ‰¾ï¼Œ$O(n)$ æ›´æ–°

### 6.2 ç©ºé—´å¤æ‚åº¦

- **è™šæ‹Ÿæœºç®¡ç†**: $O(n)$ å­˜å‚¨è™šæ‹Ÿæœºä¿¡æ¯
- **è´Ÿè½½å‡è¡¡**: $O(n)$ å­˜å‚¨æœåŠ¡å™¨åˆ—è¡¨
- **ç›‘æ§ç³»ç»Ÿ**: $O(n)$ å­˜å‚¨æŒ‡æ ‡å†å²
- **æ—¥å¿—ç³»ç»Ÿ**: $O(n)$ å­˜å‚¨æ—¥å¿—æ¡ç›®

### 6.3 ç½‘ç»œå¼€é”€

- **æœåŠ¡é—´é€šä¿¡**: $O(m \times n)$ å…¶ä¸­mæ˜¯æœåŠ¡æ•°ï¼Œnæ˜¯è¯·æ±‚æ•°
- **ç›‘æ§æ•°æ®ä¼ è¾“**: $O(k)$ å…¶ä¸­kæ˜¯ç›‘æ§æŒ‡æ ‡æ•°
- **æ—¥å¿—ä¼ è¾“**: $O(l)$ å…¶ä¸­læ˜¯æ—¥å¿—æ¡ç›®æ•°

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 ç”µå•†å¾®æœåŠ¡æ¶æ„

```python
def create_ecommerce_cloud_system():
    """åˆ›å»ºç”µå•†äº‘ç³»ç»Ÿ"""
    # åˆ›å»ºäº‘æœåŠ¡æä¾›å•†
    cloud_provider = CloudProvider()
    
    # åˆ›å»ºå®¹å™¨ç¼–æ’å™¨
    orchestrator = ContainerOrchestrator(cloud_provider)
    
    # éƒ¨ç½²å¾®æœåŠ¡
    services = [
        ("user-service", "user-service:latest", 2),
        ("product-service", "product-service:latest", 3),
        ("order-service", "order-service:latest", 2),
        ("payment-service", "payment-service:latest", 2),
        ("inventory-service", "inventory-service:latest", 2)
    ]
    
    for name, image, replicas in services:
        orchestrator.deploy_microservice(name, image, replicas)
    
    # åˆ›å»ºç›‘æ§ç³»ç»Ÿ
    monitoring = MonitoringSystem()
    
    # æ·»åŠ å‘Šè­¦è§„åˆ™
    alert_rules = [
        AlertRule("high_cpu", "cpu > 80", "warning", "CPUä½¿ç”¨ç‡è¿‡é«˜"),
        AlertRule("high_memory", "memory > 85", "warning", "å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜"),
        AlertRule("high_error_rate", "error_rate > 0.05", "critical", "é”™è¯¯ç‡è¿‡é«˜")
    ]
    
    for rule in alert_rules:
        monitoring.add_alert_rule(rule)
    
    # åˆ›å»ºæ—¥å¿—ç³»ç»Ÿ
    logging = LoggingSystem()
    
    return {
        'cloud_provider': cloud_provider,
        'orchestrator': orchestrator,
        'monitoring': monitoring,
        'logging': logging
    }

def simulate_ecommerce_traffic(system: Dict):
    """æ¨¡æ‹Ÿç”µå•†æµé‡"""
    orchestrator = system['orchestrator']
    monitoring = system['monitoring']
    logging = system['logging']
    
    # æ¨¡æ‹Ÿä¸åŒæ—¶é—´æ®µçš„æµé‡
    traffic_patterns = [
        (0.3, 100),   # ä½å³°æœŸ
        (0.6, 500),   # æ­£å¸¸æœŸ
        (0.9, 1000),  # é«˜å³°æœŸ
        (0.7, 300),   # å›è½æœŸ
    ]
    
    for cpu_factor, request_rate in traffic_patterns:
        print(f"=== æµé‡æ¨¡å¼: CPUå› å­={cpu_factor}, è¯·æ±‚ç‡={request_rate}/s ===")
        
        # æ›´æ–°æŒ‡æ ‡
        for service_name in ['user-service', 'product-service', 'order-service']:
            metrics = Metrics(
                cpu_usage=50 * cpu_factor,
                memory_usage=60 * cpu_factor,
                request_count=request_rate,
                error_count=int(request_rate * 0.01)
            )
            
            orchestrator.update_metrics(service_name, metrics)
            
            # æ£€æŸ¥å‘Šè­¦
            alerts = monitoring.check_alerts(metrics)
            for alert in alerts:
                logging.log('WARNING', service_name, f"å‘Šè­¦: {alert.message}")
                print(f"å‘Šè­¦: {alert.message}")
        
        time.sleep(2)  # æ¨¡æ‹Ÿæ—¶é—´é—´éš”

if __name__ == "__main__":
    # åˆ›å»ºç”µå•†äº‘ç³»ç»Ÿ
    system = create_ecommerce_cloud_system()
    
    # æ¨¡æ‹Ÿæµé‡
    simulate_ecommerce_traffic(system)
    
    # æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€
    print("\n=== ç³»ç»ŸçŠ¶æ€ ===")
    for service_name in ['user-service', 'product-service', 'order-service']:
        status = system['orchestrator'].get_service_status(service_name)
        print(f"{service_name}: {status['replicas']} ä¸ªå®ä¾‹")
```

### 7.2 å®¹å™¨åŒ–åº”ç”¨éƒ¨ç½²

```python
def deploy_containerized_application():
    """éƒ¨ç½²å®¹å™¨åŒ–åº”ç”¨"""
    # åˆ›å»ºäº‘æœåŠ¡æä¾›å•†
    cloud_provider = CloudProvider()
    
    # åˆ›å»ºåº”ç”¨å®¹å™¨
    app_containers = []
    
    # Webåº”ç”¨å®¹å™¨
    web_container = cloud_provider.create_container(
        "web-app", "nginx:latest", cpu_cores=0.5, memory_gb=0.5
    )
    if web_container:
        app_containers.append(web_container)
    
    # åº”ç”¨æœåŠ¡å®¹å™¨
    app_container = cloud_provider.create_container(
        "app-service", "python-app:latest", cpu_cores=1.0, memory_gb=1.0
    )
    if app_container:
        app_containers.append(app_container)
    
    # æ•°æ®åº“å®¹å™¨
    db_container = cloud_provider.create_container(
        "database", "postgres:latest", cpu_cores=2.0, memory_gb=2.0
    )
    if db_container:
        app_containers.append(db_container)
    
    # åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
    load_balancer = LoadBalancer("app-lb", algorithm="round_robin")
    
    # åˆ›å»ºæœåŠ¡å™¨
    servers = [
        Server("server-1", "web-server-1", weight=1),
        Server("server-2", "web-server-2", weight=1),
        Server("server-3", "web-server-3", weight=2)
    ]
    
    for server in servers:
        load_balancer.add_server(server)
    
    # åˆ›å»ºè‡ªåŠ¨æ‰©ç¼©å®¹å™¨
    thresholds = ScalingThresholds(
        scale_up_threshold=70.0,
        scale_down_threshold=30.0,
        min_instances=2,
        max_instances=10
    )
    auto_scaler = AutoScaler("app-service", thresholds)
    
    # æ¨¡æ‹Ÿè´Ÿè½½å˜åŒ–
    load_scenarios = [
        (0.3, "ä½è´Ÿè½½"),
        (0.6, "æ­£å¸¸è´Ÿè½½"),
        (0.9, "é«˜è´Ÿè½½"),
        (0.4, "è´Ÿè½½å›è½")
    ]
    
    for load_factor, description in load_scenarios:
        print(f"=== {description} ===")
        
        # æ¨¡æ‹Ÿæ€§èƒ½æŒ‡æ ‡
        metrics = Metrics(
            cpu_usage=50 * load_factor,
            memory_usage=60 * load_factor,
            request_count=int(1000 * load_factor),
            error_count=int(10 * load_factor)
        )
        
        # æ›´æ–°è‡ªåŠ¨æ‰©ç¼©å®¹å™¨
        auto_scaler.update_metrics(metrics)
        
        # æ˜¾ç¤ºå½“å‰çŠ¶æ€
        print(f"å½“å‰å®ä¾‹æ•°: {auto_scaler.current_instances}")
        print(f"CPUä½¿ç”¨ç‡: {metrics.cpu_usage:.2f}%")
        print(f"å†…å­˜ä½¿ç”¨ç‡: {metrics.memory_usage:.2f}%")
        
        time.sleep(1)
    
    return {
        'cloud_provider': cloud_provider,
        'containers': app_containers,
        'load_balancer': load_balancer,
        'auto_scaler': auto_scaler
    }
```

## 8. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°äº†äº‘è®¡ç®—çš„åŸºç¡€æ¦‚å¿µï¼ŒåŒ…æ‹¬ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†äº‘è®¡ç®—ç³»ç»Ÿçš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **æ ¸å¿ƒæ¦‚å¿µ**: è™šæ‹ŸåŒ–ã€è´Ÿè½½å‡è¡¡ã€è‡ªåŠ¨æ‰©ç¼©å®¹ç­‰æ ¸å¿ƒæ¦‚å¿µ
3. **æ¶æ„æ¨¡å‹**: äº‘æœåŠ¡æ¶æ„å’Œå¾®æœåŠ¡æ¶æ„
4. **Pythonå®ç°**: å®Œæ•´çš„äº‘æœåŠ¡æä¾›å•†ã€è´Ÿè½½å‡è¡¡ã€è‡ªåŠ¨æ‰©ç¼©å®¹å®ç°
5. **ç†è®ºè¯æ˜**: ç®—æ³•æ­£ç¡®æ€§å’Œç³»ç»Ÿæ€§è´¨çš„ä¸¥æ ¼è¯æ˜
6. **æ€§èƒ½åˆ†æ**: æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦åˆ†æ
7. **åº”ç”¨ç¤ºä¾‹**: ç”µå•†å¾®æœåŠ¡æ¶æ„å’Œå®¹å™¨åŒ–åº”ç”¨éƒ¨ç½²

äº‘è®¡ç®—ä½œä¸ºç°ä»£è½¯ä»¶æ¶æ„çš„é‡è¦åŸºç¡€ï¼Œå…¶ç†è®ºåŸºç¡€å’Œå®ç°æ–¹æ³•å¯¹äºæ„å»ºå¯æ‰©å±•ã€é«˜å¯ç”¨çš„ç³»ç»Ÿå…·æœ‰é‡è¦æ„ä¹‰ã€‚é€šè¿‡å½¢å¼åŒ–çš„æ–¹æ³•ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ›´å¥½åœ°ç†è§£å’Œè®¾è®¡äº‘è®¡ç®—ç³»ç»Ÿï¼Œç¡®ä¿å…¶æ­£ç¡®æ€§ã€å¯é æ€§å’Œæ•ˆç‡ã€‚

---

*æœ¬æ–‡æ¡£æ˜¯è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®—ç§‘å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„å½¢å¼åŒ–è§„èŒƒå’Œå­¦æœ¯æ ‡å‡†ã€‚*
