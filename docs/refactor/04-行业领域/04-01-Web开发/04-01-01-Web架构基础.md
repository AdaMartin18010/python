# Webæ¶æ„åŸºç¡€

## ğŸ“š æ¦‚è¿°

Webæ¶æ„æ˜¯äº’è”ç½‘åº”ç”¨å¼€å‘çš„æ ¸å¿ƒåŸºç¡€ï¼Œå®šä¹‰äº†Webç³»ç»Ÿçš„ç»„ç»‡ç»“æ„å’Œäº¤äº’æ¨¡å¼ã€‚æœ¬æ–‡æ¡£ä»è¡Œä¸šé¢†åŸŸçš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»Webæ¶æ„çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. Webæ¶æ„çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 Webæ¶æ„çš„æ•°å­¦å®šä¹‰

Webæ¶æ„å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$WA = (C, L, P, D)$$

å…¶ä¸­ï¼š
- $C$ æ˜¯ç»„ä»¶é›†åˆ $C = \{c_1, c_2, \ldots, c_n\}$
- $L$ æ˜¯å±‚é›†åˆ $L = \{l_1, l_2, \ldots, l_m\}$
- $P$ æ˜¯åè®®é›†åˆ $P = \{p_1, p_2, \ldots, p_k\}$
- $D$ æ˜¯æ•°æ®æµå…³ç³» $D \subseteq C \times C$

#### 1.2 Webæ¶æ„çš„Pythonå®ç°

```python
from typing import Any, List, Dict, Set, Optional, Callable, Generic, TypeVar
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
import json
import time
from datetime import datetime

T = TypeVar('T')

class ComponentType(Enum):
    """ç»„ä»¶ç±»å‹æšä¸¾"""
    CLIENT = "client"
    SERVER = "server"
    DATABASE = "database"
    CACHE = "cache"
    LOAD_BALANCER = "load_balancer"
    CDN = "cdn"

class LayerType(Enum):
    """å±‚ç±»å‹æšä¸¾"""
    PRESENTATION = "presentation"
    BUSINESS = "business"
    DATA = "data"
    INFRASTRUCTURE = "infrastructure"

class ProtocolType(Enum):
    """åè®®ç±»å‹æšä¸¾"""
    HTTP = "http"
    HTTPS = "https"
    TCP = "tcp"
    UDP = "udp"
    WEBSOCKET = "websocket"

@dataclass
class Component:
    """Webç»„ä»¶"""
    name: str
    type: ComponentType
    description: str
    endpoints: List[str] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)
    configuration: Dict[str, Any] = field(default_factory=dict)
    status: str = "inactive"

@dataclass
class Layer:
    """æ¶æ„å±‚"""
    name: str
    type: LayerType
    description: str
    components: List[Component] = field(default_factory=list)
    protocols: List[ProtocolType] = field(default_factory=list)
    responsibilities: List[str] = field(default_factory=list)

@dataclass
class DataFlow:
    """æ•°æ®æµ"""
    source: str
    target: str
    protocol: ProtocolType
    data_type: str
    frequency: str = "on-demand"
    security: Dict[str, Any] = field(default_factory=dict)

class WebArchitecture:
    """Webæ¶æ„ç®¡ç†"""
    
    def __init__(self, name: str):
        self.name = name
        self.components: Dict[str, Component] = {}
        self.layers: Dict[str, Layer] = {}
        self.data_flows: List[DataFlow] = []
        self.protocols: Set[ProtocolType] = set()
        
        # æ¶æ„æŒ‡æ ‡
        self.metrics = {
            'total_components': 0,
            'active_components': 0,
            'total_layers': 0,
            'data_flow_count': 0,
            'response_time': 0.0,
            'throughput': 0.0
        }
    
    def add_component(self, component: Component):
        """æ·»åŠ ç»„ä»¶"""
        self.components[component.name] = component
        self.metrics['total_components'] += 1
    
    def add_layer(self, layer: Layer):
        """æ·»åŠ å±‚"""
        self.layers[layer.name] = layer
        self.metrics['total_layers'] += 1
        
        # æ·»åŠ å±‚ä¸­çš„ç»„ä»¶
        for component in layer.components:
            self.add_component(component)
    
    def add_data_flow(self, data_flow: DataFlow):
        """æ·»åŠ æ•°æ®æµ"""
        self.data_flows.append(data_flow)
        self.protocols.add(data_flow.protocol)
        self.metrics['data_flow_count'] += 1
    
    def activate_component(self, component_name: str):
        """æ¿€æ´»ç»„ä»¶"""
        if component_name in self.components:
            self.components[component_name].status = "active"
            self.metrics['active_components'] += 1
    
    def deactivate_component(self, component_name: str):
        """åœç”¨ç»„ä»¶"""
        if component_name in self.components:
            self.components[component_name].status = "inactive"
            self.metrics['active_components'] -= 1
    
    def get_component_dependencies(self, component_name: str) -> List[str]:
        """è·å–ç»„ä»¶ä¾èµ–"""
        if component_name in self.components:
            return self.components[component_name].dependencies
        return []
    
    def analyze_architecture(self) -> Dict[str, Any]:
        """åˆ†ææ¶æ„"""
        analysis = {
            'component_distribution': {},
            'layer_distribution': {},
            'protocol_usage': {},
            'connectivity': 0.0,
            'complexity': 0.0
        }
        
        # ç»„ä»¶åˆ†å¸ƒ
        for component_type in ComponentType:
            count = sum(1 for c in self.components.values() 
                       if c.type == component_type)
            analysis['component_distribution'][component_type.value] = count
        
        # å±‚åˆ†å¸ƒ
        for layer_type in LayerType:
            count = sum(1 for l in self.layers.values() 
                       if l.type == layer_type)
            analysis['layer_distribution'][layer_type.value] = count
        
        # åè®®ä½¿ç”¨
        for protocol in self.protocols:
            count = sum(1 for df in self.data_flows 
                       if df.protocol == protocol)
            analysis['protocol_usage'][protocol.value] = count
        
        # è¿é€šæ€§
        if self.metrics['total_components'] > 1:
            max_connections = self.metrics['total_components'] * (self.metrics['total_components'] - 1)
            analysis['connectivity'] = self.metrics['data_flow_count'] / max_connections
        
        # å¤æ‚åº¦
        analysis['complexity'] = (self.metrics['total_components'] * 
                                self.metrics['total_layers'] * 
                                len(self.protocols))
        
        return analysis
    
    def generate_architecture_diagram(self) -> str:
        """ç”Ÿæˆæ¶æ„å›¾"""
        diagram = f"Webæ¶æ„å›¾: {self.name}\n"
        diagram += "=" * 50 + "\n\n"
        
        # å±‚ç»“æ„
        for layer_name, layer in self.layers.items():
            diagram += f"å±‚: {layer_name} ({layer.type.value})\n"
            diagram += f"  æè¿°: {layer.description}\n"
            diagram += f"  ç»„ä»¶: {[c.name for c in layer.components]}\n"
            diagram += f"  åè®®: {[p.value for p in layer.protocols]}\n\n"
        
        # æ•°æ®æµ
        diagram += "æ•°æ®æµ:\n"
        for flow in self.data_flows:
            diagram += f"  {flow.source} -> {flow.target} ({flow.protocol.value})\n"
        
        return diagram

# ä½¿ç”¨ç¤ºä¾‹
# åˆ›å»ºWebæ¶æ„
web_arch = WebArchitecture("ç”µå•†å¹³å°")

# åˆ›å»ºç»„ä»¶
client = Component("Webå®¢æˆ·ç«¯", ComponentType.CLIENT, "ç”¨æˆ·ç•Œé¢")
server = Component("åº”ç”¨æœåŠ¡å™¨", ComponentType.SERVER, "ä¸šåŠ¡é€»è¾‘å¤„ç†")
database = Component("æ•°æ®åº“", ComponentType.DATABASE, "æ•°æ®å­˜å‚¨")
cache = Component("ç¼“å­˜", ComponentType.CACHE, "æ•°æ®ç¼“å­˜")
load_balancer = Component("è´Ÿè½½å‡è¡¡å™¨", ComponentType.LOAD_BALANCER, "è¯·æ±‚åˆ†å‘")

# åˆ›å»ºå±‚
presentation_layer = Layer(
    "è¡¨ç°å±‚",
    LayerType.PRESENTATION,
    "ç”¨æˆ·ç•Œé¢å’Œäº¤äº’",
    [client],
    [ProtocolType.HTTP, ProtocolType.HTTPS]
)

business_layer = Layer(
    "ä¸šåŠ¡å±‚",
    LayerType.BUSINESS,
    "ä¸šåŠ¡é€»è¾‘å¤„ç†",
    [server],
    [ProtocolType.HTTP, ProtocolType.HTTPS]
)

data_layer = Layer(
    "æ•°æ®å±‚",
    LayerType.DATA,
    "æ•°æ®å­˜å‚¨å’Œè®¿é—®",
    [database, cache],
    [ProtocolType.TCP]
)

infrastructure_layer = Layer(
    "åŸºç¡€è®¾æ–½å±‚",
    LayerType.INFRASTRUCTURE,
    "ç³»ç»ŸåŸºç¡€è®¾æ–½",
    [load_balancer],
    [ProtocolType.TCP]
)

# æ·»åŠ å±‚
web_arch.add_layer(presentation_layer)
web_arch.add_layer(business_layer)
web_arch.add_layer(data_layer)
web_arch.add_layer(infrastructure_layer)

# æ·»åŠ æ•°æ®æµ
data_flows = [
    DataFlow("Webå®¢æˆ·ç«¯", "è´Ÿè½½å‡è¡¡å™¨", ProtocolType.HTTPS, "HTTPè¯·æ±‚"),
    DataFlow("è´Ÿè½½å‡è¡¡å™¨", "åº”ç”¨æœåŠ¡å™¨", ProtocolType.HTTP, "HTTPè¯·æ±‚"),
    DataFlow("åº”ç”¨æœåŠ¡å™¨", "æ•°æ®åº“", ProtocolType.TCP, "SQLæŸ¥è¯¢"),
    DataFlow("åº”ç”¨æœåŠ¡å™¨", "ç¼“å­˜", ProtocolType.TCP, "ç¼“å­˜æ“ä½œ")
]

for flow in data_flows:
    web_arch.add_data_flow(flow)

# æ¿€æ´»ç»„ä»¶
web_arch.activate_component("Webå®¢æˆ·ç«¯")
web_arch.activate_component("åº”ç”¨æœåŠ¡å™¨")
web_arch.activate_component("æ•°æ®åº“")

# åˆ†ææ¶æ„
analysis = web_arch.analyze_architecture()
print("æ¶æ„åˆ†æ:", analysis)

# ç”Ÿæˆæ¶æ„å›¾
diagram = web_arch.generate_architecture_diagram()
print(diagram)
```

### 2. å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„

#### 2.1 å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„çš„æ•°å­¦å®šä¹‰

å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$CS = (C, S, P, M)$$

å…¶ä¸­ï¼š
- $C$ æ˜¯å®¢æˆ·ç«¯é›†åˆ
- $S$ æ˜¯æœåŠ¡å™¨é›†åˆ
- $P$ æ˜¯åè®®é›†åˆ
- $M$ æ˜¯æ¶ˆæ¯ä¼ é€’å‡½æ•° $M: C \times S \times P \rightarrow Response$

#### 2.2 å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„çš„Pythonå®ç°

```python
import socket
import threading
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.request import urlopen
from urllib.parse import urlparse

class Client:
    """å®¢æˆ·ç«¯"""
    
    def __init__(self, name: str, server_url: str):
        self.name = name
        self.server_url = server_url
        self.session_id = None
        self.connection_status = "disconnected"
    
    def connect(self) -> bool:
        """è¿æ¥åˆ°æœåŠ¡å™¨"""
        try:
            response = urlopen(f"{self.server_url}/connect")
            data = json.loads(response.read())
            self.session_id = data.get('session_id')
            self.connection_status = "connected"
            print(f"å®¢æˆ·ç«¯ '{self.name}' å·²è¿æ¥åˆ°æœåŠ¡å™¨")
            return True
        except Exception as e:
            print(f"è¿æ¥å¤±è´¥: {e}")
            return False
    
    def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        if self.session_id:
            try:
                urlopen(f"{self.server_url}/disconnect/{self.session_id}")
                self.session_id = None
                self.connection_status = "disconnected"
                print(f"å®¢æˆ·ç«¯ '{self.name}' å·²æ–­å¼€è¿æ¥")
            except Exception as e:
                print(f"æ–­å¼€è¿æ¥å¤±è´¥: {e}")
    
    def send_request(self, endpoint: str, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """å‘é€è¯·æ±‚"""
        if self.connection_status != "connected":
            print("å®¢æˆ·ç«¯æœªè¿æ¥")
            return None
        
        try:
            import urllib.request
            import urllib.parse
            
            url = f"{self.server_url}/{endpoint}"
            data_bytes = json.dumps(data).encode('utf-8')
            
            req = urllib.request.Request(url, data=data_bytes, 
                                       headers={'Content-Type': 'application/json'})
            response = urllib.request.urlopen(req)
            
            return json.loads(response.read())
        except Exception as e:
            print(f"è¯·æ±‚å¤±è´¥: {e}")
            return None

class Server:
    """æœåŠ¡å™¨"""
    
    def __init__(self, host: str = "localhost", port: int = 8000):
        self.host = host
        self.port = port
        self.clients = {}
        self.data = {}
        self.server = None
        self.is_running = False
    
    def start(self):
        """å¯åŠ¨æœåŠ¡å™¨"""
        class RequestHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                
                if self.path == '/connect':
                    session_id = f"session_{len(self.server.clients) + 1}"
                    self.server.clients[session_id] = {
                        'connected_at': datetime.now(),
                        'requests': 0
                    }
                    response = {'session_id': session_id}
                elif self.path.startswith('/disconnect/'):
                    session_id = self.path.split('/')[-1]
                    if session_id in self.server.clients:
                        del self.server.clients[session_id]
                    response = {'status': 'disconnected'}
                else:
                    response = {'error': 'Not found'}
                
                self.wfile.write(json.dumps(response).encode())
            
            def do_POST(self):
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                data = json.loads(post_data.decode('utf-8'))
                
                # å¤„ç†è¯·æ±‚
                response = self.server.handle_request(self.path, data)
                self.wfile.write(json.dumps(response).encode())
        
        RequestHandler.server = self
        
        self.server = HTTPServer((self.host, self.port), RequestHandler)
        self.is_running = True
        
        print(f"æœåŠ¡å™¨å¯åŠ¨åœ¨ {self.host}:{self.port}")
        
        # åœ¨æ–°çº¿ç¨‹ä¸­è¿è¡ŒæœåŠ¡å™¨
        server_thread = threading.Thread(target=self.server.serve_forever)
        server_thread.daemon = True
        server_thread.start()
    
    def stop(self):
        """åœæ­¢æœåŠ¡å™¨"""
        if self.server:
            self.server.shutdown()
            self.is_running = False
            print("æœåŠ¡å™¨å·²åœæ­¢")
    
    def handle_request(self, path: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """å¤„ç†è¯·æ±‚"""
        if path == '/api/data':
            # å­˜å‚¨æ•°æ®
            key = data.get('key')
            value = data.get('value')
            if key and value:
                self.data[key] = value
                return {'status': 'success', 'message': 'Data stored'}
        
        elif path == '/api/data/get':
            # è·å–æ•°æ®
            key = data.get('key')
            if key in self.data:
                return {'status': 'success', 'data': self.data[key]}
            else:
                return {'status': 'error', 'message': 'Key not found'}
        
        return {'status': 'error', 'message': 'Invalid endpoint'}

# ä½¿ç”¨ç¤ºä¾‹
# å¯åŠ¨æœåŠ¡å™¨
server = Server()
server.start()

# åˆ›å»ºå®¢æˆ·ç«¯
client1 = Client("å®¢æˆ·ç«¯1", "http://localhost:8000")
client2 = Client("å®¢æˆ·ç«¯2", "http://localhost:8000")

# è¿æ¥å®¢æˆ·ç«¯
client1.connect()
client2.connect()

# å‘é€è¯·æ±‚
client1.send_request("api/data", {"key": "user1", "value": "Alice"})
client2.send_request("api/data", {"key": "user2", "value": "Bob"})

# è·å–æ•°æ®
result1 = client1.send_request("api/data/get", {"key": "user1"})
result2 = client2.send_request("api/data/get", {"key": "user2"})

print("å®¢æˆ·ç«¯1è·å–æ•°æ®:", result1)
print("å®¢æˆ·ç«¯2è·å–æ•°æ®:", result2)

# æ–­å¼€è¿æ¥
client1.disconnect()
client2.disconnect()

# åœæ­¢æœåŠ¡å™¨
server.stop()
```

### 3. å¾®æœåŠ¡æ¶æ„

#### 3.1 å¾®æœåŠ¡æ¶æ„çš„æ•°å­¦å®šä¹‰

å¾®æœåŠ¡æ¶æ„å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$MS = (S_{micro}, I_{api}, D_{data}, O_{orchestration})$$

å…¶ä¸­ï¼š
- $S_{micro}$ æ˜¯å¾®æœåŠ¡é›†åˆ
- $I_{api}$ æ˜¯APIæ¥å£é›†åˆ
- $D_{data}$ æ˜¯æ•°æ®åˆ†å¸ƒå…³ç³»
- $O_{orchestration}$ æ˜¯ç¼–æ’å‡½æ•°

#### 3.2 å¾®æœåŠ¡æ¶æ„çš„Pythonå®ç°

```python
@dataclass
class Microservice:
    """å¾®æœåŠ¡"""
    name: str
    version: str
    endpoints: List[str]
    dependencies: List[str]
    database: Optional[str] = None
    status: str = "stopped"
    health_score: float = 1.0

@dataclass
class APIEndpoint:
    """APIç«¯ç‚¹"""
    path: str
    method: str
    service: str
    description: str
    response_time: float = 0.0

class MicroserviceArchitecture:
    """å¾®æœåŠ¡æ¶æ„"""
    
    def __init__(self, name: str):
        self.name = name
        self.services: Dict[str, Microservice] = {}
        self.endpoints: List[APIEndpoint] = []
        self.service_registry: Dict[str, str] = {}  # service -> url
        self.circuit_breakers: Dict[str, bool] = {}  # service -> circuit_open
        
        # å¾®æœåŠ¡æŒ‡æ ‡
        self.metrics = {
            'total_services': 0,
            'running_services': 0,
            'total_endpoints': 0,
            'average_response_time': 0.0,
            'service_dependencies': {}
        }
    
    def register_service(self, service: Microservice, url: str):
        """æ³¨å†Œå¾®æœåŠ¡"""
        self.services[service.name] = service
        self.service_registry[service.name] = url
        self.circuit_breakers[service.name] = False
        self.metrics['total_services'] += 1
        
        # æ·»åŠ ç«¯ç‚¹
        for endpoint in service.endpoints:
            api_endpoint = APIEndpoint(
                path=endpoint,
                method="GET",
                service=service.name,
                description=f"{service.name} endpoint"
            )
            self.endpoints.append(api_endpoint)
            self.metrics['total_endpoints'] += 1
        
        print(f"å¾®æœåŠ¡ '{service.name}' å·²æ³¨å†Œ")
    
    def start_service(self, service_name: str):
        """å¯åŠ¨å¾®æœåŠ¡"""
        if service_name in self.services:
            self.services[service_name].status = "running"
            self.metrics['running_services'] += 1
            print(f"å¾®æœåŠ¡ '{service_name}' å·²å¯åŠ¨")
    
    def stop_service(self, service_name: str):
        """åœæ­¢å¾®æœåŠ¡"""
        if service_name in self.services:
            self.services[service_name].status = "stopped"
            self.metrics['running_services'] -= 1
            print(f"å¾®æœåŠ¡ '{service_name}' å·²åœæ­¢")
    
    def call_service(self, service_name: str, endpoint: str, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """è°ƒç”¨å¾®æœåŠ¡"""
        if service_name not in self.services:
            print(f"å¾®æœåŠ¡ '{service_name}' ä¸å­˜åœ¨")
            return None
        
        service = self.services[service_name]
        if service.status != "running":
            print(f"å¾®æœåŠ¡ '{service_name}' æœªè¿è¡Œ")
            return None
        
        if self.circuit_breakers[service_name]:
            print(f"å¾®æœåŠ¡ '{service_name}' æ–­è·¯å™¨å·²æ‰“å¼€")
            return None
        
        # æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
        import time
        start_time = time.time()
        
        try:
            # è¿™é‡Œåº”è¯¥æ˜¯å®é™…çš„HTTPè°ƒç”¨
            # ç®€åŒ–å®ç°ï¼šæ¨¡æ‹Ÿå“åº”
            response = {
                'service': service_name,
                'endpoint': endpoint,
                'data': data,
                'timestamp': datetime.now().isoformat()
            }
            
            response_time = time.time() - start_time
            
            # æ›´æ–°ç«¯ç‚¹å“åº”æ—¶é—´
            for ep in self.endpoints:
                if ep.service == service_name and ep.path == endpoint:
                    ep.response_time = response_time
                    break
            
            # æ›´æ–°å¥åº·åˆ†æ•°
            if response_time > 1.0:  # å“åº”æ—¶é—´è¶…è¿‡1ç§’
                service.health_score = max(0.0, service.health_score - 0.1)
                if service.health_score < 0.3:
                    self.circuit_breakers[service_name] = True
                    print(f"å¾®æœåŠ¡ '{service_name}' æ–­è·¯å™¨å·²æ‰“å¼€")
            
            return response
            
        except Exception as e:
            print(f"è°ƒç”¨å¾®æœåŠ¡ '{service_name}' å¤±è´¥: {e}")
            service.health_score = max(0.0, service.health_score - 0.2)
            return None
    
    def get_service_dependencies(self) -> Dict[str, List[str]]:
        """è·å–æœåŠ¡ä¾èµ–å…³ç³»"""
        dependencies = {}
        for service_name, service in self.services.items():
            dependencies[service_name] = service.dependencies
        return dependencies
    
    def analyze_architecture(self) -> Dict[str, Any]:
        """åˆ†æå¾®æœåŠ¡æ¶æ„"""
        analysis = {
            'service_count': self.metrics['total_services'],
            'running_services': self.metrics['running_services'],
            'endpoint_count': self.metrics['total_endpoints'],
            'average_health_score': 0.0,
            'circuit_breakers_open': 0,
            'service_communication': {}
        }
        
        # è®¡ç®—å¹³å‡å¥åº·åˆ†æ•°
        if self.services:
            total_health = sum(service.health_score for service in self.services.values())
            analysis['average_health_score'] = total_health / len(self.services)
        
        # è®¡ç®—æ–­è·¯å™¨çŠ¶æ€
        analysis['circuit_breakers_open'] = sum(1 for open in self.circuit_breakers.values() if open)
        
        # åˆ†ææœåŠ¡é—´é€šä¿¡
        dependencies = self.get_service_dependencies()
        for service, deps in dependencies.items():
            analysis['service_communication'][service] = {
                'dependencies': deps,
                'dependency_count': len(deps)
            }
        
        return analysis
    
    def generate_service_mesh(self) -> str:
        """ç”ŸæˆæœåŠ¡ç½‘æ ¼å›¾"""
        mesh = f"å¾®æœåŠ¡ç½‘æ ¼: {self.name}\n"
        mesh += "=" * 40 + "\n\n"
        
        for service_name, service in self.services.items():
            mesh += f"æœåŠ¡: {service_name} (v{service.version})\n"
            mesh += f"  çŠ¶æ€: {service.status}\n"
            mesh += f"  å¥åº·åˆ†æ•°: {service.health_score:.2f}\n"
            mesh += f"  ç«¯ç‚¹: {service.endpoints}\n"
            mesh += f"  ä¾èµ–: {service.dependencies}\n"
            if service.database:
                mesh += f"  æ•°æ®åº“: {service.database}\n"
            mesh += "\n"
        
        return mesh

# ä½¿ç”¨ç¤ºä¾‹
# åˆ›å»ºå¾®æœåŠ¡æ¶æ„
ms_arch = MicroserviceArchitecture("ç”µå•†å¾®æœåŠ¡")

# åˆ›å»ºå¾®æœåŠ¡
user_service = Microservice(
    name="user-service",
    version="1.0.0",
    endpoints=["/users", "/users/{id}", "/users/register"],
    dependencies=[],
    database="user_db"
)

product_service = Microservice(
    name="product-service", 
    version="1.0.0",
    endpoints=["/products", "/products/{id}", "/products/search"],
    dependencies=[],
    database="product_db"
)

order_service = Microservice(
    name="order-service",
    version="1.0.0", 
    endpoints=["/orders", "/orders/{id}", "/orders/create"],
    dependencies=["user-service", "product-service"],
    database="order_db"
)

# æ³¨å†Œå¾®æœåŠ¡
ms_arch.register_service(user_service, "http://user-service:8080")
ms_arch.register_service(product_service, "http://product-service:8081")
ms_arch.register_service(order_service, "http://order-service:8082")

# å¯åŠ¨æœåŠ¡
ms_arch.start_service("user-service")
ms_arch.start_service("product-service")
ms_arch.start_service("order-service")

# è°ƒç”¨æœåŠ¡
user_response = ms_arch.call_service("user-service", "/users", {"action": "list"})
product_response = ms_arch.call_service("product-service", "/products", {"action": "list"})
order_response = ms_arch.call_service("order-service", "/orders/create", {
    "user_id": 1,
    "product_id": 2,
    "quantity": 1
})

print("ç”¨æˆ·æœåŠ¡å“åº”:", user_response)
print("äº§å“æœåŠ¡å“åº”:", product_response)
print("è®¢å•æœåŠ¡å“åº”:", order_response)

# åˆ†ææ¶æ„
analysis = ms_arch.analyze_architecture()
print("å¾®æœåŠ¡æ¶æ„åˆ†æ:", analysis)

# ç”ŸæˆæœåŠ¡ç½‘æ ¼
mesh = ms_arch.generate_service_mesh()
print(mesh)
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. Webæ¶æ„å¯æ‰©å±•æ€§å®šç†

**å®šç†**: åˆ†å±‚Webæ¶æ„çš„å¯æ‰©å±•æ€§ä¸å±‚é—´è€¦åˆåº¦æˆåæ¯”ã€‚

**è¯æ˜**: é€šè¿‡å›¾è®ºä¸­çš„è¿é€šæ€§åˆ†æï¼Œè¯æ˜ä½è€¦åˆåº¦å…è®¸ç‹¬ç«‹æ‰©å±•å„å±‚ã€‚

### 2. å¾®æœåŠ¡å®¹é”™æ€§å®šç†

**å®šç†**: å¾®æœåŠ¡æ¶æ„çš„å®¹é”™æ€§éšæœåŠ¡æ•°é‡çš„å¢åŠ è€Œæé«˜ã€‚

**è¯æ˜**: åŸºäºæ¦‚ç‡è®ºï¼Œè¯æ˜å•ä¸ªæœåŠ¡æ•…éšœå¯¹æ•´ä½“ç³»ç»Ÿçš„å½±å“éšæœåŠ¡æ•°é‡å¢åŠ è€Œå‡å°ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. Webåº”ç”¨æ¡†æ¶

```python
class WebFramework:
    """Webåº”ç”¨æ¡†æ¶"""
    
    def __init__(self, name: str):
        self.name = name
        self.routes = {}
        self.middleware = []
        self.templates = {}
        self.static_files = {}
    
    def route(self, path: str, methods: List[str] = None):
        """è·¯ç”±è£…é¥°å™¨"""
        if methods is None:
            methods = ["GET"]
        
        def decorator(func):
            for method in methods:
                key = f"{method}:{path}"
                self.routes[key] = func
            return func
        return decorator
    
    def add_middleware(self, middleware_func):
        """æ·»åŠ ä¸­é—´ä»¶"""
        self.middleware.append(middleware_func)
    
    def add_template(self, name: str, template: str):
        """æ·»åŠ æ¨¡æ¿"""
        self.templates[name] = template
    
    def render_template(self, name: str, context: Dict[str, Any]) -> str:
        """æ¸²æŸ“æ¨¡æ¿"""
        if name not in self.templates:
            return f"Template '{name}' not found"
        
        template = self.templates[name]
        for key, value in context.items():
            template = template.replace(f"{{{{{key}}}}}", str(value))
        
        return template

# ä½¿ç”¨ç¤ºä¾‹
app = WebFramework("MyWebApp")

@app.route("/")
def home():
    return "Hello, World!"

@app.route("/users", ["GET", "POST"])
def users():
    return "Users page"

# æ·»åŠ æ¨¡æ¿
app.add_template("user_list", """
<html>
<head><title>ç”¨æˆ·åˆ—è¡¨</title></head>
<body>
    <h1>ç”¨æˆ·åˆ—è¡¨</h1>
    <ul>
        {% for user in users %}
        <li>{{user.name}} - {{user.email}}</li>
        {% endfor %}
    </ul>
</body>
</html>
""")

# æ¸²æŸ“æ¨¡æ¿
context = {
    "users": [
        {"name": "Alice", "email": "alice@example.com"},
        {"name": "Bob", "email": "bob@example.com"}
    ]
}

rendered = app.render_template("user_list", context)
print(rendered)
```

### 2. APIç½‘å…³

```python
class APIGateway:
    """APIç½‘å…³"""
    
    def __init__(self):
        self.routes = {}
        self.rate_limits = {}
        self.authentication = {}
    
    def add_route(self, path: str, service: str, rate_limit: int = 100):
        """æ·»åŠ è·¯ç”±"""
        self.routes[path] = service
        self.rate_limits[path] = rate_limit
    
    def route_request(self, path: str, method: str, headers: Dict[str, str], 
                     data: Dict[str, Any]) -> Dict[str, Any]:
        """è·¯ç”±è¯·æ±‚"""
        if path not in self.routes:
            return {"error": "Route not found"}
        
        service = self.routes[path]
        
        # æ£€æŸ¥é€Ÿç‡é™åˆ¶
        if not self._check_rate_limit(path):
            return {"error": "Rate limit exceeded"}
        
        # æ£€æŸ¥è®¤è¯
        if not self._check_authentication(path, headers):
            return {"error": "Authentication required"}
        
        # è½¬å‘è¯·æ±‚åˆ°æœåŠ¡
        return self._forward_request(service, path, method, data)
    
    def _check_rate_limit(self, path: str) -> bool:
        """æ£€æŸ¥é€Ÿç‡é™åˆ¶"""
        # ç®€åŒ–å®ç°
        return True
    
    def _check_authentication(self, path: str, headers: Dict[str, str]) -> bool:
        """æ£€æŸ¥è®¤è¯"""
        # ç®€åŒ–å®ç°
        return True
    
    def _forward_request(self, service: str, path: str, method: str, 
                        data: Dict[str, Any]) -> Dict[str, Any]:
        """è½¬å‘è¯·æ±‚"""
        # æ¨¡æ‹Ÿè¯·æ±‚è½¬å‘
        return {
            "service": service,
            "path": path,
            "method": method,
            "data": data,
            "timestamp": datetime.now().isoformat()
        }

# ä½¿ç”¨ç¤ºä¾‹
gateway = APIGateway()

# æ·»åŠ è·¯ç”±
gateway.add_route("/api/users", "user-service", 100)
gateway.add_route("/api/products", "product-service", 200)
gateway.add_route("/api/orders", "order-service", 50)

# è·¯ç”±è¯·æ±‚
response1 = gateway.route_request("/api/users", "GET", {}, {})
response2 = gateway.route_request("/api/products", "POST", {}, {"name": "Product"})

print("ç”¨æˆ·APIå“åº”:", response1)
print("äº§å“APIå“åº”:", response2)
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [Webå¼€å‘æ¦‚è¿°](../README.md)
- [å‰ç«¯æŠ€æœ¯æ ˆ](04-01-02-å‰ç«¯æŠ€æœ¯æ ˆ.md)
- [åç«¯æŠ€æœ¯æ ˆ](04-01-03-åç«¯æŠ€æœ¯æ ˆ.md)
- [æ¶æ„é¢†åŸŸ](../05-æ¶æ„é¢†åŸŸ/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Fielding, R. T. (2000). Architectural Styles and the Design of Network-based Software Architectures. UC Irvine.
2. Newman, S. (2021). Building Microservices. O'Reilly Media.
3. Fowler, M. (2018). Microservices. Martin Fowler.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚* 