# 社交媒体领域架构设计

## 1. 概述

### 1.1 领域定义

**定义 1.1.1 (社交媒体系统)**
社交媒体系统是一个支持用户创建、分享、传播和交互内容的数字平台，具有以下特征：

1. **用户网络**：$G = (V, E)$ 其中 $V$ 是用户集合，$E$ 是社交关系集合
2. **内容流**：$C = \{c_1, c_2, ..., c_n\}$ 内容集合
3. **交互矩阵**：$I_{ij}$ 表示用户 $i$ 对内容 $j$ 的交互强度

### 1.2 核心挑战

**定理 1.1.1 (社交媒体复杂度定理)**
社交媒体系统的复杂度与用户数量、内容数量和交互频率呈指数关系：

$$\text{Complexity}(S) = O(|V| \times |C| \times |E|)$$

*证明*：考虑每个用户可能对每个内容产生交互，且社交关系影响内容传播，复杂度为三者乘积。

## 2. 架构模式

### 2.1 微服务架构

**定义 2.1.1 (社交媒体微服务)**
社交媒体系统采用微服务架构，包含以下核心服务：

```python
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import asyncio
import uuid

@dataclass
class User:
    """用户实体"""
    id: str
    username: str
    email: str
    profile: Dict[str, Any]
    followers: List[str]
    following: List[str]
    created_at: datetime

@dataclass
class Content:
    """内容实体"""
    id: str
    author_id: str
    content_type: str  # post, story, video, etc.
    content: str
    media_urls: List[str]
    hashtags: List[str]
    likes: int
    shares: int
    comments: int
    created_at: datetime

class SocialMediaService:
    """社交媒体核心服务"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.contents: Dict[str, Content] = {}
        self.follow_graph: Dict[str, List[str]] = {}
    
    async def create_user(self, username: str, email: str, profile: Dict[str, Any]) -> User:
        """创建用户"""
        user_id = str(uuid.uuid4())
        user = User(
            id=user_id,
            username=username,
            email=email,
            profile=profile,
            followers=[],
            following=[],
            created_at=datetime.now()
        )
        self.users[user_id] = user
        self.follow_graph[user_id] = []
        return user
    
    async def follow_user(self, follower_id: str, followee_id: str) -> bool:
        """关注用户"""
        if follower_id not in self.users or followee_id not in self.users:
            return False
        
        if followee_id not in self.users[follower_id].following:
            self.users[follower_id].following.append(followee_id)
            self.users[followee_id].followers.append(follower_id)
            self.follow_graph[follower_id].append(followee_id)
        
        return True
    
    async def create_content(self, author_id: str, content_type: str, 
                           content: str, media_urls: List[str] = None) -> Content:
        """创建内容"""
        if author_id not in self.users:
            raise ValueError("User not found")
        
        content_id = str(uuid.uuid4())
        post = Content(
            id=content_id,
            author_id=author_id,
            content_type=content_type,
            content=content,
            media_urls=media_urls or [],
            hashtags=self._extract_hashtags(content),
            likes=0,
            shares=0,
            comments=0,
            created_at=datetime.now()
        )
        self.contents[content_id] = post
        return post
    
    def _extract_hashtags(self, content: str) -> List[str]:
        """提取话题标签"""
        import re
        return re.findall(r'#\w+', content)
```

### 2.2 推荐系统架构

**定义 2.2.1 (推荐算法)**
推荐算法基于用户行为和历史数据，计算用户对内容的偏好：

$$P(u, c) = \alpha \cdot \text{ContentSim}(u, c) + \beta \cdot \text{SocialSim}(u, c) + \gamma \cdot \text{TemporalSim}(u, c)$$

```python
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from collections import defaultdict

class RecommendationEngine:
    """推荐引擎"""
    
    def __init__(self):
        self.user_features: Dict[str, np.ndarray] = {}
        self.content_features: Dict[str, np.ndarray] = {}
        self.user_interactions: Dict[str, Dict[str, float]] = defaultdict(dict)
    
    def update_user_features(self, user_id: str, features: np.ndarray):
        """更新用户特征"""
        self.user_features[user_id] = features
    
    def update_content_features(self, content_id: str, features: np.ndarray):
        """更新内容特征"""
        self.content_features[content_id] = features
    
    def record_interaction(self, user_id: str, content_id: str, interaction_type: str):
        """记录用户交互"""
        weights = {
            'view': 1.0,
            'like': 2.0,
            'share': 3.0,
            'comment': 2.5
        }
        weight = weights.get(interaction_type, 1.0)
        self.user_interactions[user_id][content_id] = weight
    
    def calculate_content_similarity(self, user_id: str, content_id: str) -> float:
        """计算内容相似度"""
        if user_id not in self.user_features or content_id not in self.content_features:
            return 0.0
        
        user_vec = self.user_features[user_id].reshape(1, -1)
        content_vec = self.content_features[content_id].reshape(1, -1)
        return cosine_similarity(user_vec, content_vec)[0][0]
    
    def recommend_content(self, user_id: str, content_candidates: List[str], k: int = 10) -> List[str]:
        """推荐内容"""
        scores = []
        
        for content_id in content_candidates:
            content_sim = self.calculate_content_similarity(user_id, content_id)
            scores.append((content_id, content_sim))
        
        # 排序并返回top-k
        scores.sort(key=lambda x: x[1], reverse=True)
        return [content_id for content_id, _ in scores[:k]]
```

## 3. 实时通信系统

### 3.1 WebSocket架构

**定义 3.1.1 (实时通信模型)**
实时通信系统基于WebSocket协议，支持消息的实时推送：

```python
import asyncio
import json
from typing import Dict, Set, Any
from websockets.server import serve, WebSocketServerProtocol

class RealTimeCommunicationSystem:
    """实时通信系统"""
    
    def __init__(self):
        self.connections: Dict[str, WebSocketServerProtocol] = {}
        self.user_rooms: Dict[str, Set[str]] = defaultdict(set)
        self.room_users: Dict[str, Set[str]] = defaultdict(set)
    
    async def handle_connection(self, websocket: WebSocketServerProtocol, path: str):
        """处理WebSocket连接"""
        user_id = None
        try:
            # 等待用户认证
            auth_message = await websocket.recv()
            auth_data = json.loads(auth_message)
            user_id = auth_data.get('user_id')
            
            if not user_id:
                await websocket.close(1008, "Authentication required")
                return
            
            # 注册连接
            self.connections[user_id] = websocket
            
            # 处理消息
            async for message in websocket:
                await self.handle_message(user_id, message)
                
        except Exception as e:
            print(f"Connection error: {e}")
        finally:
            if user_id:
                await self.cleanup_user(user_id)
    
    async def handle_message(self, user_id: str, message: str):
        """处理用户消息"""
        try:
            data = json.loads(message)
            message_type = data.get('type')
            
            if message_type == 'chat_message':
                room_id = data.get('room_id')
                content = data.get('content')
                await self.broadcast_to_room(room_id, {
                    'type': 'chat_message',
                    'user_id': user_id,
                    'content': content,
                    'timestamp': datetime.now().isoformat()
                })
                
        except json.JSONDecodeError:
            await self.send_to_user(user_id, {
                'type': 'error',
                'message': 'Invalid JSON format'
            })
    
    async def broadcast_to_room(self, room_id: str, message: Dict[str, Any]):
        """向房间广播消息"""
        if room_id not in self.room_users:
            return
        
        message_json = json.dumps(message)
        tasks = []
        
        for user_id in self.room_users[room_id]:
            if user_id in self.connections:
                tasks.append(self.send_to_user(user_id, message))
        
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
    
    async def send_to_user(self, user_id: str, message: Dict[str, Any]):
        """向用户发送消息"""
        if user_id not in self.connections:
            return
        
        try:
            message_json = json.dumps(message)
            await self.connections[user_id].send(message_json)
        except Exception as e:
            print(f"Failed to send message to {user_id}: {e}")
            await self.cleanup_user(user_id)
    
    async def cleanup_user(self, user_id: str):
        """清理用户连接"""
        self.connections.pop(user_id, None)
```

## 4. 内容审核系统

### 4.1 自动审核算法

**定义 4.1.1 (内容审核模型)**
内容审核系统基于机器学习和规则引擎，自动检测违规内容：

```python
import re
from typing import List, Dict, Tuple
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
import numpy as np

class ContentModerationSystem:
    """内容审核系统"""
    
    def __init__(self):
        self.spam_keywords = set([
            'buy now', 'click here', 'free money', 'get rich quick',
            'limited time', 'act now', 'no obligation'
        ])
        
        self.toxic_patterns = [
            r'\b(spam|scam|fake)\b',
            r'\b(hate|racist|discriminatory)\b',
            r'\b(violence|threat|kill)\b'
        ]
        
        self.classifier = RandomForestClassifier(n_estimators=100)
        self.vectorizer = TfidfVectorizer(max_features=1000)
        self.is_trained = False
    
    def check_spam(self, content: str) -> Tuple[bool, float]:
        """检查垃圾内容"""
        content_lower = content.lower()
        
        # 关键词匹配
        keyword_score = sum(1 for keyword in self.spam_keywords if keyword in content_lower)
        keyword_ratio = keyword_score / len(self.spam_keywords)
        
        # 链接密度
        link_count = len(re.findall(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', content))
        link_density = link_count / max(len(content.split()), 1)
        
        # 综合评分
        spam_score = (keyword_ratio * 0.4 + link_density * 0.3)
        is_spam = spam_score > 0.5
        
        return is_spam, spam_score
    
    def check_toxic_content(self, content: str) -> Tuple[bool, Dict[str, float]]:
        """检查有害内容"""
        content_lower = content.lower()
        
        toxicity_scores = {}
        
        # 模式匹配
        for pattern in self.toxic_patterns:
            matches = re.findall(pattern, content_lower)
            toxicity_scores[pattern] = len(matches) / max(len(content.split()), 1)
        
        # 综合判断
        max_score = max(toxicity_scores.values()) if toxicity_scores else 0
        is_toxic = max_score > 0.3
        
        return is_toxic, toxicity_scores
    
    def moderate_content(self, content: str) -> Dict[str, Any]:
        """综合内容审核"""
        results = {
            'content_id': str(uuid.uuid4()),
            'is_approved': True,
            'reasons': [],
            'scores': {}
        }
        
        # 检查垃圾内容
        is_spam, spam_score = self.check_spam(content)
        results['scores']['spam'] = spam_score
        
        if is_spam:
            results['is_approved'] = False
            results['reasons'].append('spam')
        
        # 检查有害内容
        is_toxic, toxic_scores = self.check_toxic_content(content)
        results['scores']['toxic'] = toxic_scores
        
        if is_toxic:
            results['is_approved'] = False
            results['reasons'].append('toxic')
        
        return results
```

## 5. 性能优化

### 5.1 缓存策略

**定义 5.1.1 (缓存层次)**
社交媒体系统采用多层缓存策略：

```python
import redis
import pickle
from typing import Optional, Any
from functools import wraps

class CacheManager:
    """缓存管理器"""
    
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        self.local_cache = {}
        self.cache_stats = {'hits': 0, 'misses': 0}
    
    def cache_decorator(self, ttl: int = 300):
        """缓存装饰器"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                # 生成缓存键
                cache_key = f"{func.__name__}:{hash(str(args) + str(kwargs))}"
                
                # 尝试从缓存获取
                cached_result = await self.get(cache_key)
                if cached_result is not None:
                    self.cache_stats['hits'] += 1
                    return cached_result
                
                # 执行函数
                result = await func(*args, **kwargs)
                
                # 存储到缓存
                await self.set(cache_key, result, ttl)
                self.cache_stats['misses'] += 1
                
                return result
            return wrapper
        return decorator
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        # 先检查本地缓存
        if key in self.local_cache:
            return self.local_cache[key]
        
        # 检查Redis缓存
        try:
            value = self.redis_client.get(key)
            if value:
                result = pickle.loads(value)
                self.local_cache[key] = result
                return result
        except Exception as e:
            print(f"Redis get error: {e}")
        
        return None
    
    async def set(self, key: str, value: Any, ttl: int = 300):
        """设置缓存值"""
        # 设置本地缓存
        self.local_cache[key] = value
        
        # 设置Redis缓存
        try:
            serialized_value = pickle.dumps(value)
            self.redis_client.setex(key, ttl, serialized_value)
        except Exception as e:
            print(f"Redis set error: {e}")
```

## 6. 安全机制

### 6.1 用户认证与授权

**定义 6.1.1 (认证模型)**
社交媒体系统采用JWT令牌和OAuth2.0进行用户认证：

```python
import jwt
import bcrypt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

class AuthenticationSystem:
    """认证系统"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.token_blacklist = set()
    
    def hash_password(self, password: str) -> str:
        """哈希密码"""
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    def verify_password(self, password: str, hashed: str) -> bool:
        """验证密码"""
        return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))
    
    def generate_token(self, user_id: str, expires_in: int = 3600) -> str:
        """生成JWT令牌"""
        payload = {
            'user_id': user_id,
            'exp': datetime.utcnow() + timedelta(seconds=expires_in),
            'iat': datetime.utcnow()
        }
        return jwt.encode(payload, self.secret_key, algorithm='HS256')
    
    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:
        """验证JWT令牌"""
        try:
            if token in self.token_blacklist:
                return None
            
            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])
            return payload
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
```

## 7. 总结

社交媒体领域架构设计涵盖了从用户管理到内容分发的完整技术栈。通过微服务架构、实时通信、推荐系统、内容审核等核心组件，构建了可扩展、高性能的社交媒体平台。

关键成功因素包括：
1. **可扩展性**：通过分片和缓存支持大规模用户
2. **实时性**：WebSocket和消息队列确保实时交互
3. **个性化**：推荐算法提供个性化内容
4. **安全性**：多层安全机制保护用户隐私
5. **监控性**：全面的监控和分析系统

---

*本文档提供了社交媒体领域的完整架构设计，包含数学形式化定义、Python代码实现和最佳实践指导。* 