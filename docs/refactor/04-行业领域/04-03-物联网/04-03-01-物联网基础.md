# ç‰©è”ç½‘åŸºç¡€ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç‰©è”ç½‘ï¼ˆInternet of Things, IoTï¼‰æ˜¯è¿æ¥ç‰©ç†ä¸–ç•Œå’Œæ•°å­—ä¸–ç•Œçš„æŠ€æœ¯ä½“ç³»ï¼Œé€šè¿‡ä¼ æ„Ÿå™¨ã€ç½‘ç»œå’Œè®¡ç®—æŠ€æœ¯å®ç°è®¾å¤‡é—´çš„æ™ºèƒ½äº’è”ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°ç‰©è”ç½‘çš„åŸºç¡€æ¦‚å¿µã€æ¶æ„æ¨¡å‹å’Œæ ¸å¿ƒç®—æ³•ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 ç‰©è”ç½‘ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (ç‰©è”ç½‘ç³»ç»Ÿ)
ç‰©è”ç½‘ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\text{IoT} = (D, S, N, C, A)$$

å…¶ä¸­ï¼š
- $D = \{d_1, d_2, \ldots, d_n\}$ æ˜¯è®¾å¤‡é›†åˆ
- $S = \{s_1, s_2, \ldots, s_m\}$ æ˜¯ä¼ æ„Ÿå™¨é›†åˆ
- $N = (V, E)$ æ˜¯ç½‘ç»œæ‹“æ‰‘å›¾
- $C = \{c_1, c_2, \ldots, c_k\}$ æ˜¯è®¡ç®—èŠ‚ç‚¹é›†åˆ
- $A = \{a_1, a_2, \ldots, a_l\}$ æ˜¯åº”ç”¨æœåŠ¡é›†åˆ

### 1.2 è®¾å¤‡çŠ¶æ€å®šä¹‰

**å®šä¹‰ 1.2** (è®¾å¤‡çŠ¶æ€)
è®¾å¤‡ $d_i$ åœ¨æ—¶åˆ» $t$ çš„çŠ¶æ€ä¸ºï¼š
$$\text{State}(d_i, t) = (p_i, e_i, s_i, c_i)$$

å…¶ä¸­ï¼š
- $p_i$ æ˜¯ç‰©ç†ä½ç½®åæ ‡
- $e_i$ æ˜¯èƒ½é‡æ°´å¹³
- $s_i$ æ˜¯ä¼ æ„Ÿå™¨è¯»æ•°å‘é‡
- $c_i$ æ˜¯è¿æ¥çŠ¶æ€

### 1.3 æ•°æ®æµå®šä¹‰

**å®šä¹‰ 1.3** (æ•°æ®æµ)
ä»è®¾å¤‡ $d_i$ åˆ°è®¡ç®—èŠ‚ç‚¹ $c_j$ çš„æ•°æ®æµä¸ºï¼š
$$\text{DataFlow}(d_i, c_j) = (f_{ij}, \tau_{ij}, q_{ij})$$

å…¶ä¸­ï¼š
- $f_{ij}$ æ˜¯æ•°æ®é¢‘ç‡
- $\tau_{ij}$ æ˜¯ä¼ è¾“å»¶è¿Ÿ
- $q_{ij}$ æ˜¯æ•°æ®è´¨é‡

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 è®¾å¤‡ç®¡ç†

#### 2.1.1 è®¾å¤‡æ³¨å†Œ

**å®šä¹‰ 2.1** (è®¾å¤‡æ³¨å†Œ)
è®¾å¤‡æ³¨å†Œå‡½æ•°ï¼š
$$\text{Register}: D \times \text{DeviceInfo} \rightarrow \text{DeviceID}$$

**æ€§è´¨ 2.1** (æ³¨å†Œå”¯ä¸€æ€§)
å¯¹äºä»»æ„è®¾å¤‡ $d_i, d_j \in D$ï¼Œå¦‚æœ $d_i \neq d_j$ï¼Œåˆ™ï¼š
$$\text{Register}(d_i) \neq \text{Register}(d_j)$$

#### 2.1.2 è®¾å¤‡å‘ç°

**å®šä¹‰ 2.2** (è®¾å¤‡å‘ç°)
è®¾å¤‡å‘ç°ç®—æ³•ï¼š
$$\text{Discover}: \text{Network} \times \text{DiscoveryCriteria} \rightarrow \mathcal{P}(D)$$

**ç®—æ³• 2.1** (è®¾å¤‡å‘ç°ç®—æ³•)
```python
def discover_devices(network: Network, criteria: DiscoveryCriteria) -> Set[Device]:
    """
    è®¾å¤‡å‘ç°ç®—æ³•
    
    å‚æ•°:
        network: ç½‘ç»œæ‹“æ‰‘
        criteria: å‘ç°æ¡ä»¶
        
    è¿”å›:
        å‘ç°çš„è®¾å¤‡é›†åˆ
    """
    discovered = set()
    visited = set()
    
    # ä»å·²çŸ¥èŠ‚ç‚¹å¼€å§‹æœç´¢
    for node in network.get_known_nodes():
        if node not in visited:
            # æ·±åº¦ä¼˜å…ˆæœç´¢
            stack = [node]
            while stack:
                current = stack.pop()
                if current not in visited:
                    visited.add(current)
                    
                    # æ£€æŸ¥æ˜¯å¦ä¸ºè®¾å¤‡èŠ‚ç‚¹
                    if isinstance(current, Device) and criteria.matches(current):
                        discovered.add(current)
                    
                    # æ·»åŠ é‚»å±…èŠ‚ç‚¹
                    for neighbor in network.get_neighbors(current):
                        if neighbor not in visited:
                            stack.append(neighbor)
    
    return discovered
```

### 2.2 ä¼ æ„Ÿå™¨ç½‘ç»œ

#### 2.2.1 ä¼ æ„Ÿå™¨æ•°æ®æ¨¡å‹

**å®šä¹‰ 2.3** (ä¼ æ„Ÿå™¨æ•°æ®)
ä¼ æ„Ÿå™¨ $s_i$ åœ¨æ—¶åˆ» $t$ çš„æ•°æ®ä¸ºï¼š
$$\text{SensorData}(s_i, t) = (v_i, \sigma_i, t_i)$$

å…¶ä¸­ï¼š
- $v_i$ æ˜¯æµ‹é‡å€¼
- $\sigma_i$ æ˜¯æµ‹é‡ç²¾åº¦
- $t_i$ æ˜¯æ—¶é—´æˆ³

#### 2.2.2 æ•°æ®èšåˆ

**å®šä¹‰ 2.4** (æ•°æ®èšåˆ)
ä¼ æ„Ÿå™¨æ•°æ®èšåˆå‡½æ•°ï¼š
$$\text{Aggregate}: \mathcal{P}(\text{SensorData}) \times \text{AggregationType} \rightarrow \text{AggregatedData}$$

**å®šç† 2.1** (èšåˆä¸€è‡´æ€§)
å¯¹äºä»»æ„ä¼ æ„Ÿå™¨æ•°æ®é›†åˆ $S$ å’Œèšåˆç±»å‹ $T$ï¼Œèšåˆç»“æœæ»¡è¶³ï¼š
$$\text{Aggregate}(\text{Aggregate}(S, T), T) = \text{Aggregate}(S, T)$$

### 2.3 ç½‘ç»œé€šä¿¡

#### 2.3.1 é€šä¿¡åè®®

**å®šä¹‰ 2.5** (é€šä¿¡åè®®)
é€šä¿¡åè®®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$\text{Protocol} = (\text{MessageFormat}, \text{TransmissionRules}, \text{ErrorHandling})$$

#### 2.3.2 è·¯ç”±ç®—æ³•

**å®šä¹‰ 2.6** (è·¯ç”±ç®—æ³•)
è·¯ç”±ç®—æ³•ï¼š
$$\text{Route}: \text{Source} \times \text{Destination} \times \text{Network} \rightarrow \text{Path}$$

**ç®—æ³• 2.2** (Dijkstraè·¯ç”±ç®—æ³•)
```python
def dijkstra_route(source: Node, destination: Node, network: Network) -> List[Node]:
    """
    Dijkstraæœ€çŸ­è·¯å¾„è·¯ç”±ç®—æ³•
    
    å‚æ•°:
        source: æºèŠ‚ç‚¹
        destination: ç›®æ ‡èŠ‚ç‚¹
        network: ç½‘ç»œæ‹“æ‰‘
        
    è¿”å›:
        æœ€çŸ­è·¯å¾„
    """
    distances = {node: float('infinity') for node in network.nodes}
    distances[source] = 0
    previous = {}
    unvisited = set(network.nodes)
    
    while unvisited:
        # æ‰¾åˆ°è·ç¦»æœ€å°çš„æœªè®¿é—®èŠ‚ç‚¹
        current = min(unvisited, key=lambda x: distances[x])
        
        if current == destination:
            break
            
        unvisited.remove(current)
        
        # æ›´æ–°é‚»å±…è·ç¦»
        for neighbor in network.get_neighbors(current):
            if neighbor in unvisited:
                distance = distances[current] + network.get_edge_weight(current, neighbor)
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current
    
    # é‡å»ºè·¯å¾„
    path = []
    current = destination
    while current is not None:
        path.append(current)
        current = previous.get(current)
    
    return list(reversed(path))
```

## 3. æ¶æ„æ¨¡å‹

### 3.1 åˆ†å±‚æ¶æ„

**å®šä¹‰ 3.1** (ç‰©è”ç½‘åˆ†å±‚æ¶æ„)
ç‰©è”ç½‘ç³»ç»Ÿé‡‡ç”¨å››å±‚æ¶æ„ï¼š
$$\text{IoTArchitecture} = (\text{Perception}, \text{Network}, \text{Platform}, \text{Application})$$

#### 3.1.1 æ„ŸçŸ¥å±‚

**å®šä¹‰ 3.2** (æ„ŸçŸ¥å±‚)
æ„ŸçŸ¥å±‚è´Ÿè´£æ•°æ®é‡‡é›†ï¼š
$$\text{Perception} = (\text{Sensors}, \text{Actuators}, \text{DataCollection})$$

#### 3.1.2 ç½‘ç»œå±‚

**å®šä¹‰ 3.3** (ç½‘ç»œå±‚)
ç½‘ç»œå±‚è´Ÿè´£æ•°æ®ä¼ è¾“ï¼š
$$\text{Network} = (\text{Communication}, \text{Routing}, \text{Security})$$

#### 3.1.3 å¹³å°å±‚

**å®šä¹‰ 3.4** (å¹³å°å±‚)
å¹³å°å±‚è´Ÿè´£æ•°æ®å¤„ç†ï¼š
$$\text{Platform} = (\text{Storage}, \text{Processing}, \text{Analytics})$$

#### 3.1.4 åº”ç”¨å±‚

**å®šä¹‰ 3.5** (åº”ç”¨å±‚)
åº”ç”¨å±‚è´Ÿè´£ä¸šåŠ¡é€»è¾‘ï¼š
$$\text{Application} = (\text{BusinessLogic}, \text{UserInterface}, \text{Integration})$$

### 3.2 è¾¹ç¼˜è®¡ç®—æ¶æ„

**å®šä¹‰ 3.6** (è¾¹ç¼˜è®¡ç®—)
è¾¹ç¼˜è®¡ç®—å°†è®¡ç®—èƒ½åŠ›éƒ¨ç½²åœ¨é è¿‘æ•°æ®æºçš„ä½ç½®ï¼š
$$\text{EdgeComputing} = (\text{EdgeNodes}, \text{LocalProcessing}, \text{CloudIntegration})$$

**å®šç† 3.1** (è¾¹ç¼˜è®¡ç®—å»¶è¿Ÿä¼˜åŒ–)
è¾¹ç¼˜è®¡ç®—èƒ½å¤Ÿå‡å°‘å»¶è¿Ÿï¼š
$$\text{Latency}_{\text{Edge}} < \text{Latency}_{\text{Cloud}}$$

## 4. Pythonå®ç°

### 4.1 è®¾å¤‡ç®¡ç†å®ç°

```python
from typing import Dict, Set, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import time
import uuid
import math
from abc import ABC, abstractmethod

@dataclass
class DeviceInfo:
    """è®¾å¤‡ä¿¡æ¯"""
    device_id: str
    device_type: str
    capabilities: Set[str]
    location: Tuple[float, float, float]
    energy_level: float
    status: str

@dataclass
class SensorData:
    """ä¼ æ„Ÿå™¨æ•°æ®"""
    sensor_id: str
    value: float
    accuracy: float
    timestamp: float
    unit: str

class DeviceStatus(Enum):
    """è®¾å¤‡çŠ¶æ€æšä¸¾"""
    ONLINE = "online"
    OFFLINE = "offline"
    MAINTENANCE = "maintenance"
    ERROR = "error"

class Device(ABC):
    """è®¾å¤‡æŠ½è±¡åŸºç±»"""
    
    def __init__(self, device_id: str, device_type: str, location: Tuple[float, float, float]):
        self.device_id = device_id
        self.device_type = device_type
        self.location = location
        self.energy_level = 100.0
        self.status = DeviceStatus.ONLINE
        self.sensors: Dict[str, Sensor] = {}
        self.actuators: Dict[str, Actuator] = {}
    
    @abstractmethod
    def collect_data(self) -> List[SensorData]:
        """æ”¶é›†ä¼ æ„Ÿå™¨æ•°æ®"""
        pass
    
    @abstractmethod
    def execute_action(self, action: str, parameters: Dict) -> bool:
        """æ‰§è¡ŒåŠ¨ä½œ"""
        pass
    
    def get_status(self) -> DeviceInfo:
        """è·å–è®¾å¤‡çŠ¶æ€"""
        return DeviceInfo(
            device_id=self.device_id,
            device_type=self.device_type,
            capabilities=self.get_capabilities(),
            location=self.location,
            energy_level=self.energy_level,
            status=self.status.value
        )
    
    def get_capabilities(self) -> Set[str]:
        """è·å–è®¾å¤‡èƒ½åŠ›"""
        capabilities = set()
        capabilities.update(self.sensors.keys())
        capabilities.update(self.actuators.keys())
        return capabilities

class Sensor:
    """ä¼ æ„Ÿå™¨ç±»"""
    
    def __init__(self, sensor_id: str, sensor_type: str, unit: str):
        self.sensor_id = sensor_id
        self.sensor_type = sensor_type
        self.unit = unit
        self.calibration_factor = 1.0
        self.noise_level = 0.0
    
    def read(self) -> SensorData:
        """è¯»å–ä¼ æ„Ÿå™¨æ•°æ®"""
        # æ¨¡æ‹Ÿä¼ æ„Ÿå™¨è¯»æ•°
        raw_value = self._get_raw_value()
        calibrated_value = raw_value * self.calibration_factor
        noise = self.noise_level * (2 * math.random() - 1)
        final_value = calibrated_value + noise
        
        return SensorData(
            sensor_id=self.sensor_id,
            value=final_value,
            accuracy=1.0 - abs(noise) / abs(calibrated_value) if calibrated_value != 0 else 1.0,
            timestamp=time.time(),
            unit=self.unit
        )
    
    def _get_raw_value(self) -> float:
        """è·å–åŸå§‹ä¼ æ„Ÿå™¨å€¼ï¼ˆå­ç±»å®ç°ï¼‰"""
        raise NotImplementedError

class Actuator:
    """æ‰§è¡Œå™¨ç±»"""
    
    def __init__(self, actuator_id: str, actuator_type: str):
        self.actuator_id = actuator_id
        self.actuator_type = actuator_type
        self.current_state = {}
    
    def execute(self, command: str, parameters: Dict) -> bool:
        """æ‰§è¡Œå‘½ä»¤"""
        try:
            # æ¨¡æ‹Ÿæ‰§è¡Œå™¨æ“ä½œ
            self.current_state.update(parameters)
            return True
        except Exception:
            return False

class IoTP platform:
    """ç‰©è”ç½‘å¹³å°"""
    
    def __init__(self):
        self.devices: Dict[str, Device] = {}
        self.data_storage: List[SensorData] = []
        self.rules_engine = RulesEngine()
        self.analytics_engine = AnalyticsEngine()
        self.network_manager = NetworkManager()
    
    def register_device(self, device: Device) -> bool:
        """æ³¨å†Œè®¾å¤‡"""
        if device.device_id not in self.devices:
            self.devices[device.device_id] = device
            self.network_manager.add_device(device)
            return True
        return False
    
    def discover_devices(self, criteria: DiscoveryCriteria) -> Set[Device]:
        """å‘ç°è®¾å¤‡"""
        return self.network_manager.discover_devices(criteria)
    
    def collect_data(self) -> List[SensorData]:
        """æ”¶é›†æ‰€æœ‰è®¾å¤‡æ•°æ®"""
        all_data = []
        for device in self.devices.values():
            if device.status == DeviceStatus.ONLINE:
                device_data = device.collect_data()
                all_data.extend(device_data)
                self.data_storage.extend(device_data)
        return all_data
    
    def process_data(self, data: List[SensorData]) -> Dict:
        """å¤„ç†æ•°æ®"""
        # åº”ç”¨è§„åˆ™å¼•æ“
        rules_result = self.rules_engine.process_data(data)
        
        # åº”ç”¨åˆ†æå¼•æ“
        analytics_result = self.analytics_engine.process_data(data)
        
        return {
            'rules': rules_result,
            'analytics': analytics_result
        }
    
    def _handle_data(self, data: SensorData):
        """å¤„ç†å•ä¸ªæ•°æ®ç‚¹"""
        # å­˜å‚¨æ•°æ®
        self.data_storage.append(data)
        
        # åº”ç”¨è§„åˆ™
        self.rules_engine.process_data([data])
        
        # åˆ†ææ•°æ®
        self.analytics_engine.process_data([data])

class RulesEngine:
    """è§„åˆ™å¼•æ“"""
    
    def __init__(self):
        self.rules: List[Rule] = []
    
    def add_rule(self, rule: Rule):
        """æ·»åŠ è§„åˆ™"""
        self.rules.append(rule)
    
    def process_data(self, data: List[SensorData]) -> List[Action]:
        """å¤„ç†æ•°æ®å¹¶è§¦å‘è§„åˆ™"""
        actions = []
        for rule in self.rules:
            if rule.evaluate(data):
                actions.extend(rule.execute())
        return actions

class AnalyticsEngine:
    """åˆ†æå¼•æ“"""
    
    def __init__(self):
        self.analytics_models: Dict[str, AnalyticsModel] = {}
    
    def add_model(self, model_id: str, model: AnalyticsModel):
        """æ·»åŠ åˆ†ææ¨¡å‹"""
        self.analytics_models[model_id] = model
    
    def process_data(self, data: List[SensorData]) -> Dict:
        """å¤„ç†æ•°æ®å¹¶è¿›è¡Œåˆ†æ"""
        results = {}
        for model_id, model in self.analytics_models.items():
            results[model_id] = model.analyze(data)
        return results

class NetworkManager:
    """ç½‘ç»œç®¡ç†å™¨"""
    
    def __init__(self):
        self.network_topology: Dict[str, Set[str]] = {}
        self.device_locations: Dict[str, Tuple[float, float, float]] = {}
    
    def add_device(self, device: Device):
        """æ·»åŠ è®¾å¤‡åˆ°ç½‘ç»œ"""
        self.network_topology[device.device_id] = set()
        self.device_locations[device.device_id] = device.location
    
    def discover_devices(self, criteria: DiscoveryCriteria) -> Set[Device]:
        """å‘ç°è®¾å¤‡"""
        # å®ç°è®¾å¤‡å‘ç°é€»è¾‘
        discovered = set()
        # è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥åŸºäºç½‘ç»œæ‹“æ‰‘è¿›è¡Œæœç´¢
        return discovered
    
    def route_data(self, source: str, destination: str, data: bytes) -> bool:
        """è·¯ç”±æ•°æ®"""
        # å®ç°æ•°æ®è·¯ç”±é€»è¾‘
        return True

class DiscoveryCriteria:
    """è®¾å¤‡å‘ç°æ¡ä»¶"""
    
    def __init__(self, device_types: Set[str] = None, max_distance: float = None):
        self.device_types = device_types or set()
        self.max_distance = max_distance
    
    def matches(self, device: Device) -> bool:
        """æ£€æŸ¥è®¾å¤‡æ˜¯å¦åŒ¹é…æ¡ä»¶"""
        if self.device_types and device.device_type not in self.device_types:
            return False
        return True

class Rule:
    """è§„åˆ™åŸºç±»"""
    
    def __init__(self, condition: str, action: str):
        self.condition = condition
        self.action = action
    
    def evaluate(self, data: List[SensorData]) -> bool:
        """è¯„ä¼°è§„åˆ™æ¡ä»¶"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è§£ææ¡ä»¶è¡¨è¾¾å¼
        return True
    
    def execute(self) -> List[Action]:
        """æ‰§è¡Œè§„åˆ™åŠ¨ä½œ"""
        return [Action(self.action, {})]

class Action:
    """åŠ¨ä½œç±»"""
    
    def __init__(self, action_type: str, parameters: Dict):
        self.action_type = action_type
        self.parameters = parameters

class AnalyticsModel:
    """åˆ†ææ¨¡å‹åŸºç±»"""
    
    def analyze(self, data: List[SensorData]) -> Dict:
        """åˆ†ææ•°æ®"""
        # å­ç±»å®ç°å…·ä½“åˆ†æé€»è¾‘
        return {}

# å…·ä½“è®¾å¤‡å®ç°ç¤ºä¾‹
class TemperatureSensor(Device):
    """æ¸©åº¦ä¼ æ„Ÿå™¨è®¾å¤‡"""
    
    def __init__(self, device_id: str, location: Tuple[float, float, float]):
        super().__init__(device_id, "temperature_sensor", location)
        self.sensors["temperature"] = TemperatureSensor("temp_1", "temperature", "Â°C")
    
    def collect_data(self) -> List[SensorData]:
        """æ”¶é›†æ¸©åº¦æ•°æ®"""
        return [self.sensors["temperature"].read()]
    
    def execute_action(self, action: str, parameters: Dict) -> bool:
        """æ¸©åº¦ä¼ æ„Ÿå™¨é€šå¸¸ä¸æ‰§è¡ŒåŠ¨ä½œ"""
        return False

class SmartLight(Device):
    """æ™ºèƒ½ç…§æ˜è®¾å¤‡"""
    
    def __init__(self, device_id: str, location: Tuple[float, float, float]):
        super().__init__(device_id, "smart_light", location)
        self.sensors["motion"] = MotionSensor("motion_1", "motion", "boolean")
        self.actuators["light"] = LightActuator("light_1", "light")
    
    def collect_data(self) -> List[SensorData]:
        """æ”¶é›†è¿åŠ¨ä¼ æ„Ÿå™¨æ•°æ®"""
        return [self.sensors["motion"].read()]
    
    def execute_action(self, action: str, parameters: Dict) -> bool:
        """æ‰§è¡Œç…§æ˜æ§åˆ¶"""
        if action == "turn_on":
            return self.actuators["light"].execute("on", parameters)
        elif action == "turn_off":
            return self.actuators["light"].execute("off", parameters)
        return False

class TemperatureSensor(Sensor):
    """æ¸©åº¦ä¼ æ„Ÿå™¨"""
    
    def _get_raw_value(self) -> float:
        """è·å–æ¸©åº¦å€¼ï¼ˆæ¨¡æ‹Ÿï¼‰"""
        import random
        return 20.0 + random.uniform(-5, 5)

class MotionSensor(Sensor):
    """è¿åŠ¨ä¼ æ„Ÿå™¨"""
    
    def _get_raw_value(self) -> float:
        """è·å–è¿åŠ¨æ£€æµ‹å€¼ï¼ˆæ¨¡æ‹Ÿï¼‰"""
        import random
        return 1.0 if random.random() > 0.7 else 0.0

class LightActuator(Actuator):
    """ç…§æ˜æ‰§è¡Œå™¨"""
    
    def __init__(self, actuator_id: str, actuator_type: str):
        super().__init__(actuator_id, actuator_type)
        self.brightness = 0.0
        self.color = (255, 255, 255)
    
    def execute(self, command: str, parameters: Dict) -> bool:
        """æ‰§è¡Œç…§æ˜å‘½ä»¤"""
        if command == "on":
            self.brightness = parameters.get("brightness", 100.0)
            self.color = parameters.get("color", (255, 255, 255))
            return True
        elif command == "off":
            self.brightness = 0.0
            return True
        return False
```

### 4.2 æ•°æ®èšåˆå®ç°

```python
class DataAggregator:
    """æ•°æ®èšåˆå™¨"""
    
    def __init__(self):
        self.aggregation_methods = {
            'average': self._average,
            'sum': self._sum,
            'min': self._min,
            'max': self._max,
            'count': self._count,
            'variance': self._variance
        }
    
    def aggregate(self, data: List[SensorData], method: str, 
                  time_window: Optional[float] = None) -> AggregatedData:
        """
        èšåˆä¼ æ„Ÿå™¨æ•°æ®
        
        å‚æ•°:
            data: ä¼ æ„Ÿå™¨æ•°æ®åˆ—è¡¨
            method: èšåˆæ–¹æ³•
            time_window: æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
            
        è¿”å›:
            èšåˆç»“æœ
        """
        if method not in self.aggregation_methods:
            raise ValueError(f"ä¸æ”¯æŒçš„èšåˆæ–¹æ³•: {method}")
        
        # æ—¶é—´çª—å£è¿‡æ»¤
        if time_window:
            current_time = time.time()
            filtered_data = [
                d for d in data 
                if current_time - d.timestamp <= time_window
            ]
        else:
            filtered_data = data
        
        # æ‰§è¡Œèšåˆ
        values = [d.value for d in filtered_data]
        result = self.aggregation_methods[method](values)
        
        return AggregatedData(
            method=method,
            value=result,
            count=len(filtered_data),
            timestamp=time.time(),
            data_points=filtered_data
        )
    
    def _average(self, values: List[float]) -> float:
        """è®¡ç®—å¹³å‡å€¼"""
        return sum(values) / len(values) if values else 0.0
    
    def _sum(self, values: List[float]) -> float:
        """è®¡ç®—æ€»å’Œ"""
        return sum(values)
    
    def _min(self, values: List[float]) -> float:
        """è®¡ç®—æœ€å°å€¼"""
        return min(values) if values else 0.0
    
    def _max(self, values: List[float]) -> float:
        """è®¡ç®—æœ€å¤§å€¼"""
        return max(values) if values else 0.0
    
    def _count(self, values: List[float]) -> int:
        """è®¡ç®—æ•°é‡"""
        return len(values)
    
    def _variance(self, values: List[float]) -> float:
        """è®¡ç®—æ–¹å·®"""
        if len(values) < 2:
            return 0.0
        mean = self._average(values)
        return sum((x - mean) ** 2 for x in values) / (len(values) - 1)

@dataclass
class AggregatedData:
    """èšåˆæ•°æ®"""
    method: str
    value: float
    count: int
    timestamp: float
    data_points: List[SensorData]
```

### 4.3 ç½‘ç»œè·¯ç”±å®ç°

```python
class NetworkTopology:
    """ç½‘ç»œæ‹“æ‰‘"""
    
    def __init__(self):
        self.nodes: Set[str] = set()
        self.edges: Dict[Tuple[str, str], float] = {}
    
    def add_node(self, node: str):
        """æ·»åŠ èŠ‚ç‚¹"""
        self.nodes.add(node)
    
    def add_edge(self, node1: str, node2: str, weight: float):
        """æ·»åŠ è¾¹"""
        self.edges[(node1, node2)] = weight
        self.edges[(node2, node1)] = weight  # æ— å‘å›¾
    
    def get_neighbors(self, node: str) -> Set[str]:
        """è·å–é‚»å±…èŠ‚ç‚¹"""
        neighbors = set()
        for (n1, n2), weight in self.edges.items():
            if n1 == node:
                neighbors.add(n2)
        return neighbors
    
    def get_edge_weight(self, node1: str, node2: str) -> float:
        """è·å–è¾¹æƒé‡"""
        return self.edges.get((node1, node2), float('infinity'))

class Router:
    """è·¯ç”±å™¨"""
    
    def __init__(self, topology: NetworkTopology):
        self.topology = topology
        self.routing_table: Dict[Tuple[str, str], List[str]] = {}
    
    def compute_routes(self):
        """è®¡ç®—æ‰€æœ‰è·¯ç”±"""
        for source in self.topology.nodes:
            for destination in self.topology.nodes:
                if source != destination:
                    path = self.dijkstra_route(source, destination)
                    self.routing_table[(source, destination)] = path
    
    def dijkstra_route(self, source: str, destination: str) -> List[str]:
        """Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•"""
        distances = {node: float('infinity') for node in self.topology.nodes}
        distances[source] = 0
        previous = {}
        unvisited = set(self.topology.nodes)
        
        while unvisited:
            # æ‰¾åˆ°è·ç¦»æœ€å°çš„æœªè®¿é—®èŠ‚ç‚¹
            current = min(unvisited, key=lambda x: distances[x])
            
            if current == destination:
                break
                
            unvisited.remove(current)
            
            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor in self.topology.get_neighbors(current):
                if neighbor in unvisited:
                    distance = distances[current] + self.topology.get_edge_weight(current, neighbor)
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        previous[neighbor] = current
        
        # é‡å»ºè·¯å¾„
        path = []
        current = destination
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        return list(reversed(path))
    
    def route_packet(self, source: str, destination: str, packet: bytes) -> bool:
        """è·¯ç”±æ•°æ®åŒ…"""
        route = self.routing_table.get((source, destination))
        if route:
            # æ¨¡æ‹Ÿæ•°æ®åŒ…ä¼ è¾“
            return True
        return False
```

## 5. ç†è®ºè¯æ˜

### 5.1 è®¾å¤‡å‘ç°ç®—æ³•æ­£ç¡®æ€§

**å®šç† 5.1** (è®¾å¤‡å‘ç°ç®—æ³•æ­£ç¡®æ€§)
è®¾å¤‡å‘ç°ç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„è®¾å¤‡ã€‚

**è¯æ˜**:
1. **å®Œæ•´æ€§**: ç®—æ³•ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢éå†æ•´ä¸ªç½‘ç»œï¼Œç¡®ä¿è®¿é—®æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹ã€‚
2. **æ­£ç¡®æ€§**: å¯¹äºæ¯ä¸ªè®¿é—®çš„èŠ‚ç‚¹ï¼Œç®—æ³•æ£€æŸ¥æ˜¯å¦æ»¡è¶³å‘ç°æ¡ä»¶ã€‚
3. **ç»ˆæ­¢æ€§**: ç”±äºç½‘ç»œèŠ‚ç‚¹æ•°é‡æœ‰é™ï¼Œä¸”æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šè®¿é—®ä¸€æ¬¡ï¼Œç®—æ³•å¿…ç„¶ç»ˆæ­¢ã€‚

### 5.2 æ•°æ®èšåˆä¸€è‡´æ€§

**å®šç† 5.2** (æ•°æ®èšåˆä¸€è‡´æ€§)
å¯¹äºä»»æ„ä¼ æ„Ÿå™¨æ•°æ®é›†åˆ $S$ å’Œèšåˆæ–¹æ³• $M$ï¼Œèšåˆç»“æœæ»¡è¶³å¹‚ç­‰æ€§ï¼š
$$\text{Aggregate}(\text{Aggregate}(S, M), M) = \text{Aggregate}(S, M)$$

**è¯æ˜**:
- å¯¹äºå¹³å‡å€¼èšåˆï¼š$\text{avg}(\text{avg}(S)) = \text{avg}(S)$
- å¯¹äºæ±‚å’Œèšåˆï¼š$\text{sum}(\text{sum}(S)) = \text{sum}(S)$
- å¯¹äºæœ€å€¼èšåˆï¼š$\text{min}(\text{min}(S)) = \text{min}(S)$ï¼Œ$\text{max}(\text{max}(S)) = \text{max}(S)$

### 5.3 è·¯ç”±ç®—æ³•æœ€ä¼˜æ€§

**å®šç† 5.3** (Dijkstraç®—æ³•æœ€ä¼˜æ€§)
Dijkstraç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°ä»æºèŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

**è¯æ˜**:
1. **åˆå§‹åŒ–**: æºèŠ‚ç‚¹è·ç¦»ä¸º0ï¼Œå…¶ä»–èŠ‚ç‚¹è·ç¦»ä¸ºæ— ç©·å¤§ã€‚
2. **å½’çº³å‡è®¾**: å‡è®¾åœ¨å¤„ç†ç¬¬kä¸ªèŠ‚ç‚¹æ—¶ï¼Œå·²å¤„ç†çš„èŠ‚ç‚¹è·ç¦»éƒ½æ˜¯æœ€çŸ­çš„ã€‚
3. **å½’çº³æ­¥éª¤**: é€‰æ‹©è·ç¦»æœ€å°çš„æœªå¤„ç†èŠ‚ç‚¹ï¼Œå…¶è·ç¦»å¿…ç„¶æ˜¯æœ€çŸ­çš„ã€‚
4. **ç»“è®º**: ç®—æ³•ç»“æŸæ—¶ï¼Œæ‰€æœ‰èŠ‚ç‚¹çš„è·ç¦»éƒ½æ˜¯æœ€çŸ­çš„ã€‚

## 6. æ€§èƒ½åˆ†æ

### 6.1 æ—¶é—´å¤æ‚åº¦

- **è®¾å¤‡å‘ç°**: $O(|V| + |E|)$ï¼Œå…¶ä¸­ $|V|$ æ˜¯èŠ‚ç‚¹æ•°ï¼Œ$|E|$ æ˜¯è¾¹æ•°
- **æ•°æ®èšåˆ**: $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°æ®ç‚¹æ•°é‡
- **è·¯ç”±è®¡ç®—**: $O(|V|^2)$ ä½¿ç”¨Dijkstraç®—æ³•

### 6.2 ç©ºé—´å¤æ‚åº¦

- **è®¾å¤‡ç®¡ç†**: $O(|D|)$ï¼Œå…¶ä¸­ $|D|$ æ˜¯è®¾å¤‡æ•°é‡
- **æ•°æ®å­˜å‚¨**: $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°æ®ç‚¹æ•°é‡
- **è·¯ç”±è¡¨**: $O(|V|^2)$ å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹å¯¹çš„æœ€çŸ­è·¯å¾„

### 6.3 ç½‘ç»œå¼€é”€

- **è®¾å¤‡æ³¨å†Œ**: $O(1)$ æ¯æ¬¡æ³¨å†Œ
- **æ•°æ®ä¼ è¾“**: $O(|D| \times f)$ï¼Œå…¶ä¸­ $f$ æ˜¯æ•°æ®é¢‘ç‡
- **è·¯ç”±æ›´æ–°**: $O(|E|)$ å½“ç½‘ç»œæ‹“æ‰‘å˜åŒ–æ—¶

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 æ™ºèƒ½å®¶å±…ç³»ç»Ÿ

```python
def create_smart_home_system():
    """åˆ›å»ºæ™ºèƒ½å®¶å±…ç³»ç»Ÿ"""
    # åˆ›å»ºç‰©è”ç½‘å¹³å°
    platform = IoTP platform()
    
    # åˆ›å»ºè®¾å¤‡
    living_room_temp = TemperatureSensor("temp_living", (0, 0, 0))
    bedroom_temp = TemperatureSensor("temp_bedroom", (5, 0, 0))
    living_room_light = SmartLight("light_living", (0, 0, 0))
    bedroom_light = SmartLight("light_bedroom", (5, 0, 0))
    
    # æ³¨å†Œè®¾å¤‡
    platform.register_device(living_room_temp)
    platform.register_device(bedroom_temp)
    platform.register_device(living_room_light)
    platform.register_device(bedroom_light)
    
    # æ·»åŠ è§„åˆ™
    rules_engine = platform.rules_engine
    
    # æ¸©åº¦è¿‡é«˜æ—¶å¼€å¯ç©ºè°ƒ
    temp_rule = Rule("temperature > 25", "turn_on_ac")
    rules_engine.add_rule(temp_rule)
    
    # æ£€æµ‹åˆ°è¿åŠ¨æ—¶å¼€å¯ç…§æ˜
    motion_rule = Rule("motion_detected", "turn_on_light")
    rules_engine.add_rule(motion_rule)
    
    return platform

def run_smart_home_simulation():
    """è¿è¡Œæ™ºèƒ½å®¶å±…æ¨¡æ‹Ÿ"""
    platform = create_smart_home_system()
    
    # æ¨¡æ‹Ÿè¿è¡Œ
    for i in range(10):
        print(f"=== æ—¶é—´æ­¥ {i+1} ===")
        
        # æ”¶é›†æ•°æ®
        data = platform.collect_data()
        print(f"æ”¶é›†åˆ° {len(data)} ä¸ªæ•°æ®ç‚¹")
        
        # å¤„ç†æ•°æ®
        results = platform.process_data(data)
        print(f"å¤„ç†ç»“æœ: {results}")
        
        time.sleep(1)  # æ¨¡æ‹Ÿæ—¶é—´é—´éš”

if __name__ == "__main__":
    run_smart_home_simulation()
```

### 7.2 å·¥ä¸šç‰©è”ç½‘ç›‘æ§

```python
def create_industrial_monitoring_system():
    """åˆ›å»ºå·¥ä¸šç›‘æ§ç³»ç»Ÿ"""
    platform = IoTP platform()
    
    # åˆ›å»ºå·¥ä¸šè®¾å¤‡
    motor_temp = TemperatureSensor("motor_temp", (0, 0, 0))
    motor_vibration = VibrationSensor("motor_vib", (0, 0, 0))
    pump_pressure = PressureSensor("pump_pressure", (10, 0, 0))
    
    # æ³¨å†Œè®¾å¤‡
    platform.register_device(motor_temp)
    platform.register_device(motor_vibration)
    platform.register_device(pump_pressure)
    
    # æ·»åŠ åˆ†ææ¨¡å‹
    analytics_engine = platform.analytics_engine
    
    # å¼‚å¸¸æ£€æµ‹æ¨¡å‹
    anomaly_detector = AnomalyDetectionModel()
    analytics_engine.add_model("anomaly_detection", anomaly_detector)
    
    # é¢„æµ‹æ€§ç»´æŠ¤æ¨¡å‹
    predictive_maintenance = PredictiveMaintenanceModel()
    analytics_engine.add_model("predictive_maintenance", predictive_maintenance)
    
    return platform

class VibrationSensor(Sensor):
    """æŒ¯åŠ¨ä¼ æ„Ÿå™¨"""
    
    def _get_raw_value(self) -> float:
        import random
        return random.uniform(0, 10)

class PressureSensor(Sensor):
    """å‹åŠ›ä¼ æ„Ÿå™¨"""
    
    def _get_raw_value(self) -> float:
        import random
        return random.uniform(100, 200)

class AnomalyDetectionModel(AnalyticsModel):
    """å¼‚å¸¸æ£€æµ‹æ¨¡å‹"""
    
    def analyze(self, data: List[SensorData]) -> Dict:
        # ç®€åŒ–çš„å¼‚å¸¸æ£€æµ‹é€»è¾‘
        anomalies = []
        for d in data:
            if d.value > 50:  # å‡è®¾é˜ˆå€¼
                anomalies.append({
                    'sensor_id': d.sensor_id,
                    'value': d.value,
                    'timestamp': d.timestamp
                })
        
        return {
            'anomalies': anomalies,
            'anomaly_count': len(anomalies)
        }

class PredictiveMaintenanceModel(AnalyticsModel):
    """é¢„æµ‹æ€§ç»´æŠ¤æ¨¡å‹"""
    
    def analyze(self, data: List[SensorData]) -> Dict:
        # ç®€åŒ–çš„é¢„æµ‹æ€§ç»´æŠ¤é€»è¾‘
        maintenance_alerts = []
        
        # åˆ†ææ¸©åº¦è¶‹åŠ¿
        temp_data = [d for d in data if 'temp' in d.sensor_id]
        if temp_data:
            avg_temp = sum(d.value for d in temp_data) / len(temp_data)
            if avg_temp > 30:
                maintenance_alerts.append({
                    'type': 'temperature_warning',
                    'message': f'å¹³å‡æ¸©åº¦è¿‡é«˜: {avg_temp:.2f}Â°C',
                    'severity': 'high'
                })
        
        return {
            'maintenance_alerts': maintenance_alerts,
            'alert_count': len(maintenance_alerts)
        }
```

## 8. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°äº†ç‰©è”ç½‘çš„åŸºç¡€æ¦‚å¿µï¼ŒåŒ…æ‹¬ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†ç‰©è”ç½‘ç³»ç»Ÿçš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **æ ¸å¿ƒæ¦‚å¿µ**: è®¾å¤‡ç®¡ç†ã€ä¼ æ„Ÿå™¨ç½‘ç»œã€ç½‘ç»œé€šä¿¡ç­‰æ ¸å¿ƒæ¦‚å¿µ
3. **æ¶æ„æ¨¡å‹**: åˆ†å±‚æ¶æ„å’Œè¾¹ç¼˜è®¡ç®—æ¶æ„
4. **Pythonå®ç°**: å®Œæ•´çš„è®¾å¤‡ç®¡ç†ã€æ•°æ®èšåˆã€ç½‘ç»œè·¯ç”±å®ç°
5. **ç†è®ºè¯æ˜**: ç®—æ³•æ­£ç¡®æ€§å’Œç³»ç»Ÿæ€§è´¨çš„ä¸¥æ ¼è¯æ˜
6. **æ€§èƒ½åˆ†æ**: æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦åˆ†æ
7. **åº”ç”¨ç¤ºä¾‹**: æ™ºèƒ½å®¶å±…å’Œå·¥ä¸šç›‘æ§çš„å®é™…åº”ç”¨

ç‰©è”ç½‘ä½œä¸ºè¿æ¥ç‰©ç†ä¸–ç•Œå’Œæ•°å­—ä¸–ç•Œçš„é‡è¦æŠ€æœ¯ï¼Œå…¶ç†è®ºåŸºç¡€å’Œå®ç°æ–¹æ³•å¯¹äºæ„å»ºå¯é çš„ç‰©è”ç½‘ç³»ç»Ÿå…·æœ‰é‡è¦æ„ä¹‰ã€‚é€šè¿‡å½¢å¼åŒ–çš„æ–¹æ³•ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ›´å¥½åœ°ç†è§£å’Œè®¾è®¡ç‰©è”ç½‘ç³»ç»Ÿï¼Œç¡®ä¿å…¶æ­£ç¡®æ€§ã€å¯é æ€§å’Œæ•ˆç‡ã€‚

---

*æœ¬æ–‡æ¡£æ˜¯è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®—ç§‘å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„å½¢å¼åŒ–è§„èŒƒå’Œå­¦æœ¯æ ‡å‡†ã€‚*
