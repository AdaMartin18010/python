# 04-03-01 IoTåŸºç¡€

## ğŸ“‹ ç›®å½•

- [04-03-01 IoTåŸºç¡€](#04-03-01-iotåŸºç¡€)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ”¬ æ¦‚å¿µå®šä¹‰](#-æ¦‚å¿µå®šä¹‰)
  - [ğŸ“ æ•°å­¦å½¢å¼åŒ–](#-æ•°å­¦å½¢å¼åŒ–)
  - [ğŸ Pythonå®ç°](#-pythonå®ç°)
  - [ğŸ“Š æ¶æ„æ¨¡å¼](#-æ¶æ„æ¨¡å¼)
  - [ğŸ”„ å·¥ä½œæµç¨‹](#-å·¥ä½œæµç¨‹)
  - [ğŸ“ˆ åº”ç”¨æ¡ˆä¾‹](#-åº”ç”¨æ¡ˆä¾‹)
  - [ğŸ”— ç›¸å…³é“¾æ¥](#-ç›¸å…³é“¾æ¥)

## ğŸ¯ æ¦‚è¿°

ç‰©è”ç½‘(Internet of Things, IoT)æ˜¯è¿æ¥ç‰©ç†ä¸–ç•Œå’Œæ•°å­—ä¸–ç•Œçš„æŠ€æœ¯ä½“ç³»ï¼Œé€šè¿‡ä¼ æ„Ÿå™¨ã€ç½‘ç»œå’Œè®¡ç®—æŠ€æœ¯å®ç°è®¾å¤‡é—´çš„æ™ºèƒ½äº’è”ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€æ•°å­¦åŸºç¡€ã€Pythonå®ç°ç­‰å¤šä¸ªç»´åº¦å…¨é¢é˜è¿°IoTåŸºç¡€ç†è®ºã€‚

## ğŸ”¬ æ¦‚å¿µå®šä¹‰

### å®šä¹‰ 1.1 (ç‰©è”ç½‘)
ç‰©è”ç½‘æ˜¯è¿æ¥ç‰©ç†è®¾å¤‡çš„ç½‘ç»œç³»ç»Ÿï¼Œå½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$IoT = (D, N, C, A, S)$$

å…¶ä¸­ï¼š
- $D$ æ˜¯è®¾å¤‡é›†åˆ
- $N$ æ˜¯ç½‘ç»œè¿æ¥
- $C$ æ˜¯è®¡ç®—å¤„ç†
- $A$ æ˜¯åº”ç”¨æœåŠ¡
- $S$ æ˜¯å®‰å…¨æœºåˆ¶

### å®šä¹‰ 1.2 (IoTè®¾å¤‡å±‚æ¬¡)
IoTè®¾å¤‡æŒ‰èƒ½åŠ›åˆ†ä¸ºå››ä¸ªå±‚æ¬¡ï¼š

$$IoT_{layers} = \{L_1, L_2, L_3, L_4\}$$

å…¶ä¸­ï¼š
- $L_1$ æ˜¯å—é™ç»ˆç«¯è®¾å¤‡ (MCUçº§åˆ«)
- $L_2$ æ˜¯æ ‡å‡†ç»ˆç«¯è®¾å¤‡ (ä½åŠŸè€—å¤„ç†å™¨)
- $L_3$ æ˜¯è¾¹ç¼˜ç½‘å…³è®¾å¤‡ (ä¸­ç­‰è®¡ç®—èƒ½åŠ›)
- $L_4$ æ˜¯äº‘ç«¯åŸºç¡€è®¾æ–½ (é«˜è®¡ç®—èƒ½åŠ›)

### å®šä¹‰ 1.3 (IoTå®¹é”™æ¨¡å‹)
IoTå®¹é”™æ¨¡å‹ç¡®ä¿ç³»ç»Ÿå¯é æ€§ï¼š

$$FT = (R, D, I, R)$$

å…¶ä¸­ï¼š
- $R$ æ˜¯å†—ä½™æœºåˆ¶
- $D$ æ˜¯å¤±æ•ˆæ£€æµ‹
- $I$ æ˜¯æ•…éšœéš”ç¦»
- $R$ æ˜¯å¿«é€Ÿæ¢å¤

## ğŸ“ æ•°å­¦å½¢å¼åŒ–

### å®šç† 1.1 (IoTè®¾å¤‡æ•°é‡å¢é•¿)
IoTè®¾å¤‡æ•°é‡å‘ˆæŒ‡æ•°å¢é•¿ï¼š

$$N(t) = N_0 \cdot e^{kt}$$

å…¶ä¸­ï¼š
- $N(t)$ æ˜¯æ—¶é—´ $t$ çš„è®¾å¤‡æ•°é‡
- $N_0$ æ˜¯åˆå§‹è®¾å¤‡æ•°é‡
- $k$ æ˜¯å¢é•¿ç‡

### å®šç† 1.2 (IoTæ•°æ®é‡)
IoTæ•°æ®é‡éšè®¾å¤‡æ•°é‡çº¿æ€§å¢é•¿ï¼š

$$D(t) = \alpha \cdot N(t) \cdot f$$

å…¶ä¸­ï¼š
- $D(t)$ æ˜¯æ—¶é—´ $t$ çš„æ•°æ®é‡
- $\alpha$ æ˜¯æ¯è®¾å¤‡æ•°æ®ç³»æ•°
- $f$ æ˜¯æ•°æ®é¢‘ç‡

### å®šä¹‰ 1.4 (IoTå®‰å…¨æ¨¡å‹)
IoTå®‰å…¨æ¨¡å‹åŸºäºå¤šå±‚é˜²æŠ¤ï¼š

$$S = (A, C, I, M)$$

å…¶ä¸­ï¼š
- $A$ æ˜¯è®¤è¯æœºåˆ¶
- $C$ æ˜¯åŠ å¯†ç®—æ³•
- $I$ æ˜¯å®Œæ•´æ€§æ£€æŸ¥
- $M$ æ˜¯ç›‘æ§ç³»ç»Ÿ

## ğŸ Pythonå®ç°

### 1. IoTè®¾å¤‡æ¨¡æ‹Ÿ

```python
import time
import random
import json
import asyncio
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum

class DeviceType(Enum):
    """è®¾å¤‡ç±»å‹æšä¸¾"""
    SENSOR = "sensor"
    ACTUATOR = "actuator"
    GATEWAY = "gateway"
    CONTROLLER = "controller"

@dataclass
class DeviceConfig:
    """è®¾å¤‡é…ç½®"""
    device_id: str
    device_type: DeviceType
    location: str
    capabilities: List[str]
    power_consumption: float
    update_interval: int

class IoTDevice:
    """IoTè®¾å¤‡åŸºç±»"""
    
    def __init__(self, config: DeviceConfig):
        self.config = config
        self.status = "offline"
        self.last_update = time.time()
        self.data_buffer = []
        self.health_score = 100.0
    
    def connect(self) -> bool:
        """è¿æ¥è®¾å¤‡"""
        try:
            # æ¨¡æ‹Ÿè¿æ¥è¿‡ç¨‹
            time.sleep(0.1)
            self.status = "online"
            self.last_update = time.time()
            return True
        except Exception as e:
            print(f"è®¾å¤‡è¿æ¥å¤±è´¥: {e}")
            return False
    
    def disconnect(self):
        """æ–­å¼€è®¾å¤‡"""
        self.status = "offline"
        self.last_update = time.time()
    
    def get_status(self) -> Dict[str, Any]:
        """è·å–è®¾å¤‡çŠ¶æ€"""
        return {
            "device_id": self.config.device_id,
            "device_type": self.config.device_type.value,
            "status": self.status,
            "last_update": self.last_update,
            "health_score": self.health_score,
            "location": self.config.location
        }
    
    def update_health(self):
        """æ›´æ–°å¥åº·çŠ¶æ€"""
        # æ¨¡æ‹Ÿå¥åº·æ£€æŸ¥
        if self.status == "online":
            self.health_score = max(0, self.health_score - random.uniform(0, 2))
        else:
            self.health_score = max(0, self.health_score - random.uniform(1, 5))

class Sensor(IoTDevice):
    """ä¼ æ„Ÿå™¨è®¾å¤‡"""
    
    def __init__(self, config: DeviceConfig, sensor_type: str):
        super().__init__(config)
        self.sensor_type = sensor_type
        self.calibration_data = {}
    
    def read_data(self) -> Dict[str, Any]:
        """è¯»å–ä¼ æ„Ÿå™¨æ•°æ®"""
        if self.status != "online":
            return {"error": "è®¾å¤‡ç¦»çº¿"}
        
        # æ¨¡æ‹Ÿä¼ æ„Ÿå™¨è¯»æ•°
        if self.sensor_type == "temperature":
            value = random.uniform(15, 35)
        elif self.sensor_type == "humidity":
            value = random.uniform(30, 80)
        elif self.sensor_type == "pressure":
            value = random.uniform(1000, 1020)
        else:
            value = random.uniform(0, 100)
        
        data = {
            "device_id": self.config.device_id,
            "sensor_type": self.sensor_type,
            "value": round(value, 2),
            "unit": self._get_unit(),
            "timestamp": time.time(),
            "quality": random.uniform(0.8, 1.0)
        }
        
        self.data_buffer.append(data)
        return data
    
    def _get_unit(self) -> str:
        """è·å–å•ä½"""
        units = {
            "temperature": "Â°C",
            "humidity": "%",
            "pressure": "hPa",
            "light": "lux",
            "noise": "dB"
        }
        return units.get(self.sensor_type, "unit")
    
    def calibrate(self, reference_value: float):
        """æ ¡å‡†ä¼ æ„Ÿå™¨"""
        if self.data_buffer:
            current_value = self.data_buffer[-1]["value"]
            offset = reference_value - current_value
            self.calibration_data["offset"] = offset
            print(f"ä¼ æ„Ÿå™¨æ ¡å‡†å®Œæˆï¼Œåç§»é‡: {offset}")

class Actuator(IoTDevice):
    """æ‰§è¡Œå™¨è®¾å¤‡"""
    
    def __init__(self, config: DeviceConfig, actuator_type: str):
        super().__init__(config)
        self.actuator_type = actuator_type
        self.current_state = "idle"
        self.target_state = None
    
    def set_state(self, target_state: str) -> bool:
        """è®¾ç½®æ‰§è¡Œå™¨çŠ¶æ€"""
        if self.status != "online":
            return False
        
        self.target_state = target_state
        
        # æ¨¡æ‹ŸçŠ¶æ€è½¬æ¢
        if self.actuator_type == "relay":
            self.current_state = "on" if target_state == "on" else "off"
        elif self.actuator_type == "motor":
            self.current_state = target_state
        elif self.actuator_type == "valve":
            self.current_state = target_state
        
        return True
    
    def get_state(self) -> Dict[str, Any]:
        """è·å–æ‰§è¡Œå™¨çŠ¶æ€"""
        return {
            "device_id": self.config.device_id,
            "actuator_type": self.actuator_type,
            "current_state": self.current_state,
            "target_state": self.target_state,
            "status": self.status
        }

class Gateway(IoTDevice):
    """ç½‘å…³è®¾å¤‡"""
    
    def __init__(self, config: DeviceConfig):
        super().__init__(config)
        self.connected_devices = []
        self.data_queue = []
        self.routing_table = {}
    
    def add_device(self, device: IoTDevice):
        """æ·»åŠ è¿æ¥çš„è®¾å¤‡"""
        self.connected_devices.append(device)
        self.routing_table[device.config.device_id] = device
    
    def collect_data(self) -> List[Dict[str, Any]]:
        """æ”¶é›†æ‰€æœ‰è®¾å¤‡æ•°æ®"""
        collected_data = []
        
        for device in self.connected_devices:
            if device.status == "online":
                if isinstance(device, Sensor):
                    data = device.read_data()
                    if "error" not in data:
                        collected_data.append(data)
                elif isinstance(device, Actuator):
                    data = device.get_state()
                    collected_data.append(data)
        
        self.data_queue.extend(collected_data)
        return collected_data
    
    def forward_data(self, destination: str) -> bool:
        """è½¬å‘æ•°æ®åˆ°äº‘ç«¯"""
        if not self.data_queue:
            return False
        
        # æ¨¡æ‹Ÿæ•°æ®è½¬å‘
        data_batch = self.data_queue.copy()
        self.data_queue.clear()
        
        print(f"è½¬å‘ {len(data_batch)} æ¡æ•°æ®åˆ° {destination}")
        return True
    
    def get_network_status(self) -> Dict[str, Any]:
        """è·å–ç½‘ç»œçŠ¶æ€"""
        online_devices = sum(1 for device in self.connected_devices if device.status == "online")
        
        return {
            "gateway_id": self.config.device_id,
            "total_devices": len(self.connected_devices),
            "online_devices": online_devices,
            "data_queue_size": len(self.data_queue),
            "status": self.status
        }
```

### 2. IoTç½‘ç»œé€šä¿¡

```python
import socket
import threading
import queue
from typing import Callable, Any

class IoTProtocol:
    """IoTé€šä¿¡åè®®åŸºç±»"""
    
    def __init__(self, protocol_name: str):
        self.protocol_name = protocol_name
        self.message_queue = queue.Queue()
        self.callbacks = {}
    
    def register_callback(self, message_type: str, callback: Callable):
        """æ³¨å†Œæ¶ˆæ¯å›è°ƒ"""
        self.callbacks[message_type] = callback
    
    def send_message(self, message: Dict[str, Any]):
        """å‘é€æ¶ˆæ¯"""
        self.message_queue.put(message)
    
    def process_messages(self):
        """å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—"""
        while not self.message_queue.empty():
            message = self.message_queue.get()
            message_type = message.get("type")
            
            if message_type in self.callbacks:
                self.callbacks[message_type](message)

class MQTTProtocol(IoTProtocol):
    """MQTTåè®®å®ç°"""
    
    def __init__(self, broker_host: str = "localhost", broker_port: int = 1883):
        super().__init__("MQTT")
        self.broker_host = broker_host
        self.broker_port = broker_port
        self.topics = {}
        self.connected = False
    
    def connect(self) -> bool:
        """è¿æ¥åˆ°MQTTä»£ç†"""
        try:
            # æ¨¡æ‹ŸMQTTè¿æ¥
            print(f"è¿æ¥åˆ°MQTTä»£ç† {self.broker_host}:{self.broker_port}")
            self.connected = True
            return True
        except Exception as e:
            print(f"MQTTè¿æ¥å¤±è´¥: {e}")
            return False
    
    def subscribe(self, topic: str, callback: Callable):
        """è®¢é˜…ä¸»é¢˜"""
        self.topics[topic] = callback
        print(f"è®¢é˜…ä¸»é¢˜: {topic}")
    
    def publish(self, topic: str, message: str):
        """å‘å¸ƒæ¶ˆæ¯"""
        if not self.connected:
            return False
        
        mqtt_message = {
            "topic": topic,
            "payload": message,
            "timestamp": time.time()
        }
        
        print(f"å‘å¸ƒæ¶ˆæ¯åˆ°ä¸»é¢˜ {topic}: {message}")
        return True
    
    def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        self.connected = False
        print("æ–­å¼€MQTTè¿æ¥")

class CoAPProtocol(IoTProtocol):
    """CoAPåè®®å®ç°"""
    
    def __init__(self, port: int = 5683):
        super().__init__("CoAP")
        self.port = port
        self.resources = {}
        self.server_socket = None
    
    def start_server(self):
        """å¯åŠ¨CoAPæœåŠ¡å™¨"""
        try:
            # æ¨¡æ‹ŸCoAPæœåŠ¡å™¨å¯åŠ¨
            print(f"å¯åŠ¨CoAPæœåŠ¡å™¨ï¼Œç«¯å£: {self.port}")
            return True
        except Exception as e:
            print(f"CoAPæœåŠ¡å™¨å¯åŠ¨å¤±è´¥: {e}")
            return False
    
    def add_resource(self, path: str, handler: Callable):
        """æ·»åŠ èµ„æº"""
        self.resources[path] = handler
        print(f"æ·»åŠ CoAPèµ„æº: {path}")
    
    def get_resource(self, path: str) -> Dict[str, Any]:
        """è·å–èµ„æº"""
        if path in self.resources:
            return self.resources[path]()
        return {"error": "Resource not found"}
    
    def post_resource(self, path: str, data: Dict[str, Any]):
        """POSTèµ„æº"""
        if path in self.resources:
            return self.resources[path](data)
        return {"error": "Resource not found"}

class IoTNetwork:
    """IoTç½‘ç»œç®¡ç†"""
    
    def __init__(self):
        self.protocols = {}
        self.devices = {}
        self.routing_table = {}
    
    def add_protocol(self, protocol: IoTProtocol):
        """æ·»åŠ åè®®"""
        self.protocols[protocol.protocol_name] = protocol
    
    def add_device(self, device_id: str, device: IoTDevice):
        """æ·»åŠ è®¾å¤‡"""
        self.devices[device_id] = device
    
    def route_message(self, source: str, destination: str, message: Dict[str, Any]):
        """è·¯ç”±æ¶ˆæ¯"""
        if destination in self.devices:
            # ç›´æ¥è·¯ç”±åˆ°è®¾å¤‡
            target_device = self.devices[destination]
            if hasattr(target_device, 'receive_message'):
                target_device.receive_message(message)
        else:
            # é€šè¿‡åè®®è½¬å‘
            for protocol in self.protocols.values():
                if hasattr(protocol, 'forward_message'):
                    protocol.forward_message(destination, message)
    
    def broadcast_message(self, message: Dict[str, Any]):
        """å¹¿æ’­æ¶ˆæ¯"""
        for device in self.devices.values():
            if hasattr(device, 'receive_message'):
                device.receive_message(message)
    
    def get_network_topology(self) -> Dict[str, Any]:
        """è·å–ç½‘ç»œæ‹“æ‰‘"""
        return {
            "devices": list(self.devices.keys()),
            "protocols": list(self.protocols.keys()),
            "connections": len(self.devices)
        }
```

### 3. IoTæ•°æ®å¤„ç†

```python
import numpy as np
from collections import deque
import statistics

class IoTDataProcessor:
    """IoTæ•°æ®å¤„ç†å™¨"""
    
    def __init__(self, window_size: int = 100):
        self.window_size = window_size
        self.data_buffers = {}
        self.processors = {}
    
    def add_data(self, device_id: str, data: Dict[str, Any]):
        """æ·»åŠ æ•°æ®"""
        if device_id not in self.data_buffers:
            self.data_buffers[device_id] = deque(maxlen=self.window_size)
        
        self.data_buffers[device_id].append(data)
    
    def get_statistics(self, device_id: str) -> Dict[str, float]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        if device_id not in self.data_buffers:
            return {}
        
        data_buffer = self.data_buffers[device_id]
        if not data_buffer:
            return {}
        
        values = [item.get("value", 0) for item in data_buffer if "value" in item]
        
        if not values:
            return {}
        
        return {
            "mean": statistics.mean(values),
            "median": statistics.median(values),
            "std": statistics.stdev(values) if len(values) > 1 else 0,
            "min": min(values),
            "max": max(values),
            "count": len(values)
        }
    
    def detect_anomaly(self, device_id: str, threshold: float = 2.0) -> bool:
        """å¼‚å¸¸æ£€æµ‹"""
        stats = self.get_statistics(device_id)
        if not stats:
            return False
        
        if device_id not in self.data_buffers:
            return False
        
        data_buffer = self.data_buffers[device_id]
        if len(data_buffer) < 2:
            return False
        
        latest_value = data_buffer[-1].get("value", 0)
        mean = stats["mean"]
        std = stats["std"]
        
        if std == 0:
            return False
        
        z_score = abs(latest_value - mean) / std
        return z_score > threshold
    
    def filter_data(self, device_id: str, filter_type: str = "moving_average") -> List[float]:
        """æ•°æ®æ»¤æ³¢"""
        if device_id not in self.data_buffers:
            return []
        
        data_buffer = self.data_buffers[device_id]
        values = [item.get("value", 0) for item in data_buffer if "value" in item]
        
        if filter_type == "moving_average":
            return self._moving_average(values, window=5)
        elif filter_type == "median_filter":
            return self._median_filter(values, window=5)
        else:
            return values
    
    def _moving_average(self, values: List[float], window: int) -> List[float]:
        """ç§»åŠ¨å¹³å‡æ»¤æ³¢"""
        if len(values) < window:
            return values
        
        result = []
        for i in range(len(values)):
            start = max(0, i - window + 1)
            window_values = values[start:i+1]
            result.append(sum(window_values) / len(window_values))
        
        return result
    
    def _median_filter(self, values: List[float], window: int) -> List[float]:
        """ä¸­å€¼æ»¤æ³¢"""
        if len(values) < window:
            return values
        
        result = []
        for i in range(len(values)):
            start = max(0, i - window + 1)
            window_values = values[start:i+1]
            result.append(statistics.median(window_values))
        
        return result

class IoTDataAggregator:
    """IoTæ•°æ®èšåˆå™¨"""
    
    def __init__(self):
        self.aggregation_rules = {}
        self.aggregated_data = {}
    
    def add_aggregation_rule(self, rule_name: str, rule_func: Callable):
        """æ·»åŠ èšåˆè§„åˆ™"""
        self.aggregation_rules[rule_name] = rule_func
    
    def aggregate_data(self, device_ids: List[str], rule_name: str, processor: IoTDataProcessor):
        """èšåˆæ•°æ®"""
        if rule_name not in self.aggregation_rules:
            return None
        
        rule_func = self.aggregation_rules[rule_name]
        data_sets = []
        
        for device_id in device_ids:
            stats = processor.get_statistics(device_id)
            if stats:
                data_sets.append(stats)
        
        if data_sets:
            result = rule_func(data_sets)
            self.aggregated_data[rule_name] = result
            return result
        
        return None
    
    def get_aggregated_data(self, rule_name: str) -> Dict[str, Any]:
        """è·å–èšåˆæ•°æ®"""
        return self.aggregated_data.get(rule_name, {})
    
    def clear_aggregated_data(self):
        """æ¸…é™¤èšåˆæ•°æ®"""
        self.aggregated_data.clear()
```

## ğŸ“Š æ¶æ„æ¨¡å¼

### IoTæ¶æ„æ¨¡å¼å¯¹æ¯”

| æ¨¡å¼ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ | å¤æ‚åº¦ |
|------|----------|------|------|--------|
| é›†ä¸­å¼æ¶æ„ | å°å‹IoTç³»ç»Ÿ | ç®€å•ã€æ˜“ç®¡ç† | å•ç‚¹æ•…éšœã€æ‰©å±•æ€§å·® | ä½ |
| åˆ†å¸ƒå¼æ¶æ„ | å¤§å‹IoTç³»ç»Ÿ | é«˜å¯ç”¨ã€å¯æ‰©å±• | å¤æ‚ã€ä¸€è‡´æ€§éš¾ä¿è¯ | é«˜ |
| è¾¹ç¼˜è®¡ç®—æ¶æ„ | å®æ—¶å¤„ç†éœ€æ±‚ | ä½å»¶è¿Ÿã€å‡å°‘å¸¦å®½ | è¾¹ç¼˜è®¾å¤‡æˆæœ¬é«˜ | ä¸­ |
| é›¾è®¡ç®—æ¶æ„ | ä¸­ç­‰è§„æ¨¡ç³»ç»Ÿ | å¹³è¡¡æ€§èƒ½å’Œæˆæœ¬ | ç®¡ç†å¤æ‚ | ä¸­ |

### IoTæ¶æ„å›¾

```mermaid
graph TB
    A[ä¼ æ„Ÿå™¨å±‚] --> B[è¾¹ç¼˜è®¡ç®—å±‚]
    B --> C[ç½‘ç»œä¼ è¾“å±‚]
    C --> D[äº‘ç«¯å¤„ç†å±‚]
    D --> E[åº”ç”¨æœåŠ¡å±‚]
    
    subgraph "è®¾å¤‡ç±»å‹"
        A1[æ¸©åº¦ä¼ æ„Ÿå™¨]
        A2[æ¹¿åº¦ä¼ æ„Ÿå™¨]
        A3[æ‰§è¡Œå™¨]
    end
    
    subgraph "è¾¹ç¼˜èŠ‚ç‚¹"
        B1[æ•°æ®é¢„å¤„ç†]
        B2[æœ¬åœ°å†³ç­–]
        B3[æ•°æ®ç¼“å­˜]
    end
    
    subgraph "äº‘ç«¯æœåŠ¡"
        D1[æ•°æ®åˆ†æ]
        D2[æœºå™¨å­¦ä¹ ]
        D3[å­˜å‚¨ç®¡ç†]
    end
```

## ğŸ”„ å·¥ä½œæµç¨‹

### IoTç³»ç»Ÿå·¥ä½œæµç¨‹

```python
def iot_system_workflow():
    """IoTç³»ç»Ÿå®Œæ•´å·¥ä½œæµç¨‹"""
    
    # 1. åˆ›å»ºè®¾å¤‡
    temp_sensor_config = DeviceConfig(
        device_id="temp_001",
        device_type=DeviceType.SENSOR,
        location="room_101",
        capabilities=["temperature_reading"],
        power_consumption=0.1,
        update_interval=30
    )
    
    temp_sensor = Sensor(temp_sensor_config, "temperature")
    
    # 2. åˆ›å»ºç½‘å…³
    gateway_config = DeviceConfig(
        device_id="gateway_001",
        device_type=DeviceType.GATEWAY,
        location="building_1",
        capabilities=["data_collection", "routing"],
        power_consumption=5.0,
        update_interval=5
    )
    
    gateway = Gateway(gateway_config)
    gateway.add_device(temp_sensor)
    
    # 3. åˆ›å»ºç½‘ç»œ
    network = IoTNetwork()
    network.add_device("temp_001", temp_sensor)
    network.add_device("gateway_001", gateway)
    
    # 4. åˆ›å»ºé€šä¿¡åè®®
    mqtt = MQTTProtocol("mqtt.broker.com", 1883)
    network.add_protocol(mqtt)
    
    # 5. åˆ›å»ºæ•°æ®å¤„ç†å™¨
    processor = IoTDataProcessor(window_size=50)
    aggregator = IoTDataAggregator()
    
    # 6. ç³»ç»Ÿè¿è¡Œ
    print("=== IoTç³»ç»Ÿå¯åŠ¨ ===")
    
    # è¿æ¥è®¾å¤‡
    temp_sensor.connect()
    gateway.connect()
    mqtt.connect()
    
    # æ¨¡æ‹Ÿæ•°æ®æ”¶é›†å’Œå¤„ç†
    for i in range(10):
        # è¯»å–ä¼ æ„Ÿå™¨æ•°æ®
        sensor_data = temp_sensor.read_data()
        print(f"ä¼ æ„Ÿå™¨æ•°æ®: {sensor_data}")
        
        # æ·»åŠ åˆ°å¤„ç†å™¨
        processor.add_data("temp_001", sensor_data)
        
        # æ£€æŸ¥å¼‚å¸¸
        if processor.detect_anomaly("temp_001"):
            print("æ£€æµ‹åˆ°å¼‚å¸¸æ•°æ®!")
        
        # è·å–ç»Ÿè®¡ä¿¡æ¯
        stats = processor.get_statistics("temp_001")
        print(f"ç»Ÿè®¡ä¿¡æ¯: {stats}")
        
        # ç½‘å…³æ”¶é›†æ•°æ®
        gateway_data = gateway.collect_data()
        print(f"ç½‘å…³æ•°æ®: {gateway_data}")
        
        # è½¬å‘åˆ°äº‘ç«¯
        gateway.forward_data("cloud.iot.com")
        
        time.sleep(1)
    
    # 7. ç³»ç»Ÿæ¸…ç†
    temp_sensor.disconnect()
    gateway.disconnect()
    mqtt.disconnect()
    
    print("=== IoTç³»ç»Ÿå…³é—­ ===")
    
    return {
        "sensor": temp_sensor,
        "gateway": gateway,
        "network": network,
        "processor": processor
    }

# è¿è¡ŒIoTç³»ç»Ÿ
if __name__ == "__main__":
    iot_system = iot_system_workflow()
```

## ğŸ“ˆ åº”ç”¨æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šæ™ºèƒ½å®¶å±…ç³»ç»Ÿ

```python
def smart_home_system():
    """æ™ºèƒ½å®¶å±…ç³»ç»Ÿç¤ºä¾‹"""
    
    # åˆ›å»ºä¼ æ„Ÿå™¨
    temp_sensor = Sensor(
        DeviceConfig("temp_001", DeviceType.SENSOR, "å®¢å…", ["temperature"], 0.1, 30),
        "temperature"
    )
    
    humidity_sensor = Sensor(
        DeviceConfig("humidity_001", DeviceType.SENSOR, "å®¢å…", ["humidity"], 0.1, 30),
        "humidity"
    )
    
    # åˆ›å»ºæ‰§è¡Œå™¨
    ac_controller = Actuator(
        DeviceConfig("ac_001", DeviceType.ACTUATOR, "å®¢å…", ["temperature_control"], 2.0, 60),
        "relay"
    )
    
    # åˆ›å»ºç½‘å…³
    home_gateway = Gateway(
        DeviceConfig("gateway_001", DeviceType.GATEWAY, "å®¢å…", ["data_collection"], 5.0, 5)
    )
    
    # è¿æ¥è®¾å¤‡
    home_gateway.add_device(temp_sensor)
    home_gateway.add_device(humidity_sensor)
    home_gateway.add_device(ac_controller)
    
    # è¿æ¥è®¾å¤‡
    temp_sensor.connect()
    humidity_sensor.connect()
    ac_controller.connect()
    home_gateway.connect()
    
    # æ™ºèƒ½æ§åˆ¶é€»è¾‘
    def smart_control():
        temp_data = temp_sensor.read_data()
        humidity_data = humidity_sensor.read_data()
        
        temperature = temp_data.get("value", 25)
        
        # æ¸©åº¦æ§åˆ¶é€»è¾‘
        if temperature > 28:
            ac_controller.set_state("on")
            print(f"æ¸©åº¦è¿‡é«˜({temperature}Â°C)ï¼Œå¼€å¯ç©ºè°ƒ")
        elif temperature < 20:
            ac_controller.set_state("off")
            print(f"æ¸©åº¦è¿‡ä½({temperature}Â°C)ï¼Œå…³é—­ç©ºè°ƒ")
    
    # è¿è¡Œæ™ºèƒ½å®¶å±…ç³»ç»Ÿ
    print("=== æ™ºèƒ½å®¶å±…ç³»ç»Ÿå¯åŠ¨ ===")
    
    for i in range(5):
        smart_control()
        time.sleep(2)
    
    print("=== æ™ºèƒ½å®¶å±…ç³»ç»Ÿå…³é—­ ===")
    
    return {
        "temp_sensor": temp_sensor,
        "humidity_sensor": humidity_sensor,
        "ac_controller": ac_controller,
        "gateway": home_gateway
    }
```

### æ¡ˆä¾‹2ï¼šå·¥ä¸šç›‘æ§ç³»ç»Ÿ

```python
def industrial_monitoring_system():
    """å·¥ä¸šç›‘æ§ç³»ç»Ÿç¤ºä¾‹"""
    
    # åˆ›å»ºå¤šä¸ªä¼ æ„Ÿå™¨
    sensors = []
    sensor_types = ["temperature", "pressure", "vibration", "flow"]
    
    for i, sensor_type in enumerate(sensor_types):
        sensor = Sensor(
            DeviceConfig(f"{sensor_type}_{i+1:03d}", DeviceType.SENSOR, f"machine_{i+1}", [sensor_type], 0.2, 10),
            sensor_type
        )
        sensors.append(sensor)
    
    # åˆ›å»ºå·¥ä¸šç½‘å…³
    industrial_gateway = Gateway(
        DeviceConfig("industrial_gateway_001", DeviceType.GATEWAY, "factory_floor", ["data_collection", "edge_computing"], 10.0, 1)
    )
    
    # è¿æ¥æ‰€æœ‰ä¼ æ„Ÿå™¨
    for sensor in sensors:
        industrial_gateway.add_device(sensor)
        sensor.connect()
    
    industrial_gateway.connect()
    
    # åˆ›å»ºæ•°æ®å¤„ç†å™¨
    processor = IoTDataProcessor(window_size=100)
    
    # å¼‚å¸¸æ£€æµ‹è§„åˆ™
    def check_industrial_anomalies():
        anomalies = []
        for sensor in sensors:
            if processor.detect_anomaly(sensor.config.device_id, threshold=3.0):
                anomalies.append(sensor.config.device_id)
        return anomalies
    
    # è¿è¡Œå·¥ä¸šç›‘æ§ç³»ç»Ÿ
    print("=== å·¥ä¸šç›‘æ§ç³»ç»Ÿå¯åŠ¨ ===")
    
    for i in range(20):
        # æ”¶é›†æ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®
        all_data = industrial_gateway.collect_data()
        
        # å¤„ç†æ•°æ®
        for data in all_data:
            processor.add_data(data["device_id"], data)
        
        # æ£€æŸ¥å¼‚å¸¸
        anomalies = check_industrial_anomalies()
        if anomalies:
            print(f"æ£€æµ‹åˆ°å¼‚å¸¸è®¾å¤‡: {anomalies}")
        
        # è·å–ç»Ÿè®¡ä¿¡æ¯
        for sensor in sensors:
            stats = processor.get_statistics(sensor.config.device_id)
            if stats:
                print(f"{sensor.config.device_id} ç»Ÿè®¡: {stats}")
        
        time.sleep(0.5)
    
    print("=== å·¥ä¸šç›‘æ§ç³»ç»Ÿå…³é—­ ===")
    
    return {
        "sensors": sensors,
        "gateway": industrial_gateway,
        "processor": processor
    }
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [04-03-02-è®¾å¤‡ç®¡ç†](./04-03-02-è®¾å¤‡ç®¡ç†.md)
- [04-03-03-è¾¹ç¼˜è®¡ç®—](./04-03-03-è¾¹ç¼˜è®¡ç®—.md)
- [05-æ¶æ„é¢†åŸŸ/05-01-ç³»ç»Ÿæ¶æ„/05-01-01-æ¶æ„åŸºç¡€](../05-æ¶æ„é¢†åŸŸ/05-01-ç³»ç»Ÿæ¶æ„/05-01-01-æ¶æ„åŸºç¡€.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0  
**æœ€åæ›´æ–°**ï¼š2024å¹´  
**ç»´æŠ¤è€…**ï¼šAIåŠ©æ‰‹ 