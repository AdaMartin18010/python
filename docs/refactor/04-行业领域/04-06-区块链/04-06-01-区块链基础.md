# åŒºå—é“¾åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

åŒºå—é“¾æ˜¯ä¸€ç§åˆ†å¸ƒå¼è´¦æœ¬æŠ€æœ¯ï¼Œé€šè¿‡å¯†ç å­¦ã€å…±è¯†æœºåˆ¶å’Œåˆ†å¸ƒå¼ç½‘ç»œå®ç°å»ä¸­å¿ƒåŒ–çš„æ•°æ®å­˜å‚¨å’Œäº¤æ˜“éªŒè¯ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€ç†è®ºåŸºç¡€åˆ°Pythonå®ç°ï¼Œå…¨é¢é˜è¿°åŒºå—é“¾æŠ€æœ¯çš„æ ¸å¿ƒæ¦‚å¿µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 åŒºå—é“¾ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (åŒºå—é“¾ç³»ç»Ÿ)
åŒºå—é“¾ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\text{Blockchain} = (N, B, T, C, S)$ï¼Œå…¶ä¸­ï¼š

- $N = \{n_1, n_2, \ldots, n_k\}$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $B = \{b_1, b_2, \ldots, b_m\}$ æ˜¯åŒºå—é›†åˆ
- $T = \{t_1, t_2, \ldots, t_n\}$ æ˜¯äº¤æ˜“é›†åˆ
- $C: B \times B \rightarrow \{0,1\}$ æ˜¯å…±è¯†å‡½æ•°
- $S: B \rightarrow \mathcal{P}(T)$ æ˜¯çŠ¶æ€å‡½æ•°

**å®šä¹‰ 1.2** (åŒºå—)
åŒºå—æ˜¯ä¸€ä¸ªå››å…ƒç»„ $b = (h, p, t, s)$ï¼Œå…¶ä¸­ï¼š

- $h$ æ˜¯åŒºå—å“ˆå¸Œ
- $p$ æ˜¯å‰ä¸€ä¸ªåŒºå—çš„å“ˆå¸Œ
- $t$ æ˜¯æ—¶é—´æˆ³
- $s$ æ˜¯çŠ¶æ€æ ¹

**å®šä¹‰ 1.3** (äº¤æ˜“)
äº¤æ˜“æ˜¯ä¸€ä¸ªå…­å…ƒç»„ $t = (f, t, v, g, n, \sigma)$ï¼Œå…¶ä¸­ï¼š

- $f$ æ˜¯å‘é€æ–¹åœ°å€
- $t$ æ˜¯æ¥æ”¶æ–¹åœ°å€
- $v$ æ˜¯äº¤æ˜“é‡‘é¢
- $g$ æ˜¯ç‡ƒæ–™é™åˆ¶
- $n$ æ˜¯éšæœºæ•°
- $\sigma$ æ˜¯æ•°å­—ç­¾å

### 1.2 å…±è¯†æœºåˆ¶å®šä¹‰

**å®šä¹‰ 1.4** (å·¥ä½œé‡è¯æ˜)
å·¥ä½œé‡è¯æ˜æ˜¯ä¸€ä¸ªå‡½æ•° $\text{PoW}: B \times \mathbb{N} \rightarrow \{0,1\}$ï¼Œæ»¡è¶³ï¼š

$$\text{PoW}(b, n) = 1 \iff H(b \| n) < D$$

å…¶ä¸­ $H$ æ˜¯å“ˆå¸Œå‡½æ•°ï¼Œ$D$ æ˜¯éš¾åº¦ç›®æ ‡ã€‚

**å®šä¹‰ 1.5** (æƒç›Šè¯æ˜)
æƒç›Šè¯æ˜æ˜¯ä¸€ä¸ªå‡½æ•° $\text{PoS}: N \times \mathbb{R}^+ \rightarrow [0,1]$ï¼Œæ»¡è¶³ï¼š

$$\text{PoS}(n_i, s_i) = \frac{s_i}{\sum_{j=1}^k s_j}$$

å…¶ä¸­ $s_i$ æ˜¯èŠ‚ç‚¹ $n_i$ çš„æƒç›Šã€‚

## 2. ç†è®ºåŸºç¡€

### 2.1 åŒºå—é“¾å®‰å…¨æ€§å®šç†

**å®šç† 2.1** (åŒºå—é“¾ä¸å¯ç¯¡æ”¹æ€§)
å¦‚æœåŒºå—é“¾ç½‘ç»œä¸­æœ‰è¶…è¿‡ $\frac{2}{3}$ çš„èŠ‚ç‚¹æ˜¯è¯šå®çš„ï¼Œåˆ™åŒºå—é“¾æ˜¯ä¸å¯ç¯¡æ”¹çš„ã€‚

**è¯æ˜**:
è®¾ $h$ æ˜¯è¯šå®èŠ‚ç‚¹æ•°é‡ï¼Œ$t$ æ˜¯æ¶æ„èŠ‚ç‚¹æ•°é‡ã€‚
æ ¹æ®å‡è®¾ï¼Œ$h > 2t$ã€‚

å¯¹äºä»»ä½•åŒºå— $b$ï¼Œè¦ç¯¡æ”¹å®ƒéœ€è¦ï¼š
1. é‡æ–°è®¡ç®—ä» $b$ å¼€å§‹çš„æ‰€æœ‰åŒºå—
2. è·å¾—è¶…è¿‡ $\frac{1}{2}$ çš„ç®—åŠ›æ”¯æŒ

ç”±äº $h > 2t$ï¼Œæ¶æ„èŠ‚ç‚¹æ— æ³•è·å¾—è¶³å¤Ÿçš„ç®—åŠ›æ¥ç¯¡æ”¹åŒºå—é“¾ã€‚

**å®šç† 2.2** (æ‹œå åº­å®¹é”™)
åŒºå—é“¾ç½‘ç»œå¯ä»¥å®¹å¿æœ€å¤š $\frac{1}{3}$ çš„æ‹œå åº­èŠ‚ç‚¹ã€‚

**è¯æ˜**:
è®¾ç½‘ç»œæ€»èŠ‚ç‚¹æ•°ä¸º $n$ï¼Œæ‹œå åº­èŠ‚ç‚¹æ•°ä¸º $f$ã€‚
æ ¹æ®æ‹œå åº­å®¹é”™æ¡ä»¶ï¼š$n \geq 3f + 1$

å¯¹äºä»»ä½•å…±è¯†å†³ç­–ï¼Œéœ€è¦è‡³å°‘ $2f + 1$ ä¸ªèŠ‚ç‚¹çš„åŒæ„ã€‚
ç”±äºè¯šå®èŠ‚ç‚¹æ•°é‡ä¸º $n - f \geq 2f + 1$ï¼Œå› æ­¤å¯ä»¥è¾¾æˆå…±è¯†ã€‚

### 2.2 å¯†ç å­¦åŸºç¡€

**å®šä¹‰ 2.1** (æ¤­åœ†æ›²çº¿æ•°å­—ç­¾å)
æ¤­åœ†æ›²çº¿æ•°å­—ç­¾åæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(\text{KeyGen}, \text{Sign}, \text{Verify})$ï¼š

- $\text{KeyGen}() \rightarrow (pk, sk)$: ç”Ÿæˆå…¬ç§é’¥å¯¹
- $\text{Sign}(sk, m) \rightarrow \sigma$: ä½¿ç”¨ç§é’¥ç­¾åæ¶ˆæ¯
- $\text{Verify}(pk, m, \sigma) \rightarrow \{0,1\}$: éªŒè¯ç­¾å

**å®šç† 2.3** (ECDSAå®‰å…¨æ€§)
åœ¨æ¤­åœ†æ›²çº¿ç¦»æ•£å¯¹æ•°é—®é¢˜å›°éš¾æ€§å‡è®¾ä¸‹ï¼ŒECDSAæ˜¯å®‰å…¨çš„ã€‚

## 3. Pythonå®ç°

### 3.1 æ ¸å¿ƒæ•°æ®ç»“æ„

```python
from typing import List, Dict, Optional, Tuple, Any
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
import hashlib
import time
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec, utils
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import threading
from collections import defaultdict
import uuid
from enum import Enum

@dataclass
class Transaction:
    """äº¤æ˜“ç±»"""
    from_address: str
    to_address: str
    value: float
    gas_limit: int
    gas_price: int
    nonce: int
    signature: Optional[str] = None
    
    def __post_init__(self):
        """åˆå§‹åŒ–åè®¡ç®—äº¤æ˜“å“ˆå¸Œ"""
        self.hash = self._calculate_hash()
    
    def _calculate_hash(self) -> str:
        """è®¡ç®—äº¤æ˜“å“ˆå¸Œ"""
        data = f"{self.from_address}{self.to_address}{self.value}{self.gas_limit}{self.gas_price}{self.nonce}"
        return hashlib.sha256(data.encode()).hexdigest()
    
    def sign(self, private_key: str) -> None:
        """ç­¾åäº¤æ˜“"""
        data = f"{self.from_address}{self.to_address}{self.value}{self.gas_limit}{self.gas_price}{self.nonce}"
        # è¿™é‡Œç®€åŒ–äº†ç­¾åè¿‡ç¨‹ï¼Œå®é™…åº”è¯¥ä½¿ç”¨æ¤­åœ†æ›²çº¿ç­¾å
        self.signature = hashlib.sha256((data + private_key).encode()).hexdigest()
    
    def verify_signature(self) -> bool:
        """éªŒè¯äº¤æ˜“ç­¾å"""
        if not self.signature:
            return False
        data = f"{self.from_address}{self.to_address}{self.value}{self.gas_limit}{self.gas_price}{self.nonce}"
        expected_signature = hashlib.sha256((data + "private_key").encode()).hexdigest()
        return self.signature == expected_signature

@dataclass
class Block:
    """åŒºå—ç±»"""
    index: int
    timestamp: float
    transactions: List[Transaction]
    previous_hash: str
    nonce: int = 0
    hash: Optional[str] = None
    
    def __post_init__(self):
        """åˆå§‹åŒ–åè®¡ç®—åŒºå—å“ˆå¸Œ"""
        self.hash = self._calculate_hash()
    
    def _calculate_hash(self) -> str:
        """è®¡ç®—åŒºå—å“ˆå¸Œ"""
        data = f"{self.index}{self.timestamp}{self.previous_hash}{self.nonce}"
        for tx in self.transactions:
            data += tx.hash
        return hashlib.sha256(data.encode()).hexdigest()
    
    def mine(self, difficulty: int) -> None:
        """æŒ–çŸ¿è¿‡ç¨‹"""
        target = "0" * difficulty
        while self.hash[:difficulty] != target:
            self.nonce += 1
            self.hash = self._calculate_hash()

@dataclass
class Blockchain:
    """åŒºå—é“¾ç±»"""
    chain: List[Block] = field(default_factory=list)
    pending_transactions: List[Transaction] = field(default_factory=list)
    difficulty: int = 4
    mining_reward: float = 10.0
    _lock: threading.Lock = field(default_factory=threading.Lock)
    
    def __post_init__(self):
        """åˆå§‹åŒ–åˆ›ä¸–åŒºå—"""
        if not self.chain:
            genesis_block = Block(0, time.time(), [], "0")
            genesis_block.mine(self.difficulty)
            self.chain.append(genesis_block)
    
    def get_latest_block(self) -> Block:
        """è·å–æœ€æ–°åŒºå—"""
        return self.chain[-1]
    
    def add_transaction(self, transaction: Transaction) -> None:
        """æ·»åŠ å¾…å¤„ç†äº¤æ˜“"""
        if transaction.verify_signature():
            with self._lock:
                self.pending_transactions.append(transaction)
    
    def mine_pending_transactions(self, miner_address: str) -> Block:
        """æŒ–çŸ¿å¾…å¤„ç†äº¤æ˜“"""
        with self._lock:
            # åˆ›å»ºå¥–åŠ±äº¤æ˜“
            reward_tx = Transaction("", miner_address, self.mining_reward, 0, 0, 0)
            
            # åˆ›å»ºæ–°åŒºå—
            block = Block(
                index=len(self.chain),
                timestamp=time.time(),
                transactions=self.pending_transactions + [reward_tx],
                previous_hash=self.get_latest_block().hash
            )
            
            # æŒ–çŸ¿
            block.mine(self.difficulty)
            
            # æ·»åŠ åˆ°é“¾ä¸Š
            self.chain.append(block)
            
            # æ¸…ç©ºå¾…å¤„ç†äº¤æ˜“
            self.pending_transactions = []
            
            return block
    
    def is_chain_valid(self) -> bool:
        """éªŒè¯åŒºå—é“¾æœ‰æ•ˆæ€§"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            # éªŒè¯å½“å‰åŒºå—å“ˆå¸Œ
            if current_block.hash != current_block._calculate_hash():
                return False
            
            # éªŒè¯åŒºå—é“¾æ¥
            if current_block.previous_hash != previous_block.hash:
                return False
        
        return True
    
    def get_balance(self, address: str) -> float:
        """è·å–åœ°å€ä½™é¢"""
        balance = 0.0
        
        for block in self.chain:
            for transaction in block.transactions:
                if transaction.from_address == address:
                    balance -= transaction.value
                if transaction.to_address == address:
                    balance += transaction.value
        
        return balance

class ConsensusEngine(ABC):
    """å…±è¯†å¼•æ“æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def validate_block(self, block: Block, blockchain: Blockchain) -> bool:
        """éªŒè¯åŒºå—"""
        pass
    
    @abstractmethod
    def select_validator(self, validators: List[str]) -> str:
        """é€‰æ‹©éªŒè¯è€…"""
        pass

class ProofOfWork(ConsensusEngine):
    """å·¥ä½œé‡è¯æ˜å…±è¯†"""
    
    def __init__(self, difficulty: int):
        self.difficulty = difficulty
    
    def validate_block(self, block: Block, blockchain: Blockchain) -> bool:
        """éªŒè¯åŒºå—çš„å·¥ä½œé‡è¯æ˜"""
        target = "0" * self.difficulty
        return block.hash.startswith(target)
    
    def select_validator(self, validators: List[str]) -> str:
        """PoWä¸éœ€è¦é€‰æ‹©éªŒè¯è€…ï¼Œä»»ä½•èŠ‚ç‚¹éƒ½å¯ä»¥æŒ–çŸ¿"""
        return validators[0] if validators else ""

class ProofOfStake(ConsensusEngine):
    """æƒç›Šè¯æ˜å…±è¯†"""
    
    def __init__(self):
        self.stakes: Dict[str, float] = defaultdict(float)
    
    def add_stake(self, address: str, amount: float) -> None:
        """æ·»åŠ æƒç›Š"""
        self.stakes[address] += amount
    
    def validate_block(self, block: Block, blockchain: Blockchain) -> bool:
        """éªŒè¯åŒºå—ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰"""
        return True
    
    def select_validator(self, validators: List[str]) -> str:
        """æ ¹æ®æƒç›Šé€‰æ‹©éªŒè¯è€…"""
        if not validators:
            return ""
        
        total_stake = sum(self.stakes[addr] for addr in validators)
        if total_stake == 0:
            return validators[0]
        
        # ç®€å•çš„éšæœºé€‰æ‹©ï¼Œå®é™…åº”è¯¥ä½¿ç”¨æ›´å¤æ‚çš„ç®—æ³•
        import random
        weights = [self.stakes[addr] / total_stake for addr in validators]
        return random.choices(validators, weights=weights)[0]

class SmartContract:
    """æ™ºèƒ½åˆçº¦åŸºç±»"""
    
    def __init__(self, address: str):
        self.address = address
        self.storage: Dict[str, Any] = {}
        self.balance = 0.0
    
    def execute(self, transaction: Transaction, blockchain: Blockchain) -> bool:
        """æ‰§è¡Œæ™ºèƒ½åˆçº¦"""
        raise NotImplementedError
    
    def get_storage(self, key: str) -> Any:
        """è·å–å­˜å‚¨æ•°æ®"""
        return self.storage.get(key)
    
    def set_storage(self, key: str, value: Any) -> None:
        """è®¾ç½®å­˜å‚¨æ•°æ®"""
        self.storage[key] = value

class TokenContract(SmartContract):
    """ä»£å¸åˆçº¦"""
    
    def __init__(self, address: str, name: str, symbol: str, total_supply: float):
        super().__init__(address)
        self.name = name
        self.symbol = symbol
        self.total_supply = total_supply
        self.balances: Dict[str, float] = defaultdict(float)
        self.balances[address] = total_supply  # åˆå§‹ä»£å¸ç»™åˆçº¦åˆ›å»ºè€…
    
    def execute(self, transaction: Transaction, blockchain: Blockchain) -> bool:
        """æ‰§è¡Œä»£å¸è½¬è´¦"""
        # è§£æäº¤æ˜“æ•°æ®ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        if transaction.value > 0:
            # è½¬è´¦æ“ä½œ
            if self.balances[transaction.from_address] >= transaction.value:
                self.balances[transaction.from_address] -= transaction.value
                self.balances[transaction.to_address] += transaction.value
                return True
        return False
    
    def balance_of(self, address: str) -> float:
        """æŸ¥è¯¢åœ°å€ä»£å¸ä½™é¢"""
        return self.balances[address]
    
    def transfer(self, from_address: str, to_address: str, amount: float) -> bool:
        """è½¬è´¦ä»£å¸"""
        if self.balances[from_address] >= amount:
            self.balances[from_address] -= amount
            self.balances[to_address] += amount
            return True
        return False

class BlockchainNode:
    """åŒºå—é“¾èŠ‚ç‚¹"""
    
    def __init__(self, address: str, consensus_engine: ConsensusEngine):
        self.address = address
        self.blockchain = Blockchain()
        self.consensus_engine = consensus_engine
        self.peers: List[str] = []
        self._running = False
        self._lock = threading.Lock()
    
    def add_peer(self, peer_address: str) -> None:
        """æ·»åŠ å¯¹ç­‰èŠ‚ç‚¹"""
        if peer_address not in self.peers:
            self.peers.append(peer_address)
    
    def broadcast_transaction(self, transaction: Transaction) -> None:
        """å¹¿æ’­äº¤æ˜“"""
        # ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”è¯¥é€šè¿‡ç½‘ç»œå‘é€
        print(f"Broadcasting transaction {transaction.hash} to {len(self.peers)} peers")
    
    def broadcast_block(self, block: Block) -> None:
        """å¹¿æ’­åŒºå—"""
        # ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”è¯¥é€šè¿‡ç½‘ç»œå‘é€
        print(f"Broadcasting block {block.hash} to {len(self.peers)} peers")
    
    def receive_transaction(self, transaction: Transaction) -> None:
        """æ¥æ”¶äº¤æ˜“"""
        with self._lock:
            self.blockchain.add_transaction(transaction)
    
    def receive_block(self, block: Block) -> bool:
        """æ¥æ”¶åŒºå—"""
        with self._lock:
            if self.consensus_engine.validate_block(block, self.blockchain):
                # éªŒè¯åŒºå—ä¸­çš„äº¤æ˜“
                for tx in block.transactions:
                    if not tx.verify_signature():
                        return False
                
                # æ·»åŠ åˆ°åŒºå—é“¾
                self.blockchain.chain.append(block)
                return True
        return False
    
    def mine_block(self) -> Optional[Block]:
        """æŒ–çŸ¿"""
        with self._lock:
            if self.pending_transactions:
                block = self.blockchain.mine_pending_transactions(self.address)
                self.broadcast_block(block)
                return block
        return None
    
    def start_mining(self) -> None:
        """å¼€å§‹æŒ–çŸ¿"""
        self._running = True
        
        def mining_loop():
            while self._running:
                self.mine_block()
                time.sleep(1)  # é¿å…è¿‡åº¦æ¶ˆè€—CPU
        
        threading.Thread(target=mining_loop, daemon=True).start()
    
    def stop_mining(self) -> None:
        """åœæ­¢æŒ–çŸ¿"""
        self._running = False
```

### 3.2 ç½‘ç»œå±‚å®ç°

```python
class NetworkLayer:
    """ç½‘ç»œå±‚"""
    
    def __init__(self, node_address: str):
        self.node_address = node_address
        self.connections: Dict[str, 'Connection'] = {}
        self.message_queue: List[Dict] = []
        self._lock = threading.Lock()
    
    def connect(self, peer_address: str) -> bool:
        """è¿æ¥åˆ°å¯¹ç­‰èŠ‚ç‚¹"""
        try:
            # ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”è¯¥å»ºç«‹TCPè¿æ¥
            self.connections[peer_address] = Connection(peer_address)
            return True
        except Exception as e:
            print(f"Failed to connect to {peer_address}: {e}")
            return False
    
    def send_message(self, peer_address: str, message: Dict) -> bool:
        """å‘é€æ¶ˆæ¯"""
        if peer_address in self.connections:
            return self.connections[peer_address].send(message)
        return False
    
    def broadcast_message(self, message: Dict) -> None:
        """å¹¿æ’­æ¶ˆæ¯"""
        for peer_address in self.connections:
            self.send_message(peer_address, message)
    
    def receive_message(self) -> Optional[Dict]:
        """æ¥æ”¶æ¶ˆæ¯"""
        with self._lock:
            if self.message_queue:
                return self.message_queue.pop(0)
        return None
    
    def add_message(self, message: Dict) -> None:
        """æ·»åŠ æ¶ˆæ¯åˆ°é˜Ÿåˆ—"""
        with self._lock:
            self.message_queue.append(message)

class Connection:
    """è¿æ¥ç±»"""
    
    def __init__(self, peer_address: str):
        self.peer_address = peer_address
        self.connected = True
    
    def send(self, message: Dict) -> bool:
        """å‘é€æ¶ˆæ¯"""
        if self.connected:
            # ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”è¯¥é€šè¿‡socketå‘é€
            print(f"Sending message to {self.peer_address}: {message}")
            return True
        return False
    
    def close(self) -> None:
        """å…³é—­è¿æ¥"""
        self.connected = False
```

### 3.3 å­˜å‚¨å±‚å®ç°

```python
class StorageLayer:
    """å­˜å‚¨å±‚"""
    
    def __init__(self):
        self.blocks: Dict[str, Block] = {}
        self.transactions: Dict[str, Transaction] = {}
        self.accounts: Dict[str, Dict] = defaultdict(dict)
        self._lock = threading.Lock()
    
    def store_block(self, block: Block) -> bool:
        """å­˜å‚¨åŒºå—"""
        with self._lock:
            self.blocks[block.hash] = block
            # å­˜å‚¨åŒºå—ä¸­çš„äº¤æ˜“
            for tx in block.transactions:
                self.transactions[tx.hash] = tx
            return True
    
    def get_block(self, block_hash: str) -> Optional[Block]:
        """è·å–åŒºå—"""
        with self._lock:
            return self.blocks.get(block_hash)
    
    def store_transaction(self, transaction: Transaction) -> bool:
        """å­˜å‚¨äº¤æ˜“"""
        with self._lock:
            self.transactions[transaction.hash] = transaction
            return True
    
    def get_transaction(self, tx_hash: str) -> Optional[Transaction]:
        """è·å–äº¤æ˜“"""
        with self._lock:
            return self.transactions.get(tx_hash)
    
    def update_account(self, address: str, data: Dict) -> None:
        """æ›´æ–°è´¦æˆ·æ•°æ®"""
        with self._lock:
            self.accounts[address].update(data)
    
    def get_account(self, address: str) -> Dict:
        """è·å–è´¦æˆ·æ•°æ®"""
        with self._lock:
            return self.accounts[address].copy()
```

## 4. æ€§èƒ½åˆ†æ

### 4.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

**å®šç† 4.1** (æŒ–çŸ¿æ—¶é—´å¤æ‚åº¦)
å·¥ä½œé‡è¯æ˜æŒ–çŸ¿çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(2^d)$ï¼Œå…¶ä¸­ $d$ æ˜¯éš¾åº¦å€¼ã€‚

**è¯æ˜**:
è®¾å“ˆå¸Œå‡½æ•°è¾“å‡ºä¸º $n$ ä½ï¼Œéš¾åº¦ä¸º $d$ã€‚
éœ€è¦æ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„éšæœºæ•°ï¼Œæ¦‚ç‡ä¸º $\frac{1}{2^d}$ã€‚
æœŸæœ›å°è¯•æ¬¡æ•°ä¸º $2^d$ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º $O(2^d)$ã€‚

**å®šç† 4.2** (åŒºå—é“¾éªŒè¯æ—¶é—´å¤æ‚åº¦)
éªŒè¯åŒ…å« $n$ ä¸ªåŒºå—çš„åŒºå—é“¾çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

**è¯æ˜**:
éœ€è¦éªŒè¯æ¯ä¸ªåŒºå—çš„å“ˆå¸Œå’Œé“¾æ¥å…³ç³»ã€‚
æ¯ä¸ªåŒºå—çš„éªŒè¯æ—¶é—´ä¸ºå¸¸æ•°ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

### 4.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

**å®šç† 4.3** (åŒºå—é“¾å­˜å‚¨ç©ºé—´)
å­˜å‚¨åŒ…å« $n$ ä¸ªåŒºå—çš„åŒºå—é“¾çš„ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

**è¯æ˜**:
æ¯ä¸ªåŒºå—åŒ…å«å›ºå®šå¤§å°çš„æ•°æ®ï¼ˆå“ˆå¸Œã€æ—¶é—´æˆ³ã€äº¤æ˜“åˆ—è¡¨ç­‰ï¼‰ã€‚
æ€»å­˜å‚¨ç©ºé—´ä¸åŒºå—æ•°é‡æˆæ­£æ¯”ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

## 5. å®é™…åº”ç”¨ç¤ºä¾‹

### 5.1 ç®€å•åŒºå—é“¾ç³»ç»Ÿ

```python
def demo_blockchain():
    """æ¼”ç¤ºåŒºå—é“¾ç³»ç»Ÿ"""
    # åˆ›å»ºåŒºå—é“¾
    blockchain = Blockchain(difficulty=4)
    
    # åˆ›å»ºç”¨æˆ·
    alice = "alice_address"
    bob = "bob_address"
    charlie = "charlie_address"
    
    # åˆ›å»ºäº¤æ˜“
    tx1 = Transaction(alice, bob, 50.0, 21000, 20, 0)
    tx1.sign("alice_private_key")
    
    tx2 = Transaction(bob, charlie, 30.0, 21000, 20, 0)
    tx2.sign("bob_private_key")
    
    # æ·»åŠ äº¤æ˜“
    blockchain.add_transaction(tx1)
    blockchain.add_transaction(tx2)
    
    # æŒ–çŸ¿
    print("å¼€å§‹æŒ–çŸ¿...")
    block = blockchain.mine_pending_transactions("miner_address")
    print(f"æŒ–çŸ¿å®Œæˆï¼ŒåŒºå—å“ˆå¸Œ: {block.hash}")
    
    # éªŒè¯åŒºå—é“¾
    print(f"åŒºå—é“¾æœ‰æ•ˆ: {blockchain.is_chain_valid()}")
    
    # æŸ¥è¯¢ä½™é¢
    print(f"Aliceä½™é¢: {blockchain.get_balance(alice)}")
    print(f"Bobä½™é¢: {blockchain.get_balance(bob)}")
    print(f"Charlieä½™é¢: {blockchain.get_balance(charlie)}")

def demo_smart_contract():
    """æ¼”ç¤ºæ™ºèƒ½åˆçº¦"""
    # åˆ›å»ºä»£å¸åˆçº¦
    token_contract = TokenContract("contract_address", "MyToken", "MTK", 1000000.0)
    
    # è½¬è´¦
    success = token_contract.transfer("contract_address", "alice_address", 1000.0)
    print(f"è½¬è´¦æˆåŠŸ: {success}")
    
    # æŸ¥è¯¢ä½™é¢
    alice_balance = token_contract.balance_of("alice_address")
    print(f"Aliceä»£å¸ä½™é¢: {alice_balance}")

def demo_consensus():
    """æ¼”ç¤ºå…±è¯†æœºåˆ¶"""
    # å·¥ä½œé‡è¯æ˜
    pow_consensus = ProofOfWork(difficulty=4)
    
    # æƒç›Šè¯æ˜
    pos_consensus = ProofOfStake()
    pos_consensus.add_stake("validator1", 1000.0)
    pos_consensus.add_stake("validator2", 2000.0)
    pos_consensus.add_stake("validator3", 1500.0)
    
    # é€‰æ‹©éªŒè¯è€…
    validator = pos_consensus.select_validator(["validator1", "validator2", "validator3"])
    print(f"é€‰ä¸­çš„éªŒè¯è€…: {validator}")

if __name__ == "__main__":
    print("=== åŒºå—é“¾åŸºç¡€æ¼”ç¤º ===")
    demo_blockchain()
    print("\n=== æ™ºèƒ½åˆçº¦æ¼”ç¤º ===")
    demo_smart_contract()
    print("\n=== å…±è¯†æœºåˆ¶æ¼”ç¤º ===")
    demo_consensus()
```

## 6. æµ‹è¯•éªŒè¯

### 6.1 å•å…ƒæµ‹è¯•

```python
import unittest

class TestBlockchain(unittest.TestCase):
    """åŒºå—é“¾æµ‹è¯•ç±»"""
    
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.blockchain = Blockchain(difficulty=2)
        self.alice = "alice_address"
        self.bob = "bob_address"
    
    def test_create_blockchain(self):
        """æµ‹è¯•åˆ›å»ºåŒºå—é“¾"""
        self.assertEqual(len(self.blockchain.chain), 1)
        self.assertEqual(self.blockchain.chain[0].index, 0)
    
    def test_add_transaction(self):
        """æµ‹è¯•æ·»åŠ äº¤æ˜“"""
        tx = Transaction(self.alice, self.bob, 50.0, 21000, 20, 0)
        tx.sign("private_key")
        self.blockchain.add_transaction(tx)
        self.assertEqual(len(self.blockchain.pending_transactions), 1)
    
    def test_mine_block(self):
        """æµ‹è¯•æŒ–çŸ¿"""
        tx = Transaction(self.alice, self.bob, 50.0, 21000, 20, 0)
        tx.sign("private_key")
        self.blockchain.add_transaction(tx)
        
        block = self.blockchain.mine_pending_transactions("miner")
        self.assertEqual(len(self.blockchain.chain), 2)
        self.assertEqual(block.index, 1)
    
    def test_chain_validity(self):
        """æµ‹è¯•åŒºå—é“¾æœ‰æ•ˆæ€§"""
        self.assertTrue(self.blockchain.is_chain_valid())
    
    def test_balance_calculation(self):
        """æµ‹è¯•ä½™é¢è®¡ç®—"""
        # æ·»åŠ ä¸€äº›äº¤æ˜“
        tx1 = Transaction("", self.alice, 100.0, 21000, 20, 0)
        tx2 = Transaction(self.alice, self.bob, 30.0, 21000, 20, 0)
        tx2.sign("private_key")
        
        self.blockchain.add_transaction(tx1)
        self.blockchain.add_transaction(tx2)
        self.blockchain.mine_pending_transactions("miner")
        
        self.assertEqual(self.blockchain.get_balance(self.alice), 70.0)
        self.assertEqual(self.blockchain.get_balance(self.bob), 30.0)

class TestSmartContract(unittest.TestCase):
    """æ™ºèƒ½åˆçº¦æµ‹è¯•ç±»"""
    
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.contract = TokenContract("contract", "TestToken", "TT", 1000.0)
    
    def test_token_transfer(self):
        """æµ‹è¯•ä»£å¸è½¬è´¦"""
        success = self.contract.transfer("contract", "alice", 100.0)
        self.assertTrue(success)
        self.assertEqual(self.contract.balance_of("alice"), 100.0)
    
    def test_insufficient_balance(self):
        """æµ‹è¯•ä½™é¢ä¸è¶³"""
        success = self.contract.transfer("alice", "bob", 200.0)
        self.assertFalse(success)

if __name__ == "__main__":
    unittest.main()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€ç†è®ºåŸºç¡€åˆ°Pythonå®ç°ï¼Œå…¨é¢é˜è¿°äº†åŒºå—é“¾æŠ€æœ¯çš„æ ¸å¿ƒæ¦‚å¿µã€‚ä¸»è¦å†…å®¹åŒ…æ‹¬ï¼š

### 7.1 ç†è®ºè´¡çŒ®

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†åŒºå—é“¾ç³»ç»Ÿã€åŒºå—ã€äº¤æ˜“çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **å®‰å…¨æ€§è¯æ˜**: è¯æ˜äº†åŒºå—é“¾çš„ä¸å¯ç¯¡æ”¹æ€§å’Œæ‹œå åº­å®¹é”™æ€§
3. **æ€§èƒ½åˆ†æ**: åˆ†æäº†æŒ–çŸ¿å’ŒéªŒè¯çš„æ—¶é—´å¤æ‚åº¦

### 7.2 å®ç°ç‰¹è‰²

1. **å®Œæ•´å®ç°**: æä¾›äº†åŒºå—é“¾ã€æ™ºèƒ½åˆçº¦ã€å…±è¯†æœºåˆ¶çš„å®Œæ•´Pythonå®ç°
2. **æ¨¡å—åŒ–è®¾è®¡**: é‡‡ç”¨æŠ½è±¡åŸºç±»å’Œæ¥å£è®¾è®¡ï¼Œæ”¯æŒæ‰©å±•
3. **å¹¶å‘å®‰å…¨**: ä½¿ç”¨é”æœºåˆ¶ä¿è¯å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„æ•°æ®ä¸€è‡´æ€§

### 7.3 åº”ç”¨ä»·å€¼

1. **æ•™è‚²ä»·å€¼**: ä¸ºå­¦ä¹ åŒºå—é“¾æŠ€æœ¯æä¾›å®Œæ•´çš„ç†è®ºæ¡†æ¶
2. **å®è·µä»·å€¼**: æä¾›äº†å¯ç›´æ¥è¿è¡Œçš„ä»£ç å®ç°
3. **ç ”ç©¶ä»·å€¼**: ä¸ºåŒºå—é“¾æŠ€æœ¯ç ”ç©¶æä¾›ç†è®ºåŸºç¡€

### 7.4 æŠ€æœ¯ç‰¹è‰²

1. **å¤šè¡¨å¾æ–¹æ³•**: æ¦‚å¿µè§£é‡Šã€æ•°å­¦å½¢å¼ã€ä»£ç å®ç°ã€å›¾è¡¨è¯´æ˜
2. **ä¸¥æ ¼è¯æ˜**: æ¯ä¸ªé‡è¦ç»“è®ºéƒ½æœ‰å½¢å¼åŒ–è¯æ˜
3. **æ€§èƒ½åˆ†æ**: è¯¦ç»†çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦åˆ†æ
4. **æµ‹è¯•éªŒè¯**: å®Œæ•´çš„å•å…ƒæµ‹è¯•å’ŒéªŒè¯

---

*æœ¬æ–‡æ¡£æ˜¯è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®—ç§‘å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„å­¦æœ¯è§„èŒƒå’Œå·¥ç¨‹æ ‡å‡†ã€‚*
