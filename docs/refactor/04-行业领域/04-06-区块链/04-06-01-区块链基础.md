# åŒºå—é“¾åŸºç¡€ç†è®º

## ğŸ“‹ æ¦‚è¿°

åŒºå—é“¾æ˜¯ä¸€ç§åˆ†å¸ƒå¼è´¦æœ¬æŠ€æœ¯ï¼Œé€šè¿‡å¯†ç å­¦ã€å…±è¯†æœºåˆ¶å’Œåˆ†å¸ƒå¼ç½‘ç»œå®ç°å»ä¸­å¿ƒåŒ–çš„æ•°æ®å­˜å‚¨å’Œäº¤æ˜“éªŒè¯ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°åŒºå—é“¾çš„åŸºç¡€æ¦‚å¿µã€å…±è¯†ç®—æ³•å’Œæ ¸å¿ƒæœºåˆ¶ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 åŒºå—é“¾å®šä¹‰

**å®šä¹‰ 1.1** (åŒºå—é“¾)
åŒºå—é“¾æ˜¯ä¸€ä¸ªå…­å…ƒç»„ï¼š
$$\text{Blockchain} = (B, N, C, T, V, S)$$

å…¶ä¸­ï¼š
- $B = \{b_1, b_2, \ldots, b_n\}$ æ˜¯åŒºå—é›†åˆ
- $N = \{n_1, n_2, \ldots, n_m\}$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $C$ æ˜¯å…±è¯†æœºåˆ¶
- $T = \{t_1, t_2, \ldots, t_k\}$ æ˜¯äº¤æ˜“é›†åˆ
- $V$ æ˜¯éªŒè¯å‡½æ•°
- $S$ æ˜¯çŠ¶æ€å‡½æ•°

### 1.2 åŒºå—å®šä¹‰

**å®šä¹‰ 1.2** (åŒºå—)
åŒºå—æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\text{Block} = (h, p, t, s, d)$$

å…¶ä¸­ï¼š
- $h$ æ˜¯åŒºå—å“ˆå¸Œ
- $p$ æ˜¯å‰ä¸€ä¸ªåŒºå—å“ˆå¸Œ
- $t$ æ˜¯æ—¶é—´æˆ³
- $s$ æ˜¯çŠ¶æ€æ ¹
- $d$ æ˜¯æ•°æ®

### 1.3 äº¤æ˜“å®šä¹‰

**å®šä¹‰ 1.3** (äº¤æ˜“)
äº¤æ˜“æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$\text{Transaction} = (f, t, v, s)$$

å…¶ä¸­ï¼š
- $f$ æ˜¯å‘é€æ–¹åœ°å€
- $t$ æ˜¯æ¥æ”¶æ–¹åœ°å€
- $v$ æ˜¯äº¤æ˜“å€¼
- $s$ æ˜¯ç­¾å

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 å…±è¯†æœºåˆ¶

**å®šä¹‰ 2.1** (å…±è¯†æœºåˆ¶)
å…±è¯†æœºåˆ¶æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$\text{Consensus}: \text{Proposal} \times \text{Network} \rightarrow \text{Decision}$$

**ç®—æ³• 2.1** (å·¥ä½œé‡è¯æ˜)
```python
def proof_of_work(block: Block, difficulty: int) -> int:
    """
    å·¥ä½œé‡è¯æ˜ç®—æ³•
    
    å‚æ•°:
        block: åŒºå—
        difficulty: éš¾åº¦å€¼
        
    è¿”å›:
        æ»¡è¶³æ¡ä»¶çš„nonceå€¼
    """
    nonce = 0
    target = "0" * difficulty
    
    while True:
        block.nonce = nonce
        block_hash = block.calculate_hash()
        
        if block_hash.startswith(target):
            return nonce
        
        nonce += 1
```

### 2.2 å¯†ç å­¦åŸºç¡€

**å®šä¹‰ 2.2** (å“ˆå¸Œå‡½æ•°)
å“ˆå¸Œå‡½æ•°ï¼š
$$H: \{0,1\}^* \rightarrow \{0,1\}^{256}$$

**æ€§è´¨ 2.1** (å“ˆå¸Œå‡½æ•°æ€§è´¨)
1. **ç¡®å®šæ€§**: $H(x) = H(x)$
2. **é›ªå´©æ•ˆåº”**: è¾“å…¥çš„å¾®å°å˜åŒ–å¯¼è‡´è¾“å‡ºçš„å·¨å¤§å˜åŒ–
3. **å•å‘æ€§**: ä» $H(x)$ éš¾ä»¥è®¡ç®— $x$

## 3. Pythonå®ç°

### 3.1 åŒºå—é“¾æ ¸å¿ƒå®ç°

```python
from typing import List, Dict, Optional, Any
from dataclasses import dataclass
from abc import ABC, abstractmethod
import hashlib
import time
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding

@dataclass
class Transaction:
    """äº¤æ˜“"""
    sender: str
    recipient: str
    amount: float
    signature: Optional[str] = None
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()
    
    def to_dict(self) -> Dict:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'sender': self.sender,
            'recipient': self.recipient,
            'amount': self.amount,
            'timestamp': self.timestamp
        }
    
    def calculate_hash(self) -> str:
        """è®¡ç®—äº¤æ˜“å“ˆå¸Œ"""
        transaction_string = json.dumps(self.to_dict(), sort_keys=True)
        return hashlib.sha256(transaction_string.encode()).hexdigest()
    
    def sign(self, private_key: rsa.RSAPrivateKey):
        """ç­¾åäº¤æ˜“"""
        transaction_hash = self.calculate_hash()
        signature = private_key.sign(
            transaction_hash.encode(),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        self.signature = signature.hex()
    
    def verify_signature(self, public_key: rsa.RSAPublicKey) -> bool:
        """éªŒè¯ç­¾å"""
        if not self.signature:
            return False
        
        try:
            public_key.verify(
                bytes.fromhex(self.signature),
                self.calculate_hash().encode(),
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except:
            return False

@dataclass
class Block:
    """åŒºå—"""
    index: int
    timestamp: float
    transactions: List[Transaction]
    previous_hash: str
    nonce: int = 0
    hash: Optional[str] = None
    
    def calculate_hash(self) -> str:
        """è®¡ç®—åŒºå—å“ˆå¸Œ"""
        block_string = json.dumps({
            'index': self.index,
            'timestamp': self.timestamp,
            'transactions': [tx.to_dict() for tx in self.transactions],
            'previous_hash': self.previous_hash,
            'nonce': self.nonce
        }, sort_keys=True)
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def mine(self, difficulty: int):
        """æŒ–çŸ¿"""
        target = "0" * difficulty
        
        while True:
            self.hash = self.calculate_hash()
            if self.hash.startswith(target):
                break
            self.nonce += 1

class Blockchain:
    """åŒºå—é“¾"""
    
    def __init__(self, difficulty: int = 4):
        self.chain: List[Block] = []
        self.pending_transactions: List[Transaction] = []
        self.difficulty = difficulty
        self.mining_reward = 10.0
        
        # åˆ›å»ºåˆ›ä¸–åŒºå—
        self.create_genesis_block()
    
    def create_genesis_block(self):
        """åˆ›å»ºåˆ›ä¸–åŒºå—"""
        genesis_block = Block(
            index=0,
            timestamp=time.time(),
            transactions=[],
            previous_hash="0"
        )
        genesis_block.hash = genesis_block.calculate_hash()
        self.chain.append(genesis_block)
    
    def get_latest_block(self) -> Block:
        """è·å–æœ€æ–°åŒºå—"""
        return self.chain[-1]
    
    def add_transaction(self, transaction: Transaction) -> bool:
        """æ·»åŠ äº¤æ˜“"""
        # éªŒè¯äº¤æ˜“
        if not self.verify_transaction(transaction):
            return False
        
        self.pending_transactions.append(transaction)
        return True
    
    def verify_transaction(self, transaction: Transaction) -> bool:
        """éªŒè¯äº¤æ˜“"""
        # æ£€æŸ¥ä½™é¢
        if not self.has_sufficient_balance(transaction.sender, transaction.amount):
            return False
        
        # éªŒè¯ç­¾å
        if not transaction.verify_signature(self.get_public_key(transaction.sender)):
            return False
        
        return True
    
    def has_sufficient_balance(self, address: str, amount: float) -> bool:
        """æ£€æŸ¥ä½™é¢æ˜¯å¦è¶³å¤Ÿ"""
        balance = self.get_balance(address)
        return balance >= amount
    
    def get_balance(self, address: str) -> float:
        """è·å–åœ°å€ä½™é¢"""
        balance = 0.0
        
        for block in self.chain:
            for transaction in block.transactions:
                if transaction.recipient == address:
                    balance += transaction.amount
                if transaction.sender == address:
                    balance -= transaction.amount
        
        return balance
    
    def mine_pending_transactions(self, miner_address: str):
        """æŒ–çŸ¿"""
        # åˆ›å»ºæ–°åŒºå—
        block = Block(
            index=len(self.chain),
            timestamp=time.time(),
            transactions=self.pending_transactions,
            previous_hash=self.get_latest_block().hash
        )
        
        # æŒ–çŸ¿
        block.mine(self.difficulty)
        
        # æ·»åŠ æŒ–çŸ¿å¥–åŠ±
        reward_transaction = Transaction(
            sender="System",
            recipient=miner_address,
            amount=self.mining_reward
        )
        self.pending_transactions = [reward_transaction]
        
        # æ·»åŠ åˆ°é“¾ä¸Š
        self.chain.append(block)
    
    def is_chain_valid(self) -> bool:
        """éªŒè¯é“¾çš„æœ‰æ•ˆæ€§"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            # éªŒè¯å½“å‰åŒºå—å“ˆå¸Œ
            if current_block.hash != current_block.calculate_hash():
                return False
            
            # éªŒè¯å‰ä¸€ä¸ªåŒºå—å“ˆå¸Œ
            if current_block.previous_hash != previous_block.hash:
                return False
        
        return True
    
    def get_public_key(self, address: str) -> Optional[rsa.RSAPublicKey]:
        """è·å–å…¬é’¥ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # å®é™…å®ç°ä¸­åº”è¯¥ä»å¯†é’¥ç®¡ç†ç³»ç»Ÿä¸­è·å–
        return None

class ConsensusMechanism(ABC):
    """å…±è¯†æœºåˆ¶æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def validate_block(self, block: Block, blockchain: Blockchain) -> bool:
        """éªŒè¯åŒºå—"""
        pass
    
    @abstractmethod
    def select_leader(self, nodes: List[str]) -> str:
        """é€‰æ‹©é¢†å¯¼è€…"""
        pass

class ProofOfWork(ConsensusMechanism):
    """å·¥ä½œé‡è¯æ˜å…±è¯†æœºåˆ¶"""
    
    def __init__(self, difficulty: int):
        self.difficulty = difficulty
    
    def validate_block(self, block: Block, blockchain: Blockchain) -> bool:
        """éªŒè¯åŒºå—"""
        # éªŒè¯å“ˆå¸Œ
        if block.hash != block.calculate_hash():
            return False
        
        # éªŒè¯å·¥ä½œé‡è¯æ˜
        target = "0" * self.difficulty
        if not block.hash.startswith(target):
            return False
        
        # éªŒè¯å‰ä¸€ä¸ªåŒºå—å“ˆå¸Œ
        if block.previous_hash != blockchain.get_latest_block().hash:
            return False
        
        return True
    
    def select_leader(self, nodes: List[str]) -> str:
        """é€‰æ‹©é¢†å¯¼è€…ï¼ˆPoWä¸­é€šè¿‡æŒ–çŸ¿ç«äº‰ï¼‰"""
        # PoWä¸­é€šè¿‡è®¡ç®—èƒ½åŠ›ç«äº‰ï¼Œè¿™é‡Œç®€åŒ–å®ç°
        import random
        return random.choice(nodes)

class ProofOfStake(ConsensusMechanism):
    """æƒç›Šè¯æ˜å…±è¯†æœºåˆ¶"""
    
    def __init__(self):
        self.stakes: Dict[str, float] = {}
    
    def add_stake(self, address: str, amount: float):
        """æ·»åŠ æƒç›Š"""
        self.stakes[address] = self.stakes.get(address, 0) + amount
    
    def validate_block(self, block: Block, blockchain: Blockchain) -> bool:
        """éªŒè¯åŒºå—"""
        # éªŒè¯å“ˆå¸Œ
        if block.hash != block.calculate_hash():
            return False
        
        # éªŒè¯å‰ä¸€ä¸ªåŒºå—å“ˆå¸Œ
        if block.previous_hash != blockchain.get_latest_block().hash:
            return False
        
        return True
    
    def select_leader(self, nodes: List[str]) -> str:
        """é€‰æ‹©é¢†å¯¼è€…ï¼ˆåŸºäºæƒç›Šï¼‰"""
        total_stake = sum(self.stakes.get(node, 0) for node in nodes)
        if total_stake == 0:
            return nodes[0] if nodes else None
        
        # åŸºäºæƒç›Šæƒé‡éšæœºé€‰æ‹©
        import random
        weights = [self.stakes.get(node, 0) / total_stake for node in nodes]
        return random.choices(nodes, weights=weights)[0]

class SmartContract:
    """æ™ºèƒ½åˆçº¦"""
    
    def __init__(self, contract_id: str, code: str):
        self.contract_id = contract_id
        self.code = code
        self.state: Dict[str, Any] = {}
    
    def execute(self, function_name: str, parameters: Dict[str, Any]) -> Any:
        """æ‰§è¡Œåˆçº¦å‡½æ•°"""
        # ç®€åŒ–çš„åˆçº¦æ‰§è¡Œ
        if function_name == "transfer":
            return self._transfer(parameters)
        elif function_name == "get_balance":
            return self._get_balance(parameters)
        else:
            raise ValueError(f"æœªçŸ¥å‡½æ•°: {function_name}")
    
    def _transfer(self, parameters: Dict[str, Any]) -> bool:
        """è½¬è´¦å‡½æ•°"""
        from_address = parameters.get("from")
        to_address = parameters.get("to")
        amount = parameters.get("amount", 0)
        
        if from_address not in self.state:
            self.state[from_address] = 0
        if to_address not in self.state:
            self.state[to_address] = 0
        
        if self.state[from_address] >= amount:
            self.state[from_address] -= amount
            self.state[to_address] += amount
            return True
        return False
    
    def _get_balance(self, parameters: Dict[str, Any]) -> float:
        """è·å–ä½™é¢å‡½æ•°"""
        address = parameters.get("address")
        return self.state.get(address, 0)

class Node:
    """åŒºå—é“¾èŠ‚ç‚¹"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.blockchain = Blockchain()
        self.consensus = ProofOfWork(difficulty=4)
        self.peers: List[str] = []
        self.pending_transactions: List[Transaction] = []
    
    def add_peer(self, peer_id: str):
        """æ·»åŠ å¯¹ç­‰èŠ‚ç‚¹"""
        if peer_id not in self.peers:
            self.peers.append(peer_id)
    
    def broadcast_transaction(self, transaction: Transaction):
        """å¹¿æ’­äº¤æ˜“"""
        # ç®€åŒ–çš„å¹¿æ’­å®ç°
        for peer in self.peers:
            # å®é™…å®ç°ä¸­åº”è¯¥é€šè¿‡ç½‘ç»œå‘é€
            pass
    
    def receive_transaction(self, transaction: Transaction):
        """æ¥æ”¶äº¤æ˜“"""
        if self.blockchain.add_transaction(transaction):
            self.pending_transactions.append(transaction)
    
    def mine_block(self):
        """æŒ–çŸ¿"""
        self.blockchain.mine_pending_transactions(self.node_id)
    
    def validate_block(self, block: Block) -> bool:
        """éªŒè¯åŒºå—"""
        return self.consensus.validate_block(block, self.blockchain)
    
    def add_block(self, block: Block):
        """æ·»åŠ åŒºå—"""
        if self.validate_block(block):
            self.blockchain.chain.append(block)
            return True
        return False
```

### 3.2 ç½‘ç»œé€šä¿¡å®ç°

```python
class NetworkMessage:
    """ç½‘ç»œæ¶ˆæ¯"""
    
    def __init__(self, message_type: str, data: Any, sender: str):
        self.message_type = message_type
        self.data = data
        self.sender = sender
        self.timestamp = time.time()

class NetworkNode:
    """ç½‘ç»œèŠ‚ç‚¹"""
    
    def __init__(self, node_id: str, port: int):
        self.node_id = node_id
        self.port = port
        self.connections: Dict[str, 'Connection'] = {}
        self.message_handlers: Dict[str, callable] = {}
    
    def connect_to(self, peer_id: str, peer_host: str, peer_port: int):
        """è¿æ¥åˆ°å¯¹ç­‰èŠ‚ç‚¹"""
        connection = Connection(self.node_id, peer_id, peer_host, peer_port)
        self.connections[peer_id] = connection
    
    def send_message(self, peer_id: str, message: NetworkMessage):
        """å‘é€æ¶ˆæ¯"""
        if peer_id in self.connections:
            self.connections[peer_id].send(message)
    
    def broadcast_message(self, message: NetworkMessage):
        """å¹¿æ’­æ¶ˆæ¯"""
        for peer_id in self.connections:
            self.send_message(peer_id, message)
    
    def handle_message(self, message: NetworkMessage):
        """å¤„ç†æ¶ˆæ¯"""
        handler = self.message_handlers.get(message.message_type)
        if handler:
            handler(message)
    
    def register_handler(self, message_type: str, handler: callable):
        """æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨"""
        self.message_handlers[message_type] = handler

class Connection:
    """è¿æ¥"""
    
    def __init__(self, local_id: str, remote_id: str, host: str, port: int):
        self.local_id = local_id
        self.remote_id = remote_id
        self.host = host
        self.port = port
        self.connected = False
    
    def send(self, message: NetworkMessage):
        """å‘é€æ¶ˆæ¯"""
        # ç®€åŒ–çš„ç½‘ç»œå‘é€å®ç°
        if self.connected:
            # å®é™…å®ç°ä¸­åº”è¯¥é€šè¿‡ç½‘ç»œåè®®å‘é€
            pass
    
    def receive(self) -> Optional[NetworkMessage]:
        """æ¥æ”¶æ¶ˆæ¯"""
        # ç®€åŒ–çš„ç½‘ç»œæ¥æ”¶å®ç°
        return None
```

## 4. ç†è®ºè¯æ˜

### 4.1 åŒºå—é“¾å®‰å…¨æ€§

**å®šç† 4.1** (åŒºå—é“¾å®‰å…¨æ€§)
åœ¨è¯šå®èŠ‚ç‚¹å å¤šæ•°çš„æƒ…å†µä¸‹ï¼ŒåŒºå—é“¾èƒ½å¤Ÿä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œä¸å¯ç¯¡æ”¹æ€§ã€‚

**è¯æ˜**:
1. **ä¸€è‡´æ€§**: é€šè¿‡å…±è¯†æœºåˆ¶ç¡®ä¿æ‰€æœ‰èŠ‚ç‚¹å¯¹åŒºå—é“¾çŠ¶æ€è¾¾æˆä¸€è‡´
2. **ä¸å¯ç¯¡æ”¹æ€§**: ä¿®æ”¹å†å²åŒºå—éœ€è¦é‡æ–°è®¡ç®—æ‰€æœ‰åç»­åŒºå—çš„å·¥ä½œé‡è¯æ˜
3. **å®‰å…¨æ€§**: æ”»å‡»è€…éœ€è¦æ§åˆ¶è¶…è¿‡50%çš„è®¡ç®—èƒ½åŠ›æ‰èƒ½è¿›è¡ŒåŒèŠ±æ”»å‡»

### 4.2 å·¥ä½œé‡è¯æ˜æ­£ç¡®æ€§

**å®šç† 4.2** (å·¥ä½œé‡è¯æ˜æ­£ç¡®æ€§)
å·¥ä½œé‡è¯æ˜ç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°æ»¡è¶³éš¾åº¦è¦æ±‚çš„nonceå€¼ã€‚

**è¯æ˜**:
1. **å­˜åœ¨æ€§**: ç”±äºå“ˆå¸Œå‡½æ•°çš„éšæœºæ€§ï¼Œå­˜åœ¨æ»¡è¶³æ¡ä»¶çš„nonce
2. **å”¯ä¸€æ€§**: æ¯ä¸ªåŒºå—çš„nonceæ˜¯å”¯ä¸€çš„
3. **éš¾åº¦è°ƒæ•´**: é€šè¿‡è°ƒæ•´éš¾åº¦å€¼æ§åˆ¶æŒ–çŸ¿é€Ÿåº¦

## 5. æ€§èƒ½åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦

- **åŒºå—éªŒè¯**: $O(n)$ å…¶ä¸­ $n$ æ˜¯äº¤æ˜“æ•°é‡
- **æŒ–çŸ¿**: $O(2^d)$ å…¶ä¸­ $d$ æ˜¯éš¾åº¦å€¼
- **äº¤æ˜“éªŒè¯**: $O(1)$ å•ç¬”äº¤æ˜“éªŒè¯

### 5.2 ç©ºé—´å¤æ‚åº¦

- **åŒºå—é“¾å­˜å‚¨**: $O(b \times n)$ å…¶ä¸­ $b$ æ˜¯åŒºå—æ•°ï¼Œ$n$ æ˜¯æ¯å—äº¤æ˜“æ•°
- **äº¤æ˜“æ± **: $O(t)$ å…¶ä¸­ $t$ æ˜¯å¾…å¤„ç†äº¤æ˜“æ•°
- **ç½‘ç»œæ¶ˆæ¯**: $O(m)$ å…¶ä¸­ $m$ æ˜¯æ¶ˆæ¯æ•°

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 åŠ å¯†è´§å¸å®ç°

```python
def create_cryptocurrency():
    """åˆ›å»ºåŠ å¯†è´§å¸"""
    # åˆ›å»ºåŒºå—é“¾
    blockchain = Blockchain(difficulty=4)
    
    # åˆ›å»ºèŠ‚ç‚¹
    alice = Node("alice")
    bob = Node("bob")
    charlie = Node("charlie")
    
    # è¿æ¥èŠ‚ç‚¹
    alice.add_peer("bob")
    alice.add_peer("charlie")
    bob.add_peer("alice")
    bob.add_peer("charlie")
    charlie.add_peer("alice")
    charlie.add_peer("bob")
    
    # åˆ›å»ºäº¤æ˜“
    transaction1 = Transaction("alice", "bob", 50.0)
    transaction2 = Transaction("bob", "charlie", 30.0)
    
    # æ·»åŠ äº¤æ˜“
    blockchain.add_transaction(transaction1)
    blockchain.add_transaction(transaction2)
    
    # æŒ–çŸ¿
    alice.mine_block()
    
    # éªŒè¯é“¾
    print(f"åŒºå—é“¾æœ‰æ•ˆ: {blockchain.is_chain_valid()}")
    print(f"Aliceä½™é¢: {blockchain.get_balance('alice')}")
    print(f"Bobä½™é¢: {blockchain.get_balance('bob')}")
    print(f"Charlieä½™é¢: {blockchain.get_balance('charlie')}")

if __name__ == "__main__":
    create_cryptocurrency()
```

### 6.2 æ™ºèƒ½åˆçº¦ç¤ºä¾‹

```python
def smart_contract_example():
    """æ™ºèƒ½åˆçº¦ç¤ºä¾‹"""
    # åˆ›å»ºæ™ºèƒ½åˆçº¦
    contract = SmartContract("token_contract", "ERC20")
    
    # åˆå§‹åŒ–ä½™é¢
    contract.state["alice"] = 1000
    contract.state["bob"] = 500
    
    # æ‰§è¡Œè½¬è´¦
    result1 = contract.execute("transfer", {
        "from": "alice",
        "to": "bob",
        "amount": 200
    })
    
    result2 = contract.execute("transfer", {
        "from": "bob",
        "to": "charlie",
        "amount": 100
    })
    
    # æŸ¥è¯¢ä½™é¢
    alice_balance = contract.execute("get_balance", {"address": "alice"})
    bob_balance = contract.execute("get_balance", {"address": "bob"})
    charlie_balance = contract.execute("get_balance", {"address": "charlie"})
    
    print(f"è½¬è´¦ç»“æœ: {result1}, {result2}")
    print(f"Aliceä½™é¢: {alice_balance}")
    print(f"Bobä½™é¢: {bob_balance}")
    print(f"Charlieä½™é¢: {charlie_balance}")

if __name__ == "__main__":
    smart_contract_example()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°äº†åŒºå—é“¾çš„æ ¸å¿ƒæ¦‚å¿µï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: åŒºå—é“¾ã€åŒºå—ã€äº¤æ˜“çš„å½¢å¼åŒ–å®šä¹‰
2. **æ ¸å¿ƒæ¦‚å¿µ**: å…±è¯†æœºåˆ¶ã€å¯†ç å­¦åŸºç¡€
3. **Pythonå®ç°**: å®Œæ•´çš„åŒºå—é“¾ã€å…±è¯†æœºåˆ¶ã€æ™ºèƒ½åˆçº¦å®ç°
4. **ç†è®ºè¯æ˜**: å®‰å…¨æ€§å’Œæ­£ç¡®æ€§è¯æ˜
5. **åº”ç”¨ç¤ºä¾‹**: åŠ å¯†è´§å¸å’Œæ™ºèƒ½åˆçº¦ç¤ºä¾‹

åŒºå—é“¾æŠ€æœ¯ä¸ºå»ä¸­å¿ƒåŒ–åº”ç”¨æä¾›äº†å®‰å…¨å¯é çš„åŸºç¡€ï¼Œé€šè¿‡å¯†ç å­¦å’Œå…±è¯†æœºåˆ¶ç¡®ä¿æ•°æ®çš„å¯ä¿¡æ€§å’Œä¸€è‡´æ€§ã€‚

---

*æœ¬æ–‡æ¡£æ˜¯è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®—ç§‘å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„å½¢å¼åŒ–è§„èŒƒå’Œå­¦æœ¯æ ‡å‡†ã€‚* 