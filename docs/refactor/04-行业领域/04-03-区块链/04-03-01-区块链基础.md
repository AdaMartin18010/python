# 04-03-01 åŒºå—é“¾åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

åŒºå—é“¾æ˜¯ä¸€ç§åˆ†å¸ƒå¼è´¦æœ¬æŠ€æœ¯ï¼Œé€šè¿‡å¯†ç å­¦ã€å…±è¯†æœºåˆ¶å’Œåˆ†å¸ƒå¼ç½‘ç»œå®ç°å»ä¸­å¿ƒåŒ–çš„æ•°æ®å­˜å‚¨å’Œäº¤æ˜“éªŒè¯ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»åŒºå—é“¾çš„åŸºç¡€ç†è®ºã€æ ¸å¿ƒç®—æ³•å’ŒPythonå®ç°ï¼ŒåŒ…æ‹¬å¯†ç å­¦åŸºç¡€ã€å…±è¯†æœºåˆ¶ã€æ™ºèƒ½åˆçº¦ç­‰ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

1. **ç†è§£åŒºå—é“¾åŸç†**ï¼šæŒæ¡åŒºå—é“¾çš„åŸºæœ¬åŸç†å’Œæ•°å­¦åŸºç¡€
2. **æŒæ¡å¯†ç å­¦ç®—æ³•**ï¼šç†è§£å“ˆå¸Œå‡½æ•°ã€æ•°å­—ç­¾åã€å…¬é’¥å¯†ç å­¦
3. **å®ç°æ ¸å¿ƒç»„ä»¶**ï¼šç”¨Pythonå®ç°åŒºå—é“¾çš„æ ¸å¿ƒç»„ä»¶
4. **åº”ç”¨å®è·µ**ï¼šæŒæ¡åŒºå—é“¾åœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

- [1. åŒºå—é“¾åŸºç¡€æ¦‚å¿µ](#1-åŒºå—é“¾åŸºç¡€æ¦‚å¿µ)
- [2. å¯†ç å­¦åŸºç¡€](#2-å¯†ç å­¦åŸºç¡€)
- [3. å…±è¯†æœºåˆ¶](#3-å…±è¯†æœºåˆ¶)
- [4. æ™ºèƒ½åˆçº¦](#4-æ™ºèƒ½åˆçº¦)
- [5. Pythonå®ç°](#5-pythonå®ç°)
- [6. å®è·µåº”ç”¨](#6-å®è·µåº”ç”¨)
- [7. æ€»ç»“](#7-æ€»ç»“)

---

## 1. åŒºå—é“¾åŸºç¡€æ¦‚å¿µ

### 1.1 åŒºå—é“¾å®šä¹‰

#### 1.1.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 1.1** (åŒºå—é“¾)
åŒºå—é“¾æ˜¯ä¸€ä¸ªæœ‰åºçš„ã€ä¸å¯ç¯¡æ”¹çš„äº¤æ˜“è®°å½•é“¾ï¼Œæ¯ä¸ªåŒºå—åŒ…å«ï¼š

$$Block_i = (Header_i, Transactions_i)$$

å…¶ä¸­ï¼š

- $Header_i = (Hash_{i-1}, Timestamp_i, Nonce_i, MerkleRoot_i)$
- $Hash_i = H(Header_i)$
- $H$ æ˜¯å¯†ç å­¦å“ˆå¸Œå‡½æ•°

**å®šä¹‰ 1.2** (åŒºå—é“¾ç»“æ„)
åŒºå—é“¾æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œæ»¡è¶³ï¼š

$$Block_i \rightarrow Block_{i+1} \quad \forall i \geq 0$$

å…¶ä¸­ $\rightarrow$ è¡¨ç¤ºå“ˆå¸ŒæŒ‡é’ˆå…³ç³»ã€‚

### 1.2 åŒºå—ç»“æ„

#### 1.2.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 1.3** (åŒºå—å¤´)
åŒºå—å¤´åŒ…å«ä»¥ä¸‹å­—æ®µï¼š

$$Header = (Version, PreviousHash, MerkleRoot, Timestamp, Difficulty, Nonce)$$

**å®šä¹‰ 1.4** (é»˜å…‹å°”æ ‘)
é»˜å…‹å°”æ ‘æ˜¯ä¸€ä¸ªäºŒå‰æ ‘ï¼Œå…¶ä¸­ï¼š

$$MerkleRoot = H(H(Tx_1 || Tx_2) || H(Tx_3 || Tx_4))$$

å…¶ä¸­ $||$ è¡¨ç¤ºè¿æ¥æ“ä½œã€‚

### 1.3 äº¤æ˜“ç»“æ„

#### 1.3.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 1.5** (äº¤æ˜“)
äº¤æ˜“æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„ï¼š

$$Transaction = (From, To, Amount, Signature, Timestamp)$$

å…¶ä¸­ $Signature$ æ˜¯å‘é€è€…çš„æ•°å­—ç­¾åã€‚

**å®šä¹‰ 1.6** (äº¤æ˜“éªŒè¯)
äº¤æ˜“éªŒè¯å‡½æ•°ï¼š

$$Verify(Tx) = VerifySignature(Tx.Signature, Tx.From, H(Tx.Data))$$

## 2. å¯†ç å­¦åŸºç¡€

### 2.1 å“ˆå¸Œå‡½æ•°

#### 2.1.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 2.1** (å¯†ç å­¦å“ˆå¸Œå‡½æ•°)
å¯†ç å­¦å“ˆå¸Œå‡½æ•° $H: \{0,1\}^* \rightarrow \{0,1\}^n$ æ»¡è¶³ï¼š

1. **ç¡®å®šæ€§**ï¼š$H(x) = H(x)$
2. **å¿«é€Ÿè®¡ç®—**ï¼š$H(x)$ å¯åœ¨å¤šé¡¹å¼æ—¶é—´å†…è®¡ç®—
3. **æŠ—ç¢°æ’æ€§**ï¼šéš¾ä»¥æ‰¾åˆ° $x \neq y$ ä½¿å¾— $H(x) = H(y)$
4. **æŠ—åŸåƒæ€§**ï¼šç»™å®š $y$ï¼Œéš¾ä»¥æ‰¾åˆ° $x$ ä½¿å¾— $H(x) = y$

**å®šä¹‰ 2.2** (SHA-256)
SHA-256æ˜¯ä¸€ä¸ª256ä½çš„å“ˆå¸Œå‡½æ•°ï¼š

$$SHA256(x) = h_{256}(x)$$

å…¶ä¸­ $h_{256}$ æ˜¯SHA-256ç®—æ³•ã€‚

### 2.2 å…¬é’¥å¯†ç å­¦

#### 2.2.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 2.3** (æ¤­åœ†æ›²çº¿)
æ¤­åœ†æ›²çº¿æ–¹ç¨‹ï¼š

$$y^2 = x^3 + ax + b \pmod{p}$$

å…¶ä¸­ $a, b, p$ æ˜¯å‚æ•°ã€‚

**å®šä¹‰ 2.4** (æ¤­åœ†æ›²çº¿æ•°å­—ç­¾åç®—æ³•)
ECDSAç­¾åè¿‡ç¨‹ï¼š

1. é€‰æ‹©éšæœºæ•° $k \in [1, n-1]$
2. è®¡ç®— $R = k \cdot G = (x_R, y_R)$
3. è®¡ç®— $r = x_R \pmod{n}$
4. è®¡ç®— $s = k^{-1}(H(m) + r \cdot d) \pmod{n}$
5. ç­¾åä¸º $(r, s)$

**å®šä¹‰ 2.5** (ECDSAéªŒè¯)
ECDSAéªŒè¯è¿‡ç¨‹ï¼š

1. è®¡ç®— $w = s^{-1} \pmod{n}$
2. è®¡ç®— $u_1 = H(m) \cdot w \pmod{n}$
3. è®¡ç®— $u_2 = r \cdot w \pmod{n}$
4. è®¡ç®— $P = u_1 \cdot G + u_2 \cdot Q$
5. éªŒè¯ $r = x_P \pmod{n}$

### 2.3 é›¶çŸ¥è¯†è¯æ˜

#### 2.3.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 2.6** (é›¶çŸ¥è¯†è¯æ˜)
é›¶çŸ¥è¯†è¯æ˜æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(P, V, \pi)$ï¼Œæ»¡è¶³ï¼š

1. **å®Œå¤‡æ€§**ï¼šå¦‚æœé™ˆè¿°ä¸ºçœŸï¼Œè¯šå®éªŒè¯è€…æ¥å—è¯æ˜
2. **å¯é æ€§**ï¼šå¦‚æœé™ˆè¿°ä¸ºå‡ï¼Œä»»ä½•è¯æ˜è€…éƒ½æ— æ³•è®©éªŒè¯è€…æ¥å—
3. **é›¶çŸ¥è¯†æ€§**ï¼šéªŒè¯è€…æ— æ³•è·å¾—é™¤é™ˆè¿°ä¸ºçœŸä¹‹å¤–çš„ä»»ä½•ä¿¡æ¯

## 3. å…±è¯†æœºåˆ¶

### 3.1 å·¥ä½œé‡è¯æ˜

#### 3.1.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 3.1** (å·¥ä½œé‡è¯æ˜)
å·¥ä½œé‡è¯æ˜è¦æ±‚æ‰¾åˆ°ä¸€ä¸ª $Nonce$ ä½¿å¾—ï¼š

$$H(Header || Nonce) < Target$$

å…¶ä¸­ $Target$ æ˜¯ç›®æ ‡éš¾åº¦å€¼ã€‚

**å®šä¹‰ 3.2** (éš¾åº¦è°ƒæ•´)
éš¾åº¦è°ƒæ•´å…¬å¼ï¼š

$$Target_{new} = Target_{old} \cdot \frac{ActualTime}{ExpectedTime}$$

å…¶ä¸­ $ExpectedTime$ æ˜¯æœŸæœ›çš„åŒºå—ç”Ÿæˆæ—¶é—´ã€‚

### 3.2 æƒç›Šè¯æ˜

#### 3.2.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 3.3** (æƒç›Šè¯æ˜)
æƒç›Šè¯æ˜çš„éªŒè¯è€…é€‰æ‹©æ¦‚ç‡ï¼š

$$P(Validator_i) = \frac{Stake_i}{\sum_{j} Stake_j}$$

å…¶ä¸­ $Stake_i$ æ˜¯éªŒè¯è€… $i$ çš„æƒç›Šã€‚

**å®šä¹‰ 3.4** (æƒç›Šè¯æ˜å¥–åŠ±)
æƒç›Šè¯æ˜å¥–åŠ±ï¼š

$$Reward = BaseReward \cdot \frac{Stake}{TotalStake}$$

### 3.3 æ‹œå åº­å®¹é”™

#### 3.3.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 3.5** (æ‹œå åº­å®¹é”™)
æ‹œå åº­å®¹é”™è¦æ±‚ï¼š

$$n \geq 3f + 1$$

å…¶ä¸­ $n$ æ˜¯æ€»èŠ‚ç‚¹æ•°ï¼Œ$f$ æ˜¯æ‹œå åº­èŠ‚ç‚¹æ•°ã€‚

**å®šç† 3.1** (æ‹œå åº­å®¹é”™å®šç†)
åœ¨åŒæ­¥ç½‘ç»œä¸­ï¼Œå¦‚æœ $n \geq 3f + 1$ï¼Œåˆ™å­˜åœ¨æ‹œå åº­å®¹é”™ç®—æ³•ã€‚

## 4. æ™ºèƒ½åˆçº¦

### 4.1 æ™ºèƒ½åˆçº¦å®šä¹‰

#### 4.1.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 4.1** (æ™ºèƒ½åˆçº¦)
æ™ºèƒ½åˆçº¦æ˜¯ä¸€ä¸ªè‡ªåŠ¨æ‰§è¡Œçš„ç¨‹åºï¼š

$$Contract = (Code, State, Functions)$$

å…¶ä¸­ï¼š

- $Code$ æ˜¯åˆçº¦ä»£ç 
- $State$ æ˜¯åˆçº¦çŠ¶æ€
- $Functions$ æ˜¯å¯è°ƒç”¨çš„å‡½æ•°é›†åˆ

**å®šä¹‰ 4.2** (åˆçº¦æ‰§è¡Œ)
åˆçº¦æ‰§è¡Œå‡½æ•°ï¼š

$$Execute(Contract, Function, Args) = (NewState, Events)$$

### 4.2 å›¾çµå®Œå¤‡æ€§

#### 4.2.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 4.3** (å›¾çµå®Œå¤‡æ€§)
å¦‚æœä¸€ç§ç¼–ç¨‹è¯­è¨€å¯ä»¥æ¨¡æ‹Ÿå›¾çµæœºï¼Œåˆ™ç§°å…¶ä¸ºå›¾çµå®Œå¤‡çš„ã€‚

**å®šç† 4.1** (ä»¥å¤ªåŠå›¾çµå®Œå¤‡æ€§)
ä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆEVMï¼‰æ˜¯å›¾çµå®Œå¤‡çš„ã€‚

## 5. Pythonå®ç°

### 5.1 åŸºç¡€æ¡†æ¶

```python
"""
åŒºå—é“¾åŸºç¡€å®ç°
ä½œè€…ï¼šAIåŠ©æ‰‹
æ—¥æœŸï¼š2024å¹´
ç‰ˆæœ¬ï¼š1.0
"""

from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Tuple, Union
import hashlib
import json
import time
from dataclasses import dataclass, field
from enum import Enum
import hmac
import secrets
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec, utils
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import warnings
warnings.filterwarnings('ignore')

@dataclass
class Transaction:
    """äº¤æ˜“ç±»"""
    sender: str
    recipient: str
    amount: float
    timestamp: float = field(default_factory=time.time)
    signature: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'sender': self.sender,
            'recipient': self.recipient,
            'amount': self.amount,
            'timestamp': self.timestamp
        }
    
    def calculate_hash(self) -> str:
        """è®¡ç®—äº¤æ˜“å“ˆå¸Œ"""
        transaction_string = json.dumps(self.to_dict(), sort_keys=True)
        return hashlib.sha256(transaction_string.encode()).hexdigest()

@dataclass
class Block:
    """åŒºå—ç±»"""
    index: int
    timestamp: float
    transactions: List[Transaction]
    previous_hash: str
    nonce: int = 0
    merkle_root: Optional[str] = None
    
    def calculate_hash(self) -> str:
        """è®¡ç®—åŒºå—å“ˆå¸Œ"""
        block_string = json.dumps({
            'index': self.index,
            'timestamp': self.timestamp,
            'transactions': [tx.to_dict() for tx in self.transactions],
            'previous_hash': self.previous_hash,
            'nonce': self.nonce,
            'merkle_root': self.merkle_root
        }, sort_keys=True)
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def calculate_merkle_root(self) -> str:
        """è®¡ç®—é»˜å…‹å°”æ ¹"""
        if not self.transactions:
            return hashlib.sha256("".encode()).hexdigest()
        
        # è·å–æ‰€æœ‰äº¤æ˜“çš„å“ˆå¸Œ
        transaction_hashes = [tx.calculate_hash() for tx in self.transactions]
        
        # å¦‚æœäº¤æ˜“æ•°ä¸ºå¥‡æ•°ï¼Œå¤åˆ¶æœ€åä¸€ä¸ª
        if len(transaction_hashes) % 2 != 0:
            transaction_hashes.append(transaction_hashes[-1])
        
        # æ„å»ºé»˜å…‹å°”æ ‘
        while len(transaction_hashes) > 1:
            new_hashes = []
            for i in range(0, len(transaction_hashes), 2):
                combined = transaction_hashes[i] + transaction_hashes[i + 1]
                new_hash = hashlib.sha256(combined.encode()).hexdigest()
                new_hashes.append(new_hash)
            transaction_hashes = new_hashes
        
        return transaction_hashes[0]

class Blockchain:
    """åŒºå—é“¾ç±»"""
    
    def __init__(self, difficulty: int = 4):
        self.chain: List[Block] = []
        self.pending_transactions: List[Transaction] = []
        self.difficulty = difficulty
        self.mining_reward = 10.0
        
        # åˆ›å»ºåˆ›ä¸–åŒºå—
        self.create_genesis_block()
        
    def create_genesis_block(self) -> None:
        """åˆ›å»ºåˆ›ä¸–åŒºå—"""
        genesis_block = Block(
            index=0,
            timestamp=time.time(),
            transactions=[],
            previous_hash="0"
        )
        genesis_block.merkle_root = genesis_block.calculate_merkle_root()
        self.chain.append(genesis_block)
        
    def get_latest_block(self) -> Block:
        """è·å–æœ€æ–°åŒºå—"""
        return self.chain[-1]
        
    def add_transaction(self, sender: str, recipient: str, amount: float) -> int:
        """æ·»åŠ äº¤æ˜“"""
        transaction = Transaction(sender, recipient, amount)
        self.pending_transactions.append(transaction)
        return len(self.chain) + 1
        
    def mine_pending_transactions(self, miner_address: str) -> Block:
        """æŒ–æ˜å¾…å¤„ç†äº¤æ˜“"""
        # åˆ›å»ºæ–°åŒºå—
        block = Block(
            index=len(self.chain),
            timestamp=time.time(),
            transactions=self.pending_transactions,
            previous_hash=self.get_latest_block().calculate_hash()
        )
        
        # è®¡ç®—é»˜å…‹å°”æ ¹
        block.merkle_root = block.calculate_merkle_root()
        
        # å·¥ä½œé‡è¯æ˜
        self.proof_of_work(block)
        
        # æ·»åŠ åŒºå—åˆ°é“¾
        self.chain.append(block)
        
        # æ¸…ç©ºå¾…å¤„ç†äº¤æ˜“å¹¶æ·»åŠ æŒ–çŸ¿å¥–åŠ±
        self.pending_transactions = [
            Transaction("", miner_address, self.mining_reward)
        ]
        
        return block
        
    def proof_of_work(self, block: Block) -> None:
        """å·¥ä½œé‡è¯æ˜"""
        target = "0" * self.difficulty
        
        while block.calculate_hash()[:self.difficulty] != target:
            block.nonce += 1
            
    def is_chain_valid(self) -> bool:
        """éªŒè¯åŒºå—é“¾"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]
            
            # éªŒè¯å½“å‰åŒºå—å“ˆå¸Œ
            if current_block.calculate_hash() != current_block.calculate_hash():
                return False
            
            # éªŒè¯å‰ä¸€ä¸ªåŒºå—å“ˆå¸Œ
            if current_block.previous_hash != previous_block.calculate_hash():
                return False
            
            # éªŒè¯é»˜å…‹å°”æ ¹
            if current_block.merkle_root != current_block.calculate_merkle_root():
                return False
        
        return True
        
    def get_balance(self, address: str) -> float:
        """è·å–åœ°å€ä½™é¢"""
        balance = 0.0
        
        for block in self.chain:
            for transaction in block.transactions:
                if transaction.sender == address:
                    balance -= transaction.amount
                if transaction.recipient == address:
                    balance += transaction.amount
        
        return balance
```

### 5.2 å¯†ç å­¦å®ç°

```python
class CryptoUtils:
    """å¯†ç å­¦å·¥å…·ç±»"""
    
    @staticmethod
    def generate_key_pair() -> Tuple[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey]:
        """ç”Ÿæˆå¯†é’¥å¯¹"""
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        return private_key, public_key
    
    @staticmethod
    def sign_message(message: str, private_key: ec.EllipticCurvePrivateKey) -> str:
        """ç­¾åæ¶ˆæ¯"""
        message_bytes = message.encode()
        signature = private_key.sign(message_bytes, ec.ECDSA(hashes.SHA256()))
        return signature.hex()
    
    @staticmethod
    def verify_signature(message: str, signature: str, public_key: ec.EllipticCurvePublicKey) -> bool:
        """éªŒè¯ç­¾å"""
        try:
            message_bytes = message.encode()
            signature_bytes = bytes.fromhex(signature)
            public_key.verify(signature_bytes, message_bytes, ec.ECDSA(hashes.SHA256()))
            return True
        except:
            return False
    
    @staticmethod
    def public_key_to_address(public_key: ec.EllipticCurvePublicKey) -> str:
        """å…¬é’¥è½¬åœ°å€"""
        public_bytes = public_key.public_bytes(Encoding.DER, PublicFormat.SubjectPublicKeyInfo)
        return hashlib.sha256(public_bytes).hexdigest()[:40]

class Wallet:
    """é’±åŒ…ç±»"""
    
    def __init__(self):
        self.private_key, self.public_key = CryptoUtils.generate_key_pair()
        self.address = CryptoUtils.public_key_to_address(self.public_key)
        
    def sign_transaction(self, transaction: Transaction) -> Transaction:
        """ç­¾åäº¤æ˜“"""
        transaction_data = json.dumps(transaction.to_dict(), sort_keys=True)
        signature = CryptoUtils.sign_message(transaction_data, self.private_key)
        transaction.signature = signature
        return transaction
    
    def verify_transaction(self, transaction: Transaction) -> bool:
        """éªŒè¯äº¤æ˜“"""
        if not transaction.signature:
            return False
        
        transaction_data = json.dumps(transaction.to_dict(), sort_keys=True)
        return CryptoUtils.verify_signature(transaction_data, transaction.signature, self.public_key)
```

### 5.3 å…±è¯†æœºåˆ¶å®ç°

```python
class ConsensusMechanism:
    """å…±è¯†æœºåˆ¶åŸºç±»"""
    
    @abstractmethod
    def select_validator(self, validators: List[str]) -> str:
        """é€‰æ‹©éªŒè¯è€…"""
        pass

class ProofOfWork(ConsensusMechanism):
    """å·¥ä½œé‡è¯æ˜"""
    
    def __init__(self, difficulty: int = 4):
        self.difficulty = difficulty
        
    def mine_block(self, block: Block) -> int:
        """æŒ–æ˜åŒºå—"""
        target = "0" * self.difficulty
        nonce = 0
        
        while block.calculate_hash()[:self.difficulty] != target:
            block.nonce = nonce
            nonce += 1
            
        return nonce
    
    def select_validator(self, validators: List[str]) -> str:
        """é€‰æ‹©éªŒè¯è€…ï¼ˆå·¥ä½œé‡è¯æ˜ä¸­ï¼Œç¬¬ä¸€ä¸ªæ‰¾åˆ°æœ‰æ•ˆå“ˆå¸Œçš„çŸ¿å·¥è·èƒœï¼‰"""
        return validators[0] if validators else ""

class ProofOfStake(ConsensusMechanism):
    """æƒç›Šè¯æ˜"""
    
    def __init__(self):
        self.stakes: Dict[str, float] = {}
        
    def add_stake(self, validator: str, amount: float) -> None:
        """æ·»åŠ æƒç›Š"""
        self.stakes[validator] = self.stakes.get(validator, 0) + amount
        
    def select_validator(self, validators: List[str]) -> str:
        """é€‰æ‹©éªŒè¯è€…"""
        if not validators:
            return ""
        
        # è®¡ç®—æ€»æƒç›Š
        total_stake = sum(self.stakes.get(v, 0) for v in validators)
        
        if total_stake == 0:
            return validators[0]
        
        # æ ¹æ®æƒç›Šé€‰æ‹©éªŒè¯è€…
        import random
        rand = random.uniform(0, total_stake)
        current_stake = 0
        
        for validator in validators:
            current_stake += self.stakes.get(validator, 0)
            if rand <= current_stake:
                return validator
        
        return validators[-1]
```

### 5.4 æ™ºèƒ½åˆçº¦å®ç°

```python
class SmartContract:
    """æ™ºèƒ½åˆçº¦åŸºç±»"""
    
    def __init__(self, address: str):
        self.address = address
        self.state: Dict[str, Any] = {}
        self.code: str = ""
        
    @abstractmethod
    def execute(self, function_name: str, args: List[Any]) -> Any:
        """æ‰§è¡Œåˆçº¦å‡½æ•°"""
        pass

class SimpleToken(SmartContract):
    """ç®€å•ä»£å¸åˆçº¦"""
    
    def __init__(self, address: str, initial_supply: float = 1000000):
        super().__init__(address)
        self.state['total_supply'] = initial_supply
        self.state['balances'] = {}
        self.state['owner'] = address
        self.state['balances'][address] = initial_supply
        
    def execute(self, function_name: str, args: List[Any]) -> Any:
        """æ‰§è¡Œåˆçº¦å‡½æ•°"""
        if function_name == 'transfer':
            return self.transfer(args[0], args[1], args[2])
        elif function_name == 'balanceOf':
            return self.balance_of(args[0])
        elif function_name == 'totalSupply':
            return self.total_supply()
        else:
            raise ValueError(f"Unknown function: {function_name}")
    
    def transfer(self, sender: str, recipient: str, amount: float) -> bool:
        """è½¬è´¦"""
        if self.state['balances'].get(sender, 0) < amount:
            return False
        
        self.state['balances'][sender] = self.state['balances'].get(sender, 0) - amount
        self.state['balances'][recipient] = self.state['balances'].get(recipient, 0) + amount
        return True
    
    def balance_of(self, address: str) -> float:
        """æŸ¥è¯¢ä½™é¢"""
        return self.state['balances'].get(address, 0)
    
    def total_supply(self) -> float:
        """æŸ¥è¯¢æ€»ä¾›åº”é‡"""
        return self.state['total_supply']

class DecentralizedExchange(SmartContract):
    """å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€åˆçº¦"""
    
    def __init__(self, address: str):
        super().__init__(address)
        self.state['orders'] = []
        self.state['trades'] = []
        
    def execute(self, function_name: str, args: List[Any]) -> Any:
        """æ‰§è¡Œåˆçº¦å‡½æ•°"""
        if function_name == 'placeOrder':
            return self.place_order(args[0], args[1], args[2], args[3])
        elif function_name == 'cancelOrder':
            return self.cancel_order(args[0])
        elif function_name == 'getOrders':
            return self.get_orders()
        else:
            raise ValueError(f"Unknown function: {function_name}")
    
    def place_order(self, trader: str, token: str, amount: float, price: float) -> str:
        """ä¸‹å•"""
        order_id = hashlib.sha256(f"{trader}{token}{amount}{price}{time.time()}".encode()).hexdigest()
        order = {
            'id': order_id,
            'trader': trader,
            'token': token,
            'amount': amount,
            'price': price,
            'timestamp': time.time(),
            'status': 'active'
        }
        self.state['orders'].append(order)
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        """å–æ¶ˆè®¢å•"""
        for order in self.state['orders']:
            if order['id'] == order_id and order['status'] == 'active':
                order['status'] = 'cancelled'
                return True
        return False
    
    def get_orders(self) -> List[Dict[str, Any]]:
        """è·å–è®¢å•åˆ—è¡¨"""
        return [order for order in self.state['orders'] if order['status'] == 'active']
```

## 6. å®è·µåº”ç”¨

### 6.1 åŒºå—é“¾æ¼”ç¤º

```python
def blockchain_demo():
    """åŒºå—é“¾æ¼”ç¤º"""
    print("=== åŒºå—é“¾æ¼”ç¤º ===\n")
    
    # åˆ›å»ºåŒºå—é“¾
    blockchain = Blockchain(difficulty=4)
    
    # åˆ›å»ºé’±åŒ…
    wallet1 = Wallet()
    wallet2 = Wallet()
    
    print(f"é’±åŒ…1åœ°å€: {wallet1.address}")
    print(f"é’±åŒ…2åœ°å€: {wallet2.address}")
    
    # æ·»åŠ äº¤æ˜“
    print("\n1. æ·»åŠ äº¤æ˜“")
    blockchain.add_transaction(wallet1.address, wallet2.address, 50.0)
    blockchain.add_transaction(wallet2.address, wallet1.address, 30.0)
    
    print(f"å¾…å¤„ç†äº¤æ˜“æ•°: {len(blockchain.pending_transactions)}")
    
    # æŒ–æ˜åŒºå—
    print("\n2. æŒ–æ˜åŒºå—")
    print("å¼€å§‹æŒ–æ˜...")
    start_time = time.time()
    block = blockchain.mine_pending_transactions(wallet1.address)
    end_time = time.time()
    
    print(f"åŒºå—æŒ–æ˜å®Œæˆ!")
    print(f"åŒºå—å“ˆå¸Œ: {block.calculate_hash()}")
    print(f"æŒ–æ˜æ—¶é—´: {end_time - start_time:.2f}ç§’")
    print(f"Nonceå€¼: {block.nonce}")
    
    # éªŒè¯åŒºå—é“¾
    print("\n3. éªŒè¯åŒºå—é“¾")
    is_valid = blockchain.is_chain_valid()
    print(f"åŒºå—é“¾æ˜¯å¦æœ‰æ•ˆ: {is_valid}")
    
    # æŸ¥è¯¢ä½™é¢
    print("\n4. æŸ¥è¯¢ä½™é¢")
    balance1 = blockchain.get_balance(wallet1.address)
    balance2 = blockchain.get_balance(wallet2.address)
    
    print(f"é’±åŒ…1ä½™é¢: {balance1}")
    print(f"é’±åŒ…2ä½™é¢: {balance2}")
    
    return blockchain, wallet1, wallet2

def smart_contract_demo():
    """æ™ºèƒ½åˆçº¦æ¼”ç¤º"""
    print("\n=== æ™ºèƒ½åˆçº¦æ¼”ç¤º ===\n")
    
    # åˆ›å»ºä»£å¸åˆçº¦
    token_contract = SimpleToken("contract_address", initial_supply=1000000)
    
    print("1. ä»£å¸åˆçº¦")
    print(f"æ€»ä¾›åº”é‡: {token_contract.execute('totalSupply', [])}")
    print(f"åˆçº¦åœ°å€ä½™é¢: {token_contract.execute('balanceOf', ['contract_address'])}")
    
    # è½¬è´¦
    print("\n2. è½¬è´¦æ“ä½œ")
    success = token_contract.execute('transfer', ['contract_address', 'user1', 1000])
    print(f"è½¬è´¦ç»“æœ: {success}")
    print(f"ç”¨æˆ·1ä½™é¢: {token_contract.execute('balanceOf', ['user1'])}")
    
    # å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€
    print("\n3. å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€")
    dex_contract = DecentralizedExchange("dex_address")
    
    # ä¸‹å•
    order_id = dex_contract.execute('placeOrder', ['trader1', 'ETH', 10.0, 2000.0])
    print(f"è®¢å•ID: {order_id}")
    
    # æŸ¥è¯¢è®¢å•
    orders = dex_contract.execute('getOrders', [])
    print(f"æ´»è·ƒè®¢å•æ•°: {len(orders)}")
    
    return token_contract, dex_contract

def consensus_demo():
    """å…±è¯†æœºåˆ¶æ¼”ç¤º"""
    print("\n=== å…±è¯†æœºåˆ¶æ¼”ç¤º ===\n")
    
    # å·¥ä½œé‡è¯æ˜
    print("1. å·¥ä½œé‡è¯æ˜")
    pow_consensus = ProofOfWork(difficulty=4)
    
    block = Block(
        index=1,
        timestamp=time.time(),
        transactions=[],
        previous_hash="0000000000000000000000000000000000000000000000000000000000000000"
    )
    
    start_time = time.time()
    nonce = pow_consensus.mine_block(block)
    end_time = time.time()
    
    print(f"æŒ–æ˜å®Œæˆï¼ŒNonce: {nonce}")
    print(f"åŒºå—å“ˆå¸Œ: {block.calculate_hash()}")
    print(f"æŒ–æ˜æ—¶é—´: {end_time - start_time:.2f}ç§’")
    
    # æƒç›Šè¯æ˜
    print("\n2. æƒç›Šè¯æ˜")
    pos_consensus = ProofOfStake()
    
    validators = ['validator1', 'validator2', 'validator3']
    pos_consensus.add_stake('validator1', 1000)
    pos_consensus.add_stake('validator2', 2000)
    pos_consensus.add_stake('validator3', 1500)
    
    selected = pos_consensus.select_validator(validators)
    print(f"é€‰ä¸­çš„éªŒè¯è€…: {selected}")
    
    return pow_consensus, pos_consensus

def performance_analysis():
    """æ€§èƒ½åˆ†æ"""
    print("\n=== æ€§èƒ½åˆ†æ ===\n")
    
    # ä¸åŒéš¾åº¦ä¸‹çš„æŒ–æ˜æ—¶é—´
    difficulties = [2, 3, 4, 5, 6]
    mining_times = []
    
    for difficulty in difficulties:
        blockchain = Blockchain(difficulty=difficulty)
        blockchain.add_transaction("sender", "recipient", 100)
        
        start_time = time.time()
        blockchain.mine_pending_transactions("miner")
        end_time = time.time()
        
        mining_times.append(end_time - start_time)
        print(f"éš¾åº¦ {difficulty}: {end_time - start_time:.2f}ç§’")
    
    # å¯è§†åŒ–
    import matplotlib.pyplot as plt
    
    plt.figure(figsize=(10, 6))
    plt.plot(difficulties, mining_times, 'bo-')
    plt.xlabel('éš¾åº¦')
    plt.ylabel('æŒ–æ˜æ—¶é—´ (ç§’)')
    plt.title('å·¥ä½œé‡è¯æ˜éš¾åº¦ä¸æŒ–æ˜æ—¶é—´å…³ç³»')
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    # è¿è¡ŒåŒºå—é“¾æ¼”ç¤º
    blockchain, wallet1, wallet2 = blockchain_demo()
    
    # è¿è¡Œæ™ºèƒ½åˆçº¦æ¼”ç¤º
    token_contract, dex_contract = smart_contract_demo()
    
    # è¿è¡Œå…±è¯†æœºåˆ¶æ¼”ç¤º
    pow_consensus, pos_consensus = consensus_demo()
    
    # æ€§èƒ½åˆ†æ
    performance_analysis()
```

## 7. æ€»ç»“

### 7.1 æ ¸å¿ƒè¦ç‚¹

1. **åŒºå—é“¾åŸºç¡€**ï¼šåˆ†å¸ƒå¼è´¦æœ¬ã€åŒºå—ç»“æ„ã€äº¤æ˜“éªŒè¯
2. **å¯†ç å­¦åŸºç¡€**ï¼šå“ˆå¸Œå‡½æ•°ã€æ•°å­—ç­¾åã€å…¬é’¥å¯†ç å­¦
3. **å…±è¯†æœºåˆ¶**ï¼šå·¥ä½œé‡è¯æ˜ã€æƒç›Šè¯æ˜ã€æ‹œå åº­å®¹é”™
4. **æ™ºèƒ½åˆçº¦**ï¼šè‡ªåŠ¨æ‰§è¡Œç¨‹åºã€å›¾çµå®Œå¤‡æ€§
5. **åº”ç”¨åœºæ™¯**ï¼šæ•°å­—è´§å¸ã€ä¾›åº”é“¾ã€èº«ä»½è®¤è¯

### 7.2 å…³é”®å…¬å¼

- **åŒºå—å“ˆå¸Œ**ï¼š$Hash_i = H(Header_i)$
- **é»˜å…‹å°”æ ¹**ï¼š$MerkleRoot = H(H(Tx_1 || Tx_2) || H(Tx_3 || Tx_4))$
- **å·¥ä½œé‡è¯æ˜**ï¼š$H(Header || Nonce) < Target$
- **æƒç›Šè¯æ˜æ¦‚ç‡**ï¼š$P(Validator_i) = \frac{Stake_i}{\sum_{j} Stake_j}$
- **æ‹œå åº­å®¹é”™**ï¼š$n \geq 3f + 1$

### 7.3 åº”ç”¨åœºæ™¯

1. **æ•°å­—è´§å¸**ï¼šæ¯”ç‰¹å¸ã€ä»¥å¤ªåŠç­‰åŠ å¯†è´§å¸
2. **ä¾›åº”é“¾ç®¡ç†**ï¼šäº§å“æº¯æºã€é˜²ä¼ªéªŒè¯
3. **èº«ä»½è®¤è¯**ï¼šå»ä¸­å¿ƒåŒ–èº«ä»½ç®¡ç†
4. **æŠ•ç¥¨ç³»ç»Ÿ**ï¼šé€æ˜ã€ä¸å¯ç¯¡æ”¹çš„æŠ•ç¥¨
5. **é‡‘èæœåŠ¡**ï¼šDeFiã€æ™ºèƒ½åˆçº¦é‡‘è

### 7.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¯æ‰©å±•æ€§**ï¼šTPSé™åˆ¶ã€ç½‘ç»œæ‹¥å µ
2. **éšç§ä¿æŠ¤**ï¼šäº¤æ˜“é€æ˜æ€§ä¸éšç§çš„å¹³è¡¡
3. **èƒ½æºæ¶ˆè€—**ï¼šå·¥ä½œé‡è¯æ˜çš„èƒ½æºé—®é¢˜
4. **ç›‘ç®¡åˆè§„**ï¼šæ³•å¾‹æ¡†æ¶å’Œç›‘ç®¡è¦æ±‚
5. **ç”¨æˆ·ä½“éªŒ**ï¼šå¤æ‚æ€§å’Œæ˜“ç”¨æ€§

### 7.5 å‘å±•è¶‹åŠ¿

1. **Layer 2æ‰©å±•**ï¼šé—ªç”µç½‘ç»œã€Rollups
2. **è·¨é“¾æŠ€æœ¯**ï¼šå¤šé“¾äº’æ“ä½œæ€§
3. **éšç§è®¡ç®—**ï¼šé›¶çŸ¥è¯†è¯æ˜ã€åŒæ€åŠ å¯†
4. **ç»¿è‰²åŒºå—é“¾**ï¼šæƒç›Šè¯æ˜ã€ç¯ä¿å…±è¯†
5. **Web3ç”Ÿæ€**ï¼šå»ä¸­å¿ƒåŒ–åº”ç”¨ã€å…ƒå®‡å®™

### 7.6 æœ€ä½³å®è·µ

1. **å®‰å…¨æ€§**ï¼šå¤šé‡ç­¾åã€å†·é’±åŒ…å­˜å‚¨
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šåˆ†ç‰‡ã€çŠ¶æ€é€šé“
3. **ç”¨æˆ·ä½“éªŒ**ï¼šç®€åŒ–äº¤äº’ã€é™ä½é—¨æ§›
4. **åˆè§„æ€§**ï¼šäº†è§£æ³•è§„ã€åˆè§„è®¾è®¡
5. **å¯æŒç»­æ€§**ï¼šç¯ä¿å…±è¯†ã€èƒ½æºæ•ˆç‡

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04-03-02-åŠ å¯†è´§å¸](./04-03-02-åŠ å¯†è´§å¸.md)
- [04-03-03-DeFiåº”ç”¨](./04-03-03-DeFiåº”ç”¨.md)
- [06-ç»„ä»¶ç®—æ³•/06-01-åŸºç¡€ç®—æ³•/06-01-01-æ’åºç®—æ³•](../06-ç»„ä»¶ç®—æ³•/06-01-åŸºç¡€ç®—æ³•/06-01-01-æ’åºç®—æ³•.md)

**è¿”å›ä¸Šçº§**ï¼š[04-è¡Œä¸šé¢†åŸŸ](../README.md)
