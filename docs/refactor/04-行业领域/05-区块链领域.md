# 区块链领域架构设计

## 1. 概述

### 1.1 区块链技术基础

区块链是一种分布式账本技术，通过密码学、共识机制和P2P网络实现去中心化的数据存储和交易验证。

**定义 1.1.1 (区块链)**
区块链是一个有序的、不可篡改的交易记录链，每个区块包含：
- 区块头：包含元数据和前一个区块的哈希
- 交易列表：包含多个交易记录
- 时间戳：区块创建时间

**数学表示**：
$$\text{Blockchain} = \{B_i\}_{i=0}^{n} \text{ where } B_i = (H_i, T_i, \tau_i)$$

其中：
- $H_i$ 是区块头
- $T_i$ 是交易列表
- $\tau_i$ 是时间戳

### 1.2 核心特性

**定义 1.1.2 (区块链特性)**
区块链具有以下核心特性：
1. **去中心化**：$\forall n \in \text{Nodes}, \text{Equal}(n)$
2. **不可篡改**：$\text{Hash}(B_i) \rightarrow \text{Immutable}$
3. **可追溯性**：$\text{Chain}(B_0, B_1, ..., B_n)$
4. **共识机制**：$\text{Consensus}(\text{Nodes}) \rightarrow \text{Agreement}$

## 2. 密码学基础

### 2.1 哈希函数

**定义 2.1.1 (哈希函数)**
哈希函数 $H: \{0,1\}^* \rightarrow \{0,1\}^n$ 满足：
- **确定性**：$H(x) = H(x)$
- **抗碰撞性**：$\text{Pr}[H(x) = H(y)] \approx 2^{-n}$
- **雪崩效应**：$\Delta x \rightarrow \Delta H(x) \approx 50\%$

**Python实现**：
```python
import hashlib
from typing import Union, Optional
from dataclasses import dataclass

@dataclass
class Hash:
    """哈希值表示"""
    value: bytes
    
    def __init__(self, data: Union[str, bytes]):
        if isinstance(data, str):
            data = data.encode('utf-8')
        self.value = hashlib.sha256(data).digest()
    
    def __str__(self) -> str:
        return self.value.hex()
    
    def __eq__(self, other: 'Hash') -> bool:
        return self.value == other.value

class HashFunction:
    """哈希函数实现"""
    
    @staticmethod
    def sha256(data: Union[str, bytes]) -> Hash:
        """SHA-256哈希函数"""
        return Hash(data)
    
    @staticmethod
    def double_sha256(data: Union[str, bytes]) -> Hash:
        """双重SHA-256哈希"""
        first_hash = Hash(data)
        return Hash(first_hash.value)
    
    @staticmethod
    def ripemd160(data: Union[str, bytes]) -> Hash:
        """RIPEMD-160哈希函数"""
        if isinstance(data, str):
            data = data.encode('utf-8')
        return Hash(hashlib.new('ripemd160', data).digest())
```

### 2.2 数字签名

**定义 2.1.2 (数字签名)**
数字签名算法包含三个函数：
- **密钥生成**：$\text{KeyGen}() \rightarrow (pk, sk)$
- **签名**：$\text{Sign}(sk, m) \rightarrow \sigma$
- **验证**：$\text{Verify}(pk, m, \sigma) \rightarrow \{0,1\}$

**数学关系**：
$$\text{Verify}(pk, m, \text{Sign}(sk, m)) = 1$$

**Python实现**：
```python
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.exceptions import InvalidSignature
from typing import Tuple, Optional

@dataclass
class KeyPair:
    """密钥对"""
    public_key: rsa.RSAPublicKey
    private_key: rsa.RSAPrivateKey
    
    @classmethod
    def generate(cls, key_size: int = 2048) -> 'KeyPair':
        """生成密钥对"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size
        )
        public_key = private_key.public_key()
        return cls(public_key, private_key)
    
    def sign(self, message: bytes) -> bytes:
        """签名消息"""
        signature = self.private_key.sign(
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return signature
    
    def verify(self, message: bytes, signature: bytes) -> bool:
        """验证签名"""
        try:
            self.public_key.verify(
                signature,
                message,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except InvalidSignature:
            return False

class DigitalSignature:
    """数字签名系统"""
    
    def __init__(self):
        self.key_pairs: Dict[str, KeyPair] = {}
    
    def create_wallet(self, wallet_id: str) -> KeyPair:
        """创建钱包"""
        key_pair = KeyPair.generate()
        self.key_pairs[wallet_id] = key_pair
        return key_pair
    
    def sign_transaction(self, wallet_id: str, transaction_data: bytes) -> bytes:
        """签名交易"""
        if wallet_id not in self.key_pairs:
            raise ValueError(f"Wallet {wallet_id} not found")
        
        return self.key_pairs[wallet_id].sign(transaction_data)
    
    def verify_transaction(self, wallet_id: str, transaction_data: bytes, signature: bytes) -> bool:
        """验证交易签名"""
        if wallet_id not in self.key_pairs:
            return False
        
        return self.key_pairs[wallet_id].verify(transaction_data, signature)
```

## 3. 共识机制

### 3.1 工作量证明 (PoW)

**定义 3.1.1 (工作量证明)**
PoW是一种共识机制，要求节点解决计算难题来获得记账权：

$$\text{Find } n \text{ such that } H(\text{block} || n) < \text{target}$$

其中 $\text{target}$ 是难度目标值。

**Python实现**：
```python
import time
from typing import Optional, List
from dataclasses import dataclass

@dataclass
class Block:
    """区块结构"""
    index: int
    timestamp: float
    transactions: List['Transaction']
    previous_hash: str
    nonce: int = 0
    hash: Optional[str] = None
    
    def calculate_hash(self) -> str:
        """计算区块哈希"""
        block_string = f"{self.index}{self.timestamp}{self.transactions}{self.previous_hash}{self.nonce}"
        return HashFunction.sha256(block_string).__str__()

class ProofOfWork:
    """工作量证明实现"""
    
    def __init__(self, difficulty: int = 4):
        self.difficulty = difficulty
        self.target = "0" * difficulty
    
    def mine_block(self, block: Block) -> Block:
        """挖矿过程"""
        print(f"开始挖矿，目标难度: {self.difficulty}")
        start_time = time.time()
        
        while True:
            block.nonce += 1
            block.hash = block.calculate_hash()
            
            if block.hash.startswith(self.target):
                end_time = time.time()
                print(f"挖矿成功! 耗时: {end_time - start_time:.2f}秒")
                print(f"区块哈希: {block.hash}")
                return block
            
            if block.nonce % 10000 == 0:
                print(f"已尝试 {block.nonce} 次...")
    
    def validate_block(self, block: Block) -> bool:
        """验证区块"""
        calculated_hash = block.calculate_hash()
        return calculated_hash == block.hash and calculated_hash.startswith(self.target)

# 测试PoW
def test_proof_of_work():
    """测试工作量证明"""
    pow_system = ProofOfWork(difficulty=4)
    
    # 创建区块
    block = Block(
        index=1,
        timestamp=time.time(),
        transactions=["交易1", "交易2"],
        previous_hash="0000000000000000000000000000000000000000000000000000000000000000"
    )
    
    # 挖矿
    mined_block = pow_system.mine_block(block)
    
    # 验证
    is_valid = pow_system.validate_block(mined_block)
    print(f"区块验证结果: {is_valid}")

if __name__ == "__main__":
    test_proof_of_work()
```

### 3.2 权益证明 (PoS)

**定义 3.1.2 (权益证明)**
PoS是一种基于持币量的共识机制：

$$\text{Validator} = \arg\max_{v \in V} \text{Stake}(v) \times \text{Random}(v)$$

其中 $\text{Stake}(v)$ 是验证者的权益，$\text{Random}(v)$ 是随机因子。

**Python实现**：
```python
import random
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass
class Validator:
    """验证者"""
    address: str
    stake: float
    public_key: str
    
    def __post_init__(self):
        self.total_stake = 0.0
        self.rewards = 0.0

class ProofOfStake:
    """权益证明实现"""
    
    def __init__(self):
        self.validators: Dict[str, Validator] = {}
        self.total_stake = 0.0
    
    def add_validator(self, address: str, stake: float, public_key: str) -> Validator:
        """添加验证者"""
        validator = Validator(address, stake, public_key)
        self.validators[address] = validator
        self.total_stake += stake
        return validator
    
    def select_validator(self) -> Optional[Validator]:
        """选择验证者"""
        if not self.validators:
            return None
        
        # 计算选择概率
        probabilities = []
        validator_list = list(self.validators.values())
        
        for validator in validator_list:
            probability = validator.stake / self.total_stake
            probabilities.append(probability)
        
        # 根据概率选择验证者
        selected = random.choices(validator_list, weights=probabilities, k=1)[0]
        return selected
    
    def stake_tokens(self, address: str, amount: float) -> bool:
        """质押代币"""
        if address not in self.validators:
            return False
        
        self.validators[address].stake += amount
        self.total_stake += amount
        return True
    
    def unstake_tokens(self, address: str, amount: float) -> bool:
        """解质押代币"""
        if address not in self.validators:
            return False
        
        validator = self.validators[address]
        if validator.stake < amount:
            return False
        
        validator.stake -= amount
        self.total_stake -= amount
        return True
    
    def distribute_rewards(self, total_reward: float):
        """分配奖励"""
        if self.total_stake == 0:
            return
        
        for validator in self.validators.values():
            reward_share = (validator.stake / self.total_stake) * total_reward
            validator.rewards += reward_share

# 测试PoS
def test_proof_of_stake():
    """测试权益证明"""
    pos_system = ProofOfStake()
    
    # 添加验证者
    pos_system.add_validator("validator1", 1000.0, "pk1")
    pos_system.add_validator("validator2", 2000.0, "pk2")
    pos_system.add_validator("validator3", 3000.0, "pk3")
    
    # 选择验证者
    selected = pos_system.select_validator()
    print(f"选中的验证者: {selected.address}, 权益: {selected.stake}")
    
    # 分配奖励
    pos_system.distribute_rewards(100.0)
    
    for validator in pos_system.validators.values():
        print(f"验证者 {validator.address}: 权益={validator.stake}, 奖励={validator.rewards}")

if __name__ == "__main__":
    test_proof_of_stake()
```

## 4. 智能合约

### 4.1 智能合约基础

**定义 4.1.1 (智能合约)**
智能合约是运行在区块链上的自动执行程序：

$$\text{Contract} = (S, F, T)$$

其中：
- $S$ 是状态空间
- $F$ 是函数集合
- $T$ 是交易类型

**Python实现**：
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
import json

@dataclass
class ContractState:
    """合约状态"""
    storage: Dict[str, Any] = field(default_factory=dict)
    balance: float = 0.0
    owner: str = ""

@dataclass
class Transaction:
    """交易"""
    from_address: str
    to_address: str
    value: float
    data: bytes
    gas_limit: int
    gas_price: float

class SmartContract(ABC):
    """智能合约基类"""
    
    def __init__(self, contract_address: str, owner: str):
        self.contract_address = contract_address
        self.state = ContractState()
        self.state.owner = owner
        self.functions = {}
        self._register_functions()
    
    @abstractmethod
    def _register_functions(self):
        """注册合约函数"""
        pass
    
    def execute(self, transaction: Transaction) -> Dict[str, Any]:
        """执行交易"""
        # 验证交易
        if not self._validate_transaction(transaction):
            return {"success": False, "error": "Invalid transaction"}
        
        # 解析函数调用
        function_name, args = self._parse_transaction_data(transaction.data)
        
        # 执行函数
        if function_name in self.functions:
            try:
                result = self.functions[function_name](transaction, *args)
                return {"success": True, "result": result}
            except Exception as e:
                return {"success": False, "error": str(e)}
        else:
            return {"success": False, "error": "Function not found"}
    
    def _validate_transaction(self, transaction: Transaction) -> bool:
        """验证交易"""
        return transaction.to_address == self.contract_address
    
    def _parse_transaction_data(self, data: bytes) -> tuple:
        """解析交易数据"""
        # 简化实现，实际应该使用ABI
        data_str = data.decode('utf-8')
        parts = data_str.split('|')
        function_name = parts[0]
        args = parts[1:] if len(parts) > 1 else []
        return function_name, args

class TokenContract(SmartContract):
    """代币合约"""
    
    def _register_functions(self):
        """注册代币函数"""
        self.functions = {
            "transfer": self.transfer,
            "balanceOf": self.balance_of,
            "mint": self.mint,
            "burn": self.burn
        }
    
    def transfer(self, transaction: Transaction, to_address: str, amount: float) -> bool:
        """转账"""
        from_balance = self.state.storage.get(transaction.from_address, 0.0)
        if from_balance < amount:
            return False
        
        self.state.storage[transaction.from_address] = from_balance - amount
        self.state.storage[to_address] = self.state.storage.get(to_address, 0.0) + amount
        return True
    
    def balance_of(self, transaction: Transaction, address: str) -> float:
        """查询余额"""
        return self.state.storage.get(address, 0.0)
    
    def mint(self, transaction: Transaction, to_address: str, amount: float) -> bool:
        """铸造代币"""
        if transaction.from_address != self.state.owner:
            return False
        
        self.state.storage[to_address] = self.state.storage.get(to_address, 0.0) + amount
        return True
    
    def burn(self, transaction: Transaction, amount: float) -> bool:
        """销毁代币"""
        from_balance = self.state.storage.get(transaction.from_address, 0.0)
        if from_balance < amount:
            return False
        
        self.state.storage[transaction.from_address] = from_balance - amount
        return True

# 测试智能合约
def test_smart_contract():
    """测试智能合约"""
    # 创建代币合约
    contract = TokenContract("contract_address", "owner_address")
    
    # 铸造代币
    mint_tx = Transaction("owner_address", "contract_address", 0, b"mint|user1|1000", 21000, 0.001)
    result = contract.execute(mint_tx)
    print(f"铸造结果: {result}")
    
    # 转账
    transfer_tx = Transaction("user1", "contract_address", 0, b"transfer|user2|500", 21000, 0.001)
    result = contract.execute(transfer_tx)
    print(f"转账结果: {result}")
    
    # 查询余额
    balance_tx = Transaction("user1", "contract_address", 0, b"balanceOf|user1", 21000, 0.001)
    result = contract.execute(balance_tx)
    print(f"用户1余额: {result}")

if __name__ == "__main__":
    test_smart_contract()
```

## 5. 区块链网络

### 5.1 P2P网络

**定义 5.1.1 (P2P网络)**
P2P网络是一个去中心化的网络拓扑：

$$G = (V, E) \text{ where } \forall v \in V, \text{deg}(v) > 0$$

**Python实现**：
```python
import asyncio
import json
from typing import Dict, List, Set, Optional
from dataclasses import dataclass
import aiohttp
from aiohttp import web

@dataclass
class Node:
    """网络节点"""
    id: str
    address: str
    port: int
    peers: Set[str] = None
    
    def __post_init__(self):
        if self.peers is None:
            self.peers = set()

class P2PNetwork:
    """P2P网络实现"""
    
    def __init__(self, node_id: str, host: str, port: int):
        self.node = Node(node_id, host, port)
        self.app = web.Application()
        self.setup_routes()
        self.known_peers: Dict[str, Node] = {}
    
    def setup_routes(self):
        """设置路由"""
        self.app.router.add_post('/peer/connect', self.handle_peer_connect)
        self.app.router.add_post('/peer/disconnect', self.handle_peer_disconnect)
        self.app.router.add_post('/message/broadcast', self.handle_message_broadcast)
        self.app.router.add_get('/peers', self.handle_get_peers)
    
    async def start(self):
        """启动节点"""
        runner = web.AppRunner(self.app)
        await runner.setup()
        site = web.TCPSite(runner, self.node.address, self.node.port)
        await site.start()
        print(f"节点启动在 {self.node.address}:{self.node.port}")
    
    async def connect_to_peer(self, peer_address: str, peer_port: int):
        """连接到对等节点"""
        peer_id = f"{peer_address}:{peer_port}"
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(f"http://{peer_address}:{peer_port}/peer/connect", 
                                      json={"node_id": self.node.id, 
                                           "address": self.node.address, 
                                           "port": self.node.port}) as response:
                    if response.status == 200:
                        self.node.peers.add(peer_id)
                        print(f"成功连接到节点 {peer_id}")
                    else:
                        print(f"连接节点 {peer_id} 失败")
        except Exception as e:
            print(f"连接错误: {e}")
    
    async def broadcast_message(self, message: Dict[str, Any]):
        """广播消息"""
        for peer_id in self.node.peers:
            try:
                address, port = peer_id.split(':')
                async with aiohttp.ClientSession() as session:
                    async with session.post(f"http://{address}:{port}/message/broadcast", 
                                          json=message) as response:
                        if response.status != 200:
                            print(f"向节点 {peer_id} 广播失败")
            except Exception as e:
                print(f"广播到节点 {peer_id} 错误: {e}")
    
    async def handle_peer_connect(self, request):
        """处理节点连接请求"""
        data = await request.json()
        peer_id = f"{data['address']}:{data['port']}"
        
        self.node.peers.add(peer_id)
        self.known_peers[peer_id] = Node(data['node_id'], data['address'], int(data['port']))
        
        return web.json_response({"status": "connected"})
    
    async def handle_peer_disconnect(self, request):
        """处理节点断开请求"""
        data = await request.json()
        peer_id = f"{data['address']}:{data['port']}"
        
        self.node.peers.discard(peer_id)
        self.known_peers.pop(peer_id, None)
        
        return web.json_response({"status": "disconnected"})
    
    async def handle_message_broadcast(self, request):
        """处理消息广播"""
        message = await request.json()
        print(f"收到消息: {message}")
        
        # 继续转发给其他节点
        await self.broadcast_message(message)
        
        return web.json_response({"status": "received"})
    
    async def handle_get_peers(self, request):
        """获取对等节点列表"""
        peers = [{"id": peer.id, "address": peer.address, "port": peer.port} 
                for peer in self.known_peers.values()]
        return web.json_response({"peers": peers})

# 测试P2P网络
async def test_p2p_network():
    """测试P2P网络"""
    # 创建节点
    node1 = P2PNetwork("node1", "localhost", 8001)
    node2 = P2PNetwork("node2", "localhost", 8002)
    
    # 启动节点
    await asyncio.gather(
        node1.start(),
        node2.start()
    )
    
    # 等待启动
    await asyncio.sleep(1)
    
    # 连接节点
    await node1.connect_to_peer("localhost", 8002)
    
    # 广播消息
    await node1.broadcast_message({"type": "test", "content": "Hello P2P!"})
    
    # 等待消息处理
    await asyncio.sleep(2)

if __name__ == "__main__":
    asyncio.run(test_p2p_network())
```

## 6. 区块链应用

### 6.1 加密货币系统

**定义 6.1.1 (加密货币)**
加密货币是一种基于区块链的数字货币系统：

$$\text{Cryptocurrency} = (\text{Blockchain}, \text{Wallet}, \text{Mining}, \text{Exchange})$$

**Python实现**：
```python
from typing import Dict, List, Optional
from dataclasses import dataclass, field
import time
import json

@dataclass
class CryptocurrencyTransaction:
    """加密货币交易"""
    tx_id: str
    from_address: str
    to_address: str
    amount: float
    fee: float
    timestamp: float
    signature: str = ""

class CryptocurrencySystem:
    """加密货币系统"""
    
    def __init__(self, name: str, symbol: str, total_supply: float):
        self.name = name
        self.symbol = symbol
        self.total_supply = total_supply
        self.circulating_supply = 0.0
        self.blockchain = []
        self.pending_transactions = []
        self.wallets: Dict[str, 'Wallet'] = {}
        self.mining_reward = 50.0
        self.difficulty = 4
    
    def create_wallet(self, wallet_id: str) -> 'Wallet':
        """创建钱包"""
        wallet = Wallet(wallet_id, self)
        self.wallets[wallet_id] = wallet
        return wallet
    
    def create_transaction(self, from_address: str, to_address: str, amount: float, fee: float = 0.001) -> Optional[CryptocurrencyTransaction]:
        """创建交易"""
        # 检查余额
        if from_address in self.wallets:
            balance = self.wallets[from_address].get_balance()
            if balance < amount + fee:
                print(f"余额不足: {balance} < {amount + fee}")
                return None
        
        transaction = CryptocurrencyTransaction(
            tx_id=f"tx_{int(time.time())}_{from_address[:8]}",
            from_address=from_address,
            to_address=to_address,
            amount=amount,
            fee=fee,
            timestamp=time.time()
        )
        
        self.pending_transactions.append(transaction)
        return transaction
    
    def mine_block(self, miner_address: str) -> bool:
        """挖矿"""
        if not self.pending_transactions:
            print("没有待处理的交易")
            return False
        
        # 创建区块
        block = {
            "index": len(self.blockchain),
            "timestamp": time.time(),
            "transactions": [tx.__dict__ for tx in self.pending_transactions],
            "previous_hash": self.blockchain[-1]["hash"] if self.blockchain else "0" * 64,
            "nonce": 0,
            "hash": ""
        }
        
        # 工作量证明
        target = "0" * self.difficulty
        while True:
            block["hash"] = HashFunction.sha256(json.dumps(block, sort_keys=True)).__str__()
            if block["hash"].startswith(target):
                break
            block["nonce"] += 1
        
        # 添加挖矿奖励
        reward_tx = CryptocurrencyTransaction(
            tx_id=f"reward_{int(time.time())}",
            from_address="system",
            to_address=miner_address,
            amount=self.mining_reward,
            fee=0.0,
            timestamp=time.time()
        )
        block["transactions"].append(reward_tx.__dict__)
        
        # 添加到区块链
        self.blockchain.append(block)
        
        # 更新钱包余额
        self._update_balances(block["transactions"])
        
        # 清空待处理交易
        self.pending_transactions = []
        
        print(f"区块 {block['index']} 挖矿成功，哈希: {block['hash']}")
        return True
    
    def _update_balances(self, transactions: List[Dict]):
        """更新钱包余额"""
        for tx_data in transactions:
            tx = CryptocurrencyTransaction(**tx_data)
            
            # 处理发送方
            if tx.from_address != "system" and tx.from_address in self.wallets:
                self.wallets[tx.from_address].balance -= (tx.amount + tx.fee)
            
            # 处理接收方
            if tx.to_address in self.wallets:
                self.wallets[tx.to_address].balance += tx.amount
    
    def get_blockchain_info(self) -> Dict:
        """获取区块链信息"""
        return {
            "name": self.name,
            "symbol": self.symbol,
            "total_supply": self.total_supply,
            "circulating_supply": self.circulating_supply,
            "block_count": len(self.blockchain),
            "pending_transactions": len(self.pending_transactions),
            "difficulty": self.difficulty
        }

class Wallet:
    """钱包"""
    
    def __init__(self, wallet_id: str, crypto_system: CryptocurrencySystem):
        self.wallet_id = wallet_id
        self.crypto_system = crypto_system
        self.balance = 0.0
        self.transaction_history = []
    
    def get_balance(self) -> float:
        """获取余额"""
        return self.balance
    
    def send_transaction(self, to_address: str, amount: float) -> bool:
        """发送交易"""
        transaction = self.crypto_system.create_transaction(
            self.wallet_id, to_address, amount
        )
        
        if transaction:
            self.transaction_history.append(transaction)
            return True
        return False
    
    def get_transaction_history(self) -> List[CryptocurrencyTransaction]:
        """获取交易历史"""
        return self.transaction_history

# 测试加密货币系统
def test_cryptocurrency():
    """测试加密货币系统"""
    # 创建加密货币系统
    crypto = CryptocurrencySystem("TestCoin", "TST", 1000000.0)
    
    # 创建钱包
    wallet1 = crypto.create_wallet("user1")
    wallet2 = crypto.create_wallet("user2")
    
    # 挖矿获得初始代币
    crypto.mine_block("user1")
    
    # 发送交易
    wallet1.send_transaction("user2", 10.0)
    
    # 挖矿确认交易
    crypto.mine_block("user2")
    
    # 查看余额
    print(f"用户1余额: {wallet1.get_balance()}")
    print(f"用户2余额: {wallet2.get_balance()}")
    
    # 查看区块链信息
    info = crypto.get_blockchain_info()
    print(f"区块链信息: {info}")

if __name__ == "__main__":
    test_cryptocurrency()
```

## 7. 性能优化

### 7.1 并行处理

**定义 7.1.1 (并行处理)**
并行处理通过多线程/多进程提高区块链性能：

$$\text{Performance} = \frac{\text{Transactions}}{\text{Time}} \times \text{Parallelism}$$

**Python实现**：
```python
import asyncio
import threading
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
from typing import List, Dict, Any
import time

class ParallelBlockchainProcessor:
    """并行区块链处理器"""
    
    def __init__(self, max_workers: int = 4):
        self.max_workers = max_workers
        self.thread_pool = ThreadPoolExecutor(max_workers=max_workers)
        self.process_pool = ProcessPoolExecutor(max_workers=max_workers)
    
    async def parallel_transaction_processing(self, transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """并行处理交易"""
        loop = asyncio.get_event_loop()
        
        # 将交易分批
        batch_size = len(transactions) // self.max_workers
        batches = [transactions[i:i + batch_size] for i in range(0, len(transactions), batch_size)]
        
        # 并行处理每个批次
        tasks = []
        for batch in batches:
            task = loop.run_in_executor(self.thread_pool, self._process_transaction_batch, batch)
            tasks.append(task)
        
        # 等待所有任务完成
        results = await asyncio.gather(*tasks)
        
        # 合并结果
        processed_transactions = []
        for result in results:
            processed_transactions.extend(result)
        
        return processed_transactions
    
    def _process_transaction_batch(self, batch: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """处理交易批次"""
        processed = []
        for transaction in batch:
            # 模拟交易处理
            processed_tx = self._validate_and_process_transaction(transaction)
            processed.append(processed_tx)
        return processed
    
    def _validate_and_process_transaction(self, transaction: Dict[str, Any]) -> Dict[str, Any]:
        """验证和处理单个交易"""
        # 模拟验证过程
        time.sleep(0.01)  # 模拟处理时间
        
        transaction["processed"] = True
        transaction["timestamp"] = time.time()
        return transaction
    
    def parallel_mining(self, transactions: List[Dict[str, Any]], difficulty: int) -> Dict[str, Any]:
        """并行挖矿"""
        def mine_block_worker(worker_id: int, transactions: List[Dict[str, Any]], difficulty: int) -> Dict[str, Any]:
            """挖矿工作线程"""
            target = "0" * difficulty
            nonce = worker_id * 1000000  # 每个工作线程从不同的nonce开始
            
            while True:
                block = {
                    "index": 0,
                    "timestamp": time.time(),
                    "transactions": transactions,
                    "previous_hash": "0" * 64,
                    "nonce": nonce
                }
                
                block_hash = HashFunction.sha256(str(block)).__str__()
                
                if block_hash.startswith(target):
                    block["hash"] = block_hash
                    block["miner"] = f"worker_{worker_id}"
                    return block
                
                nonce += 1
        
        # 创建多个挖矿线程
        futures = []
        for i in range(self.max_workers):
            future = self.thread_pool.submit(mine_block_worker, i, transactions, difficulty)
            futures.append(future)
        
        # 等待第一个成功的挖矿结果
        for future in futures:
            try:
                result = future.result(timeout=60)  # 60秒超时
                # 取消其他任务
                for f in futures:
                    f.cancel()
                return result
            except Exception:
                continue
        
        return {"error": "Mining timeout"}

# 测试并行处理
async def test_parallel_processing():
    """测试并行处理"""
    processor = ParallelBlockchainProcessor(max_workers=4)
    
    # 创建测试交易
    transactions = [
        {"id": f"tx_{i}", "from": f"user_{i}", "to": f"user_{i+1}", "amount": 10.0}
        for i in range(100)
    ]
    
    # 并行处理交易
    start_time = time.time()
    processed_transactions = await processor.parallel_transaction_processing(transactions)
    end_time = time.time()
    
    print(f"并行处理 {len(transactions)} 个交易耗时: {end_time - start_time:.2f}秒")
    print(f"处理速度: {len(transactions) / (end_time - start_time):.2f} 交易/秒")
    
    # 并行挖矿
    print("开始并行挖矿...")
    start_time = time.time()
    mined_block = processor.parallel_mining(transactions[:10], 4)
    end_time = time.time()
    
    print(f"挖矿耗时: {end_time - start_time:.2f}秒")
    print(f"挖矿结果: {mined_block}")

if __name__ == "__main__":
    asyncio.run(test_parallel_processing())
```

## 8. 安全机制

### 8.1 多重签名

**定义 8.1.1 (多重签名)**
多重签名要求多个私钥共同签名才能执行交易：

$$\text{MultiSig} = \{pk_1, pk_2, ..., pk_n\} \text{ where } |\text{Signatures}| \geq m$$

**Python实现**：
```python
from typing import List, Dict, Set
from dataclasses import dataclass
import hashlib

@dataclass
class MultiSigWallet:
    """多重签名钱包"""
    address: str
    public_keys: List[str]
    required_signatures: int
    balance: float = 0.0
    
    def __post_init__(self):
        if self.required_signatures > len(self.public_keys):
            raise ValueError("Required signatures cannot exceed number of public keys")

class MultiSigTransaction:
    """多重签名交易"""
    
    def __init__(self, from_address: str, to_address: str, amount: float):
        self.from_address = from_address
        self.to_address = to_address
        self.amount = amount
        self.signatures: Dict[str, str] = {}
        self.tx_hash = self._calculate_hash()
    
    def _calculate_hash(self) -> str:
        """计算交易哈希"""
        data = f"{self.from_address}{self.to_address}{self.amount}"
        return hashlib.sha256(data.encode()).hexdigest()
    
    def add_signature(self, public_key: str, signature: str) -> bool:
        """添加签名"""
        # 验证签名
        if self._verify_signature(public_key, signature):
            self.signatures[public_key] = signature
            return True
        return False
    
    def _verify_signature(self, public_key: str, signature: str) -> bool:
        """验证签名（简化实现）"""
        # 实际实现应该使用真实的数字签名验证
        return len(signature) > 0
    
    def is_ready_to_execute(self, wallet: MultiSigWallet) -> bool:
        """检查是否可以执行"""
        return len(self.signatures) >= wallet.required_signatures

class MultiSigSystem:
    """多重签名系统"""
    
    def __init__(self):
        self.wallets: Dict[str, MultiSigWallet] = {}
        self.pending_transactions: Dict[str, MultiSigTransaction] = {}
    
    def create_wallet(self, address: str, public_keys: List[str], required_signatures: int) -> MultiSigWallet:
        """创建多重签名钱包"""
        wallet = MultiSigWallet(address, public_keys, required_signatures)
        self.wallets[address] = wallet
        return wallet
    
    def create_transaction(self, from_address: str, to_address: str, amount: float) -> str:
        """创建交易"""
        if from_address not in self.wallets:
            raise ValueError("Wallet not found")
        
        wallet = self.wallets[from_address]
        if wallet.balance < amount:
            raise ValueError("Insufficient balance")
        
        transaction = MultiSigTransaction(from_address, to_address, amount)
        self.pending_transactions[transaction.tx_hash] = transaction
        
        return transaction.tx_hash
    
    def sign_transaction(self, tx_hash: str, public_key: str, signature: str) -> bool:
        """签名交易"""
        if tx_hash not in self.pending_transactions:
            return False
        
        transaction = self.pending_transactions[tx_hash]
        return transaction.add_signature(public_key, signature)
    
    def execute_transaction(self, tx_hash: str) -> bool:
        """执行交易"""
        if tx_hash not in self.pending_transactions:
            return False
        
        transaction = self.pending_transactions[tx_hash]
        wallet = self.wallets[transaction.from_address]
        
        if not transaction.is_ready_to_execute(wallet):
            return False
        
        # 执行交易
        wallet.balance -= transaction.amount
        
        # 更新接收方余额
        if transaction.to_address in self.wallets:
            self.wallets[transaction.to_address].balance += transaction.amount
        
        # 移除待处理交易
        del self.pending_transactions[tx_hash]
        
        return True
    
    def get_wallet_info(self, address: str) -> Dict:
        """获取钱包信息"""
        if address not in self.wallets:
            return {}
        
        wallet = self.wallets[address]
        return {
            "address": wallet.address,
            "public_keys": wallet.public_keys,
            "required_signatures": wallet.required_signatures,
            "balance": wallet.balance,
            "total_keys": len(wallet.public_keys)
        }

# 测试多重签名
def test_multisig():
    """测试多重签名"""
    multisig_system = MultiSigSystem()
    
    # 创建多重签名钱包
    public_keys = ["pk1", "pk2", "pk3", "pk4"]
    wallet = multisig_system.create_wallet("multisig_wallet", public_keys, 3)
    wallet.balance = 1000.0
    
    # 创建交易
    tx_hash = multisig_system.create_transaction("multisig_wallet", "recipient", 100.0)
    
    # 添加签名
    multisig_system.sign_transaction(tx_hash, "pk1", "signature1")
    multisig_system.sign_transaction(tx_hash, "pk2", "signature2")
    multisig_system.sign_transaction(tx_hash, "pk3", "signature3")
    
    # 执行交易
    success = multisig_system.execute_transaction(tx_hash)
    print(f"交易执行结果: {success}")
    
    # 查看钱包信息
    info = multisig_system.get_wallet_info("multisig_wallet")
    print(f"钱包信息: {info}")

if __name__ == "__main__":
    test_multisig()
```

## 9. 总结

区块链技术通过密码学、共识机制和分布式网络实现了去中心化的信任机制。本章涵盖了：

1. **密码学基础**：哈希函数、数字签名
2. **共识机制**：工作量证明、权益证明
3. **智能合约**：自动执行的程序逻辑
4. **P2P网络**：去中心化网络通信
5. **加密货币**：数字资产系统
6. **性能优化**：并行处理技术
7. **安全机制**：多重签名等安全措施

这些技术共同构建了一个安全、透明、不可篡改的分布式系统，为各种去中心化应用提供了基础。
