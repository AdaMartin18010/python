# æ¸¸æˆå¼€å‘åŸºç¡€ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ¸¸æˆå¼€å‘æ˜¯ç»“åˆè®¡ç®—æœºå›¾å½¢å­¦ã€äººå·¥æ™ºèƒ½ã€ç‰©ç†å¼•æ“ã€éŸ³é¢‘å¤„ç†ç­‰å¤šå­¦ç§‘çš„ç»¼åˆæ€§æŠ€æœ¯é¢†åŸŸã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°æ¸¸æˆå¼€å‘çš„åŸºç¡€æ¦‚å¿µã€æ¶æ„æ¨¡å‹å’Œæ ¸å¿ƒç®—æ³•ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 æ¸¸æˆç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (æ¸¸æˆç³»ç»Ÿ)
æ¸¸æˆç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$\text{GameSystem} = (S, A, R, T, P, I, O)$$

å…¶ä¸­ï¼š
- $S$ æ˜¯çŠ¶æ€ç©ºé—´
- $A$ æ˜¯åŠ¨ä½œç©ºé—´
- $R$ æ˜¯å¥–åŠ±å‡½æ•°
- $T$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $P$ æ˜¯ç©å®¶é›†åˆ
- $I$ æ˜¯è¾“å…¥ç³»ç»Ÿ
- $O$ æ˜¯è¾“å‡ºç³»ç»Ÿ

### 1.2 æ¸¸æˆçŠ¶æ€å®šä¹‰

**å®šä¹‰ 1.2** (æ¸¸æˆçŠ¶æ€)
æ¸¸æˆçŠ¶æ€æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$\text{GameState} = (W, P, E, T)$$

å…¶ä¸­ï¼š
- $W$ æ˜¯ä¸–ç•ŒçŠ¶æ€
- $P$ æ˜¯ç©å®¶çŠ¶æ€
- $E$ æ˜¯å®ä½“çŠ¶æ€
- $T$ æ˜¯æ—¶é—´çŠ¶æ€

### 1.3 æ¸¸æˆå¾ªç¯å®šä¹‰

**å®šä¹‰ 1.3** (æ¸¸æˆå¾ªç¯)
æ¸¸æˆå¾ªç¯æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$\text{GameLoop}: \text{GameState} \times \text{Input} \rightarrow \text{GameState}$$

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 æ¸¸æˆå¼•æ“æ¶æ„

**å®šä¹‰ 2.1** (æ¸¸æˆå¼•æ“)
æ¸¸æˆå¼•æ“æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\text{GameEngine} = (\text{Renderer}, \text{Physics}, \text{Audio}, \text{Input}, \text{AI})$$

### 2.2 ç‰©ç†å¼•æ“

**å®šä¹‰ 2.2** (ç‰©ç†å¼•æ“)
ç‰©ç†å¼•æ“æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$\text{PhysicsEngine} = (\text{Simulation}, \text{Collision}, \text{Constraints})$$

**ç®—æ³• 2.1** (ç¢°æ’æ£€æµ‹)
```python
def collision_detection(object1: GameObject, object2: GameObject) -> bool:
    """
    ç¢°æ’æ£€æµ‹ç®—æ³•
    
    å‚æ•°:
        object1: æ¸¸æˆå¯¹è±¡1
        object2: æ¸¸æˆå¯¹è±¡2
        
    è¿”å›:
        æ˜¯å¦å‘ç”Ÿç¢°æ’
    """
    # AABBç¢°æ’æ£€æµ‹
    if (object1.x < object2.x + object2.width and
        object1.x + object1.width > object2.x and
        object1.y < object2.y + object2.height and
        object1.y + object1.height > object2.y):
        return True
    return False
```

## 3. Pythonå®ç°

### 3.1 æ¸¸æˆå¼•æ“æ ¸å¿ƒå®ç°

```python
from typing import List, Dict, Optional, Any, Tuple
from dataclasses import dataclass
from abc import ABC, abstractmethod
import time
import math
import pygame
import random

@dataclass
class Vector2D:
    """äºŒç»´å‘é‡"""
    x: float
    y: float
    
    def __add__(self, other: 'Vector2D') -> 'Vector2D':
        return Vector2D(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other: 'Vector2D') -> 'Vector2D':
        return Vector2D(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar: float) -> 'Vector2D':
        return Vector2D(self.x * scalar, self.y * scalar)
    
    def magnitude(self) -> float:
        """è®¡ç®—å‘é‡é•¿åº¦"""
        return math.sqrt(self.x * self.x + self.y * self.y)
    
    def normalize(self) -> 'Vector2D':
        """å‘é‡å½’ä¸€åŒ–"""
        mag = self.magnitude()
        if mag == 0:
            return Vector2D(0, 0)
        return Vector2D(self.x / mag, self.y / mag)

@dataclass
class GameObject:
    """æ¸¸æˆå¯¹è±¡"""
    position: Vector2D
    velocity: Vector2D
    size: Vector2D
    mass: float = 1.0
    active: bool = True
    
    def update(self, delta_time: float):
        """æ›´æ–°å¯¹è±¡çŠ¶æ€"""
        self.position = self.position + self.velocity * delta_time
    
    def apply_force(self, force: Vector2D):
        """æ–½åŠ åŠ›"""
        acceleration = force * (1.0 / self.mass)
        self.velocity = self.velocity + acceleration

class GameState:
    """æ¸¸æˆçŠ¶æ€"""
    
    def __init__(self):
        self.game_objects: List[GameObject] = []
        self.time: float = 0.0
        self.score: int = 0
        self.game_over: bool = False
    
    def add_object(self, obj: GameObject):
        """æ·»åŠ æ¸¸æˆå¯¹è±¡"""
        self.game_objects.append(obj)
    
    def remove_object(self, obj: GameObject):
        """ç§»é™¤æ¸¸æˆå¯¹è±¡"""
        if obj in self.game_objects:
            self.game_objects.remove(obj)
    
    def update(self, delta_time: float):
        """æ›´æ–°æ¸¸æˆçŠ¶æ€"""
        self.time += delta_time
        
        # æ›´æ–°æ‰€æœ‰æ¸¸æˆå¯¹è±¡
        for obj in self.game_objects:
            if obj.active:
                obj.update(delta_time)

class Renderer:
    """æ¸²æŸ“å™¨"""
    
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((width, height))
        self.clock = pygame.time.Clock()
    
    def clear(self, color: Tuple[int, int, int] = (0, 0, 0)):
        """æ¸…å±"""
        self.screen.fill(color)
    
    def draw_object(self, obj: GameObject, color: Tuple[int, int, int]):
        """ç»˜åˆ¶æ¸¸æˆå¯¹è±¡"""
        pygame.draw.rect(
            self.screen,
            color,
            (obj.position.x, obj.position.y, obj.size.x, obj.size.y)
        )
    
    def draw_text(self, text: str, position: Vector2D, color: Tuple[int, int, int]):
        """ç»˜åˆ¶æ–‡æœ¬"""
        font = pygame.font.Font(None, 36)
        text_surface = font.render(text, True, color)
        self.screen.blit(text_surface, (position.x, position.y))
    
    def update(self):
        """æ›´æ–°æ˜¾ç¤º"""
        pygame.display.flip()
        self.clock.tick(60)  # 60 FPS

class PhysicsEngine:
    """ç‰©ç†å¼•æ“"""
    
    def __init__(self):
        self.gravity = Vector2D(0, 9.8)
        self.collision_pairs: List[Tuple[GameObject, GameObject]] = []
    
    def update(self, game_state: GameState, delta_time: float):
        """æ›´æ–°ç‰©ç†"""
        # åº”ç”¨é‡åŠ›
        for obj in game_state.game_objects:
            if obj.active:
                obj.apply_force(self.gravity * obj.mass)
        
        # ç¢°æ’æ£€æµ‹
        self.detect_collisions(game_state)
        
        # å¤„ç†ç¢°æ’
        self.resolve_collisions()
    
    def detect_collisions(self, game_state: GameState):
        """æ£€æµ‹ç¢°æ’"""
        self.collision_pairs.clear()
        
        for i, obj1 in enumerate(game_state.game_objects):
            if not obj1.active:
                continue
            
            for j, obj2 in enumerate(game_state.game_objects[i+1:], i+1):
                if not obj2.active:
                    continue
                
                if self.check_collision(obj1, obj2):
                    self.collision_pairs.append((obj1, obj2))
    
    def check_collision(self, obj1: GameObject, obj2: GameObject) -> bool:
        """æ£€æŸ¥ç¢°æ’"""
        return (obj1.position.x < obj2.position.x + obj2.size.x and
                obj1.position.x + obj1.size.x > obj2.position.x and
                obj1.position.y < obj2.position.y + obj2.size.y and
                obj1.position.y + obj1.size.y > obj2.position.y)
    
    def resolve_collisions(self):
        """è§£å†³ç¢°æ’"""
        for obj1, obj2 in self.collision_pairs:
            # ç®€åŒ–çš„ç¢°æ’å“åº”
            # å®é™…å®ç°ä¸­åº”è¯¥ä½¿ç”¨æ›´å¤æ‚çš„ç‰©ç†è®¡ç®—
            overlap_x = min(obj1.position.x + obj1.size.x - obj2.position.x,
                          obj2.position.x + obj2.size.x - obj1.position.x)
            overlap_y = min(obj1.position.y + obj1.size.y - obj2.position.y,
                          obj2.position.y + obj2.size.y - obj1.position.y)
            
            if overlap_x < overlap_y:
                # æ°´å¹³åˆ†ç¦»
                if obj1.position.x < obj2.position.x:
                    obj1.position.x -= overlap_x
                else:
                    obj1.position.x += overlap_x
            else:
                # å‚ç›´åˆ†ç¦»
                if obj1.position.y < obj2.position.y:
                    obj1.position.y -= overlap_y
                else:
                    obj1.position.y += overlap_y

class InputManager:
    """è¾“å…¥ç®¡ç†å™¨"""
    
    def __init__(self):
        self.keys_pressed: Dict[int, bool] = {}
        self.mouse_position = Vector2D(0, 0)
        self.mouse_buttons: Dict[int, bool] = {}
    
    def update(self):
        """æ›´æ–°è¾“å…¥çŠ¶æ€"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            
            elif event.type == pygame.KEYDOWN:
                self.keys_pressed[event.key] = True
            
            elif event.type == pygame.KEYUP:
                self.keys_pressed[event.key] = False
            
            elif event.type == pygame.MOUSEMOTION:
                self.mouse_position = Vector2D(event.pos[0], event.pos[1])
            
            elif event.type == pygame.MOUSEBUTTONDOWN:
                self.mouse_buttons[event.button] = True
            
            elif event.type == pygame.MOUSEBUTTONUP:
                self.mouse_buttons[event.button] = False
        
        return True
    
    def is_key_pressed(self, key: int) -> bool:
        """æ£€æŸ¥æŒ‰é”®æ˜¯å¦æŒ‰ä¸‹"""
        return self.keys_pressed.get(key, False)
    
    def is_mouse_button_pressed(self, button: int) -> bool:
        """æ£€æŸ¥é¼ æ ‡æŒ‰é”®æ˜¯å¦æŒ‰ä¸‹"""
        return self.mouse_buttons.get(button, False)

class AudioManager:
    """éŸ³é¢‘ç®¡ç†å™¨"""
    
    def __init__(self):
        self.sounds: Dict[str, pygame.mixer.Sound] = {}
        self.music_playing = False
    
    def load_sound(self, name: str, file_path: str):
        """åŠ è½½éŸ³æ•ˆ"""
        try:
            self.sounds[name] = pygame.mixer.Sound(file_path)
        except:
            print(f"æ— æ³•åŠ è½½éŸ³æ•ˆ: {file_path}")
    
    def play_sound(self, name: str):
        """æ’­æ”¾éŸ³æ•ˆ"""
        if name in self.sounds:
            self.sounds[name].play()
    
    def play_music(self, file_path: str):
        """æ’­æ”¾éŸ³ä¹"""
        try:
            pygame.mixer.music.load(file_path)
            pygame.mixer.music.play(-1)  # å¾ªç¯æ’­æ”¾
            self.music_playing = True
        except:
            print(f"æ— æ³•æ’­æ”¾éŸ³ä¹: {file_path}")
    
    def stop_music(self):
        """åœæ­¢éŸ³ä¹"""
        pygame.mixer.music.stop()
        self.music_playing = False

class GameEngine:
    """æ¸¸æˆå¼•æ“"""
    
    def __init__(self, width: int, height: int):
        pygame.init()
        
        self.renderer = Renderer(width, height)
        self.physics_engine = PhysicsEngine()
        self.input_manager = InputManager()
        self.audio_manager = AudioManager()
        
        self.game_state = GameState()
        self.running = True
    
    def run(self):
        """è¿è¡Œæ¸¸æˆ"""
        last_time = time.time()
        
        while self.running:
            current_time = time.time()
            delta_time = current_time - last_time
            last_time = current_time
            
            # å¤„ç†è¾“å…¥
            self.running = self.input_manager.update()
            
            # æ›´æ–°æ¸¸æˆé€»è¾‘
            self.update(delta_time)
            
            # æ¸²æŸ“
            self.render()
    
    def update(self, delta_time: float):
        """æ›´æ–°æ¸¸æˆ"""
        # æ›´æ–°æ¸¸æˆçŠ¶æ€
        self.game_state.update(delta_time)
        
        # æ›´æ–°ç‰©ç†
        self.physics_engine.update(self.game_state, delta_time)
        
        # æ›´æ–°æ¸¸æˆé€»è¾‘
        self.update_game_logic(delta_time)
    
    def update_game_logic(self, delta_time: float):
        """æ›´æ–°æ¸¸æˆé€»è¾‘"""
        # å­ç±»å®ç°å…·ä½“æ¸¸æˆé€»è¾‘
        pass
    
    def render(self):
        """æ¸²æŸ“æ¸¸æˆ"""
        self.renderer.clear()
        
        # æ¸²æŸ“æ¸¸æˆå¯¹è±¡
        for obj in self.game_state.game_objects:
            if obj.active:
                self.renderer.draw_object(obj, (255, 255, 255))
        
        # æ¸²æŸ“UI
        self.renderer.draw_text(
            f"Score: {self.game_state.score}",
            Vector2D(10, 10),
            (255, 255, 255)
        )
        
        self.renderer.update()
    
    def quit(self):
        """é€€å‡ºæ¸¸æˆ"""
        pygame.quit()

class Player(GameObject):
    """ç©å®¶ç±»"""
    
    def __init__(self, position: Vector2D):
        super().__init__(position, Vector2D(0, 0), Vector2D(32, 32))
        self.speed = 200.0
        self.jump_force = 400.0
        self.on_ground = False
    
    def handle_input(self, input_manager: InputManager, delta_time: float):
        """å¤„ç†è¾“å…¥"""
        # æ°´å¹³ç§»åŠ¨
        if input_manager.is_key_pressed(pygame.K_LEFT):
            self.velocity.x = -self.speed
        elif input_manager.is_key_pressed(pygame.K_RIGHT):
            self.velocity.x = self.speed
        else:
            self.velocity.x = 0
        
        # è·³è·ƒ
        if input_manager.is_key_pressed(pygame.K_SPACE) and self.on_ground:
            self.velocity.y = -self.jump_force
            self.on_ground = False

class Enemy(GameObject):
    """æ•Œäººç±»"""
    
    def __init__(self, position: Vector2D):
        super().__init__(position, Vector2D(0, 0), Vector2D(24, 24))
        self.speed = 100.0
        self.direction = 1
    
    def update(self, delta_time: float):
        """æ›´æ–°æ•Œäºº"""
        super().update(delta_time)
        
        # ç®€å•çš„AIè¡Œä¸º
        self.velocity.x = self.speed * self.direction
        
        # è¾¹ç•Œæ£€æµ‹
        if self.position.x <= 0 or self.position.x >= 800 - self.size.x:
            self.direction *= -1

class Platform(GameObject):
    """å¹³å°ç±»"""
    
    def __init__(self, position: Vector2D, size: Vector2D):
        super().__init__(position, Vector2D(0, 0), size)
        self.mass = float('inf')  # é™æ€å¯¹è±¡
```

### 3.2 æ¸¸æˆé€»è¾‘å®ç°

```python
class PlatformerGame(GameEngine):
    """å¹³å°è·³è·ƒæ¸¸æˆ"""
    
    def __init__(self):
        super().__init__(800, 600)
        
        # åˆ›å»ºç©å®¶
        self.player = Player(Vector2D(100, 300))
        self.game_state.add_object(self.player)
        
        # åˆ›å»ºå¹³å°
        platforms = [
            Platform(Vector2D(0, 550), Vector2D(800, 50)),  # åœ°é¢
            Platform(Vector2D(200, 450), Vector2D(100, 20)),
            Platform(Vector2D(400, 350), Vector2D(100, 20)),
            Platform(Vector2D(600, 250), Vector2D(100, 20)),
        ]
        
        for platform in platforms:
            self.game_state.add_object(platform)
        
        # åˆ›å»ºæ•Œäºº
        enemies = [
            Enemy(Vector2D(300, 520)),
            Enemy(Vector2D(500, 520)),
        ]
        
        for enemy in enemies:
            self.game_state.add_object(enemy)
    
    def update_game_logic(self, delta_time: float):
        """æ›´æ–°æ¸¸æˆé€»è¾‘"""
        # å¤„ç†ç©å®¶è¾“å…¥
        self.player.handle_input(self.input_manager, delta_time)
        
        # æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨åœ°é¢ä¸Š
        self.player.on_ground = False
        for obj in self.game_state.game_objects:
            if isinstance(obj, Platform):
                if self.physics_engine.check_collision(self.player, obj):
                    if self.player.velocity.y > 0:  # ä»ä¸Šæ–¹ç¢°æ’
                        self.player.position.y = obj.position.y - self.player.size.y
                        self.player.velocity.y = 0
                        self.player.on_ground = True
        
        # æ£€æŸ¥ç©å®¶ä¸æ•Œäººçš„ç¢°æ’
        for obj in self.game_state.game_objects:
            if isinstance(obj, Enemy):
                if self.physics_engine.check_collision(self.player, obj):
                    self.game_state.game_over = True
        
        # æ£€æŸ¥ç©å®¶æ˜¯å¦æ‰å‡ºå±å¹•
        if self.player.position.y > 600:
            self.game_state.game_over = True
        
        # æ›´æ–°åˆ†æ•°
        self.game_state.score = int(self.game_state.time * 10)
    
    def render(self):
        """æ¸²æŸ“æ¸¸æˆ"""
        self.renderer.clear()
        
        # æ¸²æŸ“æ¸¸æˆå¯¹è±¡
        for obj in self.game_state.game_objects:
            if obj.active:
                if isinstance(obj, Player):
                    color = (0, 255, 0)  # ç»¿è‰²
                elif isinstance(obj, Enemy):
                    color = (255, 0, 0)  # çº¢è‰²
                elif isinstance(obj, Platform):
                    color = (128, 128, 128)  # ç°è‰²
                else:
                    color = (255, 255, 255)  # ç™½è‰²
                
                self.renderer.draw_object(obj, color)
        
        # æ¸²æŸ“UI
        self.renderer.draw_text(
            f"Score: {self.game_state.score}",
            Vector2D(10, 10),
            (255, 255, 255)
        )
        
        if self.game_state.game_over:
            self.renderer.draw_text(
                "Game Over!",
                Vector2D(350, 250),
                (255, 0, 0)
            )
        
        self.renderer.update()

def run_platformer_game():
    """è¿è¡Œå¹³å°è·³è·ƒæ¸¸æˆ"""
    game = PlatformerGame()
    try:
        game.run()
    finally:
        game.quit()

if __name__ == "__main__":
    run_platformer_game()
```

## 4. ç†è®ºè¯æ˜

### 4.1 æ¸¸æˆå¾ªç¯ç¨³å®šæ€§

**å®šç† 4.1** (æ¸¸æˆå¾ªç¯ç¨³å®šæ€§)
åœ¨å›ºå®šæ—¶é—´æ­¥é•¿ä¸‹ï¼Œæ¸¸æˆå¾ªç¯èƒ½å¤Ÿä¿æŒç¨³å®šçš„å¸§ç‡ã€‚

**è¯æ˜**:
1. **æ—¶é—´æ­¥é•¿**: ä½¿ç”¨å›ºå®šçš„delta_timeç¡®ä¿ç‰©ç†æ¨¡æ‹Ÿçš„ä¸€è‡´æ€§
2. **å¸§ç‡æ§åˆ¶**: é€šè¿‡clock.tick()æ§åˆ¶å¸§ç‡
3. **çŠ¶æ€æ›´æ–°**: æ¯æ¬¡å¾ªç¯éƒ½å®Œæ•´æ›´æ–°æ¸¸æˆçŠ¶æ€

### 4.2 ç¢°æ’æ£€æµ‹æ­£ç¡®æ€§

**å®šç† 4.2** (ç¢°æ’æ£€æµ‹æ­£ç¡®æ€§)
AABBç¢°æ’æ£€æµ‹ç®—æ³•èƒ½å¤Ÿæ­£ç¡®æ£€æµ‹çŸ©å½¢ç‰©ä½“çš„ç¢°æ’ã€‚

**è¯æ˜**:
1. **å……åˆ†æ€§**: å¦‚æœä¸¤ä¸ªçŸ©å½¢é‡å ï¼Œåˆ™æ»¡è¶³AABBæ¡ä»¶
2. **å¿…è¦æ€§**: å¦‚æœæ»¡è¶³AABBæ¡ä»¶ï¼Œåˆ™ä¸¤ä¸ªçŸ©å½¢é‡å 
3. **æ­£ç¡®æ€§**: ç®—æ³•èƒ½å¤Ÿæ£€æµ‹æ‰€æœ‰ç¢°æ’æƒ…å†µ

## 5. æ€§èƒ½åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦

- **ç¢°æ’æ£€æµ‹**: $O(n^2)$ å…¶ä¸­ $n$ æ˜¯æ¸¸æˆå¯¹è±¡æ•°é‡
- **æ¸²æŸ“**: $O(n)$ ç»˜åˆ¶æ‰€æœ‰å¯è§å¯¹è±¡
- **ç‰©ç†æ›´æ–°**: $O(n)$ æ›´æ–°æ‰€æœ‰å¯¹è±¡çŠ¶æ€

### 5.2 ç©ºé—´å¤æ‚åº¦

- **æ¸¸æˆå¯¹è±¡**: $O(n)$ å­˜å‚¨æ‰€æœ‰å¯¹è±¡
- **ç¢°æ’æ£€æµ‹**: $O(n^2)$ å­˜å‚¨ç¢°æ’å¯¹
- **æ¸²æŸ“**: $O(1)$ å›ºå®šå¤§å°çš„å±å¹•ç¼“å†²åŒº

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 ç®€å•å°„å‡»æ¸¸æˆ

```python
class ShooterGame(GameEngine):
    """å°„å‡»æ¸¸æˆ"""
    
    def __init__(self):
        super().__init__(800, 600)
        
        # åˆ›å»ºç©å®¶
        self.player = Player(Vector2D(400, 550))
        self.game_state.add_object(self.player)
        
        # å­å¼¹åˆ—è¡¨
        self.bullets: List[GameObject] = []
        
        # æ•Œäººç”Ÿæˆè®¡æ—¶å™¨
        self.enemy_spawn_timer = 0.0
    
    def update_game_logic(self, delta_time: float):
        """æ›´æ–°æ¸¸æˆé€»è¾‘"""
        # å¤„ç†ç©å®¶è¾“å…¥
        self.player.handle_input(self.input_manager, delta_time)
        
        # å°„å‡»
        if self.input_manager.is_key_pressed(pygame.K_SPACE):
            self.shoot()
        
        # ç”Ÿæˆæ•Œäºº
        self.enemy_spawn_timer += delta_time
        if self.enemy_spawn_timer >= 2.0:  # æ¯2ç§’ç”Ÿæˆä¸€ä¸ªæ•Œäºº
            self.spawn_enemy()
            self.enemy_spawn_timer = 0.0
        
        # æ›´æ–°å­å¼¹
        self.update_bullets(delta_time)
        
        # æ£€æŸ¥ç¢°æ’
        self.check_bullet_collisions()
    
    def shoot(self):
        """å°„å‡»"""
        bullet = GameObject(
            Vector2D(self.player.position.x + 16, self.player.position.y),
            Vector2D(0, -400),
            Vector2D(4, 8)
        )
        self.bullets.append(bullet)
        self.game_state.add_object(bullet)
    
    def spawn_enemy(self):
        """ç”Ÿæˆæ•Œäºº"""
        x = random.randint(0, 800 - 24)
        enemy = Enemy(Vector2D(x, 0))
        self.game_state.add_object(enemy)
    
    def update_bullets(self, delta_time: float):
        """æ›´æ–°å­å¼¹"""
        for bullet in self.bullets[:]:
            bullet.update(delta_time)
            
            # ç§»é™¤è¶…å‡ºå±å¹•çš„å­å¼¹
            if bullet.position.y < 0:
                self.bullets.remove(bullet)
                self.game_state.remove_object(bullet)
    
    def check_bullet_collisions(self):
        """æ£€æŸ¥å­å¼¹ç¢°æ’"""
        for bullet in self.bullets[:]:
            for obj in self.game_state.game_objects:
                if isinstance(obj, Enemy):
                    if self.physics_engine.check_collision(bullet, obj):
                        # ç§»é™¤å­å¼¹å’Œæ•Œäºº
                        self.bullets.remove(bullet)
                        self.game_state.remove_object(bullet)
                        self.game_state.remove_object(obj)
                        self.game_state.score += 100
                        break

def run_shooter_game():
    """è¿è¡Œå°„å‡»æ¸¸æˆ"""
    game = ShooterGame()
    try:
        game.run()
    finally:
        game.quit()

if __name__ == "__main__":
    run_shooter_game()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–ç†è®ºè§’åº¦é˜è¿°äº†æ¸¸æˆå¼€å‘çš„æ ¸å¿ƒæ¦‚å¿µï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æ¸¸æˆç³»ç»Ÿã€çŠ¶æ€ã€å¾ªç¯çš„å½¢å¼åŒ–å®šä¹‰
2. **æ ¸å¿ƒæ¦‚å¿µ**: æ¸¸æˆå¼•æ“æ¶æ„ã€ç‰©ç†å¼•æ“
3. **Pythonå®ç°**: å®Œæ•´çš„æ¸¸æˆå¼•æ“ã€ç‰©ç†å¼•æ“ã€è¾“å…¥ç³»ç»Ÿå®ç°
4. **ç†è®ºè¯æ˜**: æ¸¸æˆå¾ªç¯ç¨³å®šæ€§å’Œç¢°æ’æ£€æµ‹æ­£ç¡®æ€§
5. **åº”ç”¨ç¤ºä¾‹**: å¹³å°è·³è·ƒæ¸¸æˆå’Œå°„å‡»æ¸¸æˆ

æ¸¸æˆå¼€å‘æŠ€æœ¯ä¸ºåˆ›å»ºäº¤äº’å¼å¨±ä¹åº”ç”¨æä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆï¼Œé€šè¿‡æ¨¡å—åŒ–çš„æ¶æ„è®¾è®¡å®ç°äº†é«˜æ•ˆçš„æ¸¸æˆå¼€å‘æµç¨‹ã€‚

---

*æœ¬æ–‡æ¡£æ˜¯è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®—ç§‘å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„å½¢å¼åŒ–è§„èŒƒå’Œå­¦æœ¯æ ‡å‡†ã€‚* 