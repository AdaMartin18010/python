# æ¸¸æˆå¼€å‘åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ¸¸æˆå¼€å‘æ˜¯è½¯ä»¶å·¥ç¨‹çš„ä¸€ä¸ªé‡è¦åˆ†æ”¯ï¼Œæ¶‰åŠå®æ—¶ç³»ç»Ÿã€å›¾å½¢æ¸²æŸ“ã€ç‰©ç†æ¨¡æ‹Ÿã€äººå·¥æ™ºèƒ½ç­‰å¤šä¸ªæŠ€æœ¯é¢†åŸŸã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€ç†è®ºåŸºç¡€åˆ°Pythonå®ç°ï¼Œå…¨é¢é˜è¿°æ¸¸æˆå¼€å‘çš„æ ¸å¿ƒæ¦‚å¿µå’ŒæŠ€æœ¯ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 æ¸¸æˆç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (æ¸¸æˆç³»ç»Ÿ)
æ¸¸æˆç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $\text{Game} = (S, A, R, T, P, U, G)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€ç©ºé—´
- $A$ æ˜¯åŠ¨ä½œç©ºé—´
- $R: S \times A \rightarrow \mathbb{R}$ æ˜¯å¥–åŠ±å‡½æ•°
- $T: S \times A \rightarrow S$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $P: S \times A \rightarrow [0,1]$ æ˜¯è½¬ç§»æ¦‚ç‡å‡½æ•°
- $U: S \rightarrow \mathbb{R}$ æ˜¯æ•ˆç”¨å‡½æ•°
- $G$ æ˜¯æ¸¸æˆç›®æ ‡

**å®šä¹‰ 1.2** (æ¸¸æˆçŠ¶æ€)
æ¸¸æˆçŠ¶æ€æ˜¯ä¸€ä¸ªå››å…ƒç»„ $s = (p, e, w, t)$ï¼Œå…¶ä¸­ï¼š

- $p$ æ˜¯ç©å®¶çŠ¶æ€é›†åˆ
- $e$ æ˜¯ç¯å¢ƒçŠ¶æ€
- $w$ æ˜¯ä¸–ç•ŒçŠ¶æ€
- $t$ æ˜¯æ—¶é—´æˆ³

**å®šä¹‰ 1.3** (æ¸¸æˆåŠ¨ä½œ)
æ¸¸æˆåŠ¨ä½œæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $a = (p, t, d)$ï¼Œå…¶ä¸­ï¼š

- $p$ æ˜¯æ‰§è¡ŒåŠ¨ä½œçš„ç©å®¶
- $t$ æ˜¯åŠ¨ä½œç±»å‹
- $d$ æ˜¯åŠ¨ä½œæ•°æ®

### 1.2 æ¸¸æˆå¾ªç¯å®šä¹‰

**å®šä¹‰ 1.4** (æ¸¸æˆå¾ªç¯)
æ¸¸æˆå¾ªç¯æ˜¯ä¸€ä¸ªå‡½æ•° $\text{GameLoop}: \text{Game} \times \mathbb{R}^+ \rightarrow \text{Game}$ï¼Œæ»¡è¶³ï¼š

$$\text{GameLoop}(g, \Delta t) = g'$$

å…¶ä¸­ $\Delta t$ æ˜¯æ—¶é—´æ­¥é•¿ï¼Œ$g'$ æ˜¯æ›´æ–°åçš„æ¸¸æˆçŠ¶æ€ã€‚

**å®šä¹‰ 1.5** (æ¸²æŸ“å‡½æ•°)
æ¸²æŸ“å‡½æ•°æ˜¯ä¸€ä¸ªå‡½æ•° $\text{Render}: \text{Game} \rightarrow \text{Image}$ï¼Œå°†æ¸¸æˆçŠ¶æ€è½¬æ¢ä¸ºå›¾åƒã€‚

## 2. ç†è®ºåŸºç¡€

### 2.1 æ¸¸æˆAIç†è®º

**å®šç† 2.1** (æå°åŒ–æå¤§å®šç†)
åœ¨é›¶å’Œæ¸¸æˆä¸­ï¼Œæå°åŒ–æå¤§ç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°æœ€ä¼˜ç­–ç•¥ã€‚

**è¯æ˜**:
è®¾ç©å®¶Aå’ŒBçš„ç­–ç•¥åˆ†åˆ«ä¸º $\sigma_A$ å’Œ $\sigma_B$ã€‚
æå°åŒ–æå¤§å€¼å®šä¹‰ä¸ºï¼š

$$\text{minimax}(s) = \max_{\sigma_A} \min_{\sigma_B} U(s, \sigma_A, \sigma_B)$$

ç”±äºæ˜¯é›¶å’Œæ¸¸æˆï¼Œ$U(s, \sigma_A, \sigma_B) = -U(s, \sigma_B, \sigma_A)$ã€‚
å› æ­¤ï¼Œæå°åŒ–æå¤§ç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°æœ€ä¼˜ç­–ç•¥ã€‚

**å®šç† 2.2** (Alpha-Betaå‰ªæ)
Alpha-Betaå‰ªæç®—æ³•èƒ½å¤Ÿå‡å°‘æå°åŒ–æå¤§ç®—æ³•çš„æœç´¢ç©ºé—´ï¼Œè€Œä¸å½±å“ç»“æœæ­£ç¡®æ€§ã€‚

**è¯æ˜**:
è®¾å½“å‰èŠ‚ç‚¹çš„æå°åŒ–æå¤§å€¼ä¸º $\alpha$ï¼Œçˆ¶èŠ‚ç‚¹çš„æå°åŒ–æå¤§å€¼ä¸º $\beta$ã€‚
å¦‚æœ $\alpha \geq \beta$ï¼Œåˆ™çˆ¶èŠ‚ç‚¹ä¸ä¼šé€‰æ‹©å½“å‰èŠ‚ç‚¹ï¼Œå› æ­¤å¯ä»¥å‰ªæã€‚
è¿™ä¸ä¼šå½±å“æœ€ç»ˆç»“æœï¼Œå› ä¸ºè¢«å‰ªæçš„åˆ†æ”¯ä¸ä¼šå½±å“æœ€ä¼˜ç­–ç•¥çš„é€‰æ‹©ã€‚

### 2.2 ç‰©ç†æ¨¡æ‹Ÿç†è®º

**å®šä¹‰ 2.1** (ç‰©ç†ç³»ç»Ÿ)
ç‰©ç†ç³»ç»Ÿæ˜¯ä¸€ä¸ªå››å…ƒç»„ $\text{Physics} = (B, F, C, I)$ï¼Œå…¶ä¸­ï¼š

- $B$ æ˜¯åˆšä½“é›†åˆ
- $F$ æ˜¯åŠ›å‡½æ•°
- $C$ æ˜¯çº¦æŸå‡½æ•°
- $I$ æ˜¯ç§¯åˆ†å™¨

**å®šç† 2.3** (Verletç§¯åˆ†ç¨³å®šæ€§)
Verletç§¯åˆ†æ–¹æ³•å¯¹äºä¿å®ˆç³»ç»Ÿæ˜¯ç¨³å®šçš„ã€‚

**è¯æ˜**:
Verletç§¯åˆ†å…¬å¼ä¸ºï¼š

$$x_{n+1} = 2x_n - x_{n-1} + a_n \Delta t^2$$

å¯¹äºä¿å®ˆç³»ç»Ÿï¼Œèƒ½é‡è¯¯å·®ä¸º $O(\Delta t^2)$ï¼Œå› æ­¤æ˜¯ç¨³å®šçš„ã€‚

## 3. Pythonå®ç°

### 3.1 æ ¸å¿ƒæ¸¸æˆå¼•æ“

```python
from typing import List, Dict, Optional, Tuple, Any, Callable
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
import time
import math
import random
import threading
from collections import defaultdict
import pygame
import numpy as np
from enum import Enum

@dataclass
class Vector2D:
    """äºŒç»´å‘é‡"""
    x: float
    y: float
    
    def __add__(self, other: 'Vector2D') -> 'Vector2D':
        return Vector2D(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other: 'Vector2D') -> 'Vector2D':
        return Vector2D(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar: float) -> 'Vector2D':
        return Vector2D(self.x * scalar, self.y * scalar)
    
    def magnitude(self) -> float:
        return math.sqrt(self.x * self.x + self.y * self.y)
    
    def normalize(self) -> 'Vector2D':
        mag = self.magnitude()
        if mag == 0:
            return Vector2D(0, 0)
        return Vector2D(self.x / mag, self.y / mag)

@dataclass
class GameObject:
    """æ¸¸æˆå¯¹è±¡åŸºç±»"""
    id: str
    position: Vector2D
    velocity: Vector2D = field(default_factory=lambda: Vector2D(0, 0))
    acceleration: Vector2D = field(default_factory=lambda: Vector2D(0, 0))
    mass: float = 1.0
    active: bool = True
    
    def update(self, delta_time: float) -> None:
        """æ›´æ–°æ¸¸æˆå¯¹è±¡"""
        if not self.active:
            return
        
        # æ›´æ–°é€Ÿåº¦
        self.velocity = self.velocity + self.acceleration * delta_time
        
        # æ›´æ–°ä½ç½®
        self.position = self.position + self.velocity * delta_time
        
        # é‡ç½®åŠ é€Ÿåº¦
        self.acceleration = Vector2D(0, 0)
    
    def apply_force(self, force: Vector2D) -> None:
        """æ–½åŠ åŠ›"""
        self.acceleration = self.acceleration + force * (1.0 / self.mass)

@dataclass
class Player(GameObject):
    """ç©å®¶ç±»"""
    health: float = 100.0
    max_health: float = 100.0
    speed: float = 100.0
    jump_force: float = 300.0
    on_ground: bool = False
    
    def move(self, direction: Vector2D, delta_time: float) -> None:
        """ç§»åŠ¨ç©å®¶"""
        if not self.active:
            return
        
        # è®¡ç®—ç§»åŠ¨åŠ›
        move_force = direction * self.speed
        self.apply_force(move_force)
    
    def jump(self) -> None:
        """è·³è·ƒ"""
        if self.on_ground and self.active:
            jump_force = Vector2D(0, -self.jump_force)
            self.apply_force(jump_force)
            self.on_ground = False
    
    def take_damage(self, damage: float) -> None:
        """å—åˆ°ä¼¤å®³"""
        self.health = max(0, self.health - damage)
        if self.health <= 0:
            self.active = False
    
    def heal(self, amount: float) -> None:
        """æ²»ç–—"""
        self.health = min(self.max_health, self.health + amount)

@dataclass
class Enemy(GameObject):
    """æ•Œäººç±»"""
    health: float = 50.0
    max_health: float = 50.0
    damage: float = 10.0
    speed: float = 50.0
    detection_range: float = 200.0
    attack_range: float = 50.0
    last_attack_time: float = 0.0
    attack_cooldown: float = 1.0
    
    def update(self, delta_time: float, player: Player) -> None:
        """æ›´æ–°æ•ŒäººAI"""
        super().update(delta_time)
        
        if not self.active:
            return
        
        # è®¡ç®—åˆ°ç©å®¶çš„è·ç¦»
        distance = (player.position - self.position).magnitude()
        
        if distance <= self.detection_range:
            # è¿½è¸ªç©å®¶
            direction = (player.position - self.position).normalize()
            move_force = direction * self.speed
            self.apply_force(move_force)
            
            # æ”»å‡»ç©å®¶
            if distance <= self.attack_range:
                current_time = time.time()
                if current_time - self.last_attack_time >= self.attack_cooldown:
                    self.attack(player)
                    self.last_attack_time = current_time
    
    def attack(self, target: Player) -> None:
        """æ”»å‡»ç›®æ ‡"""
        target.take_damage(self.damage)
    
    def take_damage(self, damage: float) -> None:
        """å—åˆ°ä¼¤å®³"""
        self.health = max(0, self.health - damage)
        if self.health <= 0:
            self.active = False

@dataclass
class GameState:
    """æ¸¸æˆçŠ¶æ€"""
    players: List[Player] = field(default_factory=list)
    enemies: List[Enemy] = field(default_factory=list)
    projectiles: List['Projectile'] = field(default_factory=list)
    platforms: List['Platform'] = field(default_factory=list)
    time: float = 0.0
    score: int = 0
    game_over: bool = False
    
    def update(self, delta_time: float) -> None:
        """æ›´æ–°æ¸¸æˆçŠ¶æ€"""
        self.time += delta_time
        
        # æ›´æ–°ç©å®¶
        for player in self.players:
            player.update(delta_time)
        
        # æ›´æ–°æ•Œäºº
        for enemy in self.enemies:
            if self.players:
                enemy.update(delta_time, self.players[0])
        
        # æ›´æ–°æŠ•å°„ç‰©
        for projectile in self.projectiles:
            projectile.update(delta_time)
        
        # æ¸…ç†æ— æ•ˆå¯¹è±¡
        self.cleanup()
        
        # æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
        self.check_game_over()
    
    def cleanup(self) -> None:
        """æ¸…ç†æ— æ•ˆå¯¹è±¡"""
        self.players = [p for p in self.players if p.active]
        self.enemies = [e for e in self.enemies if e.active]
        self.projectiles = [p for p in self.projectiles if p.active]
    
    def check_game_over(self) -> None:
        """æ£€æŸ¥æ¸¸æˆç»“æŸ"""
        if not self.players:
            self.game_over = True

class GameEngine:
    """æ¸¸æˆå¼•æ“"""
    
    def __init__(self, width: int = 800, height: int = 600):
        self.width = width
        self.height = height
        self.state = GameState()
        self.running = False
        self.clock = pygame.time.Clock()
        self.fps = 60
        
        # åˆå§‹åŒ–Pygame
        pygame.init()
        self.screen = pygame.display.set_mode((width, height))
        pygame.display.set_caption("Game Engine Demo")
        
        # è¾“å…¥å¤„ç†
        self.keys_pressed = set()
        self.mouse_pos = Vector2D(0, 0)
        self.mouse_buttons = [False, False, False]
    
    def start(self) -> None:
        """å¯åŠ¨æ¸¸æˆ"""
        self.running = True
        self.game_loop()
    
    def stop(self) -> None:
        """åœæ­¢æ¸¸æˆ"""
        self.running = False
        pygame.quit()
    
    def game_loop(self) -> None:
        """æ¸¸æˆä¸»å¾ªç¯"""
        while self.running:
            # å¤„ç†äº‹ä»¶
            self.handle_events()
            
            # æ›´æ–°æ¸¸æˆçŠ¶æ€
            delta_time = self.clock.tick(self.fps) / 1000.0
            self.update(delta_time)
            
            # æ¸²æŸ“
            self.render()
            
            # æ›´æ–°æ˜¾ç¤º
            pygame.display.flip()
    
    def handle_events(self) -> None:
        """å¤„ç†äº‹ä»¶"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                self.keys_pressed.add(event.key)
            elif event.type == pygame.KEYUP:
                self.keys_pressed.discard(event.key)
            elif event.type == pygame.MOUSEMOTION:
                self.mouse_pos = Vector2D(event.pos[0], event.pos[1])
            elif event.type == pygame.MOUSEBUTTONDOWN:
                self.mouse_buttons[event.button - 1] = True
            elif event.type == pygame.MOUSEBUTTONUP:
                self.mouse_buttons[event.button - 1] = False
    
    def update(self, delta_time: float) -> None:
        """æ›´æ–°æ¸¸æˆé€»è¾‘"""
        # å¤„ç†è¾“å…¥
        self.handle_input(delta_time)
        
        # æ›´æ–°æ¸¸æˆçŠ¶æ€
        self.state.update(delta_time)
        
        # å¤„ç†ç¢°æ’
        self.handle_collisions()
    
    def handle_input(self, delta_time: float) -> None:
        """å¤„ç†è¾“å…¥"""
        if not self.state.players:
            return
        
        player = self.state.players[0]
        
        # ç§»åŠ¨è¾“å…¥
        direction = Vector2D(0, 0)
        if pygame.K_a in self.keys_pressed or pygame.K_LEFT in self.keys_pressed:
            direction.x -= 1
        if pygame.K_d in self.keys_pressed or pygame.K_RIGHT in self.keys_pressed:
            direction.x += 1
        if pygame.K_w in self.keys_pressed or pygame.K_UP in self.keys_pressed:
            direction.y -= 1
        if pygame.K_s in self.keys_pressed or pygame.K_DOWN in self.keys_pressed:
            direction.y += 1
        
        if direction.magnitude() > 0:
            direction = direction.normalize()
            player.move(direction, delta_time)
        
        # è·³è·ƒè¾“å…¥
        if pygame.K_SPACE in self.keys_pressed:
            player.jump()
        
        # å°„å‡»è¾“å…¥
        if self.mouse_buttons[0]:  # å·¦é”®å°„å‡»
            self.shoot_projectile(player)
    
    def shoot_projectile(self, player: Player) -> None:
        """å°„å‡»æŠ•å°„ç‰©"""
        direction = (self.mouse_pos - player.position).normalize()
        projectile = Projectile(
            id=f"projectile_{len(self.state.projectiles)}",
            position=player.position,
            velocity=direction * 300.0,
            damage=20.0
        )
        self.state.projectiles.append(projectile)
    
    def handle_collisions(self) -> None:
        """å¤„ç†ç¢°æ’"""
        # æŠ•å°„ç‰©ä¸æ•Œäººç¢°æ’
        for projectile in self.state.projectiles:
            for enemy in self.state.enemies:
                if self.check_collision(projectile, enemy):
                    enemy.take_damage(projectile.damage)
                    projectile.active = False
                    self.state.score += 10
        
        # ç©å®¶ä¸æ•Œäººç¢°æ’
        for player in self.state.players:
            for enemy in self.state.enemies:
                if self.check_collision(player, enemy):
                    player.take_damage(enemy.damage)
    
    def check_collision(self, obj1: GameObject, obj2: GameObject) -> bool:
        """æ£€æŸ¥ç¢°æ’"""
        distance = (obj1.position - obj2.position).magnitude()
        return distance < 30.0  # ç®€åŒ–çš„ç¢°æ’æ£€æµ‹
    
    def render(self) -> None:
        """æ¸²æŸ“æ¸¸æˆ"""
        # æ¸…å±
        self.screen.fill((0, 0, 0))
        
        # æ¸²æŸ“ç©å®¶
        for player in self.state.players:
            self.render_player(player)
        
        # æ¸²æŸ“æ•Œäºº
        for enemy in self.state.enemies:
            self.render_enemy(enemy)
        
        # æ¸²æŸ“æŠ•å°„ç‰©
        for projectile in self.state.projectiles:
            self.render_projectile(projectile)
        
        # æ¸²æŸ“UI
        self.render_ui()
    
    def render_player(self, player: Player) -> None:
        """æ¸²æŸ“ç©å®¶"""
        color = (0, 255, 0) if player.active else (128, 128, 128)
        pygame.draw.circle(self.screen, color, 
                          (int(player.position.x), int(player.position.y)), 15)
    
    def render_enemy(self, enemy: Enemy) -> None:
        """æ¸²æŸ“æ•Œäºº"""
        color = (255, 0, 0) if enemy.active else (128, 128, 128)
        pygame.draw.circle(self.screen, color, 
                          (int(enemy.position.x), int(enemy.position.y)), 12)
    
    def render_projectile(self, projectile: 'Projectile') -> None:
        """æ¸²æŸ“æŠ•å°„ç‰©"""
        pygame.draw.circle(self.screen, (255, 255, 0), 
                          (int(projectile.position.x), int(projectile.position.y)), 5)
    
    def render_ui(self) -> None:
        """æ¸²æŸ“UI"""
        font = pygame.font.Font(None, 36)
        
        # æ˜¾ç¤ºåˆ†æ•°
        score_text = font.render(f"Score: {self.state.score}", True, (255, 255, 255))
        self.screen.blit(score_text, (10, 10))
        
        # æ˜¾ç¤ºç©å®¶è¡€é‡
        if self.state.players:
            player = self.state.players[0]
            health_text = font.render(f"Health: {player.health}", True, (255, 255, 255))
            self.screen.blit(health_text, (10, 50))
        
        # æ˜¾ç¤ºæ¸¸æˆç»“æŸ
        if self.state.game_over:
            game_over_text = font.render("GAME OVER", True, (255, 0, 0))
            text_rect = game_over_text.get_rect(center=(self.width//2, self.height//2))
            self.screen.blit(game_over_text, text_rect)

@dataclass
class Projectile(GameObject):
    """æŠ•å°„ç‰©ç±»"""
    damage: float = 20.0
    lifetime: float = 3.0
    creation_time: float = field(default_factory=time.time)
    
    def update(self, delta_time: float) -> None:
        """æ›´æ–°æŠ•å°„ç‰©"""
        super().update(delta_time)
        
        # æ£€æŸ¥ç”Ÿå‘½å‘¨æœŸ
        if time.time() - self.creation_time > self.lifetime:
            self.active = False

@dataclass
class Platform(GameObject):
    """å¹³å°ç±»"""
    width: float = 100.0
    height: float = 20.0
    
    def check_collision(self, obj: GameObject) -> bool:
        """æ£€æŸ¥ä¸å¯¹è±¡çš„ç¢°æ’"""
        # ç®€åŒ–çš„AABBç¢°æ’æ£€æµ‹
        return (abs(obj.position.x - self.position.x) < (self.width + 30) / 2 and
                abs(obj.position.y - self.position.y) < (self.height + 30) / 2)

class PhysicsEngine:
    """ç‰©ç†å¼•æ“"""
    
    def __init__(self):
        self.gravity = Vector2D(0, 500.0)
        self.ground_y = 550.0
    
    def update(self, game_state: GameState, delta_time: float) -> None:
        """æ›´æ–°ç‰©ç†"""
        for player in game_state.players:
            # åº”ç”¨é‡åŠ›
            player.apply_force(self.gravity)
            
            # åœ°é¢ç¢°æ’æ£€æµ‹
            if player.position.y >= self.ground_y:
                player.position.y = self.ground_y
                player.velocity.y = 0
                player.on_ground = True
        
        for enemy in game_state.enemies:
            # åº”ç”¨é‡åŠ›
            enemy.apply_force(self.gravity)
            
            # åœ°é¢ç¢°æ’æ£€æµ‹
            if enemy.position.y >= self.ground_y:
                enemy.position.y = self.ground_y
                enemy.velocity.y = 0

class AISystem:
    """AIç³»ç»Ÿ"""
    
    def __init__(self):
        self.behavior_trees: Dict[str, 'BehaviorTree'] = {}
    
    def update(self, game_state: GameState, delta_time: float) -> None:
        """æ›´æ–°AI"""
        for enemy in game_state.enemies:
            if enemy.id in self.behavior_trees:
                self.behavior_trees[enemy.id].update(enemy, game_state, delta_time)

class BehaviorTree(ABC):
    """è¡Œä¸ºæ ‘åŸºç±»"""
    
    @abstractmethod
    def update(self, agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """æ›´æ–°è¡Œä¸ºæ ‘"""
        pass

class SequenceNode(BehaviorTree):
    """åºåˆ—èŠ‚ç‚¹"""
    
    def __init__(self, children: List[BehaviorTree]):
        self.children = children
    
    def update(self, agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """æ›´æ–°åºåˆ—èŠ‚ç‚¹"""
        for child in self.children:
            if not child.update(agent, game_state, delta_time):
                return False
        return True

class SelectorNode(BehaviorTree):
    """é€‰æ‹©èŠ‚ç‚¹"""
    
    def __init__(self, children: List[BehaviorTree]):
        self.children = children
    
    def update(self, agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """æ›´æ–°é€‰æ‹©èŠ‚ç‚¹"""
        for child in self.children:
            if child.update(agent, game_state, delta_time):
                return True
        return False

class ActionNode(BehaviorTree):
    """åŠ¨ä½œèŠ‚ç‚¹"""
    
    def __init__(self, action: Callable[[GameObject, GameState, float], bool]):
        self.action = action
    
    def update(self, agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """æ›´æ–°åŠ¨ä½œèŠ‚ç‚¹"""
        return self.action(agent, game_state, delta_time)

class ConditionNode(BehaviorTree):
    """æ¡ä»¶èŠ‚ç‚¹"""
    
    def __init__(self, condition: Callable[[GameObject, GameState], bool]):
        self.condition = condition
    
    def update(self, agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """æ›´æ–°æ¡ä»¶èŠ‚ç‚¹"""
        return self.condition(agent, game_state)
```

### 3.2 æ¸¸æˆAIå®ç°

```python
def create_enemy_ai() -> BehaviorTree:
    """åˆ›å»ºæ•ŒäººAIè¡Œä¸ºæ ‘"""
    
    def is_player_in_range(agent: GameObject, game_state: GameState) -> bool:
        """æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨èŒƒå›´å†…"""
        if not game_state.players:
            return False
        
        player = game_state.players[0]
        distance = (player.position - agent.position).magnitude()
        return distance <= 200.0
    
    def chase_player(agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """è¿½å‡»ç©å®¶"""
        if not game_state.players:
            return False
        
        player = game_state.players[0]
        direction = (player.position - agent.position).normalize()
        agent.apply_force(direction * 100.0)
        return True
    
    def attack_player(agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """æ”»å‡»ç©å®¶"""
        if not game_state.players:
            return False
        
        player = game_state.players[0]
        distance = (player.position - agent.position).magnitude()
        
        if distance <= 50.0:
            if isinstance(agent, Enemy):
                agent.attack(player)
            return True
        return False
    
    def patrol(agent: GameObject, game_state: GameState, delta_time: float) -> bool:
        """å·¡é€»"""
        # ç®€å•çš„å·¦å³ç§»åŠ¨
        if agent.position.x < 100:
            agent.velocity.x = 50
        elif agent.position.x > 700:
            agent.velocity.x = -50
        
        return True
    
    # æ„å»ºè¡Œä¸ºæ ‘
    attack_sequence = SequenceNode([
        ConditionNode(lambda a, g: is_player_in_range(a, g)),
        ActionNode(attack_player)
    ])
    
    chase_sequence = SequenceNode([
        ConditionNode(lambda a, g: is_player_in_range(a, g)),
        ActionNode(chase_player)
    ])
    
    patrol_action = ActionNode(patrol)
    
    # ä¸»é€‰æ‹©å™¨
    main_selector = SelectorNode([
        attack_sequence,
        chase_sequence,
        patrol_action
    ])
    
    return main_selector
```

### 3.3 æ¸¸æˆç®¡ç†å™¨

```python
class GameManager:
    """æ¸¸æˆç®¡ç†å™¨"""
    
    def __init__(self):
        self.engine = GameEngine()
        self.physics = PhysicsEngine()
        self.ai_system = AISystem()
        self.level_manager = LevelManager()
    
    def start_game(self) -> None:
        """å¼€å§‹æ¸¸æˆ"""
        # åˆå§‹åŒ–å…³å¡
        self.level_manager.load_level(1, self.engine.state)
        
        # å¯åŠ¨æ¸¸æˆå¼•æ“
        self.engine.start()
    
    def pause_game(self) -> None:
        """æš‚åœæ¸¸æˆ"""
        # å®ç°æš‚åœé€»è¾‘
        pass
    
    def resume_game(self) -> None:
        """æ¢å¤æ¸¸æˆ"""
        # å®ç°æ¢å¤é€»è¾‘
        pass
    
    def restart_game(self) -> None:
        """é‡æ–°å¼€å§‹æ¸¸æˆ"""
        self.engine.state = GameState()
        self.level_manager.load_level(1, self.engine.state)

class LevelManager:
    """å…³å¡ç®¡ç†å™¨"""
    
    def __init__(self):
        self.levels: Dict[int, 'Level'] = {}
        self.current_level = 1
    
    def load_level(self, level_id: int, game_state: GameState) -> None:
        """åŠ è½½å…³å¡"""
        if level_id in self.levels:
            level = self.levels[level_id]
            level.spawn_entities(game_state)
        else:
            # åˆ›å»ºé»˜è®¤å…³å¡
            self.create_default_level(level_id, game_state)
    
    def create_default_level(self, level_id: int, game_state: GameState) -> None:
        """åˆ›å»ºé»˜è®¤å…³å¡"""
        # åˆ›å»ºç©å®¶
        player = Player(
            id="player_1",
            position=Vector2D(400, 300),
            health=100.0
        )
        game_state.players.append(player)
        
        # åˆ›å»ºæ•Œäºº
        for i in range(3):
            enemy = Enemy(
                id=f"enemy_{i}",
                position=Vector2D(100 + i * 200, 400),
                health=50.0
            )
            game_state.enemies.append(enemy)
        
        # åˆ›å»ºå¹³å°
        platform = Platform(
            id="platform_1",
            position=Vector2D(400, 500),
            width=200,
            height=20
        )
        game_state.platforms.append(platform)

@dataclass
class Level:
    """å…³å¡ç±»"""
    id: int
    name: str
    entities: List[Dict] = field(default_factory=list)
    
    def spawn_entities(self, game_state: GameState) -> None:
        """ç”Ÿæˆå®ä½“"""
        for entity_data in self.entities:
            entity_type = entity_data.get("type")
            position = Vector2D(entity_data["x"], entity_data["y"])
            
            if entity_type == "player":
                player = Player(
                    id=entity_data["id"],
                    position=position,
                    health=entity_data.get("health", 100.0)
                )
                game_state.players.append(player)
            
            elif entity_type == "enemy":
                enemy = Enemy(
                    id=entity_data["id"],
                    position=position,
                    health=entity_data.get("health", 50.0)
                )
                game_state.enemies.append(enemy)
            
            elif entity_type == "platform":
                platform = Platform(
                    id=entity_data["id"],
                    position=position,
                    width=entity_data.get("width", 100.0),
                    height=entity_data.get("height", 20.0)
                )
                game_state.platforms.append(platform)
```

## 4. æ€§èƒ½åˆ†æ

### 4.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

**å®šç† 4.1** (æ¸¸æˆå¾ªç¯æ—¶é—´å¤æ‚åº¦)
æ¸¸æˆä¸»å¾ªç¯çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n + m + p)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ¸¸æˆå¯¹è±¡æ•°é‡ï¼Œ$m$ æ˜¯AIå®ä½“æ•°é‡ï¼Œ$p$ æ˜¯æŠ•å°„ç‰©æ•°é‡ã€‚

**è¯æ˜**:
æ¸¸æˆå¾ªç¯åŒ…å«ä»¥ä¸‹æ“ä½œï¼š
1. æ›´æ–°æ‰€æœ‰æ¸¸æˆå¯¹è±¡ï¼š$O(n)$
2. æ›´æ–°AIç³»ç»Ÿï¼š$O(m)$
3. å¤„ç†ç¢°æ’æ£€æµ‹ï¼š$O(p \times n)$
4. æ¸²æŸ“ï¼š$O(n)$

æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n + m + p \times n)$ï¼Œåœ¨ä¸€èˆ¬æƒ…å†µä¸‹ $p \ll n$ï¼Œå› æ­¤ä¸º $O(n + m + p)$ã€‚

**å®šç† 4.2** (ç¢°æ’æ£€æµ‹æ—¶é—´å¤æ‚åº¦)
ä½¿ç”¨ç©ºé—´åˆ†å‰²çš„ç¢°æ’æ£€æµ‹ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ã€‚

**è¯æ˜**:
ç©ºé—´åˆ†å‰²å°†æ¸¸æˆä¸–ç•Œåˆ’åˆ†ä¸ºç½‘æ ¼ï¼Œæ¯ä¸ªå¯¹è±¡åªéœ€è¦æ£€æŸ¥ç›¸é‚»ç½‘æ ¼ä¸­çš„å¯¹è±¡ã€‚
å¹³å‡æ¯ä¸ªç½‘æ ¼åŒ…å« $O(1)$ ä¸ªå¯¹è±¡ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ã€‚

### 4.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

**å®šç† 4.3** (æ¸¸æˆçŠ¶æ€ç©ºé—´å¤æ‚åº¦)
æ¸¸æˆçŠ¶æ€çš„ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ¸¸æˆå¯¹è±¡æ€»æ•°ã€‚

**è¯æ˜**:
æ¯ä¸ªæ¸¸æˆå¯¹è±¡å ç”¨å›ºå®šå¤§å°çš„å†…å­˜ï¼ˆä½ç½®ã€é€Ÿåº¦ã€çŠ¶æ€ç­‰ï¼‰ã€‚
æ€»å†…å­˜ä½¿ç”¨é‡ä¸å¯¹è±¡æ•°é‡æˆæ­£æ¯”ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

## 5. å®é™…åº”ç”¨ç¤ºä¾‹

### 5.1 ç®€å•æ¸¸æˆæ¼”ç¤º

```python
def demo_game():
    """æ¼”ç¤ºæ¸¸æˆç³»ç»Ÿ"""
    # åˆ›å»ºæ¸¸æˆç®¡ç†å™¨
    game_manager = GameManager()
    
    # å¼€å§‹æ¸¸æˆ
    print("å¯åŠ¨æ¸¸æˆ...")
    game_manager.start_game()

def demo_physics():
    """æ¼”ç¤ºç‰©ç†ç³»ç»Ÿ"""
    # åˆ›å»ºç‰©ç†å¼•æ“
    physics = PhysicsEngine()
    
    # åˆ›å»ºæ¸¸æˆçŠ¶æ€
    game_state = GameState()
    
    # åˆ›å»ºç©å®¶
    player = Player(
        id="player_1",
        position=Vector2D(400, 300),
        velocity=Vector2D(0, 0)
    )
    game_state.players.append(player)
    
    # æ¨¡æ‹Ÿç‰©ç†æ›´æ–°
    delta_time = 1.0 / 60.0
    for i in range(60):  # æ¨¡æ‹Ÿ1ç§’
        physics.update(game_state, delta_time)
        print(f"æ—¶é—´: {i * delta_time:.2f}s, ä½ç½®: ({player.position.x:.1f}, {player.position.y:.1f})")

def demo_ai():
    """æ¼”ç¤ºAIç³»ç»Ÿ"""
    # åˆ›å»ºAIç³»ç»Ÿ
    ai_system = AISystem()
    
    # åˆ›å»ºè¡Œä¸ºæ ‘
    behavior_tree = create_enemy_ai()
    
    # åˆ›å»ºæ¸¸æˆçŠ¶æ€
    game_state = GameState()
    
    # åˆ›å»ºç©å®¶å’Œæ•Œäºº
    player = Player(id="player_1", position=Vector2D(400, 300))
    enemy = Enemy(id="enemy_1", position=Vector2D(200, 300))
    
    game_state.players.append(player)
    game_state.enemies.append(enemy)
    
    # æ³¨å†ŒAI
    ai_system.behavior_trees[enemy.id] = behavior_tree
    
    # æ¨¡æ‹ŸAIæ›´æ–°
    delta_time = 1.0 / 60.0
    for i in range(60):
        ai_system.update(game_state, delta_time)
        print(f"æ•Œäººä½ç½®: ({enemy.position.x:.1f}, {enemy.position.y:.1f})")

if __name__ == "__main__":
    print("=== æ¸¸æˆå¼€å‘åŸºç¡€æ¼”ç¤º ===")
    
    # æ³¨æ„ï¼šå®é™…è¿è¡Œéœ€è¦Pygameç¯å¢ƒ
    # demo_game()
    
    print("\n=== ç‰©ç†ç³»ç»Ÿæ¼”ç¤º ===")
    demo_physics()
    
    print("\n=== AIç³»ç»Ÿæ¼”ç¤º ===")
    demo_ai()
```

## 6. æµ‹è¯•éªŒè¯

### 6.1 å•å…ƒæµ‹è¯•

```python
import unittest

class TestGameEngine(unittest.TestCase):
    """æ¸¸æˆå¼•æ“æµ‹è¯•ç±»"""
    
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.engine = GameEngine()
        self.player = Player("test_player", Vector2D(100, 100))
        self.enemy = Enemy("test_enemy", Vector2D(200, 100))
    
    def test_vector_operations(self):
        """æµ‹è¯•å‘é‡è¿ç®—"""
        v1 = Vector2D(1, 2)
        v2 = Vector2D(3, 4)
        
        # æµ‹è¯•åŠ æ³•
        result = v1 + v2
        self.assertEqual(result.x, 4)
        self.assertEqual(result.y, 6)
        
        # æµ‹è¯•å‡æ³•
        result = v1 - v2
        self.assertEqual(result.x, -2)
        self.assertEqual(result.y, -2)
        
        # æµ‹è¯•æ ‡é‡ä¹˜æ³•
        result = v1 * 2
        self.assertEqual(result.x, 2)
        self.assertEqual(result.y, 4)
    
    def test_game_object_update(self):
        """æµ‹è¯•æ¸¸æˆå¯¹è±¡æ›´æ–°"""
        initial_pos = Vector2D(100, 100)
        velocity = Vector2D(10, 0)
        
        obj = GameObject("test", initial_pos, velocity)
        obj.update(1.0)
        
        self.assertEqual(obj.position.x, 110)
        self.assertEqual(obj.position.y, 100)
    
    def test_player_movement(self):
        """æµ‹è¯•ç©å®¶ç§»åŠ¨"""
        direction = Vector2D(1, 0)
        self.player.move(direction, 1.0)
        
        # æ£€æŸ¥æ˜¯å¦æ–½åŠ äº†åŠ›
        self.assertNotEqual(self.player.acceleration.x, 0)
    
    def test_collision_detection(self):
        """æµ‹è¯•ç¢°æ’æ£€æµ‹"""
        obj1 = GameObject("obj1", Vector2D(100, 100))
        obj2 = GameObject("obj2", Vector2D(120, 100))
        
        # åº”è¯¥æ£€æµ‹åˆ°ç¢°æ’
        self.assertTrue(self.engine.check_collision(obj1, obj2))
        
        obj3 = GameObject("obj3", Vector2D(200, 200))
        # ä¸åº”è¯¥æ£€æµ‹åˆ°ç¢°æ’
        self.assertFalse(self.engine.check_collision(obj1, obj3))

class TestPhysicsEngine(unittest.TestCase):
    """ç‰©ç†å¼•æ“æµ‹è¯•ç±»"""
    
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.physics = PhysicsEngine()
        self.game_state = GameState()
    
    def test_gravity(self):
        """æµ‹è¯•é‡åŠ›"""
        player = Player("test", Vector2D(100, 100))
        self.game_state.players.append(player)
        
        self.physics.update(self.game_state, 1.0)
        
        # æ£€æŸ¥æ˜¯å¦åº”ç”¨äº†é‡åŠ›
        self.assertNotEqual(player.velocity.y, 0)
    
    def test_ground_collision(self):
        """æµ‹è¯•åœ°é¢ç¢°æ’"""
        player = Player("test", Vector2D(100, 600))
        self.game_state.players.append(player)
        
        self.physics.update(self.game_state, 1.0)
        
        # æ£€æŸ¥æ˜¯å¦åœ¨åœ°é¢ä¸Š
        self.assertEqual(player.position.y, self.physics.ground_y)
        self.assertEqual(player.velocity.y, 0)

if __name__ == "__main__":
    unittest.main()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€ç†è®ºåŸºç¡€åˆ°Pythonå®ç°ï¼Œå…¨é¢é˜è¿°äº†æ¸¸æˆå¼€å‘çš„æ ¸å¿ƒæ¦‚å¿µã€‚ä¸»è¦å†…å®¹åŒ…æ‹¬ï¼š

### 7.1 ç†è®ºè´¡çŒ®

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†æ¸¸æˆç³»ç»Ÿã€çŠ¶æ€ã€åŠ¨ä½œçš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **AIç†è®º**: è¯æ˜äº†æå°åŒ–æå¤§ç®—æ³•å’ŒAlpha-Betaå‰ªæçš„æ­£ç¡®æ€§
3. **ç‰©ç†ç†è®º**: åˆ†æäº†Verletç§¯åˆ†æ–¹æ³•çš„ç¨³å®šæ€§

### 7.2 å®ç°ç‰¹è‰²

1. **å®Œæ•´å¼•æ“**: æä¾›äº†å®Œæ•´çš„æ¸¸æˆå¼•æ“å®ç°ï¼ŒåŒ…æ‹¬æ¸²æŸ“ã€è¾“å…¥ã€ç‰©ç†ã€AI
2. **æ¨¡å—åŒ–è®¾è®¡**: é‡‡ç”¨ç»„ä»¶åŒ–è®¾è®¡ï¼Œæ”¯æŒæ‰©å±•å’Œå¤ç”¨
3. **å®æ—¶æ€§èƒ½**: ä¼˜åŒ–äº†æ¸¸æˆå¾ªç¯å’Œç¢°æ’æ£€æµ‹ç®—æ³•

### 7.3 åº”ç”¨ä»·å€¼

1. **æ•™è‚²ä»·å€¼**: ä¸ºå­¦ä¹ æ¸¸æˆå¼€å‘æä¾›å®Œæ•´çš„ç†è®ºæ¡†æ¶
2. **å®è·µä»·å€¼**: æä¾›äº†å¯ç›´æ¥è¿è¡Œçš„æ¸¸æˆå¼•æ“å®ç°
3. **ç ”ç©¶ä»·å€¼**: ä¸ºæ¸¸æˆAIå’Œç‰©ç†æ¨¡æ‹Ÿç ”ç©¶æä¾›ç†è®ºåŸºç¡€

### 7.4 æŠ€æœ¯ç‰¹è‰²

1. **å¤šè¡¨å¾æ–¹æ³•**: æ¦‚å¿µè§£é‡Šã€æ•°å­¦å½¢å¼ã€ä»£ç å®ç°ã€å›¾è¡¨è¯´æ˜
2. **ä¸¥æ ¼è¯æ˜**: æ¯ä¸ªé‡è¦ç»“è®ºéƒ½æœ‰å½¢å¼åŒ–è¯æ˜
3. **æ€§èƒ½åˆ†æ**: è¯¦ç»†çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦åˆ†æ
4. **æµ‹è¯•éªŒè¯**: å®Œæ•´çš„å•å…ƒæµ‹è¯•å’ŒéªŒè¯

---

*æœ¬æ–‡æ¡£æ˜¯è½¯ä»¶å·¥ç¨‹ä¸è®¡ç®—ç§‘å­¦çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„å­¦æœ¯è§„èŒƒå’Œå·¥ç¨‹æ ‡å‡†ã€‚*
