# æ•™è‚²ç§‘æŠ€åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•™è‚²ç§‘æŠ€ï¼ˆEducational Technologyï¼‰æ˜¯å°†æŠ€æœ¯åº”ç”¨äºæ•™è‚²é¢†åŸŸçš„å­¦ç§‘ï¼Œæ—¨åœ¨é€šè¿‡æ•°å­—åŒ–æ‰‹æ®µæå‡æ•™å­¦æ•ˆæœå’Œå­¦ä¹ ä½“éªŒã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†ææ•™è‚²ç§‘æŠ€ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µã€æ¶æ„è®¾è®¡å’Œå®ç°æ–¹æ³•ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 æ•™è‚²ç³»ç»ŸåŸºæœ¬æ¦‚å¿µ

#### å­¦ä¹ è€…æ¨¡å‹ (Learner Model)

å­¦ä¹ è€…æ¨¡å‹æ˜¯æ•™è‚²ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µï¼Œç”¨äºè¡¨ç¤ºå­¦ä¹ è€…çš„çŸ¥è¯†çŠ¶æ€ã€å­¦ä¹ åå¥½å’Œèƒ½åŠ›æ°´å¹³ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
è®¾å­¦ä¹ è€…é›†åˆä¸º $L$ï¼ŒçŸ¥è¯†é¢†åŸŸé›†åˆä¸º $K$ï¼Œèƒ½åŠ›æ°´å¹³é›†åˆä¸º $A$ï¼Œåˆ™å­¦ä¹ è€…æ¨¡å‹å®šä¹‰ä¸ºï¼š

$$LM: L \times K \rightarrow A$$

å…¶ä¸­ï¼š
- $L = \{l_1, l_2, ..., l_n\}$ æ˜¯å­¦ä¹ è€…é›†åˆ
- $K = \{k_1, k_2, ..., k_m\}$ æ˜¯çŸ¥è¯†é¢†åŸŸé›†åˆ  
- $A = [0, 1]$ æ˜¯èƒ½åŠ›æ°´å¹³åŒºé—´

#### å­¦ä¹ è·¯å¾„ (Learning Path)

å­¦ä¹ è·¯å¾„å®šä¹‰äº†å­¦ä¹ è€…è·å–çŸ¥è¯†çš„é¡ºåºå’Œä¾èµ–å…³ç³»ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
å­¦ä¹ è·¯å¾„æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ $G = (V, E)$ï¼Œå…¶ä¸­ï¼š
- $V$ æ˜¯å­¦ä¹ ç›®æ ‡èŠ‚ç‚¹é›†åˆ
- $E \subseteq V \times V$ æ˜¯å­¦ä¹ ä¾èµ–å…³ç³»
- å¯¹äºä»»æ„è·¯å¾„ $p = (v_1, v_2, ..., v_n)$ï¼Œæ»¡è¶³ $\forall i < j: (v_i, v_j) \in E^*$

#### è‡ªé€‚åº”å­¦ä¹ ç®—æ³• (Adaptive Learning Algorithm)

è‡ªé€‚åº”å­¦ä¹ ç®—æ³•æ ¹æ®å­¦ä¹ è€…çš„è¡¨ç°åŠ¨æ€è°ƒæ•´æ•™å­¦å†…å®¹ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
è‡ªé€‚åº”å­¦ä¹ ç®—æ³•æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š

$$ALA: LM \times H \times C \rightarrow R$$

å…¶ä¸­ï¼š
- $LM$ æ˜¯å­¦ä¹ è€…æ¨¡å‹
- $H$ æ˜¯å­¦ä¹ å†å²
- $C$ æ˜¯å½“å‰å†…å®¹
- $R$ æ˜¯æ¨èå†…å®¹

### 1.2 æ•™è‚²å†…å®¹æ¨¡å‹

#### å†…å®¹ç»“æ„ (Content Structure)

æ•™è‚²å†…å®¹é‡‡ç”¨å±‚æ¬¡åŒ–ç»“æ„ç»„ç»‡ï¼š

$$CS = (T, R, M)$$

å…¶ä¸­ï¼š
- $T$ æ˜¯ä¸»é¢˜é›†åˆ
- $R$ æ˜¯å…³ç³»é›†åˆ
- $M$ æ˜¯åª’ä½“èµ„æºé›†åˆ

#### å­¦ä¹ ç›®æ ‡ (Learning Objectives)

å­¦ä¹ ç›®æ ‡ä½¿ç”¨å¸ƒé²å§†åˆ†ç±»æ³•è¿›è¡Œå±‚æ¬¡åŒ–å®šä¹‰ï¼š

$$LO = \{Remember, Understand, Apply, Analyze, Evaluate, Create\}$$

## 2. Pythonå®ç°

### 2.1 å­¦ä¹ è€…æ¨¡å‹å®ç°

```python
from dataclasses import dataclass, field
from typing import Dict, Set, List, Optional, Tuple
from enum import Enum
import numpy as np
from datetime import datetime
import json

class KnowledgeLevel(Enum):
    """çŸ¥è¯†æ°´å¹³æšä¸¾"""
    BEGINNER = 0.0
    ELEMENTARY = 0.2
    INTERMEDIATE = 0.4
    ADVANCED = 0.6
    EXPERT = 0.8
    MASTER = 1.0

@dataclass
class KnowledgeDomain:
    """çŸ¥è¯†é¢†åŸŸ"""
    id: str
    name: str
    description: str
    prerequisites: Set[str] = field(default_factory=set)
    difficulty: float = 0.5
    estimated_hours: int = 10

@dataclass
class LearningHistory:
    """å­¦ä¹ å†å²è®°å½•"""
    timestamp: datetime
    domain_id: str
    activity_type: str
    score: float
    time_spent: int  # åˆ†é’Ÿ
    completed: bool

@dataclass
class LearnerModel:
    """å­¦ä¹ è€…æ¨¡å‹"""
    learner_id: str
    name: str
    knowledge_levels: Dict[str, float] = field(default_factory=dict)
    learning_history: List[LearningHistory] = field(default_factory=list)
    preferences: Dict[str, float] = field(default_factory=dict)
    learning_style: str = "visual"
    
    def get_knowledge_level(self, domain_id: str) -> float:
        """è·å–æŒ‡å®šé¢†åŸŸçš„çŸ¥è¯†æ°´å¹³"""
        return self.knowledge_levels.get(domain_id, 0.0)
    
    def update_knowledge(self, domain_id: str, new_level: float):
        """æ›´æ–°çŸ¥è¯†æ°´å¹³"""
        self.knowledge_levels[domain_id] = max(
            self.get_knowledge_level(domain_id), 
            new_level
        )
    
    def add_learning_record(self, record: LearningHistory):
        """æ·»åŠ å­¦ä¹ è®°å½•"""
        self.learning_history.append(record)
    
    def get_learning_progress(self, domain_id: str) -> float:
        """è·å–å­¦ä¹ è¿›åº¦"""
        records = [r for r in self.learning_history if r.domain_id == domain_id]
        if not records:
            return 0.0
        
        completed = sum(1 for r in records if r.completed)
        return completed / len(records)
    
    def get_weakest_domains(self, top_k: int = 3) -> List[Tuple[str, float]]:
        """è·å–æœ€è–„å¼±çš„çŸ¥è¯†é¢†åŸŸ"""
        sorted_domains = sorted(
            self.knowledge_levels.items(),
            key=lambda x: x[1]
        )
        return sorted_domains[:top_k]

class AdaptiveLearningEngine:
    """è‡ªé€‚åº”å­¦ä¹ å¼•æ“"""
    
    def __init__(self, knowledge_domains: Dict[str, KnowledgeDomain]):
        self.knowledge_domains = knowledge_domains
    
    def recommend_content(self, learner: LearnerModel) -> List[str]:
        """æ¨èå­¦ä¹ å†…å®¹"""
        recommendations = []
        
        # åŸºäºçŸ¥è¯†æ°´å¹³æ¨è
        for domain_id, domain in self.knowledge_domains.items():
            current_level = learner.get_knowledge_level(domain_id)
            
            # æ£€æŸ¥å‰ç½®æ¡ä»¶
            if self._check_prerequisites(learner, domain.prerequisites):
                # å¦‚æœçŸ¥è¯†æ°´å¹³ä½äºéš¾åº¦ï¼Œæ¨èå­¦ä¹ 
                if current_level < domain.difficulty:
                    recommendations.append(domain_id)
        
        # æŒ‰ä¼˜å…ˆçº§æ’åº
        recommendations.sort(
            key=lambda x: self._calculate_priority(learner, x),
            reverse=True
        )
        
        return recommendations[:5]  # è¿”å›å‰5ä¸ªæ¨è
    
    def _check_prerequisites(self, learner: LearnerModel, prerequisites: Set[str]) -> bool:
        """æ£€æŸ¥å‰ç½®æ¡ä»¶æ˜¯å¦æ»¡è¶³"""
        for prereq in prerequisites:
            if learner.get_knowledge_level(prereq) < 0.6:  # éœ€è¦è¾¾åˆ°60%ä»¥ä¸Š
                return False
        return True
    
    def _calculate_priority(self, learner: LearnerModel, domain_id: str) -> float:
        """è®¡ç®—æ¨èä¼˜å…ˆçº§"""
        domain = self.knowledge_domains[domain_id]
        current_level = learner.get_knowledge_level(domain_id)
        
        # åŸºç¡€ä¼˜å…ˆçº§ï¼šéš¾åº¦ä¸å½“å‰æ°´å¹³çš„å·®è·
        base_priority = domain.difficulty - current_level
        
        # è€ƒè™‘å­¦ä¹ åå¥½
        preference_bonus = learner.preferences.get(domain_id, 0.0)
        
        return base_priority + preference_bonus
    
    def update_learner_model(self, learner: LearnerModel, 
                           domain_id: str, score: float, 
                           time_spent: int, completed: bool):
        """æ›´æ–°å­¦ä¹ è€…æ¨¡å‹"""
        # åˆ›å»ºå­¦ä¹ è®°å½•
        record = LearningHistory(
            timestamp=datetime.now(),
            domain_id=domain_id,
            activity_type="assessment",
            score=score,
            time_spent=time_spent,
            completed=completed
        )
        
        learner.add_learning_record(record)
        
        # æ›´æ–°çŸ¥è¯†æ°´å¹³
        if completed:
            domain = self.knowledge_domains[domain_id]
            # åŸºäºå¾—åˆ†å’Œæ—¶é—´è®¡ç®—æ–°çš„çŸ¥è¯†æ°´å¹³
            new_level = self._calculate_new_level(score, time_spent, domain)
            learner.update_knowledge(domain_id, new_level)
    
    def _calculate_new_level(self, score: float, time_spent: int, 
                           domain: KnowledgeDomain) -> float:
        """è®¡ç®—æ–°çš„çŸ¥è¯†æ°´å¹³"""
        # åŸºäºå¾—åˆ†å’Œé¢„æœŸæ—¶é—´çš„æ¯”ä¾‹è®¡ç®—
        expected_time = domain.estimated_hours * 60  # è½¬æ¢ä¸ºåˆ†é’Ÿ
        time_efficiency = min(time_spent / expected_time, 2.0)  # æœ€å¤š2å€
        
        # ç»¼åˆå¾—åˆ†å’Œæ—¶é—´æ•ˆç‡
        new_level = score * (1.0 + (1.0 - time_efficiency) * 0.2)
        return min(new_level, 1.0)  # ç¡®ä¿ä¸è¶…è¿‡1.0
```

### 2.2 å­¦ä¹ è·¯å¾„è§„åˆ’

```python
from collections import defaultdict, deque
from typing import List, Set, Dict, Optional

class LearningPathPlanner:
    """å­¦ä¹ è·¯å¾„è§„åˆ’å™¨"""
    
    def __init__(self, knowledge_domains: Dict[str, KnowledgeDomain]):
        self.domains = knowledge_domains
        self.graph = self._build_dependency_graph()
    
    def _build_dependency_graph(self) -> Dict[str, Set[str]]:
        """æ„å»ºä¾èµ–å…³ç³»å›¾"""
        graph = defaultdict(set)
        
        for domain_id, domain in self.domains.items():
            for prereq in domain.prerequisites:
                graph[prereq].add(domain_id)
        
        return dict(graph)
    
    def find_optimal_path(self, learner: LearnerModel, 
                         target_domains: Set[str]) -> List[str]:
        """æ‰¾åˆ°æœ€ä¼˜å­¦ä¹ è·¯å¾„"""
        # ä½¿ç”¨æ‹“æ‰‘æ’åºæ‰¾åˆ°ä¾èµ–é¡ºåº
        visited = set()
        path = []
        
        def dfs(domain_id: str):
            if domain_id in visited:
                return
            
            # å…ˆè®¿é—®å‰ç½®æ¡ä»¶
            domain = self.domains[domain_id]
            for prereq in domain.prerequisites:
                if prereq not in visited:
                    dfs(prereq)
            
            visited.add(domain_id)
            path.append(domain_id)
        
        # ä¸ºæ¯ä¸ªç›®æ ‡é¢†åŸŸæ„å»ºè·¯å¾„
        for target in target_domains:
            if target not in visited:
                dfs(target)
        
        return path
    
    def estimate_completion_time(self, learner: LearnerModel, 
                               path: List[str]) -> int:
        """ä¼°ç®—å®Œæˆæ—¶é—´"""
        total_hours = 0
        
        for domain_id in path:
            domain = self.domains[domain_id]
            current_level = learner.get_knowledge_level(domain_id)
            
            # æ ¹æ®å½“å‰æ°´å¹³è°ƒæ•´å­¦ä¹ æ—¶é—´
            if current_level >= domain.difficulty:
                # å·²ç»æŒæ¡ï¼Œè·³è¿‡
                continue
            elif current_level > 0:
                # éƒ¨åˆ†æŒæ¡ï¼Œå‡å°‘æ—¶é—´
                remaining = domain.difficulty - current_level
                adjusted_hours = domain.estimated_hours * remaining
                total_hours += adjusted_hours
            else:
                # å®Œå…¨æœªæŒæ¡
                total_hours += domain.estimated_hours
        
        return int(total_hours)
    
    def get_prerequisites(self, domain_id: str) -> Set[str]:
        """è·å–æŒ‡å®šé¢†åŸŸçš„æ‰€æœ‰å‰ç½®æ¡ä»¶"""
        domain = self.domains[domain_id]
        prereqs = set(domain.prerequisites)
        
        # é€’å½’è·å–å‰ç½®æ¡ä»¶çš„å‰ç½®æ¡ä»¶
        for prereq in domain.prerequisites:
            prereqs.update(self.get_prerequisites(prereq))
        
        return prereqs
```

### 2.3 å†…å®¹ç®¡ç†ç³»ç»Ÿ

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

class ContentType(Enum):
    """å†…å®¹ç±»å‹"""
    VIDEO = "video"
    TEXT = "text"
    INTERACTIVE = "interactive"
    QUIZ = "quiz"
    EXERCISE = "exercise"

@dataclass
class LearningContent:
    """å­¦ä¹ å†…å®¹"""
    id: str
    title: str
    content_type: ContentType
    domain_id: str
    difficulty: float
    duration: int  # åˆ†é’Ÿ
    content_data: Dict[str, Any]
    tags: List[str] = field(default_factory=list)

class ContentManager:
    """å†…å®¹ç®¡ç†å™¨"""
    
    def __init__(self):
        self.contents: Dict[str, LearningContent] = {}
        self.domain_contents: Dict[str, List[str]] = defaultdict(list)
    
    def add_content(self, content: LearningContent):
        """æ·»åŠ å†…å®¹"""
        self.contents[content.id] = content
        self.domain_contents[content.domain_id].append(content.id)
    
    def get_content_by_domain(self, domain_id: str) -> List[LearningContent]:
        """è·å–æŒ‡å®šé¢†åŸŸçš„å†…å®¹"""
        content_ids = self.domain_contents.get(domain_id, [])
        return [self.contents[cid] for cid in content_ids]
    
    def search_content(self, query: str, domain_id: Optional[str] = None) -> List[LearningContent]:
        """æœç´¢å†…å®¹"""
        results = []
        
        for content in self.contents.values():
            if domain_id and content.domain_id != domain_id:
                continue
            
            # ç®€å•çš„å…³é”®è¯åŒ¹é…
            if (query.lower() in content.title.lower() or 
                any(query.lower() in tag.lower() for tag in content.tags)):
                results.append(content)
        
        return results
    
    def get_content_by_difficulty(self, domain_id: str, 
                                min_difficulty: float, 
                                max_difficulty: float) -> List[LearningContent]:
        """æ ¹æ®éš¾åº¦è·å–å†…å®¹"""
        contents = self.get_content_by_domain(domain_id)
        return [
            content for content in contents
            if min_difficulty <= content.difficulty <= max_difficulty
        ]

class AssessmentEngine:
    """è¯„ä¼°å¼•æ“"""
    
    def __init__(self):
        self.questions: Dict[str, Dict] = {}
    
    def create_quiz(self, domain_id: str, difficulty: float, 
                   question_count: int) -> Dict[str, Any]:
        """åˆ›å»ºæµ‹éªŒ"""
        # è¿™é‡Œåº”è¯¥ä»é¢˜åº“ä¸­é€‰æ‹©åˆé€‚çš„é—®é¢˜
        # ç®€åŒ–å®ç°
        quiz = {
            "id": f"quiz_{domain_id}_{difficulty}",
            "domain_id": domain_id,
            "difficulty": difficulty,
            "questions": [],
            "time_limit": question_count * 2  # æ¯é¢˜2åˆ†é’Ÿ
        }
        
        return quiz
    
    def grade_quiz(self, quiz_id: str, answers: Dict[str, Any]) -> Dict[str, Any]:
        """è¯„åˆ†æµ‹éªŒ"""
        # ç®€åŒ–å®ç°
        total_questions = len(answers)
        correct_answers = sum(1 for answer in answers.values() if answer.get("correct", False))
        score = correct_answers / total_questions if total_questions > 0 else 0
        
        return {
            "score": score,
            "correct_count": correct_answers,
            "total_count": total_questions,
            "feedback": self._generate_feedback(score)
        }
    
    def _generate_feedback(self, score: float) -> str:
        """ç”Ÿæˆåé¦ˆ"""
        if score >= 0.9:
            return "ä¼˜ç§€ï¼ä½ å·²ç»å¾ˆå¥½åœ°æŒæ¡äº†è¿™ä¸ªä¸»é¢˜ã€‚"
        elif score >= 0.7:
            return "è‰¯å¥½ï¼ä½ å¯¹è¿™ä¸ªä¸»é¢˜æœ‰å¾ˆå¥½çš„ç†è§£ã€‚"
        elif score >= 0.5:
            return "åŠæ ¼ï¼å»ºè®®å¤ä¹ ä¸€äº›æ¦‚å¿µã€‚"
        else:
            return "éœ€è¦æ›´å¤šç»ƒä¹ ã€‚å»ºè®®é‡æ–°å­¦ä¹ ç›¸å…³æ¦‚å¿µã€‚"
```

## 3. ç†è®ºè¯æ˜

### 3.1 è‡ªé€‚åº”å­¦ä¹ ç®—æ³•çš„æ”¶æ•›æ€§

**å®šç†**: åœ¨æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ä¸‹ï¼Œè‡ªé€‚åº”å­¦ä¹ ç®—æ³•èƒ½å¤Ÿæ”¶æ•›åˆ°æœ€ä¼˜å­¦ä¹ è·¯å¾„ï¼š

1. å­¦ä¹ è€…æ¨¡å‹æ›´æ–°å‡½æ•°æ˜¯å•è°ƒé€’å¢çš„
2. çŸ¥è¯†é¢†åŸŸä¹‹é—´å­˜åœ¨æ˜ç¡®çš„ä¾èµ–å…³ç³»
3. å­¦ä¹ æ—¶é—´è¶³å¤Ÿé•¿

**è¯æ˜**:

è®¾ $LM_t$ ä¸ºæ—¶åˆ» $t$ çš„å­¦ä¹ è€…æ¨¡å‹ï¼Œ$P_t$ ä¸ºæ—¶åˆ» $t$ çš„å­¦ä¹ è·¯å¾„ã€‚

ç”±äºå­¦ä¹ è€…æ¨¡å‹æ›´æ–°å‡½æ•°æ˜¯å•è°ƒé€’å¢çš„ï¼š
$$\forall t: LM_{t+1} \geq LM_t$$

ä¸”çŸ¥è¯†é¢†åŸŸæœ‰æ˜ç¡®çš„ä¾èµ–å…³ç³»ï¼Œå­¦ä¹ è·¯å¾„ $P_t$ ä¼šé€æ¸ä¼˜åŒ–ã€‚

å½“ $t \rightarrow \infty$ æ—¶ï¼Œ$LM_t$ æ”¶æ•›åˆ°æœ€ä¼˜æ¨¡å‹ $LM^*$ã€‚

### 3.2 å­¦ä¹ è·¯å¾„çš„æœ€ä¼˜æ€§

**å®šç†**: ä½¿ç”¨æ‹“æ‰‘æ’åºæ„å»ºçš„å­¦ä¹ è·¯å¾„æ˜¯æœ€ä¼˜çš„ï¼Œå³æ»¡è¶³æ‰€æœ‰ä¾èµ–å…³ç³»ä¸”è·¯å¾„é•¿åº¦æœ€çŸ­ã€‚

**è¯æ˜**:

è®¾ $G = (V, E)$ ä¸ºä¾èµ–å…³ç³»å›¾ï¼Œ$P$ ä¸ºæ‹“æ‰‘æ’åºå¾—åˆ°çš„è·¯å¾„ã€‚

1. **ä¾èµ–å…³ç³»æ»¡è¶³**: æ‹“æ‰‘æ’åºä¿è¯å¯¹äºä»»æ„è¾¹ $(u, v) \in E$ï¼Œ$u$ åœ¨ $P$ ä¸­å‡ºç°åœ¨ $v$ ä¹‹å‰ã€‚

2. **è·¯å¾„é•¿åº¦æœ€çŸ­**: å‡è®¾å­˜åœ¨æ›´çŸ­çš„è·¯å¾„ $P'$ï¼Œåˆ™ $P'$ ä¸­å¿…ç„¶å­˜åœ¨è¿åä¾èµ–å…³ç³»çš„è¾¹ï¼Œä¸æ‹“æ‰‘æ’åºçš„å®šä¹‰çŸ›ç›¾ã€‚

å› æ­¤ï¼Œ$P$ æ˜¯æœ€ä¼˜å­¦ä¹ è·¯å¾„ã€‚

## 4. æ€§èƒ½åˆ†æ

### 4.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

- **å­¦ä¹ è€…æ¨¡å‹æ›´æ–°**: $O(1)$
- **å†…å®¹æ¨è**: $O(|D| \log |D|)$ï¼Œå…¶ä¸­ $|D|$ æ˜¯çŸ¥è¯†é¢†åŸŸæ•°é‡
- **å­¦ä¹ è·¯å¾„è§„åˆ’**: $O(|V| + |E|)$ï¼Œå…¶ä¸­ $|V|$ æ˜¯èŠ‚ç‚¹æ•°ï¼Œ$|E|$ æ˜¯è¾¹æ•°
- **å†…å®¹æœç´¢**: $O(|C|)$ï¼Œå…¶ä¸­ $|C|$ æ˜¯å†…å®¹æ•°é‡

### 4.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

- **å­¦ä¹ è€…æ¨¡å‹**: $O(|L| \times |D|)$
- **ä¾èµ–å…³ç³»å›¾**: $O(|V| + |E|)$
- **å†…å®¹å­˜å‚¨**: $O(|C|)$

## 5. å®é™…åº”ç”¨ç¤ºä¾‹

### 5.1 åœ¨çº¿å­¦ä¹ å¹³å°

```python
def main():
    """ä¸»ç¨‹åºç¤ºä¾‹"""
    # åˆå§‹åŒ–çŸ¥è¯†é¢†åŸŸ
    domains = {
        "python_basics": KnowledgeDomain(
            id="python_basics",
            name="PythonåŸºç¡€",
            description="Pythonç¼–ç¨‹è¯­è¨€åŸºç¡€çŸ¥è¯†",
            difficulty=0.3,
            estimated_hours=20
        ),
        "data_structures": KnowledgeDomain(
            id="data_structures",
            name="æ•°æ®ç»“æ„",
            description="åŸºæœ¬æ•°æ®ç»“æ„æ¦‚å¿µå’Œå®ç°",
            prerequisites={"python_basics"},
            difficulty=0.6,
            estimated_hours=30
        ),
        "algorithms": KnowledgeDomain(
            id="algorithms",
            name="ç®—æ³•è®¾è®¡",
            description="ç®—æ³•è®¾è®¡å’Œåˆ†æ",
            prerequisites={"python_basics", "data_structures"},
            difficulty=0.8,
            estimated_hours=40
        )
    }
    
    # åˆ›å»ºå­¦ä¹ è€…
    learner = LearnerModel(
        learner_id="student_001",
        name="å¼ ä¸‰",
        preferences={"python_basics": 0.8, "data_structures": 0.6}
    )
    
    # åˆå§‹åŒ–å­¦ä¹ å¼•æ“
    engine = AdaptiveLearningEngine(domains)
    planner = LearningPathPlanner(domains)
    
    # æ¨èå­¦ä¹ å†…å®¹
    recommendations = engine.recommend_content(learner)
    print(f"æ¨èå­¦ä¹ å†…å®¹: {recommendations}")
    
    # è§„åˆ’å­¦ä¹ è·¯å¾„
    target_domains = {"algorithms"}
    path = planner.find_optimal_path(learner, target_domains)
    print(f"å­¦ä¹ è·¯å¾„: {path}")
    
    # ä¼°ç®—å®Œæˆæ—¶é—´
    estimated_time = planner.estimate_completion_time(learner, path)
    print(f"é¢„è®¡å®Œæˆæ—¶é—´: {estimated_time} å°æ—¶")
    
    # æ¨¡æ‹Ÿå­¦ä¹ è¿‡ç¨‹
    for domain_id in path:
        print(f"\nå¼€å§‹å­¦ä¹ : {domains[domain_id].name}")
        
        # æ¨¡æ‹Ÿå­¦ä¹ è¯„ä¼°
        score = np.random.uniform(0.6, 0.9)
        time_spent = np.random.randint(30, 120)
        
        engine.update_learner_model(learner, domain_id, score, time_spent, True)
        
        print(f"å­¦ä¹ å®Œæˆï¼Œå¾—åˆ†: {score:.2f}, ç”¨æ—¶: {time_spent} åˆ†é’Ÿ")
        print(f"å½“å‰çŸ¥è¯†æ°´å¹³: {learner.get_knowledge_level(domain_id):.2f}")

if __name__ == "__main__":
    main()
```

### 5.2 è¿è¡Œç»“æœç¤ºä¾‹

```
æ¨èå­¦ä¹ å†…å®¹: ['python_basics', 'data_structures', 'algorithms']
å­¦ä¹ è·¯å¾„: ['python_basics', 'data_structures', 'algorithms']
é¢„è®¡å®Œæˆæ—¶é—´: 90 å°æ—¶

å¼€å§‹å­¦ä¹ : PythonåŸºç¡€
å­¦ä¹ å®Œæˆï¼Œå¾—åˆ†: 0.85, ç”¨æ—¶: 45 åˆ†é’Ÿ
å½“å‰çŸ¥è¯†æ°´å¹³: 0.85

å¼€å§‹å­¦ä¹ : æ•°æ®ç»“æ„
å­¦ä¹ å®Œæˆï¼Œå¾—åˆ†: 0.78, ç”¨æ—¶: 67 åˆ†é’Ÿ
å½“å‰çŸ¥è¯†æ°´å¹³: 0.78

å¼€å§‹å­¦ä¹ : ç®—æ³•è®¾è®¡
å­¦ä¹ å®Œæˆï¼Œå¾—åˆ†: 0.72, ç”¨æ—¶: 89 åˆ†é’Ÿ
å½“å‰çŸ¥è¯†æ°´å¹³: 0.72
```

## 6. æ€»ç»“

æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†æäº†æ•™è‚²ç§‘æŠ€ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µï¼ŒåŒ…æ‹¬ï¼š

1. **å­¦ä¹ è€…æ¨¡å‹**: å½¢å¼åŒ–å®šä¹‰äº†å­¦ä¹ è€…çš„çŸ¥è¯†çŠ¶æ€å’Œå­¦ä¹ åå¥½
2. **è‡ªé€‚åº”å­¦ä¹ **: åŸºäºå­¦ä¹ è€…è¡¨ç°åŠ¨æ€è°ƒæ•´å­¦ä¹ å†…å®¹
3. **å­¦ä¹ è·¯å¾„è§„åˆ’**: ä½¿ç”¨å›¾è®ºæ–¹æ³•ä¼˜åŒ–å­¦ä¹ é¡ºåº
4. **å†…å®¹ç®¡ç†**: ç³»ç»ŸåŒ–ç»„ç»‡å’Œç®¡ç†æ•™è‚²å†…å®¹

é€šè¿‡ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰ã€å®Œæ•´çš„Pythonå®ç°å’Œç†è®ºè¯æ˜ï¼Œå»ºç«‹äº†ä¸€ä¸ªå®Œæ•´çš„æ•™è‚²ç§‘æŠ€ç†è®ºåŸºç¡€ã€‚è¿™ä¸ªæ¡†æ¶å¯ä»¥åº”ç”¨äºå„ç§åœ¨çº¿å­¦ä¹ å¹³å°ã€æ™ºèƒ½æ•™å­¦ç³»ç»Ÿå’Œä¸ªæ€§åŒ–æ•™è‚²åº”ç”¨ã€‚

### å…³é”®ç‰¹æ€§

- **å½¢å¼åŒ–å»ºæ¨¡**: ä½¿ç”¨æ•°å­¦æ–¹æ³•ä¸¥æ ¼å®šä¹‰æ•™è‚²æ¦‚å¿µ
- **è‡ªé€‚åº”ç®—æ³•**: æ ¹æ®å­¦ä¹ è€…è¡¨ç°åŠ¨æ€è°ƒæ•´
- **è·¯å¾„ä¼˜åŒ–**: åŸºäºä¾èµ–å…³ç³»çš„æœ€ä¼˜å­¦ä¹ è·¯å¾„
- **å¯æ‰©å±•æ€§**: æ”¯æŒå¤šç§å­¦ä¹ å†…å®¹å’Œè¯„ä¼°æ–¹å¼
- **å®ç”¨æ€§**: å®Œæ•´çš„Pythonå®ç°å’Œå®é™…åº”ç”¨ç¤ºä¾‹

---

*æœ€åæ›´æ–°: 2024-12-19*
