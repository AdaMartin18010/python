# åˆ†å¸ƒå¼ç®—æ³•

## ğŸ“‹ æ¦‚è¿°

åˆ†å¸ƒå¼ç®—æ³•æ˜¯è§£å†³åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å„ç§é—®é¢˜çš„ç®—æ³•é›†åˆï¼ŒåŒ…æ‹¬å…±è¯†ç®—æ³•ã€åˆ†å¸ƒå¼æ’åºã€åˆ†å¸ƒå¼æœç´¢ç­‰ã€‚æœ¬æ–‡æ¡£æä¾›åˆ†å¸ƒå¼ç®—æ³•çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. åˆ†å¸ƒå¼ç®—æ³•å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**åˆ†å¸ƒå¼ç®—æ³•å››å…ƒç»„**:
$$\mathcal{DA} = (P, M, S, T)$$

å…¶ä¸­ï¼š
- $P = \{p_1, p_2, ..., p_n\}$ æ˜¯è¿›ç¨‹é›†åˆ
- $M = \{m_1, m_2, ..., m_k\}$ æ˜¯æ¶ˆæ¯é›†åˆ
- $S = \{s_1, s_2, ..., s_m\}$ æ˜¯çŠ¶æ€é›†åˆ
- $T: P \times M \times S \rightarrow P \times S$ æ˜¯è½¬ç§»å‡½æ•°

#### 1.2 ç®—æ³•åˆ†ç±»

**åŒæ­¥ç®—æ³•**:
$$\forall p_i, p_j \in P: \Delta t_{i,j} \leq \delta$$

**å¼‚æ­¥ç®—æ³•**:
$$\exists p_i, p_j \in P: \Delta t_{i,j} > \delta$$

**éƒ¨åˆ†åŒæ­¥ç®—æ³•**:
$$\exists \delta: \forall p_i, p_j \in P: \Delta t_{i,j} \leq \delta$$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Set, Optional, Any, Tuple, Callable
from collections import defaultdict, deque
import time
import uuid
import asyncio
import threading
import random
import heapq
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MessageType(Enum):
    """æ¶ˆæ¯ç±»å‹æšä¸¾"""
    REQUEST = "request"
    RESPONSE = "response"
    ACK = "ack"
    NACK = "nack"
    HEARTBEAT = "heartbeat"
    ELECTION = "election"
    VOTE = "vote"

class ProcessState(Enum):
    """è¿›ç¨‹çŠ¶æ€æšä¸¾"""
    ACTIVE = "active"
    PASSIVE = "passive"
    FAILED = "failed"
    RECOVERING = "recovering"

@dataclass
class Message:
    """æ¶ˆæ¯å®šä¹‰"""
    id: str
    type: MessageType
    sender: str
    receiver: str
    data: Any
    timestamp: float
    sequence_number: int = 0
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = time.time()

@dataclass
class Process:
    """è¿›ç¨‹å®šä¹‰"""
    id: str
    state: ProcessState
    neighbors: List[str]
    data: Dict[str, Any] = field(default_factory=dict)
    message_queue: deque = field(default_factory=deque)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

class DistributedAlgorithm(ABC):
    """åˆ†å¸ƒå¼ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    def __init__(self, process_id: str, processes: List[str]):
        self.process_id = process_id
        self.processes = processes
        self.state = ProcessState.ACTIVE
        self.message_queue = deque()
        self.sequence_number = 0
        self.lock = threading.Lock()
        
    @abstractmethod
    async def execute(self, input_data: Any) -> Any:
        """æ‰§è¡Œç®—æ³•"""
        pass
    
    @abstractmethod
    async def handle_message(self, message: Message) -> Optional[Message]:
        """å¤„ç†æ¶ˆæ¯"""
        pass
    
    def send_message(self, receiver: str, message_type: MessageType, data: Any) -> Message:
        """å‘é€æ¶ˆæ¯"""
        with self.lock:
            self.sequence_number += 1
            message = Message(
                type=message_type,
                sender=self.process_id,
                receiver=receiver,
                data=data,
                sequence_number=self.sequence_number
            )
            self.message_queue.append(message)
            return message

class DistributedSortingAlgorithm(DistributedAlgorithm):
    """åˆ†å¸ƒå¼æ’åºç®—æ³•"""
    
    def __init__(self, process_id: str, processes: List[str]):
        super().__init__(process_id, processes)
        self.local_data: List[int] = []
        self.sorted_data: List[int] = []
        self.partition_size = 0
        self.current_phase = 0
        
    async def execute(self, input_data: List[int]) -> List[int]:
        """æ‰§è¡Œåˆ†å¸ƒå¼æ’åº"""
        self.local_data = input_data.copy()
        self.partition_size = len(input_data) // len(self.processes)
        
        # Phase 1: æœ¬åœ°æ’åº
        await self._local_sort()
        
        # Phase 2: åˆ†å¸ƒå¼å½’å¹¶
        await self._distributed_merge()
        
        # Phase 3: æ”¶é›†ç»“æœ
        return await self._collect_results()
    
    async def _local_sort(self):
        """æœ¬åœ°æ’åº"""
        self.local_data.sort()
        logger.info(f"Process {self.process_id} completed local sort: {self.local_data}")
    
    async def _distributed_merge(self):
        """åˆ†å¸ƒå¼å½’å¹¶"""
        # ä½¿ç”¨å½’å¹¶æ’åºçš„æ€æƒ³è¿›è¡Œåˆ†å¸ƒå¼å½’å¹¶
        for phase in range(len(self.processes).bit_length()):
            partner = self._get_merge_partner(phase)
            if partner:
                await self._merge_with_partner(partner)
    
    def _get_merge_partner(self, phase: int) -> Optional[str]:
        """è·å–å½’å¹¶ä¼™ä¼´"""
        process_index = self.processes.index(self.process_id)
        partner_index = process_index ^ (1 << phase)
        if 0 <= partner_index < len(self.processes):
            return self.processes[partner_index]
        return None
    
    async def _merge_with_partner(self, partner: str):
        """ä¸ä¼™ä¼´å½’å¹¶"""
        # å‘é€æœ¬åœ°æ•°æ®ç»™ä¼™ä¼´
        message = self.send_message(partner, MessageType.REQUEST, self.local_data)
        
        # æ¨¡æ‹Ÿæ¥æ”¶ä¼™ä¼´æ•°æ®
        partner_data = [random.randint(1, 100) for _ in range(len(self.local_data))]
        
        # å½’å¹¶æ•°æ®
        merged_data = self._merge_sorted_arrays(self.local_data, partner_data)
        
        # ä¿ç•™å‰åŠéƒ¨åˆ†
        mid = len(merged_data) // 2
        if self.processes.index(self.process_id) < self.processes.index(partner):
            self.local_data = merged_data[:mid]
        else:
            self.local_data = merged_data[mid:]
        
        logger.info(f"Process {self.process_id} merged with {partner}: {self.local_data}")
    
    def _merge_sorted_arrays(self, arr1: List[int], arr2: List[int]) -> List[int]:
        """å½’å¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
        result = []
        i = j = 0
        
        while i < len(arr1) and j < len(arr2):
            if arr1[i] <= arr2[j]:
                result.append(arr1[i])
                i += 1
            else:
                result.append(arr2[j])
                j += 1
        
        result.extend(arr1[i:])
        result.extend(arr2[j:])
        return result
    
    async def _collect_results(self) -> List[int]:
        """æ”¶é›†ç»“æœ"""
        if self.process_id == self.processes[0]:  # ä¸»è¿›ç¨‹æ”¶é›†
            all_data = []
            for process in self.processes:
                # æ¨¡æ‹Ÿä»å…¶ä»–è¿›ç¨‹æ”¶é›†æ•°æ®
                process_data = [random.randint(1, 100) for _ in range(self.partition_size)]
                all_data.extend(process_data)
            return sorted(all_data)
        else:
            return self.local_data
    
    async def handle_message(self, message: Message) -> Optional[Message]:
        """å¤„ç†æ¶ˆæ¯"""
        if message.type == MessageType.REQUEST:
            # è¿”å›æœ¬åœ°æ•°æ®
            return Message(
                type=MessageType.RESPONSE,
                sender=self.process_id,
                receiver=message.sender,
                data=self.local_data
            )
        return None

class DistributedSearchAlgorithm(DistributedAlgorithm):
    """åˆ†å¸ƒå¼æœç´¢ç®—æ³•"""
    
    def __init__(self, process_id: str, processes: List[str]):
        super().__init__(process_id, processes)
        self.local_index: Dict[str, List[int]] = defaultdict(list)
        self.search_results: List[Tuple[str, int]] = []
        
    async def execute(self, query: str) -> List[Tuple[str, int]]:
        """æ‰§è¡Œåˆ†å¸ƒå¼æœç´¢"""
        self.search_results.clear()
        
        # Phase 1: æœ¬åœ°æœç´¢
        local_results = await self._local_search(query)
        self.search_results.extend(local_results)
        
        # Phase 2: åˆ†å¸ƒå¼æœç´¢
        await self._distributed_search(query)
        
        # Phase 3: èšåˆç»“æœ
        return await self._aggregate_results()
    
    async def _local_search(self, query: str) -> List[Tuple[str, int]]:
        """æœ¬åœ°æœç´¢"""
        results = []
        for key, positions in self.local_index.items():
            if query.lower() in key.lower():
                for pos in positions:
                    results.append((key, pos))
        return results
    
    async def _distributed_search(self, query: str):
        """åˆ†å¸ƒå¼æœç´¢"""
        # å‘å…¶ä»–è¿›ç¨‹å‘é€æœç´¢è¯·æ±‚
        for process in self.processes:
            if process != self.process_id:
                message = self.send_message(process, MessageType.REQUEST, query)
        
        # æ¨¡æ‹Ÿæ¥æ”¶æœç´¢ç»“æœ
        for process in self.processes:
            if process != self.process_id:
                # æ¨¡æ‹Ÿæœç´¢ç»“æœ
                mock_results = [(f"result_from_{process}", random.randint(1, 100))]
                self.search_results.extend(mock_results)
    
    async def _aggregate_results(self) -> List[Tuple[str, int]]:
        """èšåˆç»“æœ"""
        # æŒ‰ç›¸å…³æ€§æ’åº
        self.search_results.sort(key=lambda x: x[1], reverse=True)
        return self.search_results
    
    def build_index(self, documents: List[str]):
        """æ„å»ºç´¢å¼•"""
        for i, doc in enumerate(documents):
            words = doc.lower().split()
            for word in words:
                self.local_index[word].append(i)
    
    async def handle_message(self, message: Message) -> Optional[Message]:
        """å¤„ç†æ¶ˆæ¯"""
        if message.type == MessageType.REQUEST:
            # æ‰§è¡Œæœ¬åœ°æœç´¢
            results = await self._local_search(message.data)
            return Message(
                type=MessageType.RESPONSE,
                sender=self.process_id,
                receiver=message.sender,
                data=results
            )
        return None

class DistributedGraphAlgorithm(DistributedAlgorithm):
    """åˆ†å¸ƒå¼å›¾ç®—æ³•"""
    
    def __init__(self, process_id: str, processes: List[str]):
        super().__init__(process_id, processes)
        self.graph: Dict[str, List[str]] = defaultdict(list)
        self.distances: Dict[str, int] = defaultdict(lambda: float('inf'))
        self.predecessors: Dict[str, str] = {}
        
    async def execute(self, start_node: str, end_node: str) -> Optional[List[str]]:
        """æ‰§è¡Œåˆ†å¸ƒå¼æœ€çŸ­è·¯å¾„ç®—æ³•"""
        # åˆå§‹åŒ–
        self.distances[start_node] = 0
        self.predecessors[start_node] = start_node
        
        # åˆ†å¸ƒå¼Bellman-Fordç®—æ³•
        for _ in range(len(self.graph) - 1):
            await self._distributed_relaxation()
        
        # æ£€æŸ¥è´Ÿç¯
        if await self._check_negative_cycle():
            return None
        
        # é‡å»ºè·¯å¾„
        return self._reconstruct_path(start_node, end_node)
    
    async def _distributed_relaxation(self):
        """åˆ†å¸ƒå¼æ¾å¼›æ“ä½œ"""
        # å‘é‚»å±…å‘é€è·ç¦»æ›´æ–°
        for node in self.graph:
            if self.distances[node] != float('inf'):
                for neighbor in self.graph[node]:
                    message = self.send_message(
                        neighbor, 
                        MessageType.REQUEST, 
                        {"node": node, "distance": self.distances[node]}
                    )
        
        # æ¨¡æ‹Ÿæ¥æ”¶æ›´æ–°
        for node in self.graph:
            for neighbor in self.graph[node]:
                # æ¨¡æ‹Ÿè·ç¦»æ›´æ–°
                new_distance = self.distances[node] + 1  # å‡è®¾è¾¹æƒé‡ä¸º1
                if new_distance < self.distances[neighbor]:
                    self.distances[neighbor] = new_distance
                    self.predecessors[neighbor] = node
    
    async def _check_negative_cycle(self) -> bool:
        """æ£€æŸ¥è´Ÿç¯"""
        # æ‰§è¡Œé¢å¤–çš„æ¾å¼›æ“ä½œ
        for node in self.graph:
            if self.distances[node] != float('inf'):
                for neighbor in self.graph[node]:
                    new_distance = self.distances[node] + 1
                    if new_distance < self.distances[neighbor]:
                        return True  # å‘ç°è´Ÿç¯
        return False
    
    def _reconstruct_path(self, start: str, end: str) -> List[str]:
        """é‡å»ºè·¯å¾„"""
        if self.distances[end] == float('inf'):
            return []
        
        path = [end]
        current = end
        
        while current != start:
            current = self.predecessors[current]
            path.append(current)
        
        return path[::-1]
    
    def add_edge(self, u: str, v: str):
        """æ·»åŠ è¾¹"""
        self.graph[u].append(v)
    
    async def handle_message(self, message: Message) -> Optional[Message]:
        """å¤„ç†æ¶ˆæ¯"""
        if message.type == MessageType.REQUEST:
            data = message.data
            node = data["node"]
            distance = data["distance"]
            
            # æ›´æ–°è·ç¦»
            if distance + 1 < self.distances[node]:
                self.distances[node] = distance + 1
                self.predecessors[node] = node
            
            return Message(
                type=MessageType.ACK,
                sender=self.process_id,
                receiver=message.sender,
                data={"updated": True}
            )
        return None

class DistributedConsensusAlgorithm(DistributedAlgorithm):
    """åˆ†å¸ƒå¼å…±è¯†ç®—æ³•"""
    
    def __init__(self, process_id: str, processes: List[str]):
        super().__init__(process_id, processes)
        self.proposed_value = None
        self.decided_value = None
        self.promises: Dict[int, Any] = {}
        self.accepted_values: Dict[int, Any] = {}
        self.proposal_number = 0
        
    async def execute(self, value: Any) -> Any:
        """æ‰§è¡Œå…±è¯†ç®—æ³•"""
        self.proposed_value = value
        
        # Phase 1: Prepare
        promises = await self._prepare_phase()
        
        if len(promises) <= len(self.processes) / 2:
            logger.warning(f"Process {self.process_id} did not receive enough promises")
            return None
        
        # Phase 2: Accept
        accepted = await self._accept_phase()
        
        if len(accepted) > len(self.processes) / 2:
            self.decided_value = self.proposed_value
            return self.decided_value
        
        return None
    
    async def _prepare_phase(self) -> List[Dict]:
        """å‡†å¤‡é˜¶æ®µ"""
        self.proposal_number += 1
        promises = []
        
        for process in self.processes:
            if process != self.process_id:
                message = self.send_message(
                    process,
                    MessageType.REQUEST,
                    {"phase": "prepare", "proposal_number": self.proposal_number}
                )
                # æ¨¡æ‹Ÿå“åº”
                promises.append({"process": process, "promised": True})
        
        return promises
    
    async def _accept_phase(self) -> List[Dict]:
        """æ¥å—é˜¶æ®µ"""
        accepted = []
        
        for process in self.processes:
            if process != self.process_id:
                message = self.send_message(
                    process,
                    MessageType.REQUEST,
                    {
                        "phase": "accept",
                        "proposal_number": self.proposal_number,
                        "value": self.proposed_value
                    }
                )
                # æ¨¡æ‹Ÿå“åº”
                accepted.append({"process": process, "accepted": True})
        
        return accepted
    
    async def handle_message(self, message: Message) -> Optional[Message]:
        """å¤„ç†æ¶ˆæ¯"""
        data = message.data
        
        if data["phase"] == "prepare":
            # å‡†å¤‡é˜¶æ®µå“åº”
            return Message(
                type=MessageType.RESPONSE,
                sender=self.process_id,
                receiver=message.sender,
                data={"promised": True, "proposal_number": data["proposal_number"]}
            )
        
        elif data["phase"] == "accept":
            # æ¥å—é˜¶æ®µå“åº”
            self.accepted_values[data["proposal_number"]] = data["value"]
            return Message(
                type=MessageType.ACK,
                sender=self.process_id,
                receiver=message.sender,
                data={"accepted": True}
            )
        
        return None

class DistributedAlgorithmManager:
    """åˆ†å¸ƒå¼ç®—æ³•ç®¡ç†å™¨"""
    
    def __init__(self, process_id: str, processes: List[str]):
        self.process_id = process_id
        self.processes = processes
        self.algorithms = {
            "sorting": DistributedSortingAlgorithm(process_id, processes),
            "search": DistributedSearchAlgorithm(process_id, processes),
            "graph": DistributedGraphAlgorithm(process_id, processes),
            "consensus": DistributedConsensusAlgorithm(process_id, processes)
        }
    
    async def execute_algorithm(self, algorithm_type: str, input_data: Any) -> Any:
        """æ‰§è¡ŒæŒ‡å®šç®—æ³•"""
        if algorithm_type not in self.algorithms:
            raise ValueError(f"Unsupported algorithm type: {algorithm_type}")
        
        algorithm = self.algorithms[algorithm_type]
        return await algorithm.execute(input_data)
    
    def get_algorithm_status(self, algorithm_type: str) -> Dict[str, Any]:
        """è·å–ç®—æ³•çŠ¶æ€"""
        if algorithm_type not in self.algorithms:
            return {"error": f"Algorithm {algorithm_type} not found"}
        
        algorithm = self.algorithms[algorithm_type]
        return {
            "process_id": self.process_id,
            "algorithm_type": algorithm_type,
            "state": algorithm.state.value,
            "message_queue_size": len(algorithm.message_queue)
        }
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
async def demonstrate_distributed_algorithms():
    """æ¼”ç¤ºåˆ†å¸ƒå¼ç®—æ³•"""
    processes = ["process1", "process2", "process3", "process4"]
    
    # åˆ›å»ºç®—æ³•ç®¡ç†å™¨
    managers = []
    for process_id in processes:
        managers.append(DistributedAlgorithmManager(process_id, processes))
    
    # æ¼”ç¤ºåˆ†å¸ƒå¼æ’åº
    print("=== Distributed Sorting Demo ===")
    input_data = [64, 34, 25, 12, 22, 11, 90]
    
    for i, manager in enumerate(managers):
        result = await manager.execute_algorithm("sorting", input_data)
        print(f"Process {processes[i]} sorting result: {result}")
    
    # æ¼”ç¤ºåˆ†å¸ƒå¼æœç´¢
    print("\n=== Distributed Search Demo ===")
    documents = [
        "Python programming language",
        "Distributed systems theory",
        "Algorithm design and analysis",
        "Computer science fundamentals"
    ]
    
    # æ„å»ºç´¢å¼•
    for manager in managers:
        search_algorithm = manager.algorithms["search"]
        search_algorithm.build_index(documents)
    
    query = "Python"
    for i, manager in enumerate(managers):
        result = await manager.execute_algorithm("search", query)
        print(f"Process {processes[i]} search result: {result}")
    
    # æ¼”ç¤ºåˆ†å¸ƒå¼å›¾ç®—æ³•
    print("\n=== Distributed Graph Algorithm Demo ===")
    for manager in managers:
        graph_algorithm = manager.algorithms["graph"]
        graph_algorithm.add_edge("A", "B")
        graph_algorithm.add_edge("B", "C")
        graph_algorithm.add_edge("A", "C")
        graph_algorithm.add_edge("C", "D")
    
    for i, manager in enumerate(managers):
        result = await manager.execute_algorithm("graph", ("A", "D"))
        print(f"Process {processes[i]} shortest path: {result}")
    
    # æ¼”ç¤ºåˆ†å¸ƒå¼å…±è¯†
    print("\n=== Distributed Consensus Demo ===")
    for i, manager in enumerate(managers):
        value = f"value_from_{processes[i]}"
        result = await manager.execute_algorithm("consensus", value)
        print(f"Process {processes[i]} consensus result: {result}")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    asyncio.run(demonstrate_distributed_algorithms())
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**åˆ†å¸ƒå¼æ’åº**:
- æœ¬åœ°æ’åº: $O(n \log n)$
- åˆ†å¸ƒå¼å½’å¹¶: $O(\log p \cdot n)$
- æ€»å¤æ‚åº¦: $O(n \log n + \log p \cdot n)$

**åˆ†å¸ƒå¼æœç´¢**:
- æœ¬åœ°æœç´¢: $O(m)$ å…¶ä¸­ $m$ æ˜¯æœ¬åœ°æ–‡æ¡£æ•°
- åˆ†å¸ƒå¼æœç´¢: $O(p \cdot m)$
- æ€»å¤æ‚åº¦: $O(p \cdot m)$

**åˆ†å¸ƒå¼å›¾ç®—æ³•**:
- Bellman-Ford: $O(V \cdot E)$
- åˆ†å¸ƒå¼ç‰ˆæœ¬: $O(V \cdot E \cdot p)$
- æ€»å¤æ‚åº¦: $O(V \cdot E \cdot p)$

#### 4.2 ç©ºé—´å¤æ‚åº¦

**æ’åºç®—æ³•**: $O(n)$
**æœç´¢ç®—æ³•**: $O(m)$
**å›¾ç®—æ³•**: $O(V + E)$
**å…±è¯†ç®—æ³•**: $O(p)$

### 5. é€šä¿¡å¤æ‚åº¦

#### 5.1 æ¶ˆæ¯æ•°é‡

**æ’åºç®—æ³•**: $O(p \log p)$
**æœç´¢ç®—æ³•**: $O(p)$
**å›¾ç®—æ³•**: $O(V \cdot E \cdot p)$
**å…±è¯†ç®—æ³•**: $O(p^2)$

#### 5.2 æ¶ˆæ¯å¤§å°

**æ’åºç®—æ³•**: $O(n/p)$
**æœç´¢ç®—æ³•**: $O(m/p)$
**å›¾ç®—æ³•**: $O(1)$
**å…±è¯†ç®—æ³•**: $O(1)$

## ğŸ”— ç›¸å…³é“¾æ¥

- [ä¸€è‡´æ€§åè®®](./03-04-02-ä¸€è‡´æ€§åè®®.md)
- [åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](./03-04-01-åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€.md)
- [ç®—æ³•ç†è®º](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., et al. (2009). "Introduction to Algorithms". MIT Press.
2. Lynch, N. A. (1996). "Distributed Algorithms". Morgan Kaufmann.
3. Attiya, H., & Welch, J. (2004). "Distributed Computing: Fundamentals, Simulations, and Advanced Topics". Wiley.

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant 