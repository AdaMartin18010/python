# 01. 创建型模式

## 导航
- [上级目录](../README.md)
- [同级目录](./README.md)
- [下级目录](./02-结构型模式.md)

## 1. 形式化定义

### 1.1 创建型模式基础

**定义 1.1.1** (创建型模式)
创建型模式是处理对象创建机制的设计模式，它们试图在适合特定情况的场景下创建对象。

$$\text{创建型模式} = (C, F, R, \mathcal{I})$$

其中：
- $C$ 是创建者集合
- $F$ 是工厂函数集合
- $R$ 是创建规则集合
- $\mathcal{I}$ 是实例化接口

**定义 1.1.2** (对象创建)
对象创建是一个映射 $create: P \rightarrow O$，其中 $P$ 是参数空间，$O$ 是对象空间。

### 1.2 单例模式

**定义 1.2.1** (单例模式)
单例模式确保一个类只有一个实例，并提供全局访问点。

$$\text{Singleton}(C) = \{instance \in C | \forall c \in C, c = instance\}$$

**形式化约束**：
- 唯一性：$\forall x, y \in \text{Singleton}(C), x = y$
- 全局访问：$\exists g: \rightarrow \text{Singleton}(C)$

### 1.3 工厂方法模式

**定义 1.3.1** (工厂方法)
工厂方法定义一个创建对象的接口，让子类决定实例化哪个类。

$$\text{FactoryMethod} = (Creator, Product, factory\_method)$$

其中：
- $Creator$ 是创建者抽象类
- $Product$ 是产品抽象类
- $factory\_method: Creator \rightarrow Product$ 是工厂方法

### 1.4 抽象工厂模式

**定义 1.4.1** (抽象工厂)
抽象工厂提供一个创建一系列相关对象的接口。

$$\text{AbstractFactory} = (Factory, ProductFamily, create\_methods)$$

其中：
- $Factory$ 是工厂接口
- $ProductFamily = \{P_1, P_2, ..., P_n\}$ 是产品族
- $create\_methods = \{create_{P_1}, create_{P_2}, ..., create_{P_n}\}$

## 2. Python实现

### 2.1 单例模式

```python
from typing import TypeVar, Type, Dict, Any
from threading import Lock
from abc import ABC, abstractmethod
import weakref

T = TypeVar('T')

class SingletonMeta(type):
    """单例元类"""
    
    _instances: Dict[Type, Any] = {}
    _lock = Lock()
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            with cls._lock:
                if cls not in cls._instances:
                    cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Singleton(metaclass=SingletonMeta):
    """单例基类"""
    
    def __init__(self):
        self._data: Dict[str, Any] = {}
    
    def set_data(self, key: str, value: Any):
        """设置数据"""
        self._data[key] = value
    
    def get_data(self, key: str) -> Any:
        """获取数据"""
        return self._data.get(key)
    
    def __repr__(self):
        return f"{self.__class__.__name__}(id={id(self)})"

class Configuration(Singleton):
    """配置管理器单例"""
    
    def __init__(self):
        super().__init__()
        self._config = {}
    
    def load_config(self, config_dict: Dict[str, Any]):
        """加载配置"""
        self._config.update(config_dict)
    
    def get(self, key: str, default=None):
        """获取配置值"""
        return self._config.get(key, default)
    
    def set(self, key: str, value: Any):
        """设置配置值"""
        self._config[key] = value

# 使用示例
def test_singleton():
    """测试单例模式"""
    config1 = Configuration()
    config2 = Configuration()
    
    print(f"config1: {config1}")
    print(f"config2: {config2}")
    print(f"config1 is config2: {config1 is config2}")
    
    config1.set("database_url", "postgresql://localhost:5432/mydb")
    config1.set("api_key", "secret_key_123")
    
    print(f"config2.get('database_url'): {config2.get('database_url')}")
    print(f"config2.get('api_key'): {config2.get('api_key')}")

if __name__ == "__main__":
    test_singleton()
```

### 2.2 工厂方法模式

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Dict, Type
from dataclasses import dataclass

# 类型变量
ProductType = TypeVar('ProductType')

class Product(ABC):
    """产品抽象基类"""
    
    @abstractmethod
    def operation(self) -> str:
        """产品操作"""
        pass

class ConcreteProductA(Product):
    """具体产品A"""
    
    def operation(self) -> str:
        return "ConcreteProductA operation"

class ConcreteProductB(Product):
    """具体产品B"""
    
    def operation(self) -> str:
        return "ConcreteProductB operation"

class Creator(ABC):
    """创建者抽象基类"""
    
    @abstractmethod
    def factory_method(self) -> Product:
        """工厂方法"""
        pass
    
    def some_operation(self) -> str:
        """使用工厂方法创建产品并执行操作"""
        product = self.factory_method()
        return f"Creator: {product.operation()}"

class ConcreteCreatorA(Creator):
    """具体创建者A"""
    
    def factory_method(self) -> Product:
        return ConcreteProductA()

class ConcreteCreatorB(Creator):
    """具体创建者B"""
    
    def factory_method(self) -> Product:
        return ConcreteProductB()

# 工厂方法注册器
class ProductRegistry:
    """产品注册器"""
    
    def __init__(self):
        self._creators: Dict[str, Type[Creator]] = {}
    
    def register(self, name: str, creator_class: Type[Creator]):
        """注册创建者"""
        self._creators[name] = creator_class
    
    def create(self, name: str) -> Product:
        """通过名称创建产品"""
        if name not in self._creators:
            raise ValueError(f"Unknown product type: {name}")
        
        creator = self._creators[name]()
        return creator.factory_method()
    
    def list_products(self) -> list[str]:
        """列出所有可用的产品类型"""
        return list(self._creators.keys())

# 使用示例
def test_factory_method():
    """测试工厂方法模式"""
    # 直接使用
    creator_a = ConcreteCreatorA()
    creator_b = ConcreteCreatorB()
    
    print(creator_a.some_operation())
    print(creator_b.some_operation())
    
    # 使用注册器
    registry = ProductRegistry()
    registry.register("A", ConcreteCreatorA)
    registry.register("B", ConcreteCreatorB)
    
    print(f"Available products: {registry.list_products()}")
    
    product_a = registry.create("A")
    product_b = registry.create("B")
    
    print(f"Product A: {product_a.operation()}")
    print(f"Product B: {product_b.operation()}")

if __name__ == "__main__":
    test_factory_method()
```

### 2.3 抽象工厂模式

```python
from abc import ABC, abstractmethod
from typing import Dict, Type, Any
from dataclasses import dataclass

class AbstractProductA(ABC):
    """抽象产品A"""
    
    @abstractmethod
    def useful_function_a(self) -> str:
        pass

class AbstractProductB(ABC):
    """抽象产品B"""
    
    @abstractmethod
    def useful_function_b(self) -> str:
        pass
    
    @abstractmethod
    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
        pass

class ConcreteProductA1(AbstractProductA):
    """具体产品A1"""
    
    def useful_function_a(self) -> str:
        return "The result of the product A1."

class ConcreteProductA2(AbstractProductA):
    """具体产品A2"""
    
    def useful_function_a(self) -> str:
        return "The result of the product A2."

class ConcreteProductB1(AbstractProductB):
    """具体产品B1"""
    
    def useful_function_b(self) -> str:
        return "The result of the product B1."
    
    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
        result = collaborator.useful_function_a()
        return f"The result of the B1 collaborating with the ({result})"

class ConcreteProductB2(AbstractProductB):
    """具体产品B2"""
    
    def useful_function_b(self) -> str:
        return "The result of the product B2."
    
    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
        result = collaborator.useful_function_a()
        return f"The result of the B2 collaborating with the ({result})"

class AbstractFactory(ABC):
    """抽象工厂"""
    
    @abstractmethod
    def create_product_a(self) -> AbstractProductA:
        pass
    
    @abstractmethod
    def create_product_b(self) -> AbstractProductB:
        pass

class ConcreteFactory1(AbstractFactory):
    """具体工厂1"""
    
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA1()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB1()

class ConcreteFactory2(AbstractFactory):
    """具体工厂2"""
    
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA2()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB2()

# 工厂管理器
class FactoryManager:
    """工厂管理器"""
    
    def __init__(self):
        self._factories: Dict[str, Type[AbstractFactory]] = {}
    
    def register_factory(self, name: str, factory_class: Type[AbstractFactory]):
        """注册工厂"""
        self._factories[name] = factory_class
    
    def get_factory(self, name: str) -> AbstractFactory:
        """获取工厂实例"""
        if name not in self._factories:
            raise ValueError(f"Unknown factory: {name}")
        
        return self._factories[name]()
    
    def create_product_family(self, factory_name: str) -> Dict[str, Any]:
        """创建完整的产品族"""
        factory = self.get_factory(factory_name)
        return {
            'product_a': factory.create_product_a(),
            'product_b': factory.create_product_b()
        }

def client_code(factory: AbstractFactory) -> str:
    """客户端代码"""
    product_a = factory.create_product_a()
    product_b = factory.create_product_b()
    
    result = []
    result.append(product_b.useful_function_b())
    result.append(product_b.another_useful_function_b(product_a))
    return "\n".join(result)

# 使用示例
def test_abstract_factory():
    """测试抽象工厂模式"""
    # 直接使用
    factory1 = ConcreteFactory1()
    factory2 = ConcreteFactory2()
    
    print("Client: Testing client code with the first factory type...")
    print(client_code(factory1))
    
    print("\nClient: Testing the same client code with the second factory type...")
    print(client_code(factory2))
    
    # 使用工厂管理器
    manager = FactoryManager()
    manager.register_factory("factory1", ConcreteFactory1)
    manager.register_factory("factory2", ConcreteFactory2)
    
    family1 = manager.create_product_family("factory1")
    family2 = manager.create_product_family("factory2")
    
    print(f"\nFamily 1 Product A: {family1['product_a'].useful_function_a()}")
    print(f"Family 2 Product A: {family2['product_a'].useful_function_a()}")

if __name__ == "__main__":
    test_abstract_factory()
```

### 2.4 建造者模式

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Optional, Dict, Any
from dataclasses import dataclass, field

T = TypeVar('T')

@dataclass
class Product:
    """产品类"""
    part_a: Optional[str] = None
    part_b: Optional[str] = None
    part_c: Optional[int] = None
    parts: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        parts_str = ", ".join([f"{k}={v}" for k, v in self.parts.items()])
        return f"Product(part_a={self.part_a}, part_b={self.part_b}, part_c={self.part_c}, parts={{{parts_str}}})"

class Builder(ABC):
    """抽象建造者"""
    
    def __init__(self):
        self.reset()
    
    @abstractmethod
    def reset(self):
        """重置建造者状态"""
        pass
    
    @abstractmethod
    def build_part_a(self, value: str) -> 'Builder':
        """构建部件A"""
        pass
    
    @abstractmethod
    def build_part_b(self, value: str) -> 'Builder':
        """构建部件B"""
        pass
    
    @abstractmethod
    def build_part_c(self, value: int) -> 'Builder':
        """构建部件C"""
        pass
    
    @abstractmethod
    def get_result(self) -> Product:
        """获取构建结果"""
        pass

class ConcreteBuilder(Builder):
    """具体建造者"""
    
    def reset(self):
        self._product = Product()
    
    def build_part_a(self, value: str) -> 'Builder':
        self._product.part_a = value
        return self
    
    def build_part_b(self, value: str) -> 'Builder':
        self._product.part_b = value
        return self
    
    def build_part_c(self, value: int) -> 'Builder':
        self._product.part_c = value
        return self
    
    def add_custom_part(self, name: str, value: Any) -> 'Builder':
        """添加自定义部件"""
        self._product.parts[name] = value
        return self
    
    def get_result(self) -> Product:
        return self._product

class Director:
    """指导者"""
    
    def __init__(self, builder: Builder):
        self._builder = builder
    
    def construct_minimal_product(self) -> Product:
        """构建最小产品"""
        return self._builder.build_part_a("default_a").get_result()
    
    def construct_full_product(self) -> Product:
        """构建完整产品"""
        return (self._builder
                .build_part_a("full_a")
                .build_part_b("full_b")
                .build_part_c(42)
                .add_custom_part("extra", "value")
                .get_result())
    
    def construct_custom_product(self, 
                                part_a: str = None,
                                part_b: str = None,
                                part_c: int = None,
                                **custom_parts) -> Product:
        """构建自定义产品"""
        builder = self._builder.reset()
        
        if part_a:
            builder.build_part_a(part_a)
        if part_b:
            builder.build_part_b(part_b)
        if part_c:
            builder.build_part_c(part_c)
        
        for name, value in custom_parts.items():
            builder.add_custom_part(name, value)
        
        return builder.get_result()

# 使用示例
def test_builder():
    """测试建造者模式"""
    # 直接使用建造者
    builder = ConcreteBuilder()
    
    product1 = (builder
                .build_part_a("Hello")
                .build_part_b("World")
                .build_part_c(123)
                .add_custom_part("timestamp", "2024-01-01")
                .get_result())
    
    print(f"Product 1: {product1}")
    
    # 使用指导者
    director = Director(ConcreteBuilder())
    
    minimal_product = director.construct_minimal_product()
    print(f"Minimal Product: {minimal_product}")
    
    full_product = director.construct_full_product()
    print(f"Full Product: {full_product}")
    
    custom_product = director.construct_custom_product(
        part_a="Custom A",
        part_c=999,
        feature_x="enabled",
        priority="high"
    )
    print(f"Custom Product: {custom_product}")

if __name__ == "__main__":
    test_builder()
```

## 3. 数学证明

### 3.1 单例模式的唯一性

**定理 1.5.1** (单例唯一性)
在单例模式中，对于任意两个实例 $x, y$，都有 $x = y$。

**证明**：
设 $S$ 是单例类的实例集合。
根据单例模式的定义，$|S| = 1$。
因此，对于任意 $x, y \in S$，由于 $S$ 只有一个元素，所以 $x = y$。

### 3.2 工厂方法的可扩展性

**定理 1.5.2** (工厂方法可扩展性)
工厂方法模式支持在不修改现有代码的情况下添加新的产品类型。

**证明**：
设 $Creator$ 是抽象创建者，$Product$ 是抽象产品。
对于新的产品类型 $Product_{new}$，我们只需要：
1. 创建 $Product_{new}$ 实现 $Product$ 接口
2. 创建 $Creator_{new}$ 实现 $Creator$ 接口
3. 在 $Creator_{new}$ 中实现 $factory\_method() \rightarrow Product_{new}$

这不需要修改现有的 $Creator$ 或 $Product$ 代码。

## 4. 应用场景

### 4.1 单例模式
- 配置管理器
- 日志记录器
- 数据库连接池
- 缓存管理器

### 4.2 工厂方法模式
- 插件系统
- 文档处理器
- 图形渲染器
- 网络协议处理器

### 4.3 抽象工厂模式
- GUI组件库
- 数据库抽象层
- 跨平台适配器
- 主题系统

### 4.4 建造者模式
- 复杂对象构建
- 配置对象创建
- 查询构建器
- 报告生成器

## 5. 相关链接

- [结构型模式](./02-结构型模式.md)
- [行为型模式](./03-行为型模式.md)
- [架构模式](../02-架构模式/01-微服务架构.md)
- [设计原则](../../00-理念基础/02-软件工程哲学/01-设计原则.md) 