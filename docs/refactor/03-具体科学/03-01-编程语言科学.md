# 03-01-ç¼–ç¨‹è¯­è¨€ç§‘å­¦

## ğŸ“‹ æ¦‚è¿°

ç¼–ç¨‹è¯­è¨€ç§‘å­¦æ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶ç¼–ç¨‹è¯­è¨€çš„è®¾è®¡ã€å®ç°ã€åˆ†æå’Œåº”ç”¨ã€‚å®ƒç»“åˆäº†å½¢å¼è¯­è¨€ç†è®ºã€ç±»å‹ç†è®ºã€ç¼–è¯‘åŸç†å’Œè¯­è¨€è¿è¡Œæ—¶ç³»ç»Ÿç­‰å¤šä¸ªé¢†åŸŸçš„çŸ¥è¯†ã€‚

**ç›¸å…³æ–‡æ¡£**:

- [01-04-å›¾è®ºåŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-04-å›¾è®ºåŸºç¡€.md) - è¯­æ³•æ ‘å’Œä¾èµ–å›¾
- [02-04-å½¢å¼è¯­è¨€ç†è®º](../02-ç†è®ºåŸºç¡€/02-04-å½¢å¼è¯­è¨€ç†è®º.md) - å½¢å¼è¯­è¨€åŸºç¡€
- [03-02-è½¯ä»¶æ¶æ„ç§‘å­¦](./03-02-è½¯ä»¶æ¶æ„ç§‘å­¦.md) - è¯­è¨€è¿è¡Œæ—¶æ¶æ„

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç¼–ç¨‹è¯­è¨€çš„å®šä¹‰

ç¼–ç¨‹è¯­è¨€æ˜¯ä¸€ç§ç”¨äºç¼–å†™è®¡ç®—æœºç¨‹åºçš„å½¢å¼åŒ–è¯­è¨€ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- **è¯­æ³•**: å®šä¹‰ç¨‹åºçš„ç»“æ„å’Œå½¢å¼
- **è¯­ä¹‰**: å®šä¹‰ç¨‹åºçš„å«ä¹‰å’Œæ‰§è¡Œç»“æœ
- **ç±»å‹ç³»ç»Ÿ**: å®šä¹‰æ•°æ®ç±»å‹å’Œç±»å‹æ£€æŸ¥è§„åˆ™
- **è¿è¡Œæ—¶ç³»ç»Ÿ**: æä¾›ç¨‹åºæ‰§è¡Œç¯å¢ƒ

### 2. è¯­è¨€åˆ†ç±»

æ ¹æ®ä¸åŒçš„ç‰¹å¾ï¼Œç¼–ç¨‹è¯­è¨€å¯ä»¥åˆ†ä¸ºï¼š

- **æŒ‰èŒƒå¼åˆ†ç±»**: å‘½ä»¤å¼ã€å‡½æ•°å¼ã€é¢å‘å¯¹è±¡ã€é€»è¾‘å¼
- **æŒ‰ç±»å‹ç³»ç»Ÿåˆ†ç±»**: é™æ€ç±»å‹ã€åŠ¨æ€ç±»å‹ã€å¼ºç±»å‹ã€å¼±ç±»å‹
- **æŒ‰æ‰§è¡Œæ–¹å¼åˆ†ç±»**: ç¼–è¯‘å‹ã€è§£é‡Šå‹ã€æ··åˆå‹

## ğŸ”¢ æ•°å­¦å½¢å¼åŒ–

### 1. å½¢å¼è¯­æ³•å®šä¹‰

ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•å¯ä»¥ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼ˆCFGï¼‰å®šä¹‰ï¼š

$$G = (V, \Sigma, P, S)$$

å…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼è§„åˆ™é›†åˆ
- $S$ æ˜¯å¼€å§‹ç¬¦å·

### 2. ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–

ç±»å‹ç³»ç»Ÿå¯ä»¥å½¢å¼åŒ–ä¸ºä¸‰å…ƒç»„ï¼š

$$T = (T, \sqsubseteq, \vdash)$$

å…¶ä¸­ï¼š

- $T$ æ˜¯ç±»å‹é›†åˆ
- $\sqsubseteq$ æ˜¯å­ç±»å‹å…³ç³»
- $\vdash$ æ˜¯ç±»å‹æ¨å¯¼å…³ç³»

### 3. è¯­ä¹‰å®šä¹‰

æ“ä½œè¯­ä¹‰å¯ä»¥ç”¨å°æ­¥è¯­ä¹‰å®šä¹‰ï¼š

$$\frac{e_1 \rightarrow e_1'}{e_1 \oplus e_2 \rightarrow e_1' \oplus e_2}$$

è¡¨ç¤ºè¡¨è¾¾å¼ $e_1$ åœ¨ä¸€æ­¥æ±‚å€¼åå˜ä¸º $e_1'$ã€‚

## ğŸ’» Python å®ç°

### 1. åŸºç¡€è¯­è¨€æ¨¡å‹

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Set, Union
from enum import Enum
from dataclasses import dataclass
import re

class LanguageParadigm(Enum):
    """ç¼–ç¨‹èŒƒå¼æšä¸¾"""
    IMPERATIVE = "imperative"
    FUNCTIONAL = "functional"
    OBJECT_ORIENTED = "object_oriented"
    LOGIC = "logic"
    CONCURRENT = "concurrent"

@dataclass
class Token:
    """è¯æ³•å•å…ƒ"""
    type: str
    value: str
    line: int
    column: int

class ASTNode(ABC):
    """æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹"""
    
    @abstractmethod
    def evaluate(self, environment: Dict[str, Any]) -> Any:
        """æ±‚å€¼æ–¹æ³•"""
        pass

class Expression(ASTNode):
    """è¡¨è¾¾å¼åŸºç±»"""
    pass

class Statement(ASTNode):
    """è¯­å¥åŸºç±»"""
    pass

class ProgrammingLanguage:
    """ç¼–ç¨‹è¯­è¨€çš„åŸºæœ¬å®šä¹‰"""
    
    def __init__(self, name: str, paradigm: LanguageParadigm):
        self.name = name
        self.paradigm = paradigm
        self.features: Dict[str, Any] = {}
        self.syntax_rules: List[str] = []
        self.semantic_rules: List[str] = []
    
    def add_feature(self, feature: str, implementation: Any):
        """æ·»åŠ è¯­è¨€ç‰¹æ€§"""
        self.features[feature] = implementation
    
    def has_feature(self, feature: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦æ”¯æŒæŸä¸ªç‰¹æ€§"""
        return feature in self.features
    
    def validate_syntax(self, code: str) -> bool:
        """è¯­æ³•éªŒè¯"""
        # ç®€åŒ–å®ç°
        return True
    
    def validate_semantics(self, ast: ASTNode) -> bool:
        """è¯­ä¹‰éªŒè¯"""
        # ç®€åŒ–å®ç°
        return True
```

### 2. è¯æ³•åˆ†æå™¨

```python
class Lexer:
    """è¯æ³•åˆ†æå™¨"""
    
    def __init__(self):
        self.tokens: List[Token] = []
        self.keywords = {
            'if', 'else', 'while', 'for', 'def', 'class',
            'return', 'import', 'from', 'as', 'in', 'is'
        }
        self.operators = {
            '+', '-', '*', '/', '=', '==', '!=', '<', '>', '<=', '>=',
            'and', 'or', 'not', '&', '|', '^', '<<', '>>'
        }
    
    def tokenize(self, source_code: str) -> List[Token]:
        """è¯æ³•åˆ†æ"""
        self.tokens = []
        lines = source_code.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            column = 0
            while column < len(line):
                char = line[column]
                
                if char.isspace():
                    column += 1
                    continue
                
                if char.isalpha() or char == '_':
                    # æ ‡è¯†ç¬¦æˆ–å…³é”®å­—
                    token = self._read_identifier(line, line_num, column)
                    self.tokens.append(token)
                    column += len(token.value)
                
                elif char.isdigit():
                    # æ•°å­—
                    token = self._read_number(line, line_num, column)
                    self.tokens.append(token)
                    column += len(token.value)
                
                elif char in '"\'':
                    # å­—ç¬¦ä¸²
                    token = self._read_string(line, line_num, column)
                    self.tokens.append(token)
                    column += len(token.value)
                
                else:
                    # æ“ä½œç¬¦æˆ–åˆ†éš”ç¬¦
                    token = self._read_operator(line, line_num, column)
                    self.tokens.append(token)
                    column += len(token.value)
        
        return self.tokens
    
    def _read_identifier(self, line: str, line_num: int, start: int) -> Token:
        """è¯»å–æ ‡è¯†ç¬¦"""
        end = start
        while end < len(line) and (line[end].isalnum() or line[end] == '_'):
            end += 1
        
        value = line[start:end]
        token_type = 'KEYWORD' if value in self.keywords else 'IDENTIFIER'
        
        return Token(token_type, value, line_num, start + 1)
    
    def _read_number(self, line: str, line_num: int, start: int) -> Token:
        """è¯»å–æ•°å­—"""
        end = start
        while end < len(line) and (line[end].isdigit() or line[end] == '.'):
            end += 1
        
        value = line[start:end]
        return Token('NUMBER', value, line_num, start + 1)
    
    def _read_string(self, line: str, line_num: int, start: int) -> Token:
        """è¯»å–å­—ç¬¦ä¸²"""
        quote = line[start]
        end = start + 1
        
        while end < len(line) and line[end] != quote:
            if line[end] == '\\':
                end += 2  # è·³è¿‡è½¬ä¹‰å­—ç¬¦
            else:
                end += 1
        
        if end < len(line):
            end += 1  # åŒ…å«ç»“æŸå¼•å·
        
        value = line[start:end]
        return Token('STRING', value, line_num, start + 1)
    
    def _read_operator(self, line: str, line_num: int, start: int) -> Token:
        """è¯»å–æ“ä½œç¬¦"""
        # å°è¯•è¯»å–å¤šå­—ç¬¦æ“ä½œç¬¦
        for length in range(3, 0, -1):
            if start + length <= len(line):
                candidate = line[start:start + length]
                if candidate in self.operators:
                    return Token('OPERATOR', candidate, line_num, start + 1)
        
        # å•å­—ç¬¦æ“ä½œç¬¦
        return Token('OPERATOR', line[start], line_num, start + 1)
```

### 3. è¯­æ³•åˆ†æå™¨

```python
class Parser:
    """è¯­æ³•åˆ†æå™¨"""
    
    def __init__(self, tokens: List[Token]):
        self.tokens = tokens
        self.current = 0
    
    def parse(self) -> ASTNode:
        """è§£æç¨‹åº"""
        statements = []
        
        while not self.is_at_end():
            stmt = self.parse_statement()
            if stmt:
                statements.append(stmt)
        
        return Program(statements)
    
    def parse_statement(self) -> Optional[Statement]:
        """è§£æè¯­å¥"""
        if self.match('IDENTIFIER'):
            return self.parse_assignment()
        elif self.match('KEYWORD', 'if'):
            return self.parse_if_statement()
        elif self.match('KEYWORD', 'while'):
            return self.parse_while_statement()
        elif self.match('KEYWORD', 'def'):
            return self.parse_function_definition()
        
        return None
    
    def parse_expression(self) -> Expression:
        """è§£æè¡¨è¾¾å¼"""
        return self.parse_logical_or()
    
    def parse_logical_or(self) -> Expression:
        """è§£æé€»è¾‘æˆ–è¡¨è¾¾å¼"""
        expr = self.parse_logical_and()
        
        while self.match('OPERATOR', 'or'):
            operator = self.previous()
            right = self.parse_logical_and()
            expr = BinaryExpression(expr, operator, right)
        
        return expr
    
    def parse_logical_and(self) -> Expression:
        """è§£æé€»è¾‘ä¸è¡¨è¾¾å¼"""
        expr = self.parse_equality()
        
        while self.match('OPERATOR', 'and'):
            operator = self.previous()
            right = self.parse_equality()
            expr = BinaryExpression(expr, operator, right)
        
        return expr
    
    def parse_equality(self) -> Expression:
        """è§£æç›¸ç­‰æ€§è¡¨è¾¾å¼"""
        expr = self.parse_comparison()
        
        while self.match('OPERATOR', '==', '!='):
            operator = self.previous()
            right = self.parse_comparison()
            expr = BinaryExpression(expr, operator, right)
        
        return expr
    
    def parse_comparison(self) -> Expression:
        """è§£ææ¯”è¾ƒè¡¨è¾¾å¼"""
        expr = self.parse_term()
        
        while self.match('OPERATOR', '<', '>', '<=', '>='):
            operator = self.previous()
            right = self.parse_term()
            expr = BinaryExpression(expr, operator, right)
        
        return expr
    
    def parse_term(self) -> Expression:
        """è§£æé¡¹è¡¨è¾¾å¼"""
        expr = self.parse_factor()
        
        while self.match('OPERATOR', '+', '-'):
            operator = self.previous()
            right = self.parse_factor()
            expr = BinaryExpression(expr, operator, right)
        
        return expr
    
    def parse_factor(self) -> Expression:
        """è§£æå› å­è¡¨è¾¾å¼"""
        expr = self.parse_primary()
        
        while self.match('OPERATOR', '*', '/'):
            operator = self.previous()
            right = self.parse_primary()
            expr = BinaryExpression(expr, operator, right)
        
        return expr
    
    def parse_primary(self) -> Expression:
        """è§£æåŸºæœ¬è¡¨è¾¾å¼"""
        if self.match('NUMBER'):
            return LiteralExpression(float(self.previous().value))
        
        if self.match('STRING'):
            return LiteralExpression(self.previous().value[1:-1])
        
        if self.match('IDENTIFIER'):
            return VariableExpression(self.previous().value)
        
        if self.match('OPERATOR', '('):
            expr = self.parse_expression()
            self.consume('OPERATOR', ')', "Expect ')' after expression.")
            return GroupingExpression(expr)
        
        raise self.error(self.peek(), "Expect expression.")
    
    def match(self, *types: str) -> bool:
        """åŒ¹é…å½“å‰token"""
        for token_type in types:
            if self.check(token_type):
                self.advance()
                return True
        return False
    
    def check(self, token_type: str) -> bool:
        """æ£€æŸ¥å½“å‰tokenç±»å‹"""
        if self.is_at_end():
            return False
        return self.peek().type == token_type
    
    def advance(self) -> Token:
        """å‰è¿›åˆ°ä¸‹ä¸€ä¸ªtoken"""
        if not self.is_at_end():
            self.current += 1
        return self.previous()
    
    def is_at_end(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æœ«å°¾"""
        return self.peek().type == 'EOF'
    
    def peek(self) -> Token:
        """æŸ¥çœ‹å½“å‰token"""
        return self.tokens[self.current]
    
    def previous(self) -> Token:
        """è·å–å‰ä¸€ä¸ªtoken"""
        return self.tokens[self.current - 1]
    
    def consume(self, token_type: str, value: str, message: str) -> Token:
        """æ¶ˆè´¹æŒ‡å®štoken"""
        if self.check(token_type) and self.peek().value == value:
            return self.advance()
        
        raise self.error(self.peek(), message)
    
    def error(self, token: Token, message: str) -> Exception:
        """åˆ›å»ºé”™è¯¯"""
        return Exception(f"Error at {token.value}: {message}")
```

### 4. ç±»å‹ç³»ç»Ÿ

```python
class TypeSystem:
    """ç±»å‹ç³»ç»Ÿ"""
    
    def __init__(self):
        self.types: Dict[str, Set[str]] = {}
        self.subtype_relation: Dict[str, Set[str]] = {}
        self.type_environment: Dict[str, str] = {}
    
    def define_type(self, name: str, values: Set[str]):
        """å®šä¹‰ç±»å‹"""
        self.types[name] = values
        self.subtype_relation[name] = set()
    
    def define_subtype(self, subtype: str, supertype: str):
        """å®šä¹‰å­ç±»å‹å…³ç³»"""
        if subtype in self.subtype_relation:
            self.subtype_relation[subtype].add(supertype)
    
    def is_subtype(self, subtype: str, supertype: str) -> bool:
        """æ£€æŸ¥å­ç±»å‹å…³ç³»"""
        if subtype == supertype:
            return True
        
        if subtype in self.subtype_relation:
            return supertype in self.subtype_relation[subtype]
        
        return False
    
    def type_check(self, expression: Expression) -> str:
        """ç±»å‹æ£€æŸ¥"""
        if isinstance(expression, LiteralExpression):
            if isinstance(expression.value, (int, float)):
                return 'number'
            elif isinstance(expression.value, str):
                return 'string'
            elif isinstance(expression.value, bool):
                return 'boolean'
        
        elif isinstance(expression, VariableExpression):
            return self.type_environment.get(expression.name, 'unknown')
        
        elif isinstance(expression, BinaryExpression):
            left_type = self.type_check(expression.left)
            right_type = self.type_check(expression.right)
            
            # ç±»å‹å…¼å®¹æ€§æ£€æŸ¥
            if self.is_compatible(left_type, right_type, expression.operator):
                return self.result_type(left_type, right_type, expression.operator)
            else:
                raise TypeError(f"Type mismatch: {left_type} {expression.operator} {right_type}")
        
        return 'unknown'
    
    def is_compatible(self, left_type: str, right_type: str, operator: Token) -> bool:
        """æ£€æŸ¥ç±»å‹å…¼å®¹æ€§"""
        if operator.value in ['+', '-', '*', '/']:
            return left_type == 'number' and right_type == 'number'
        elif operator.value in ['==', '!=', '<', '>', '<=', '>=']:
            return left_type == right_type
        elif operator.value in ['and', 'or']:
            return left_type == 'boolean' and right_type == 'boolean'
        
        return False
    
    def result_type(self, left_type: str, right_type: str, operator: Token) -> str:
        """è®¡ç®—ç»“æœç±»å‹"""
        if operator.value in ['+', '-', '*', '/']:
            return 'number'
        elif operator.value in ['==', '!=', '<', '>', '<=', '>=']:
            return 'boolean'
        elif operator.value in ['and', 'or']:
            return 'boolean'
        
        return 'unknown'
```

### 5. è§£é‡Šå™¨

```python
class Interpreter:
    """è§£é‡Šå™¨"""
    
    def __init__(self):
        self.environment = Environment()
        self.globals = self.environment
        self.locals: Dict[Expression, int] = {}
    
    def interpret(self, statements: List[Statement]):
        """è§£é‡Šæ‰§è¡Œ"""
        try:
            for statement in statements:
                self.execute(statement)
        except RuntimeError as error:
            print(f"Runtime error: {error}")
    
    def execute(self, statement: Statement):
        """æ‰§è¡Œè¯­å¥"""
        if isinstance(statement, ExpressionStatement):
            self.evaluate(statement.expression)
        elif isinstance(statement, PrintStatement):
            value = self.evaluate(statement.expression)
            print(self.stringify(value))
        elif isinstance(statement, VariableStatement):
            value = None
            if statement.initializer:
                value = self.evaluate(statement.initializer)
            
            self.environment.define(statement.name.lexeme, value)
        elif isinstance(statement, BlockStatement):
            self.execute_block(statement.statements, Environment(self.environment))
        elif isinstance(statement, IfStatement):
            if self.is_truthy(self.evaluate(statement.condition)):
                self.execute(statement.then_branch)
            elif statement.else_branch:
                self.execute(statement.else_branch)
        elif isinstance(statement, WhileStatement):
            while self.is_truthy(self.evaluate(statement.condition)):
                self.execute(statement.body)
        elif isinstance(statement, FunctionStatement):
            function = Function(statement, self.environment)
            self.environment.define(statement.name.lexeme, function)
    
    def evaluate(self, expression: Expression) -> Any:
        """æ±‚å€¼è¡¨è¾¾å¼"""
        if isinstance(expression, LiteralExpression):
            return expression.value
        elif isinstance(expression, GroupingExpression):
            return self.evaluate(expression.expression)
        elif isinstance(expression, UnaryExpression):
            right = self.evaluate(expression.right)
            
            if expression.operator.type == 'OPERATOR':
                if expression.operator.lexeme == '-':
                    self.check_number_operand(expression.operator, right)
                    return -float(right)
                elif expression.operator.lexeme == '!':
                    return not self.is_truthy(right)
            
            return None
        elif isinstance(expression, BinaryExpression):
            left = self.evaluate(expression.left)
            right = self.evaluate(expression.right)
            
            if expression.operator.type == 'OPERATOR':
                if expression.operator.lexeme == '-':
                    self.check_number_operands(expression.operator, left, right)
                    return float(left) - float(right)
                elif expression.operator.lexeme == '/':
                    self.check_number_operands(expression.operator, left, right)
                    return float(left) / float(right)
                elif expression.operator.lexeme == '*':
                    self.check_number_operands(expression.operator, left, right)
                    return float(left) * float(right)
                elif expression.operator.lexeme == '+':
                    if isinstance(left, (int, float)) and isinstance(right, (int, float)):
                        return float(left) + float(right)
                    if isinstance(left, str) and isinstance(right, str):
                        return str(left) + str(right)
                    raise RuntimeError("Operands must be two numbers or two strings.")
                elif expression.operator.lexeme == '>':
                    self.check_number_operands(expression.operator, left, right)
                    return float(left) > float(right)
                elif expression.operator.lexeme == '>=':
                    self.check_number_operands(expression.operator, left, right)
                    return float(left) >= float(right)
                elif expression.operator.lexeme == '<':
                    self.check_number_operands(expression.operator, left, right)
                    return float(left) < float(right)
                elif expression.operator.lexeme == '<=':
                    self.check_number_operands(expression.operator, left, right)
                    return float(left) <= float(right)
                elif expression.operator.lexeme == '!=':
                    return not self.is_equal(left, right)
                elif expression.operator.lexeme == '==':
                    return self.is_equal(left, right)
            
            return None
        elif isinstance(expression, VariableExpression):
            return self.lookup_variable(expression.name, expression)
        elif isinstance(expression, AssignExpression):
            value = self.evaluate(expression.value)
            
            distance = self.locals.get(expression)
            if distance is not None:
                self.environment.assign_at(distance, expression.name, value)
            else:
                self.globals.assign(expression.name, value)
            
            return value
        
        return None
    
    def execute_block(self, statements: List[Statement], environment: 'Environment'):
        """æ‰§è¡Œä»£ç å—"""
        previous = self.environment
        try:
            self.environment = environment
            for statement in statements:
                self.execute(statement)
        finally:
            self.environment = previous
    
    def resolve(self, expression: Expression, depth: int):
        """è§£æå˜é‡"""
        self.locals[expression] = depth
    
    def lookup_variable(self, name: Token, expression: Expression) -> Any:
        """æŸ¥æ‰¾å˜é‡"""
        distance = self.locals.get(expression)
        if distance is not None:
            return self.environment.get_at(distance, name.lexeme)
        else:
            return self.globals.get(name)
    
    def check_number_operand(self, operator: Token, operand: Any):
        """æ£€æŸ¥æ•°å­—æ“ä½œæ•°"""
        if not isinstance(operand, (int, float)):
            raise RuntimeError(f"Operand must be a number. Got {type(operand)}")
    
    def check_number_operands(self, operator: Token, left: Any, right: Any):
        """æ£€æŸ¥æ•°å­—æ“ä½œæ•°"""
        if not isinstance(left, (int, float)) or not isinstance(right, (int, float)):
            raise RuntimeError("Operands must be numbers.")
    
    def is_truthy(self, object: Any) -> bool:
        """æ£€æŸ¥çœŸå€¼"""
        if object is None:
            return False
        if isinstance(object, bool):
            return object
        return True
    
    def is_equal(self, a: Any, b: Any) -> bool:
        """æ£€æŸ¥ç›¸ç­‰æ€§"""
        if a is None and b is None:
            return True
        if a is None:
            return False
        return a == b
    
    def stringify(self, object: Any) -> str:
        """è½¬æ¢ä¸ºå­—ç¬¦ä¸²"""
        if object is None:
            return "nil"
        if isinstance(object, float):
            text = str(object)
            if text.endswith('.0'):
                text = text[:-2]
            return text
        return str(object)
```

### 6. å†…å­˜ç®¡ç†ç³»ç»Ÿ

```python
class MemoryManager:
    """å†…å­˜ç®¡ç†å™¨"""
    
    def __init__(self, heap_size: int = 1024 * 1024):
        self.heap_size = heap_size
        self.heap = bytearray(heap_size)
        self.allocated_blocks: Dict[int, int] = {}  # address -> size
        self.free_blocks: Set[int] = {0}  # ç©ºé—²å—èµ·å§‹åœ°å€
        self.next_address = 0
        self.gc_threshold = heap_size // 2
    
    def allocate(self, size: int) -> int:
        """åˆ†é…å†…å­˜"""
        if size <= 0:
            raise ValueError("Allocation size must be positive")
        
        # æŸ¥æ‰¾åˆé€‚çš„ç©ºé—²å—
        best_fit = None
        best_size = float('inf')
        
        for free_start in self.free_blocks:
            free_size = self._get_free_block_size(free_start)
            if free_size >= size and free_size < best_size:
                best_fit = free_start
                best_size = free_size
        
        if best_fit is None:
            # è§¦å‘åƒåœ¾å›æ”¶
            self.garbage_collect()
            
            # å†æ¬¡å°è¯•åˆ†é…
            for free_start in self.free_blocks:
                free_size = self._get_free_block_size(free_start)
                if free_size >= size:
                    best_fit = free_start
                    break
        
        if best_fit is None:
            raise MemoryError("Out of memory")
        
        # åˆ†é…å†…å­˜
        self.allocated_blocks[best_fit] = size
        self.free_blocks.remove(best_fit)
        
        # å¦‚æœå‰©ä½™ç©ºé—´è¶³å¤Ÿï¼Œåˆ›å»ºæ–°çš„ç©ºé—²å—
        remaining_size = self._get_free_block_size(best_fit) - size
        if remaining_size > 0:
            new_free_start = best_fit + size
            self.free_blocks.add(new_free_start)
        
        return best_fit
    
    def deallocate(self, address: int):
        """é‡Šæ”¾å†…å­˜"""
        if address not in self.allocated_blocks:
            raise ValueError(f"Invalid address: {address}")
        
        size = self.allocated_blocks[address]
        del self.allocated_blocks[address]
        
        # åˆå¹¶ç›¸é‚»çš„ç©ºé—²å—
        self._merge_free_blocks(address, size)
    
    def _merge_free_blocks(self, start: int, size: int):
        """åˆå¹¶ç›¸é‚»çš„ç©ºé—²å—"""
        end = start + size
        
        # æŸ¥æ‰¾ç›¸é‚»çš„ç©ºé—²å—
        left_neighbor = None
        right_neighbor = None
        
        for free_start in self.free_blocks:
            free_end = free_start + self._get_free_block_size(free_start)
            
            if free_end == start:
                left_neighbor = free_start
            elif end == free_start:
                right_neighbor = free_start
        
        # åˆå¹¶ç©ºé—²å—
        if left_neighbor is not None:
            self.free_blocks.remove(left_neighbor)
            start = left_neighbor
        
        if right_neighbor is not None:
            self.free_blocks.remove(right_neighbor)
            size += self._get_free_block_size(right_neighbor)
        
        self.free_blocks.add(start)
    
    def _get_free_block_size(self, start: int) -> int:
        """è·å–ç©ºé—²å—å¤§å°"""
        # ç®€åŒ–å®ç°ï¼šæŸ¥æ‰¾ä¸‹ä¸€ä¸ªå·²åˆ†é…å—
        size = 0
        while start + size < self.heap_size:
            if start + size in self.allocated_blocks:
                break
            size += 1
        return size
    
    def garbage_collect(self):
        """åƒåœ¾å›æ”¶"""
        # æ ‡è®°é˜¶æ®µ
        marked = set()
        roots = self._get_roots()
        
        for root in roots:
            self._mark_reachable(root, marked)
        
        # æ¸…é™¤é˜¶æ®µ
        unreachable = set(self.allocated_blocks.keys()) - marked
        for address in unreachable:
            self.deallocate(address)
    
    def _get_roots(self) -> Set[int]:
        """è·å–æ ¹å¯¹è±¡"""
        # ç®€åŒ–å®ç°ï¼šè¿”å›æ‰€æœ‰å·²åˆ†é…å—çš„åœ°å€
        return set(self.allocated_blocks.keys())
    
    def _mark_reachable(self, address: int, marked: Set[int]):
        """æ ‡è®°å¯è¾¾å¯¹è±¡"""
        if address in marked:
            return
        
        marked.add(address)
        
        # éå†å¯¹è±¡å¼•ç”¨çš„å…¶ä»–å¯¹è±¡
        # è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ ¹æ®å¯¹è±¡ç±»å‹æ¥éå†å¼•ç”¨
        size = self.allocated_blocks[address]
        for i in range(address, address + size, 4):  # å‡è®¾æŒ‡é’ˆå¤§å°ä¸º4å­—èŠ‚
            if i + 4 <= address + size:
                ptr_value = int.from_bytes(self.heap[i:i+4], 'little')
                if ptr_value in self.allocated_blocks:
                    self._mark_reachable(ptr_value, marked)
    
    def get_memory_stats(self) -> Dict[str, int]:
        """è·å–å†…å­˜ç»Ÿè®¡ä¿¡æ¯"""
        total_allocated = sum(self.allocated_blocks.values())
        total_free = self.heap_size - total_allocated
        fragmentation = len(self.free_blocks)
        
        return {
            'total_heap': self.heap_size,
            'total_allocated': total_allocated,
            'total_free': total_free,
            'fragmentation': fragmentation,
            'allocation_count': len(self.allocated_blocks)
        }
```

## ğŸ“Š å›¾è¡¨è¯´æ˜

### 1. ç¼–ç¨‹è¯­è¨€æ¶æ„å›¾

```mermaid
graph TB
    A[æºä»£ç ] --> B[è¯æ³•åˆ†æå™¨]
    B --> C[è¯­æ³•åˆ†æå™¨]
    C --> D[è¯­ä¹‰åˆ†æå™¨]
    D --> E[ä¸­é—´ä»£ç ç”Ÿæˆ]
    E --> F[ä»£ç ä¼˜åŒ–]
    F --> G[ç›®æ ‡ä»£ç ç”Ÿæˆ]
    G --> H[å¯æ‰§è¡Œç¨‹åº]
    
    I[ç±»å‹ç³»ç»Ÿ] --> D
    J[ç¬¦å·è¡¨] --> D
    K[é”™è¯¯å¤„ç†] --> B
    K --> C
    K --> D
```

### 2. ç±»å‹ç³»ç»Ÿå±‚æ¬¡ç»“æ„

```mermaid
graph TD
    A[Any] --> B[Object]
    B --> C[Number]
    B --> D[String]
    B --> E[Boolean]
    B --> F[Array]
    
    C --> G[Integer]
    C --> H[Float]
    
    F --> I[Array&lt;Number&gt;]
    F --> J[Array&lt;String&gt;]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px
```

### 3. å†…å­˜ç®¡ç†æµç¨‹å›¾

```mermaid
flowchart TD
    A[åˆ†é…è¯·æ±‚] --> B{æœ‰è¶³å¤Ÿç©ºé—´?}
    B -->|æ˜¯| C[åˆ†é…å†…å­˜]
    B -->|å¦| D[åƒåœ¾å›æ”¶]
    D --> E{å›æ”¶åç©ºé—´è¶³å¤Ÿ?}
    E -->|æ˜¯| C
    E -->|å¦| F[å†…å­˜ä¸è¶³é”™è¯¯]
    
    C --> G[è¿”å›åœ°å€]
    G --> H[ä½¿ç”¨å†…å­˜]
    H --> I[é‡Šæ”¾è¯·æ±‚]
    I --> J[é‡Šæ”¾å†…å­˜]
    J --> K[åˆå¹¶ç©ºé—²å—]
```

## ğŸ“ æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹1: ç®€å•è¡¨è¾¾å¼æ±‚å€¼

```python
def test_expression_evaluation():
    """æµ‹è¯•è¡¨è¾¾å¼æ±‚å€¼"""
    # åˆ›å»ºè§£é‡Šå™¨
    interpreter = Interpreter()
    
    # æµ‹è¯•ç®—æœ¯è¡¨è¾¾å¼
    expressions = [
        "2 + 3 * 4",      # åº”è¯¥ç­‰äº 14
        "(2 + 3) * 4",    # åº”è¯¥ç­‰äº 20
        "10 / 2 + 3",     # åº”è¯¥ç­‰äº 8
        "5 - 3 + 2"       # åº”è¯¥ç­‰äº 4
    ]
    
    for expr in expressions:
        # è¯æ³•åˆ†æ
        lexer = Lexer()
        tokens = lexer.tokenize(expr)
        
        # è¯­æ³•åˆ†æ
        parser = Parser(tokens)
        ast = parser.parse_expression()
        
        # æ±‚å€¼
        result = interpreter.evaluate(ast)
        print(f"{expr} = {result}")

# è¿è¡Œæµ‹è¯•
test_expression_evaluation()
```

### æ¡ˆä¾‹2: ç±»å‹ç³»ç»ŸéªŒè¯

```python
def test_type_system():
    """æµ‹è¯•ç±»å‹ç³»ç»Ÿ"""
    # åˆ›å»ºç±»å‹ç³»ç»Ÿ
    type_system = TypeSystem()
    
    # å®šä¹‰åŸºæœ¬ç±»å‹
    type_system.define_type('number', {'int', 'float'})
    type_system.define_type('string', {'str'})
    type_system.define_type('boolean', {'bool'})
    
    # å®šä¹‰å­ç±»å‹å…³ç³»
    type_system.define_subtype('int', 'number')
    type_system.define_subtype('float', 'number')
    
    # æµ‹è¯•ç±»å‹æ£€æŸ¥
    test_cases = [
        (LiteralExpression(42), 'number'),
        (LiteralExpression("hello"), 'string'),
        (LiteralExpression(True), 'boolean'),
        (BinaryExpression(
            LiteralExpression(10),
            Token('OPERATOR', '+', 1, 1),
            LiteralExpression(20)
        ), 'number')
    ]
    
    for expression, expected_type in test_cases:
        actual_type = type_system.type_check(expression)
        print(f"Expression: {expression}, Expected: {expected_type}, Actual: {actual_type}")

# è¿è¡Œæµ‹è¯•
test_type_system()
```

### æ¡ˆä¾‹3: å†…å­˜ç®¡ç†æµ‹è¯•

```python
def test_memory_management():
    """æµ‹è¯•å†…å­˜ç®¡ç†"""
    # åˆ›å»ºå†…å­˜ç®¡ç†å™¨
    memory_manager = MemoryManager(1024)  # 1KB å †
    
    # åˆ†é…å†…å­˜
    addresses = []
    for i in range(5):
        addr = memory_manager.allocate(64)  # åˆ†é…64å­—èŠ‚
        addresses.append(addr)
        print(f"Allocated 64 bytes at address {addr}")
    
    # æŸ¥çœ‹å†…å­˜ç»Ÿè®¡
    stats = memory_manager.get_memory_stats()
    print(f"Memory stats: {stats}")
    
    # é‡Šæ”¾éƒ¨åˆ†å†…å­˜
    memory_manager.deallocate(addresses[1])
    memory_manager.deallocate(addresses[3])
    print("Deallocated addresses 1 and 3")
    
    # å†æ¬¡æŸ¥çœ‹ç»Ÿè®¡
    stats = memory_manager.get_memory_stats()
    print(f"Memory stats after deallocation: {stats}")
    
    # è§¦å‘åƒåœ¾å›æ”¶
    memory_manager.garbage_collect()
    print("Garbage collection completed")
    
    # æœ€ç»ˆç»Ÿè®¡
    stats = memory_manager.get_memory_stats()
    print(f"Final memory stats: {stats}")

# è¿è¡Œæµ‹è¯•
test_memory_management()
```

## ğŸ”¬ ç†è®ºè¯æ˜

### å®šç†1: ç±»å‹å®‰å…¨å®šç†

**å®šç†**: å¦‚æœè¡¨è¾¾å¼ $e$ é€šè¿‡ç±»å‹æ£€æŸ¥ï¼Œç±»å‹ä¸º $\tau$ï¼Œé‚£ä¹ˆåœ¨ç±»å‹ç¯å¢ƒä¸­æ‰§è¡Œ $e$ ä¸ä¼šäº§ç”Ÿç±»å‹é”™è¯¯ã€‚

**è¯æ˜**:

1. **åŸºç¡€æƒ…å†µ**: å¯¹äºå­—é¢é‡è¡¨è¾¾å¼
   - æ•°å­—å­—é¢é‡: $n : \text{number}$
   - å­—ç¬¦ä¸²å­—é¢é‡: $s : \text{string}$
   - å¸ƒå°”å­—é¢é‡: $b : \text{boolean}$

2. **å½’çº³æ­¥éª¤**: å¯¹äºå¤åˆè¡¨è¾¾å¼
   - äºŒå…ƒè¡¨è¾¾å¼: $e_1 \oplus e_2$
     - å¦‚æœ $e_1 : \tau_1$ ä¸” $e_2 : \tau_2$
     - ä¸” $\oplus$ çš„ç±»å‹è§„åˆ™ä¸º $\tau_1 \times \tau_2 \rightarrow \tau$
     - åˆ™ $e_1 \oplus e_2 : \tau$

3. **ç±»å‹ç¯å¢ƒ**: $\Gamma \vdash e : \tau$ è¡¨ç¤ºåœ¨ç¯å¢ƒ $\Gamma$ ä¸­ï¼Œè¡¨è¾¾å¼ $e$ çš„ç±»å‹ä¸º $\tau$

4. **ç±»å‹ä¿æŒ**: å¦‚æœ $\Gamma \vdash e : \tau$ ä¸” $e \rightarrow e'$ï¼Œåˆ™ $\Gamma \vdash e' : \tau$

### å®šç†2: å†…å­˜å®‰å…¨å®šç†

**å®šç†**: åœ¨åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­ï¼Œå¦‚æœå¯¹è±¡ $o$ æ˜¯å¯è¾¾çš„ï¼Œåˆ™ $o$ ä¸ä¼šè¢«å›æ”¶ã€‚

**è¯æ˜**:

1. **å¯è¾¾æ€§å®šä¹‰**: å¯¹è±¡ $o$ æ˜¯å¯è¾¾çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä»æ ¹å¯¹è±¡åˆ° $o$ çš„å¼•ç”¨é“¾ã€‚

2. **æ ‡è®°ç®—æ³•**:
   - ä»æ‰€æœ‰æ ¹å¯¹è±¡å¼€å§‹æ ‡è®°
   - é€’å½’æ ‡è®°æ‰€æœ‰è¢«å¼•ç”¨å¯¹è±¡
   - åªæœ‰è¢«æ ‡è®°çš„å¯¹è±¡ä¿ç•™

3. **æ­£ç¡®æ€§**:
   - å¦‚æœ $o$ å¯è¾¾ï¼Œåˆ™å­˜åœ¨å¼•ç”¨é“¾ $r \rightarrow o_1 \rightarrow ... \rightarrow o_n \rightarrow o$
   - æ ‡è®°ç®—æ³•ä¼šä» $r$ å¼€å§‹ï¼Œæ²¿ç€å¼•ç”¨é“¾æ ‡è®°æ‰€æœ‰å¯¹è±¡
   - å› æ­¤ $o$ ä¼šè¢«æ ‡è®°ï¼Œä¸ä¼šè¢«å›æ”¶

4. **å®Œæ•´æ€§**: æ‰€æœ‰ä¸å¯è¾¾å¯¹è±¡éƒ½ä¼šè¢«å›æ”¶ï¼Œå› ä¸ºå®ƒä»¬ä¸ä¼šè¢«æ ‡è®°ã€‚

### å®šç†3: è¯­æ³•åˆ†ææ­£ç¡®æ€§å®šç†

**å®šç†**: å¦‚æœå­—ç¬¦ä¸² $s$ å±äºè¯­è¨€ $L(G)$ï¼Œåˆ™è¯­æ³•åˆ†æå™¨èƒ½å¤Ÿæ­£ç¡®æ„å»ºè¯­æ³•æ ‘ã€‚

**è¯æ˜**:

1. **è¯­æ³•å®šä¹‰**: $G = (V, \Sigma, P, S)$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•

2. **æ¨å¯¼å…³ç³»**: $S \Rightarrow^* s$ è¡¨ç¤ºä»å¼€å§‹ç¬¦å· $S$ å¯ä»¥æ¨å¯¼å‡ºå­—ç¬¦ä¸² $s$

3. **åˆ†æç®—æ³•**: é€’å½’ä¸‹é™åˆ†æå™¨æŒ‰ç…§äº§ç”Ÿå¼è§„åˆ™æ„å»ºè¯­æ³•æ ‘

4. **æ­£ç¡®æ€§**:
   - å¯¹äºæ¯ä¸ªäº§ç”Ÿå¼ $A \rightarrow \alpha$ï¼Œåˆ†æå™¨ä¼šåˆ›å»ºèŠ‚ç‚¹ $A$ å¹¶è§£æ $\alpha$
   - å¦‚æœ $S \Rightarrow^* s$ï¼Œåˆ™åˆ†æå™¨èƒ½å¤ŸæŒ‰ç…§æ¨å¯¼åºåˆ—æ„å»ºè¯­æ³•æ ‘
   - å› æ­¤ï¼Œåˆ†æå™¨èƒ½å¤Ÿæ­£ç¡®è¯†åˆ«æ‰€æœ‰å±äº $L(G)$ çš„å­—ç¬¦ä¸²

## ğŸ”— ç›¸å…³é“¾æ¥

- [01-04-å›¾è®ºåŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-04-å›¾è®ºåŸºç¡€.md) - è¯­æ³•æ ‘å’Œä¾èµ–å›¾
- [02-04-å½¢å¼è¯­è¨€ç†è®º](../02-ç†è®ºåŸºç¡€/02-04-å½¢å¼è¯­è¨€ç†è®º.md) - å½¢å¼è¯­è¨€åŸºç¡€
- [03-02-è½¯ä»¶æ¶æ„ç§‘å­¦](./03-02-è½¯ä»¶æ¶æ„ç§‘å­¦.md) - è¯­è¨€è¿è¡Œæ—¶æ¶æ„
- [04-01-äººå·¥æ™ºèƒ½åº”ç”¨](../04-è¡Œä¸šé¢†åŸŸ/04-01-äººå·¥æ™ºèƒ½åº”ç”¨.md) - ç¼–ç¨‹è¯­è¨€åœ¨AIä¸­çš„åº”ç”¨

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
