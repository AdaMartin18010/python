# 03-04-01 ç³»ç»Ÿè®¾è®¡åŸºç¡€ (System Design Fundamentals)

## ğŸ“‹ æ¦‚è¿°

ç³»ç»Ÿè®¾è®¡æ˜¯è½¯ä»¶å·¥ç¨‹çš„æ ¸å¿ƒé¢†åŸŸï¼Œå®ƒå…³æ³¨å¦‚ä½•æ„å»ºå¤§è§„æ¨¡ã€å¯æ‰©å±•ã€é«˜æ€§èƒ½çš„è½¯ä»¶ç³»ç»Ÿã€‚ç³»ç»Ÿè®¾è®¡æ¶‰åŠæ¶æ„æ¨¡å¼ã€è®¾è®¡åŸåˆ™ã€æ€§èƒ½ä¼˜åŒ–ã€å¯æ‰©å±•æ€§ç­‰å¤šä¸ªæ–¹é¢ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼ç§‘å­¦è§’åº¦å¯¹ç³»ç»Ÿè®¾è®¡è¿›è¡Œä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰å’Œè¯æ˜ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç³»ç»Ÿ (System)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $S = (C, I, O, F, R)$ï¼Œå…¶ä¸­ï¼š

- $C$ æ˜¯ç»„ä»¶é›†åˆ (Components)
- $I$ æ˜¯è¾“å…¥é›†åˆ (Inputs)
- $O$ æ˜¯è¾“å‡ºé›†åˆ (Outputs)
- $F$ æ˜¯åŠŸèƒ½æ˜ å°„ (Functions)
- $R$ æ˜¯å…³ç³»é›†åˆ (Relations)

**æ•°å­¦è¡¨ç¤º**ï¼š
$$S = \{(c_1, c_2, ..., c_n), (i_1, i_2, ..., i_m), (o_1, o_2, ..., o_k), f, (r_1, r_2, ..., r_l)\}$$

**Python å®ç°**ï¼š

```python
from typing import TypeVar, Generic, Dict, List, Any, Callable
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import time
import asyncio

T = TypeVar('T')
U = TypeVar('U')

class ComponentType(Enum):
    """ç»„ä»¶ç±»å‹"""
    PROCESSOR = "processor"
    STORAGE = "storage"
    NETWORK = "network"
    INTERFACE = "interface"

@dataclass
class Component(Generic[T]):
    """ç³»ç»Ÿç»„ä»¶"""
    id: str
    name: str
    type: ComponentType
    data: T
    status: str = "active"
    
    def process(self, input_data: Any) -> Any:
        """å¤„ç†è¾“å…¥æ•°æ®"""
        pass
    
    def get_status(self) -> str:
        """è·å–ç»„ä»¶çŠ¶æ€"""
        return self.status

class System(Generic[T]):
    """ç³»ç»ŸæŠ½è±¡ç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.components: Dict[str, Component] = {}
        self.inputs: List[Any] = []
        self.outputs: List[Any] = []
        self.functions: Dict[str, Callable] = {}
        self.relations: List[tuple] = []
    
    def add_component(self, component: Component):
        """æ·»åŠ ç»„ä»¶"""
        self.components[component.id] = component
    
    def remove_component(self, component_id: str):
        """ç§»é™¤ç»„ä»¶"""
        if component_id in self.components:
            del self.components[component_id]
    
    def add_function(self, name: str, func: Callable):
        """æ·»åŠ åŠŸèƒ½"""
        self.functions[name] = func
    
    def add_relation(self, source_id: str, target_id: str, relation_type: str):
        """æ·»åŠ å…³ç³»"""
        self.relations.append((source_id, target_id, relation_type))
    
    def process_input(self, input_data: Any) -> Any:
        """å¤„ç†è¾“å…¥"""
        # é»˜è®¤å¤„ç†é€»è¾‘
        return input_data
    
    def get_system_status(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        return {
            "name": self.name,
            "component_count": len(self.components),
            "active_components": sum(1 for c in self.components.values() if c.status == "active"),
            "relations_count": len(self.relations)
        }
```

### 2. ç³»ç»Ÿæ¶æ„ (System Architecture)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
ç³»ç»Ÿæ¶æ„æ˜¯ä¸€ä¸ªå››å…ƒç»„ $A = (P, C, I, Q)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯æ¶æ„æ¨¡å¼é›†åˆ (Patterns)
- $C$ æ˜¯çº¦æŸé›†åˆ (Constraints)
- $I$ æ˜¯æ¥å£é›†åˆ (Interfaces)
- $Q$ æ˜¯è´¨é‡å±æ€§é›†åˆ (Quality Attributes)

**æ•°å­¦è¡¨ç¤º**ï¼š
$$A = \{(p_1, p_2, ..., p_n), (c_1, c_2, ..., c_m), (i_1, i_2, ..., i_k), (q_1, q_2, ..., q_l)\}$$

**Python å®ç°**ï¼š

```python
from typing import Dict, List, Any, Set
from dataclasses import dataclass
from enum import Enum

class ArchitecturePattern(Enum):
    """æ¶æ„æ¨¡å¼"""
    LAYERED = "layered"
    MICROSERVICES = "microservices"
    EVENT_DRIVEN = "event_driven"
    PIPE_FILTER = "pipe_filter"
    CLIENT_SERVER = "client_server"
    PEER_TO_PEER = "peer_to_peer"

class QualityAttribute(Enum):
    """è´¨é‡å±æ€§"""
    PERFORMANCE = "performance"
    SCALABILITY = "scalability"
    RELIABILITY = "reliability"
    AVAILABILITY = "availability"
    SECURITY = "security"
    MAINTAINABILITY = "maintainability"
    TESTABILITY = "testability"

@dataclass
class Constraint:
    """æ¶æ„çº¦æŸ"""
    name: str
    description: str
    type: str  # "functional", "non-functional", "technical"
    priority: int  # 1-5, 5ä¸ºæœ€é«˜ä¼˜å…ˆçº§

@dataclass
class Interface:
    """ç³»ç»Ÿæ¥å£"""
    name: str
    protocol: str  # "HTTP", "gRPC", "WebSocket", etc.
    data_format: str  # "JSON", "XML", "Protocol Buffers", etc.
    authentication: str  # "None", "JWT", "OAuth", etc.

class SystemArchitecture:
    """ç³»ç»Ÿæ¶æ„"""
    
    def __init__(self, name: str):
        self.name = name
        self.patterns: Set[ArchitecturePattern] = set()
        self.constraints: List[Constraint] = []
        self.interfaces: List[Interface] = []
        self.quality_attributes: Dict[QualityAttribute, float] = {}
    
    def add_pattern(self, pattern: ArchitecturePattern):
        """æ·»åŠ æ¶æ„æ¨¡å¼"""
        self.patterns.add(pattern)
    
    def add_constraint(self, constraint: Constraint):
        """æ·»åŠ çº¦æŸ"""
        self.constraints.append(constraint)
    
    def add_interface(self, interface: Interface):
        """æ·»åŠ æ¥å£"""
        self.interfaces.append(interface)
    
    def set_quality_attribute(self, attribute: QualityAttribute, value: float):
        """è®¾ç½®è´¨é‡å±æ€§"""
        self.quality_attributes[attribute] = value
    
    def evaluate_architecture(self) -> Dict[str, Any]:
        """è¯„ä¼°æ¶æ„"""
        return {
            "name": self.name,
            "patterns": [p.value for p in self.patterns],
            "constraints_count": len(self.constraints),
            "interfaces_count": len(self.interfaces),
            "quality_attributes": {k.value: v for k, v in self.quality_attributes.items()}
        }
```

### 3. å¯æ‰©å±•æ€§ (Scalability)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
å¯æ‰©å±•æ€§æ˜¯ç³»ç»Ÿåœ¨è´Ÿè½½å¢åŠ æ—¶ä¿æŒæ€§èƒ½çš„èƒ½åŠ›ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\text{Scalability} = \frac{\text{Performance}(n)}{\text{Performance}(1)}$$

å…¶ä¸­ $n$ æ˜¯ç³»ç»Ÿè§„æ¨¡ã€‚

**Python å®ç°**ï¼š

```python
from typing import Callable, Dict, List, Any
import time
import threading
import asyncio
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

class ScalabilityTest:
    """å¯æ‰©å±•æ€§æµ‹è¯•"""
    
    def __init__(self):
        self.results: Dict[int, float] = {}
    
    def measure_performance(self, workload: Callable, scale: int) -> float:
        """æµ‹é‡æ€§èƒ½"""
        start_time = time.time()
        
        # æ‰§è¡Œå·¥ä½œè´Ÿè½½
        workload(scale)
        
        end_time = time.time()
        return end_time - start_time
    
    def calculate_scalability(self, base_scale: int = 1) -> Dict[int, float]:
        """è®¡ç®—å¯æ‰©å±•æ€§"""
        scalability_ratios = {}
        
        for scale, performance in self.results.items():
            if scale == base_scale:
                scalability_ratios[scale] = 1.0
            else:
                base_performance = self.results[base_scale]
                scalability_ratios[scale] = base_performance / performance
        
        return scalability_ratios
    
    def test_vertical_scaling(self, workload: Callable, max_scale: int):
        """æµ‹è¯•å‚ç›´æ‰©å±•"""
        for scale in range(1, max_scale + 1):
            performance = self.measure_performance(workload, scale)
            self.results[scale] = performance
    
    def test_horizontal_scaling(self, workload: Callable, max_instances: int):
        """æµ‹è¯•æ°´å¹³æ‰©å±•"""
        for instances in range(1, max_instances + 1):
            performance = self.measure_performance(
                lambda scale: self._distributed_workload(workload, scale, instances),
                1
            )
            self.results[instances] = performance
    
    def _distributed_workload(self, workload: Callable, scale: int, instances: int):
        """åˆ†å¸ƒå¼å·¥ä½œè´Ÿè½½"""
        with ThreadPoolExecutor(max_workers=instances) as executor:
            futures = [executor.submit(workload, scale // instances) for _ in range(instances)]
            for future in futures:
                future.result()

# ç¤ºä¾‹å·¥ä½œè´Ÿè½½
def cpu_intensive_workload(scale: int):
    """CPUå¯†é›†å‹å·¥ä½œè´Ÿè½½"""
    result = 0
    for i in range(scale * 1000000):
        result += i * i
    return result

def io_intensive_workload(scale: int):
    """IOå¯†é›†å‹å·¥ä½œè´Ÿè½½"""
    import time
    time.sleep(scale * 0.1)  # æ¨¡æ‹ŸIOæ“ä½œ

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_scalability():
    """æ¼”ç¤ºå¯æ‰©å±•æ€§æµ‹è¯•"""
    test = ScalabilityTest()
    
    # æµ‹è¯•å‚ç›´æ‰©å±•
    print("Testing vertical scaling...")
    test.test_vertical_scaling(cpu_intensive_workload, 4)
    
    scalability = test.calculate_scalability()
    print(f"Vertical scalability ratios: {scalability}")
    
    # æµ‹è¯•æ°´å¹³æ‰©å±•
    print("\nTesting horizontal scaling...")
    test.test_horizontal_scaling(io_intensive_workload, 4)
    
    scalability = test.calculate_scalability()
    print(f"Horizontal scalability ratios: {scalability}")
```

### 4. æ€§èƒ½ (Performance)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
æ€§èƒ½æ˜¯ç³»ç»Ÿåœ¨ç»™å®šæ—¶é—´å†…å¤„ç†è¯·æ±‚çš„èƒ½åŠ›ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\text{Performance} = \frac{\text{Throughput}}{\text{Latency}}$$

**Python å®ç°**ï¼š

```python
import time
import statistics
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
import threading
import queue

@dataclass
class PerformanceMetrics:
    """æ€§èƒ½æŒ‡æ ‡"""
    throughput: float  # ååé‡ (requests/second)
    latency: float     # å»¶è¿Ÿ (seconds)
    response_time: float  # å“åº”æ—¶é—´ (seconds)
    error_rate: float     # é”™è¯¯ç‡
    cpu_usage: float      # CPUä½¿ç”¨ç‡
    memory_usage: float   # å†…å­˜ä½¿ç”¨ç‡

class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics: List[PerformanceMetrics] = []
        self.start_time = None
        self.end_time = None
    
    def start_monitoring(self):
        """å¼€å§‹ç›‘æ§"""
        self.start_time = time.time()
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.end_time = time.time()
    
    def record_metrics(self, metrics: PerformanceMetrics):
        """è®°å½•æ€§èƒ½æŒ‡æ ‡"""
        self.metrics.append(metrics)
    
    def get_average_metrics(self) -> PerformanceMetrics:
        """è·å–å¹³å‡æ€§èƒ½æŒ‡æ ‡"""
        if not self.metrics:
            return PerformanceMetrics(0, 0, 0, 0, 0, 0)
        
        return PerformanceMetrics(
            throughput=statistics.mean([m.throughput for m in self.metrics]),
            latency=statistics.mean([m.latency for m in self.metrics]),
            response_time=statistics.mean([m.response_time for m in self.metrics]),
            error_rate=statistics.mean([m.error_rate for m in self.metrics]),
            cpu_usage=statistics.mean([m.cpu_usage for m in self.metrics]),
            memory_usage=statistics.mean([m.memory_usage for m in self.metrics])
        )
    
    def get_performance_report(self) -> Dict[str, Any]:
        """è·å–æ€§èƒ½æŠ¥å‘Š"""
        avg_metrics = self.get_average_metrics()
        
        return {
            "duration": self.end_time - self.start_time if self.end_time else 0,
            "total_requests": len(self.metrics),
            "average_throughput": avg_metrics.throughput,
            "average_latency": avg_metrics.latency,
            "average_response_time": avg_metrics.response_time,
            "average_error_rate": avg_metrics.error_rate,
            "average_cpu_usage": avg_metrics.cpu_usage,
            "average_memory_usage": avg_metrics.memory_usage
        }

class LoadGenerator:
    """è´Ÿè½½ç”Ÿæˆå™¨"""
    
    def __init__(self, target_system: Callable):
        self.target_system = target_system
        self.request_queue = queue.Queue()
        self.results = []
    
    def generate_load(self, requests_per_second: int, duration: int):
        """ç”Ÿæˆè´Ÿè½½"""
        start_time = time.time()
        end_time = start_time + duration
        
        # å¯åŠ¨å·¥ä½œçº¿ç¨‹
        threads = []
        for _ in range(requests_per_second):
            thread = threading.Thread(target=self._worker)
            thread.start()
            threads.append(thread)
        
        # ç”Ÿæˆè¯·æ±‚
        while time.time() < end_time:
            for _ in range(requests_per_second):
                self.request_queue.put(time.time())
            time.sleep(1)
        
        # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for thread in threads:
            thread.join()
    
    def _worker(self):
        """å·¥ä½œçº¿ç¨‹"""
        while True:
            try:
                start_time = self.request_queue.get(timeout=1)
                request_start = time.time()
                
                # è°ƒç”¨ç›®æ ‡ç³»ç»Ÿ
                result = self.target_system()
                
                request_end = time.time()
                self.results.append({
                    "start_time": start_time,
                    "request_start": request_start,
                    "request_end": request_end,
                    "response_time": request_end - request_start,
                    "result": result
                })
                
            except queue.Empty:
                break

# ç¤ºä¾‹ç›®æ ‡ç³»ç»Ÿ
def sample_system():
    """ç¤ºä¾‹ç³»ç»Ÿ"""
    import random
    time.sleep(random.uniform(0.01, 0.1))  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    return "success"

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_performance_testing():
    """æ¼”ç¤ºæ€§èƒ½æµ‹è¯•"""
    monitor = PerformanceMonitor()
    load_generator = LoadGenerator(sample_system)
    
    # å¼€å§‹ç›‘æ§
    monitor.start_monitoring()
    
    # ç”Ÿæˆè´Ÿè½½
    load_generator.generate_load(requests_per_second=10, duration=5)
    
    # åœæ­¢ç›‘æ§
    monitor.stop_monitoring()
    
    # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    total_requests = len(load_generator.results)
    total_time = monitor.end_time - monitor.start_time
    throughput = total_requests / total_time
    
    avg_response_time = statistics.mean([r["response_time"] for r in load_generator.results])
    
    metrics = PerformanceMetrics(
        throughput=throughput,
        latency=avg_response_time,
        response_time=avg_response_time,
        error_rate=0.0,
        cpu_usage=50.0,  # æ¨¡æ‹Ÿå€¼
        memory_usage=30.0  # æ¨¡æ‹Ÿå€¼
    )
    
    monitor.record_metrics(metrics)
    
    # ç”ŸæˆæŠ¥å‘Š
    report = monitor.get_performance_report()
    print("Performance Report:")
    for key, value in report.items():
        print(f"  {key}: {value}")
```

### 5. å¯é æ€§ (Reliability)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
å¯é æ€§æ˜¯ç³»ç»Ÿåœ¨ç»™å®šæ—¶é—´å†…æ­£ç¡®æ‰§è¡Œå…¶åŠŸèƒ½çš„èƒ½åŠ›ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\text{Reliability} = e^{-\lambda t}$$

å…¶ä¸­ $\lambda$ æ˜¯æ•…éšœç‡ï¼Œ$t$ æ˜¯æ—¶é—´ã€‚

**Python å®ç°**ï¼š

```python
import random
import time
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
import statistics

@dataclass
class ReliabilityMetrics:
    """å¯é æ€§æŒ‡æ ‡"""
    mttf: float  # å¹³å‡æ•…éšœæ—¶é—´ (Mean Time To Failure)
    mttr: float  # å¹³å‡ä¿®å¤æ—¶é—´ (Mean Time To Repair)
    availability: float  # å¯ç”¨æ€§
    error_rate: float  # é”™è¯¯ç‡

class ReliabilityTest:
    """å¯é æ€§æµ‹è¯•"""
    
    def __init__(self, system: Callable):
        self.system = system
        self.failures: List[float] = []
        self.repairs: List[float] = []
        self.total_operations = 0
        self.failed_operations = 0
    
    def run_reliability_test(self, duration: int, failure_rate: float = 0.01):
        """è¿è¡Œå¯é æ€§æµ‹è¯•"""
        start_time = time.time()
        end_time = start_time + duration
        
        last_failure_time = start_time
        
        while time.time() < end_time:
            try:
                # æ‰§è¡Œç³»ç»Ÿæ“ä½œ
                self.system()
                self.total_operations += 1
                
                # æ£€æŸ¥æ˜¯å¦å‘ç”Ÿæ•…éšœ
                if random.random() < failure_rate:
                    failure_time = time.time()
                    self.failures.append(failure_time - last_failure_time)
                    self.failed_operations += 1
                    
                    # æ¨¡æ‹Ÿä¿®å¤æ—¶é—´
                    repair_time = random.uniform(0.1, 1.0)
                    self.repairs.append(repair_time)
                    time.sleep(repair_time)
                    
                    last_failure_time = time.time()
                
            except Exception as e:
                # è®°å½•å¼‚å¸¸æ•…éšœ
                failure_time = time.time()
                self.failures.append(failure_time - last_failure_time)
                self.failed_operations += 1
                last_failure_time = time.time()
    
    def calculate_reliability_metrics(self) -> ReliabilityMetrics:
        """è®¡ç®—å¯é æ€§æŒ‡æ ‡"""
        if not self.failures:
            return ReliabilityMetrics(
                mttf=float('inf'),
                mttr=0.0,
                availability=1.0,
                error_rate=0.0
            )
        
        mttf = statistics.mean(self.failures)
        mttr = statistics.mean(self.repairs) if self.repairs else 0.0
        availability = mttf / (mttf + mttr) if (mttf + mttr) > 0 else 1.0
        error_rate = self.failed_operations / self.total_operations if self.total_operations > 0 else 0.0
        
        return ReliabilityMetrics(mttf, mttr, availability, error_rate)

class FaultTolerance:
    """å®¹é”™æœºåˆ¶"""
    
    def __init__(self, primary_system: Callable, backup_system: Callable = None):
        self.primary_system = primary_system
        self.backup_system = backup_system
        self.failure_count = 0
        self.switch_count = 0
    
    def execute_with_fault_tolerance(self, *args, **kwargs):
        """å¸¦å®¹é”™çš„æ‰§è¡Œ"""
        try:
            return self.primary_system(*args, **kwargs)
        except Exception as e:
            self.failure_count += 1
            
            if self.backup_system:
                self.switch_count += 1
                return self.backup_system(*args, **kwargs)
            else:
                raise e
    
    def get_fault_tolerance_metrics(self) -> Dict[str, Any]:
        """è·å–å®¹é”™æŒ‡æ ‡"""
        return {
            "failure_count": self.failure_count,
            "switch_count": self.switch_count,
            "successful_switches": self.switch_count,
            "fault_tolerance_rate": self.switch_count / max(self.failure_count, 1)
        }

# ç¤ºä¾‹ç³»ç»Ÿ
def reliable_system():
    """å¯é ç³»ç»Ÿ"""
    if random.random() < 0.05:  # 5% æ•…éšœç‡
        raise Exception("System failure")
    return "success"

def backup_system():
    """å¤‡ä»½ç³»ç»Ÿ"""
    return "backup_success"

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_reliability():
    """æ¼”ç¤ºå¯é æ€§æµ‹è¯•"""
    # å¯é æ€§æµ‹è¯•
    test = ReliabilityTest(reliable_system)
    test.run_reliability_test(duration=10, failure_rate=0.05)
    
    metrics = test.calculate_reliability_metrics()
    print("Reliability Metrics:")
    print(f"  MTTF: {metrics.mttf:.2f} seconds")
    print(f"  MTTR: {metrics.mttr:.2f} seconds")
    print(f"  Availability: {metrics.availability:.2%}")
    print(f"  Error Rate: {metrics.error_rate:.2%}")
    
    # å®¹é”™æµ‹è¯•
    fault_tolerance = FaultTolerance(reliable_system, backup_system)
    
    for _ in range(100):
        try:
            result = fault_tolerance.execute_with_fault_tolerance()
        except Exception as e:
            pass
    
    ft_metrics = fault_tolerance.get_fault_tolerance_metrics()
    print("\nFault Tolerance Metrics:")
    for key, value in ft_metrics.items():
        print(f"  {key}: {value}")
```

## ğŸ”¬ ç³»ç»Ÿè®¾è®¡æ¨¡å¼

### 1. åˆ†å±‚æ¶æ„ (Layered Architecture)

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List

class Layer(ABC):
    """å±‚æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.upper_layer = None
        self.lower_layer = None
    
    def set_upper_layer(self, layer: 'Layer'):
        """è®¾ç½®ä¸Šå±‚"""
        self.upper_layer = layer
    
    def set_lower_layer(self, layer: 'Layer'):
        """è®¾ç½®ä¸‹å±‚"""
        self.lower_layer = layer
    
    @abstractmethod
    def process(self, data: Any) -> Any:
        """å¤„ç†æ•°æ®"""
        pass

class PresentationLayer(Layer):
    """è¡¨ç¤ºå±‚"""
    
    def process(self, data: Any) -> Any:
        print(f"[{self.name}] Processing presentation data: {data}")
        
        # å¤„ç†è¡¨ç¤ºå±‚é€»è¾‘
        processed_data = f"presentation_{data}"
        
        if self.lower_layer:
            return self.lower_layer.process(processed_data)
        return processed_data

class BusinessLayer(Layer):
    """ä¸šåŠ¡å±‚"""
    
    def process(self, data: Any) -> Any:
        print(f"[{self.name}] Processing business logic: {data}")
        
        # å¤„ç†ä¸šåŠ¡é€»è¾‘
        processed_data = f"business_{data}"
        
        if self.lower_layer:
            return self.lower_layer.process(processed_data)
        return processed_data

class DataLayer(Layer):
    """æ•°æ®å±‚"""
    
    def process(self, data: Any) -> Any:
        print(f"[{self.name}] Processing data: {data}")
        
        # å¤„ç†æ•°æ®è®¿é—®
        processed_data = f"data_{data}"
        
        if self.upper_layer:
            return self.upper_layer.process(processed_data)
        return processed_data

class LayeredSystem:
    """åˆ†å±‚ç³»ç»Ÿ"""
    
    def __init__(self):
        self.layers: List[Layer] = []
    
    def add_layer(self, layer: Layer):
        """æ·»åŠ å±‚"""
        self.layers.append(layer)
        
        # è®¾ç½®å±‚é—´å…³ç³»
        if len(self.layers) > 1:
            self.layers[-2].set_lower_layer(layer)
            layer.set_upper_layer(self.layers[-2])
    
    def process_request(self, data: Any) -> Any:
        """å¤„ç†è¯·æ±‚"""
        if not self.layers:
            return data
        
        return self.layers[0].process(data)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_layered_architecture():
    """æ¼”ç¤ºåˆ†å±‚æ¶æ„"""
    system = LayeredSystem()
    
    # æ·»åŠ å±‚
    system.add_layer(PresentationLayer("Presentation"))
    system.add_layer(BusinessLayer("Business"))
    system.add_layer(DataLayer("Data"))
    
    # å¤„ç†è¯·æ±‚
    result = system.process_request("user_request")
    print(f"Final result: {result}")
```

### 2. å¾®æœåŠ¡æ¶æ„ (Microservices Architecture)

```python
from typing import Dict, List, Any, Callable
import json
import time
import threading

class Microservice:
    """å¾®æœåŠ¡"""
    
    def __init__(self, name: str, service_function: Callable):
        self.name = name
        self.service_function = service_function
        self.status = "running"
        self.request_count = 0
        self.error_count = 0
    
    def process_request(self, request_data: Any) -> Any:
        """å¤„ç†è¯·æ±‚"""
        self.request_count += 1
        
        try:
            result = self.service_function(request_data)
            return {"status": "success", "data": result, "service": self.name}
        except Exception as e:
            self.error_count += 1
            return {"status": "error", "error": str(e), "service": self.name}
    
    def get_health(self) -> Dict[str, Any]:
        """è·å–å¥åº·çŠ¶æ€"""
        return {
            "name": self.name,
            "status": self.status,
            "request_count": self.request_count,
            "error_count": self.error_count,
            "error_rate": self.error_count / max(self.request_count, 1)
        }

class ServiceRegistry:
    """æœåŠ¡æ³¨å†Œä¸­å¿ƒ"""
    
    def __init__(self):
        self.services: Dict[str, Microservice] = {}
    
    def register_service(self, service: Microservice):
        """æ³¨å†ŒæœåŠ¡"""
        self.services[service.name] = service
    
    def get_service(self, name: str) -> Microservice:
        """è·å–æœåŠ¡"""
        return self.services.get(name)
    
    def list_services(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
        return list(self.services.keys())
    
    def get_health_report(self) -> Dict[str, Any]:
        """è·å–å¥åº·æŠ¥å‘Š"""
        return {
            service_name: service.get_health()
            for service_name, service in self.services.items()
        }

class APIGateway:
    """APIç½‘å…³"""
    
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry
        self.routing_rules: Dict[str, str] = {}
    
    def add_routing_rule(self, path: str, service_name: str):
        """æ·»åŠ è·¯ç”±è§„åˆ™"""
        self.routing_rules[path] = service_name
    
    def route_request(self, path: str, request_data: Any) -> Any:
        """è·¯ç”±è¯·æ±‚"""
        service_name = self.routing_rules.get(path)
        if not service_name:
            return {"status": "error", "error": "Service not found"}
        
        service = self.service_registry.get_service(service_name)
        if not service:
            return {"status": "error", "error": "Service unavailable"}
        
        return service.process_request(request_data)

# ç¤ºä¾‹å¾®æœåŠ¡
def user_service(data):
    """ç”¨æˆ·æœåŠ¡"""
    return {"user_id": 123, "name": "John Doe"}

def order_service(data):
    """è®¢å•æœåŠ¡"""
    return {"order_id": 456, "items": ["item1", "item2"]}

def payment_service(data):
    """æ”¯ä»˜æœåŠ¡"""
    return {"payment_id": 789, "amount": 100.0}

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_microservices():
    """æ¼”ç¤ºå¾®æœåŠ¡æ¶æ„"""
    # åˆ›å»ºæœåŠ¡æ³¨å†Œä¸­å¿ƒ
    registry = ServiceRegistry()
    
    # æ³¨å†Œå¾®æœåŠ¡
    registry.register_service(Microservice("user", user_service))
    registry.register_service(Microservice("order", order_service))
    registry.register_service(Microservice("payment", payment_service))
    
    # åˆ›å»ºAPIç½‘å…³
    gateway = APIGateway(registry)
    
    # æ·»åŠ è·¯ç”±è§„åˆ™
    gateway.add_routing_rule("/users", "user")
    gateway.add_routing_rule("/orders", "order")
    gateway.add_routing_rule("/payments", "payment")
    
    # å¤„ç†è¯·æ±‚
    paths = ["/users", "/orders", "/payments"]
    for path in paths:
        result = gateway.route_request(path, {})
        print(f"Request to {path}: {result}")
    
    # è·å–å¥åº·æŠ¥å‘Š
    health_report = registry.get_health_report()
    print("\nHealth Report:")
    for service_name, health in health_report.items():
        print(f"  {service_name}: {health}")
```

## ğŸ§ª æµ‹è¯•ä¸éªŒè¯

```python
import unittest
from typing import List, Any

class SystemDesignTest(unittest.TestCase):
    """ç³»ç»Ÿè®¾è®¡æµ‹è¯•ç±»"""
    
    def test_system_components(self):
        """æµ‹è¯•ç³»ç»Ÿç»„ä»¶"""
        system = System("TestSystem")
        
        # æ·»åŠ ç»„ä»¶
        component = Component("comp1", "TestComponent", ComponentType.PROCESSOR, "data")
        system.add_component(component)
        
        # éªŒè¯ç»„ä»¶
        self.assertIn("comp1", system.components)
        self.assertEqual(len(system.components), 1)
    
    def test_architecture_patterns(self):
        """æµ‹è¯•æ¶æ„æ¨¡å¼"""
        architecture = SystemArchitecture("TestArchitecture")
        
        # æ·»åŠ æ¨¡å¼
        architecture.add_pattern(ArchitecturePattern.MICROSERVICES)
        architecture.add_pattern(ArchitecturePattern.EVENT_DRIVEN)
        
        # éªŒè¯æ¨¡å¼
        self.assertIn(ArchitecturePattern.MICROSERVICES, architecture.patterns)
        self.assertIn(ArchitecturePattern.EVENT_DRIVEN, architecture.patterns)
    
    def test_scalability(self):
        """æµ‹è¯•å¯æ‰©å±•æ€§"""
        test = ScalabilityTest()
        
        def simple_workload(scale):
            return sum(range(scale * 1000))
        
        # æµ‹è¯•å‚ç›´æ‰©å±•
        test.test_vertical_scaling(simple_workload, 3)
        
        # éªŒè¯ç»“æœ
        self.assertIn(1, test.results)
        self.assertIn(2, test.results)
        self.assertIn(3, test.results)
    
    def test_layered_architecture(self):
        """æµ‹è¯•åˆ†å±‚æ¶æ„"""
        system = LayeredSystem()
        
        # æ·»åŠ å±‚
        system.add_layer(PresentationLayer("Presentation"))
        system.add_layer(BusinessLayer("Business"))
        system.add_layer(DataLayer("Data"))
        
        # å¤„ç†è¯·æ±‚
        result = system.process_request("test")
        
        # éªŒè¯ç»“æœåŒ…å«æ‰€æœ‰å±‚çš„å¤„ç†
        self.assertIn("presentation", result)
        self.assertIn("business", result)
        self.assertIn("data", result)
    
    def test_microservices(self):
        """æµ‹è¯•å¾®æœåŠ¡æ¶æ„"""
        registry = ServiceRegistry()
        
        # æ³¨å†ŒæœåŠ¡
        def test_service(data):
            return "test_result"
        
        service = Microservice("test", test_service)
        registry.register_service(service)
        
        # éªŒè¯æœåŠ¡æ³¨å†Œ
        self.assertIn("test", registry.list_services())
        
        # æµ‹è¯•æœåŠ¡è°ƒç”¨
        result = service.process_request("test_data")
        self.assertEqual(result["status"], "success")
        self.assertEqual(result["data"], "test_result")

if __name__ == '__main__':
    unittest.main()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [03-04-02-åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡](./03-04-02-åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡.md)
- [03-04-03-é«˜å¯ç”¨æ€§è®¾è®¡](./03-04-03-é«˜å¯ç”¨æ€§è®¾è®¡.md)
- [03-02-è½¯ä»¶æ¶æ„åŸºç¡€](../03-02-è½¯ä»¶æ¶æ„/03-02-01-è½¯ä»¶æ¶æ„åŸºç¡€.md)
- [05-01-å¾®æœåŠ¡æ¶æ„](../../05-æ¶æ„é¢†åŸŸ/05-01-å¾®æœåŠ¡æ¶æ„/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Bass, L., Clements, P., & Kazman, R. (2012). Software Architecture in Practice.
2. Fowler, M. (2018). Microservices Patterns.
3. Hohpe, G., & Woolf, B. (2003). Enterprise Integration Patterns.
4. Kleppmann, M. (2017). Designing Data-Intensive Applications.

---

*æœ¬æ–‡æ¡£æä¾›äº†ç³»ç»Ÿè®¾è®¡åŸºç¡€çš„å®Œæ•´å½¢å¼åŒ–ç†è®ºæ¡†æ¶ï¼Œä»æ•°å­¦å®šä¹‰åˆ°Pythonå®ç°ï¼Œä¸ºç³»ç»Ÿè®¾è®¡å®è·µæä¾›ç†è®ºåŸºç¡€ã€‚*
