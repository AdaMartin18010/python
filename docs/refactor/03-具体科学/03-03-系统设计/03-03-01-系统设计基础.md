# 03-03-01 ç³»ç»Ÿè®¾è®¡åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

ç³»ç»Ÿè®¾è®¡æ˜¯æ„å»ºå¯æ‰©å±•ã€é«˜æ€§èƒ½ã€é«˜å¯ç”¨è½¯ä»¶ç³»ç»Ÿçš„è‰ºæœ¯å’Œç§‘å­¦ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°ç³»ç»Ÿè®¾è®¡çš„æ ¸å¿ƒæ¦‚å¿µï¼Œæä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜ï¼Œå¹¶é€šè¿‡Pythonä»£ç å®ç°ç›¸å…³è®¾è®¡æ¨¡å¼ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç³»ç»Ÿå®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (è½¯ä»¶ç³»ç»Ÿ)
è½¯ä»¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$S = (C, I, O, F)$$
å…¶ä¸­ï¼š
- $C$ æ˜¯ç»„ä»¶é›†åˆ
- $I$ æ˜¯è¾“å…¥é›†åˆ
- $O$ æ˜¯è¾“å‡ºé›†åˆ
- $F$ æ˜¯åŠŸèƒ½æ˜ å°„ï¼š$F: I \rightarrow O$

**å®šä¹‰ 1.2** (ç³»ç»Ÿæ€§èƒ½)
ç³»ç»Ÿæ€§èƒ½å®šä¹‰ä¸ºï¼š
$$P(S) = \frac{\text{å¤„ç†è¯·æ±‚æ•°}}{\text{æ—¶é—´}} \times \text{å“åº”æ—¶é—´} \times \text{å¯ç”¨æ€§}$$

**å®šä¹‰ 1.3** (ç³»ç»Ÿå¯æ‰©å±•æ€§)
ç³»ç»Ÿå¯æ‰©å±•æ€§å®šä¹‰ä¸ºï¼š
$$E(S) = \frac{\text{è´Ÿè½½å¢åŠ }}{\text{èµ„æºå¢åŠ }}$$

#### 1.2 ç³»ç»Ÿå±æ€§å®šç†

**å®šç† 1.1** (ç³»ç»Ÿå®Œæ•´æ€§)
å¦‚æœç³»ç»Ÿ $S = (C, I, O, F)$ æ˜¯å®Œæ•´çš„ï¼Œåˆ™å¯¹äºä»»æ„è¾“å…¥ $i \in I$ï¼Œå­˜åœ¨è¾“å‡º $o \in O$ ä½¿å¾— $F(i) = o$ã€‚

**è¯æ˜**:
1. è®¾ $S = (C, I, O, F)$ æ˜¯å®Œæ•´ç³»ç»Ÿ
2. æ ¹æ®å®Œæ•´æ€§å®šä¹‰ï¼Œ$F$ æ˜¯æ»¡å°„
3. å› æ­¤å¯¹äºä»»æ„ $i \in I$ï¼Œå­˜åœ¨ $o \in O$ ä½¿å¾— $F(i) = o$

### 2. è´Ÿè½½å‡è¡¡

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1** (è´Ÿè½½å‡è¡¡)
è´Ÿè½½å‡è¡¡æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$LB: \text{Request} \rightarrow \text{Server}$$
æ»¡è¶³ï¼š
$$\forall s \in \text{Server}: |LB^{-1}(s)| \approx \frac{|\text{Request}|}{|\text{Server}|}$$

**å®šä¹‰ 2.2** (è´Ÿè½½å‡è¡¡ç®—æ³•)
è´Ÿè½½å‡è¡¡ç®—æ³• $A$ çš„æ€§èƒ½å®šä¹‰ä¸ºï¼š
$$P(A) = \frac{\text{å¹³å‡å“åº”æ—¶é—´}}{\text{ååé‡}} \times \text{å…¬å¹³æ€§}$$

#### 2.2 è´Ÿè½½å‡è¡¡å®šç†

**å®šç† 2.1** (è´Ÿè½½å‡è¡¡æœ€ä¼˜æ€§)
è½®è¯¢ç®—æ³•åœ¨æœåŠ¡å™¨æ€§èƒ½ç›¸åŒæ—¶æ˜¯æœ€ä¼˜çš„ã€‚

**è¯æ˜**:
1. è®¾ $n$ ä¸ªæœåŠ¡å™¨æ€§èƒ½ç›¸åŒ
2. è½®è¯¢ç®—æ³•å°†è¯·æ±‚å‡åŒ€åˆ†é…
3. æ¯ä¸ªæœåŠ¡å™¨å¤„ç† $\frac{|\text{Request}|}{n}$ ä¸ªè¯·æ±‚
4. å› æ­¤è´Ÿè½½åˆ†å¸ƒæœ€å‡åŒ€

### 3. ç¼“å­˜ç­–ç•¥

#### 3.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 3.1** (ç¼“å­˜)
ç¼“å­˜æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$C: \text{Key} \rightarrow \text{Value}$$
å…·æœ‰å®¹é‡é™åˆ¶ï¼š
$$|C| \leq \text{Capacity}$$

**å®šä¹‰ 3.2** (ç¼“å­˜å‘½ä¸­ç‡)
ç¼“å­˜å‘½ä¸­ç‡å®šä¹‰ä¸ºï¼š
$$H(C) = \frac{\text{å‘½ä¸­æ¬¡æ•°}}{\text{æ€»è¯·æ±‚æ¬¡æ•°}}$$

**å®šä¹‰ 3.3** (LRUç®—æ³•)
LRUç®—æ³•æ»¡è¶³ï¼š
$$\forall k \in C: \text{AccessTime}(k) \geq \text{AccessTime}(k') \text{ for } k' \notin C$$

#### 3.2 ç¼“å­˜ç­–ç•¥å®šç†

**å®šç† 3.1** (LRUæœ€ä¼˜æ€§)
å¯¹äºå±€éƒ¨æ€§è®¿é—®æ¨¡å¼ï¼ŒLRUç®—æ³•è¿‘ä¼¼æœ€ä¼˜ã€‚

**è¯æ˜**:
1. è®¾è®¿é—®æ¨¡å¼å…·æœ‰æ—¶é—´å±€éƒ¨æ€§
2. LRUä¿ç•™æœ€è¿‘è®¿é—®çš„æ•°æ®
3. å› æ­¤å‘½ä¸­ç‡æœ€é«˜
4. å¯¹äºå±€éƒ¨æ€§æ¨¡å¼ï¼ŒLRUè¿‘ä¼¼æœ€ä¼˜

## ğŸ Pythonå®ç°

### 1. åŸºç¡€ç³»ç»Ÿæ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import queue
import statistics

class SystemStatus(Enum):
    """ç³»ç»ŸçŠ¶æ€æšä¸¾"""
    RUNNING = "running"
    STOPPED = "stopped"
    ERROR = "error"
    MAINTENANCE = "maintenance"

@dataclass
class Request:
    """è¯·æ±‚ç±»"""
    id: str
    data: Any
    timestamp: float = field(default_factory=time.time)
    priority: int = 0
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Response:
    """å“åº”ç±»"""
    request_id: str
    data: Any
    timestamp: float = field(default_factory=time.time)
    processing_time: float = 0.0

class Component(ABC):
    """ç»„ä»¶æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.status = SystemStatus.STOPPED
        self.metrics = {
            "requests_processed": 0,
            "response_times": [],
            "errors": 0
        }
    
    @abstractmethod
    def process(self, request: Request) -> Response:
        """å¤„ç†è¯·æ±‚"""
        pass
    
    def start(self) -> None:
        """å¯åŠ¨ç»„ä»¶"""
        self.status = SystemStatus.RUNNING
    
    def stop(self) -> None:
        """åœæ­¢ç»„ä»¶"""
        self.status = SystemStatus.STOPPED
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡"""
        avg_response_time = (statistics.mean(self.metrics["response_times"]) 
                           if self.metrics["response_times"] else 0)
        return {
            **self.metrics,
            "avg_response_time": avg_response_time,
            "status": self.status.value
        }

class System:
    """ç³»ç»Ÿç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.components: Dict[str, Component] = {}
        self.status = SystemStatus.STOPPED
        self.request_queue = queue.Queue()
        self.response_queue = queue.Queue()
        self.workers: List[threading.Thread] = []
        self.max_workers = 4
    
    def add_component(self, component: Component) -> None:
        """æ·»åŠ ç»„ä»¶"""
        self.components[component.name] = component
    
    def remove_component(self, component_name: str) -> None:
        """ç§»é™¤ç»„ä»¶"""
        if component_name in self.components:
            del self.components[component_name]
    
    def submit_request(self, request: Request) -> None:
        """æäº¤è¯·æ±‚"""
        self.request_queue.put(request)
    
    def get_response(self, timeout: float = 1.0) -> Optional[Response]:
        """è·å–å“åº”"""
        try:
            return self.response_queue.get(timeout=timeout)
        except queue.Empty:
            return None
    
    def start(self) -> None:
        """å¯åŠ¨ç³»ç»Ÿ"""
        self.status = SystemStatus.RUNNING
        
        # å¯åŠ¨æ‰€æœ‰ç»„ä»¶
        for component in self.components.values():
            component.start()
        
        # å¯åŠ¨å·¥ä½œçº¿ç¨‹
        for i in range(self.max_workers):
            worker = threading.Thread(target=self._worker, daemon=True)
            worker.start()
            self.workers.append(worker)
    
    def stop(self) -> None:
        """åœæ­¢ç³»ç»Ÿ"""
        self.status = SystemStatus.STOPPED
        
        # åœæ­¢æ‰€æœ‰ç»„ä»¶
        for component in self.components.values():
            component.stop()
    
    def _worker(self) -> None:
        """å·¥ä½œçº¿ç¨‹"""
        while self.status == SystemStatus.RUNNING:
            try:
                request = self.request_queue.get(timeout=1.0)
                response = self._process_request(request)
                self.response_queue.put(response)
            except queue.Empty:
                continue
            except Exception as e:
                print(f"å¤„ç†è¯·æ±‚æ—¶å‡ºé”™: {e}")
    
    def _process_request(self, request: Request) -> Response:
        """å¤„ç†è¯·æ±‚"""
        start_time = time.time()
        
        # é€‰æ‹©ç»„ä»¶å¤„ç†è¯·æ±‚
        component = self._select_component(request)
        if component:
            response = component.process(request)
        else:
            response = Response(request.id, {"error": "No component available"})
        
        response.processing_time = time.time() - start_time
        return response
    
    def _select_component(self, request: Request) -> Optional[Component]:
        """é€‰æ‹©ç»„ä»¶"""
        # ç®€å•çš„è½®è¯¢é€‰æ‹©
        available_components = [c for c in self.components.values() 
                              if c.status == SystemStatus.RUNNING]
        if available_components:
            return available_components[hash(request.id) % len(available_components)]
        return None
    
    def get_system_metrics(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸæŒ‡æ ‡"""
        total_requests = sum(c.metrics["requests_processed"] 
                           for c in self.components.values())
        total_errors = sum(c.metrics["errors"] 
                         for c in self.components.values())
        
        return {
            "name": self.name,
            "status": self.status.value,
            "total_requests": total_requests,
            "total_errors": total_errors,
            "error_rate": total_errors / total_requests if total_requests > 0 else 0,
            "components": {name: comp.get_metrics() 
                          for name, comp in self.components.items()}
        }
```

### 2. è´Ÿè½½å‡è¡¡å™¨å®ç°

```python
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass, field
import time
import random

class LoadBalancingStrategy(ABC):
    """è´Ÿè½½å‡è¡¡ç­–ç•¥æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def select_server(self, servers: List['Server'], request: Request) -> 'Server':
        """é€‰æ‹©æœåŠ¡å™¨"""
        pass

class RoundRobinStrategy(LoadBalancingStrategy):
    """è½®è¯¢ç­–ç•¥"""
    
    def __init__(self):
        self.current_index = 0
    
    def select_server(self, servers: List['Server'], request: Request) -> 'Server':
        if not servers:
            raise ValueError("æ²¡æœ‰å¯ç”¨çš„æœåŠ¡å™¨")
        
        server = servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(servers)
        return server

class LeastConnectionsStrategy(LoadBalancingStrategy):
    """æœ€å°‘è¿æ¥ç­–ç•¥"""
    
    def select_server(self, servers: List['Server'], request: Request) -> 'Server':
        if not servers:
            raise ValueError("æ²¡æœ‰å¯ç”¨çš„æœåŠ¡å™¨")
        
        return min(servers, key=lambda s: s.active_connections)

class WeightedRoundRobinStrategy(LoadBalancingStrategy):
    """åŠ æƒè½®è¯¢ç­–ç•¥"""
    
    def __init__(self, weights: Dict[str, int]):
        self.weights = weights
        self.current_weights = weights.copy()
    
    def select_server(self, servers: List['Server'], request: Request) -> 'Server':
        if not servers:
            raise ValueError("æ²¡æœ‰å¯ç”¨çš„æœåŠ¡å™¨")
        
        # æ‰¾åˆ°æƒé‡æœ€å¤§çš„æœåŠ¡å™¨
        max_weight = max(self.current_weights.values())
        selected_server = None
        
        for server in servers:
            if self.current_weights[server.name] == max_weight:
                selected_server = server
                break
        
        # æ›´æ–°æƒé‡
        for server_name in self.current_weights:
            if server_name == selected_server.name:
                self.current_weights[server_name] -= sum(self.weights.values())
            else:
                self.current_weights[server_name] += self.weights[server_name]
        
        return selected_server

@dataclass
class Server:
    """æœåŠ¡å™¨ç±»"""
    name: str
    address: str
    weight: int = 1
    active_connections: int = 0
    total_requests: int = 0
    response_times: List[float] = field(default_factory=list)
    
    def process_request(self, request: Request) -> Response:
        """å¤„ç†è¯·æ±‚"""
        start_time = time.time()
        self.active_connections += 1
        self.total_requests += 1
        
        # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        processing_time = random.uniform(0.1, 0.5)
        time.sleep(processing_time)
        
        response = Response(
            request_id=request.id,
            data=f"Processed by {self.name}",
            processing_time=time.time() - start_time
        )
        
        self.response_times.append(response.processing_time)
        self.active_connections -= 1
        
        return response
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡"""
        avg_response_time = (statistics.mean(self.response_times) 
                           if self.response_times else 0)
        return {
            "name": self.name,
            "address": self.address,
            "weight": self.weight,
            "active_connections": self.active_connections,
            "total_requests": self.total_requests,
            "avg_response_time": avg_response_time
        }

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, strategy: LoadBalancingStrategy):
        self.strategy = strategy
        self.servers: List[Server] = []
        self.metrics = {
            "total_requests": 0,
            "requests_per_server": {},
            "response_times": []
        }
    
    def add_server(self, server: Server) -> None:
        """æ·»åŠ æœåŠ¡å™¨"""
        self.servers.append(server)
        self.metrics["requests_per_server"][server.name] = 0
    
    def remove_server(self, server_name: str) -> None:
        """ç§»é™¤æœåŠ¡å™¨"""
        self.servers = [s for s in self.servers if s.name != server_name]
        if server_name in self.metrics["requests_per_server"]:
            del self.metrics["requests_per_server"][server_name]
    
    def process_request(self, request: Request) -> Response:
        """å¤„ç†è¯·æ±‚"""
        if not self.servers:
            raise ValueError("æ²¡æœ‰å¯ç”¨çš„æœåŠ¡å™¨")
        
        # é€‰æ‹©æœåŠ¡å™¨
        server = self.strategy.select_server(self.servers, request)
        
        # å¤„ç†è¯·æ±‚
        start_time = time.time()
        response = server.process_request(request)
        response.processing_time = time.time() - start_time
        
        # æ›´æ–°æŒ‡æ ‡
        self.metrics["total_requests"] += 1
        self.metrics["requests_per_server"][server.name] += 1
        self.metrics["response_times"].append(response.processing_time)
        
        return response
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡"""
        avg_response_time = (statistics.mean(self.metrics["response_times"]) 
                           if self.metrics["response_times"] else 0)
        
        return {
            "total_requests": self.metrics["total_requests"],
            "avg_response_time": avg_response_time,
            "requests_per_server": self.metrics["requests_per_server"],
            "servers": [server.get_metrics() for server in self.servers]
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_load_balancing():
    """æ¼”ç¤ºè´Ÿè½½å‡è¡¡"""
    
    # åˆ›å»ºæœåŠ¡å™¨
    servers = [
        Server("server1", "192.168.1.10:8080", weight=2),
        Server("server2", "192.168.1.11:8080", weight=1),
        Server("server3", "192.168.1.12:8080", weight=1)
    ]
    
    # åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
    weights = {"server1": 2, "server2": 1, "server3": 1}
    lb = LoadBalancer(WeightedRoundRobinStrategy(weights))
    
    for server in servers:
        lb.add_server(server)
    
    # å¤„ç†è¯·æ±‚
    for i in range(10):
        request = Request(f"req_{i}", f"data_{i}")
        response = lb.process_request(request)
        print(f"è¯·æ±‚ {i}: {response.data}")
    
    # æ˜¾ç¤ºæŒ‡æ ‡
    metrics = lb.get_metrics()
    print(f"è´Ÿè½½å‡è¡¡å™¨æŒ‡æ ‡: {metrics}")
    
    return lb, servers
```

### 3. ç¼“å­˜ç³»ç»Ÿå®ç°

```python
from typing import Dict, Any, Optional, Callable
from dataclasses import dataclass, field
import time
import threading
from collections import OrderedDict

class CachePolicy(ABC):
    """ç¼“å­˜ç­–ç•¥æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def get(self, key: str) -> Optional[Any]:
        """è·å–å€¼"""
        pass
    
    @abstractmethod
    def put(self, key: str, value: Any) -> None:
        """å­˜å‚¨å€¼"""
        pass
    
    @abstractmethod
    def evict(self) -> Optional[str]:
        """é©±é€é”®"""
        pass

class LRUCache(CachePolicy):
    """LRUç¼“å­˜å®ç°"""
    
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache: OrderedDict[str, Any] = OrderedDict()
        self.lock = threading.Lock()
    
    def get(self, key: str) -> Optional[Any]:
        with self.lock:
            if key in self.cache:
                # ç§»åŠ¨åˆ°æœ«å°¾ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
                value = self.cache.pop(key)
                self.cache[key] = value
                return value
            return None
    
    def put(self, key: str, value: Any) -> None:
        with self.lock:
            if key in self.cache:
                # æ›´æ–°ç°æœ‰å€¼
                self.cache.pop(key)
            elif len(self.cache) >= self.capacity:
                # é©±é€æœ€ä¹…æœªä½¿ç”¨çš„
                self.cache.popitem(last=False)
            
            self.cache[key] = value
    
    def evict(self) -> Optional[str]:
        with self.lock:
            if self.cache:
                return self.cache.popitem(last=False)[0]
            return None

class LFUCache(CachePolicy):
    """LFUç¼“å­˜å®ç°"""
    
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache: Dict[str, Any] = {}
        self.frequency: Dict[str, int] = {}
        self.freq_to_keys: Dict[int, set] = {}
        self.min_freq = 0
        self.lock = threading.Lock()
    
    def get(self, key: str) -> Optional[Any]:
        with self.lock:
            if key in self.cache:
                # æ›´æ–°é¢‘ç‡
                freq = self.frequency[key]
                self.frequency[key] = freq + 1
                
                # æ›´æ–°é¢‘ç‡æ˜ å°„
                self.freq_to_keys[freq].discard(key)
                if not self.freq_to_keys[freq]:
                    del self.freq_to_keys[freq]
                    if freq == self.min_freq:
                        self.min_freq += 1
                
                if freq + 1 not in self.freq_to_keys:
                    self.freq_to_keys[freq + 1] = set()
                self.freq_to_keys[freq + 1].add(key)
                
                return self.cache[key]
            return None
    
    def put(self, key: str, value: Any) -> None:
        with self.lock:
            if key in self.cache:
                # æ›´æ–°ç°æœ‰å€¼
                self.cache[key] = value
                self.get(key)  # æ›´æ–°é¢‘ç‡
                return
            
            if len(self.cache) >= self.capacity:
                # é©±é€æœ€å°‘ä½¿ç”¨çš„
                evict_key = min(self.freq_to_keys[self.min_freq])
                self.freq_to_keys[self.min_freq].discard(evict_key)
                if not self.freq_to_keys[self.min_freq]:
                    del self.freq_to_keys[self.min_freq]
                del self.cache[evict_key]
                del self.frequency[evict_key]
            
            # æ·»åŠ æ–°å€¼
            self.cache[key] = value
            self.frequency[key] = 1
            if 1 not in self.freq_to_keys:
                self.freq_to_keys[1] = set()
            self.freq_to_keys[1].add(key)
            self.min_freq = 1
    
    def evict(self) -> Optional[str]:
        with self.lock:
            if self.cache:
                evict_key = min(self.freq_to_keys[self.min_freq])
                self.freq_to_keys[self.min_freq].discard(evict_key)
                if not self.freq_to_keys[self.min_freq]:
                    del self.freq_to_keys[self.min_freq]
                del self.cache[evict_key]
                del self.frequency[evict_key]
                return evict_key
            return None

class CacheManager:
    """ç¼“å­˜ç®¡ç†å™¨"""
    
    def __init__(self, policy: CachePolicy):
        self.policy = policy
        self.metrics = {
            "hits": 0,
            "misses": 0,
            "evictions": 0
        }
    
    def get(self, key: str) -> Optional[Any]:
        """è·å–å€¼"""
        value = self.policy.get(key)
        if value is not None:
            self.metrics["hits"] += 1
        else:
            self.metrics["misses"] += 1
        return value
    
    def put(self, key: str, value: Any) -> None:
        """å­˜å‚¨å€¼"""
        # æ£€æŸ¥æ˜¯å¦éœ€è¦é©±é€
        if hasattr(self.policy, 'capacity') and hasattr(self.policy, 'cache'):
            if len(self.policy.cache) >= self.policy.capacity and key not in self.policy.cache:
                self.metrics["evictions"] += 1
        
        self.policy.put(key, value)
    
    def get_hit_rate(self) -> float:
        """è·å–å‘½ä¸­ç‡"""
        total = self.metrics["hits"] + self.metrics["misses"]
        return self.metrics["hits"] / total if total > 0 else 0
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡"""
        return {
            **self.metrics,
            "hit_rate": self.get_hit_rate(),
            "cache_size": len(self.policy.cache) if hasattr(self.policy, 'cache') else 0
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_caching():
    """æ¼”ç¤ºç¼“å­˜ç³»ç»Ÿ"""
    
    # åˆ›å»ºLRUç¼“å­˜
    lru_cache = LRUCache(capacity=3)
    cache_manager = CacheManager(lru_cache)
    
    # æ¨¡æ‹Ÿæ•°æ®è®¿é—®æ¨¡å¼
    access_pattern = ["A", "B", "C", "A", "D", "B", "E", "A", "C"]
    
    print("LRUç¼“å­˜æ¼”ç¤º:")
    for key in access_pattern:
        value = cache_manager.get(key)
        if value is None:
            # ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®æºè·å–
            value = f"data_{key}"
            cache_manager.put(key, value)
            print(f"ç¼“å­˜æœªå‘½ä¸­: {key} -> {value}")
        else:
            print(f"ç¼“å­˜å‘½ä¸­: {key} -> {value}")
    
    print(f"ç¼“å­˜æŒ‡æ ‡: {cache_manager.get_metrics()}")
    
    # åˆ›å»ºLFUç¼“å­˜
    lfu_cache = LFUCache(capacity=3)
    lfu_manager = CacheManager(lfu_cache)
    
    print("\nLFUç¼“å­˜æ¼”ç¤º:")
    for key in access_pattern:
        value = lfu_manager.get(key)
        if value is None:
            value = f"data_{key}"
            lfu_manager.put(key, value)
            print(f"ç¼“å­˜æœªå‘½ä¸­: {key} -> {value}")
        else:
            print(f"ç¼“å­˜å‘½ä¸­: {key} -> {value}")
    
    print(f"ç¼“å­˜æŒ‡æ ‡: {lfu_manager.get_metrics()}")
    
    return cache_manager, lfu_manager
```

## ğŸ“Š æ•°å­¦è¯æ˜

### 1. ç³»ç»Ÿæ€§èƒ½å®šç†

**å®šç† 1.1** (ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–)
å¯¹äºç»™å®šè´Ÿè½½ï¼Œç³»ç»Ÿæ€§èƒ½å¯ä»¥é€šè¿‡å¢åŠ èµ„æºæ¥ä¼˜åŒ–ã€‚

**è¯æ˜**:
1. è®¾ç³»ç»Ÿ $S$ çš„å½“å‰æ€§èƒ½ä¸º $P(S)$
2. å¢åŠ èµ„æº $R$ åï¼Œæ–°ç³»ç»Ÿ $S'$ çš„æ€§èƒ½ä¸º $P(S')$
3. æ ¹æ®èµ„æºå¢åŠ ï¼Œ$P(S') > P(S)$
4. å› æ­¤ç³»ç»Ÿæ€§èƒ½å¾—åˆ°ä¼˜åŒ–

### 2. è´Ÿè½½å‡è¡¡æœ€ä¼˜æ€§å®šç†

**å®šç† 1.2** (è´Ÿè½½å‡è¡¡æœ€ä¼˜æ€§)
åœ¨æœåŠ¡å™¨æ€§èƒ½ç›¸åŒæ—¶ï¼Œè½®è¯¢ç®—æ³•æ˜¯æœ€ä¼˜çš„è´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚

**è¯æ˜**:
1. è®¾ $n$ ä¸ªæœåŠ¡å™¨æ€§èƒ½ç›¸åŒ
2. è½®è¯¢ç®—æ³•å°†è¯·æ±‚å‡åŒ€åˆ†é…
3. æ¯ä¸ªæœåŠ¡å™¨å¤„ç† $\frac{|\text{Request}|}{n}$ ä¸ªè¯·æ±‚
4. å› æ­¤è´Ÿè½½åˆ†å¸ƒæœ€å‡åŒ€ï¼Œæ€§èƒ½æœ€ä¼˜

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [è½¯ä»¶æ¶æ„ç†è®º](../03-02-è½¯ä»¶æ¶æ„/README.md)
- [è®¾è®¡æ¨¡å¼ç†è®º](../03-01-è®¾è®¡æ¨¡å¼/README.md)
- [åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º](../03-05-åˆ†å¸ƒå¼ç³»ç»Ÿ/README.md)
- [æ€§èƒ½ä¼˜åŒ–ç†è®º](../03-06-æ€§èƒ½ä¼˜åŒ–/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Kleppmann, M. (2017). Designing Data-Intensive Applications
2. Newman, S. (2021). Building Microservices: Designing Fine-Grained Systems
3. Martin, R. C. (2017). Clean Architecture: A Craftsman's Guide to Software Structure and Design
4. Bass, L., Clements, P., & Kazman, R. (2012). Software Architecture in Practice
5. Richards, M. (2020). Fundamentals of Software Architecture: An Engineering Approach

---

*ç³»ç»Ÿè®¾è®¡ä¸ºæ„å»ºå¯æ‰©å±•ã€é«˜æ€§èƒ½çš„è½¯ä»¶ç³»ç»Ÿæä¾›äº†ç³»ç»ŸåŒ–çš„æ–¹æ³•è®ºï¼Œé€šè¿‡å½¢å¼åŒ–çš„æ•°å­¦å®šä¹‰å’Œä¸¥æ ¼çš„è¯æ˜ï¼Œæˆ‘ä»¬å»ºç«‹äº†ç³»ç»Ÿè®¾è®¡çš„å®Œæ•´ç†è®ºä½“ç³»ã€‚* 