# 01-编程语言理论

## 概述

编程语言理论是计算机科学的核心基础，研究编程语言的设计、实现、语义和类型系统。本章将系统性地介绍编程语言的基本理论，包括语言设计原理、类型系统、编译原理和运行时系统，并通过Python实现展示这些理论的实际应用。

## 1. 语言设计原理

### 1.1 编程语言的形式化定义

**定义1.1**: 编程语言是一个四元组 $\mathcal{L} = (\Sigma, \mathcal{S}, \mathcal{E}, \mathcal{T})$，其中：

- $\Sigma$ 是字母表（字符集）
- $\mathcal{S}$ 是语法规则集合
- $\mathcal{E}$ 是语义规则集合  
- $\mathcal{T}$ 是类型系统

**定义1.2**: 语法结构 $G = (N, T, P, S)$ 是一个上下文无关文法，其中：

- $N$ 是非终结符集合
- $T$ 是终结符集合
- $P$ 是产生式规则集合
- $S$ 是开始符号

**定义1.3**: 抽象语法树（AST）是一个有根树 $T = (V, E, r)$，其中：

- $V$ 是节点集合
- $E$ 是边集合
- $r \in V$ 是根节点
- 每个节点表示一个语法结构

### 1.2 语言设计原则

**原则1.1**: 正交性原则 - 语言特性应该相互独立，避免冗余。

**原则1.2**: 一致性原则 - 相似的概念应该有相似的处理方式。

**原则1.3**: 简洁性原则 - 语言应该简洁明了，避免不必要的复杂性。

**原则1.4**: 表达能力原则 - 语言应该具有足够的表达能力。

### 1.3 Python实现：语言解析器

```python
from typing import List, Dict, Optional, Union, Any
from enum import Enum
from dataclasses import dataclass
from abc import ABC, abstractmethod

class TokenType(Enum):
    """词法单元类型"""
    IDENTIFIER = "IDENTIFIER"
    NUMBER = "NUMBER"
    STRING = "STRING"
    KEYWORD = "KEYWORD"
    OPERATOR = "OPERATOR"
    PUNCTUATION = "PUNCTUATION"
    WHITESPACE = "WHITESPACE"
    EOF = "EOF"

@dataclass
class Token:
    """词法单元"""
    type: TokenType
    value: str
    line: int
    column: int
    
    def __str__(self) -> str:
        return f"Token({self.type.value}, '{self.value}', line={self.line}, col={self.column})"

class ASTNode(ABC):
    """抽象语法树节点基类"""
    
    @abstractmethod
    def accept(self, visitor: 'ASTVisitor') -> Any:
        pass

@dataclass
class BinaryOp(ASTNode):
    """二元操作节点"""
    operator: str
    left: ASTNode
    right: ASTNode
    
    def accept(self, visitor: 'ASTVisitor') -> Any:
        return visitor.visit_binary_op(self)

@dataclass
class UnaryOp(ASTNode):
    """一元操作节点"""
    operator: str
    operand: ASTNode
    
    def accept(self, visitor: 'ASTVisitor') -> Any:
        return visitor.visit_unary_op(self)

@dataclass
class Literal(ASTNode):
    """字面量节点"""
    value: Any
    type: str
    
    def accept(self, visitor: 'ASTVisitor') -> Any:
        return visitor.visit_literal(self)

@dataclass
class Variable(ASTNode):
    """变量节点"""
    name: str
    
    def accept(self, visitor: 'ASTVisitor') -> Any:
        return visitor.visit_variable(self)

@dataclass
class FunctionCall(ASTNode):
    """函数调用节点"""
    name: str
    arguments: List[ASTNode]
    
    def accept(self, visitor: 'ASTVisitor') -> Any:
        return visitor.visit_function_call(self)

class ASTVisitor(ABC):
    """访问者模式基类"""
    
    @abstractmethod
    def visit_binary_op(self, node: BinaryOp) -> Any:
        pass
    
    @abstractmethod
    def visit_unary_op(self, node: UnaryOp) -> Any:
        pass
    
    @abstractmethod
    def visit_literal(self, node: Literal) -> Any:
        pass
    
    @abstractmethod
    def visit_variable(self, node: Variable) -> Any:
        pass
    
    @abstractmethod
    def visit_function_call(self, node: FunctionCall) -> Any:
        pass

class Lexer:
    """词法分析器"""
    
    def __init__(self, source: str):
        self.source = source
        self.position = 0
        self.line = 1
        self.column = 1
        self.keywords = {'if', 'else', 'while', 'for', 'def', 'return', 'True', 'False', 'None'}
        self.operators = {'+', '-', '*', '/', '=', '==', '!=', '<', '>', '<=', '>='}
    
    def tokenize(self) -> List[Token]:
        """词法分析主函数"""
        tokens = []
        
        while self.position < len(self.source):
            char = self.source[self.position]
            
            if char.isspace():
                self._skip_whitespace()
            elif char.isalpha() or char == '_':
                tokens.append(self._read_identifier())
            elif char.isdigit():
                tokens.append(self._read_number())
            elif char == '"' or char == "'":
                tokens.append(self._read_string())
            elif char in self.operators or char in '()[]{},:;':
                tokens.append(self._read_operator_or_punctuation())
            else:
                raise SyntaxError(f"Unexpected character '{char}' at line {self.line}, column {self.column}")
        
        tokens.append(Token(TokenType.EOF, "", self.line, self.column))
        return tokens
    
    def _skip_whitespace(self):
        """跳过空白字符"""
        while (self.position < len(self.source) and 
               self.source[self.position].isspace()):
            if self.source[self.position] == '\n':
                self.line += 1
                self.column = 1
            else:
                self.column += 1
            self.position += 1
    
    def _read_identifier(self) -> Token:
        """读取标识符或关键字"""
        start = self.position
        while (self.position < len(self.source) and 
               (self.source[self.position].isalnum() or self.source[self.position] == '_')):
            self.position += 1
            self.column += 1
        
        value = self.source[start:self.position]
        token_type = TokenType.KEYWORD if value in self.keywords else TokenType.IDENTIFIER
        
        return Token(token_type, value, self.line, self.column - len(value))
    
    def _read_number(self) -> Token:
        """读取数字"""
        start = self.position
        while (self.position < len(self.source) and 
               (self.source[self.position].isdigit() or self.source[self.position] == '.')):
            self.position += 1
            self.column += 1
        
        value = self.source[start:self.position]
        return Token(TokenType.NUMBER, value, self.line, self.column - len(value))
    
    def _read_string(self) -> Token:
        """读取字符串"""
        quote = self.source[self.position]
        self.position += 1
        self.column += 1
        start = self.position
        
        while (self.position < len(self.source) and 
               self.source[self.position] != quote):
            if self.source[self.position] == '\n':
                self.line += 1
                self.column = 1
            else:
                self.column += 1
            self.position += 1
        
        if self.position >= len(self.source):
            raise SyntaxError(f"Unterminated string at line {self.line}, column {self.column}")
        
        value = self.source[start:self.position]
        self.position += 1
        self.column += 1
        
        return Token(TokenType.STRING, value, self.line, self.column - len(value) - 1)
    
    def _read_operator_or_punctuation(self) -> Token:
        """读取操作符或标点符号"""
        char = self.source[self.position]
        self.position += 1
        self.column += 1
        
        # 检查双字符操作符
        if (self.position < len(self.source) and 
            char + self.source[self.position] in self.operators):
            value = char + self.source[self.position]
            self.position += 1
            self.column += 1
        else:
            value = char
        
        token_type = TokenType.OPERATOR if value in self.operators else TokenType.PUNCTUATION
        return Token(token_type, value, self.line, self.column - len(value))

class Parser:
    """语法分析器"""
    
    def __init__(self, tokens: List[Token]):
        self.tokens = tokens
        self.position = 0
    
    def parse(self) -> ASTNode:
        """语法分析主函数"""
        return self._parse_expression()
    
    def _parse_expression(self) -> ASTNode:
        """解析表达式"""
        left = self._parse_term()
        
        while (self.position < len(self.tokens) and 
               self.tokens[self.position].value in {'+', '-'}):
            operator = self.tokens[self.position].value
            self.position += 1
            right = self._parse_term()
            left = BinaryOp(operator, left, right)
        
        return left
    
    def _parse_term(self) -> ASTNode:
        """解析项"""
        left = self._parse_factor()
        
        while (self.position < len(self.tokens) and 
               self.tokens[self.position].value in {'*', '/'}):
            operator = self.tokens[self.position].value
            self.position += 1
            right = self._parse_factor()
            left = BinaryOp(operator, left, right)
        
        return left
    
    def _parse_factor(self) -> ASTNode:
        """解析因子"""
        if self.position >= len(self.tokens):
            raise SyntaxError("Unexpected end of input")
        
        token = self.tokens[self.position]
        
        if token.type == TokenType.NUMBER:
            self.position += 1
            return Literal(float(token.value), "number")
        elif token.type == TokenType.STRING:
            self.position += 1
            return Literal(token.value, "string")
        elif token.type == TokenType.IDENTIFIER:
            self.position += 1
            return Variable(token.value)
        elif token.value == '(':
            self.position += 1
            expr = self._parse_expression()
            if (self.position >= len(self.tokens) or 
                self.tokens[self.position].value != ')'):
                raise SyntaxError("Expected ')'")
            self.position += 1
            return expr
        else:
            raise SyntaxError(f"Unexpected token {token}")

class Interpreter(ASTVisitor):
    """解释器"""
    
    def __init__(self):
        self.variables = {}
    
    def visit_binary_op(self, node: BinaryOp) -> Any:
        left = node.left.accept(self)
        right = node.right.accept(self)
        
        if node.operator == '+':
            return left + right
        elif node.operator == '-':
            return left - right
        elif node.operator == '*':
            return left * right
        elif node.operator == '/':
            return left / right
        else:
            raise ValueError(f"Unknown operator: {node.operator}")
    
    def visit_unary_op(self, node: UnaryOp) -> Any:
        operand = node.operand.accept(self)
        
        if node.operator == '-':
            return -operand
        else:
            raise ValueError(f"Unknown operator: {node.operator}")
    
    def visit_literal(self, node: Literal) -> Any:
        return node.value
    
    def visit_variable(self, node: Variable) -> Any:
        if node.name not in self.variables:
            raise NameError(f"Variable '{node.name}' is not defined")
        return self.variables[node.name]
    
    def visit_function_call(self, node: FunctionCall) -> Any:
        # 简化实现，只支持内置函数
        if node.name == 'print':
            args = [arg.accept(self) for arg in node.arguments]
            print(*args)
            return None
        else:
            raise NameError(f"Function '{node.name}' is not defined")

# 使用示例
def demonstrate_language_design():
    """演示语言设计原理"""
    source = "2 + 3 * 4"
    
    # 词法分析
    lexer = Lexer(source)
    tokens = lexer.tokenize()
    print("Tokens:", tokens)
    
    # 语法分析
    parser = Parser(tokens)
    ast = parser.parse()
    print("AST:", ast)
    
    # 解释执行
    interpreter = Interpreter()
    result = ast.accept(interpreter)
    print("Result:", result)

if __name__ == "__main__":
    demonstrate_language_design()
```

## 2. 类型系统理论

### 2.1 类型系统基础

**定义2.1**: 类型系统是一个三元组 $\mathcal{T} = (T, \sqsubseteq, \vdash)$，其中：

- $T$ 是类型集合
- $\sqsubseteq$ 是子类型关系
- $\vdash$ 是类型推导关系

**定义2.2**: 类型推导规则 $\Gamma \vdash e : \tau$ 表示在类型环境 $\Gamma$ 下，表达式 $e$ 具有类型 $\tau$。

**定义2.3**: 类型安全性的形式化定义：

对于所有程序 $P$，如果 $\emptyset \vdash P : \tau$，则 $P$ 在执行时不会产生类型错误。

### 2.2 类型系统分类

**定理2.1**: 类型系统可以按以下维度分类：

1. **静态类型 vs 动态类型**
2. **强类型 vs 弱类型**  
3. **显式类型 vs 隐式类型**
4. **结构类型 vs 名义类型**

**定义2.4**: 多态性类型系统支持类型参数化，形式化为：

$\forall \alpha. \tau$ 表示对于所有类型 $\alpha$，表达式具有类型 $\tau[\alpha]$

### 2.3 Python实现：类型检查器

```python
from typing import Dict, List, Optional, Union, Any, TypeVar, Generic
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod

class Type(ABC):
    """类型基类"""
    
    @abstractmethod
    def is_subtype_of(self, other: 'Type') -> bool:
        pass
    
    @abstractmethod
    def unify_with(self, other: 'Type') -> Optional['Type']:
        pass

class BasicType(Type):
    """基本类型"""
    
    def __init__(self, name: str):
        self.name = name
    
    def is_subtype_of(self, other: Type) -> bool:
        if isinstance(other, BasicType):
            return self.name == other.name
        return False
    
    def unify_with(self, other: Type) -> Optional[Type]:
        if self.is_subtype_of(other):
            return self
        return None
    
    def __str__(self) -> str:
        return self.name

class FunctionType(Type):
    """函数类型"""
    
    def __init__(self, parameter_types: List[Type], return_type: Type):
        self.parameter_types = parameter_types
        self.return_type = return_type
    
    def is_subtype_of(self, other: Type) -> bool:
        if isinstance(other, FunctionType):
            if len(self.parameter_types) != len(other.parameter_types):
                return False
            
            # 参数类型是逆变的
            for param1, param2 in zip(self.parameter_types, other.parameter_types):
                if not param2.is_subtype_of(param1):
                    return False
            
            # 返回类型是协变的
            return self.return_type.is_subtype_of(other.return_type)
        return False
    
    def unify_with(self, other: Type) -> Optional[Type]:
        if isinstance(other, FunctionType):
            if len(self.parameter_types) != len(other.parameter_types):
                return None
            
            unified_params = []
            for param1, param2 in zip(self.parameter_types, other.parameter_types):
                unified_param = param1.unify_with(param2)
                if unified_param is None:
                    return None
                unified_params.append(unified_param)
            
            unified_return = self.return_type.unify_with(other.return_type)
            if unified_return is None:
                return None
            
            return FunctionType(unified_params, unified_return)
        return None
    
    def __str__(self) -> str:
        params_str = ", ".join(str(t) for t in self.parameter_types)
        return f"({params_str}) -> {self.return_type}"

class TypeVariable(Type):
    """类型变量"""
    
    def __init__(self, name: str):
        self.name = name
    
    def is_subtype_of(self, other: Type) -> bool:
        return True  # 类型变量是任何类型的子类型
    
    def unify_with(self, other: Type) -> Optional[Type]:
        return other  # 类型变量可以与任何类型统一
    
    def __str__(self) -> str:
        return self.name

class TypeEnvironment:
    """类型环境"""
    
    def __init__(self):
        self.bindings: Dict[str, Type] = {}
        self.parent: Optional[TypeEnvironment] = None
    
    def bind(self, name: str, type_: Type):
        """绑定变量到类型"""
        self.bindings[name] = type_
    
    def lookup(self, name: str) -> Optional[Type]:
        """查找变量类型"""
        if name in self.bindings:
            return self.bindings[name]
        elif self.parent:
            return self.parent.lookup(name)
        return None
    
    def extend(self) -> 'TypeEnvironment':
        """扩展类型环境"""
        new_env = TypeEnvironment()
        new_env.parent = self
        return new_env

class TypeChecker:
    """类型检查器"""
    
    def __init__(self):
        self.type_vars = {}  # 类型变量映射
    
    def check(self, ast: ASTNode, env: TypeEnvironment) -> Type:
        """类型检查主函数"""
        if isinstance(ast, Literal):
            return self._check_literal(ast)
        elif isinstance(ast, Variable):
            return self._check_variable(ast, env)
        elif isinstance(ast, BinaryOp):
            return self._check_binary_op(ast, env)
        elif isinstance(ast, UnaryOp):
            return self._check_unary_op(ast, env)
        elif isinstance(ast, FunctionCall):
            return self._check_function_call(ast, env)
        else:
            raise TypeError(f"Unknown AST node type: {type(ast)}")
    
    def _check_literal(self, ast: Literal) -> Type:
        """检查字面量类型"""
        if ast.type == "number":
            return BasicType("int")
        elif ast.type == "string":
            return BasicType("str")
        else:
            raise TypeError(f"Unknown literal type: {ast.type}")
    
    def _check_variable(self, ast: Variable, env: TypeEnvironment) -> Type:
        """检查变量类型"""
        type_ = env.lookup(ast.name)
        if type_ is None:
            raise TypeError(f"Undefined variable: {ast.name}")
        return type_
    
    def _check_binary_op(self, ast: BinaryOp, env: TypeEnvironment) -> Type:
        """检查二元操作类型"""
        left_type = self.check(ast.left, env)
        right_type = self.check(ast.right, env)
        
        # 类型统一
        unified_type = left_type.unify_with(right_type)
        if unified_type is None:
            raise TypeError(f"Cannot unify types {left_type} and {right_type}")
        
        # 检查操作符类型
        if ast.operator in {'+', '-', '*', '/'}:
            if not isinstance(unified_type, BasicType) or unified_type.name not in {'int', 'float'}:
                raise TypeError(f"Operator {ast.operator} requires numeric types")
            return unified_type
        else:
            raise TypeError(f"Unknown operator: {ast.operator}")
    
    def _check_unary_op(self, ast: UnaryOp, env: TypeEnvironment) -> Type:
        """检查一元操作类型"""
        operand_type = self.check(ast.operand, env)
        
        if ast.operator == '-':
            if not isinstance(operand_type, BasicType) or operand_type.name not in {'int', 'float'}:
                raise TypeError("Unary minus requires numeric type")
            return operand_type
        else:
            raise TypeError(f"Unknown operator: {ast.operator}")
    
    def _check_function_call(self, ast: FunctionCall, env: TypeEnvironment) -> Type:
        """检查函数调用类型"""
        # 获取函数类型
        func_type = env.lookup(ast.name)
        if func_type is None:
            raise TypeError(f"Undefined function: {ast.name}")
        
        if not isinstance(func_type, FunctionType):
            raise TypeError(f"{ast.name} is not a function")
        
        # 检查参数类型
        if len(ast.arguments) != len(func_type.parameter_types):
            raise TypeError(f"Function {ast.name} expects {len(func_type.parameter_types)} arguments, got {len(ast.arguments)}")
        
        for arg, expected_type in zip(ast.arguments, func_type.parameter_types):
            arg_type = self.check(arg, env)
            if not arg_type.is_subtype_of(expected_type):
                raise TypeError(f"Argument type {arg_type} is not compatible with expected type {expected_type}")
        
        return func_type.return_type

# 使用示例
def demonstrate_type_system():
    """演示类型系统"""
    # 创建类型环境
    env = TypeEnvironment()
    env.bind("x", BasicType("int"))
    env.bind("y", BasicType("int"))
    
    # 创建AST
    ast = BinaryOp("+", Variable("x"), Variable("y"))
    
    # 类型检查
    checker = TypeChecker()
    try:
        result_type = checker.check(ast, env)
        print(f"Expression type: {result_type}")
    except TypeError as e:
        print(f"Type error: {e}")

if __name__ == "__main__":
    demonstrate_type_system()
```

## 3. 编译原理

### 3.1 编译过程的形式化定义

**定义3.1**: 编译器是一个函数 $C: \mathcal{L}_S \rightarrow \mathcal{L}_T$，将源语言 $\mathcal{L}_S$ 转换为目标语言 $\mathcal{L}_T$。

**定义3.2**: 编译过程可以分解为以下阶段：

1. **词法分析**: $L: \Sigma^* \rightarrow T^*$
2. **语法分析**: $P: T^* \rightarrow AST$
3. **语义分析**: $S: AST \rightarrow AST'$
4. **中间代码生成**: $I: AST' \rightarrow IR$
5. **代码优化**: $O: IR \rightarrow IR'$
6. **目标代码生成**: $G: IR' \rightarrow \mathcal{L}_T$

**定理3.1**: 编译器的正确性定义为：

对于所有程序 $p \in \mathcal{L}_S$，如果 $p$ 在源语言中的语义为 $s$，则 $C(p)$ 在目标语言中的语义应该等价于 $s$。

### 3.2 中间表示

**定义3.3**: 三地址码是一种中间表示，每条指令最多包含三个操作数：

$op \quad dest, \quad src1, \quad src2$

**定义3.4**: 静态单赋值（SSA）形式要求每个变量只被赋值一次：

$\phi(x_1, x_2, \ldots, x_n)$ 表示在控制流汇合点选择正确的值。

### 3.3 Python实现：简单编译器

```python
from typing import List, Dict, Optional, Any
from dataclasses import dataclass
from enum import Enum

class IRInstruction:
    """中间表示指令基类"""
    pass

@dataclass
class LoadConstant(IRInstruction):
    """加载常量指令"""
    dest: str
    value: Any
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.value}"

@dataclass
class BinaryOp(IRInstruction):
    """二元操作指令"""
    dest: str
    op: str
    src1: str
    src2: str
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.src1} {self.op} {self.src2}"

@dataclass
class UnaryOp(IRInstruction):
    """一元操作指令"""
    dest: str
    op: str
    src: str
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.op} {self.src}"

@dataclass
class Copy(IRInstruction):
    """复制指令"""
    dest: str
    src: str
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.src}"

class IRGenerator:
    """中间代码生成器"""
    
    def __init__(self):
        self.temp_counter = 0
        self.instructions: List[IRInstruction] = []
    
    def generate_temp(self) -> str:
        """生成临时变量名"""
        temp = f"t{self.temp_counter}"
        self.temp_counter += 1
        return temp
    
    def generate(self, ast: ASTNode) -> str:
        """生成中间代码"""
        if isinstance(ast, Literal):
            return self._generate_literal(ast)
        elif isinstance(ast, Variable):
            return ast.name
        elif isinstance(ast, BinaryOp):
            return self._generate_binary_op(ast)
        elif isinstance(ast, UnaryOp):
            return self._generate_unary_op(ast)
        else:
            raise ValueError(f"Unknown AST node type: {type(ast)}")
    
    def _generate_literal(self, ast: Literal) -> str:
        """生成字面量代码"""
        temp = self.generate_temp()
        self.instructions.append(LoadConstant(temp, ast.value))
        return temp
    
    def _generate_binary_op(self, ast: BinaryOp) -> str:
        """生成二元操作代码"""
        left_temp = self.generate(ast.left)
        right_temp = self.generate(ast.right)
        result_temp = self.generate_temp()
        
        self.instructions.append(BinaryOp(result_temp, ast.operator, left_temp, right_temp))
        return result_temp
    
    def _generate_unary_op(self, ast: UnaryOp) -> str:
        """生成一元操作代码"""
        operand_temp = self.generate(ast.operand)
        result_temp = self.generate_temp()
        
        self.instructions.append(UnaryOp(result_temp, ast.operator, operand_temp))
        return result_temp
    
    def get_instructions(self) -> List[IRInstruction]:
        """获取生成的指令列表"""
        return self.instructions.copy()

class CodeOptimizer:
    """代码优化器"""
    
    def __init__(self):
        self.optimizations = [
            self._constant_folding,
            self._dead_code_elimination,
            self._common_subexpression_elimination
        ]
    
    def optimize(self, instructions: List[IRInstruction]) -> List[IRInstruction]:
        """应用所有优化"""
        optimized = instructions.copy()
        
        for optimization in self.optimizations:
            optimized = optimization(optimized)
        
        return optimized
    
    def _constant_folding(self, instructions: List[IRInstruction]) -> List[IRInstruction]:
        """常量折叠优化"""
        optimized = []
        constants = {}  # 常量映射
        
        for instr in instructions:
            if isinstance(instr, LoadConstant):
                constants[instr.dest] = instr.value
                optimized.append(instr)
            elif isinstance(instr, BinaryOp):
                # 检查是否可以进行常量折叠
                if (instr.src1 in constants and instr.src2 in constants):
                    val1 = constants[instr.src1]
                    val2 = constants[instr.src2]
                    
                    if instr.op == '+':
                        result = val1 + val2
                    elif instr.op == '-':
                        result = val1 - val2
                    elif instr.op == '*':
                        result = val1 * val2
                    elif instr.op == '/':
                        result = val1 / val2
                    else:
                        optimized.append(instr)
                        continue
                    
                    constants[instr.dest] = result
                    optimized.append(LoadConstant(instr.dest, result))
                else:
                    optimized.append(instr)
            else:
                optimized.append(instr)
        
        return optimized
    
    def _dead_code_elimination(self, instructions: List[IRInstruction]) -> List[IRInstruction]:
        """死代码消除"""
        used_vars = set()
        
        # 从后向前扫描，找出被使用的变量
        for instr in reversed(instructions):
            if isinstance(instr, BinaryOp):
                used_vars.add(instr.src1)
                used_vars.add(instr.src2)
            elif isinstance(instr, UnaryOp):
                used_vars.add(instr.src)
            elif isinstance(instr, Copy):
                used_vars.add(instr.src)
        
        # 过滤掉未使用的指令
        optimized = []
        for instr in instructions:
            if isinstance(instr, LoadConstant):
                if instr.dest in used_vars:
                    optimized.append(instr)
            else:
                optimized.append(instr)
        
        return optimized
    
    def _common_subexpression_elimination(self, instructions: List[IRInstruction]) -> List[IRInstruction]:
        """公共子表达式消除"""
        expressions = {}  # 表达式到临时变量的映射
        optimized = []
        
        for instr in instructions:
            if isinstance(instr, BinaryOp):
                expr_key = (instr.op, instr.src1, instr.src2)
                if expr_key in expressions:
                    # 使用已有的临时变量
                    optimized.append(Copy(instr.dest, expressions[expr_key]))
                else:
                    # 记录新的表达式
                    expressions[expr_key] = instr.dest
                    optimized.append(instr)
            else:
                optimized.append(instr)
        
        return optimized

class SimpleCompiler:
    """简单编译器"""
    
    def __init__(self):
        self.lexer = Lexer("")
        self.parser = Parser([])
        self.ir_generator = IRGenerator()
        self.optimizer = CodeOptimizer()
    
    def compile(self, source: str) -> List[IRInstruction]:
        """编译源代码"""
        # 词法分析
        self.lexer = Lexer(source)
        tokens = self.lexer.tokenize()
        
        # 语法分析
        self.parser = Parser(tokens)
        ast = self.parser.parse()
        
        # 中间代码生成
        self.ir_generator = IRGenerator()
        self.ir_generator.generate(ast)
        instructions = self.ir_generator.get_instructions()
        
        # 代码优化
        optimized_instructions = self.optimizer.optimize(instructions)
        
        return optimized_instructions

# 使用示例
def demonstrate_compilation():
    """演示编译过程"""
    source = "2 + 3 * 4"
    
    compiler = SimpleCompiler()
    instructions = compiler.compile(source)
    
    print("Generated IR instructions:")
    for i, instr in enumerate(instructions):
        print(f"{i}: {instr}")

if __name__ == "__main__":
    demonstrate_compilation()
```

## 4. 运行时系统

### 4.1 运行时系统架构

**定义4.1**: 运行时系统是一个四元组 $\mathcal{R} = (M, E, G, H)$，其中：

- $M$ 是内存管理器
- $E$ 是执行引擎
- $G$ 是垃圾收集器
- $H$ 是异常处理器

**定义4.2**: 内存模型定义了程序如何访问和操作内存：

$\mathcal{M} = (A, V, \rightarrow)$ 其中 $A$ 是地址集合，$V$ 是值集合，$\rightarrow$ 是访问关系。

**定义4.3**: 垃圾收集的正确性条件：

对于所有可达对象 $o$，$o \in \text{Reachable}(G) \Rightarrow o \notin \text{Collected}(G)$

### 4.2 内存管理

**定理4.1**: 内存分配算法的复杂度：

- 首次适应算法：$O(n)$ 其中 $n$ 是空闲块数量
- 最佳适应算法：$O(n \log n)$
- 伙伴系统：$O(\log n)$

### 4.3 Python实现：简单运行时系统

```python
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass
from enum import Enum
import weakref

class ObjectType(Enum):
    """对象类型"""
    INTEGER = "INTEGER"
    STRING = "STRING"
    ARRAY = "ARRAY"
    OBJECT = "OBJECT"

@dataclass
class RuntimeObject:
    """运行时对象"""
    type: ObjectType
    value: Any
    size: int
    marked: bool = False
    
    def __str__(self) -> str:
        return f"{self.type.value}({self.value})"

class MemoryManager:
    """内存管理器"""
    
    def __init__(self, heap_size: int = 1024):
        self.heap_size = heap_size
        self.heap: List[Optional[RuntimeObject]] = [None] * heap_size
        self.free_list: List[int] = list(range(heap_size))
        self.allocated: Set[int] = set()
    
    def allocate(self, obj: RuntimeObject) -> int:
        """分配内存"""
        if not self.free_list:
            raise MemoryError("Out of memory")
        
        address = self.free_list.pop()
        self.heap[address] = obj
        self.allocated.add(address)
        return address
    
    def deallocate(self, address: int):
        """释放内存"""
        if address in self.allocated:
            self.heap[address] = None
            self.allocated.remove(address)
            self.free_list.append(address)
    
    def get_object(self, address: int) -> Optional[RuntimeObject]:
        """获取对象"""
        if 0 <= address < len(self.heap):
            return self.heap[address]
        return None
    
    def get_free_memory(self) -> int:
        """获取空闲内存大小"""
        return len(self.free_list)

class GarbageCollector:
    """垃圾收集器"""
    
    def __init__(self, memory_manager: MemoryManager):
        self.memory_manager = memory_manager
        self.roots: Set[int] = set()
    
    def add_root(self, address: int):
        """添加根对象"""
        self.roots.add(address)
    
    def remove_root(self, address: int):
        """移除根对象"""
        self.roots.discard(address)
    
    def mark_and_sweep(self):
        """标记-清除垃圾收集"""
        # 标记阶段
        self._mark_phase()
        
        # 清除阶段
        self._sweep_phase()
    
    def _mark_phase(self):
        """标记阶段"""
        # 重置所有标记
        for address in self.memory_manager.allocated:
            obj = self.memory_manager.get_object(address)
            if obj:
                obj.marked = False
        
        # 从根对象开始标记
        for root in self.roots:
            self._mark_object(root)
    
    def _mark_object(self, address: int):
        """标记对象及其可达对象"""
        obj = self.memory_manager.get_object(address)
        if obj is None or obj.marked:
            return
        
        obj.marked = True
        
        # 如果是数组或对象，标记其元素
        if obj.type == ObjectType.ARRAY:
            for element in obj.value:
                if isinstance(element, int) and element in self.memory_manager.allocated:
                    self._mark_object(element)
        elif obj.type == ObjectType.OBJECT:
            for value in obj.value.values():
                if isinstance(value, int) and value in self.memory_manager.allocated:
                    self._mark_object(value)
    
    def _sweep_phase(self):
        """清除阶段"""
        unmarked = []
        for address in self.memory_manager.allocated:
            obj = self.memory_manager.get_object(address)
            if obj and not obj.marked:
                unmarked.append(address)
        
        # 释放未标记的对象
        for address in unmarked:
            self.memory_manager.deallocate(address)

class ExecutionEngine:
    """执行引擎"""
    
    def __init__(self, memory_manager: MemoryManager):
        self.memory_manager = memory_manager
        self.gc = GarbageCollector(memory_manager)
        self.stack: List[int] = []
        self.variables: Dict[str, int] = {}
    
    def execute(self, instructions: List[IRInstruction]):
        """执行指令序列"""
        for instr in instructions:
            self._execute_instruction(instr)
    
    def _execute_instruction(self, instr: IRInstruction):
        """执行单条指令"""
        if isinstance(instr, LoadConstant):
            obj = RuntimeObject(ObjectType.INTEGER, instr.value, 1)
            address = self.memory_manager.allocate(obj)
            self.variables[instr.dest] = address
            self.gc.add_root(address)
        
        elif isinstance(instr, BinaryOp):
            src1_addr = self.variables[instr.src1]
            src2_addr = self.variables[instr.src2]
            
            obj1 = self.memory_manager.get_object(src1_addr)
            obj2 = self.memory_manager.get_object(src2_addr)
            
            if obj1 and obj2:
                if instr.op == '+':
                    result = obj1.value + obj2.value
                elif instr.op == '-':
                    result = obj1.value - obj2.value
                elif instr.op == '*':
                    result = obj1.value * obj2.value
                elif instr.op == '/':
                    result = obj1.value / obj2.value
                else:
                    raise ValueError(f"Unknown operator: {instr.op}")
                
                result_obj = RuntimeObject(ObjectType.INTEGER, result, 1)
                result_addr = self.memory_manager.allocate(result_obj)
                self.variables[instr.dest] = result_addr
                self.gc.add_root(result_addr)
        
        elif isinstance(instr, Copy):
            src_addr = self.variables[instr.src]
            self.variables[instr.dest] = src_addr
    
    def get_result(self, variable: str) -> Optional[Any]:
        """获取变量值"""
        if variable in self.variables:
            addr = self.variables[variable]
            obj = self.memory_manager.get_object(addr)
            return obj.value if obj else None
        return None

class RuntimeSystem:
    """运行时系统"""
    
    def __init__(self, heap_size: int = 1024):
        self.memory_manager = MemoryManager(heap_size)
        self.execution_engine = ExecutionEngine(self.memory_manager)
    
    def run(self, instructions: List[IRInstruction]) -> Dict[str, Any]:
        """运行程序"""
        # 执行指令
        self.execution_engine.execute(instructions)
        
        # 垃圾收集
        self.execution_engine.gc.mark_and_sweep()
        
        # 返回结果
        results = {}
        for var in self.execution_engine.variables:
            results[var] = self.execution_engine.get_result(var)
        
        return results

# 使用示例
def demonstrate_runtime_system():
    """演示运行时系统"""
    # 创建编译器
    compiler = SimpleCompiler()
    
    # 编译程序
    source = "2 + 3 * 4"
    instructions = compiler.compile(source)
    
    print("Compiled instructions:")
    for i, instr in enumerate(instructions):
        print(f"{i}: {instr}")
    
    # 创建运行时系统
    runtime = RuntimeSystem()
    
    # 运行程序
    results = runtime.run(instructions)
    
    print("\nExecution results:")
    for var, value in results.items():
        print(f"{var} = {value}")
    
    print(f"\nFree memory: {runtime.memory_manager.get_free_memory()}")

if __name__ == "__main__":
    demonstrate_runtime_system()
```

## 总结

本章系统性地介绍了编程语言理论的核心概念，包括：

1. **语言设计原理**: 形式化定义、设计原则、解析器实现
2. **类型系统理论**: 类型安全、类型推导、类型检查器
3. **编译原理**: 编译过程、中间表示、代码优化
4. **运行时系统**: 内存管理、垃圾收集、执行引擎

所有概念都通过严格的数学定义和完整的Python实现进行了阐述，为后续的软件工程实践提供了坚实的理论基础。 