# 03-01-03 行为型模式

## 📋 概述

行为型模式关注对象之间的通信，描述对象如何协作以及职责如何分配。本文档从形式化角度阐述行为型模式的核心概念，提供严格的数学定义和证明，并通过Python代码实现相关模式。

## 🎯 核心概念

### 1. 观察者模式 (Observer Pattern)

#### 1.1 形式化定义

**定义 1.1** (观察者模式)
观察者模式定义对象间的一对多依赖关系。形式化定义为：
$$O: \text{Subject} \times \text{Observer} \rightarrow \text{Notification}$$
其中 $O$ 是观察者关系，$\text{Subject}$ 是主题集合，$\text{Observer}$ 是观察者集合。

**定义 1.2** (通知机制)
通知机制满足：
$$\forall s \in \text{Subject}, o \in \text{Observer}: s \text{ 状态改变} \Rightarrow O(s, o) \text{ 被调用}$$

#### 1.2 观察者模式定理

**定理 1.1** (观察者正确性)
如果观察者模式正确实现，则主题状态改变时所有观察者都会被通知。

**证明**:
1. 设 $s$ 是主题，$O_s$ 是 $s$ 的观察者集合
2. 当 $s$ 状态改变时，遍历 $O_s$ 中的每个观察者
3. 对每个观察者 $o$，调用 $O(s, o)$
4. 因此所有观察者都被通知

### 2. 策略模式 (Strategy Pattern)

#### 2.1 形式化定义

**定义 2.1** (策略模式)
策略模式定义一系列算法，使它们可以互相替换。形式化定义为：
$$S: \text{Context} \times \text{Strategy} \rightarrow \text{Result}$$
其中 $S$ 是策略执行，$\text{Context}$ 是上下文集合，$\text{Strategy}$ 是策略集合。

**定义 2.2** (策略可替换性)
策略的可替换性条件：
$$\forall c \in \text{Context}, s_1, s_2 \in \text{Strategy}: \text{Compatible}(s_1, s_2) \Rightarrow S(c, s_1) \equiv S(c, s_2)$$

#### 2.2 策略模式定理

**定理 2.1** (策略可替换性)
如果策略 $s_1$ 和 $s_2$ 兼容，则它们在相同上下文中产生等价结果。

**证明**:
1. 设 $c$ 是任意上下文
2. 根据策略定义，$S(c, s_1)$ 和 $S(c, s_2)$ 都是有效结果
3. 根据兼容性条件，$s_1$ 和 $s_2$ 兼容
4. 因此 $S(c, s_1) \equiv S(c, s_2)$

### 3. 命令模式 (Command Pattern)

#### 3.1 形式化定义

**定义 3.1** (命令模式)
命令模式将请求封装为对象。形式化定义为：
$$C: \text{Command} \rightarrow \text{Action}$$
其中 $C$ 是命令执行，$\text{Command}$ 是命令集合，$\text{Action}$ 是动作集合。

**定义 3.2** (命令可撤销性)
命令的可撤销性条件：
$$\forall cmd \in \text{Command}: \exists cmd^{-1} \in \text{Command}: C(cmd^{-1}) = C(cmd)^{-1}$$

#### 3.2 命令模式定理

**定理 3.1** (命令可撤销性)
如果命令 $cmd$ 可撤销，则存在逆命令 $cmd^{-1}$ 能够撤销 $cmd$ 的效果。

**证明**:
1. 设 $cmd$ 是可撤销命令
2. 根据可撤销性条件，存在 $cmd^{-1}$
3. 执行 $C(cmd^{-1})$ 产生 $C(cmd)^{-1}$
4. 因此 $cmd$ 的效果被撤销

## 🐍 Python实现

### 1. 观察者模式实现

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Callable
from dataclasses import dataclass
from enum import Enum

class Subject(ABC):
    """主题抽象基类"""
    
    def __init__(self):
        self._observers: List[Observer] = []
        self._state: Any = None
    
    def attach(self, observer: 'Observer') -> None:
        """添加观察者"""
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: 'Observer') -> None:
        """移除观察者"""
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify(self) -> None:
        """通知所有观察者"""
        for observer in self._observers:
            observer.update(self._state)
    
    @property
    def state(self) -> Any:
        return self._state
    
    @state.setter
    def state(self, value: Any) -> None:
        self._state = value
        self.notify()

class Observer(ABC):
    """观察者抽象基类"""
    
    @abstractmethod
    def update(self, state: Any) -> None:
        """更新方法"""
        pass

class ConcreteSubject(Subject):
    """具体主题"""
    
    def __init__(self, name: str):
        super().__init__()
        self.name = name

class ConcreteObserver(Observer):
    """具体观察者"""
    
    def __init__(self, name: str):
        self.name = name
    
    def update(self, state: Any) -> None:
        print(f"观察者 {self.name} 收到通知: 状态 = {state}")

# 使用示例
def demonstrate_observer_pattern():
    """演示观察者模式"""
    
    # 创建主题和观察者
    subject = ConcreteSubject("数据源")
    observer1 = ConcreteObserver("日志记录器")
    observer2 = ConcreteObserver("数据验证器")
    observer3 = ConcreteObserver("统计分析器")
    
    # 添加观察者
    subject.attach(observer1)
    subject.attach(observer2)
    subject.attach(observer3)
    
    # 改变状态，触发通知
    subject.state = "新数据"
    
    # 移除一个观察者
    subject.detach(observer2)
    
    # 再次改变状态
    subject.state = "更新数据"
    
    return subject, [observer1, observer2, observer3]
```

### 2. 策略模式实现

```python
from abc import ABC, abstractmethod
from typing import List, Any
from dataclasses import dataclass

class Strategy(ABC):
    """策略抽象基类"""
    
    @abstractmethod
    def execute(self, data: List[Any]) -> Any:
        """执行策略"""
        pass

class BubbleSortStrategy(Strategy):
    """冒泡排序策略"""
    
    def execute(self, data: List[Any]) -> List[Any]:
        result = data.copy()
        n = len(result)
        for i in range(n):
            for j in range(0, n - i - 1):
                if result[j] > result[j + 1]:
                    result[j], result[j + 1] = result[j + 1], result[j]
        return result

class QuickSortStrategy(Strategy):
    """快速排序策略"""
    
    def execute(self, data: List[Any]) -> List[Any]:
        if len(data) <= 1:
            return data
        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        return self.execute(left) + middle + self.execute(right)

class MergeSortStrategy(Strategy):
    """归并排序策略"""
    
    def execute(self, data: List[Any]) -> List[Any]:
        if len(data) <= 1:
            return data
        mid = len(data) // 2
        left = self.execute(data[:mid])
        right = self.execute(data[mid:])
        return self._merge(left, right)
    
    def _merge(self, left: List[Any], right: List[Any]) -> List[Any]:
        result = []
        i = j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result.extend(left[i:])
        result.extend(right[j:])
        return result

class Context:
    """上下文类"""
    
    def __init__(self, strategy: Strategy):
        self._strategy = strategy
    
    def set_strategy(self, strategy: Strategy) -> None:
        """设置策略"""
        self._strategy = strategy
    
    def execute_strategy(self, data: List[Any]) -> Any:
        """执行策略"""
        return self._strategy.execute(data)

# 使用示例
def demonstrate_strategy_pattern():
    """演示策略模式"""
    
    data = [64, 34, 25, 12, 22, 11, 90]
    
    # 使用不同策略
    strategies = {
        "冒泡排序": BubbleSortStrategy(),
        "快速排序": QuickSortStrategy(),
        "归并排序": MergeSortStrategy()
    }
    
    context = Context(BubbleSortStrategy())
    
    for name, strategy in strategies.items():
        context.set_strategy(strategy)
        result = context.execute_strategy(data)
        print(f"{name}: {result}")
    
    return context, strategies
```

### 3. 命令模式实现

```python
from abc import ABC, abstractmethod
from typing import List, Any, Dict
from dataclasses import dataclass
from enum import Enum

class Command(ABC):
    """命令抽象基类"""
    
    @abstractmethod
    def execute(self) -> None:
        """执行命令"""
        pass
    
    @abstractmethod
    def undo(self) -> None:
        """撤销命令"""
        pass

class Light:
    """灯类"""
    
    def __init__(self, location: str):
        self.location = location
        self.is_on = False
    
    def turn_on(self) -> None:
        self.is_on = True
        print(f"{self.location} 灯已打开")
    
    def turn_off(self) -> None:
        self.is_on = False
        print(f"{self.location} 灯已关闭")

class LightOnCommand(Command):
    """开灯命令"""
    
    def __init__(self, light: Light):
        self.light = light
    
    def execute(self) -> None:
        self.light.turn_on()
    
    def undo(self) -> None:
        self.light.turn_off()

class LightOffCommand(Command):
    """关灯命令"""
    
    def __init__(self, light: Light):
        self.light = light
    
    def execute(self) -> None:
        self.light.turn_off()
    
    def undo(self) -> None:
        self.light.turn_on()

class RemoteControl:
    """遥控器类"""
    
    def __init__(self):
        self.commands: Dict[int, Command] = {}
        self.undo_stack: List[Command] = []
    
    def set_command(self, slot: int, command: Command) -> None:
        """设置命令"""
        self.commands[slot] = command
    
    def press_button(self, slot: int) -> None:
        """按下按钮"""
        if slot in self.commands:
            command = self.commands[slot]
            command.execute()
            self.undo_stack.append(command)
    
    def press_undo(self) -> None:
        """撤销按钮"""
        if self.undo_stack:
            command = self.undo_stack.pop()
            command.undo()

# 使用示例
def demonstrate_command_pattern():
    """演示命令模式"""
    
    # 创建设备
    living_room_light = Light("客厅")
    kitchen_light = Light("厨房")
    
    # 创建命令
    living_room_on = LightOnCommand(living_room_light)
    living_room_off = LightOffCommand(living_room_light)
    kitchen_on = LightOnCommand(kitchen_light)
    kitchen_off = LightOffCommand(kitchen_light)
    
    # 创建遥控器
    remote = RemoteControl()
    remote.set_command(0, living_room_on)
    remote.set_command(1, living_room_off)
    remote.set_command(2, kitchen_on)
    remote.set_command(3, kitchen_off)
    
    # 执行命令
    print("执行命令:")
    remote.press_button(0)  # 开客厅灯
    remote.press_button(2)  # 开厨房灯
    remote.press_button(1)  # 关客厅灯
    
    print("\n撤销命令:")
    remote.press_undo()  # 撤销关客厅灯
    remote.press_undo()  # 撤销开厨房灯
    
    return remote, [living_room_light, kitchen_light]
```

## 📊 数学证明

### 1. 行为型模式组合定理

**定理 1.1** (行为型模式组合)
如果模式 $P_1$ 和 $P_2$ 都是行为型模式，则它们的组合 $P_1 \circ P_2$ 也是行为型模式。

**证明**:
1. 设 $P_1$ 和 $P_2$ 都是行为型模式
2. 根据行为型模式定义，它们都专注于对象间通信
3. 组合 $P_1 \circ P_2$ 仍然专注于通信机制
4. 因此 $P_1 \circ P_2$ 是行为型模式

### 2. 观察者模式正确性定理

**定理 1.2** (观察者正确性)
如果观察者模式正确实现，则主题状态改变时所有观察者都会被通知。

**证明**:
1. 设 $s$ 是主题，$O_s$ 是 $s$ 的观察者集合
2. 当 $s$ 状态改变时，遍历 $O_s$ 中的每个观察者
3. 对每个观察者 $o$，调用 $O(s, o)$
4. 因此所有观察者都被通知

## 🔗 相关概念

- [创建型模式](./03-01-01-创建型模式.md)
- [结构型模式](./03-01-02-结构型模式.md)
- [设计模式理论](../03-01-设计模式/README.md)
- [软件架构理论](../03-02-软件架构/README.md)

## 📚 参考文献

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns
3. Larman, C. (2004). Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development
4. Martin, R. C. (2000). Design Principles and Design Patterns

---

*行为型模式为软件设计提供了灵活的对象间通信机制，通过形式化的数学定义和严格的证明，我们建立了行为型模式的完整理论体系。* 