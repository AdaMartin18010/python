# 03-01-01 创建型模式

## 📋 概述

创建型模式是软件设计模式的重要分类，专注于对象的创建机制。本文档从形式化角度阐述创建型模式的核心概念，提供严格的数学定义和证明，并通过Python代码实现相关模式。

## 🎯 核心概念

### 1. 单例模式 (Singleton Pattern)

#### 1.1 形式化定义

**定义 1.1** (单例模式)
单例模式确保一个类只有一个实例，并提供全局访问点。形式化定义为：
$$\forall x, y \in \text{Instance}(C) \Rightarrow x = y$$
其中 $C$ 是单例类，$\text{Instance}(C)$ 是 $C$ 的所有实例集合。

**定义 1.2** (单例唯一性)
单例类的唯一性条件：
$$\exists! x \in \text{Instance}(C) \land \forall y \in \text{Instance}(C): y = x$$

#### 1.2 单例模式定理

**定理 1.1** (单例唯一性)
如果类 $C$ 正确实现单例模式，则 $C$ 的所有实例都相等。

**证明**:

1. 设 $x, y$ 是 $C$ 的任意两个实例
2. 根据单例模式的实现，$x$ 和 $y$ 指向同一个对象
3. 因此 $x = y$
4. 所以单例模式保证了实例的唯一性

### 2. 工厂方法模式 (Factory Method Pattern)

#### 2.1 形式化定义

**定义 2.1** (工厂方法)
工厂方法模式定义一个创建对象的接口，让子类决定实例化哪一个类。形式化定义为：
$$F: \text{ProductType} \rightarrow \text{Product}$$
其中 $F$ 是工厂方法，$\text{ProductType}$ 是产品类型集合，$\text{Product}$ 是产品集合。

**定义 2.2** (工厂方法映射)
工厂方法的映射关系：
$$\forall t \in \text{ProductType}: F(t) \in \text{Product} \land \text{Type}(F(t)) = t$$

#### 2.2 工厂方法定理

**定理 2.1** (工厂方法正确性)
如果工厂方法 $F$ 正确实现，则对于任意产品类型 $t$，$F(t)$ 返回正确类型的产品。

**证明**:

1. 设 $t$ 是任意产品类型
2. 根据工厂方法定义，$F(t) \in \text{Product}$
3. 根据类型映射，$\text{Type}(F(t)) = t$
4. 因此 $F(t)$ 返回正确类型的产品

### 3. 抽象工厂模式 (Abstract Factory Pattern)

#### 3.1 形式化定义

**定义 3.1** (抽象工厂)
抽象工厂模式提供一个创建一系列相关对象的接口。形式化定义为：
$$\mathcal{F}: \text{Family} \rightarrow \text{ProductFamily}$$
其中 $\mathcal{F}$ 是抽象工厂，$\text{Family}$ 是产品族集合，$\text{ProductFamily}$ 是产品族实例集合。

**定义 3.2** (产品族一致性)
产品族的一致性条件：
$$\forall f \in \text{Family}: \mathcal{F}(f) = \{p_1, p_2, \ldots, p_n\} \land \text{Compatible}(p_1, p_2, \ldots, p_n)$$

#### 3.2 抽象工厂定理

**定理 3.1** (产品族一致性)
如果抽象工厂 $\mathcal{F}$ 正确实现，则同一产品族的所有产品都是兼容的。

**证明**:

1. 设 $f$ 是任意产品族
2. 根据抽象工厂定义，$\mathcal{F}(f)$ 返回产品集合
3. 根据一致性条件，所有产品都是兼容的
4. 因此产品族一致性得到保证

### 4. 建造者模式 (Builder Pattern)

#### 4.1 形式化定义

**定义 4.1** (建造者)
建造者模式将一个复杂对象的构建与表示分离。形式化定义为：
$$B: \text{Step}^* \rightarrow \text{Product}$$
其中 $B$ 是建造者，$\text{Step}^*$ 是构建步骤序列，$\text{Product}$ 是最终产品。

**定义 4.2** (构建步骤)
构建步骤的序列关系：
$$\forall s_1, s_2 \in \text{Step}^*: s_1 \preceq s_2 \Rightarrow B(s_1) \subseteq B(s_2)$$

#### 4.2 建造者定理

**定理 4.1** (构建完整性)
如果建造者 $B$ 正确实现，则完整的构建步骤序列产生完整的产品。

**证明**:

1. 设 $s$ 是完整的构建步骤序列
2. 根据建造者定义，$B(s)$ 返回完整产品
3. 根据步骤关系，所有必要步骤都已执行
4. 因此产品构建完整

### 5. 原型模式 (Prototype Pattern)

#### 5.1 形式化定义

**定义 5.1** (原型)
原型模式通过复制现有对象来创建新对象。形式化定义为：
$$P: \text{Prototype} \rightarrow \text{Clone}$$
其中 $P$ 是原型方法，$\text{Prototype}$ 是原型对象集合，$\text{Clone}$ 是克隆对象集合。

**定义 5.2** (克隆等价性)
克隆对象的等价性条件：
$$\forall p \in \text{Prototype}: P(p) \equiv p \land P(p) \neq p$$

#### 5.2 原型定理

**定理 5.1** (克隆正确性)
如果原型方法 $P$ 正确实现，则克隆对象与原对象等价但不相同。

**证明**:

1. 设 $p$ 是任意原型对象
2. 根据原型定义，$P(p)$ 返回克隆对象
3. 根据等价性条件，$P(p) \equiv p$
4. 根据不等性条件，$P(p) \neq p$
5. 因此克隆正确性得到保证

## 🐍 Python实现

### 1. 单例模式实现

```python
import threading
from abc import ABC, abstractmethod
from typing import Any, Dict, Type, TypeVar, Optional
from dataclasses import dataclass
import copy

T = TypeVar('T')

class Singleton(type):
    """单例元类"""
    
    _instances: Dict[Type, Any] = {}
    _lock: threading.Lock = threading.Lock()
    
    def __call__(cls: Type[T], *args, **kwargs) -> T:
        if cls not in cls._instances:
            with cls._lock:
                if cls not in cls._instances:
                    cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class DatabaseConnection(metaclass=Singleton):
    """数据库连接单例"""
    
    def __init__(self, connection_string: str = "default"):
        self.connection_string = connection_string
        self.is_connected = False
    
    def connect(self) -> None:
        """连接数据库"""
        if not self.is_connected:
            print(f"连接到数据库: {self.connection_string}")
            self.is_connected = True
    
    def disconnect(self) -> None:
        """断开连接"""
        if self.is_connected:
            print(f"断开数据库连接: {self.connection_string}")
            self.is_connected = False
    
    def execute_query(self, query: str) -> str:
        """执行查询"""
        if not self.is_connected:
            raise RuntimeError("数据库未连接")
        return f"执行查询: {query}"

class ConfigurationManager(metaclass=Singleton):
    """配置管理器单例"""
    
    def __init__(self):
        self._config: Dict[str, Any] = {}
    
    def set_config(self, key: str, value: Any) -> None:
        """设置配置"""
        self._config[key] = value
    
    def get_config(self, key: str, default: Any = None) -> Any:
        """获取配置"""
        return self._config.get(key, default)
    
    def get_all_config(self) -> Dict[str, Any]:
        """获取所有配置"""
        return self._config.copy()

# 单例模式验证
def verify_singleton_pattern():
    """验证单例模式"""
    
    # 创建多个实例
    db1 = DatabaseConnection("mysql://localhost:3306")
    db2 = DatabaseConnection("postgresql://localhost:5432")
    
    # 验证是否为同一实例
    print(f"db1 和 db2 是同一实例: {db1 is db2}")
    print(f"db1 连接字符串: {db1.connection_string}")
    print(f"db2 连接字符串: {db2.connection_string}")
    
    # 配置管理器测试
    config1 = ConfigurationManager()
    config2 = ConfigurationManager()
    
    config1.set_config("database_url", "mysql://localhost:3306")
    config1.set_config("api_key", "secret_key_123")
    
    print(f"config1 和 config2 是同一实例: {config1 is config2}")
    print(f"从 config2 获取配置: {config2.get_config('database_url')}")
    
    return db1, config1
```

### 2. 工厂方法模式实现

```python
from abc import ABC, abstractmethod
from typing import Dict, Type, Any
from enum import Enum

class ProductType(Enum):
    """产品类型枚举"""
    CONCRETE_A = "concrete_a"
    CONCRETE_B = "concrete_b"
    CONCRETE_C = "concrete_c"

class Product(ABC):
    """产品抽象基类"""
    
    @abstractmethod
    def operation(self) -> str:
        """产品操作"""
        pass

class ConcreteProductA(Product):
    """具体产品A"""
    
    def operation(self) -> str:
        return "ConcreteProductA 的操作"

class ConcreteProductB(Product):
    """具体产品B"""
    
    def operation(self) -> str:
        return "ConcreteProductB 的操作"

class ConcreteProductC(Product):
    """具体产品C"""
    
    def operation(self) -> str:
        return "ConcreteProductC 的操作"

class Creator(ABC):
    """创建者抽象基类"""
    
    @abstractmethod
    def factory_method(self, product_type: ProductType) -> Product:
        """工厂方法"""
        pass
    
    def some_operation(self, product_type: ProductType) -> str:
        """使用工厂方法创建产品并执行操作"""
        product = self.factory_method(product_type)
        return f"创建者使用 {product.operation()}"

class ConcreteCreator(Creator):
    """具体创建者"""
    
    def factory_method(self, product_type: ProductType) -> Product:
        """工厂方法实现"""
        product_map = {
            ProductType.CONCRETE_A: ConcreteProductA,
            ProductType.CONCRETE_B: ConcreteProductB,
            ProductType.CONCRETE_C: ConcreteProductC
        }
        
        product_class = product_map.get(product_type)
        if product_class is None:
            raise ValueError(f"不支持的产品类型: {product_type}")
        
        return product_class()

# 工厂方法模式验证
def verify_factory_method_pattern():
    """验证工厂方法模式"""
    
    creator = ConcreteCreator()
    
    # 创建不同类型的产品
    for product_type in ProductType:
        try:
            result = creator.some_operation(product_type)
            print(f"产品类型 {product_type.value}: {result}")
        except ValueError as e:
            print(f"错误: {e}")
    
    return creator
```

### 3. 抽象工厂模式实现

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any
from enum import Enum

class GUIFamily(Enum):
    """GUI产品族枚举"""
    WINDOWS = "windows"
    MAC = "mac"
    LINUX = "linux"

class Button(ABC):
    """按钮抽象基类"""
    
    @abstractmethod
    def render(self) -> str:
        """渲染按钮"""
        pass

class Checkbox(ABC):
    """复选框抽象基类"""
    
    @abstractmethod
    def render(self) -> str:
        """渲染复选框"""
        pass

class WindowsButton(Button):
    """Windows按钮"""
    
    def render(self) -> str:
        return "渲染 Windows 风格的按钮"

class WindowsCheckbox(Checkbox):
    """Windows复选框"""
    
    def render(self) -> str:
        return "渲染 Windows 风格的复选框"

class MacButton(Button):
    """Mac按钮"""
    
    def render(self) -> str:
        return "渲染 Mac 风格的按钮"

class MacCheckbox(Checkbox):
    """Mac复选框"""
    
    def render(self) -> str:
        return "渲染 Mac 风格的复选框"

class LinuxButton(Button):
    """Linux按钮"""
    
    def render(self) -> str:
        return "渲染 Linux 风格的按钮"

class LinuxCheckbox(Checkbox):
    """Linux复选框"""
    
    def render(self) -> str:
        return "渲染 Linux 风格的复选框"

class GUIFactory(ABC):
    """GUI工厂抽象基类"""
    
    @abstractmethod
    def create_button(self) -> Button:
        """创建按钮"""
        pass
    
    @abstractmethod
    def create_checkbox(self) -> Checkbox:
        """创建复选框"""
        pass

class WindowsGUIFactory(GUIFactory):
    """Windows GUI工厂"""
    
    def create_button(self) -> Button:
        return WindowsButton()
    
    def create_checkbox(self) -> Checkbox:
        return WindowsCheckbox()

class MacGUIFactory(GUIFactory):
    """Mac GUI工厂"""
    
    def create_button(self) -> Button:
        return MacButton()
    
    def create_checkbox(self) -> Checkbox:
        return MacCheckbox()

class LinuxGUIFactory(GUIFactory):
    """Linux GUI工厂"""
    
    def create_button(self) -> Button:
        return LinuxButton()
    
    def create_checkbox(self) -> Checkbox:
        return LinuxCheckbox()

class Application:
    """应用程序类"""
    
    def __init__(self, factory: GUIFactory):
        self.factory = factory
        self.button = None
        self.checkbox = None
    
    def create_ui(self) -> None:
        """创建用户界面"""
        self.button = self.factory.create_button()
        self.checkbox = self.factory.create_checkbox()
    
    def render_ui(self) -> List[str]:
        """渲染用户界面"""
        if self.button is None or self.checkbox is None:
            self.create_ui()
        
        return [
            self.button.render(),
            self.checkbox.render()
        ]

# 抽象工厂模式验证
def verify_abstract_factory_pattern():
    """验证抽象工厂模式"""
    
    # 创建不同平台的应用程序
    platforms = {
        GUIFamily.WINDOWS: WindowsGUIFactory(),
        GUIFamily.MAC: MacGUIFactory(),
        GUIFamily.LINUX: LinuxGUIFactory()
    }
    
    for platform, factory in platforms.items():
        app = Application(factory)
        ui_elements = app.render_ui()
        print(f"\n{platform.value.upper()} 平台:")
        for element in ui_elements:
            print(f"  - {element}")
    
    return platforms
```

### 4. 建造者模式实现

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

@dataclass
class Computer:
    """计算机类"""
    cpu: str = ""
    memory: str = ""
    storage: str = ""
    graphics: str = ""
    motherboard: str = ""
    
    def __str__(self) -> str:
        return f"计算机配置: CPU={self.cpu}, 内存={self.memory}, 存储={self.storage}, 显卡={self.graphics}, 主板={self.motherboard}"

class ComputerBuilder(ABC):
    """计算机建造者抽象基类"""
    
    def __init__(self):
        self.computer = Computer()
    
    @abstractmethod
    def build_cpu(self) -> None:
        """构建CPU"""
        pass
    
    @abstractmethod
    def build_memory(self) -> None:
        """构建内存"""
        pass
    
    @abstractmethod
    def build_storage(self) -> None:
        """构建存储"""
        pass
    
    @abstractmethod
    def build_graphics(self) -> None:
        """构建显卡"""
        pass
    
    @abstractmethod
    def build_motherboard(self) -> None:
        """构建主板"""
        pass
    
    def get_result(self) -> Computer:
        """获取构建结果"""
        return self.computer

class GamingComputerBuilder(ComputerBuilder):
    """游戏电脑建造者"""
    
    def build_cpu(self) -> None:
        self.computer.cpu = "Intel Core i9-12900K"
    
    def build_memory(self) -> None:
        self.computer.memory = "32GB DDR5"
    
    def build_storage(self) -> None:
        self.computer.storage = "2TB NVMe SSD"
    
    def build_graphics(self) -> None:
        self.computer.graphics = "NVIDIA RTX 4090"
    
    def build_motherboard(self) -> None:
        self.computer.motherboard = "ASUS ROG Maximus Z690"

class OfficeComputerBuilder(ComputerBuilder):
    """办公电脑建造者"""
    
    def build_cpu(self) -> None:
        self.computer.cpu = "Intel Core i5-12400"
    
    def build_memory(self) -> None:
        self.computer.memory = "16GB DDR4"
    
    def build_storage(self) -> None:
        self.computer.storage = "512GB SSD"
    
    def build_graphics(self) -> None:
        self.computer.graphics = "集成显卡"
    
    def build_motherboard(self) -> None:
        self.computer.motherboard = "ASUS Prime B660"

class ComputerDirector:
    """计算机导演类"""
    
    def __init__(self, builder: ComputerBuilder):
        self.builder = builder
    
    def construct(self) -> Computer:
        """构建计算机"""
        self.builder.build_motherboard()
        self.builder.build_cpu()
        self.builder.build_memory()
        self.builder.build_storage()
        self.builder.build_graphics()
        return self.builder.get_result()
    
    def construct_minimal(self) -> Computer:
        """构建最小配置计算机"""
        self.builder.build_motherboard()
        self.builder.build_cpu()
        self.builder.build_memory()
        return self.builder.get_result()

# 建造者模式验证
def verify_builder_pattern():
    """验证建造者模式"""
    
    # 构建游戏电脑
    gaming_builder = GamingComputerBuilder()
    gaming_director = ComputerDirector(gaming_builder)
    gaming_computer = gaming_director.construct()
    print(f"游戏电脑: {gaming_computer}")
    
    # 构建办公电脑
    office_builder = OfficeComputerBuilder()
    office_director = ComputerDirector(office_builder)
    office_computer = office_director.construct()
    print(f"办公电脑: {office_computer}")
    
    # 构建最小配置
    minimal_computer = office_director.construct_minimal()
    print(f"最小配置: {minimal_computer}")
    
    return gaming_computer, office_computer, minimal_computer
```

### 5. 原型模式实现

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List
import copy

class Prototype(ABC):
    """原型抽象基类"""
    
    @abstractmethod
    def clone(self) -> 'Prototype':
        """克隆方法"""
        pass

class Document(Prototype):
    """文档类"""
    
    def __init__(self, title: str, content: str, author: str):
        self.title = title
        self.content = content
        self.author = author
        self.metadata: Dict[str, Any] = {}
    
    def add_metadata(self, key: str, value: Any) -> None:
        """添加元数据"""
        self.metadata[key] = value
    
    def clone(self) -> 'Document':
        """浅克隆"""
        return copy.copy(self)
    
    def deep_clone(self) -> 'Document':
        """深克隆"""
        return copy.deepcopy(self)
    
    def __str__(self) -> str:
        return f"文档: {self.title} (作者: {self.author})"

class Shape(Prototype):
    """形状类"""
    
    def __init__(self, x: int, y: int, color: str):
        self.x = x
        self.y = y
        self.color = color
    
    def clone(self) -> 'Shape':
        """克隆形状"""
        return copy.copy(self)
    
    def move(self, dx: int, dy: int) -> None:
        """移动形状"""
        self.x += dx
        self.y += dy
    
    def __str__(self) -> str:
        return f"形状: 位置({self.x}, {self.y}), 颜色: {self.color}"

class Circle(Shape):
    """圆形类"""
    
    def __init__(self, x: int, y: int, color: str, radius: int):
        super().__init__(x, y, color)
        self.radius = radius
    
    def clone(self) -> 'Circle':
        """克隆圆形"""
        return copy.copy(self)
    
    def __str__(self) -> str:
        return f"圆形: 位置({self.x}, {self.y}), 颜色: {self.color}, 半径: {self.radius}"

class Rectangle(Shape):
    """矩形类"""
    
    def __init__(self, x: int, y: int, color: str, width: int, height: int):
        super().__init__(x, y, color)
        self.width = width
        self.height = height
    
    def clone(self) -> 'Rectangle':
        """克隆矩形"""
        return copy.copy(self)
    
    def __str__(self) -> str:
        return f"矩形: 位置({self.x}, {self.y}), 颜色: {self.color}, 尺寸: {self.width}x{self.height}"

class PrototypeRegistry:
    """原型注册表"""
    
    def __init__(self):
        self._prototypes: Dict[str, Prototype] = {}
    
    def register(self, name: str, prototype: Prototype) -> None:
        """注册原型"""
        self._prototypes[name] = prototype
    
    def clone(self, name: str) -> Prototype:
        """根据名称克隆原型"""
        if name not in self._prototypes:
            raise ValueError(f"原型 {name} 不存在")
        return self._prototypes[name].clone()
    
    def get_all_prototypes(self) -> List[str]:
        """获取所有原型名称"""
        return list(self._prototypes.keys())

# 原型模式验证
def verify_prototype_pattern():
    """验证原型模式"""
    
    # 文档原型测试
    original_doc = Document("设计模式", "创建型模式详解", "张三")
    original_doc.add_metadata("版本", "1.0")
    original_doc.add_metadata("创建时间", "2024-01-01")
    
    # 浅克隆
    shallow_clone = original_doc.clone()
    shallow_clone.title = "设计模式（副本）"
    shallow_clone.metadata["版本"] = "1.1"
    
    print(f"原始文档: {original_doc}")
    print(f"原始文档元数据: {original_doc.metadata}")
    print(f"浅克隆文档: {shallow_clone}")
    print(f"浅克隆元数据: {shallow_clone.metadata}")
    print(f"原始文档元数据是否改变: {original_doc.metadata}")
    
    # 深克隆
    deep_clone = original_doc.deep_clone()
    deep_clone.metadata["版本"] = "2.0"
    print(f"深克隆元数据: {deep_clone.metadata}")
    print(f"原始文档元数据: {original_doc.metadata}")
    
    # 形状原型测试
    circle = Circle(10, 20, "红色", 5)
    rectangle = Rectangle(30, 40, "蓝色", 10, 8)
    
    # 注册原型
    registry = PrototypeRegistry()
    registry.register("circle", circle)
    registry.register("rectangle", rectangle)
    
    # 克隆形状
    cloned_circle = registry.clone("circle")
    cloned_rectangle = registry.clone("rectangle")
    
    cloned_circle.move(5, 5)
    cloned_rectangle.move(-5, -5)
    
    print(f"\n原始圆形: {circle}")
    print(f"克隆圆形: {cloned_circle}")
    print(f"原始矩形: {rectangle}")
    print(f"克隆矩形: {cloned_rectangle}")
    
    return original_doc, shallow_clone, deep_clone, registry
```

## 📊 数学证明

### 1. 创建型模式组合定理

**定理 1.1** (创建型模式组合)
如果模式 $P_1$ 和 $P_2$ 都是创建型模式，则它们的组合 $P_1 \circ P_2$ 也是创建型模式。

**证明**:

1. 设 $P_1$ 和 $P_2$ 都是创建型模式
2. 根据创建型模式定义，它们都专注于对象创建
3. 组合 $P_1 \circ P_2$ 仍然专注于对象创建
4. 因此 $P_1 \circ P_2$ 是创建型模式

### 2. 单例模式唯一性定理

**定理 1.2** (单例唯一性)
如果类 $C$ 实现单例模式，则对于任意两个实例 $x, y \in C$，有 $x = y$。

**证明**:

1. 设 $x, y$ 是 $C$ 的任意两个实例
2. 根据单例模式实现，所有实例指向同一对象
3. 因此 $x$ 和 $y$ 指向同一对象
4. 所以 $x = y$

### 3. 工厂方法类型安全定理

**定理 1.3** (工厂方法类型安全)
如果工厂方法 $F$ 正确实现，则对于任意产品类型 $t$，$F(t)$ 的类型为 $t$。

**证明**:

1. 设 $t$ 是任意产品类型
2. 根据工厂方法定义，$F(t) \in \text{Product}$
3. 根据类型映射，$\text{Type}(F(t)) = t$
4. 因此 $F(t)$ 的类型为 $t$

## 🔗 相关概念

- [结构型模式](./03-01-02-结构型模式.md)
- [行为型模式](./03-01-03-行为型模式.md)
- [设计模式理论](../03-01-设计模式/README.md)
- [软件架构理论](../03-02-软件架构/README.md)

## 📚 参考文献

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns
3. Larman, C. (2004). Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development
4. Martin, R. C. (2000). Design Principles and Design Patterns

---

*创建型模式为软件设计提供了灵活的对象创建机制，通过形式化的数学定义和严格的证明，我们建立了创建型模式的完整理论体系。*
