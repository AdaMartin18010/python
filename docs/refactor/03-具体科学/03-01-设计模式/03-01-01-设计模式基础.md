# è®¾è®¡æ¨¡å¼åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

è®¾è®¡æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­è§£å†³å¸¸è§è®¾è®¡é—®é¢˜çš„æ ‡å‡†è§£å†³æ–¹æ¡ˆã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ¢è®¨è®¾è®¡æ¨¡å¼çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå»ºç«‹ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¾è®¡æ¨¡å¼çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 åŸºæœ¬å®šä¹‰

è®¾è®¡æ¨¡å¼å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$\mathcal{P} = (N, C, S, F, E)$$

å…¶ä¸­ï¼š
- $N$ æ˜¯åç§°é›†åˆ (Name Set)
- $C$ æ˜¯ä¸Šä¸‹æ–‡é›†åˆ (Context Set)
- $S$ æ˜¯è§£å†³æ–¹æ¡ˆé›†åˆ (Solution Set)
- $F$ æ˜¯å½¢å¼åŒ–æè¿° (Formal Description)
- $E$ æ˜¯æ•ˆæœé›†åˆ (Effect Set)

#### 1.2 è®¾è®¡æ¨¡å¼åˆ†ç±»

è®¾è®¡æ¨¡å¼æŒ‰ç›®çš„åˆ†ä¸ºä¸‰ç±»ï¼š

1. **åˆ›å»ºå‹æ¨¡å¼**: å¤„ç†å¯¹è±¡åˆ›å»ºæœºåˆ¶
2. **ç»“æ„å‹æ¨¡å¼**: å¤„ç†ç±»å’Œå¯¹è±¡çš„ç»„åˆ
3. **è¡Œä¸ºå‹æ¨¡å¼**: å¤„ç†å¯¹è±¡é—´çš„é€šä¿¡

## ğŸ”§ Python å®ç°

### 1. è®¾è®¡æ¨¡å¼åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Type, Union
from dataclasses import dataclass, field
from enum import Enum
import json

class PatternType(Enum):
    """è®¾è®¡æ¨¡å¼ç±»å‹æšä¸¾"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"

class PatternCategory(Enum):
    """è®¾è®¡æ¨¡å¼åˆ†ç±»æšä¸¾"""
    GOF = "gang_of_four"
    ENTERPRISE = "enterprise"
    CONCURRENCY = "concurrency"
    ARCHITECTURAL = "architectural"

@dataclass
class PatternSpecification:
    """è®¾è®¡æ¨¡å¼è§„æ ¼è¯´æ˜"""
    name: str
    pattern_type: PatternType
    category: PatternCategory
    description: str
    problem: str
    solution: str
    consequences: List[str]
    participants: List[str]
    collaborations: List[str]
    
    def __post_init__(self):
        """éªŒè¯æ¨¡å¼è§„æ ¼"""
        if not self.name or not self.description:
            raise ValueError("æ¨¡å¼åç§°å’Œæè¿°ä¸èƒ½ä¸ºç©º")

@dataclass
class PatternImplementation:
    """è®¾è®¡æ¨¡å¼å®ç°"""
    specification: PatternSpecification
    code_example: str
    use_cases: List[str]
    advantages: List[str]
    disadvantages: List[str]
    alternatives: List[str]

class DesignPattern(ABC):
    """è®¾è®¡æ¨¡å¼æŠ½è±¡åŸºç±»"""
    
    def __init__(self, specification: PatternSpecification):
        self.specification = specification
        self.implementation: Optional[PatternImplementation] = None
        self.usage_examples: List[Dict[str, Any]] = []
    
    @abstractmethod
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """åº”ç”¨è®¾è®¡æ¨¡å¼"""
        pass
    
    @abstractmethod
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """æ¼”ç¤ºè®¾è®¡æ¨¡å¼"""
        pass
    
    def add_usage_example(self, example: Dict[str, Any]):
        """æ·»åŠ ä½¿ç”¨ç¤ºä¾‹"""
        self.usage_examples.append(example)
    
    def get_pattern_info(self) -> Dict[str, Any]:
        """è·å–æ¨¡å¼ä¿¡æ¯"""
        return {
            "name": self.specification.name,
            "type": self.specification.pattern_type.value,
            "category": self.specification.category.value,
            "description": self.specification.description,
            "problem": self.specification.problem,
            "solution": self.specification.solution,
            "consequences": self.specification.consequences,
            "participants": self.specification.participants,
            "collaborations": self.specification.collaborations
        }

class CreationalPattern(DesignPattern):
    """åˆ›å»ºå‹æ¨¡å¼åŸºç±»"""
    
    def __init__(self, specification: PatternSpecification):
        super().__init__(specification)
        if specification.pattern_type != PatternType.CREATIONAL:
            raise ValueError("åˆ›å»ºå‹æ¨¡å¼ç±»å‹ä¸åŒ¹é…")

class StructuralPattern(DesignPattern):
    """ç»“æ„å‹æ¨¡å¼åŸºç±»"""
    
    def __init__(self, specification: PatternSpecification):
        super().__init__(specification)
        if specification.pattern_type != PatternType.STRUCTURAL:
            raise ValueError("ç»“æ„å‹æ¨¡å¼ç±»å‹ä¸åŒ¹é…")

class BehavioralPattern(DesignPattern):
    """è¡Œä¸ºå‹æ¨¡å¼åŸºç±»"""
    
    def __init__(self, specification: PatternSpecification):
        super().__init__(specification)
        if specification.pattern_type != PatternType.BEHAVIORAL:
            raise ValueError("è¡Œä¸ºå‹æ¨¡å¼ç±»å‹ä¸åŒ¹é…")

# å…·ä½“è®¾è®¡æ¨¡å¼å®ç°

class SingletonPattern(CreationalPattern):
    """å•ä¾‹æ¨¡å¼"""
    
    def __init__(self):
        specification = PatternSpecification(
            name="å•ä¾‹æ¨¡å¼",
            pattern_type=PatternType.CREATIONAL,
            category=PatternCategory.GOF,
            description="ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹",
            problem="å¦‚ä½•ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Ÿ",
            solution="å°†æ„é€ å‡½æ•°è®¾ä¸ºç§æœ‰ï¼Œæä¾›é™æ€æ–¹æ³•è·å–å®ä¾‹",
            consequences=[
                "ä¿è¯ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹",
                "æä¾›å…¨å±€è®¿é—®ç‚¹",
                "å¯èƒ½è¿åå•ä¸€èŒè´£åŸåˆ™"
            ],
            participants=["Singleton"],
            collaborations=["å®¢æˆ·ç«¯é€šè¿‡getInstance()è®¿é—®å•ä¾‹"]
        )
        super().__init__(specification)
    
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """åº”ç”¨å•ä¾‹æ¨¡å¼"""
        class_name = context.get("class_name", "MyClass")
        
        singleton_code = f"""
class {class_name}:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
            # åˆå§‹åŒ–ä»£ç 
"""
        return singleton_code
    
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """æ¼”ç¤ºå•ä¾‹æ¨¡å¼"""
        class DatabaseConnection:
            _instance = None
            
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                return cls._instance
            
            def __init__(self):
                if not hasattr(self, '_initialized'):
                    self._initialized = True
                    self.connection_string = "database://localhost:5432"
                    print("æ•°æ®åº“è¿æ¥å·²åˆ›å»º")
            
            def connect(self):
                return f"è¿æ¥åˆ°: {self.connection_string}"
        
        # æ¼”ç¤ºå•ä¾‹è¡Œä¸º
        db1 = DatabaseConnection()
        db2 = DatabaseConnection()
        
        return {
            "pattern": "å•ä¾‹æ¨¡å¼",
            "demonstration": {
                "instance1_id": id(db1),
                "instance2_id": id(db2),
                "are_same_instance": db1 is db2,
                "connection1": db1.connect(),
                "connection2": db2.connect()
            }
        }

class FactoryPattern(CreationalPattern):
    """å·¥å‚æ¨¡å¼"""
    
    def __init__(self):
        specification = PatternSpecification(
            name="å·¥å‚æ¨¡å¼",
            pattern_type=PatternType.CREATIONAL,
            category=PatternCategory.GOF,
            description="å®šä¹‰ä¸€ä¸ªåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œè®©å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»",
            problem="å¦‚ä½•åˆ›å»ºå¯¹è±¡è€Œä¸æš´éœ²åˆ›å»ºé€»è¾‘ï¼Ÿ",
            solution="ä½¿ç”¨å·¥å‚æ–¹æ³•å°è£…å¯¹è±¡åˆ›å»º",
            consequences=[
                "å°è£…å¯¹è±¡åˆ›å»ºé€»è¾‘",
                "æ”¯æŒå¼€é—­åŸåˆ™",
                "å¯èƒ½å¢åŠ ç±»çš„æ•°é‡"
            ],
            participants=["Product", "ConcreteProduct", "Creator", "ConcreteCreator"],
            collaborations=["Creatorè°ƒç”¨ConcreteCreatoråˆ›å»ºProduct"]
        )
        super().__init__(specification)
    
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """åº”ç”¨å·¥å‚æ¨¡å¼"""
        product_type = context.get("product_type", "Product")
        
        factory_code = f"""
from abc import ABC, abstractmethod

class {product_type}(ABC):
    @abstractmethod
    def operation(self):
        pass

class Concrete{product_type}({product_type}):
    def operation(self):
        return "å…·ä½“äº§å“æ“ä½œ"

class Creator(ABC):
    @abstractmethod
    def factory_method(self) -> {product_type}:
        pass
    
    def some_operation(self):
        product = self.factory_method()
        return product.operation()

class ConcreteCreator(Creator):
    def factory_method(self) -> {product_type}:
        return Concrete{product_type}()
"""
        return factory_code
    
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """æ¼”ç¤ºå·¥å‚æ¨¡å¼"""
        from abc import ABC, abstractmethod
        
        class Vehicle(ABC):
            @abstractmethod
            def drive(self):
                pass
        
        class Car(Vehicle):
            def drive(self):
                return "é©¾é©¶æ±½è½¦"
        
        class Motorcycle(Vehicle):
            def drive(self):
                return "é©¾é©¶æ‘©æ‰˜è½¦"
        
        class VehicleFactory(ABC):
            @abstractmethod
            def create_vehicle(self) -> Vehicle:
                pass
        
        class CarFactory(VehicleFactory):
            def create_vehicle(self) -> Vehicle:
                return Car()
        
        class MotorcycleFactory(VehicleFactory):
            def create_vehicle(self) -> Vehicle:
                return Motorcycle()
        
        # æ¼”ç¤ºå·¥å‚æ¨¡å¼
        car_factory = CarFactory()
        motorcycle_factory = MotorcycleFactory()
        
        car = car_factory.create_vehicle()
        motorcycle = motorcycle_factory.create_vehicle()
        
        return {
            "pattern": "å·¥å‚æ¨¡å¼",
            "demonstration": {
                "car_drive": car.drive(),
                "motorcycle_drive": motorcycle.drive(),
                "car_type": type(car).__name__,
                "motorcycle_type": type(motorcycle).__name__
            }
        }

class ObserverPattern(BehavioralPattern):
    """è§‚å¯Ÿè€…æ¨¡å¼"""
    
    def __init__(self):
        specification = PatternSpecification(
            name="è§‚å¯Ÿè€…æ¨¡å¼",
            pattern_type=PatternType.BEHAVIORAL,
            category=PatternCategory.GOF,
            description="å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çŠ¶æ€æ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–è€…éƒ½å¾—åˆ°é€šçŸ¥",
            problem="å¦‚ä½•å®ç°å¯¹è±¡é—´çš„æ¾è€¦åˆé€šä¿¡ï¼Ÿ",
            solution="ä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼å»ºç«‹å‘å¸ƒ-è®¢é˜…å…³ç³»",
            consequences=[
                "æ”¯æŒå¹¿æ’­é€šä¿¡",
                "æ¾è€¦åˆè®¾è®¡",
                "å¯èƒ½äº§ç”Ÿæ„å¤–çš„æ›´æ–°"
            ],
            participants=["Subject", "Observer", "ConcreteSubject", "ConcreteObserver"],
            collaborations=["Subjecté€šçŸ¥ObserverçŠ¶æ€å˜åŒ–"]
        )
        super().__init__(specification)
    
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """åº”ç”¨è§‚å¯Ÿè€…æ¨¡å¼"""
        observer_code = """
from abc import ABC, abstractmethod
from typing import List

class Observer(ABC):
    @abstractmethod
    def update(self, subject):
        pass

class Subject(ABC):
    def __init__(self):
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer):
        self._observers.append(observer)
    
    def detach(self, observer: Observer):
        self._observers.remove(observer)
    
    def notify(self):
        for observer in self._observers:
            observer.update(self)

class ConcreteSubject(Subject):
    def __init__(self):
        super().__init__()
        self._state = None
    
    @property
    def state(self):
        return self._state
    
    @state.setter
    def state(self, value):
        self._state = value
        self.notify()

class ConcreteObserver(Observer):
    def __init__(self, name: str):
        self.name = name
    
    def update(self, subject):
        print(f"{self.name} æ”¶åˆ°æ›´æ–°: {subject.state}")
"""
        return observer_code
    
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """æ¼”ç¤ºè§‚å¯Ÿè€…æ¨¡å¼"""
        from abc import ABC, abstractmethod
        from typing import List
        
        class Observer(ABC):
            @abstractmethod
            def update(self, subject):
                pass
        
        class Subject(ABC):
            def __init__(self):
                self._observers: List[Observer] = []
            
            def attach(self, observer: Observer):
                self._observers.append(observer)
            
            def detach(self, observer: Observer):
                self._observers.remove(observer)
            
            def notify(self):
                for observer in self._observers:
                    observer.update(self)
        
        class WeatherStation(Subject):
            def __init__(self):
                super().__init__()
                self._temperature = 0
            
            @property
            def temperature(self):
                return self._temperature
            
            @temperature.setter
            def temperature(self, value):
                self._temperature = value
                self.notify()
        
        class WeatherDisplay(Observer):
            def __init__(self, name: str):
                self.name = name
            
            def update(self, subject):
                print(f"{self.name}: æ¸©åº¦æ›´æ–°ä¸º {subject.temperature}Â°C")
        
        # æ¼”ç¤ºè§‚å¯Ÿè€…æ¨¡å¼
        weather_station = WeatherStation()
        display1 = WeatherDisplay("å®¢å…æ˜¾ç¤ºå™¨")
        display2 = WeatherDisplay("å§å®¤æ˜¾ç¤ºå™¨")
        
        weather_station.attach(display1)
        weather_station.attach(display2)
        
        weather_station.temperature = 25
        weather_station.temperature = 30
        
        return {
            "pattern": "è§‚å¯Ÿè€…æ¨¡å¼",
            "demonstration": {
                "observers_count": len(weather_station._observers),
                "current_temperature": weather_station.temperature
            }
        }

class DesignPatternCatalog:
    """è®¾è®¡æ¨¡å¼ç›®å½•"""
    
    def __init__(self):
        self.patterns: Dict[str, DesignPattern] = {}
        self.pattern_categories: Dict[PatternCategory, List[str]] = {
            PatternCategory.GOF: [],
            PatternCategory.ENTERPRISE: [],
            PatternCategory.CONCURRENCY: [],
            PatternCategory.ARCHITECTURAL: []
        }
    
    def add_pattern(self, pattern: DesignPattern):
        """æ·»åŠ è®¾è®¡æ¨¡å¼"""
        self.patterns[pattern.specification.name] = pattern
        category = pattern.specification.category
        self.pattern_categories[category].append(pattern.specification.name)
    
    def get_pattern(self, name: str) -> Optional[DesignPattern]:
        """è·å–è®¾è®¡æ¨¡å¼"""
        return self.patterns.get(name)
    
    def get_patterns_by_type(self, pattern_type: PatternType) -> List[DesignPattern]:
        """æŒ‰ç±»å‹è·å–è®¾è®¡æ¨¡å¼"""
        return [
            pattern for pattern in self.patterns.values()
            if pattern.specification.pattern_type == pattern_type
        ]
    
    def get_patterns_by_category(self, category: PatternCategory) -> List[DesignPattern]:
        """æŒ‰åˆ†ç±»è·å–è®¾è®¡æ¨¡å¼"""
        return [
            pattern for pattern in self.patterns.values()
            if pattern.specification.category == category
        ]
    
    def search_patterns(self, keyword: str) -> List[DesignPattern]:
        """æœç´¢è®¾è®¡æ¨¡å¼"""
        results = []
        keyword_lower = keyword.lower()
        
        for pattern in self.patterns.values():
            if (keyword_lower in pattern.specification.name.lower() or
                keyword_lower in pattern.specification.description.lower() or
                keyword_lower in pattern.specification.problem.lower()):
                results.append(pattern)
        
        return results
    
    def generate_pattern_report(self) -> Dict[str, Any]:
        """ç”Ÿæˆæ¨¡å¼æŠ¥å‘Š"""
        report = {
            "total_patterns": len(self.patterns),
            "patterns_by_type": {},
            "patterns_by_category": {},
            "pattern_details": {}
        }
        
        # æŒ‰ç±»å‹ç»Ÿè®¡
        for pattern_type in PatternType:
            patterns = self.get_patterns_by_type(pattern_type)
            report["patterns_by_type"][pattern_type.value] = {
                "count": len(patterns),
                "patterns": [p.specification.name for p in patterns]
            }
        
        # æŒ‰åˆ†ç±»ç»Ÿè®¡
        for category in PatternCategory:
            patterns = self.get_patterns_by_category(category)
            report["patterns_by_category"][category.value] = {
                "count": len(patterns),
                "patterns": [p.specification.name for p in patterns]
            }
        
        # è¯¦ç»†æ¨¡å¼ä¿¡æ¯
        for name, pattern in self.patterns.items():
            report["pattern_details"][name] = pattern.get_pattern_info()
        
        return report
    
    def demonstrate_patterns(self, pattern_names: List[str]) -> Dict[str, Any]:
        """æ¼”ç¤ºå¤šä¸ªè®¾è®¡æ¨¡å¼"""
        demonstrations = {}
        
        for name in pattern_names:
            pattern = self.get_pattern(name)
            if pattern:
                demonstrations[name] = pattern.demonstrate_pattern()
        
        return demonstrations

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_design_patterns():
    """æ¼”ç¤ºè®¾è®¡æ¨¡å¼"""
    
    # åˆ›å»ºè®¾è®¡æ¨¡å¼ç›®å½•
    catalog = DesignPatternCatalog()
    
    # æ·»åŠ è®¾è®¡æ¨¡å¼
    singleton = SingletonPattern()
    factory = FactoryPattern()
    observer = ObserverPattern()
    
    catalog.add_pattern(singleton)
    catalog.add_pattern(factory)
    catalog.add_pattern(observer)
    
    # ç”Ÿæˆæ¨¡å¼æŠ¥å‘Š
    report = catalog.generate_pattern_report()
    
    print("=== è®¾è®¡æ¨¡å¼ç›®å½•æŠ¥å‘Š ===")
    print(f"æ€»æ¨¡å¼æ•°: {report['total_patterns']}")
    
    print("\n=== æŒ‰ç±»å‹åˆ†ç±» ===")
    for type_name, type_info in report["patterns_by_type"].items():
        print(f"{type_name}: {type_info['count']} ä¸ªæ¨¡å¼")
        print(f"  æ¨¡å¼åˆ—è¡¨: {type_info['patterns']}")
    
    print("\n=== æŒ‰åˆ†ç±»åˆ†ç±» ===")
    for category_name, category_info in report["patterns_by_category"].items():
        print(f"{category_name}: {category_info['count']} ä¸ªæ¨¡å¼")
        print(f"  æ¨¡å¼åˆ—è¡¨: {category_info['patterns']}")
    
    # æ¼”ç¤ºè®¾è®¡æ¨¡å¼
    demonstrations = catalog.demonstrate_patterns(["å•ä¾‹æ¨¡å¼", "å·¥å‚æ¨¡å¼", "è§‚å¯Ÿè€…æ¨¡å¼"])
    
    print("\n=== è®¾è®¡æ¨¡å¼æ¼”ç¤º ===")
    for pattern_name, demo in demonstrations.items():
        print(f"\n{pattern_name}:")
        for key, value in demo["demonstration"].items():
            print(f"  {key}: {value}")
    
    # æœç´¢æ¨¡å¼
    search_results = catalog.search_patterns("åˆ›å»º")
    print(f"\n=== æœç´¢ 'åˆ›å»º' çš„ç»“æœ ===")
    for pattern in search_results:
        print(f"- {pattern.specification.name}: {pattern.specification.description}")
    
    return catalog

if __name__ == "__main__":
    # è¿è¡Œæ¼”ç¤º
    result = demonstrate_design_patterns()

## ğŸ“Š ç†è®ºè¯æ˜

### 1. è®¾è®¡æ¨¡å¼æœ‰æ•ˆæ€§å®šç†

**å®šç†**: å¦‚æœè®¾è®¡æ¨¡å¼ $P$ è§£å†³äº†é—®é¢˜ $Q$ï¼Œå¹¶ä¸”åœ¨ä¸Šä¸‹æ–‡ $C$ ä¸­åº”ç”¨ï¼Œåˆ™ $P$ æ˜¯æœ‰æ•ˆçš„ã€‚

**è¯æ˜**:
1. è®¾ $P$ æ˜¯è®¾è®¡æ¨¡å¼ï¼Œ$Q$ æ˜¯é—®é¢˜ï¼Œ$C$ æ˜¯ä¸Šä¸‹æ–‡
2. å¦‚æœ $P$ åœ¨ $C$ ä¸­è§£å†³äº† $Q$ï¼Œåˆ™ $P$ æ»¡è¶³æœ‰æ•ˆæ€§æ¡ä»¶
3. è¿™å¯ä»¥é€šè¿‡å½¢å¼åŒ–éªŒè¯æˆ–å®é™…æµ‹è¯•æ¥è¯æ˜

### 2. è®¾è®¡æ¨¡å¼ç»„åˆå®šç†

**å®šç†**: å¤šä¸ªè®¾è®¡æ¨¡å¼å¯ä»¥ç»„åˆä½¿ç”¨ï¼Œå½¢æˆæ›´å¤æ‚çš„è§£å†³æ–¹æ¡ˆã€‚

**è¯æ˜**:
1. è®¾ $P_1, P_2, ..., P_n$ æ˜¯è®¾è®¡æ¨¡å¼
2. å¦‚æœ $P_i$ å’Œ $P_j$ å…¼å®¹ï¼Œåˆ™å¯ä»¥ç»„åˆ
3. ç»„åˆåçš„æ¨¡å¼ä»ç„¶æ»¡è¶³è®¾è®¡åŸåˆ™

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [è½¯ä»¶æ¶æ„ç†è®º](../03-02-è½¯ä»¶æ¶æ„/03-02-01-è½¯ä»¶æ¶æ„åŸºç¡€.md)
- [ç¼–ç¨‹èŒƒå¼ç†è®º](../03-03-ç¼–ç¨‹èŒƒå¼/03-03-01-ç¼–ç¨‹èŒƒå¼åŸºç¡€.md)
- [åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º](../03-04-åˆ†å¸ƒå¼ç³»ç»Ÿ/03-04-01-åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€.md)
- [ç®—æ³•ç†è®º](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md)

## ğŸ“ˆ åº”ç”¨å®ä¾‹

### 1. è®¾è®¡æ¨¡å¼åº”ç”¨åˆ†æ

```python
class DesignPatternAnalyzer:
    """è®¾è®¡æ¨¡å¼åˆ†æå™¨"""
    
    def __init__(self):
        self.analysis_results = {}
    
    def analyze_pattern_usage(self, pattern: DesignPattern, context: Dict[str, Any]) -> Dict[str, Any]:
        """åˆ†ææ¨¡å¼ä½¿ç”¨æƒ…å†µ"""
        analysis = {
            "pattern_name": pattern.specification.name,
            "context": context,
            "applicability": self._assess_applicability(pattern, context),
            "complexity": self._assess_complexity(pattern),
            "maintainability": self._assess_maintainability(pattern),
            "performance_impact": self._assess_performance_impact(pattern),
            "recommendations": []
        }
        
        # ç”Ÿæˆå»ºè®®
        if analysis["complexity"] > 0.7:
            analysis["recommendations"].append("è€ƒè™‘ä½¿ç”¨æ›´ç®€å•çš„æ¨¡å¼")
        
        if analysis["maintainability"] < 0.5:
            analysis["recommendations"].append("éœ€è¦æ”¹è¿›ä»£ç ç»“æ„")
        
        if analysis["performance_impact"] > 0.8:
            analysis["recommendations"].append("è€ƒè™‘æ€§èƒ½ä¼˜åŒ–")
        
        return analysis
    
    def _assess_applicability(self, pattern: DesignPattern, context: Dict[str, Any]) -> float:
        """è¯„ä¼°é€‚ç”¨æ€§"""
        # ç®€åŒ–çš„é€‚ç”¨æ€§è¯„ä¼°
        score = 0.0
        
        # æ£€æŸ¥é—®é¢˜åŒ¹é…åº¦
        if "problem" in context and context["problem"] in pattern.specification.problem:
            score += 0.3
        
        # æ£€æŸ¥ä¸Šä¸‹æ–‡åŒ¹é…åº¦
        if "context" in context and context["context"] in pattern.specification.description:
            score += 0.3
        
        # æ£€æŸ¥è§£å†³æ–¹æ¡ˆåŒ¹é…åº¦
        if "solution" in context and context["solution"] in pattern.specification.solution:
            score += 0.4
        
        return min(score, 1.0)
    
    def _assess_complexity(self, pattern: DesignPattern) -> float:
        """è¯„ä¼°å¤æ‚åº¦"""
        # åŸºäºå‚ä¸è€…æ•°é‡è¯„ä¼°å¤æ‚åº¦
        participants_count = len(pattern.specification.participants)
        return min(participants_count / 10.0, 1.0)
    
    def _assess_maintainability(self, pattern: DesignPattern) -> float:
        """è¯„ä¼°å¯ç»´æŠ¤æ€§"""
        # åŸºäºåæœè¯„ä¼°å¯ç»´æŠ¤æ€§
        positive_consequences = 0
        total_consequences = len(pattern.specification.consequences)
        
        for consequence in pattern.specification.consequences:
            if any(word in consequence.lower() for word in ["æ¾è€¦åˆ", "å¯æ‰©å±•", "å¯ç»´æŠ¤", "çµæ´»"]):
                positive_consequences += 1
        
        return positive_consequences / total_consequences if total_consequences > 0 else 0.5
    
    def _assess_performance_impact(self, pattern: DesignPattern) -> float:
        """è¯„ä¼°æ€§èƒ½å½±å“"""
        # åŸºäºæ¨¡å¼ç±»å‹è¯„ä¼°æ€§èƒ½å½±å“
        pattern_type = pattern.specification.pattern_type
        
        if pattern_type == PatternType.CREATIONAL:
            return 0.2  # åˆ›å»ºå‹æ¨¡å¼é€šå¸¸æ€§èƒ½å½±å“è¾ƒå°
        elif pattern_type == PatternType.STRUCTURAL:
            return 0.5  # ç»“æ„å‹æ¨¡å¼å¯èƒ½æœ‰ä¸­ç­‰æ€§èƒ½å½±å“
        else:  # BEHAVIORAL
            return 0.7  # è¡Œä¸ºå‹æ¨¡å¼å¯èƒ½æœ‰è¾ƒå¤§æ€§èƒ½å½±å“
    
    def compare_patterns(self, patterns: List[DesignPattern], context: Dict[str, Any]) -> Dict[str, Any]:
        """æ¯”è¾ƒå¤šä¸ªè®¾è®¡æ¨¡å¼"""
        comparison = {
            "context": context,
            "patterns": {},
            "recommendations": []
        }
        
        for pattern in patterns:
            analysis = self.analyze_pattern_usage(pattern, context)
            comparison["patterns"][pattern.specification.name] = analysis
        
        # ç”Ÿæˆæ¯”è¾ƒå»ºè®®
        best_pattern = max(
            comparison["patterns"].items(),
            key=lambda x: x[1]["applicability"]
        )
        
        comparison["recommendations"].append(f"æ¨èä½¿ç”¨ {best_pattern[0]} æ¨¡å¼")
        
        return comparison
    
    def generate_pattern_selection_guide(self, problem_description: str) -> Dict[str, Any]:
        """ç”Ÿæˆæ¨¡å¼é€‰æ‹©æŒ‡å—"""
        guide = {
            "problem": problem_description,
            "suggested_patterns": [],
            "selection_criteria": {},
            "decision_matrix": {}
        }
        
        # åŸºäºé—®é¢˜æè¿°æ¨èæ¨¡å¼
        problem_lower = problem_description.lower()
        
        if "åˆ›å»º" in problem_lower or "å®ä¾‹åŒ–" in problem_lower:
            guide["suggested_patterns"].extend(["å·¥å‚æ¨¡å¼", "å•ä¾‹æ¨¡å¼", "å»ºé€ è€…æ¨¡å¼"])
        
        if "ç»“æ„" in problem_lower or "ç»„åˆ" in problem_lower:
            guide["suggested_patterns"].extend(["é€‚é…å™¨æ¨¡å¼", "è£…é¥°å™¨æ¨¡å¼", "ä»£ç†æ¨¡å¼"])
        
        if "è¡Œä¸º" in problem_lower or "é€šä¿¡" in problem_lower:
            guide["suggested_patterns"].extend(["è§‚å¯Ÿè€…æ¨¡å¼", "ç­–ç•¥æ¨¡å¼", "å‘½ä»¤æ¨¡å¼"])
        
        # é€‰æ‹©æ ‡å‡†
        guide["selection_criteria"] = {
            "é€‚ç”¨æ€§": "æ¨¡å¼æ˜¯å¦é€‚åˆè§£å†³å½“å‰é—®é¢˜",
            "å¤æ‚åº¦": "æ¨¡å¼çš„å®ç°å¤æ‚åº¦",
            "å¯ç»´æŠ¤æ€§": "æ¨¡å¼çš„å¯ç»´æŠ¤æ€§",
            "æ€§èƒ½": "æ¨¡å¼å¯¹æ€§èƒ½çš„å½±å“"
        }
        
        return guide

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_pattern_analysis():
    """æ¼”ç¤ºè®¾è®¡æ¨¡å¼åˆ†æ"""
    
    # åˆ›å»ºåˆ†æå™¨
    analyzer = DesignPatternAnalyzer()
    
    # åˆ›å»ºè®¾è®¡æ¨¡å¼
    singleton = SingletonPattern()
    factory = FactoryPattern()
    observer = ObserverPattern()
    
    # åˆ†ææ¨¡å¼ä½¿ç”¨æƒ…å†µ
    context = {
        "problem": "éœ€è¦ç¡®ä¿æ•°æ®åº“è¿æ¥çš„å”¯ä¸€æ€§",
        "context": "æ•°æ®åº“è¿æ¥ç®¡ç†",
        "solution": "ä½¿ç”¨å•ä¾‹æ¨¡å¼ç®¡ç†è¿æ¥"
    }
    
    singleton_analysis = analyzer.analyze_pattern_usage(singleton, context)
    
    print("=== å•ä¾‹æ¨¡å¼åˆ†æ ===")
    print(f"é€‚ç”¨æ€§: {singleton_analysis['applicability']:.2f}")
    print(f"å¤æ‚åº¦: {singleton_analysis['complexity']:.2f}")
    print(f"å¯ç»´æŠ¤æ€§: {singleton_analysis['maintainability']:.2f}")
    print(f"æ€§èƒ½å½±å“: {singleton_analysis['performance_impact']:.2f}")
    print(f"å»ºè®®: {singleton_analysis['recommendations']}")
    
    # æ¯”è¾ƒå¤šä¸ªæ¨¡å¼
    patterns = [singleton, factory, observer]
    comparison = analyzer.compare_patterns(patterns, context)
    
    print("\n=== æ¨¡å¼æ¯”è¾ƒ ===")
    for pattern_name, analysis in comparison["patterns"].items():
        print(f"{pattern_name}: é€‚ç”¨æ€§ {analysis['applicability']:.2f}")
    
    print(f"æ¨è: {comparison['recommendations']}")
    
    # ç”Ÿæˆé€‰æ‹©æŒ‡å—
    problem = "éœ€è¦æ ¹æ®ç”¨æˆ·ç±»å‹åˆ›å»ºä¸åŒçš„ç”¨æˆ·ç•Œé¢"
    guide = analyzer.generate_pattern_selection_guide(problem)
    
    print(f"\n=== æ¨¡å¼é€‰æ‹©æŒ‡å— ===")
    print(f"é—®é¢˜: {guide['problem']}")
    print(f"å»ºè®®æ¨¡å¼: {guide['suggested_patterns']}")

if __name__ == "__main__":
    demonstrate_pattern_analysis()
```

### 2. è®¾è®¡æ¨¡å¼å®ç°ç”Ÿæˆå™¨

```python
class PatternCodeGenerator:
    """è®¾è®¡æ¨¡å¼ä»£ç ç”Ÿæˆå™¨"""
    
    def __init__(self):
        self.templates = {}
        self.generated_code = {}
    
    def generate_pattern_code(self, pattern: DesignPattern, customizations: Dict[str, Any]) -> str:
        """ç”Ÿæˆæ¨¡å¼ä»£ç """
        pattern_name = pattern.specification.name
        
        if pattern_name == "å•ä¾‹æ¨¡å¼":
            return self._generate_singleton_code(customizations)
        elif pattern_name == "å·¥å‚æ¨¡å¼":
            return self._generate_factory_code(customizations)
        elif pattern_name == "è§‚å¯Ÿè€…æ¨¡å¼":
            return self._generate_observer_code(customizations)
        else:
            return self._generate_generic_pattern_code(pattern, customizations)
    
    def _generate_singleton_code(self, customizations: Dict[str, Any]) -> str:
        """ç”Ÿæˆå•ä¾‹æ¨¡å¼ä»£ç """
        class_name = customizations.get("class_name", "MySingleton")
        attributes = customizations.get("attributes", {})
        
        code = f"""
class {class_name}:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
"""
        
        # æ·»åŠ å±æ€§
        for attr_name, attr_value in attributes.items():
            code += f"            self.{attr_name} = {repr(attr_value)}\n"
        
        code += f"""
    def get_instance(self):
        return self
    
    def __str__(self):
        return f"{class_name}()"
"""
        
        return code
    
    def _generate_factory_code(self, customizations: Dict[str, Any]) -> str:
        """ç”Ÿæˆå·¥å‚æ¨¡å¼ä»£ç """
        product_name = customizations.get("product_name", "Product")
        concrete_products = customizations.get("concrete_products", ["ConcreteProduct1", "ConcreteProduct2"])
        
        code = f"""
from abc import ABC, abstractmethod

class {product_name}(ABC):
    @abstractmethod
    def operation(self):
        pass
"""
        
        # ç”Ÿæˆå…·ä½“äº§å“ç±»
        for product in concrete_products:
            code += f"""

class {product}({product_name}):
    def operation(self):
        return f"{product} çš„æ“ä½œ"
"""
        
        code += f"""

class {product_name}Factory(ABC):
    @abstractmethod
    def create_product(self) -> {product_name}:
        pass

class ConcreteFactory({product_name}Factory):
    def __init__(self, product_type: str):
        self.product_type = product_type
    
    def create_product(self) -> {product_name}:
        if self.product_type == "{concrete_products[0]}":
            return {concrete_products[0]}()
        elif self.product_type == "{concrete_products[1]}":
            return {concrete_products[1]}()
        else:
            raise ValueError(f"æœªçŸ¥çš„äº§å“ç±»å‹: {{self.product_type}}")
"""
        
        return code
    
    def _generate_observer_code(self, customizations: Dict[str, Any]) -> str:
        """ç”Ÿæˆè§‚å¯Ÿè€…æ¨¡å¼ä»£ç """
        subject_name = customizations.get("subject_name", "Subject")
        observer_name = customizations.get("observer_name", "Observer")
        events = customizations.get("events", ["event1", "event2"])
        
        code = f"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class {observer_name}(ABC):
    @abstractmethod
    def update(self, subject, event: str, data: Any = None):
        pass

class {subject_name}(ABC):
    def __init__(self):
        self._observers: List[{observer_name}] = []
        self._state: Dict[str, Any] = {{}}
    
    def attach(self, observer: {observer_name}):
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: {observer_name}):
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify(self, event: str, data: Any = None):
        for observer in self._observers:
            observer.update(self, event, data)

class Concrete{subject_name}({subject_name}):
    def __init__(self):
        super().__init__()
"""
        
        # æ·»åŠ äº‹ä»¶å±æ€§
        for event in events:
            code += f"        self.{event} = None\n"
        
        code += f"""
    def set_state(self, event: str, value: Any):
        if hasattr(self, event):
            setattr(self, event, value)
            self.notify(event, value)

class Concrete{observer_name}({observer_name}):
    def __init__(self, name: str):
        self.name = name
    
    def update(self, subject, event: str, data: Any = None):
        print(f"{{self.name}} æ”¶åˆ°äº‹ä»¶ {{event}}: {{data}}")
"""
        
        return code
    
    def _generate_generic_pattern_code(self, pattern: DesignPattern, customizations: Dict[str, Any]) -> str:
        """ç”Ÿæˆé€šç”¨æ¨¡å¼ä»£ç """
        return f"""
# {pattern.specification.name} æ¨¡å¼å®ç°
# é—®é¢˜: {pattern.specification.problem}
# è§£å†³æ–¹æ¡ˆ: {pattern.specification.solution}

class {pattern.specification.name.replace('æ¨¡å¼', '')}:
    def __init__(self):
        pass
    
    def apply(self, context):
        # åœ¨è¿™é‡Œå®ç°å…·ä½“çš„æ¨¡å¼é€»è¾‘
        pass
"""

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_code_generation():
    """æ¼”ç¤ºä»£ç ç”Ÿæˆ"""
    
    # åˆ›å»ºä»£ç ç”Ÿæˆå™¨
    generator = PatternCodeGenerator()
    
    # åˆ›å»ºè®¾è®¡æ¨¡å¼
    singleton = SingletonPattern()
    factory = FactoryPattern()
    observer = ObserverPattern()
    
    # ç”Ÿæˆå•ä¾‹æ¨¡å¼ä»£ç 
    singleton_customizations = {
        "class_name": "DatabaseConnection",
        "attributes": {
            "connection_string": "localhost:5432",
            "max_connections": 10
        }
    }
    
    singleton_code = generator.generate_pattern_code(singleton, singleton_customizations)
    print("=== ç”Ÿæˆçš„å•ä¾‹æ¨¡å¼ä»£ç  ===")
    print(singleton_code)
    
    # ç”Ÿæˆå·¥å‚æ¨¡å¼ä»£ç 
    factory_customizations = {
        "product_name": "Vehicle",
        "concrete_products": ["Car", "Motorcycle", "Bicycle"]
    }
    
    factory_code = generator.generate_pattern_code(factory, factory_customizations)
    print("\n=== ç”Ÿæˆçš„å·¥å‚æ¨¡å¼ä»£ç  ===")
    print(factory_code)
    
    # ç”Ÿæˆè§‚å¯Ÿè€…æ¨¡å¼ä»£ç 
    observer_customizations = {
        "subject_name": "WeatherStation",
        "observer_name": "WeatherDisplay",
        "events": ["temperature", "humidity", "pressure"]
    }
    
    observer_code = generator.generate_pattern_code(observer, observer_customizations)
    print("\n=== ç”Ÿæˆçš„è§‚å¯Ÿè€…æ¨¡å¼ä»£ç  ===")
    print(observer_code)

if __name__ == "__main__":
    demonstrate_code_generation()
```

## ğŸ¯ æ€»ç»“

è®¾è®¡æ¨¡å¼ä¸ºè½¯ä»¶è®¾è®¡æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚é€šè¿‡å½¢å¼åŒ–å®šä¹‰ã€å¤šè¡¨å¾æ–¹å¼å’Œå®é™…åº”ç”¨ï¼Œæˆ‘ä»¬å»ºç«‹äº†å®Œæ•´çš„è®¾è®¡æ¨¡å¼ä½“ç³»ï¼Œä¸ºè½¯ä»¶æ¶æ„å’Œè®¾è®¡æä¾›äº†æŒ‡å¯¼ã€‚

### å…³é”®è¦ç‚¹

1. **å½¢å¼åŒ–å®šä¹‰**: è®¾è®¡æ¨¡å¼å¯ä»¥ç”¨äº”å…ƒç»„ $\mathcal{P} = (N, C, S, F, E)$ è¡¨ç¤º
2. **æ¨¡å¼åˆ†ç±»**: åˆ›å»ºå‹ã€ç»“æ„å‹ã€è¡Œä¸ºå‹ä¸‰å¤§ç±»
3. **å¤šè¡¨å¾æ–¹å¼**: åŒ…å«æ¦‚å¿µè§£é‡Šã€æ•°å­¦å½¢å¼ã€ä»£ç å®ç°ã€å›¾è¡¨è¯´æ˜å’Œå®ä¾‹åˆ†æ
4. **å®é™…åº”ç”¨**: é€šè¿‡Pythonå®ç°éªŒè¯æ¨¡å¼æ¦‚å¿µ
5. **ç†è®ºè¯æ˜**: æä¾›æœ‰æ•ˆæ€§å®šç†å’Œç»„åˆå®šç†çš„è¯æ˜

---

**ç›¸å…³æ–‡æ¡£**: 
- [åˆ›å»ºå‹æ¨¡å¼](./03-01-02-åˆ›å»ºå‹æ¨¡å¼.md)
- [ç»“æ„å‹æ¨¡å¼](./03-01-03-ç»“æ„å‹æ¨¡å¼.md)
- [è¡Œä¸ºå‹æ¨¡å¼](./03-01-04-è¡Œä¸ºå‹æ¨¡å¼.md)
- [è½¯ä»¶æ¶æ„åŸºç¡€](../03-02-è½¯ä»¶æ¶æ„/03-02-01-è½¯ä»¶æ¶æ„åŸºç¡€.md)
