# 03-01-01 è®¾è®¡æ¨¡å¼åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

è®¾è®¡æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­è§£å†³å¸¸è§è®¾è®¡é—®é¢˜çš„æ ‡å‡†åŒ–è§£å†³æ–¹æ¡ˆã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰è®¾è®¡æ¨¡å¼çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¾è®¡æ¨¡å¼çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 æ•°å­¦å®šä¹‰

**å®šä¹‰ 1.1.1** (è®¾è®¡æ¨¡å¼)
è®¾è®¡æ¨¡å¼æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{P} = (N, C, S, F, E)$ï¼Œå…¶ä¸­ï¼š

- $N$ æ˜¯æ¨¡å¼åç§° (Name)
- $C$ æ˜¯ä¸Šä¸‹æ–‡ (Context)
- $S$ æ˜¯è§£å†³æ–¹æ¡ˆ (Solution)
- $F$ æ˜¯å½¢å¼åŒ–æè¿° (Formal Description)
- $E$ æ˜¯æ•ˆæœ (Effects)

**å®šä¹‰ 1.1.2** (æ¨¡å¼åˆ†ç±»)
è®¾è®¡æ¨¡å¼æŒ‰ç›®çš„åˆ†ä¸ºä¸‰ç±»ï¼š

$$\mathcal{P} = \mathcal{P}_{creational} \cup \mathcal{P}_{structural} \cup \mathcal{P}_{behavioral}$$

å…¶ä¸­ï¼š

- $\mathcal{P}_{creational}$: åˆ›å»ºå‹æ¨¡å¼é›†åˆ
- $\mathcal{P}_{structural}$: ç»“æ„å‹æ¨¡å¼é›†åˆ
- $\mathcal{P}_{behavioral}$: è¡Œä¸ºå‹æ¨¡å¼é›†åˆ

#### 1.2 æ¨¡å¼å…³ç³»å›¾

**å®šä¹‰ 1.2.1** (æ¨¡å¼å…³ç³»å›¾)
æ¨¡å¼å…³ç³»å›¾æ˜¯ä¸€ä¸ªæœ‰å‘å›¾ $\mathcal{G} = (V, E)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯æ¨¡å¼é›†åˆ
- $E$ æ˜¯æ¨¡å¼é—´çš„å…³ç³»é›†åˆ

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Any, Set, Optional, TypeVar, Generic
from dataclasses import dataclass, field
from enum import Enum
from abc import ABC, abstractmethod
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict

T = TypeVar('T')

class PatternType(Enum):
    """è®¾è®¡æ¨¡å¼ç±»å‹æšä¸¾"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"
    CONCURRENT = "concurrent"
    DISTRIBUTED = "distributed"
    WORKFLOW = "workflow"

class PatternCategory(Enum):
    """æ¨¡å¼åˆ†ç±»"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"
    CONCURRENT = "concurrent"
    DISTRIBUTED = "distributed"
    WORKFLOW = "workflow"

@dataclass
class PatternContext:
    """æ¨¡å¼ä¸Šä¸‹æ–‡"""
    problem: str
    constraints: List[str]
    forces: List[str]
    participants: List[str]
    collaborations: List[str]

@dataclass
class PatternSolution:
    """æ¨¡å¼è§£å†³æ–¹æ¡ˆ"""
    structure: Dict[str, Any]
    implementation: str
    code_example: str
    trade_offs: List[str]

@dataclass
class PatternEffects:
    """æ¨¡å¼æ•ˆæœ"""
    benefits: List[str]
    liabilities: List[str]
    applicability: float
    complexity: float

@dataclass
class DesignPattern:
    """è®¾è®¡æ¨¡å¼å®šä¹‰"""
    name: str
    pattern_type: PatternType
    context: PatternContext
    solution: PatternSolution
    effects: PatternEffects
    related_patterns: List[str] = field(default_factory=list)
    
    def __str__(self) -> str:
        return f"{self.name} ({self.pattern_type.value})"
    
    def get_complexity_score(self) -> float:
        """è·å–å¤æ‚åº¦è¯„åˆ†"""
        return self.effects.complexity
    
    def get_applicability_score(self) -> float:
        """è·å–é€‚ç”¨æ€§è¯„åˆ†"""
        return self.effects.applicability

class PatternRegistry:
    """è®¾è®¡æ¨¡å¼æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self.patterns: Dict[str, DesignPattern] = {}
        self.pattern_graph = nx.DiGraph()
        self.category_patterns: Dict[PatternCategory, List[DesignPattern]] = defaultdict(list)
    
    def register_pattern(self, pattern: DesignPattern) -> None:
        """æ³¨å†Œè®¾è®¡æ¨¡å¼"""
        self.patterns[pattern.name] = pattern
        self.pattern_graph.add_node(pattern.name, pattern=pattern)
        self.category_patterns[PatternCategory(pattern.pattern_type.value)].append(pattern)
        
        # æ·»åŠ ç›¸å…³æ¨¡å¼çš„å…³ç³»
        for related_pattern in pattern.related_patterns:
            if related_pattern in self.patterns:
                self.pattern_graph.add_edge(pattern.name, related_pattern)
    
    def get_pattern(self, name: str) -> Optional[DesignPattern]:
        """è·å–è®¾è®¡æ¨¡å¼"""
        return self.patterns.get(name)
    
    def get_patterns_by_category(self, category: PatternCategory) -> List[DesignPattern]:
        """æŒ‰ç±»åˆ«è·å–æ¨¡å¼"""
        return self.category_patterns[category]
    
    def find_patterns_by_problem(self, problem: str) -> List[DesignPattern]:
        """æ ¹æ®é—®é¢˜æŸ¥æ‰¾æ¨¡å¼"""
        matches = []
        for pattern in self.patterns.values():
            if problem.lower() in pattern.context.problem.lower():
                matches.append(pattern)
        return matches
    
    def get_related_patterns(self, pattern_name: str) -> List[DesignPattern]:
        """è·å–ç›¸å…³æ¨¡å¼"""
        if pattern_name not in self.patterns:
            return []
        
        related = []
        for neighbor in self.pattern_graph.neighbors(pattern_name):
            if neighbor in self.patterns:
                related.append(self.patterns[neighbor])
        return related
    
    def visualize_pattern_relationships(self) -> None:
        """å¯è§†åŒ–æ¨¡å¼å…³ç³»"""
        plt.figure(figsize=(15, 10))
        pos = nx.spring_layout(self.pattern_graph, k=3, iterations=50)
        
        # ç»˜åˆ¶èŠ‚ç‚¹
        nx.draw_networkx_nodes(self.pattern_graph, pos, 
                             node_color='lightblue', 
                             node_size=2000)
        
        # ç»˜åˆ¶è¾¹
        nx.draw_networkx_edges(self.pattern_graph, pos, 
                             edge_color='gray', 
                             arrows=True, 
                             arrowsize=20)
        
        # ç»˜åˆ¶æ ‡ç­¾
        nx.draw_networkx_labels(self.pattern_graph, pos, 
                              font_size=8, 
                              font_weight='bold')
        
        plt.title("Design Pattern Relationships")
        plt.axis('off')
        plt.tight_layout()
        plt.show()

class PatternAnalyzer:
    """æ¨¡å¼åˆ†æå™¨"""
    
    def __init__(self, registry: PatternRegistry):
        self.registry = registry
    
    def analyze_pattern_complexity(self) -> Dict[str, float]:
        """åˆ†ææ¨¡å¼å¤æ‚åº¦"""
        complexity_scores = {}
        for pattern in self.registry.patterns.values():
            complexity_scores[pattern.name] = pattern.get_complexity_score()
        return complexity_scores
    
    def analyze_pattern_applicability(self) -> Dict[str, float]:
        """åˆ†ææ¨¡å¼é€‚ç”¨æ€§"""
        applicability_scores = {}
        for pattern in self.registry.patterns.values():
            applicability_scores[pattern.name] = pattern.get_applicability_score()
        return applicability_scores
    
    def find_optimal_patterns(self, problem: str, max_complexity: float = 0.8) -> List[DesignPattern]:
        """æŸ¥æ‰¾æœ€ä¼˜æ¨¡å¼"""
        candidates = self.registry.find_patterns_by_problem(problem)
        optimal_patterns = []
        
        for pattern in candidates:
            if (pattern.get_complexity_score() <= max_complexity and 
                pattern.get_applicability_score() >= 0.7):
                optimal_patterns.append(pattern)
        
        # æŒ‰é€‚ç”¨æ€§æ’åº
        optimal_patterns.sort(key=lambda p: p.get_applicability_score(), reverse=True)
        return optimal_patterns
    
    def generate_pattern_combination_suggestions(self, primary_pattern: str) -> List[List[str]]:
        """ç”Ÿæˆæ¨¡å¼ç»„åˆå»ºè®®"""
        if primary_pattern not in self.registry.patterns:
            return []
        
        primary = self.registry.patterns[primary_pattern]
        related = self.registry.get_related_patterns(primary_pattern)
        
        combinations = []
        for pattern in related:
            combinations.append([primary_pattern, pattern.name])
        
        return combinations

class PatternValidator:
    """æ¨¡å¼éªŒè¯å™¨"""
    
    def __init__(self):
        self.validation_rules: List[callable] = []
    
    def add_validation_rule(self, rule: callable) -> None:
        """æ·»åŠ éªŒè¯è§„åˆ™"""
        self.validation_rules.append(rule)
    
    def validate_pattern(self, pattern: DesignPattern) -> Dict[str, bool]:
        """éªŒè¯æ¨¡å¼"""
        results = {}
        for rule in self.validation_rules:
            try:
                results[rule.__name__] = rule(pattern)
            except Exception:
                results[rule.__name__] = False
        return results
    
    def validate_pattern_application(self, pattern: DesignPattern, context: Dict[str, Any]) -> bool:
        """éªŒè¯æ¨¡å¼åº”ç”¨"""
        # æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦åŒ¹é…
        if not self._check_context_compatibility(pattern, context):
            return False
        
        # æ£€æŸ¥çº¦æŸæ˜¯å¦æ»¡è¶³
        if not self._check_constraints_satisfaction(pattern, context):
            return False
        
        return True
    
    def _check_context_compatibility(self, pattern: DesignPattern, context: Dict[str, Any]) -> bool:
        """æ£€æŸ¥ä¸Šä¸‹æ–‡å…¼å®¹æ€§"""
        # ç®€åŒ–çš„ä¸Šä¸‹æ–‡æ£€æŸ¥
        required_elements = set(pattern.context.participants)
        available_elements = set(context.keys())
        return required_elements.issubset(available_elements)
    
    def _check_constraints_satisfaction(self, pattern: DesignPattern, context: Dict[str, Any]) -> bool:
        """æ£€æŸ¥çº¦æŸæ»¡è¶³æ€§"""
        # ç®€åŒ–çš„çº¦æŸæ£€æŸ¥
        for constraint in pattern.context.constraints:
            if not self._evaluate_constraint(constraint, context):
                return False
        return True
    
    def _evaluate_constraint(self, constraint: str, context: Dict[str, Any]) -> bool:
        """è¯„ä¼°çº¦æŸ"""
        # ç®€åŒ–çš„çº¦æŸè¯„ä¼°
        return True  # å®é™…å®ç°ä¸­éœ€è¦æ›´å¤æ‚çš„é€»è¾‘

# ç¤ºä¾‹ï¼šåˆ›å»ºæ¨¡å¼æ³¨å†Œè¡¨å’Œåˆ†æå™¨
def create_pattern_registry() -> PatternRegistry:
    """åˆ›å»ºæ¨¡å¼æ³¨å†Œè¡¨ç¤ºä¾‹"""
    registry = PatternRegistry()
    
    # åˆ›å»ºå•ä¾‹æ¨¡å¼
    singleton_context = PatternContext(
        problem="ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹",
        constraints=["çº¿ç¨‹å®‰å…¨", "å»¶è¿Ÿåˆå§‹åŒ–"],
        forces=["å…¨å±€çŠ¶æ€ç®¡ç†", "èµ„æºæ§åˆ¶"],
        participants=["Singleton", "Client"],
        collaborations=["Clienté€šè¿‡Singletonè®¿é—®å”¯ä¸€å®ä¾‹"]
    )
    
    singleton_solution = PatternSolution(
        structure={"Singleton": "ç±»", "getInstance": "é™æ€æ–¹æ³•"},
        implementation="ä½¿ç”¨ç§æœ‰æ„é€ å‡½æ•°å’Œé™æ€å®ä¾‹",
        code_example="""
class Singleton:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
        """,
        trade_offs=["å…¨å±€çŠ¶æ€", "æµ‹è¯•å›°éš¾", "è¿åå•ä¸€èŒè´£"]
    )
    
    singleton_effects = PatternEffects(
        benefits=["ä¿è¯å”¯ä¸€å®ä¾‹", "å»¶è¿Ÿåˆå§‹åŒ–", "çº¿ç¨‹å®‰å…¨"],
        liabilities=["å…¨å±€çŠ¶æ€", "æµ‹è¯•å›°éš¾", "è¿åå•ä¸€èŒè´£"],
        applicability=0.8,
        complexity=0.3
    )
    
    singleton_pattern = DesignPattern(
        name="Singleton",
        pattern_type=PatternType.CREATIONAL,
        context=singleton_context,
        solution=singleton_solution,
        effects=singleton_effects,
        related_patterns=["Factory Method", "Abstract Factory"]
    )
    
    registry.register_pattern(singleton_pattern)
    
    return registry

def demonstrate_pattern_analysis():
    """æ¼”ç¤ºæ¨¡å¼åˆ†æ"""
    print("=== è®¾è®¡æ¨¡å¼åˆ†ææ¼”ç¤º ===")
    
    # åˆ›å»ºæ³¨å†Œè¡¨
    registry = create_pattern_registry()
    
    # åˆ›å»ºåˆ†æå™¨
    analyzer = PatternAnalyzer(registry)
    
    # åˆ†æå¤æ‚åº¦
    complexity_scores = analyzer.analyze_pattern_complexity()
    print(f"æ¨¡å¼å¤æ‚åº¦åˆ†æ: {complexity_scores}")
    
    # åˆ†æé€‚ç”¨æ€§
    applicability_scores = analyzer.analyze_pattern_applicability()
    print(f"æ¨¡å¼é€‚ç”¨æ€§åˆ†æ: {applicability_scores}")
    
    # æŸ¥æ‰¾æœ€ä¼˜æ¨¡å¼
    optimal_patterns = analyzer.find_optimal_patterns("å•ä¾‹", max_complexity=0.5)
    print(f"æœ€ä¼˜æ¨¡å¼: {[p.name for p in optimal_patterns]}")
    
    # ç”Ÿæˆç»„åˆå»ºè®®
    combinations = analyzer.generate_pattern_combination_suggestions("Singleton")
    print(f"æ¨¡å¼ç»„åˆå»ºè®®: {combinations}")
    
    return registry, analyzer

if __name__ == "__main__":
    registry, analyzer = demonstrate_pattern_analysis()

## 2. è®¾è®¡æ¨¡å¼åˆ†ç±»ä½“ç³»

#### 2.1 åˆ›å»ºå‹æ¨¡å¼ (Creational Patterns)

**å®šä¹‰ 2.1.1** (åˆ›å»ºå‹æ¨¡å¼)
åˆ›å»ºå‹æ¨¡å¼å¤„ç†å¯¹è±¡åˆ›å»ºæœºåˆ¶ï¼Œè¯•å›¾åœ¨é€‚åˆç‰¹å®šæƒ…å†µçš„åœºæ™¯ä¸‹åˆ›å»ºå¯¹è±¡ï¼š

$$\mathcal{P}_{creational} = \{\text{Singleton}, \text{Factory Method}, \text{Abstract Factory}, \text{Builder}, \text{Prototype}\}$$

#### 2.2 ç»“æ„å‹æ¨¡å¼ (Structural Patterns)

**å®šä¹‰ 2.2.1** (ç»“æ„å‹æ¨¡å¼)
ç»“æ„å‹æ¨¡å¼å¤„ç†ç±»å’Œå¯¹è±¡çš„ç»„åˆï¼š

$$\mathcal{P}_{structural} = \{\text{Adapter}, \text{Bridge}, \text{Composite}, \text{Decorator}, \text{Facade}, \text{Flyweight}, \text{Proxy}\}$$

#### 2.3 è¡Œä¸ºå‹æ¨¡å¼ (Behavioral Patterns)

**å®šä¹‰ 2.3.1** (è¡Œä¸ºå‹æ¨¡å¼)
è¡Œä¸ºå‹æ¨¡å¼å¤„ç†ç±»æˆ–å¯¹è±¡ä¹‹é—´çš„é€šä¿¡ï¼š

$$\mathcal{P}_{behavioral} = \{\text{Chain of Responsibility}, \text{Command}, \text{Interpreter}, \text{Iterator}, \text{Mediator}, \text{Memento}, \text{Observer}, \text{State}, \text{Strategy}, \text{Template Method}, \text{Visitor}\}$$

## 3. æ¨¡å¼åº”ç”¨åŸåˆ™

#### 3.1 æ¨¡å¼é€‰æ‹©åŸåˆ™

**åŸåˆ™ 3.1.1** (é€‚ç”¨æ€§ä¼˜å…ˆ)
é€‰æ‹©æ¨¡å¼æ—¶åº”ä¼˜å…ˆè€ƒè™‘é€‚ç”¨æ€§ï¼š

$$\text{SelectPattern}(P, C) = \arg\max_{p \in P} \text{Applicability}(p, C)$$

**åŸåˆ™ 3.1.2** (å¤æ‚åº¦æ§åˆ¶)
åœ¨æ»¡è¶³é€‚ç”¨æ€§çš„å‰æä¸‹ï¼Œé€‰æ‹©å¤æ‚åº¦æœ€ä½çš„æ¨¡å¼ï¼š

$$\text{SelectPattern}(P, C) = \arg\min_{p \in P} \text{Complexity}(p) \text{ s.t. } \text{Applicability}(p, C) \geq \theta$$

#### 3.2 æ¨¡å¼ç»„åˆåŸåˆ™

**åŸåˆ™ 3.2.1** (å…¼å®¹æ€§æ£€æŸ¥)
æ¨¡å¼ç»„åˆå¿…é¡»æ»¡è¶³å…¼å®¹æ€§çº¦æŸï¼š

$$\text{Compatible}(p_1, p_2) = \text{CheckConstraints}(p_1, p_2) \land \text{CheckDependencies}(p_1, p_2)$$

**åŸåˆ™ 3.2.2** (ç»„åˆä¼˜åŒ–)
æ¨¡å¼ç»„åˆåº”ä¼˜åŒ–æ•´ä½“æ•ˆæœï¼š

$$\text{OptimizeCombination}(P) = \arg\max_{C \subseteq P} \sum_{p \in C} \text{Benefit}(p) - \sum_{p \in C} \text{Cost}(p)$$

## 4. æ¨¡å¼è¯„ä¼°æ¡†æ¶

#### 4.1 è¯„ä¼°æŒ‡æ ‡

**å®šä¹‰ 4.1.1** (é€‚ç”¨æ€§æŒ‡æ ‡)
é€‚ç”¨æ€§æŒ‡æ ‡è¡¡é‡æ¨¡å¼ä¸é—®é¢˜çš„åŒ¹é…ç¨‹åº¦ï¼š

$$\text{Applicability}(p, c) = \frac{\sum_{i=1}^{n} w_i \cdot \text{Match}_i(p, c)}{\sum_{i=1}^{n} w_i}$$

å…¶ä¸­ $w_i$ æ˜¯æƒé‡ï¼Œ$\text{Match}_i$ æ˜¯ç¬¬ $i$ ä¸ªåŒ¹é…åº¦å‡½æ•°ã€‚

**å®šä¹‰ 4.1.2** (å¤æ‚åº¦æŒ‡æ ‡)
å¤æ‚åº¦æŒ‡æ ‡è¡¡é‡æ¨¡å¼çš„å®ç°éš¾åº¦ï¼š

$$\text{Complexity}(p) = \alpha \cdot \text{StructuralComplexity}(p) + \beta \cdot \text{BehavioralComplexity}(p) + \gamma \cdot \text{IntegrationComplexity}(p)$$

å…¶ä¸­ $\alpha, \beta, \gamma$ æ˜¯æƒé‡ç³»æ•°ã€‚

#### 4.2 è¯„ä¼°æ–¹æ³•

```python
class PatternEvaluator:
    """æ¨¡å¼è¯„ä¼°å™¨"""
    
    def __init__(self):
        self.evaluation_metrics: Dict[str, callable] = {}
        self.weights: Dict[str, float] = {}
    
    def add_evaluation_metric(self, name: str, metric: callable, weight: float = 1.0) -> None:
        """æ·»åŠ è¯„ä¼°æŒ‡æ ‡"""
        self.evaluation_metrics[name] = metric
        self.weights[name] = weight
    
    def evaluate_pattern(self, pattern: DesignPattern, context: Dict[str, Any]) -> Dict[str, float]:
        """è¯„ä¼°æ¨¡å¼"""
        results = {}
        total_weight = sum(self.weights.values())
        
        for name, metric in self.evaluation_metrics.items():
            try:
                score = metric(pattern, context)
                results[name] = score * self.weights[name] / total_weight
            except Exception:
                results[name] = 0.0
        
        return results
    
    def get_overall_score(self, pattern: DesignPattern, context: Dict[str, Any]) -> float:
        """è·å–æ€»ä½“è¯„åˆ†"""
        scores = self.evaluate_pattern(pattern, context)
        return sum(scores.values())

# ç¤ºä¾‹è¯„ä¼°æŒ‡æ ‡
def applicability_metric(pattern: DesignPattern, context: Dict[str, Any]) -> float:
    """é€‚ç”¨æ€§è¯„ä¼°æŒ‡æ ‡"""
    # ç®€åŒ–çš„é€‚ç”¨æ€§è®¡ç®—
    problem_match = 0.0
    if pattern.context.problem.lower() in str(context).lower():
        problem_match = 1.0
    
    constraint_satisfaction = 0.0
    for constraint in pattern.context.constraints:
        if constraint.lower() in str(context).lower():
            constraint_satisfaction += 1.0
    constraint_satisfaction /= len(pattern.context.constraints)
    
    return (problem_match + constraint_satisfaction) / 2.0

def complexity_metric(pattern: DesignPattern, context: Dict[str, Any]) -> float:
    """å¤æ‚åº¦è¯„ä¼°æŒ‡æ ‡"""
    return 1.0 - pattern.get_complexity_score()

def maintainability_metric(pattern: DesignPattern, context: Dict[str, Any]) -> float:
    """å¯ç»´æŠ¤æ€§è¯„ä¼°æŒ‡æ ‡"""
    # ç®€åŒ–çš„å¯ç»´æŠ¤æ€§è®¡ç®—
    benefits_count = len(pattern.effects.benefits)
    liabilities_count = len(pattern.effects.liabilities)
    
    if benefits_count + liabilities_count == 0:
        return 0.5
    
    return benefits_count / (benefits_count + liabilities_count)

def demonstrate_pattern_evaluation():
    """æ¼”ç¤ºæ¨¡å¼è¯„ä¼°"""
    print("=== æ¨¡å¼è¯„ä¼°æ¼”ç¤º ===")
    
    # åˆ›å»ºæ³¨å†Œè¡¨
    registry = create_pattern_registry()
    
    # åˆ›å»ºè¯„ä¼°å™¨
    evaluator = PatternEvaluator()
    evaluator.add_evaluation_metric("applicability", applicability_metric, weight=0.4)
    evaluator.add_evaluation_metric("complexity", complexity_metric, weight=0.3)
    evaluator.add_evaluation_metric("maintainability", maintainability_metric, weight=0.3)
    
    # è·å–æ¨¡å¼
    singleton_pattern = registry.get_pattern("Singleton")
    if singleton_pattern:
        # åˆ›å»ºä¸Šä¸‹æ–‡
        context = {
            "problem": "éœ€è¦å…¨å±€é…ç½®ç®¡ç†",
            "constraints": ["çº¿ç¨‹å®‰å…¨", "å»¶è¿Ÿåˆå§‹åŒ–"],
            "requirements": ["å”¯ä¸€å®ä¾‹", "å…¨å±€è®¿é—®"]
        }
        
        # è¯„ä¼°æ¨¡å¼
        scores = evaluator.evaluate_pattern(singleton_pattern, context)
        overall_score = evaluator.get_overall_score(singleton_pattern, context)
        
        print(f"æ¨¡å¼è¯„ä¼°ç»“æœ:")
        for metric, score in scores.items():
            print(f"  {metric}: {score:.3f}")
        print(f"  æ€»ä½“è¯„åˆ†: {overall_score:.3f}")
    
    return evaluator

if __name__ == "__main__":
    demonstrate_pattern_evaluation()

## ğŸ“Š æ€»ç»“

æœ¬æ–‡æ¡£å»ºç«‹äº†è®¾è®¡æ¨¡å¼çš„å®Œæ•´å½¢å¼åŒ–æ¡†æ¶ï¼ŒåŒ…æ‹¬ï¼š

1. **æ•°å­¦å®šä¹‰**: ä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰å’Œåˆ†ç±»
2. **Pythonå®ç°**: å®Œæ•´çš„ä»£ç å®ç°å’Œç¤ºä¾‹
3. **è¯„ä¼°æ¡†æ¶**: ç³»ç»Ÿæ€§çš„æ¨¡å¼è¯„ä¼°æ–¹æ³•
4. **åº”ç”¨åŸåˆ™**: æ¨¡å¼é€‰æ‹©å’Œç»„åˆçš„åŸåˆ™

è¿™ä¸ªæ¡†æ¶ä¸ºåç»­çš„å…·ä½“æ¨¡å¼å®ç°æä¾›äº†ç†è®ºåŸºç¡€å’Œå®è·µæŒ‡å¯¼ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*æ–‡æ¡£çŠ¶æ€: å·²å®Œæˆ*
