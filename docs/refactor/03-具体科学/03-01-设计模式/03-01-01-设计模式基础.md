# 03-01-01 设计模式基础

## 📋 概述

设计模式是软件工程中解决常见设计问题的标准化解决方案。本文档从形式化角度定义设计模式的核心概念，并提供完整的Python实现。

## 🎯 核心概念

### 1. 设计模式的形式化定义

#### 1.1 数学定义

**定义 1.1.1** (设计模式)
设计模式是一个五元组 $\mathcal{P} = (N, C, S, F, E)$，其中：

- $N$ 是模式名称 (Name)
- $C$ 是上下文 (Context)
- $S$ 是解决方案 (Solution)
- $F$ 是形式化描述 (Formal Description)
- $E$ 是效果 (Effects)

**定义 1.1.2** (模式分类)
设计模式按目的分为三类：

$$\mathcal{P} = \mathcal{P}_{creational} \cup \mathcal{P}_{structural} \cup \mathcal{P}_{behavioral}$$

其中：

- $\mathcal{P}_{creational}$: 创建型模式集合
- $\mathcal{P}_{structural}$: 结构型模式集合
- $\mathcal{P}_{behavioral}$: 行为型模式集合

#### 1.2 模式关系图

**定义 1.2.1** (模式关系图)
模式关系图是一个有向图 $\mathcal{G} = (V, E)$，其中：

- $V$ 是模式集合
- $E$ 是模式间的关系集合

**Python实现**：

```python
from typing import Dict, List, Any, Set, Optional, TypeVar, Generic
from dataclasses import dataclass, field
from enum import Enum
from abc import ABC, abstractmethod
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict

T = TypeVar('T')

class PatternType(Enum):
    """设计模式类型枚举"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"
    CONCURRENT = "concurrent"
    DISTRIBUTED = "distributed"
    WORKFLOW = "workflow"

class PatternCategory(Enum):
    """模式分类"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"
    CONCURRENT = "concurrent"
    DISTRIBUTED = "distributed"
    WORKFLOW = "workflow"

@dataclass
class PatternContext:
    """模式上下文"""
    problem: str
    constraints: List[str]
    forces: List[str]
    participants: List[str]
    collaborations: List[str]

@dataclass
class PatternSolution:
    """模式解决方案"""
    structure: Dict[str, Any]
    implementation: str
    code_example: str
    trade_offs: List[str]

@dataclass
class PatternEffects:
    """模式效果"""
    benefits: List[str]
    liabilities: List[str]
    applicability: float
    complexity: float

@dataclass
class DesignPattern:
    """设计模式定义"""
    name: str
    pattern_type: PatternType
    context: PatternContext
    solution: PatternSolution
    effects: PatternEffects
    related_patterns: List[str] = field(default_factory=list)
    
    def __str__(self) -> str:
        return f"{self.name} ({self.pattern_type.value})"
    
    def get_complexity_score(self) -> float:
        """获取复杂度评分"""
        return self.effects.complexity
    
    def get_applicability_score(self) -> float:
        """获取适用性评分"""
        return self.effects.applicability

class PatternRegistry:
    """设计模式注册表"""
    
    def __init__(self):
        self.patterns: Dict[str, DesignPattern] = {}
        self.pattern_graph = nx.DiGraph()
        self.category_patterns: Dict[PatternCategory, List[DesignPattern]] = defaultdict(list)
    
    def register_pattern(self, pattern: DesignPattern) -> None:
        """注册设计模式"""
        self.patterns[pattern.name] = pattern
        self.pattern_graph.add_node(pattern.name, pattern=pattern)
        self.category_patterns[PatternCategory(pattern.pattern_type.value)].append(pattern)
        
        # 添加相关模式的关系
        for related_pattern in pattern.related_patterns:
            if related_pattern in self.patterns:
                self.pattern_graph.add_edge(pattern.name, related_pattern)
    
    def get_pattern(self, name: str) -> Optional[DesignPattern]:
        """获取设计模式"""
        return self.patterns.get(name)
    
    def get_patterns_by_category(self, category: PatternCategory) -> List[DesignPattern]:
        """按类别获取模式"""
        return self.category_patterns[category]
    
    def find_patterns_by_problem(self, problem: str) -> List[DesignPattern]:
        """根据问题查找模式"""
        matches = []
        for pattern in self.patterns.values():
            if problem.lower() in pattern.context.problem.lower():
                matches.append(pattern)
        return matches
    
    def get_related_patterns(self, pattern_name: str) -> List[DesignPattern]:
        """获取相关模式"""
        if pattern_name not in self.patterns:
            return []
        
        related = []
        for neighbor in self.pattern_graph.neighbors(pattern_name):
            if neighbor in self.patterns:
                related.append(self.patterns[neighbor])
        return related
    
    def visualize_pattern_relationships(self) -> None:
        """可视化模式关系"""
        plt.figure(figsize=(15, 10))
        pos = nx.spring_layout(self.pattern_graph, k=3, iterations=50)
        
        # 绘制节点
        nx.draw_networkx_nodes(self.pattern_graph, pos, 
                             node_color='lightblue', 
                             node_size=2000)
        
        # 绘制边
        nx.draw_networkx_edges(self.pattern_graph, pos, 
                             edge_color='gray', 
                             arrows=True, 
                             arrowsize=20)
        
        # 绘制标签
        nx.draw_networkx_labels(self.pattern_graph, pos, 
                              font_size=8, 
                              font_weight='bold')
        
        plt.title("Design Pattern Relationships")
        plt.axis('off')
        plt.tight_layout()
        plt.show()

class PatternAnalyzer:
    """模式分析器"""
    
    def __init__(self, registry: PatternRegistry):
        self.registry = registry
    
    def analyze_pattern_complexity(self) -> Dict[str, float]:
        """分析模式复杂度"""
        complexity_scores = {}
        for pattern in self.registry.patterns.values():
            complexity_scores[pattern.name] = pattern.get_complexity_score()
        return complexity_scores
    
    def analyze_pattern_applicability(self) -> Dict[str, float]:
        """分析模式适用性"""
        applicability_scores = {}
        for pattern in self.registry.patterns.values():
            applicability_scores[pattern.name] = pattern.get_applicability_score()
        return applicability_scores
    
    def find_optimal_patterns(self, problem: str, max_complexity: float = 0.8) -> List[DesignPattern]:
        """查找最优模式"""
        candidates = self.registry.find_patterns_by_problem(problem)
        optimal_patterns = []
        
        for pattern in candidates:
            if (pattern.get_complexity_score() <= max_complexity and 
                pattern.get_applicability_score() >= 0.7):
                optimal_patterns.append(pattern)
        
        # 按适用性排序
        optimal_patterns.sort(key=lambda p: p.get_applicability_score(), reverse=True)
        return optimal_patterns
    
    def generate_pattern_combination_suggestions(self, primary_pattern: str) -> List[List[str]]:
        """生成模式组合建议"""
        if primary_pattern not in self.registry.patterns:
            return []
        
        primary = self.registry.patterns[primary_pattern]
        related = self.registry.get_related_patterns(primary_pattern)
        
        combinations = []
        for pattern in related:
            combinations.append([primary_pattern, pattern.name])
        
        return combinations

class PatternValidator:
    """模式验证器"""
    
    def __init__(self):
        self.validation_rules: List[callable] = []
    
    def add_validation_rule(self, rule: callable) -> None:
        """添加验证规则"""
        self.validation_rules.append(rule)
    
    def validate_pattern(self, pattern: DesignPattern) -> Dict[str, bool]:
        """验证模式"""
        results = {}
        for rule in self.validation_rules:
            try:
                results[rule.__name__] = rule(pattern)
            except Exception:
                results[rule.__name__] = False
        return results
    
    def validate_pattern_application(self, pattern: DesignPattern, context: Dict[str, Any]) -> bool:
        """验证模式应用"""
        # 检查上下文是否匹配
        if not self._check_context_compatibility(pattern, context):
            return False
        
        # 检查约束是否满足
        if not self._check_constraints_satisfaction(pattern, context):
            return False
        
        return True
    
    def _check_context_compatibility(self, pattern: DesignPattern, context: Dict[str, Any]) -> bool:
        """检查上下文兼容性"""
        # 简化的上下文检查
        required_elements = set(pattern.context.participants)
        available_elements = set(context.keys())
        return required_elements.issubset(available_elements)
    
    def _check_constraints_satisfaction(self, pattern: DesignPattern, context: Dict[str, Any]) -> bool:
        """检查约束满足性"""
        # 简化的约束检查
        for constraint in pattern.context.constraints:
            if not self._evaluate_constraint(constraint, context):
                return False
        return True
    
    def _evaluate_constraint(self, constraint: str, context: Dict[str, Any]) -> bool:
        """评估约束"""
        # 简化的约束评估
        return True  # 实际实现中需要更复杂的逻辑

# 示例：创建模式注册表和分析器
def create_pattern_registry() -> PatternRegistry:
    """创建模式注册表示例"""
    registry = PatternRegistry()
    
    # 创建单例模式
    singleton_context = PatternContext(
        problem="确保一个类只有一个实例，并提供全局访问点",
        constraints=["线程安全", "延迟初始化"],
        forces=["全局状态管理", "资源控制"],
        participants=["Singleton", "Client"],
        collaborations=["Client通过Singleton访问唯一实例"]
    )
    
    singleton_solution = PatternSolution(
        structure={"Singleton": "类", "getInstance": "静态方法"},
        implementation="使用私有构造函数和静态实例",
        code_example="""
class Singleton:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
        """,
        trade_offs=["全局状态", "测试困难", "违反单一职责"]
    )
    
    singleton_effects = PatternEffects(
        benefits=["保证唯一实例", "延迟初始化", "线程安全"],
        liabilities=["全局状态", "测试困难", "违反单一职责"],
        applicability=0.8,
        complexity=0.3
    )
    
    singleton_pattern = DesignPattern(
        name="Singleton",
        pattern_type=PatternType.CREATIONAL,
        context=singleton_context,
        solution=singleton_solution,
        effects=singleton_effects,
        related_patterns=["Factory Method", "Abstract Factory"]
    )
    
    registry.register_pattern(singleton_pattern)
    
    return registry

def demonstrate_pattern_analysis():
    """演示模式分析"""
    print("=== 设计模式分析演示 ===")
    
    # 创建注册表
    registry = create_pattern_registry()
    
    # 创建分析器
    analyzer = PatternAnalyzer(registry)
    
    # 分析复杂度
    complexity_scores = analyzer.analyze_pattern_complexity()
    print(f"模式复杂度分析: {complexity_scores}")
    
    # 分析适用性
    applicability_scores = analyzer.analyze_pattern_applicability()
    print(f"模式适用性分析: {applicability_scores}")
    
    # 查找最优模式
    optimal_patterns = analyzer.find_optimal_patterns("单例", max_complexity=0.5)
    print(f"最优模式: {[p.name for p in optimal_patterns]}")
    
    # 生成组合建议
    combinations = analyzer.generate_pattern_combination_suggestions("Singleton")
    print(f"模式组合建议: {combinations}")
    
    return registry, analyzer

if __name__ == "__main__":
    registry, analyzer = demonstrate_pattern_analysis()

## 2. 设计模式分类体系

#### 2.1 创建型模式 (Creational Patterns)

**定义 2.1.1** (创建型模式)
创建型模式处理对象创建机制，试图在适合特定情况的场景下创建对象：

$$\mathcal{P}_{creational} = \{\text{Singleton}, \text{Factory Method}, \text{Abstract Factory}, \text{Builder}, \text{Prototype}\}$$

#### 2.2 结构型模式 (Structural Patterns)

**定义 2.2.1** (结构型模式)
结构型模式处理类和对象的组合：

$$\mathcal{P}_{structural} = \{\text{Adapter}, \text{Bridge}, \text{Composite}, \text{Decorator}, \text{Facade}, \text{Flyweight}, \text{Proxy}\}$$

#### 2.3 行为型模式 (Behavioral Patterns)

**定义 2.3.1** (行为型模式)
行为型模式处理类或对象之间的通信：

$$\mathcal{P}_{behavioral} = \{\text{Chain of Responsibility}, \text{Command}, \text{Interpreter}, \text{Iterator}, \text{Mediator}, \text{Memento}, \text{Observer}, \text{State}, \text{Strategy}, \text{Template Method}, \text{Visitor}\}$$

## 3. 模式应用原则

#### 3.1 模式选择原则

**原则 3.1.1** (适用性优先)
选择模式时应优先考虑适用性：

$$\text{SelectPattern}(P, C) = \arg\max_{p \in P} \text{Applicability}(p, C)$$

**原则 3.1.2** (复杂度控制)
在满足适用性的前提下，选择复杂度最低的模式：

$$\text{SelectPattern}(P, C) = \arg\min_{p \in P} \text{Complexity}(p) \text{ s.t. } \text{Applicability}(p, C) \geq \theta$$

#### 3.2 模式组合原则

**原则 3.2.1** (兼容性检查)
模式组合必须满足兼容性约束：

$$\text{Compatible}(p_1, p_2) = \text{CheckConstraints}(p_1, p_2) \land \text{CheckDependencies}(p_1, p_2)$$

**原则 3.2.2** (组合优化)
模式组合应优化整体效果：

$$\text{OptimizeCombination}(P) = \arg\max_{C \subseteq P} \sum_{p \in C} \text{Benefit}(p) - \sum_{p \in C} \text{Cost}(p)$$

## 4. 模式评估框架

#### 4.1 评估指标

**定义 4.1.1** (适用性指标)
适用性指标衡量模式与问题的匹配程度：

$$\text{Applicability}(p, c) = \frac{\sum_{i=1}^{n} w_i \cdot \text{Match}_i(p, c)}{\sum_{i=1}^{n} w_i}$$

其中 $w_i$ 是权重，$\text{Match}_i$ 是第 $i$ 个匹配度函数。

**定义 4.1.2** (复杂度指标)
复杂度指标衡量模式的实现难度：

$$\text{Complexity}(p) = \alpha \cdot \text{StructuralComplexity}(p) + \beta \cdot \text{BehavioralComplexity}(p) + \gamma \cdot \text{IntegrationComplexity}(p)$$

其中 $\alpha, \beta, \gamma$ 是权重系数。

#### 4.2 评估方法

```python
class PatternEvaluator:
    """模式评估器"""
    
    def __init__(self):
        self.evaluation_metrics: Dict[str, callable] = {}
        self.weights: Dict[str, float] = {}
    
    def add_evaluation_metric(self, name: str, metric: callable, weight: float = 1.0) -> None:
        """添加评估指标"""
        self.evaluation_metrics[name] = metric
        self.weights[name] = weight
    
    def evaluate_pattern(self, pattern: DesignPattern, context: Dict[str, Any]) -> Dict[str, float]:
        """评估模式"""
        results = {}
        total_weight = sum(self.weights.values())
        
        for name, metric in self.evaluation_metrics.items():
            try:
                score = metric(pattern, context)
                results[name] = score * self.weights[name] / total_weight
            except Exception:
                results[name] = 0.0
        
        return results
    
    def get_overall_score(self, pattern: DesignPattern, context: Dict[str, Any]) -> float:
        """获取总体评分"""
        scores = self.evaluate_pattern(pattern, context)
        return sum(scores.values())

# 示例评估指标
def applicability_metric(pattern: DesignPattern, context: Dict[str, Any]) -> float:
    """适用性评估指标"""
    # 简化的适用性计算
    problem_match = 0.0
    if pattern.context.problem.lower() in str(context).lower():
        problem_match = 1.0
    
    constraint_satisfaction = 0.0
    for constraint in pattern.context.constraints:
        if constraint.lower() in str(context).lower():
            constraint_satisfaction += 1.0
    constraint_satisfaction /= len(pattern.context.constraints)
    
    return (problem_match + constraint_satisfaction) / 2.0

def complexity_metric(pattern: DesignPattern, context: Dict[str, Any]) -> float:
    """复杂度评估指标"""
    return 1.0 - pattern.get_complexity_score()

def maintainability_metric(pattern: DesignPattern, context: Dict[str, Any]) -> float:
    """可维护性评估指标"""
    # 简化的可维护性计算
    benefits_count = len(pattern.effects.benefits)
    liabilities_count = len(pattern.effects.liabilities)
    
    if benefits_count + liabilities_count == 0:
        return 0.5
    
    return benefits_count / (benefits_count + liabilities_count)

def demonstrate_pattern_evaluation():
    """演示模式评估"""
    print("=== 模式评估演示 ===")
    
    # 创建注册表
    registry = create_pattern_registry()
    
    # 创建评估器
    evaluator = PatternEvaluator()
    evaluator.add_evaluation_metric("applicability", applicability_metric, weight=0.4)
    evaluator.add_evaluation_metric("complexity", complexity_metric, weight=0.3)
    evaluator.add_evaluation_metric("maintainability", maintainability_metric, weight=0.3)
    
    # 获取模式
    singleton_pattern = registry.get_pattern("Singleton")
    if singleton_pattern:
        # 创建上下文
        context = {
            "problem": "需要全局配置管理",
            "constraints": ["线程安全", "延迟初始化"],
            "requirements": ["唯一实例", "全局访问"]
        }
        
        # 评估模式
        scores = evaluator.evaluate_pattern(singleton_pattern, context)
        overall_score = evaluator.get_overall_score(singleton_pattern, context)
        
        print(f"模式评估结果:")
        for metric, score in scores.items():
            print(f"  {metric}: {score:.3f}")
        print(f"  总体评分: {overall_score:.3f}")
    
    return evaluator

if __name__ == "__main__":
    demonstrate_pattern_evaluation()

## 📊 总结

本文档建立了设计模式的完整形式化框架，包括：

1. **数学定义**: 严格的形式化定义和分类
2. **Python实现**: 完整的代码实现和示例
3. **评估框架**: 系统性的模式评估方法
4. **应用原则**: 模式选择和组合的原则

这个框架为后续的具体模式实现提供了理论基础和实践指导。

---

*最后更新: 2024-12-19*
*文档状态: 已完成*
