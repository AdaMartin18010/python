# ËÆæËÆ°Ê®°ÂºèÂü∫Á°Ä

## üìã Ê¶ÇËø∞

ËÆæËÆ°Ê®°ÂºèÊòØËΩØ‰ª∂Â∑•Á®ã‰∏≠Ëß£ÂÜ≥Â∏∏ËßÅËÆæËÆ°ÈóÆÈ¢òÁöÑÊ†áÂáÜËß£ÂÜ≥ÊñπÊ°à„ÄÇÊú¨ÊñáÊ°£‰ªéÂΩ¢ÂºèÂåñËßíÂ∫¶Êé¢ËÆ®ËÆæËÆ°Ê®°ÂºèÁöÑÊ†∏ÂøÉÊ¶ÇÂøµÔºåÂª∫Á´ã‰∏•Ê†ºÁöÑÊï∞Â≠¶ÂÆö‰πâÂíåPythonÂÆûÁé∞„ÄÇ

## üéØ Ê†∏ÂøÉÊ¶ÇÂøµ

### 1. ËÆæËÆ°Ê®°ÂºèÁöÑÂΩ¢ÂºèÂåñÂÆö‰πâ

#### 1.1 Âü∫Êú¨ÂÆö‰πâ

ËÆæËÆ°Ê®°ÂºèÂèØ‰ª•ÂΩ¢ÂºèÂåñÂÆö‰πâ‰∏∫Ôºö

$$\mathcal{P} = (N, C, S, F, E)$$

ÂÖ∂‰∏≠Ôºö
- $N$ ÊòØÂêçÁß∞ÈõÜÂêà (Name Set)
- $C$ ÊòØ‰∏ä‰∏ãÊñáÈõÜÂêà (Context Set)
- $S$ ÊòØËß£ÂÜ≥ÊñπÊ°àÈõÜÂêà (Solution Set)
- $F$ ÊòØÂΩ¢ÂºèÂåñÊèèËø∞ (Formal Description)
- $E$ ÊòØÊïàÊûúÈõÜÂêà (Effect Set)

#### 1.2 ËÆæËÆ°Ê®°ÂºèÂàÜÁ±ª

ËÆæËÆ°Ê®°ÂºèÊåâÁõÆÁöÑÂàÜ‰∏∫‰∏âÁ±ªÔºö

1. **ÂàõÂª∫ÂûãÊ®°Âºè**: Â§ÑÁêÜÂØπË±°ÂàõÂª∫Êú∫Âà∂
2. **ÁªìÊûÑÂûãÊ®°Âºè**: Â§ÑÁêÜÁ±ªÂíåÂØπË±°ÁöÑÁªÑÂêà
3. **Ë°å‰∏∫ÂûãÊ®°Âºè**: Â§ÑÁêÜÂØπË±°Èó¥ÁöÑÈÄö‰ø°

## üîß Python ÂÆûÁé∞

### 1. ËÆæËÆ°Ê®°ÂºèÂü∫Á°ÄÊ°ÜÊû∂

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Type, Union
from dataclasses import dataclass, field
from enum import Enum
import json

class PatternType(Enum):
    """ËÆæËÆ°Ê®°ÂºèÁ±ªÂûãÊûö‰∏æ"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"

class PatternCategory(Enum):
    """ËÆæËÆ°Ê®°ÂºèÂàÜÁ±ªÊûö‰∏æ"""
    GOF = "gang_of_four"
    ENTERPRISE = "enterprise"
    CONCURRENCY = "concurrency"
    ARCHITECTURAL = "architectural"

@dataclass
class PatternSpecification:
    """ËÆæËÆ°Ê®°ÂºèËßÑÊ†ºËØ¥Êòé"""
    name: str
    pattern_type: PatternType
    category: PatternCategory
    description: str
    problem: str
    solution: str
    consequences: List[str]
    participants: List[str]
    collaborations: List[str]
    
    def __post_init__(self):
        """È™åËØÅÊ®°ÂºèËßÑÊ†º"""
        if not self.name or not self.description:
            raise ValueError("Ê®°ÂºèÂêçÁß∞ÂíåÊèèËø∞‰∏çËÉΩ‰∏∫Á©∫")

@dataclass
class PatternImplementation:
    """ËÆæËÆ°Ê®°ÂºèÂÆûÁé∞"""
    specification: PatternSpecification
    code_example: str
    use_cases: List[str]
    advantages: List[str]
    disadvantages: List[str]
    alternatives: List[str]

class DesignPattern(ABC):
    """ËÆæËÆ°Ê®°ÂºèÊäΩË±°Âü∫Á±ª"""
    
    def __init__(self, specification: PatternSpecification):
        self.specification = specification
        self.implementation: Optional[PatternImplementation] = None
        self.usage_examples: List[Dict[str, Any]] = []
    
    @abstractmethod
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """Â∫îÁî®ËÆæËÆ°Ê®°Âºè"""
        pass
    
    @abstractmethod
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """ÊºîÁ§∫ËÆæËÆ°Ê®°Âºè"""
        pass
    
    def add_usage_example(self, example: Dict[str, Any]):
        """Ê∑ªÂä†‰ΩøÁî®Á§∫‰æã"""
        self.usage_examples.append(example)
    
    def get_pattern_info(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÊ®°Âºè‰ø°ÊÅØ"""
        return {
            "name": self.specification.name,
            "type": self.specification.pattern_type.value,
            "category": self.specification.category.value,
            "description": self.specification.description,
            "problem": self.specification.problem,
            "solution": self.specification.solution,
            "consequences": self.specification.consequences,
            "participants": self.specification.participants,
            "collaborations": self.specification.collaborations
        }

class CreationalPattern(DesignPattern):
    """ÂàõÂª∫ÂûãÊ®°ÂºèÂü∫Á±ª"""
    
    def __init__(self, specification: PatternSpecification):
        super().__init__(specification)
        if specification.pattern_type != PatternType.CREATIONAL:
            raise ValueError("ÂàõÂª∫ÂûãÊ®°ÂºèÁ±ªÂûã‰∏çÂåπÈÖç")

class StructuralPattern(DesignPattern):
    """ÁªìÊûÑÂûãÊ®°ÂºèÂü∫Á±ª"""
    
    def __init__(self, specification: PatternSpecification):
        super().__init__(specification)
        if specification.pattern_type != PatternType.STRUCTURAL:
            raise ValueError("ÁªìÊûÑÂûãÊ®°ÂºèÁ±ªÂûã‰∏çÂåπÈÖç")

class BehavioralPattern(DesignPattern):
    """Ë°å‰∏∫ÂûãÊ®°ÂºèÂü∫Á±ª"""
    
    def __init__(self, specification: PatternSpecification):
        super().__init__(specification)
        if specification.pattern_type != PatternType.BEHAVIORAL:
            raise ValueError("Ë°å‰∏∫ÂûãÊ®°ÂºèÁ±ªÂûã‰∏çÂåπÈÖç")

# ÂÖ∑‰ΩìËÆæËÆ°Ê®°ÂºèÂÆûÁé∞

class SingletonPattern(CreationalPattern):
    """Âçï‰æãÊ®°Âºè"""
    
    def __init__(self):
        specification = PatternSpecification(
            name="Âçï‰æãÊ®°Âºè",
            pattern_type=PatternType.CREATIONAL,
            category=PatternCategory.GOF,
            description="Á°Æ‰øù‰∏Ä‰∏™Á±ªÂè™Êúâ‰∏Ä‰∏™ÂÆû‰æãÔºåÂπ∂Êèê‰æõÂÖ®Â±ÄËÆøÈóÆÁÇπ",
            problem="Â¶Ç‰ΩïÁ°Æ‰øù‰∏Ä‰∏™Á±ªÂè™Êúâ‰∏Ä‰∏™ÂÆû‰æãÔºü",
            solution="Â∞ÜÊûÑÈÄ†ÂáΩÊï∞ËÆæ‰∏∫ÁßÅÊúâÔºåÊèê‰æõÈùôÊÄÅÊñπÊ≥ïËé∑ÂèñÂÆû‰æã",
            consequences=[
                "‰øùËØÅ‰∏Ä‰∏™Á±ªÂè™Êúâ‰∏Ä‰∏™ÂÆû‰æã",
                "Êèê‰æõÂÖ®Â±ÄËÆøÈóÆÁÇπ",
                "ÂèØËÉΩËøùÂèçÂçï‰∏ÄËÅåË¥£ÂéüÂàô"
            ],
            participants=["Singleton"],
            collaborations=["ÂÆ¢Êà∑Á´ØÈÄöËøágetInstance()ËÆøÈóÆÂçï‰æã"]
        )
        super().__init__(specification)
    
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """Â∫îÁî®Âçï‰æãÊ®°Âºè"""
        class_name = context.get("class_name", "MyClass")
        
        singleton_code = f"""
class {class_name}:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
            # ÂàùÂßãÂåñ‰ª£Á†Å
"""
        return singleton_code
    
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """ÊºîÁ§∫Âçï‰æãÊ®°Âºè"""
        class DatabaseConnection:
            _instance = None
            
            def __new__(cls):
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                return cls._instance
            
            def __init__(self):
                if not hasattr(self, '_initialized'):
                    self._initialized = True
                    self.connection_string = "database://localhost:5432"
                    print("Êï∞ÊçÆÂ∫ìËøûÊé•Â∑≤ÂàõÂª∫")
            
            def connect(self):
                return f"ËøûÊé•Âà∞: {self.connection_string}"
        
        # ÊºîÁ§∫Âçï‰æãË°å‰∏∫
        db1 = DatabaseConnection()
        db2 = DatabaseConnection()
        
        return {
            "pattern": "Âçï‰æãÊ®°Âºè",
            "demonstration": {
                "instance1_id": id(db1),
                "instance2_id": id(db2),
                "are_same_instance": db1 is db2,
                "connection1": db1.connect(),
                "connection2": db2.connect()
            }
        }

class FactoryPattern(CreationalPattern):
    """Â∑•ÂéÇÊ®°Âºè"""
    
    def __init__(self):
        specification = PatternSpecification(
            name="Â∑•ÂéÇÊ®°Âºè",
            pattern_type=PatternType.CREATIONAL,
            category=PatternCategory.GOF,
            description="ÂÆö‰πâ‰∏Ä‰∏™ÂàõÂª∫ÂØπË±°ÁöÑÊé•Âè£ÔºåËÆ©Â≠êÁ±ªÂÜ≥ÂÆöÂÆû‰æãÂåñÂì™‰∏™Á±ª",
            problem="Â¶Ç‰ΩïÂàõÂª∫ÂØπË±°ËÄå‰∏çÊö¥Èú≤ÂàõÂª∫ÈÄªËæëÔºü",
            solution="‰ΩøÁî®Â∑•ÂéÇÊñπÊ≥ïÂ∞ÅË£ÖÂØπË±°ÂàõÂª∫",
            consequences=[
                "Â∞ÅË£ÖÂØπË±°ÂàõÂª∫ÈÄªËæë",
                "ÊîØÊåÅÂºÄÈó≠ÂéüÂàô",
                "ÂèØËÉΩÂ¢ûÂä†Á±ªÁöÑÊï∞Èáè"
            ],
            participants=["Product", "ConcreteProduct", "Creator", "ConcreteCreator"],
            collaborations=["CreatorË∞ÉÁî®ConcreteCreatorÂàõÂª∫Product"]
        )
        super().__init__(specification)
    
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """Â∫îÁî®Â∑•ÂéÇÊ®°Âºè"""
        product_type = context.get("product_type", "Product")
        
        factory_code = f"""
from abc import ABC, abstractmethod

class {product_type}(ABC):
    @abstractmethod
    def operation(self):
        pass

class Concrete{product_type}({product_type}):
    def operation(self):
        return "ÂÖ∑‰Ωì‰∫ßÂìÅÊìç‰Ωú"

class Creator(ABC):
    @abstractmethod
    def factory_method(self) -> {product_type}:
        pass
    
    def some_operation(self):
        product = self.factory_method()
        return product.operation()

class ConcreteCreator(Creator):
    def factory_method(self) -> {product_type}:
        return Concrete{product_type}()
"""
        return factory_code
    
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """ÊºîÁ§∫Â∑•ÂéÇÊ®°Âºè"""
        from abc import ABC, abstractmethod
        
        class Vehicle(ABC):
            @abstractmethod
            def drive(self):
                pass
        
        class Car(Vehicle):
            def drive(self):
                return "È©æÈ©∂Ê±ΩËΩ¶"
        
        class Motorcycle(Vehicle):
            def drive(self):
                return "È©æÈ©∂Êë©ÊâòËΩ¶"
        
        class VehicleFactory(ABC):
            @abstractmethod
            def create_vehicle(self) -> Vehicle:
                pass
        
        class CarFactory(VehicleFactory):
            def create_vehicle(self) -> Vehicle:
                return Car()
        
        class MotorcycleFactory(VehicleFactory):
            def create_vehicle(self) -> Vehicle:
                return Motorcycle()
        
        # ÊºîÁ§∫Â∑•ÂéÇÊ®°Âºè
        car_factory = CarFactory()
        motorcycle_factory = MotorcycleFactory()
        
        car = car_factory.create_vehicle()
        motorcycle = motorcycle_factory.create_vehicle()
        
        return {
            "pattern": "Â∑•ÂéÇÊ®°Âºè",
            "demonstration": {
                "car_drive": car.drive(),
                "motorcycle_drive": motorcycle.drive(),
                "car_type": type(car).__name__,
                "motorcycle_type": type(motorcycle).__name__
            }
        }

class ObserverPattern(BehavioralPattern):
    """ËßÇÂØüËÄÖÊ®°Âºè"""
    
    def __init__(self):
        specification = PatternSpecification(
            name="ËßÇÂØüËÄÖÊ®°Âºè",
            pattern_type=PatternType.BEHAVIORAL,
            category=PatternCategory.GOF,
            description="ÂÆö‰πâÂØπË±°Èó¥ÁöÑ‰∏ÄÂØπÂ§ö‰æùËµñÂÖ≥Á≥ªÔºåÂΩì‰∏Ä‰∏™ÂØπË±°Áä∂ÊÄÅÊîπÂèòÊó∂ÔºåÊâÄÊúâ‰æùËµñËÄÖÈÉΩÂæóÂà∞ÈÄöÁü•",
            problem="Â¶Ç‰ΩïÂÆûÁé∞ÂØπË±°Èó¥ÁöÑÊùæËÄ¶ÂêàÈÄö‰ø°Ôºü",
            solution="‰ΩøÁî®ËßÇÂØüËÄÖÊ®°ÂºèÂª∫Á´ãÂèëÂ∏É-ËÆ¢ÈòÖÂÖ≥Á≥ª",
            consequences=[
                "ÊîØÊåÅÂπøÊí≠ÈÄö‰ø°",
                "ÊùæËÄ¶ÂêàËÆæËÆ°",
                "ÂèØËÉΩ‰∫ßÁîüÊÑèÂ§ñÁöÑÊõ¥Êñ∞"
            ],
            participants=["Subject", "Observer", "ConcreteSubject", "ConcreteObserver"],
            collaborations=["SubjectÈÄöÁü•ObserverÁä∂ÊÄÅÂèòÂåñ"]
        )
        super().__init__(specification)
    
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """Â∫îÁî®ËßÇÂØüËÄÖÊ®°Âºè"""
        observer_code = """
from abc import ABC, abstractmethod
from typing import List

class Observer(ABC):
    @abstractmethod
    def update(self, subject):
        pass

class Subject(ABC):
    def __init__(self):
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer):
        self._observers.append(observer)
    
    def detach(self, observer: Observer):
        self._observers.remove(observer)
    
    def notify(self):
        for observer in self._observers:
            observer.update(self)

class ConcreteSubject(Subject):
    def __init__(self):
        super().__init__()
        self._state = None
    
    @property
    def state(self):
        return self._state
    
    @state.setter
    def state(self, value):
        self._state = value
        self.notify()

class ConcreteObserver(Observer):
    def __init__(self, name: str):
        self.name = name
    
    def update(self, subject):
        print(f"{self.name} Êî∂Âà∞Êõ¥Êñ∞: {subject.state}")
"""
        return observer_code
    
    def demonstrate_pattern(self) -> Dict[str, Any]:
        """ÊºîÁ§∫ËßÇÂØüËÄÖÊ®°Âºè"""
        from abc import ABC, abstractmethod
        from typing import List
        
        class Observer(ABC):
            @abstractmethod
            def update(self, subject):
                pass
        
        class Subject(ABC):
            def __init__(self):
                self._observers: List[Observer] = []
            
            def attach(self, observer: Observer):
                self._observers.append(observer)
            
            def detach(self, observer: Observer):
                self._observers.remove(observer)
            
            def notify(self):
                for observer in self._observers:
                    observer.update(self)
        
        class WeatherStation(Subject):
            def __init__(self):
                super().__init__()
                self._temperature = 0
            
            @property
            def temperature(self):
                return self._temperature
            
            @temperature.setter
            def temperature(self, value):
                self._temperature = value
                self.notify()
        
        class WeatherDisplay(Observer):
            def __init__(self, name: str):
                self.name = name
            
            def update(self, subject):
                print(f"{self.name}: Ê∏©Â∫¶Êõ¥Êñ∞‰∏∫ {subject.temperature}¬∞C")
        
        # ÊºîÁ§∫ËßÇÂØüËÄÖÊ®°Âºè
        weather_station = WeatherStation()
        display1 = WeatherDisplay("ÂÆ¢ÂéÖÊòæÁ§∫Âô®")
        display2 = WeatherDisplay("ÂçßÂÆ§ÊòæÁ§∫Âô®")
        
        weather_station.attach(display1)
        weather_station.attach(display2)
        
        weather_station.temperature = 25
        weather_station.temperature = 30
        
        return {
            "pattern": "ËßÇÂØüËÄÖÊ®°Âºè",
            "demonstration": {
                "observers_count": len(weather_station._observers),
                "current_temperature": weather_station.temperature
            }
        }

class DesignPatternCatalog:
    """ËÆæËÆ°Ê®°ÂºèÁõÆÂΩï"""
    
    def __init__(self):
        self.patterns: Dict[str, DesignPattern] = {}
        self.pattern_categories: Dict[PatternCategory, List[str]] = {
            PatternCategory.GOF: [],
            PatternCategory.ENTERPRISE: [],
            PatternCategory.CONCURRENCY: [],
            PatternCategory.ARCHITECTURAL: []
        }
    
    def add_pattern(self, pattern: DesignPattern):
        """Ê∑ªÂä†ËÆæËÆ°Ê®°Âºè"""
        self.patterns[pattern.specification.name] = pattern
        category = pattern.specification.category
        self.pattern_categories[category].append(pattern.specification.name)
    
    def get_pattern(self, name: str) -> Optional[DesignPattern]:
        """Ëé∑ÂèñËÆæËÆ°Ê®°Âºè"""
        return self.patterns.get(name)
    
    def get_patterns_by_type(self, pattern_type: PatternType) -> List[DesignPattern]:
        """ÊåâÁ±ªÂûãËé∑ÂèñËÆæËÆ°Ê®°Âºè"""
        return [
            pattern for pattern in self.patterns.values()
            if pattern.specification.pattern_type == pattern_type
        ]
    
    def get_patterns_by_category(self, category: PatternCategory) -> List[DesignPattern]:
        """ÊåâÂàÜÁ±ªËé∑ÂèñËÆæËÆ°Ê®°Âºè"""
        return [
            pattern for pattern in self.patterns.values()
            if pattern.specification.category == category
        ]
    
    def search_patterns(self, keyword: str) -> List[DesignPattern]:
        """ÊêúÁ¥¢ËÆæËÆ°Ê®°Âºè"""
        results = []
        keyword_lower = keyword.lower()
        
        for pattern in self.patterns.values():
            if (keyword_lower in pattern.specification.name.lower() or
                keyword_lower in pattern.specification.description.lower() or
                keyword_lower in pattern.specification.problem.lower()):
                results.append(pattern)
        
        return results
    
    def generate_pattern_report(self) -> Dict[str, Any]:
        """ÁîüÊàêÊ®°ÂºèÊä•Âëä"""
        report = {
            "total_patterns": len(self.patterns),
            "patterns_by_type": {},
            "patterns_by_category": {},
            "pattern_details": {}
        }
        
        # ÊåâÁ±ªÂûãÁªüËÆ°
        for pattern_type in PatternType:
            patterns = self.get_patterns_by_type(pattern_type)
            report["patterns_by_type"][pattern_type.value] = {
                "count": len(patterns),
                "patterns": [p.specification.name for p in patterns]
            }
        
        # ÊåâÂàÜÁ±ªÁªüËÆ°
        for category in PatternCategory:
            patterns = self.get_patterns_by_category(category)
            report["patterns_by_category"][category.value] = {
                "count": len(patterns),
                "patterns": [p.specification.name for p in patterns]
            }
        
        # ËØ¶ÁªÜÊ®°Âºè‰ø°ÊÅØ
        for name, pattern in self.patterns.items():
            report["pattern_details"][name] = pattern.get_pattern_info()
        
        return report
    
    def demonstrate_patterns(self, pattern_names: List[str]) -> Dict[str, Any]:
        """ÊºîÁ§∫Â§ö‰∏™ËÆæËÆ°Ê®°Âºè"""
        demonstrations = {}
        
        for name in pattern_names:
            pattern = self.get_pattern(name)
            if pattern:
                demonstrations[name] = pattern.demonstrate_pattern()
        
        return demonstrations

# ‰ΩøÁî®Á§∫‰æã
def demonstrate_design_patterns():
    """ÊºîÁ§∫ËÆæËÆ°Ê®°Âºè"""
    
    # ÂàõÂª∫ËÆæËÆ°Ê®°ÂºèÁõÆÂΩï
    catalog = DesignPatternCatalog()
    
    # Ê∑ªÂä†ËÆæËÆ°Ê®°Âºè
    singleton = SingletonPattern()
    factory = FactoryPattern()
    observer = ObserverPattern()
    
    catalog.add_pattern(singleton)
    catalog.add_pattern(factory)
    catalog.add_pattern(observer)
    
    # ÁîüÊàêÊ®°ÂºèÊä•Âëä
    report = catalog.generate_pattern_report()
    
    print("=== ËÆæËÆ°Ê®°ÂºèÁõÆÂΩïÊä•Âëä ===")
    print(f"ÊÄªÊ®°ÂºèÊï∞: {report['total_patterns']}")
    
    print("\n=== ÊåâÁ±ªÂûãÂàÜÁ±ª ===")
    for type_name, type_info in report["patterns_by_type"].items():
        print(f"{type_name}: {type_info['count']} ‰∏™Ê®°Âºè")
        print(f"  Ê®°ÂºèÂàóË°®: {type_info['patterns']}")
    
    print("\n=== ÊåâÂàÜÁ±ªÂàÜÁ±ª ===")
    for category_name, category_info in report["patterns_by_category"].items():
        print(f"{category_name}: {category_info['count']} ‰∏™Ê®°Âºè")
        print(f"  Ê®°ÂºèÂàóË°®: {category_info['patterns']}")
    
    # ÊºîÁ§∫ËÆæËÆ°Ê®°Âºè
    demonstrations = catalog.demonstrate_patterns(["Âçï‰æãÊ®°Âºè", "Â∑•ÂéÇÊ®°Âºè", "ËßÇÂØüËÄÖÊ®°Âºè"])
    
    print("\n=== ËÆæËÆ°Ê®°ÂºèÊºîÁ§∫ ===")
    for pattern_name, demo in demonstrations.items():
        print(f"\n{pattern_name}:")
        for key, value in demo["demonstration"].items():
            print(f"  {key}: {value}")
    
    # ÊêúÁ¥¢Ê®°Âºè
    search_results = catalog.search_patterns("ÂàõÂª∫")
    print(f"\n=== ÊêúÁ¥¢ 'ÂàõÂª∫' ÁöÑÁªìÊûú ===")
    for pattern in search_results:
        print(f"- {pattern.specification.name}: {pattern.specification.description}")
    
    return catalog

if __name__ == "__main__":
    # ËøêË°åÊºîÁ§∫
    result = demonstrate_design_patterns()

## üìä ÁêÜËÆ∫ËØÅÊòé

### 1. ËÆæËÆ°Ê®°ÂºèÊúâÊïàÊÄßÂÆöÁêÜ

**ÂÆöÁêÜ**: Â¶ÇÊûúËÆæËÆ°Ê®°Âºè $P$ Ëß£ÂÜ≥‰∫ÜÈóÆÈ¢ò $Q$ÔºåÂπ∂‰∏îÂú®‰∏ä‰∏ãÊñá $C$ ‰∏≠Â∫îÁî®ÔºåÂàô $P$ ÊòØÊúâÊïàÁöÑ„ÄÇ

**ËØÅÊòé**:
1. ËÆæ $P$ ÊòØËÆæËÆ°Ê®°ÂºèÔºå$Q$ ÊòØÈóÆÈ¢òÔºå$C$ ÊòØ‰∏ä‰∏ãÊñá
2. Â¶ÇÊûú $P$ Âú® $C$ ‰∏≠Ëß£ÂÜ≥‰∫Ü $Q$ÔºåÂàô $P$ Êª°Ë∂≥ÊúâÊïàÊÄßÊù°‰ª∂
3. ËøôÂèØ‰ª•ÈÄöËøáÂΩ¢ÂºèÂåñÈ™åËØÅÊàñÂÆûÈôÖÊµãËØïÊù•ËØÅÊòé

### 2. ËÆæËÆ°Ê®°ÂºèÁªÑÂêàÂÆöÁêÜ

**ÂÆöÁêÜ**: Â§ö‰∏™ËÆæËÆ°Ê®°ÂºèÂèØ‰ª•ÁªÑÂêà‰ΩøÁî®ÔºåÂΩ¢ÊàêÊõ¥Â§çÊùÇÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇ

**ËØÅÊòé**:
1. ËÆæ $P_1, P_2, ..., P_n$ ÊòØËÆæËÆ°Ê®°Âºè
2. Â¶ÇÊûú $P_i$ Âíå $P_j$ ÂÖºÂÆπÔºåÂàôÂèØ‰ª•ÁªÑÂêà
3. ÁªÑÂêàÂêéÁöÑÊ®°Âºè‰ªçÁÑ∂Êª°Ë∂≥ËÆæËÆ°ÂéüÂàô

## üîó Áõ∏ÂÖ≥Ê¶ÇÂøµ

- [ËΩØ‰ª∂Êû∂ÊûÑÁêÜËÆ∫](../03-02-ËΩØ‰ª∂Êû∂ÊûÑ/03-02-01-ËΩØ‰ª∂Êû∂ÊûÑÂü∫Á°Ä.md)
- [ÁºñÁ®ãËåÉÂºèÁêÜËÆ∫](../03-03-ÁºñÁ®ãËåÉÂºè/03-03-01-ÁºñÁ®ãËåÉÂºèÂü∫Á°Ä.md)
- [ÂàÜÂ∏ÉÂºèÁ≥ªÁªüÁêÜËÆ∫](../03-04-ÂàÜÂ∏ÉÂºèÁ≥ªÁªü/03-04-01-ÂàÜÂ∏ÉÂºèÁ≥ªÁªüÂü∫Á°Ä.md)
- [ÁÆóÊ≥ïÁêÜËÆ∫](../../02-ÁêÜËÆ∫Âü∫Á°Ä/02-01-ÁÆóÊ≥ïÁêÜËÆ∫/02-01-01-ÁÆóÊ≥ïÂü∫Á°Ä.md)

## üìà Â∫îÁî®ÂÆû‰æã

### 1. ËÆæËÆ°Ê®°ÂºèÂ∫îÁî®ÂàÜÊûê

```python
class DesignPatternAnalyzer:
    """ËÆæËÆ°Ê®°ÂºèÂàÜÊûêÂô®"""
    
    def __init__(self):
        self.analysis_results = {}
    
    def analyze_pattern_usage(self, pattern: DesignPattern, context: Dict[str, Any]) -> Dict[str, Any]:
        """ÂàÜÊûêÊ®°Âºè‰ΩøÁî®ÊÉÖÂÜµ"""
        analysis = {
            "pattern_name": pattern.specification.name,
            "context": context,
            "applicability": self._assess_applicability(pattern, context),
            "complexity": self._assess_complexity(pattern),
            "maintainability": self._assess_maintainability(pattern),
            "performance_impact": self._assess_performance_impact(pattern),
            "recommendations": []
        }
        
        # ÁîüÊàêÂª∫ËÆÆ
        if analysis["complexity"] > 0.7:
            analysis["recommendations"].append("ËÄÉËôë‰ΩøÁî®Êõ¥ÁÆÄÂçïÁöÑÊ®°Âºè")
        
        if analysis["maintainability"] < 0.5:
            analysis["recommendations"].append("ÈúÄË¶ÅÊîπËøõ‰ª£Á†ÅÁªìÊûÑ")
        
        if analysis["performance_impact"] > 0.8:
            analysis["recommendations"].append("ËÄÉËôëÊÄßËÉΩ‰ºòÂåñ")
        
        return analysis
    
    def _assess_applicability(self, pattern: DesignPattern, context: Dict[str, Any]) -> float:
        """ËØÑ‰º∞ÈÄÇÁî®ÊÄß"""
        # ÁÆÄÂåñÁöÑÈÄÇÁî®ÊÄßËØÑ‰º∞
        score = 0.0
        
        # Ê£ÄÊü•ÈóÆÈ¢òÂåπÈÖçÂ∫¶
        if "problem" in context and context["problem"] in pattern.specification.problem:
            score += 0.3
        
        # Ê£ÄÊü•‰∏ä‰∏ãÊñáÂåπÈÖçÂ∫¶
        if "context" in context and context["context"] in pattern.specification.description:
            score += 0.3
        
        # Ê£ÄÊü•Ëß£ÂÜ≥ÊñπÊ°àÂåπÈÖçÂ∫¶
        if "solution" in context and context["solution"] in pattern.specification.solution:
            score += 0.4
        
        return min(score, 1.0)
    
    def _assess_complexity(self, pattern: DesignPattern) -> float:
        """ËØÑ‰º∞Â§çÊùÇÂ∫¶"""
        # Âü∫‰∫éÂèÇ‰∏éËÄÖÊï∞ÈáèËØÑ‰º∞Â§çÊùÇÂ∫¶
        participants_count = len(pattern.specification.participants)
        return min(participants_count / 10.0, 1.0)
    
    def _assess_maintainability(self, pattern: DesignPattern) -> float:
        """ËØÑ‰º∞ÂèØÁª¥Êä§ÊÄß"""
        # Âü∫‰∫éÂêéÊûúËØÑ‰º∞ÂèØÁª¥Êä§ÊÄß
        positive_consequences = 0
        total_consequences = len(pattern.specification.consequences)
        
        for consequence in pattern.specification.consequences:
            if any(word in consequence.lower() for word in ["ÊùæËÄ¶Âêà", "ÂèØÊâ©Â±ï", "ÂèØÁª¥Êä§", "ÁÅµÊ¥ª"]):
                positive_consequences += 1
        
        return positive_consequences / total_consequences if total_consequences > 0 else 0.5
    
    def _assess_performance_impact(self, pattern: DesignPattern) -> float:
        """ËØÑ‰º∞ÊÄßËÉΩÂΩ±Âìç"""
        # Âü∫‰∫éÊ®°ÂºèÁ±ªÂûãËØÑ‰º∞ÊÄßËÉΩÂΩ±Âìç
        pattern_type = pattern.specification.pattern_type
        
        if pattern_type == PatternType.CREATIONAL:
            return 0.2  # ÂàõÂª∫ÂûãÊ®°ÂºèÈÄöÂ∏∏ÊÄßËÉΩÂΩ±ÂìçËæÉÂ∞è
        elif pattern_type == PatternType.STRUCTURAL:
            return 0.5  # ÁªìÊûÑÂûãÊ®°ÂºèÂèØËÉΩÊúâ‰∏≠Á≠âÊÄßËÉΩÂΩ±Âìç
        else:  # BEHAVIORAL
            return 0.7  # Ë°å‰∏∫ÂûãÊ®°ÂºèÂèØËÉΩÊúâËæÉÂ§ßÊÄßËÉΩÂΩ±Âìç
    
    def compare_patterns(self, patterns: List[DesignPattern], context: Dict[str, Any]) -> Dict[str, Any]:
        """ÊØîËæÉÂ§ö‰∏™ËÆæËÆ°Ê®°Âºè"""
        comparison = {
            "context": context,
            "patterns": {},
            "recommendations": []
        }
        
        for pattern in patterns:
            analysis = self.analyze_pattern_usage(pattern, context)
            comparison["patterns"][pattern.specification.name] = analysis
        
        # ÁîüÊàêÊØîËæÉÂª∫ËÆÆ
        best_pattern = max(
            comparison["patterns"].items(),
            key=lambda x: x[1]["applicability"]
        )
        
        comparison["recommendations"].append(f"Êé®Ëçê‰ΩøÁî® {best_pattern[0]} Ê®°Âºè")
        
        return comparison
    
    def generate_pattern_selection_guide(self, problem_description: str) -> Dict[str, Any]:
        """ÁîüÊàêÊ®°ÂºèÈÄâÊã©ÊåáÂçó"""
        guide = {
            "problem": problem_description,
            "suggested_patterns": [],
            "selection_criteria": {},
            "decision_matrix": {}
        }
        
        # Âü∫‰∫éÈóÆÈ¢òÊèèËø∞Êé®ËçêÊ®°Âºè
        problem_lower = problem_description.lower()
        
        if "ÂàõÂª∫" in problem_lower or "ÂÆû‰æãÂåñ" in problem_lower:
            guide["suggested_patterns"].extend(["Â∑•ÂéÇÊ®°Âºè", "Âçï‰æãÊ®°Âºè", "Âª∫ÈÄ†ËÄÖÊ®°Âºè"])
        
        if "ÁªìÊûÑ" in problem_lower or "ÁªÑÂêà" in problem_lower:
            guide["suggested_patterns"].extend(["ÈÄÇÈÖçÂô®Ê®°Âºè", "Ë£ÖÈ•∞Âô®Ê®°Âºè", "‰ª£ÁêÜÊ®°Âºè"])
        
        if "Ë°å‰∏∫" in problem_lower or "ÈÄö‰ø°" in problem_lower:
            guide["suggested_patterns"].extend(["ËßÇÂØüËÄÖÊ®°Âºè", "Á≠ñÁï•Ê®°Âºè", "ÂëΩ‰ª§Ê®°Âºè"])
        
        # ÈÄâÊã©Ê†áÂáÜ
        guide["selection_criteria"] = {
            "ÈÄÇÁî®ÊÄß": "Ê®°ÂºèÊòØÂê¶ÈÄÇÂêàËß£ÂÜ≥ÂΩìÂâçÈóÆÈ¢ò",
            "Â§çÊùÇÂ∫¶": "Ê®°ÂºèÁöÑÂÆûÁé∞Â§çÊùÇÂ∫¶",
            "ÂèØÁª¥Êä§ÊÄß": "Ê®°ÂºèÁöÑÂèØÁª¥Êä§ÊÄß",
            "ÊÄßËÉΩ": "Ê®°ÂºèÂØπÊÄßËÉΩÁöÑÂΩ±Âìç"
        }
        
        return guide

# ‰ΩøÁî®Á§∫‰æã
def demonstrate_pattern_analysis():
    """ÊºîÁ§∫ËÆæËÆ°Ê®°ÂºèÂàÜÊûê"""
    
    # ÂàõÂª∫ÂàÜÊûêÂô®
    analyzer = DesignPatternAnalyzer()
    
    # ÂàõÂª∫ËÆæËÆ°Ê®°Âºè
    singleton = SingletonPattern()
    factory = FactoryPattern()
    observer = ObserverPattern()
    
    # ÂàÜÊûêÊ®°Âºè‰ΩøÁî®ÊÉÖÂÜµ
    context = {
        "problem": "ÈúÄË¶ÅÁ°Æ‰øùÊï∞ÊçÆÂ∫ìËøûÊé•ÁöÑÂîØ‰∏ÄÊÄß",
        "context": "Êï∞ÊçÆÂ∫ìËøûÊé•ÁÆ°ÁêÜ",
        "solution": "‰ΩøÁî®Âçï‰æãÊ®°ÂºèÁÆ°ÁêÜËøûÊé•"
    }
    
    singleton_analysis = analyzer.analyze_pattern_usage(singleton, context)
    
    print("=== Âçï‰æãÊ®°ÂºèÂàÜÊûê ===")
    print(f"ÈÄÇÁî®ÊÄß: {singleton_analysis['applicability']:.2f}")
    print(f"Â§çÊùÇÂ∫¶: {singleton_analysis['complexity']:.2f}")
    print(f"ÂèØÁª¥Êä§ÊÄß: {singleton_analysis['maintainability']:.2f}")
    print(f"ÊÄßËÉΩÂΩ±Âìç: {singleton_analysis['performance_impact']:.2f}")
    print(f"Âª∫ËÆÆ: {singleton_analysis['recommendations']}")
    
    # ÊØîËæÉÂ§ö‰∏™Ê®°Âºè
    patterns = [singleton, factory, observer]
    comparison = analyzer.compare_patterns(patterns, context)
    
    print("\n=== Ê®°ÂºèÊØîËæÉ ===")
    for pattern_name, analysis in comparison["patterns"].items():
        print(f"{pattern_name}: ÈÄÇÁî®ÊÄß {analysis['applicability']:.2f}")
    
    print(f"Êé®Ëçê: {comparison['recommendations']}")
    
    # ÁîüÊàêÈÄâÊã©ÊåáÂçó
    problem = "ÈúÄË¶ÅÊ†πÊçÆÁî®Êà∑Á±ªÂûãÂàõÂª∫‰∏çÂêåÁöÑÁî®Êà∑ÁïåÈù¢"
    guide = analyzer.generate_pattern_selection_guide(problem)
    
    print(f"\n=== Ê®°ÂºèÈÄâÊã©ÊåáÂçó ===")
    print(f"ÈóÆÈ¢ò: {guide['problem']}")
    print(f"Âª∫ËÆÆÊ®°Âºè: {guide['suggested_patterns']}")

if __name__ == "__main__":
    demonstrate_pattern_analysis()
```

### 2. ËÆæËÆ°Ê®°ÂºèÂÆûÁé∞ÁîüÊàêÂô®

```python
class PatternCodeGenerator:
    """ËÆæËÆ°Ê®°Âºè‰ª£Á†ÅÁîüÊàêÂô®"""
    
    def __init__(self):
        self.templates = {}
        self.generated_code = {}
    
    def generate_pattern_code(self, pattern: DesignPattern, customizations: Dict[str, Any]) -> str:
        """ÁîüÊàêÊ®°Âºè‰ª£Á†Å"""
        pattern_name = pattern.specification.name
        
        if pattern_name == "Âçï‰æãÊ®°Âºè":
            return self._generate_singleton_code(customizations)
        elif pattern_name == "Â∑•ÂéÇÊ®°Âºè":
            return self._generate_factory_code(customizations)
        elif pattern_name == "ËßÇÂØüËÄÖÊ®°Âºè":
            return self._generate_observer_code(customizations)
        else:
            return self._generate_generic_pattern_code(pattern, customizations)
    
    def _generate_singleton_code(self, customizations: Dict[str, Any]) -> str:
        """ÁîüÊàêÂçï‰æãÊ®°Âºè‰ª£Á†Å"""
        class_name = customizations.get("class_name", "MySingleton")
        attributes = customizations.get("attributes", {})
        
        code = f"""
class {class_name}:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
"""
        
        # Ê∑ªÂä†Â±ûÊÄß
        for attr_name, attr_value in attributes.items():
            code += f"            self.{attr_name} = {repr(attr_value)}\n"
        
        code += f"""
    def get_instance(self):
        return self
    
    def __str__(self):
        return f"{class_name}()"
"""
        
        return code
    
    def _generate_factory_code(self, customizations: Dict[str, Any]) -> str:
        """ÁîüÊàêÂ∑•ÂéÇÊ®°Âºè‰ª£Á†Å"""
        product_name = customizations.get("product_name", "Product")
        concrete_products = customizations.get("concrete_products", ["ConcreteProduct1", "ConcreteProduct2"])
        
        code = f"""
from abc import ABC, abstractmethod

class {product_name}(ABC):
    @abstractmethod
    def operation(self):
        pass
"""
        
        # ÁîüÊàêÂÖ∑‰Ωì‰∫ßÂìÅÁ±ª
        for product in concrete_products:
            code += f"""

class {product}({product_name}):
    def operation(self):
        return f"{product} ÁöÑÊìç‰Ωú"
"""
        
        code += f"""

class {product_name}Factory(ABC):
    @abstractmethod
    def create_product(self) -> {product_name}:
        pass

class ConcreteFactory({product_name}Factory):
    def __init__(self, product_type: str):
        self.product_type = product_type
    
    def create_product(self) -> {product_name}:
        if self.product_type == "{concrete_products[0]}":
            return {concrete_products[0]}()
        elif self.product_type == "{concrete_products[1]}":
            return {concrete_products[1]}()
        else:
            raise ValueError(f"Êú™Áü•ÁöÑ‰∫ßÂìÅÁ±ªÂûã: {{self.product_type}}")
"""
        
        return code
    
    def _generate_observer_code(self, customizations: Dict[str, Any]) -> str:
        """ÁîüÊàêËßÇÂØüËÄÖÊ®°Âºè‰ª£Á†Å"""
        subject_name = customizations.get("subject_name", "Subject")
        observer_name = customizations.get("observer_name", "Observer")
        events = customizations.get("events", ["event1", "event2"])
        
        code = f"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class {observer_name}(ABC):
    @abstractmethod
    def update(self, subject, event: str, data: Any = None):
        pass

class {subject_name}(ABC):
    def __init__(self):
        self._observers: List[{observer_name}] = []
        self._state: Dict[str, Any] = {{}}
    
    def attach(self, observer: {observer_name}):
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: {observer_name}):
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify(self, event: str, data: Any = None):
        for observer in self._observers:
            observer.update(self, event, data)

class Concrete{subject_name}({subject_name}):
    def __init__(self):
        super().__init__()
"""
        
        # Ê∑ªÂä†‰∫ã‰ª∂Â±ûÊÄß
        for event in events:
            code += f"        self.{event} = None\n"
        
        code += f"""
    def set_state(self, event: str, value: Any):
        if hasattr(self, event):
            setattr(self, event, value)
            self.notify(event, value)

class Concrete{observer_name}({observer_name}):
    def __init__(self, name: str):
        self.name = name
    
    def update(self, subject, event: str, data: Any = None):
        print(f"{{self.name}} Êî∂Âà∞‰∫ã‰ª∂ {{event}}: {{data}}")
"""
        
        return code
    
    def _generate_generic_pattern_code(self, pattern: DesignPattern, customizations: Dict[str, Any]) -> str:
        """ÁîüÊàêÈÄöÁî®Ê®°Âºè‰ª£Á†Å"""
        return f"""
# {pattern.specification.name} Ê®°ÂºèÂÆûÁé∞
# ÈóÆÈ¢ò: {pattern.specification.problem}
# Ëß£ÂÜ≥ÊñπÊ°à: {pattern.specification.solution}

class {pattern.specification.name.replace('Ê®°Âºè', '')}:
    def __init__(self):
        pass
    
    def apply(self, context):
        # Âú®ËøôÈáåÂÆûÁé∞ÂÖ∑‰ΩìÁöÑÊ®°ÂºèÈÄªËæë
        pass
"""

# ‰ΩøÁî®Á§∫‰æã
def demonstrate_code_generation():
    """ÊºîÁ§∫‰ª£Á†ÅÁîüÊàê"""
    
    # ÂàõÂª∫‰ª£Á†ÅÁîüÊàêÂô®
    generator = PatternCodeGenerator()
    
    # ÂàõÂª∫ËÆæËÆ°Ê®°Âºè
    singleton = SingletonPattern()
    factory = FactoryPattern()
    observer = ObserverPattern()
    
    # ÁîüÊàêÂçï‰æãÊ®°Âºè‰ª£Á†Å
    singleton_customizations = {
        "class_name": "DatabaseConnection",
        "attributes": {
            "connection_string": "localhost:5432",
            "max_connections": 10
        }
    }
    
    singleton_code = generator.generate_pattern_code(singleton, singleton_customizations)
    print("=== ÁîüÊàêÁöÑÂçï‰æãÊ®°Âºè‰ª£Á†Å ===")
    print(singleton_code)
    
    # ÁîüÊàêÂ∑•ÂéÇÊ®°Âºè‰ª£Á†Å
    factory_customizations = {
        "product_name": "Vehicle",
        "concrete_products": ["Car", "Motorcycle", "Bicycle"]
    }
    
    factory_code = generator.generate_pattern_code(factory, factory_customizations)
    print("\n=== ÁîüÊàêÁöÑÂ∑•ÂéÇÊ®°Âºè‰ª£Á†Å ===")
    print(factory_code)
    
    # ÁîüÊàêËßÇÂØüËÄÖÊ®°Âºè‰ª£Á†Å
    observer_customizations = {
        "subject_name": "WeatherStation",
        "observer_name": "WeatherDisplay",
        "events": ["temperature", "humidity", "pressure"]
    }
    
    observer_code = generator.generate_pattern_code(observer, observer_customizations)
    print("\n=== ÁîüÊàêÁöÑËßÇÂØüËÄÖÊ®°Âºè‰ª£Á†Å ===")
    print(observer_code)

if __name__ == "__main__":
    demonstrate_code_generation()
```

## üéØ ÊÄªÁªì

ËÆæËÆ°Ê®°Âºè‰∏∫ËΩØ‰ª∂ËÆæËÆ°Êèê‰æõ‰∫ÜÈáçË¶ÅÁöÑÁêÜËÆ∫Âü∫Á°Ä„ÄÇÈÄöËøáÂΩ¢ÂºèÂåñÂÆö‰πâ„ÄÅÂ§öË°®ÂæÅÊñπÂºèÂíåÂÆûÈôÖÂ∫îÁî®ÔºåÊàë‰ª¨Âª∫Á´ã‰∫ÜÂÆåÊï¥ÁöÑËÆæËÆ°Ê®°Âºè‰ΩìÁ≥ªÔºå‰∏∫ËΩØ‰ª∂Êû∂ÊûÑÂíåËÆæËÆ°Êèê‰æõ‰∫ÜÊåáÂØº„ÄÇ

### ÂÖ≥ÈîÆË¶ÅÁÇπ

1. **ÂΩ¢ÂºèÂåñÂÆö‰πâ**: ËÆæËÆ°Ê®°ÂºèÂèØ‰ª•Áî®‰∫îÂÖÉÁªÑ $\mathcal{P} = (N, C, S, F, E)$ Ë°®Á§∫
2. **Ê®°ÂºèÂàÜÁ±ª**: ÂàõÂª∫Âûã„ÄÅÁªìÊûÑÂûã„ÄÅË°å‰∏∫Âûã‰∏âÂ§ßÁ±ª
3. **Â§öË°®ÂæÅÊñπÂºè**: ÂåÖÂê´Ê¶ÇÂøµËß£Èáä„ÄÅÊï∞Â≠¶ÂΩ¢Âºè„ÄÅ‰ª£Á†ÅÂÆûÁé∞„ÄÅÂõæË°®ËØ¥ÊòéÂíåÂÆû‰æãÂàÜÊûê
4. **ÂÆûÈôÖÂ∫îÁî®**: ÈÄöËøáPythonÂÆûÁé∞È™åËØÅÊ®°ÂºèÊ¶ÇÂøµ
5. **ÁêÜËÆ∫ËØÅÊòé**: Êèê‰æõÊúâÊïàÊÄßÂÆöÁêÜÂíåÁªÑÂêàÂÆöÁêÜÁöÑËØÅÊòé

---

**Áõ∏ÂÖ≥ÊñáÊ°£**: 
- [ÂàõÂª∫ÂûãÊ®°Âºè](./03-01-02-ÂàõÂª∫ÂûãÊ®°Âºè.md)
- [ÁªìÊûÑÂûãÊ®°Âºè](./03-01-03-ÁªìÊûÑÂûãÊ®°Âºè.md)
- [Ë°å‰∏∫ÂûãÊ®°Âºè](./03-01-04-Ë°å‰∏∫ÂûãÊ®°Âºè.md)
- [ËΩØ‰ª∂Êû∂ÊûÑÂü∫Á°Ä](../03-02-ËΩØ‰ª∂Êû∂ÊûÑ/03-02-01-ËΩØ‰ª∂Êû∂ÊûÑÂü∫Á°Ä.md)
