# 03-05-01 åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ç”±å¤šä¸ªç‹¬ç«‹è®¡ç®—æœºç»„æˆçš„ç³»ç»Ÿï¼Œè¿™äº›è®¡ç®—æœºé€šè¿‡ç½‘ç»œè¿›è¡Œé€šä¿¡å’Œåè°ƒã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µï¼Œæä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜ï¼Œå¹¶é€šè¿‡Pythonä»£ç å®ç°ç›¸å…³åˆ†å¸ƒå¼ç®—æ³•ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. åˆ†å¸ƒå¼ç³»ç»Ÿå®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (åˆ†å¸ƒå¼ç³»ç»Ÿ)
åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$DS = (N, C, P)$$
å…¶ä¸­ï¼š
- $N$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $C$ æ˜¯é€šä¿¡ç½‘ç»œ
- $P$ æ˜¯åè®®é›†åˆ

**å®šä¹‰ 1.2** (èŠ‚ç‚¹)
èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$n = (id, state, neighbors, protocol)$$
å…¶ä¸­ $id$ æ˜¯èŠ‚ç‚¹æ ‡è¯†ç¬¦ï¼Œ$state$ æ˜¯èŠ‚ç‚¹çŠ¶æ€ï¼Œ$neighbors$ æ˜¯é‚»å±…èŠ‚ç‚¹é›†åˆï¼Œ$protocol$ æ˜¯åè®®ã€‚

**å®šä¹‰ 1.3** (é€šä¿¡ç½‘ç»œ)
é€šä¿¡ç½‘ç»œæ˜¯ä¸€ä¸ªå›¾ï¼š
$$C = (N, E)$$
å…¶ä¸­ $N$ æ˜¯èŠ‚ç‚¹é›†åˆï¼Œ$E$ æ˜¯è¾¹é›†åˆï¼Œè¡¨ç¤ºèŠ‚ç‚¹é—´çš„é€šä¿¡é“¾è·¯ã€‚

#### 1.2 åˆ†å¸ƒå¼ç³»ç»Ÿå±æ€§å®šç†

**å®šç† 1.1** (åˆ†å¸ƒå¼ç³»ç»Ÿè¿é€šæ€§)
å¦‚æœåˆ†å¸ƒå¼ç³»ç»Ÿ $DS$ æ˜¯è¿é€šçš„ï¼Œåˆ™ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´éƒ½å­˜åœ¨é€šä¿¡è·¯å¾„ã€‚

**è¯æ˜**:
1. è®¾ $DS = (N, C, P)$ æ˜¯è¿é€šåˆ†å¸ƒå¼ç³»ç»Ÿ
2. æ ¹æ®è¿é€šæ€§å®šä¹‰ï¼Œé€šä¿¡ç½‘ç»œ $C$ æ˜¯è¿é€šå›¾
3. å› æ­¤ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´éƒ½å­˜åœ¨è·¯å¾„

### 2. ä¸€è‡´æ€§ç®—æ³•

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1** (ä¸€è‡´æ€§)
åˆ†å¸ƒå¼ç³»ç»Ÿè¾¾åˆ°ä¸€è‡´æ€§ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall n_1, n_2 \in N: \text{State}(n_1) = \text{State}(n_2)$$

**å®šä¹‰ 2.2** (Paxosç®—æ³•)
Paxosç®—æ³•æ»¡è¶³ï¼š
- **å®‰å…¨æ€§**: å¦‚æœå€¼è¢«é€‰æ‹©ï¼Œåˆ™æ‰€æœ‰èŠ‚ç‚¹æœ€ç»ˆå­¦ä¹ åˆ°è¯¥å€¼
- **æ´»æ€§**: å¦‚æœæè®®è€…æè®®å€¼ï¼Œåˆ™æœ€ç»ˆä¼šé€‰æ‹©ä¸€ä¸ªå€¼

**å®šä¹‰ 2.3** (Raftç®—æ³•)
Raftç®—æ³•å°†æ—¶é—´åˆ’åˆ†ä¸ºä»»æœŸï¼Œæ¯ä¸ªä»»æœŸæœ€å¤šæœ‰ä¸€ä¸ªé¢†å¯¼è€…ã€‚

#### 2.2 ä¸€è‡´æ€§ç®—æ³•å®šç†

**å®šç† 2.1** (Paxoså®‰å…¨æ€§)
Paxosç®—æ³•ä¿è¯å®‰å…¨æ€§ï¼šå¦‚æœå€¼ $v$ è¢«é€‰æ‹©ï¼Œåˆ™æ‰€æœ‰èŠ‚ç‚¹æœ€ç»ˆå­¦ä¹ åˆ° $v$ã€‚

**è¯æ˜**:
1. è®¾å€¼ $v$ è¢«é€‰æ‹©ï¼Œææ¡ˆç¼–å·ä¸º $n$
2. æ ¹æ®Paxosè§„åˆ™ï¼Œä»»ä½•æ›´é«˜ç¼–å·çš„ææ¡ˆå¿…é¡»æè®®å€¼ $v$
3. å› æ­¤æ‰€æœ‰èŠ‚ç‚¹æœ€ç»ˆå­¦ä¹ åˆ° $v$

### 3. å®¹é”™æœºåˆ¶

#### 3.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 3.1** (æ•…éšœæ¨¡å‹)
æ•…éšœæ¨¡å‹å®šä¹‰èŠ‚ç‚¹å¯èƒ½çš„æ•…éšœç±»å‹ï¼š
$$F = \{crash, byzantine, omission\}$$

**å®šä¹‰ 3.2** (å®¹é”™æ€§)
ç³»ç»Ÿå®¹é”™æ€§å®šä¹‰ä¸ºï¼š
$$T(S) = \frac{\text{æœ€å¤§æ•…éšœèŠ‚ç‚¹æ•°}}{\text{æ€»èŠ‚ç‚¹æ•°}}$$

**å®šä¹‰ 3.3** (æ‹œå åº­å®¹é”™)
æ‹œå åº­å®¹é”™è¦æ±‚ï¼š
$$\text{æ€»èŠ‚ç‚¹æ•°} > 3f$$
å…¶ä¸­ $f$ æ˜¯æ‹œå åº­æ•…éšœèŠ‚ç‚¹æ•°ã€‚

#### 3.2 å®¹é”™æœºåˆ¶å®šç†

**å®šç† 3.1** (æ‹œå åº­å®¹é”™ä¸‹é™)
æ‹œå åº­å®¹é”™éœ€è¦è‡³å°‘ $3f + 1$ ä¸ªèŠ‚ç‚¹æ‰èƒ½å®¹å¿ $f$ ä¸ªæ‹œå åº­æ•…éšœã€‚

**è¯æ˜**:
1. è®¾ç³»ç»Ÿæœ‰ $n$ ä¸ªèŠ‚ç‚¹ï¼Œå…¶ä¸­ $f$ ä¸ªæ‹œå åº­æ•…éšœ
2. æ­£ç¡®èŠ‚ç‚¹æ•°ä¸º $n - f$
3. ä¸ºäº†è¾¾æˆä¸€è‡´ï¼Œæ­£ç¡®èŠ‚ç‚¹æ•°å¿…é¡»å¤§äºæ•…éšœèŠ‚ç‚¹æ•°
4. å› æ­¤ $n - f > f$ï¼Œå³ $n > 2f$
5. è€ƒè™‘æœ€åæƒ…å†µï¼Œéœ€è¦ $n \geq 3f + 1$

## ğŸ Pythonå®ç°

### 1. åŸºç¡€åˆ†å¸ƒå¼ç³»ç»Ÿæ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
import uuid
import time
import threading
import queue
import random
import networkx as nx

class NodeState(Enum):
    """èŠ‚ç‚¹çŠ¶æ€æšä¸¾"""
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    LEADER = "leader"
    CRASHED = "crashed"

class MessageType(Enum):
    """æ¶ˆæ¯ç±»å‹æšä¸¾"""
    HEARTBEAT = "heartbeat"
    VOTE_REQUEST = "vote_request"
    VOTE_RESPONSE = "vote_response"
    APPEND_ENTRIES = "append_entries"
    APPEND_RESPONSE = "append_response"
    PROPOSE = "propose"
    ACCEPT = "accept"
    LEARN = "learn"

@dataclass
class Message:
    """æ¶ˆæ¯ç±»"""
    id: str
    type: MessageType
    sender: str
    receiver: str
    data: Any
    timestamp: float = field(default_factory=time.time)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Node:
    """èŠ‚ç‚¹ç±»"""
    id: str
    address: str
    state: NodeState = NodeState.FOLLOWER
    neighbors: Set[str] = field(default_factory=set)
    data: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

class DistributedSystem:
    """åˆ†å¸ƒå¼ç³»ç»Ÿç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.nodes: Dict[str, Node] = {}
        self.network: nx.Graph = nx.Graph()
        self.message_queue: queue.Queue = queue.Queue()
        self.running = False
        self.threads: List[threading.Thread] = []
    
    def add_node(self, node: Node) -> None:
        """æ·»åŠ èŠ‚ç‚¹"""
        self.nodes[node.id] = node
        self.network.add_node(node.id)
    
    def add_connection(self, node1_id: str, node2_id: str) -> None:
        """æ·»åŠ è¿æ¥"""
        if node1_id in self.nodes and node2_id in self.nodes:
            self.network.add_edge(node1_id, node2_id)
            self.nodes[node1_id].neighbors.add(node2_id)
            self.nodes[node2_id].neighbors.add(node1_id)
    
    def send_message(self, message: Message) -> None:
        """å‘é€æ¶ˆæ¯"""
        if message.receiver in self.nodes:
            self.message_queue.put(message)
    
    def broadcast_message(self, message: Message) -> None:
        """å¹¿æ’­æ¶ˆæ¯"""
        for node_id in self.nodes:
            if node_id != message.sender:
                broadcast_msg = Message(
                    id="",
                    type=message.type,
                    sender=message.sender,
                    receiver=node_id,
                    data=message.data
                )
                self.send_message(broadcast_msg)
    
    def start(self) -> None:
        """å¯åŠ¨ç³»ç»Ÿ"""
        self.running = True
        
        # å¯åŠ¨æ¶ˆæ¯å¤„ç†çº¿ç¨‹
        for node_id in self.nodes:
            thread = threading.Thread(target=self._message_processor, args=(node_id,), daemon=True)
            thread.start()
            self.threads.append(thread)
    
    def stop(self) -> None:
        """åœæ­¢ç³»ç»Ÿ"""
        self.running = False
    
    def _message_processor(self, node_id: str) -> None:
        """æ¶ˆæ¯å¤„ç†å™¨"""
        while self.running:
            try:
                # å¤„ç†å‘é€ç»™è¯¥èŠ‚ç‚¹çš„æ¶ˆæ¯
                messages = []
                while not self.message_queue.empty():
                    try:
                        msg = self.message_queue.get_nowait()
                        if msg.receiver == node_id:
                            messages.append(msg)
                    except queue.Empty:
                        break
                
                for message in messages:
                    self._handle_message(node_id, message)
                
                time.sleep(0.1)  # é¿å…è¿‡åº¦å ç”¨CPU
                
            except Exception as e:
                print(f"èŠ‚ç‚¹ {node_id} æ¶ˆæ¯å¤„ç†é”™è¯¯: {e}")
    
    def _handle_message(self, node_id: str, message: Message) -> None:
        """å¤„ç†æ¶ˆæ¯"""
        node = self.nodes[node_id]
        
        if message.type == MessageType.HEARTBEAT:
            # å¤„ç†å¿ƒè·³æ¶ˆæ¯
            self._handle_heartbeat(node, message)
        elif message.type == MessageType.VOTE_REQUEST:
            # å¤„ç†æŠ•ç¥¨è¯·æ±‚
            self._handle_vote_request(node, message)
        elif message.type == MessageType.PROPOSE:
            # å¤„ç†æè®®
            self._handle_propose(node, message)
        # å¯ä»¥æ·»åŠ æ›´å¤šæ¶ˆæ¯ç±»å‹å¤„ç†
    
    def _handle_heartbeat(self, node: Node, message: Message) -> None:
        """å¤„ç†å¿ƒè·³æ¶ˆæ¯"""
        # ç®€å•çš„å¿ƒè·³å¤„ç†
        pass
    
    def _handle_vote_request(self, node: Node, message: Message) -> None:
        """å¤„ç†æŠ•ç¥¨è¯·æ±‚"""
        # ç®€å•çš„æŠ•ç¥¨å¤„ç†
        pass
    
    def _handle_propose(self, node: Node, message: Message) -> None:
        """å¤„ç†æè®®"""
        # ç®€å•çš„æè®®å¤„ç†
        pass
    
    def get_system_status(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        return {
            "name": self.name,
            "node_count": len(self.nodes),
            "connection_count": self.network.number_of_edges(),
            "is_connected": nx.is_connected(self.network),
            "nodes": {
                node_id: {
                    "id": node.id,
                    "address": node.address,
                    "state": node.state.value,
                    "neighbor_count": len(node.neighbors)
                }
                for node_id, node in self.nodes.items()
            }
        }
```

### 2. Raftå…±è¯†ç®—æ³•å®ç°

```python
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass, field
import random

@dataclass
class LogEntry:
    """æ—¥å¿—æ¡ç›®"""
    term: int
    index: int
    command: Any
    timestamp: float = field(default_factory=time.time)

@dataclass
class RaftNode(Node):
    """RaftèŠ‚ç‚¹"""
    current_term: int = 0
    voted_for: Optional[str] = None
    log: List[LogEntry] = field(default_factory=list)
    commit_index: int = 0
    last_applied: int = 0
    next_index: Dict[str, int] = field(default_factory=dict)
    match_index: Dict[str, int] = field(default_factory=dict)
    election_timeout: float = 0.0
    last_heartbeat: float = 0.0
    
    def __post_init__(self):
        super().__post_init__()
        self.election_timeout = random.uniform(150, 300) / 1000  # 150-300ms
        self.last_heartbeat = time.time()

class RaftSystem(DistributedSystem):
    """Raftç³»ç»Ÿ"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.raft_nodes: Dict[str, RaftNode] = {}
    
    def add_raft_node(self, node: RaftNode) -> None:
        """æ·»åŠ RaftèŠ‚ç‚¹"""
        self.add_node(node)
        self.raft_nodes[node.id] = node
    
    def start_election(self, node_id: str) -> None:
        """å¼€å§‹é€‰ä¸¾"""
        node = self.raft_nodes[node_id]
        node.current_term += 1
        node.state = NodeState.CANDIDATE
        node.voted_for = node_id
        
        # å‘é€æŠ•ç¥¨è¯·æ±‚
        vote_request = Message(
            id="",
            type=MessageType.VOTE_REQUEST,
            sender=node_id,
            receiver="",  # å¹¿æ’­
            data={
                "term": node.current_term,
                "candidate_id": node_id,
                "last_log_index": len(node.log) - 1,
                "last_log_term": node.log[-1].term if node.log else 0
            }
        )
        self.broadcast_message(vote_request)
    
    def handle_vote_request(self, node: RaftNode, message: Message) -> None:
        """å¤„ç†æŠ•ç¥¨è¯·æ±‚"""
        data = message.data
        term = data["term"]
        candidate_id = data["candidate_id"]
        
        if term < node.current_term:
            # æ‹’ç»æŠ•ç¥¨
            response = Message(
                id="",
                type=MessageType.VOTE_RESPONSE,
                sender=node.id,
                receiver=candidate_id,
                data={"term": node.current_term, "vote_granted": False}
            )
            self.send_message(response)
            return
        
        if term > node.current_term:
            node.current_term = term
            node.state = NodeState.FOLLOWER
            node.voted_for = None
        
        # æ£€æŸ¥æ˜¯å¦å¯ä»¥æŠ•ç¥¨
        can_vote = (node.voted_for is None or node.voted_for == candidate_id)
        
        if can_vote:
            # æ£€æŸ¥æ—¥å¿—å®Œæ•´æ€§
            last_log_index = data["last_log_index"]
            last_log_term = data["last_log_term"]
            
            if (last_log_term > (node.log[-1].term if node.log else 0) or
                (last_log_term == (node.log[-1].term if node.log else 0) and
                 last_log_index >= len(node.log) - 1)):
                
                node.voted_for = candidate_id
                vote_granted = True
            else:
                vote_granted = False
        else:
            vote_granted = False
        
        response = Message(
            id="",
            type=MessageType.VOTE_RESPONSE,
            sender=node.id,
            receiver=candidate_id,
            data={"term": node.current_term, "vote_granted": vote_granted}
        )
        self.send_message(response)
    
    def handle_vote_response(self, node: RaftNode, message: Message) -> None:
        """å¤„ç†æŠ•ç¥¨å“åº”"""
        if node.state != NodeState.CANDIDATE:
            return
        
        data = message.data
        term = data["term"]
        vote_granted = data["vote_granted"]
        
        if term > node.current_term:
            node.current_term = term
            node.state = NodeState.FOLLOWER
            node.voted_for = None
            return
        
        if term == node.current_term and vote_granted:
            # ç»Ÿè®¡æŠ•ç¥¨
            votes_received = sum(1 for n in self.raft_nodes.values() 
                               if n.voted_for == node.id)
            
            if votes_received > len(self.raft_nodes) // 2:
                # æˆä¸ºé¢†å¯¼è€…
                self.become_leader(node)
    
    def become_leader(self, node: RaftNode) -> None:
        """æˆä¸ºé¢†å¯¼è€…"""
        node.state = NodeState.LEADER
        
        # åˆå§‹åŒ–é¢†å¯¼è€…çŠ¶æ€
        for neighbor_id in node.neighbors:
            node.next_index[neighbor_id] = len(node.log)
            node.match_index[neighbor_id] = 0
        
        # å‘é€å¿ƒè·³
        self.send_heartbeat(node)
    
    def send_heartbeat(self, node: RaftNode) -> None:
        """å‘é€å¿ƒè·³"""
        if node.state != NodeState.LEADER:
            return
        
        for neighbor_id in node.neighbors:
            entries = node.log[node.next_index[neighbor_id]:]
            heartbeat = Message(
                id="",
                type=MessageType.APPEND_ENTRIES,
                sender=node.id,
                receiver=neighbor_id,
                data={
                    "term": node.current_term,
                    "leader_id": node.id,
                    "prev_log_index": node.next_index[neighbor_id] - 1,
                    "prev_log_term": (node.log[node.next_index[neighbor_id] - 1].term 
                                    if node.next_index[neighbor_id] > 0 else 0),
                    "entries": [{"term": entry.term, "command": entry.command} 
                              for entry in entries],
                    "leader_commit": node.commit_index
                }
            )
            self.send_message(heartbeat)
        
        node.last_heartbeat = time.time()
    
    def handle_append_entries(self, node: RaftNode, message: Message) -> None:
        """å¤„ç†è¿½åŠ æ¡ç›®"""
        data = message.data
        term = data["term"]
        leader_id = data["leader_id"]
        prev_log_index = data["prev_log_index"]
        prev_log_term = data["prev_log_term"]
        entries = data["entries"]
        leader_commit = data["leader_commit"]
        
        if term < node.current_term:
            # æ‹’ç»è¯·æ±‚
            response = Message(
                id="",
                type=MessageType.APPEND_RESPONSE,
                sender=node.id,
                receiver=leader_id,
                data={"term": node.current_term, "success": False}
            )
            self.send_message(response)
            return
        
        # æ›´æ–°ä»»æœŸå’ŒçŠ¶æ€
        if term > node.current_term:
            node.current_term = term
            node.voted_for = None
        
        node.state = NodeState.FOLLOWER
        node.last_heartbeat = time.time()
        
        # æ£€æŸ¥æ—¥å¿—ä¸€è‡´æ€§
        if (prev_log_index >= len(node.log) or
            (prev_log_index >= 0 and node.log[prev_log_index].term != prev_log_term)):
            response = Message(
                id="",
                type=MessageType.APPEND_RESPONSE,
                sender=node.id,
                receiver=leader_id,
                data={"term": node.current_term, "success": False}
            )
            self.send_message(response)
            return
        
        # è¿½åŠ æ–°æ¡ç›®
        for entry_data in entries:
            entry = LogEntry(
                term=entry_data["term"],
                index=len(node.log),
                command=entry_data["command"]
            )
            node.log.append(entry)
        
        # æ›´æ–°æäº¤ç´¢å¼•
        if leader_commit > node.commit_index:
            node.commit_index = min(leader_commit, len(node.log) - 1)
        
        response = Message(
            id="",
            type=MessageType.APPEND_RESPONSE,
            sender=node.id,
            receiver=leader_id,
            data={"term": node.current_term, "success": True}
        )
        self.send_message(response)
    
    def apply_committed_entries(self, node: RaftNode) -> None:
        """åº”ç”¨å·²æäº¤çš„æ¡ç›®"""
        while node.last_applied < node.commit_index:
            node.last_applied += 1
            entry = node.log[node.last_applied]
            # åº”ç”¨å‘½ä»¤åˆ°çŠ¶æ€æœº
            self._apply_command(node, entry.command)
    
    def _apply_command(self, node: RaftNode, command: Any) -> None:
        """åº”ç”¨å‘½ä»¤"""
        # ç®€å•çš„å‘½ä»¤åº”ç”¨
        if isinstance(command, dict):
            node.data.update(command)
    
    def get_raft_status(self) -> Dict[str, Any]:
        """è·å–RaftçŠ¶æ€"""
        return {
            "nodes": {
                node_id: {
                    "id": node.id,
                    "state": node.state.value,
                    "current_term": node.current_term,
                    "voted_for": node.voted_for,
                    "log_length": len(node.log),
                    "commit_index": node.commit_index,
                    "last_applied": node.last_applied
                }
                for node_id, node in self.raft_nodes.items()
            }
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_raft():
    """æ¼”ç¤ºRaftç®—æ³•"""
    
    # åˆ›å»ºRaftç³»ç»Ÿ
    raft_system = RaftSystem("Rafté›†ç¾¤")
    
    # åˆ›å»ºRaftèŠ‚ç‚¹
    nodes = [
        RaftNode("node1", "192.168.1.10:8080"),
        RaftNode("node2", "192.168.1.11:8080"),
        RaftNode("node3", "192.168.1.12:8080"),
        RaftNode("node4", "192.168.1.13:8080"),
        RaftNode("node5", "192.168.1.14:8080")
    ]
    
    # æ·»åŠ èŠ‚ç‚¹
    for node in nodes:
        raft_system.add_raft_node(node)
    
    # æ·»åŠ è¿æ¥ï¼ˆå…¨è¿æ¥ç½‘ç»œï¼‰
    for i in range(len(nodes)):
        for j in range(i + 1, len(nodes)):
            raft_system.add_connection(nodes[i].id, nodes[j].id)
    
    # å¯åŠ¨ç³»ç»Ÿ
    raft_system.start()
    
    # å¼€å§‹é€‰ä¸¾
    raft_system.start_election("node1")
    
    # ç­‰å¾…ä¸€æ®µæ—¶é—´
    time.sleep(2)
    
    # è·å–çŠ¶æ€
    status = raft_system.get_raft_status()
    print(f"RaftçŠ¶æ€: {status}")
    
    return raft_system
```

### 3. æ‹œå åº­å®¹é”™å®ç°

```python
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass, field
import hashlib

@dataclass
class ByzantineNode(Node):
    """æ‹œå åº­èŠ‚ç‚¹"""
    is_byzantine: bool = False
    received_messages: Dict[str, List[Message]] = field(default_factory=dict)
    consensus_value: Optional[Any] = None
    round_number: int = 0
    
    def __post_init__(self):
        super().__post_init__()
        self.received_messages = {msg_type.value: [] for msg_type in MessageType}

class ByzantineSystem(DistributedSystem):
    """æ‹œå åº­å®¹é”™ç³»ç»Ÿ"""
    
    def __init__(self, name: str, f: int):
        super().__init__(name)
        self.f = f  # æœ€å¤§æ‹œå åº­æ•…éšœèŠ‚ç‚¹æ•°
        self.byzantine_nodes: Dict[str, ByzantineNode] = {}
        self.consensus_rounds: Dict[int, Dict[str, Any]] = {}
    
    def add_byzantine_node(self, node: ByzantineNode) -> None:
        """æ·»åŠ æ‹œå åº­èŠ‚ç‚¹"""
        self.add_node(node)
        self.byzantine_nodes[node.id] = node
    
    def validate_byzantine_condition(self) -> bool:
        """éªŒè¯æ‹œå åº­æ¡ä»¶"""
        total_nodes = len(self.byzantine_nodes)
        return total_nodes > 3 * self.f
    
    def start_consensus(self, initial_value: Any) -> None:
        """å¼€å§‹å…±è¯†"""
        if not self.validate_byzantine_condition():
            raise ValueError("èŠ‚ç‚¹æ•°ä¸è¶³ä»¥å®¹å¿æ‹œå åº­æ•…éšœ")
        
        # åˆå§‹åŒ–å…±è¯†è½®æ¬¡
        round_id = 0
        self.consensus_rounds[round_id] = {
            "phase": "propose",
            "values": {},
            "votes": {},
            "decisions": {}
        }
        
        # æ¯ä¸ªèŠ‚ç‚¹æè®®åˆå§‹å€¼
        for node_id, node in self.byzantine_nodes.items():
            if not node.is_byzantine:
                self._propose_value(node, initial_value, round_id)
    
    def _propose_value(self, node: ByzantineNode, value: Any, round_id: int) -> None:
        """æè®®å€¼"""
        propose_msg = Message(
            id="",
            type=MessageType.PROPOSE,
            sender=node.id,
            receiver="",  # å¹¿æ’­
            data={
                "round": round_id,
                "value": value,
                "signature": self._sign_message(node, value)
            }
        )
        self.broadcast_message(propose_msg)
    
    def _sign_message(self, node: ByzantineNode, data: Any) -> str:
        """ç­¾åæ¶ˆæ¯"""
        message_str = f"{node.id}:{data}"
        return hashlib.sha256(message_str.encode()).hexdigest()
    
    def handle_propose(self, node: ByzantineNode, message: Message) -> None:
        """å¤„ç†æè®®"""
        data = message.data
        round_id = data["round"]
        value = data["value"]
        signature = data["signature"]
        
        # éªŒè¯ç­¾å
        if not self._verify_signature(message.sender, value, signature):
            return  # å¿½ç•¥æ— æ•ˆæ¶ˆæ¯
        
        # è®°å½•æè®®
        if round_id not in self.consensus_rounds:
            self.consensus_rounds[round_id] = {
                "phase": "propose",
                "values": {},
                "votes": {},
                "decisions": {}
            }
        
        self.consensus_rounds[round_id]["values"][message.sender] = value
        
        # å¦‚æœæ”¶åˆ°è¶³å¤Ÿçš„æè®®ï¼Œè¿›å…¥æŠ•ç¥¨é˜¶æ®µ
        if len(self.consensus_rounds[round_id]["values"]) >= len(self.byzantine_nodes) - self.f:
            self._start_voting(node, round_id)
    
    def _start_voting(self, node: ByzantineNode, round_id: int) -> None:
        """å¼€å§‹æŠ•ç¥¨"""
        # é€‰æ‹©æœ€å¸¸è§çš„å€¼
        values = self.consensus_rounds[round_id]["values"]
        value_counts = {}
        for value in values.values():
            value_counts[value] = value_counts.get(value, 0) + 1
        
        most_common_value = max(value_counts, key=value_counts.get)
        
        # æŠ•ç¥¨
        vote_msg = Message(
            id="",
            type=MessageType.ACCEPT,
            sender=node.id,
            receiver="",  # å¹¿æ’­
            data={
                "round": round_id,
                "value": most_common_value,
                "signature": self._sign_message(node, most_common_value)
            }
        )
        self.broadcast_message(vote_msg)
    
    def handle_accept(self, node: ByzantineNode, message: Message) -> None:
        """å¤„ç†æŠ•ç¥¨"""
        data = message.data
        round_id = data["round"]
        value = data["value"]
        signature = data["signature"]
        
        # éªŒè¯ç­¾å
        if not self._verify_signature(message.sender, value, signature):
            return
        
        # è®°å½•æŠ•ç¥¨
        if round_id not in self.consensus_rounds:
            return
        
        if "votes" not in self.consensus_rounds[round_id]:
            self.consensus_rounds[round_id]["votes"] = {}
        
        self.consensus_rounds[round_id]["votes"][message.sender] = value
        
        # å¦‚æœæ”¶åˆ°è¶³å¤Ÿçš„æŠ•ç¥¨ï¼Œè¾¾æˆå…±è¯†
        if len(self.consensus_rounds[round_id]["votes"]) >= len(self.byzantine_nodes) - self.f:
            self._reach_consensus(node, round_id)
    
    def _reach_consensus(self, node: ByzantineNode, round_id: int) -> None:
        """è¾¾æˆå…±è¯†"""
        votes = self.consensus_rounds[round_id]["votes"]
        value_counts = {}
        for value in votes.values():
            value_counts[value] = value_counts.get(value, 0) + 1
        
        # é€‰æ‹©å¾—ç¥¨æœ€å¤šçš„å€¼
        consensus_value = max(value_counts, key=value_counts.get)
        
        # è®°å½•å†³ç­–
        self.consensus_rounds[round_id]["decisions"][node.id] = consensus_value
        node.consensus_value = consensus_value
        
        # å¹¿æ’­å­¦ä¹ æ¶ˆæ¯
        learn_msg = Message(
            id="",
            type=MessageType.LEARN,
            sender=node.id,
            receiver="",  # å¹¿æ’­
            data={
                "round": round_id,
                "value": consensus_value,
                "signature": self._sign_message(node, consensus_value)
            }
        )
        self.broadcast_message(learn_msg)
    
    def handle_learn(self, node: ByzantineNode, message: Message) -> None:
        """å¤„ç†å­¦ä¹ æ¶ˆæ¯"""
        data = message.data
        round_id = data["round"]
        value = data["value"]
        signature = data["signature"]
        
        # éªŒè¯ç­¾å
        if not self._verify_signature(message.sender, value, signature):
            return
        
        # å­¦ä¹ å…±è¯†å€¼
        node.consensus_value = value
        print(f"èŠ‚ç‚¹ {node.id} å­¦ä¹ åˆ°å…±è¯†å€¼: {value}")
    
    def _verify_signature(self, sender: str, data: Any, signature: str) -> bool:
        """éªŒè¯ç­¾å"""
        expected_signature = hashlib.sha256(f"{sender}:{data}".encode()).hexdigest()
        return signature == expected_signature
    
    def get_byzantine_status(self) -> Dict[str, Any]:
        """è·å–æ‹œå åº­ç³»ç»ŸçŠ¶æ€"""
        total_nodes = len(self.byzantine_nodes)
        byzantine_nodes = [node_id for node_id, node in self.byzantine_nodes.items() 
                          if node.is_byzantine]
        
        return {
            "total_nodes": total_nodes,
            "byzantine_nodes": byzantine_nodes,
            "max_byzantine_faults": self.f,
            "byzantine_condition_satisfied": self.validate_byzantine_condition(),
            "nodes": {
                node_id: {
                    "id": node.id,
                    "is_byzantine": node.is_byzantine,
                    "consensus_value": node.consensus_value,
                    "round_number": node.round_number
                }
                for node_id, node in self.byzantine_nodes.items()
            },
            "consensus_rounds": self.consensus_rounds
        }

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_byzantine_fault_tolerance():
    """æ¼”ç¤ºæ‹œå åº­å®¹é”™"""
    
    # åˆ›å»ºæ‹œå åº­ç³»ç»Ÿï¼ˆå®¹å¿1ä¸ªæ‹œå åº­æ•…éšœï¼Œéœ€è¦è‡³å°‘4ä¸ªèŠ‚ç‚¹ï¼‰
    byzantine_system = ByzantineSystem("æ‹œå åº­ç³»ç»Ÿ", f=1)
    
    # åˆ›å»ºèŠ‚ç‚¹
    nodes = [
        ByzantineNode("node1", "192.168.1.10:8080", is_byzantine=False),
        ByzantineNode("node2", "192.168.1.11:8080", is_byzantine=False),
        ByzantineNode("node3", "192.168.1.12:8080", is_byzantine=False),
        ByzantineNode("node4", "192.168.1.13:8080", is_byzantine=True),  # æ‹œå åº­èŠ‚ç‚¹
    ]
    
    # æ·»åŠ èŠ‚ç‚¹
    for node in nodes:
        byzantine_system.add_byzantine_node(node)
    
    # æ·»åŠ è¿æ¥
    for i in range(len(nodes)):
        for j in range(i + 1, len(nodes)):
            byzantine_system.add_connection(nodes[i].id, nodes[j].id)
    
    # å¯åŠ¨ç³»ç»Ÿ
    byzantine_system.start()
    
    # å¼€å§‹å…±è¯†
    byzantine_system.start_consensus("åˆå§‹å€¼")
    
    # ç­‰å¾…å…±è¯†è¾¾æˆ
    time.sleep(3)
    
    # è·å–çŠ¶æ€
    status = byzantine_system.get_byzantine_status()
    print(f"æ‹œå åº­ç³»ç»ŸçŠ¶æ€: {status}")
    
    return byzantine_system
```

## ğŸ“Š æ•°å­¦è¯æ˜

### 1. åˆ†å¸ƒå¼ç³»ç»Ÿè¿é€šæ€§å®šç†

**å®šç† 1.1** (åˆ†å¸ƒå¼ç³»ç»Ÿè¿é€šæ€§)
å¦‚æœåˆ†å¸ƒå¼ç³»ç»Ÿ $DS = (N, C, P)$ æ˜¯è¿é€šçš„ï¼Œåˆ™ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´éƒ½å­˜åœ¨é€šä¿¡è·¯å¾„ã€‚

**è¯æ˜**:
1. è®¾ $DS$ æ˜¯è¿é€šåˆ†å¸ƒå¼ç³»ç»Ÿ
2. æ ¹æ®è¿é€šæ€§å®šä¹‰ï¼Œé€šä¿¡ç½‘ç»œ $C$ æ˜¯è¿é€šå›¾
3. å› æ­¤ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´éƒ½å­˜åœ¨è·¯å¾„

### 2. æ‹œå åº­å®¹é”™å®šç†

**å®šç† 1.2** (æ‹œå åº­å®¹é”™ä¸‹é™)
æ‹œå åº­å®¹é”™éœ€è¦è‡³å°‘ $3f + 1$ ä¸ªèŠ‚ç‚¹æ‰èƒ½å®¹å¿ $f$ ä¸ªæ‹œå åº­æ•…éšœã€‚

**è¯æ˜**:
1. è®¾ç³»ç»Ÿæœ‰ $n$ ä¸ªèŠ‚ç‚¹ï¼Œå…¶ä¸­ $f$ ä¸ªæ‹œå åº­æ•…éšœ
2. æ­£ç¡®èŠ‚ç‚¹æ•°ä¸º $n - f$
3. ä¸ºäº†è¾¾æˆä¸€è‡´ï¼Œæ­£ç¡®èŠ‚ç‚¹æ•°å¿…é¡»å¤§äºæ•…éšœèŠ‚ç‚¹æ•°
4. å› æ­¤ $n - f > f$ï¼Œå³ $n > 2f$
5. è€ƒè™‘æœ€åæƒ…å†µï¼Œéœ€è¦ $n \geq 3f + 1$

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [ç³»ç»Ÿè®¾è®¡ç†è®º](../03-03-ç³»ç»Ÿè®¾è®¡/README.md)
- [è½¯ä»¶æ¶æ„ç†è®º](../03-02-è½¯ä»¶æ¶æ„/README.md)
- [ç½‘ç»œç†è®º](../02-è®¡ç®—æœºç§‘å­¦/02-03-ç½‘ç»œ/README.md)
- [ç®—æ³•ç†è®º](../02-è®¡ç®—æœºç§‘å­¦/02-02-ç®—æ³•/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Tanenbaum, A. S., & Van Steen, M. (2017). Distributed Systems: Principles and Paradigms
2. Lamport, L. (2001). Paxos Made Simple
3. Ongaro, D., & Ousterhout, J. (2014). In Search of an Understandable Consensus Algorithm
4. Castro, M., & Liskov, B. (2002). Practical Byzantine Fault Tolerance and Proactive Recovery
5. Fischer, M. J., Lynch, N. A., & Paterson, M. S. (1985). Impossibility of Distributed Consensus with One Faulty Process

---

*åˆ†å¸ƒå¼ç³»ç»Ÿä¸ºæ„å»ºé«˜å¯ç”¨ã€é«˜å¯æ‰©å±•çš„è½¯ä»¶ç³»ç»Ÿæä¾›äº†ç†è®ºåŸºç¡€ï¼Œé€šè¿‡å½¢å¼åŒ–çš„æ•°å­¦å®šä¹‰å’Œä¸¥æ ¼çš„è¯æ˜ï¼Œæˆ‘ä»¬å»ºç«‹äº†åˆ†å¸ƒå¼ç³»ç»Ÿçš„å®Œæ•´ç†è®ºä½“ç³»ã€‚* 