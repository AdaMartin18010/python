# 03-02-è½¯ä»¶æ¶æ„ç§‘å­¦

## ğŸ“‹ æ¦‚è¿°

è½¯ä»¶æ¶æ„ç§‘å­¦æ˜¯ç ”ç©¶è½¯ä»¶ç³»ç»Ÿæ•´ä½“ç»“æ„å’Œç»„ç»‡æ–¹å¼çš„å­¦ç§‘ï¼Œæ¶‰åŠç³»ç»Ÿçš„åˆ†è§£ã€ç»„ä»¶é—´çš„å…³ç³»ã€è´¨é‡å±æ€§çš„å®ç°ä»¥åŠæ¶æ„çš„æ¼”åŒ–è§„å¾‹ã€‚å®ƒæ˜¯è¿æ¥è½¯ä»¶è®¾è®¡å’Œå®ç°çš„é‡è¦æ¡¥æ¢ã€‚

**ç›¸å…³æ–‡æ¡£**:

- [03-01-ç¼–ç¨‹è¯­è¨€ç§‘å­¦](./03-01-ç¼–ç¨‹è¯­è¨€ç§‘å­¦.md) - è¯­è¨€è¿è¡Œæ—¶æ¶æ„
- [03-03-è®¾è®¡æ¨¡å¼ç§‘å­¦](./03-03-è®¾è®¡æ¨¡å¼ç§‘å­¦.md) - æ¶æ„æ¨¡å¼åº”ç”¨
- [05-01-å¾®æœåŠ¡æ¶æ„](../05-æ¶æ„é¢†åŸŸ/05-01-å¾®æœåŠ¡æ¶æ„.md) - ç°ä»£æ¶æ„æ¨¡å¼

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è½¯ä»¶æ¶æ„çš„å®šä¹‰

è½¯ä»¶æ¶æ„æ˜¯è½¯ä»¶ç³»ç»Ÿçš„é«˜çº§æŠ½è±¡ï¼Œæè¿°äº†ï¼š

- **ç»„ä»¶ç»“æ„**: ç³»ç»Ÿçš„ä¸»è¦ç»„ä»¶åŠå…¶èŒè´£
- **è¿æ¥å…³ç³»**: ç»„ä»¶é—´çš„äº¤äº’æ–¹å¼å’Œåè®®
- **è´¨é‡å±æ€§**: ç³»ç»Ÿå¿…é¡»æ»¡è¶³çš„éåŠŸèƒ½æ€§éœ€æ±‚
- **è®¾è®¡åŸåˆ™**: æŒ‡å¯¼æ¶æ„å†³ç­–çš„åŸºæœ¬åŸåˆ™

### 2. æ¶æ„è§†å›¾

è½¯ä»¶æ¶æ„å¯ä»¥ä»å¤šä¸ªè§†è§’è¿›è¡Œæè¿°ï¼š

- **é€»è¾‘è§†å›¾**: ç³»ç»Ÿçš„åŠŸèƒ½åˆ†è§£å’Œæ¨¡å—ç»„ç»‡
- **è¿›ç¨‹è§†å›¾**: è¿è¡Œæ—¶è¿›ç¨‹å’Œçº¿ç¨‹çš„ç»„ç»‡
- **ç‰©ç†è§†å›¾**: ç¡¬ä»¶éƒ¨ç½²å’Œç½‘ç»œæ‹“æ‰‘
- **å¼€å‘è§†å›¾**: å¼€å‘å›¢é˜Ÿçš„ç»„ç»‡å’Œä»£ç ç»“æ„

### 3. è´¨é‡å±æ€§

è½¯ä»¶æ¶æ„å¿…é¡»æ»¡è¶³çš„è´¨é‡å±æ€§åŒ…æ‹¬ï¼š

- **æ€§èƒ½**: å“åº”æ—¶é—´å’Œååé‡
- **å¯ç”¨æ€§**: ç³»ç»Ÿæ­£å¸¸è¿è¡Œæ—¶é—´
- **å¯ç»´æŠ¤æ€§**: ä¿®æ”¹å’Œæ‰©å±•çš„å®¹æ˜“ç¨‹åº¦
- **å®‰å…¨æ€§**: ä¿æŠ¤æ•°æ®å’Œç³»ç»Ÿå…å—å¨èƒ
- **å¯æ‰©å±•æ€§**: å¤„ç†å¢é•¿è´Ÿè½½çš„èƒ½åŠ›

## ğŸ”¢ æ•°å­¦å½¢å¼åŒ–

### 1. æ¶æ„ç»„ä»¶æ¨¡å‹

è½¯ä»¶æ¶æ„å¯ä»¥å½¢å¼åŒ–ä¸ºæœ‰å‘å›¾ï¼š

$$A = (C, R, \phi)$$

å…¶ä¸­ï¼š

- $C$ æ˜¯ç»„ä»¶é›†åˆ
- $R$ æ˜¯å…³ç³»é›†åˆ
- $\phi: R \rightarrow C \times C$ æ˜¯å…³ç³»æ˜ å°„å‡½æ•°

### 2. è´¨é‡å±æ€§åº¦é‡

æ€§èƒ½å¯ä»¥ç”¨å“åº”æ—¶é—´å‡½æ•°è¡¨ç¤ºï¼š

$$T_{response} = T_{processing} + T_{communication} + T_{waiting}$$

å¯ç”¨æ€§å¯ä»¥ç”¨MTTFå’ŒMTTRè¡¨ç¤ºï¼š

$$Availability = \frac{MTTF}{MTTF + MTTR}$$

### 3. æ¶æ„å¤æ‚åº¦

æ¶æ„å¤æ‚åº¦å¯ä»¥ç”¨å›¾è®ºæŒ‡æ ‡åº¦é‡ï¼š

$$Complexity = \frac{|R|}{|C|} + \sum_{c \in C} \frac{fan\_in(c) + fan\_out(c)}{2}$$

## ğŸ’» Python å®ç°

### 1. åŸºç¡€æ¶æ„æ¨¡å‹

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Optional, Any, Tuple
from enum import Enum
from dataclasses import dataclass, field
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict

class ComponentType(Enum):
    """ç»„ä»¶ç±»å‹æšä¸¾"""
    SERVICE = "service"
    DATABASE = "database"
    CACHE = "cache"
    QUEUE = "queue"
    API_GATEWAY = "api_gateway"
    LOAD_BALANCER = "load_balancer"

class RelationshipType(Enum):
    """å…³ç³»ç±»å‹æšä¸¾"""
    DEPENDS_ON = "depends_on"
    COMMUNICATES_WITH = "communicates_with"
    CONTAINS = "contains"
    IMPLEMENTS = "implements"
    EXTENDS = "extends"

@dataclass
class QualityAttribute:
    """è´¨é‡å±æ€§"""
    name: str
    value: float
    unit: str
    target: float
    weight: float = 1.0
    
    def is_satisfied(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æ»¡è¶³ç›®æ ‡"""
        return self.value >= self.target

@dataclass
class Component:
    """æ¶æ„ç»„ä»¶"""
    id: str
    name: str
    type: ComponentType
    description: str
    responsibilities: List[str] = field(default_factory=list)
    quality_attributes: Dict[str, QualityAttribute] = field(default_factory=dict)
    properties: Dict[str, Any] = field(default_factory=dict)
    
    def add_responsibility(self, responsibility: str):
        """æ·»åŠ èŒè´£"""
        self.responsibilities.append(responsibility)
    
    def add_quality_attribute(self, name: str, value: float, unit: str, target: float):
        """æ·»åŠ è´¨é‡å±æ€§"""
        self.quality_attributes[name] = QualityAttribute(name, value, unit, target)
    
    def get_quality_score(self) -> float:
        """è®¡ç®—è´¨é‡å¾—åˆ†"""
        if not self.quality_attributes:
            return 0.0
        
        total_score = 0.0
        total_weight = 0.0
        
        for attr in self.quality_attributes.values():
            if attr.is_satisfied():
                total_score += attr.weight
            total_weight += attr.weight
        
        return total_score / total_weight if total_weight > 0 else 0.0

@dataclass
class Relationship:
    """ç»„ä»¶å…³ç³»"""
    id: str
    source: str
    target: str
    type: RelationshipType
    properties: Dict[str, Any] = field(default_factory=dict)
    protocol: Optional[str] = None
    reliability: float = 1.0
    
    def is_reliable(self) -> bool:
        """æ£€æŸ¥å…³ç³»æ˜¯å¦å¯é """
        return self.reliability >= 0.99

class SoftwareArchitecture:
    """è½¯ä»¶æ¶æ„"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.components: Dict[str, Component] = {}
        self.relationships: Dict[str, Relationship] = {}
        self.quality_attributes: Dict[str, QualityAttribute] = {}
        self.constraints: List[str] = []
        self.principles: List[str] = []
    
    def add_component(self, component: Component):
        """æ·»åŠ ç»„ä»¶"""
        self.components[component.id] = component
    
    def add_relationship(self, relationship: Relationship):
        """æ·»åŠ å…³ç³»"""
        self.relationships[relationship.id] = relationship
    
    def add_quality_attribute(self, name: str, value: float, unit: str, target: float):
        """æ·»åŠ æ¶æ„çº§è´¨é‡å±æ€§"""
        self.quality_attributes[name] = QualityAttribute(name, value, unit, target)
    
    def get_component(self, component_id: str) -> Optional[Component]:
        """è·å–ç»„ä»¶"""
        return self.components.get(component_id)
    
    def get_dependencies(self, component_id: str) -> List[Component]:
        """è·å–ç»„ä»¶çš„ä¾èµ–"""
        dependencies = []
        for rel in self.relationships.values():
            if rel.target == component_id and rel.type == RelationshipType.DEPENDS_ON:
                dep_component = self.get_component(rel.source)
                if dep_component:
                    dependencies.append(dep_component)
        return dependencies
    
    def get_dependents(self, component_id: str) -> List[Component]:
        """è·å–ä¾èµ–è¯¥ç»„ä»¶çš„ç»„ä»¶"""
        dependents = []
        for rel in self.relationships.values():
            if rel.source == component_id and rel.type == RelationshipType.DEPENDS_ON:
                dep_component = self.get_component(rel.target)
                if dep_component:
                    dependents.append(dep_component)
        return dependents
    
    def calculate_complexity(self) -> float:
        """è®¡ç®—æ¶æ„å¤æ‚åº¦"""
        if not self.components:
            return 0.0
        
        # è®¡ç®—å¹³å‡è¿æ¥åº¦
        total_connections = len(self.relationships)
        avg_connections = total_connections / len(self.components)
        
        # è®¡ç®—ç»„ä»¶å¤æ‚åº¦
        component_complexity = 0.0
        for component in self.components.values():
            fan_in = len(self.get_dependents(component.id))
            fan_out = len(self.get_dependencies(component.id))
            component_complexity += (fan_in + fan_out) / 2
        
        return avg_connections + component_complexity / len(self.components)
    
    def validate_architecture(self) -> Dict[str, List[str]]:
        """éªŒè¯æ¶æ„"""
        issues = {
            'errors': [],
            'warnings': [],
            'suggestions': []
        }
        
        # æ£€æŸ¥å­¤ç«‹ç»„ä»¶
        for component_id in self.components:
            if not self.get_dependencies(component_id) and not self.get_dependents(component_id):
                issues['warnings'].append(f"Component {component_id} is isolated")
        
        # æ£€æŸ¥å¾ªç¯ä¾èµ–
        if self._has_circular_dependencies():
            issues['errors'].append("Circular dependencies detected")
        
        # æ£€æŸ¥è´¨é‡å±æ€§
        for attr_name, attr in self.quality_attributes.items():
            if not attr.is_satisfied():
                issues['warnings'].append(f"Quality attribute {attr_name} not satisfied")
        
        return issues
    
    def _has_circular_dependencies(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¾ªç¯ä¾èµ–"""
        # ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢æ£€æµ‹å¾ªç¯
        visited = set()
        rec_stack = set()
        
        def dfs(component_id: str) -> bool:
            if component_id in rec_stack:
                return True
            if component_id in visited:
                return False
            
            visited.add(component_id)
            rec_stack.add(component_id)
            
            for dep in self.get_dependencies(component_id):
                if dfs(dep.id):
                    return True
            
            rec_stack.remove(component_id)
            return False
        
        for component_id in self.components:
            if component_id not in visited:
                if dfs(component_id):
                    return True
        
        return False
```

### 2. æ¶æ„æ¨¡å¼å®ç°

```python
class ArchitecturalPattern(ABC):
    """æ¶æ„æ¨¡å¼æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def apply(self, architecture: SoftwareArchitecture):
        """åº”ç”¨æ¶æ„æ¨¡å¼"""
        pass
    
    @abstractmethod
    def get_benefits(self) -> List[str]:
        """è·å–æ¨¡å¼ä¼˜åŠ¿"""
        pass
    
    @abstractmethod
    def get_trade_offs(self) -> List[str]:
        """è·å–æ¨¡å¼æƒè¡¡"""
        pass

class LayeredArchitecture(ArchitecturalPattern):
    """åˆ†å±‚æ¶æ„æ¨¡å¼"""
    
    def __init__(self, layers: List[str]):
        self.layers = layers
    
    def apply(self, architecture: SoftwareArchitecture):
        """åº”ç”¨åˆ†å±‚æ¶æ„"""
        # åˆ›å»ºå±‚ç»„ä»¶
        for i, layer_name in enumerate(self.layers):
            layer_component = Component(
                id=f"layer_{i}",
                name=layer_name,
                type=ComponentType.SERVICE,
                description=f"{layer_name} layer"
            )
            architecture.add_component(layer_component)
            
            # æ·»åŠ å±‚é—´ä¾èµ–å…³ç³»
            if i > 0:
                dependency = Relationship(
                    id=f"dep_{i}_{i-1}",
                    source=f"layer_{i}",
                    target=f"layer_{i-1}",
                    type=RelationshipType.DEPENDS_ON
                )
                architecture.add_relationship(dependency)
    
    def get_benefits(self) -> List[str]:
        return [
            "Separation of concerns",
            "Modularity",
            "Maintainability",
            "Testability"
        ]
    
    def get_trade_offs(self) -> List[str]:
        return [
            "Performance overhead",
            "Tight coupling between layers",
            "Difficulty in changing layer boundaries"
        ]

class MicroservicesArchitecture(ArchitecturalPattern):
    """å¾®æœåŠ¡æ¶æ„æ¨¡å¼"""
    
    def __init__(self, services: List[str]):
        self.services = services
    
    def apply(self, architecture: SoftwareArchitecture):
        """åº”ç”¨å¾®æœåŠ¡æ¶æ„"""
        # åˆ›å»ºAPIç½‘å…³
        gateway = Component(
            id="api_gateway",
            name="API Gateway",
            type=ComponentType.API_GATEWAY,
            description="Central entry point for all client requests"
        )
        architecture.add_component(gateway)
        
        # åˆ›å»ºå¾®æœåŠ¡
        for service_name in self.services:
            service = Component(
                id=f"service_{service_name.lower()}",
                name=service_name,
                type=ComponentType.SERVICE,
                description=f"Microservice for {service_name}"
            )
            architecture.add_component(service)
            
            # æœåŠ¡ä¾èµ–ç½‘å…³
            dependency = Relationship(
                id=f"gateway_{service_name.lower()}",
                source=gateway.id,
                target=service.id,
                type=RelationshipType.COMMUNICATES_WITH,
                protocol="HTTP/REST"
            )
            architecture.add_relationship(dependency)
    
    def get_benefits(self) -> List[str]:
        return [
            "Independent deployment",
            "Technology diversity",
            "Scalability",
            "Fault isolation"
        ]
    
    def get_trade_offs(self) -> List[str]:
        return [
            "Distributed system complexity",
            "Network latency",
            "Data consistency challenges",
            "Operational overhead"
        ]

class EventDrivenArchitecture(ArchitecturalPattern):
    """äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼"""
    
    def __init__(self, producers: List[str], consumers: List[str]):
        self.producers = producers
        self.consumers = consumers
    
    def apply(self, architecture: SoftwareArchitecture):
        """åº”ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„"""
        # åˆ›å»ºäº‹ä»¶æ€»çº¿
        event_bus = Component(
            id="event_bus",
            name="Event Bus",
            type=ComponentType.QUEUE,
            description="Central event routing and distribution"
        )
        architecture.add_component(event_bus)
        
        # åˆ›å»ºç”Ÿäº§è€…
        for producer in self.producers:
            producer_component = Component(
                id=f"producer_{producer.lower()}",
                name=producer,
                type=ComponentType.SERVICE,
                description=f"Event producer: {producer}"
            )
            architecture.add_component(producer_component)
            
            # ç”Ÿäº§è€…å‘å¸ƒåˆ°äº‹ä»¶æ€»çº¿
            publish_rel = Relationship(
                id=f"publish_{producer.lower()}",
                source=producer_component.id,
                target=event_bus.id,
                type=RelationshipType.COMMUNICATES_WITH,
                protocol="Event"
            )
            architecture.add_relationship(publish_rel)
        
        # åˆ›å»ºæ¶ˆè´¹è€…
        for consumer in self.consumers:
            consumer_component = Component(
                id=f"consumer_{consumer.lower()}",
                name=consumer,
                type=ComponentType.SERVICE,
                description=f"Event consumer: {consumer}"
            )
            architecture.add_component(consumer_component)
            
            # æ¶ˆè´¹è€…è®¢é˜…äº‹ä»¶æ€»çº¿
            subscribe_rel = Relationship(
                id=f"subscribe_{consumer.lower()}",
                source=event_bus.id,
                target=consumer_component.id,
                type=RelationshipType.COMMUNICATES_WITH,
                protocol="Event"
            )
            architecture.add_relationship(subscribe_rel)
    
    def get_benefits(self) -> List[str]:
        return [
            "Loose coupling",
            "Scalability",
            "Asynchronous processing",
            "Extensibility"
        ]
    
    def get_trade_offs(self) -> List[str]:
        return [
            "Event ordering challenges",
            "Debugging complexity",
            "Event schema evolution",
            "Eventual consistency"
        ]
```

### 3. æ¶æ„è¯„ä¼°ç³»ç»Ÿ

```python
class ArchitectureEvaluator:
    """æ¶æ„è¯„ä¼°å™¨"""
    
    def __init__(self):
        self.evaluation_criteria: Dict[str, float] = {
            'modularity': 0.2,
            'scalability': 0.2,
            'maintainability': 0.2,
            'performance': 0.15,
            'security': 0.15,
            'reliability': 0.1
        }
    
    def evaluate_architecture(self, architecture: SoftwareArchitecture) -> Dict[str, float]:
        """è¯„ä¼°æ¶æ„"""
        scores = {}
        
        # è¯„ä¼°æ¨¡å—åŒ–
        scores['modularity'] = self._evaluate_modularity(architecture)
        
        # è¯„ä¼°å¯æ‰©å±•æ€§
        scores['scalability'] = self._evaluate_scalability(architecture)
        
        # è¯„ä¼°å¯ç»´æŠ¤æ€§
        scores['maintainability'] = self._evaluate_maintainability(architecture)
        
        # è¯„ä¼°æ€§èƒ½
        scores['performance'] = self._evaluate_performance(architecture)
        
        # è¯„ä¼°å®‰å…¨æ€§
        scores['security'] = self._evaluate_security(architecture)
        
        # è¯„ä¼°å¯é æ€§
        scores['reliability'] = self._evaluate_reliability(architecture)
        
        return scores
    
    def calculate_overall_score(self, scores: Dict[str, float]) -> float:
        """è®¡ç®—æ€»ä½“å¾—åˆ†"""
        overall_score = 0.0
        for criterion, weight in self.evaluation_criteria.items():
            if criterion in scores:
                overall_score += scores[criterion] * weight
        return overall_score
    
    def _evaluate_modularity(self, architecture: SoftwareArchitecture) -> float:
        """è¯„ä¼°æ¨¡å—åŒ–"""
        if not architecture.components:
            return 0.0
        
        # è®¡ç®—ç»„ä»¶é—´çš„å†…èšåº¦
        cohesion_score = 0.0
        for component in architecture.components.values():
            # åŸºäºç»„ä»¶èŒè´£æ•°é‡è¯„ä¼°å†…èšåº¦
            responsibility_count = len(component.responsibilities)
            if responsibility_count <= 3:
                cohesion_score += 1.0
            elif responsibility_count <= 5:
                cohesion_score += 0.8
            elif responsibility_count <= 8:
                cohesion_score += 0.6
            else:
                cohesion_score += 0.4
        
        cohesion_score /= len(architecture.components)
        
        # è®¡ç®—ç»„ä»¶é—´çš„è€¦åˆåº¦
        coupling_score = 1.0 - (len(architecture.relationships) / (len(architecture.components) * (len(architecture.components) - 1)))
        
        return (cohesion_score + coupling_score) / 2
    
    def _evaluate_scalability(self, architecture: SoftwareArchitecture) -> float:
        """è¯„ä¼°å¯æ‰©å±•æ€§"""
        if not architecture.components:
            return 0.0
        
        # æ£€æŸ¥æ˜¯å¦æœ‰è´Ÿè½½å‡è¡¡å™¨
        has_load_balancer = any(
            comp.type == ComponentType.LOAD_BALANCER 
            for comp in architecture.components.values()
        )
        
        # æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜ç»„ä»¶
        has_cache = any(
            comp.type == ComponentType.CACHE 
            for comp in architecture.components.values()
        )
        
        # æ£€æŸ¥æ˜¯å¦æœ‰é˜Ÿåˆ—ç»„ä»¶
        has_queue = any(
            comp.type == ComponentType.QUEUE 
            for comp in architecture.components.values()
        )
        
        score = 0.0
        if has_load_balancer:
            score += 0.4
        if has_cache:
            score += 0.3
        if has_queue:
            score += 0.3
        
        return score
    
    def _evaluate_maintainability(self, architecture: SoftwareArchitecture) -> float:
        """è¯„ä¼°å¯ç»´æŠ¤æ€§"""
        if not architecture.components:
            return 0.0
        
        # åŸºäºæ¶æ„å¤æ‚åº¦è¯„ä¼°
        complexity = architecture.calculate_complexity()
        
        # å¤æ‚åº¦è¶Šä½ï¼Œå¯ç»´æŠ¤æ€§è¶Šé«˜
        if complexity <= 2.0:
            return 1.0
        elif complexity <= 4.0:
            return 0.8
        elif complexity <= 6.0:
            return 0.6
        elif complexity <= 8.0:
            return 0.4
        else:
            return 0.2
    
    def _evaluate_performance(self, architecture: SoftwareArchitecture) -> float:
        """è¯„ä¼°æ€§èƒ½"""
        if not architecture.components:
            return 0.0
        
        # æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜
        has_cache = any(
            comp.type == ComponentType.CACHE 
            for comp in architecture.components.values()
        )
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®åº“
        has_database = any(
            comp.type == ComponentType.DATABASE 
            for comp in architecture.components.values()
        )
        
        # æ£€æŸ¥ç»„ä»¶æ•°é‡ï¼ˆç»„ä»¶è¶Šå¤šï¼Œæ€§èƒ½å¼€é”€è¶Šå¤§ï¼‰
        component_count = len(architecture.components)
        component_penalty = min(component_count / 10.0, 0.5)
        
        score = 1.0 - component_penalty
        if has_cache:
            score += 0.2
        if has_database:
            score += 0.1
        
        return min(score, 1.0)
    
    def _evaluate_security(self, architecture: SoftwareArchitecture) -> float:
        """è¯„ä¼°å®‰å…¨æ€§"""
        if not architecture.components:
            return 0.0
        
        # æ£€æŸ¥æ˜¯å¦æœ‰APIç½‘å…³
        has_gateway = any(
            comp.type == ComponentType.API_GATEWAY 
            for comp in architecture.components.values()
        )
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®åº“
        has_database = any(
            comp.type == ComponentType.DATABASE 
            for comp in architecture.components.values()
        )
        
        score = 0.0
        if has_gateway:
            score += 0.6
        if has_database:
            score += 0.4
        
        return score
    
    def _evaluate_reliability(self, architecture: SoftwareArchitecture) -> float:
        """è¯„ä¼°å¯é æ€§"""
        if not architecture.relationships:
            return 0.0
        
        # åŸºäºå…³ç³»å¯é æ€§è¯„ä¼°
        reliable_relationships = sum(
            1 for rel in architecture.relationships.values()
            if rel.is_reliable()
        )
        
        return reliable_relationships / len(architecture.relationships)
```

### 4. æ¶æ„å¯è§†åŒ–

```python
class ArchitectureVisualizer:
    """æ¶æ„å¯è§†åŒ–å™¨"""
    
    def __init__(self):
        self.graph = nx.DiGraph()
        self.component_colors = {
            ComponentType.SERVICE: 'lightblue',
            ComponentType.DATABASE: 'lightgreen',
            ComponentType.CACHE: 'yellow',
            ComponentType.QUEUE: 'orange',
            ComponentType.API_GATEWAY: 'red',
            ComponentType.LOAD_BALANCER: 'purple'
        }
    
    def visualize_architecture(self, architecture: SoftwareArchitecture, 
                             filename: str = "architecture.png"):
        """å¯è§†åŒ–æ¶æ„"""
        # æ¸…ç©ºå›¾
        self.graph.clear()
        
        # æ·»åŠ èŠ‚ç‚¹
        for component in architecture.components.values():
            self.graph.add_node(
                component.id,
                name=component.name,
                type=component.type.value,
                color=self.component_colors.get(component.type, 'gray')
            )
        
        # æ·»åŠ è¾¹
        for relationship in architecture.relationships.values():
            self.graph.add_edge(
                relationship.source,
                relationship.target,
                type=relationship.type.value,
                protocol=relationship.protocol
            )
        
        # ç»˜åˆ¶å›¾
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(self.graph, k=1, iterations=50)
        
        # ç»˜åˆ¶èŠ‚ç‚¹
        node_colors = [self.graph.nodes[node]['color'] for node in self.graph.nodes()]
        nx.draw_networkx_nodes(self.graph, pos, node_color=node_colors, 
                             node_size=2000, alpha=0.7)
        
        # ç»˜åˆ¶è¾¹
        nx.draw_networkx_edges(self.graph, pos, edge_color='gray', 
                             arrows=True, arrowsize=20)
        
        # æ·»åŠ æ ‡ç­¾
        labels = {node: self.graph.nodes[node]['name'] for node in self.graph.nodes()}
        nx.draw_networkx_labels(self.graph, pos, labels, font_size=8)
        
        # æ·»åŠ è¾¹æ ‡ç­¾
        edge_labels = {(u, v): self.graph.edges[u, v]['type'] 
                      for u, v in self.graph.edges()}
        nx.draw_networkx_edge_labels(self.graph, pos, edge_labels, font_size=6)
        
        plt.title(f"Software Architecture: {architecture.name}")
        plt.axis('off')
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()
    
    def generate_architecture_report(self, architecture: SoftwareArchitecture) -> str:
        """ç”Ÿæˆæ¶æ„æŠ¥å‘Š"""
        report = []
        report.append(f"# Architecture Report: {architecture.name}")
        report.append(f"\n## Overview")
        report.append(f"Description: {architecture.description}")
        report.append(f"Components: {len(architecture.components)}")
        report.append(f"Relationships: {len(architecture.relationships)}")
        report.append(f"Complexity: {architecture.calculate_complexity():.2f}")
        
        report.append(f"\n## Components")
        for component in architecture.components.values():
            report.append(f"\n### {component.name} ({component.type.value})")
            report.append(f"ID: {component.id}")
            report.append(f"Description: {component.description}")
            if component.responsibilities:
                report.append("Responsibilities:")
                for resp in component.responsibilities:
                    report.append(f"- {resp}")
        
        report.append(f"\n## Relationships")
        for relationship in architecture.relationships.values():
            source_name = architecture.components[relationship.source].name
            target_name = architecture.components[relationship.target].name
            report.append(f"- {source_name} {relationship.type.value} {target_name}")
            if relationship.protocol:
                report.append(f"  Protocol: {relationship.protocol}")
        
        report.append(f"\n## Quality Attributes")
        for attr_name, attr in architecture.quality_attributes.items():
            status = "âœ“" if attr.is_satisfied() else "âœ—"
            report.append(f"- {attr_name}: {attr.value} {attr.unit} {status}")
        
        return "\n".join(report)
```

## ğŸ“Š å›¾è¡¨è¯´æ˜

### 1. æ¶æ„å±‚æ¬¡ç»“æ„å›¾

```mermaid
graph TB
    A[è½¯ä»¶æ¶æ„] --> B[é€»è¾‘è§†å›¾]
    A --> C[è¿›ç¨‹è§†å›¾]
    A --> D[ç‰©ç†è§†å›¾]
    A --> E[å¼€å‘è§†å›¾]
    
    B --> F[ç»„ä»¶åˆ†è§£]
    B --> G[æ¨¡å—ç»„ç»‡]
    
    C --> H[è¿›ç¨‹ç»„ç»‡]
    C --> I[çº¿ç¨‹ç®¡ç†]
    
    D --> J[ç¡¬ä»¶éƒ¨ç½²]
    D --> K[ç½‘ç»œæ‹“æ‰‘]
    
    E --> L[å›¢é˜Ÿç»„ç»‡]
    E --> M[ä»£ç ç»“æ„]
```

### 2. è´¨é‡å±æ€§å…³ç³»å›¾

```mermaid
graph LR
    A[æ€§èƒ½] --> B[å“åº”æ—¶é—´]
    A --> C[ååé‡]
    A --> D[èµ„æºåˆ©ç”¨ç‡]
    
    E[å¯ç”¨æ€§] --> F[MTTF]
    E --> G[MTTR]
    E --> H[æ•…éšœæ¢å¤]
    
    I[å¯ç»´æŠ¤æ€§] --> J[æ¨¡å—åŒ–]
    I --> K[å†…èšåº¦]
    I --> L[è€¦åˆåº¦]
    
    M[å®‰å…¨æ€§] --> N[è®¤è¯]
    M --> O[æˆæƒ]
    M --> P[æ•°æ®ä¿æŠ¤]
    
    Q[å¯æ‰©å±•æ€§] --> R[æ°´å¹³æ‰©å±•]
    Q --> S[å‚ç›´æ‰©å±•]
    Q --> T[è´Ÿè½½å‡è¡¡]
```

### 3. æ¶æ„æ¨¡å¼å¯¹æ¯”å›¾

```mermaid
graph TD
    A[æ¶æ„æ¨¡å¼] --> B[åˆ†å±‚æ¶æ„]
    A --> C[å¾®æœåŠ¡æ¶æ„]
    A --> D[äº‹ä»¶é©±åŠ¨æ¶æ„]
    A --> E[ç®¡é“è¿‡æ»¤å™¨]
    A --> F[å®¢æˆ·ç«¯æœåŠ¡å™¨]
    
    B --> G[ä¼˜åŠ¿: æ¨¡å—åŒ–]
    B --> H[åŠ£åŠ¿: æ€§èƒ½å¼€é”€]
    
    C --> I[ä¼˜åŠ¿: ç‹¬ç«‹éƒ¨ç½²]
    C --> J[åŠ£åŠ¿: åˆ†å¸ƒå¼å¤æ‚æ€§]
    
    D --> K[ä¼˜åŠ¿: æ¾è€¦åˆ]
    D --> L[åŠ£åŠ¿: äº‹ä»¶é¡ºåº]
    
    E --> M[ä¼˜åŠ¿: å¯é‡ç”¨]
    E --> N[åŠ£åŠ¿: æ•°æ®è½¬æ¢]
    
    F --> O[ä¼˜åŠ¿: ç®€å•]
    F --> P[åŠ£åŠ¿: å•ç‚¹æ•…éšœ]
```

## ğŸ“ æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹1: ç”µå•†ç³»ç»Ÿæ¶æ„è®¾è®¡

```python
def design_ecommerce_architecture():
    """è®¾è®¡ç”µå•†ç³»ç»Ÿæ¶æ„"""
    # åˆ›å»ºæ¶æ„
    architecture = SoftwareArchitecture(
        name="E-commerce System",
        description="Modern e-commerce platform with microservices architecture"
    )
    
    # æ·»åŠ ç»„ä»¶
    components = [
        Component("api_gateway", "API Gateway", ComponentType.API_GATEWAY, 
                 "Central entry point for all client requests"),
        Component("user_service", "User Service", ComponentType.SERVICE,
                 "User management and authentication"),
        Component("product_service", "Product Service", ComponentType.SERVICE,
                 "Product catalog and inventory management"),
        Component("order_service", "Order Service", ComponentType.SERVICE,
                 "Order processing and management"),
        Component("payment_service", "Payment Service", ComponentType.SERVICE,
                 "Payment processing and integration"),
        Component("user_db", "User Database", ComponentType.DATABASE,
                 "User data storage"),
        Component("product_db", "Product Database", ComponentType.DATABASE,
                 "Product data storage"),
        Component("order_db", "Order Database", ComponentType.DATABASE,
                 "Order data storage"),
        Component("cache", "Redis Cache", ComponentType.CACHE,
                 "Session and data caching"),
        Component("message_queue", "Message Queue", ComponentType.QUEUE,
                 "Asynchronous message processing")
    ]
    
    for component in components:
        architecture.add_component(component)
    
    # æ·»åŠ å…³ç³»
    relationships = [
        Relationship("r1", "api_gateway", "user_service", RelationshipType.COMMUNICATES_WITH),
        Relationship("r2", "api_gateway", "product_service", RelationshipType.COMMUNICATES_WITH),
        Relationship("r3", "api_gateway", "order_service", RelationshipType.COMMUNICATES_WITH),
        Relationship("r4", "user_service", "user_db", RelationshipType.DEPENDS_ON),
        Relationship("r5", "product_service", "product_db", RelationshipType.DEPENDS_ON),
        Relationship("r6", "order_service", "order_db", RelationshipType.DEPENDS_ON),
        Relationship("r7", "order_service", "payment_service", RelationshipType.COMMUNICATES_WITH),
        Relationship("r8", "user_service", "cache", RelationshipType.COMMUNICATES_WITH),
        Relationship("r9", "product_service", "cache", RelationshipType.COMMUNICATES_WITH),
        Relationship("r10", "order_service", "message_queue", RelationshipType.COMMUNICATES_WITH)
    ]
    
    for relationship in relationships:
        architecture.add_relationship(relationship)
    
    # æ·»åŠ è´¨é‡å±æ€§
    architecture.add_quality_attribute("availability", 99.9, "%", 99.5)
    architecture.add_quality_attribute("response_time", 200, "ms", 500)
    architecture.add_quality_attribute("throughput", 1000, "req/s", 500)
    
    return architecture

# åˆ›å»ºç”µå•†æ¶æ„
ecommerce_arch = design_ecommerce_architecture()

# è¯„ä¼°æ¶æ„
evaluator = ArchitectureEvaluator()
scores = evaluator.evaluate_architecture(ecommerce_arch)
overall_score = evaluator.calculate_overall_score(scores)

print(f"E-commerce Architecture Evaluation:")
for criterion, score in scores.items():
    print(f"{criterion}: {score:.2f}")
print(f"Overall Score: {overall_score:.2f}")

# å¯è§†åŒ–æ¶æ„
visualizer = ArchitectureVisualizer()
visualizer.visualize_architecture(ecommerce_arch, "ecommerce_architecture.png")

# ç”ŸæˆæŠ¥å‘Š
report = visualizer.generate_architecture_report(ecommerce_arch)
print("\n" + report)
```

### æ¡ˆä¾‹2: æ¶æ„æ¨¡å¼åº”ç”¨

```python
def apply_architectural_patterns():
    """åº”ç”¨æ¶æ„æ¨¡å¼"""
    # åˆ›å»ºåŸºç¡€æ¶æ„
    base_architecture = SoftwareArchitecture(
        name="Base System",
        description="Base system for pattern application"
    )
    
    # åº”ç”¨åˆ†å±‚æ¶æ„
    layered_pattern = LayeredArchitecture([
        "Presentation Layer",
        "Business Logic Layer", 
        "Data Access Layer"
    ])
    layered_pattern.apply(base_architecture)
    
    print("Applied Layered Architecture:")
    print(f"Benefits: {layered_pattern.get_benefits()}")
    print(f"Trade-offs: {layered_pattern.get_trade_offs()}")
    
    # åˆ›å»ºå¾®æœåŠ¡æ¶æ„
    microservices_arch = SoftwareArchitecture(
        name="Microservices System",
        description="Microservices-based system"
    )
    
    microservices_pattern = MicroservicesArchitecture([
        "User Management",
        "Product Catalog",
        "Order Processing",
        "Payment Processing"
    ])
    microservices_pattern.apply(microservices_arch)
    
    print("\nApplied Microservices Architecture:")
    print(f"Benefits: {microservices_pattern.get_benefits()}")
    print(f"Trade-offs: {microservices_pattern.get_trade_offs()}")
    
    # åˆ›å»ºäº‹ä»¶é©±åŠ¨æ¶æ„
    event_driven_arch = SoftwareArchitecture(
        name="Event-Driven System",
        description="Event-driven system"
    )
    
    event_pattern = EventDrivenArchitecture(
        producers=["Order Service", "Payment Service"],
        consumers=["Notification Service", "Analytics Service"]
    )
    event_pattern.apply(event_driven_arch)
    
    print("\nApplied Event-Driven Architecture:")
    print(f"Benefits: {event_pattern.get_benefits()}")
    print(f"Trade-offs: {event_pattern.get_trade_offs()}")
    
    return base_architecture, microservices_arch, event_driven_arch

# åº”ç”¨æ¶æ„æ¨¡å¼
layered_arch, micro_arch, event_arch = apply_architectural_patterns()

# æ¯”è¾ƒä¸åŒæ¶æ„
architectures = [
    ("Layered", layered_arch),
    ("Microservices", micro_arch),
    ("Event-Driven", event_arch)
]

evaluator = ArchitectureEvaluator()

print("\nArchitecture Comparison:")
for name, arch in architectures:
    scores = evaluator.evaluate_architecture(arch)
    overall = evaluator.calculate_overall_score(scores)
    print(f"\n{name} Architecture:")
    print(f"Modularity: {scores['modularity']:.2f}")
    print(f"Scalability: {scores['scalability']:.2f}")
    print(f"Maintainability: {scores['maintainability']:.2f}")
    print(f"Overall Score: {overall:.2f}")
```

### æ¡ˆä¾‹3: æ¶æ„æ¼”åŒ–åˆ†æ

```python
def analyze_architecture_evolution():
    """åˆ†ææ¶æ„æ¼”åŒ–"""
    # åˆå§‹æ¶æ„ï¼ˆå•ä½“ï¼‰
    monolithic_arch = SoftwareArchitecture(
        name="Monolithic System",
        description="Initial monolithic architecture"
    )
    
    # æ·»åŠ å•ä½“ç»„ä»¶
    monolithic = Component(
        "monolith", "Monolithic Application", ComponentType.SERVICE,
        "Single application containing all functionality"
    )
    monolithic_arch.add_component(monolithic)
    
    # æ•°æ®åº“
    db = Component("database", "Database", ComponentType.DATABASE,
                  "Central database")
    monolithic_arch.add_component(db)
    
    # å…³ç³»
    rel = Relationship("dep1", "monolith", "database", RelationshipType.DEPENDS_ON)
    monolithic_arch.add_relationship(rel)
    
    # æ¼”åŒ–åˆ°å¾®æœåŠ¡
    evolved_arch = SoftwareArchitecture(
        name="Evolved Microservices",
        description="Evolved microservices architecture"
    )
    
    # æ·»åŠ å¾®æœåŠ¡ç»„ä»¶
    services = ["user", "product", "order", "payment"]
    for service in services:
        service_comp = Component(
            f"{service}_service", f"{service.title()} Service", 
            ComponentType.SERVICE, f"Microservice for {service}"
        )
        evolved_arch.add_component(service_comp)
        
        # æ¯ä¸ªæœåŠ¡æœ‰è‡ªå·±çš„æ•°æ®åº“
        service_db = Component(
            f"{service}_db", f"{service.title()} Database",
            ComponentType.DATABASE, f"Database for {service}"
        )
        evolved_arch.add_component(service_db)
        
        # æœåŠ¡ä¾èµ–è‡ªå·±çš„æ•°æ®åº“
        service_rel = Relationship(
            f"dep_{service}", f"{service}_service", f"{service}_db",
            RelationshipType.DEPENDS_ON
        )
        evolved_arch.add_relationship(service_rel)
    
    # æ·»åŠ APIç½‘å…³
    gateway = Component("gateway", "API Gateway", ComponentType.API_GATEWAY,
                       "Central entry point")
    evolved_arch.add_component(gateway)
    
    # ç½‘å…³è¿æ¥æ‰€æœ‰æœåŠ¡
    for service in services:
        gateway_rel = Relationship(
            f"gateway_{service}", "gateway", f"{service}_service",
            RelationshipType.COMMUNICATES_WITH
        )
        evolved_arch.add_relationship(gateway_rel)
    
    # æ¯”è¾ƒæ¼”åŒ–å‰åçš„æ¶æ„
    evaluator = ArchitectureEvaluator()
    
    print("Architecture Evolution Analysis:")
    print("\nBefore Evolution (Monolithic):")
    mono_scores = evaluator.evaluate_architecture(monolithic_arch)
    mono_overall = evaluator.calculate_overall_score(mono_scores)
    print(f"Modularity: {mono_scores['modularity']:.2f}")
    print(f"Scalability: {mono_scores['scalability']:.2f}")
    print(f"Maintainability: {mono_scores['maintainability']:.2f}")
    print(f"Overall Score: {mono_overall:.2f}")
    
    print("\nAfter Evolution (Microservices):")
    evolved_scores = evaluator.evaluate_architecture(evolved_arch)
    evolved_overall = evaluator.calculate_overall_score(evolved_scores)
    print(f"Modularity: {evolved_scores['modularity']:.2f}")
    print(f"Scalability: {evolved_scores['scalability']:.2f}")
    print(f"Maintainability: {evolved_scores['maintainability']:.2f}")
    print(f"Overall Score: {evolved_overall:.2f}")
    
    # åˆ†ææ”¹è¿›
    improvements = {}
    for criterion in mono_scores:
        improvement = evolved_scores[criterion] - mono_scores[criterion]
        improvements[criterion] = improvement
    
    print("\nImprovements:")
    for criterion, improvement in improvements.items():
        direction = "â†‘" if improvement > 0 else "â†“"
        print(f"{criterion}: {improvement:+.2f} {direction}")
    
    return monolithic_arch, evolved_arch

# åˆ†ææ¶æ„æ¼”åŒ–
mono_arch, evolved_arch = analyze_architecture_evolution()
```

## ğŸ”¬ ç†è®ºè¯æ˜

### å®šç†1: æ¶æ„å¤æ‚åº¦å®šç†

**å®šç†**: å¯¹äºåŒ…å« $n$ ä¸ªç»„ä»¶çš„è½¯ä»¶æ¶æ„ï¼Œå…¶å¤æ‚åº¦ $C$ æ»¡è¶³ï¼š

$$C \geq \frac{n(n-1)}{2} \cdot \frac{1}{n} = \frac{n-1}{2}$$

**è¯æ˜**:

1. **æœ€å°å¤æ‚åº¦**: å½“æ‰€æœ‰ç»„ä»¶éƒ½ç›¸äº’è¿æ¥æ—¶ï¼Œå¤æ‚åº¦è¾¾åˆ°æœ€å¤§å€¼
   - æ€»è¿æ¥æ•°: $\frac{n(n-1)}{2}$
   - å¹³å‡è¿æ¥æ•°: $\frac{n(n-1)}{2} \cdot \frac{1}{n} = \frac{n-1}{2}$

2. **å®é™…å¤æ‚åº¦**: å®é™…æ¶æ„çš„è¿æ¥æ•°é€šå¸¸å°äºå®Œå…¨å›¾
   - è®¾å®é™…è¿æ¥æ•°ä¸º $m$
   - åˆ™å¤æ‚åº¦ $C = \frac{m}{n} \geq \frac{n-1}{2}$

3. **ç»“è®º**: æ¶æ„å¤æ‚åº¦éšç»„ä»¶æ•°é‡çº¿æ€§å¢é•¿ï¼Œä½†å®é™…å¤æ‚åº¦é€šå¸¸è¿œä½äºç†è®ºæœ€å¤§å€¼ã€‚

### å®šç†2: è´¨é‡å±æ€§æƒè¡¡å®šç†

**å®šç†**: åœ¨è½¯ä»¶æ¶æ„ä¸­ï¼Œè´¨é‡å±æ€§ä¹‹é—´å­˜åœ¨æƒè¡¡å…³ç³»ï¼Œä¸å¯èƒ½åŒæ—¶ä¼˜åŒ–æ‰€æœ‰è´¨é‡å±æ€§ã€‚

**è¯æ˜**:

1. **æ€§èƒ½ vs å¯ç»´æŠ¤æ€§**:
   - æé«˜æ€§èƒ½é€šå¸¸éœ€è¦å¢åŠ ç¼“å­˜ã€ä¼˜åŒ–ç®—æ³•
   - è¿™å¢åŠ äº†ç³»ç»Ÿå¤æ‚åº¦ï¼Œé™ä½å¯ç»´æŠ¤æ€§
   - å› æ­¤å­˜åœ¨æƒè¡¡å…³ç³»

2. **å®‰å…¨æ€§ vs æ€§èƒ½**:
   - å¢åŠ å®‰å…¨æªæ–½ï¼ˆåŠ å¯†ã€è®¤è¯ï¼‰ä¼šå¢åŠ è®¡ç®—å¼€é”€
   - é™ä½ç³»ç»Ÿæ€§èƒ½
   - å› æ­¤å­˜åœ¨æƒè¡¡å…³ç³»

3. **å¯æ‰©å±•æ€§ vs ä¸€è‡´æ€§**:
   - æ°´å¹³æ‰©å±•é€šå¸¸éœ€è¦æ•°æ®åˆ†ç‰‡
   - è¿™å¢åŠ äº†æ•°æ®ä¸€è‡´æ€§çš„å¤æ‚æ€§
   - å› æ­¤å­˜åœ¨æƒè¡¡å…³ç³»

4. **ä¸€èˆ¬æ€§ç»“è®º**: ç”±äºèµ„æºé™åˆ¶å’Œè®¾è®¡çº¦æŸï¼Œä¸å¯èƒ½åŒæ—¶ä¼˜åŒ–æ‰€æœ‰è´¨é‡å±æ€§ã€‚

### å®šç†3: æ¶æ„ç¨³å®šæ€§å®šç†

**å®šç†**: å¦‚æœæ¶æ„ $A$ æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œåˆ™å®ƒæ˜¯ç¨³å®šçš„ï¼š

1. ç»„ä»¶é—´è€¦åˆåº¦ä½
2. ç»„ä»¶å†…èšåº¦é«˜
3. æ¥å£ç¨³å®š
4. å˜æ›´å½±å“èŒƒå›´æœ‰é™

**è¯æ˜**:

1. **ä½è€¦åˆ**: ç»„ä»¶é—´ä¾èµ–å°‘ï¼Œå˜æ›´å½±å“èŒƒå›´å°
   - è®¾ç»„ä»¶ $c_i$ çš„è€¦åˆåº¦ä¸º $coupling(c_i)$
   - ç¨³å®šæ€§ $S = 1 - \frac{\sum_{i} coupling(c_i)}{n}$

2. **é«˜å†…èš**: ç»„ä»¶èŒè´£æ˜ç¡®ï¼Œå†…éƒ¨å˜æ›´ä¸å½±å“å¤–éƒ¨
   - è®¾ç»„ä»¶ $c_i$ çš„å†…èšåº¦ä¸º $cohesion(c_i)$
   - ç¨³å®šæ€§ $S = \frac{\sum_{i} cohesion(c_i)}{n}$

3. **æ¥å£ç¨³å®š**: æ¥å£ä¸å˜ï¼Œå®ç°å¯ä»¥è‡ªç”±å˜æ›´
   - æ¥å£å˜æ›´é¢‘ç‡ $f_{interface}$
   - ç¨³å®šæ€§ $S = 1 - f_{interface}$

4. **ç»¼åˆç¨³å®šæ€§**:
   $$S_{total} = \alpha \cdot S_{coupling} + \beta \cdot S_{cohesion} + \gamma \cdot S_{interface}$$
   å…¶ä¸­ $\alpha + \beta + \gamma = 1$

5. **ç»“è®º**: å½“ $S_{total} > 0.8$ æ—¶ï¼Œæ¶æ„è¢«è®¤ä¸ºæ˜¯ç¨³å®šçš„ã€‚

## ğŸ”— ç›¸å…³é“¾æ¥

- [03-01-ç¼–ç¨‹è¯­è¨€ç§‘å­¦](./03-01-ç¼–ç¨‹è¯­è¨€ç§‘å­¦.md) - è¯­è¨€è¿è¡Œæ—¶æ¶æ„
- [03-03-è®¾è®¡æ¨¡å¼ç§‘å­¦](./03-03-è®¾è®¡æ¨¡å¼ç§‘å­¦.md) - æ¶æ„æ¨¡å¼åº”ç”¨
- [05-01-å¾®æœåŠ¡æ¶æ„](../05-æ¶æ„é¢†åŸŸ/05-01-å¾®æœåŠ¡æ¶æ„.md) - ç°ä»£æ¶æ„æ¨¡å¼
- [06-01-åŸºç¡€ç®—æ³•](../06-ç»„ä»¶ç®—æ³•/06-01-åŸºç¡€ç®—æ³•.md) - æ¶æ„ç®—æ³•å®ç°

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
