# è½¯ä»¶ç”Ÿå‘½å‘¨æœŸ

## ğŸ“š æ¦‚è¿°

è½¯ä»¶ç”Ÿå‘½å‘¨æœŸæ˜¯è½¯ä»¶å·¥ç¨‹ç§‘å­¦çš„æ ¸å¿ƒæ¦‚å¿µï¼Œæè¿°äº†è½¯ä»¶ä»æ¦‚å¿µåˆ°é€€å½¹çš„å®Œæ•´è¿‡ç¨‹ã€‚æœ¬æ–‡æ¡£ä»å…·ä½“ç§‘å­¦çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»è½¯ä»¶ç”Ÿå‘½å‘¨æœŸçš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è½¯ä»¶ç”Ÿå‘½å‘¨æœŸçš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 è½¯ä»¶ç”Ÿå‘½å‘¨æœŸçš„æ•°å­¦å®šä¹‰

è½¯ä»¶ç”Ÿå‘½å‘¨æœŸå¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$SLC = (P, T, S, R)$$

å…¶ä¸­ï¼š
- $P$ æ˜¯é˜¶æ®µé›†åˆ $P = \{p_1, p_2, \ldots, p_n\}$
- $T$ æ˜¯è½¬æ¢å…³ç³» $T \subseteq P \times P$
- $S$ æ˜¯çŠ¶æ€é›†åˆ $S = \{s_1, s_2, \ldots, s_m\}$
- $R$ æ˜¯è§„åˆ™é›†åˆ $R: P \times S \rightarrow S$

æ¯ä¸ªé˜¶æ®µ $p_i$ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$p_i = (name_i, duration_i, activities_i, artifacts_i)$$

#### 1.2 è½¯ä»¶ç”Ÿå‘½å‘¨æœŸçš„Pythonå®ç°

```python
from typing import Any, List, Dict, Set, Optional, Callable, Generic, TypeVar
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
import time
from datetime import datetime, timedelta

T = TypeVar('T')

class PhaseType(Enum):
    """é˜¶æ®µç±»å‹æšä¸¾"""
    REQUIREMENTS = "requirements"
    DESIGN = "design"
    IMPLEMENTATION = "implementation"
    TESTING = "testing"
    DEPLOYMENT = "deployment"
    MAINTENANCE = "maintenance"
    RETIREMENT = "retirement"

class ActivityType(Enum):
    """æ´»åŠ¨ç±»å‹æšä¸¾"""
    ANALYSIS = "analysis"
    DESIGN = "design"
    CODING = "coding"
    TESTING = "testing"
    REVIEW = "review"
    DOCUMENTATION = "documentation"

class ArtifactType(Enum):
    """åˆ¶å“ç±»å‹æšä¸¾"""
    DOCUMENT = "document"
    CODE = "code"
    TEST = "test"
    CONFIG = "config"
    DATA = "data"

@dataclass
class Activity:
    """è½¯ä»¶æ´»åŠ¨"""
    name: str
    type: ActivityType
    description: str
    duration: timedelta
    dependencies: List[str] = field(default_factory=list)
    resources: List[str] = field(default_factory=list)
    status: str = "pending"
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None

@dataclass
class Artifact:
    """è½¯ä»¶åˆ¶å“"""
    name: str
    type: ArtifactType
    content: Any
    version: str = "1.0"
    created_time: datetime = field(default_factory=datetime.now)
    modified_time: datetime = field(default_factory=datetime.now)
    dependencies: List[str] = field(default_factory=list)

@dataclass
class Phase:
    """è½¯ä»¶ç”Ÿå‘½å‘¨æœŸé˜¶æ®µ"""
    name: str
    type: PhaseType
    description: str
    duration: timedelta
    activities: List[Activity] = field(default_factory=list)
    artifacts: List[Artifact] = field(default_factory=list)
    entry_criteria: List[str] = field(default_factory=list)
    exit_criteria: List[str] = field(default_factory=list)
    status: str = "pending"
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None

@dataclass
class Transition:
    """é˜¶æ®µè½¬æ¢"""
    from_phase: str
    to_phase: str
    conditions: List[str] = field(default_factory=list)
    triggers: List[str] = field(default_factory=list)

class SoftwareLifecycle:
    """è½¯ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†"""
    
    def __init__(self, name: str):
        self.name = name
        self.phases: Dict[str, Phase] = {}
        self.transitions: List[Transition] = []
        self.current_phase: Optional[str] = None
        self.start_time: Optional[datetime] = None
        self.end_time: Optional[datetime] = None
        self.status = "initialized"
        
        # æ€§èƒ½æŒ‡æ ‡
        self.metrics = {
            'total_duration': timedelta(0),
            'phase_durations': {},
            'activity_counts': {},
            'artifact_counts': {}
        }
    
    def add_phase(self, phase: Phase):
        """æ·»åŠ é˜¶æ®µ"""
        self.phases[phase.name] = phase
    
    def add_transition(self, transition: Transition):
        """æ·»åŠ è½¬æ¢"""
        self.transitions.append(transition)
    
    def start_lifecycle(self):
        """å¼€å§‹ç”Ÿå‘½å‘¨æœŸ"""
        if not self.phases:
            raise ValueError("No phases defined")
        
        self.start_time = datetime.now()
        self.status = "started"
        
        # æ‰¾åˆ°ç¬¬ä¸€ä¸ªé˜¶æ®µ
        first_phase = next(iter(self.phases.values()))
        self.current_phase = first_phase.name
        first_phase.start_time = self.start_time
        first_phase.status = "active"
        
        print(f"è½¯ä»¶ç”Ÿå‘½å‘¨æœŸ '{self.name}' å·²å¼€å§‹")
        print(f"å½“å‰é˜¶æ®µ: {first_phase.name}")
    
    def complete_phase(self, phase_name: str):
        """å®Œæˆé˜¶æ®µ"""
        if phase_name not in self.phases:
            raise ValueError(f"Phase '{phase_name}' not found")
        
        phase = self.phases[phase_name]
        phase.end_time = datetime.now()
        phase.status = "completed"
        
        # è®¡ç®—é˜¶æ®µæŒç»­æ—¶é—´
        if phase.start_time:
            duration = phase.end_time - phase.start_time
            self.metrics['phase_durations'][phase_name] = duration
        
        print(f"é˜¶æ®µ '{phase_name}' å·²å®Œæˆ")
        
        # æŸ¥æ‰¾ä¸‹ä¸€ä¸ªé˜¶æ®µ
        next_phase = self._find_next_phase(phase_name)
        if next_phase:
            self._transition_to_phase(next_phase)
        else:
            self._complete_lifecycle()
    
    def _find_next_phase(self, current_phase: str) -> Optional[str]:
        """æŸ¥æ‰¾ä¸‹ä¸€ä¸ªé˜¶æ®µ"""
        for transition in self.transitions:
            if transition.from_phase == current_phase:
                # æ£€æŸ¥è½¬æ¢æ¡ä»¶
                if self._check_transition_conditions(transition):
                    return transition.to_phase
        return None
    
    def _check_transition_conditions(self, transition: Transition) -> bool:
        """æ£€æŸ¥è½¬æ¢æ¡ä»¶"""
        # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥å½“å‰é˜¶æ®µæ˜¯å¦å®Œæˆ
        current_phase = self.phases[transition.from_phase]
        return current_phase.status == "completed"
    
    def _transition_to_phase(self, phase_name: str):
        """è½¬æ¢åˆ°æŒ‡å®šé˜¶æ®µ"""
        phase = self.phases[phase_name]
        phase.start_time = datetime.now()
        phase.status = "active"
        self.current_phase = phase_name
        
        print(f"è½¬æ¢åˆ°é˜¶æ®µ: {phase_name}")
    
    def _complete_lifecycle(self):
        """å®Œæˆç”Ÿå‘½å‘¨æœŸ"""
        self.end_time = datetime.now()
        self.status = "completed"
        
        if self.start_time:
            self.metrics['total_duration'] = self.end_time - self.start_time
        
        print(f"è½¯ä»¶ç”Ÿå‘½å‘¨æœŸ '{self.name}' å·²å®Œæˆ")
        print(f"æ€»æŒç»­æ—¶é—´: {self.metrics['total_duration']}")
    
    def get_current_phase(self) -> Optional[Phase]:
        """è·å–å½“å‰é˜¶æ®µ"""
        if self.current_phase:
            return self.phases[self.current_phase]
        return None
    
    def get_phase_progress(self, phase_name: str) -> float:
        """è·å–é˜¶æ®µè¿›åº¦"""
        if phase_name not in self.phases:
            return 0.0
        
        phase = self.phases[phase_name]
        if phase.status == "completed":
            return 1.0
        elif phase.status == "pending":
            return 0.0
        else:
            # è®¡ç®—æ´»åŠ¨å®Œæˆè¿›åº¦
            completed_activities = sum(1 for activity in phase.activities 
                                     if activity.status == "completed")
            total_activities = len(phase.activities)
            return completed_activities / total_activities if total_activities > 0 else 0.0
    
    def get_overall_progress(self) -> float:
        """è·å–æ•´ä½“è¿›åº¦"""
        if not self.phases:
            return 0.0
        
        completed_phases = sum(1 for phase in self.phases.values() 
                              if phase.status == "completed")
        total_phases = len(self.phases)
        return completed_phases / total_phases
    
    def generate_report(self) -> str:
        """ç”Ÿæˆç”Ÿå‘½å‘¨æœŸæŠ¥å‘Š"""
        report = f"è½¯ä»¶ç”Ÿå‘½å‘¨æœŸæŠ¥å‘Š: {self.name}\n"
        report += "=" * 50 + "\n\n"
        
        report += f"çŠ¶æ€: {self.status}\n"
        if self.start_time:
            report += f"å¼€å§‹æ—¶é—´: {self.start_time}\n"
        if self.end_time:
            report += f"ç»“æŸæ—¶é—´: {self.end_time}\n"
        report += f"æ€»æŒç»­æ—¶é—´: {self.metrics['total_duration']}\n\n"
        
        report += "é˜¶æ®µè¯¦æƒ…:\n"
        for phase_name, phase in self.phases.items():
            progress = self.get_phase_progress(phase_name)
            report += f"  {phase_name}:\n"
            report += f"    çŠ¶æ€: {phase.status}\n"
            report += f"    è¿›åº¦: {progress:.1%}\n"
            if phase_name in self.metrics['phase_durations']:
                report += f"    æŒç»­æ—¶é—´: {self.metrics['phase_durations'][phase_name]}\n"
            report += "\n"
        
        report += f"æ•´ä½“è¿›åº¦: {self.get_overall_progress():.1%}\n"
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
# åˆ›å»ºè½¯ä»¶ç”Ÿå‘½å‘¨æœŸ
lifecycle = SoftwareLifecycle("Webåº”ç”¨å¼€å‘")

# å®šä¹‰é˜¶æ®µ
requirements_phase = Phase(
    name="éœ€æ±‚åˆ†æ",
    type=PhaseType.REQUIREMENTS,
    description="æ”¶é›†å’Œåˆ†æç”¨æˆ·éœ€æ±‚",
    duration=timedelta(days=7),
    entry_criteria=["é¡¹ç›®å¯åŠ¨"],
    exit_criteria=["éœ€æ±‚æ–‡æ¡£å®Œæˆ", "éœ€æ±‚è¯„å®¡é€šè¿‡"]
)

design_phase = Phase(
    name="ç³»ç»Ÿè®¾è®¡",
    type=PhaseType.DESIGN,
    description="è®¾è®¡ç³»ç»Ÿæ¶æ„å’Œè¯¦ç»†è®¾è®¡",
    duration=timedelta(days=10),
    entry_criteria=["éœ€æ±‚åˆ†æå®Œæˆ"],
    exit_criteria=["è®¾è®¡æ–‡æ¡£å®Œæˆ", "è®¾è®¡è¯„å®¡é€šè¿‡"]
)

implementation_phase = Phase(
    name="ç¼–ç å®ç°",
    type=PhaseType.IMPLEMENTATION,
    description="ç¼–å†™ä»£ç å®ç°åŠŸèƒ½",
    duration=timedelta(days=21),
    entry_criteria=["ç³»ç»Ÿè®¾è®¡å®Œæˆ"],
    exit_criteria=["ä»£ç å®Œæˆ", "ä»£ç å®¡æŸ¥é€šè¿‡"]
)

testing_phase = Phase(
    name="æµ‹è¯•éªŒè¯",
    type=PhaseType.TESTING,
    description="è¿›è¡Œå„ç§æµ‹è¯•",
    duration=timedelta(days=14),
    entry_criteria=["ç¼–ç å®ç°å®Œæˆ"],
    exit_criteria=["æµ‹è¯•é€šè¿‡", "ç¼ºé™·ä¿®å¤å®Œæˆ"]
)

deployment_phase = Phase(
    name="éƒ¨ç½²ä¸Šçº¿",
    type=PhaseType.DEPLOYMENT,
    description="éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ",
    duration=timedelta(days=3),
    entry_criteria=["æµ‹è¯•éªŒè¯å®Œæˆ"],
    exit_criteria=["éƒ¨ç½²æˆåŠŸ", "ç”¨æˆ·éªŒæ”¶é€šè¿‡"]
)

# æ·»åŠ é˜¶æ®µ
lifecycle.add_phase(requirements_phase)
lifecycle.add_phase(design_phase)
lifecycle.add_phase(implementation_phase)
lifecycle.add_phase(testing_phase)
lifecycle.add_phase(deployment_phase)

# å®šä¹‰è½¬æ¢
transitions = [
    Transition("éœ€æ±‚åˆ†æ", "ç³»ç»Ÿè®¾è®¡"),
    Transition("ç³»ç»Ÿè®¾è®¡", "ç¼–ç å®ç°"),
    Transition("ç¼–ç å®ç°", "æµ‹è¯•éªŒè¯"),
    Transition("æµ‹è¯•éªŒè¯", "éƒ¨ç½²ä¸Šçº¿")
]

for transition in transitions:
    lifecycle.add_transition(transition)

# å¼€å§‹ç”Ÿå‘½å‘¨æœŸ
lifecycle.start_lifecycle()

# æ¨¡æ‹Ÿé˜¶æ®µå®Œæˆ
import time
time.sleep(1)  # æ¨¡æ‹Ÿæ—¶é—´æµé€
lifecycle.complete_phase("éœ€æ±‚åˆ†æ")

time.sleep(1)
lifecycle.complete_phase("ç³»ç»Ÿè®¾è®¡")

time.sleep(1)
lifecycle.complete_phase("ç¼–ç å®ç°")

time.sleep(1)
lifecycle.complete_phase("æµ‹è¯•éªŒè¯")

time.sleep(1)
lifecycle.complete_phase("éƒ¨ç½²ä¸Šçº¿")

# ç”ŸæˆæŠ¥å‘Š
print(lifecycle.generate_report())
```

### 2. ç€‘å¸ƒæ¨¡å‹

#### 2.1 ç€‘å¸ƒæ¨¡å‹çš„æ•°å­¦å®šä¹‰

ç€‘å¸ƒæ¨¡å‹å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$WM = (P_{seq}, T_{seq}, V_{gate})$$

å…¶ä¸­ï¼š
- $P_{seq} = \{p_1, p_2, \ldots, p_n\}$ æ˜¯é¡ºåºé˜¶æ®µé›†åˆ
- $T_{seq} = \{(p_i, p_{i+1}) | i = 1, 2, \ldots, n-1\}$ æ˜¯é¡ºåºè½¬æ¢å…³ç³»
- $V_{gate}$ æ˜¯éªŒè¯é—¨æ§å‡½æ•°

#### 2.2 ç€‘å¸ƒæ¨¡å‹çš„Pythonå®ç°

```python
class WaterfallModel(SoftwareLifecycle):
    """ç€‘å¸ƒæ¨¡å‹"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.phase_order = [
            "éœ€æ±‚åˆ†æ",
            "ç³»ç»Ÿè®¾è®¡", 
            "è¯¦ç»†è®¾è®¡",
            "ç¼–ç å®ç°",
            "å•å…ƒæµ‹è¯•",
            "é›†æˆæµ‹è¯•",
            "ç³»ç»Ÿæµ‹è¯•",
            "éªŒæ”¶æµ‹è¯•",
            "éƒ¨ç½²ç»´æŠ¤"
        ]
        self.verification_gates = {}
    
    def add_verification_gate(self, phase_name: str, criteria: List[str]):
        """æ·»åŠ éªŒè¯é—¨æ§"""
        self.verification_gates[phase_name] = criteria
    
    def verify_phase(self, phase_name: str) -> bool:
        """éªŒè¯é˜¶æ®µ"""
        if phase_name not in self.verification_gates:
            return True
        
        criteria = self.verification_gates[phase_name]
        phase = self.phases[phase_name]
        
        # æ£€æŸ¥åˆ¶å“æ˜¯å¦æ»¡è¶³æ ‡å‡†
        for criterion in criteria:
            if not self._check_criterion(phase, criterion):
                print(f"éªŒè¯å¤±è´¥: {criterion}")
                return False
        
        print(f"é˜¶æ®µ '{phase_name}' éªŒè¯é€šè¿‡")
        return True
    
    def _check_criterion(self, phase: Phase, criterion: str) -> bool:
        """æ£€æŸ¥æ ‡å‡†"""
        # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç›¸å…³åˆ¶å“
        for artifact in phase.artifacts:
            if criterion.lower() in artifact.name.lower():
                return True
        return False
    
    def complete_phase(self, phase_name: str):
        """å®Œæˆé˜¶æ®µï¼ˆåŒ…å«éªŒè¯ï¼‰"""
        if not self.verify_phase(phase_name):
            print(f"é˜¶æ®µ '{phase_name}' éªŒè¯å¤±è´¥ï¼Œæ— æ³•è¿›å…¥ä¸‹ä¸€é˜¶æ®µ")
            return
        
        super().complete_phase(phase_name)
    
    def get_phase_dependencies(self) -> Dict[str, List[str]]:
        """è·å–é˜¶æ®µä¾èµ–å…³ç³»"""
        dependencies = {}
        for i, phase_name in enumerate(self.phase_order):
            if i > 0:
                dependencies[phase_name] = [self.phase_order[i-1]]
            else:
                dependencies[phase_name] = []
        return dependencies

# ä½¿ç”¨ç¤ºä¾‹
waterfall = WaterfallModel("ä¼ä¸šç®¡ç†ç³»ç»Ÿ")

# æ·»åŠ éªŒè¯é—¨æ§
waterfall.add_verification_gate("éœ€æ±‚åˆ†æ", [
    "éœ€æ±‚æ–‡æ¡£å®Œæ•´æ€§",
    "éœ€æ±‚å¯è¿½æº¯æ€§",
    "éœ€æ±‚ä¸€è‡´æ€§"
])

waterfall.add_verification_gate("ç³»ç»Ÿè®¾è®¡", [
    "æ¶æ„è®¾è®¡æ–‡æ¡£",
    "æ¥å£è®¾è®¡è§„èŒƒ",
    "æ•°æ®åº“è®¾è®¡"
])

waterfall.add_verification_gate("ç¼–ç å®ç°", [
    "ä»£ç è§„èŒƒæ£€æŸ¥",
    "å•å…ƒæµ‹è¯•è¦†ç›–ç‡",
    "ä»£ç å®¡æŸ¥è®°å½•"
])

# åˆ›å»ºåˆ¶å“
req_doc = Artifact("éœ€æ±‚æ–‡æ¡£", ArtifactType.DOCUMENT, "è¯¦ç»†çš„éœ€æ±‚æè¿°")
arch_doc = Artifact("æ¶æ„è®¾è®¡æ–‡æ¡£", ArtifactType.DOCUMENT, "ç³»ç»Ÿæ¶æ„è®¾è®¡")
code_review = Artifact("ä»£ç å®¡æŸ¥è®°å½•", ArtifactType.DOCUMENT, "ä»£ç å®¡æŸ¥ç»“æœ")

# æ·»åŠ åˆ¶å“åˆ°é˜¶æ®µ
waterfall.phases["éœ€æ±‚åˆ†æ"].artifacts.append(req_doc)
waterfall.phases["ç³»ç»Ÿè®¾è®¡"].artifacts.append(arch_doc)
waterfall.phases["ç¼–ç å®ç°"].artifacts.append(code_review)

# å¼€å§‹ç€‘å¸ƒæ¨¡å‹
waterfall.start_lifecycle()

# éªŒè¯å’Œå®Œæˆé˜¶æ®µ
waterfall.complete_phase("éœ€æ±‚åˆ†æ")
waterfall.complete_phase("ç³»ç»Ÿè®¾è®¡")
waterfall.complete_phase("ç¼–ç å®ç°")

print(waterfall.generate_report())
```

### 3. æ•æ·æ¨¡å‹

#### 3.1 æ•æ·æ¨¡å‹çš„æ•°å­¦å®šä¹‰

æ•æ·æ¨¡å‹å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$AM = (S_{sprint}, B_{backlog}, V_{velocity}, R_{retro})$$

å…¶ä¸­ï¼š
- $S_{sprint}$ æ˜¯å†²åˆºé›†åˆ
- $B_{backlog}$ æ˜¯äº§å“å¾…åŠäº‹é¡¹
- $V_{velocity}$ æ˜¯å›¢é˜Ÿé€Ÿåº¦
- $R_{retro}$ æ˜¯å›é¡¾å‡½æ•°

#### 3.2 æ•æ·æ¨¡å‹çš„Pythonå®ç°

```python
@dataclass
class UserStory:
    """ç”¨æˆ·æ•…äº‹"""
    id: str
    title: str
    description: str
    priority: int
    story_points: int
    status: str = "backlog"
    assignee: Optional[str] = None
    sprint: Optional[str] = None

@dataclass
class Sprint:
    """å†²åˆº"""
    id: str
    name: str
    start_date: datetime
    end_date: datetime
    velocity: int
    stories: List[UserStory] = field(default_factory=list)
    status: str = "planned"

class AgileModel:
    """æ•æ·æ¨¡å‹"""
    
    def __init__(self, name: str):
        self.name = name
        self.product_backlog: List[UserStory] = []
        self.sprints: List[Sprint] = []
        self.current_sprint: Optional[Sprint] = None
        self.team_velocity = 0
        self.sprint_duration = timedelta(weeks=2)
        
        # æ•æ·æŒ‡æ ‡
        self.metrics = {
            'total_stories': 0,
            'completed_stories': 0,
            'total_story_points': 0,
            'completed_story_points': 0,
            'sprint_velocities': [],
            'burndown_data': []
        }
    
    def add_user_story(self, story: UserStory):
        """æ·»åŠ ç”¨æˆ·æ•…äº‹"""
        self.product_backlog.append(story)
        self.product_backlog.sort(key=lambda x: x.priority, reverse=True)
        self.metrics['total_stories'] += 1
        self.metrics['total_story_points'] += story.story_points
    
    def create_sprint(self, name: str, start_date: datetime) -> Sprint:
        """åˆ›å»ºå†²åˆº"""
        end_date = start_date + self.sprint_duration
        sprint = Sprint(
            id=f"sprint_{len(self.sprints) + 1}",
            name=name,
            start_date=start_date,
            end_date=end_date,
            velocity=self.team_velocity
        )
        self.sprints.append(sprint)
        return sprint
    
    def plan_sprint(self, sprint: Sprint, stories: List[UserStory]):
        """è§„åˆ’å†²åˆº"""
        total_points = sum(story.story_points for story in stories)
        
        if total_points > sprint.velocity:
            print(f"è­¦å‘Š: æ•…äº‹ç‚¹æ•° ({total_points}) è¶…è¿‡å›¢é˜Ÿé€Ÿåº¦ ({sprint.velocity})")
        
        for story in stories:
            story.sprint = sprint.id
            story.status = "planned"
            sprint.stories.append(story)
        
        sprint.status = "active"
        self.current_sprint = sprint
    
    def complete_story(self, story_id: str):
        """å®Œæˆç”¨æˆ·æ•…äº‹"""
        for sprint in self.sprints:
            for story in sprint.stories:
                if story.id == story_id:
                    story.status = "completed"
                    self.metrics['completed_stories'] += 1
                    self.metrics['completed_story_points'] += story.story_points
                    print(f"ç”¨æˆ·æ•…äº‹ '{story.title}' å·²å®Œæˆ")
                    return
        
        print(f"æœªæ‰¾åˆ°ç”¨æˆ·æ•…äº‹: {story_id}")
    
    def complete_sprint(self, sprint: Sprint):
        """å®Œæˆå†²åˆº"""
        completed_points = sum(story.story_points for story in sprint.stories 
                              if story.status == "completed")
        
        # æ›´æ–°å›¢é˜Ÿé€Ÿåº¦
        self.team_velocity = int(completed_points * 0.8 + self.team_velocity * 0.2)
        self.metrics['sprint_velocities'].append(completed_points)
        
        sprint.status = "completed"
        print(f"å†²åˆº '{sprint.name}' å·²å®Œæˆ")
        print(f"å®Œæˆæ•…äº‹ç‚¹æ•°: {completed_points}")
        print(f"æ›´æ–°å›¢é˜Ÿé€Ÿåº¦: {self.team_velocity}")
    
    def calculate_burndown(self, sprint: Sprint) -> List[Dict[str, Any]]:
        """è®¡ç®—ç‡ƒå°½å›¾æ•°æ®"""
        total_points = sum(story.story_points for story in sprint.stories)
        sprint_days = (sprint.end_date - sprint.start_date).days
        
        burndown = []
        for day in range(sprint_days + 1):
            current_date = sprint.start_date + timedelta(days=day)
            completed_points = sum(story.story_points for story in sprint.stories 
                                  if story.status == "completed")
            
            burndown.append({
                'day': day,
                'date': current_date,
                'remaining_points': total_points - completed_points,
                'ideal_burndown': total_points * (1 - day / sprint_days)
            })
        
        return burndown
    
    def generate_sprint_report(self, sprint: Sprint) -> str:
        """ç”Ÿæˆå†²åˆºæŠ¥å‘Š"""
        report = f"å†²åˆºæŠ¥å‘Š: {sprint.name}\n"
        report += "=" * 30 + "\n\n"
        
        report += f"çŠ¶æ€: {sprint.status}\n"
        report += f"å¼€å§‹æ—¥æœŸ: {sprint.start_date}\n"
        report += f"ç»“æŸæ—¥æœŸ: {sprint.end_date}\n"
        report += f"è®¡åˆ’é€Ÿåº¦: {sprint.velocity}\n\n"
        
        # æ•…äº‹ç»Ÿè®¡
        total_stories = len(sprint.stories)
        completed_stories = sum(1 for story in sprint.stories 
                               if story.status == "completed")
        total_points = sum(story.story_points for story in sprint.stories)
        completed_points = sum(story.story_points for story in sprint.stories 
                              if story.status == "completed")
        
        report += f"æ•…äº‹ç»Ÿè®¡:\n"
        report += f"  æ€»æ•…äº‹æ•°: {total_stories}\n"
        report += f"  å®Œæˆæ•…äº‹æ•°: {completed_stories}\n"
        report += f"  æ€»æ•…äº‹ç‚¹æ•°: {total_points}\n"
        report += f"  å®Œæˆæ•…äº‹ç‚¹æ•°: {completed_points}\n"
        report += f"  å®Œæˆç‡: {completed_stories/total_stories:.1%}\n\n"
        
        # æ•…äº‹è¯¦æƒ…
        report += "æ•…äº‹è¯¦æƒ…:\n"
        for story in sprint.stories:
            status_icon = "âœ“" if story.status == "completed" else "â—‹"
            report += f"  {status_icon} {story.title} ({story.story_points} ç‚¹)\n"
        
        return report
    
    def generate_product_report(self) -> str:
        """ç”Ÿæˆäº§å“æŠ¥å‘Š"""
        report = f"äº§å“æŠ¥å‘Š: {self.name}\n"
        report += "=" * 30 + "\n\n"
        
        report += f"æ€»æ•…äº‹æ•°: {self.metrics['total_stories']}\n"
        report += f"å®Œæˆæ•…äº‹æ•°: {self.metrics['completed_stories']}\n"
        report += f"æ€»æ•…äº‹ç‚¹æ•°: {self.metrics['total_story_points']}\n"
        report += f"å®Œæˆæ•…äº‹ç‚¹æ•°: {self.metrics['completed_story_points']}\n"
        report += f"æ•´ä½“å®Œæˆç‡: {self.metrics['completed_stories']/self.metrics['total_stories']:.1%}\n\n"
        
        if self.metrics['sprint_velocities']:
            avg_velocity = sum(self.metrics['sprint_velocities']) / len(self.metrics['sprint_velocities'])
            report += f"å¹³å‡å†²åˆºé€Ÿåº¦: {avg_velocity:.1f} ç‚¹\n"
            report += f"å½“å‰å›¢é˜Ÿé€Ÿåº¦: {self.team_velocity} ç‚¹\n"
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
agile = AgileModel("ç”µå•†å¹³å°")

# è®¾ç½®åˆå§‹å›¢é˜Ÿé€Ÿåº¦
agile.team_velocity = 20

# åˆ›å»ºç”¨æˆ·æ•…äº‹
stories = [
    UserStory("US001", "ç”¨æˆ·æ³¨å†Œ", "ç”¨æˆ·å¯ä»¥æ³¨å†Œæ–°è´¦æˆ·", 1, 3),
    UserStory("US002", "ç”¨æˆ·ç™»å½•", "ç”¨æˆ·å¯ä»¥ç™»å½•ç³»ç»Ÿ", 1, 2),
    UserStory("US003", "å•†å“æµè§ˆ", "ç”¨æˆ·å¯ä»¥æµè§ˆå•†å“åˆ—è¡¨", 2, 5),
    UserStory("US004", "è´­ç‰©è½¦", "ç”¨æˆ·å¯ä»¥æ·»åŠ å•†å“åˆ°è´­ç‰©è½¦", 2, 8),
    UserStory("US005", "è®¢å•ç®¡ç†", "ç”¨æˆ·å¯ä»¥ç®¡ç†è®¢å•", 3, 13),
    UserStory("US006", "æ”¯ä»˜åŠŸèƒ½", "ç”¨æˆ·å¯ä»¥å®Œæˆæ”¯ä»˜", 3, 8)
]

for story in stories:
    agile.add_user_story(story)

# åˆ›å»ºç¬¬ä¸€ä¸ªå†²åˆº
sprint1 = agile.create_sprint("Sprint 1", datetime.now())
agile.plan_sprint(sprint1, stories[:3])  # å‰3ä¸ªæ•…äº‹

# å®Œæˆä¸€äº›æ•…äº‹
agile.complete_story("US001")
agile.complete_story("US002")

# å®Œæˆå†²åˆº
agile.complete_sprint(sprint1)

# åˆ›å»ºç¬¬äºŒä¸ªå†²åˆº
sprint2 = agile.create_sprint("Sprint 2", datetime.now() + timedelta(weeks=2))
agile.plan_sprint(sprint2, stories[3:])  # å3ä¸ªæ•…äº‹

# å®Œæˆæ›´å¤šæ•…äº‹
agile.complete_story("US003")
agile.complete_story("US004")

# å®Œæˆç¬¬äºŒä¸ªå†²åˆº
agile.complete_sprint(sprint2)

# ç”ŸæˆæŠ¥å‘Š
print(agile.generate_sprint_report(sprint1))
print(agile.generate_sprint_report(sprint2))
print(agile.generate_product_report())
```

### 4. èºæ—‹æ¨¡å‹

#### 4.1 èºæ—‹æ¨¡å‹çš„æ•°å­¦å®šä¹‰

èºæ—‹æ¨¡å‹å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$SM = (C_{cycles}, R_{risk}, P_{prototype}, E_{evaluation})$$

å…¶ä¸­ï¼š
- $C_{cycles}$ æ˜¯èºæ—‹å‘¨æœŸé›†åˆ
- $R_{risk}$ æ˜¯é£é™©è¯„ä¼°å‡½æ•°
- $P_{prototype}$ æ˜¯åŸå‹å¼€å‘å‡½æ•°
- $E_{evaluation}$ æ˜¯è¯„ä¼°å‡½æ•°

#### 4.2 èºæ—‹æ¨¡å‹çš„Pythonå®ç°

```python
@dataclass
class Risk:
    """é£é™©"""
    id: str
    name: str
    description: str
    probability: float  # 0-1
    impact: float  # 0-1
    mitigation: str
    status: str = "identified"

@dataclass
class Prototype:
    """åŸå‹"""
    id: str
    name: str
    purpose: str
    features: List[str]
    status: str = "planned"
    feedback: List[str] = field(default_factory=list)

@dataclass
class SpiralCycle:
    """èºæ—‹å‘¨æœŸ"""
    id: str
    name: str
    objectives: List[str]
    risks: List[Risk] = field(default_factory=list)
    prototypes: List[Prototype] = field(default_factory=list)
    evaluation: Dict[str, Any] = field(default_factory=dict)
    status: str = "planned"

class SpiralModel:
    """èºæ—‹æ¨¡å‹"""
    
    def __init__(self, name: str):
        self.name = name
        self.cycles: List[SpiralCycle] = []
        self.current_cycle: Optional[SpiralCycle] = None
        self.risk_threshold = 0.7  # é£é™©é˜ˆå€¼
        
        # èºæ—‹æ¨¡å‹æŒ‡æ ‡
        self.metrics = {
            'total_cycles': 0,
            'completed_cycles': 0,
            'total_risks': 0,
            'mitigated_risks': 0,
            'total_prototypes': 0,
            'successful_prototypes': 0
        }
    
    def add_cycle(self, cycle: SpiralCycle):
        """æ·»åŠ èºæ—‹å‘¨æœŸ"""
        self.cycles.append(cycle)
        self.metrics['total_cycles'] += 1
    
    def start_cycle(self, cycle_id: str):
        """å¼€å§‹èºæ—‹å‘¨æœŸ"""
        cycle = self._find_cycle(cycle_id)
        if not cycle:
            raise ValueError(f"Cycle '{cycle_id}' not found")
        
        cycle.status = "active"
        self.current_cycle = cycle
        print(f"å¼€å§‹èºæ—‹å‘¨æœŸ: {cycle.name}")
    
    def add_risk(self, cycle_id: str, risk: Risk):
        """æ·»åŠ é£é™©"""
        cycle = self._find_cycle(cycle_id)
        if cycle:
            cycle.risks.append(risk)
            self.metrics['total_risks'] += 1
    
    def assess_risks(self, cycle_id: str) -> Dict[str, float]:
        """è¯„ä¼°é£é™©"""
        cycle = self._find_cycle(cycle_id)
        if not cycle:
            return {}
        
        risk_assessment = {}
        total_risk_score = 0
        
        for risk in cycle.risks:
            risk_score = risk.probability * risk.impact
            risk_assessment[risk.name] = risk_score
            total_risk_score += risk_score
        
        risk_assessment['total_risk'] = total_risk_score
        
        if total_risk_score > self.risk_threshold:
            print(f"è­¦å‘Š: å‘¨æœŸ '{cycle.name}' é£é™©è¿‡é«˜ ({total_risk_score:.2f})")
        
        return risk_assessment
    
    def create_prototype(self, cycle_id: str, prototype: Prototype):
        """åˆ›å»ºåŸå‹"""
        cycle = self._find_cycle(cycle_id)
        if cycle:
            cycle.prototypes.append(prototype)
            self.metrics['total_prototypes'] += 1
    
    def evaluate_prototype(self, cycle_id: str, prototype_id: str, 
                          evaluation: Dict[str, Any]):
        """è¯„ä¼°åŸå‹"""
        cycle = self._find_cycle(cycle_id)
        if not cycle:
            return
        
        for prototype in cycle.prototypes:
            if prototype.id == prototype_id:
                prototype.status = "evaluated"
                prototype.feedback.extend(evaluation.get('feedback', []))
                
                if evaluation.get('success', False):
                    prototype.status = "successful"
                    self.metrics['successful_prototypes'] += 1
                
                print(f"åŸå‹ '{prototype.name}' è¯„ä¼°å®Œæˆ")
                break
    
    def complete_cycle(self, cycle_id: str):
        """å®Œæˆèºæ—‹å‘¨æœŸ"""
        cycle = self._find_cycle(cycle_id)
        if not cycle:
            return
        
        # è¯„ä¼°å‘¨æœŸ
        risk_assessment = self.assess_risks(cycle_id)
        cycle.evaluation = {
            'risk_assessment': risk_assessment,
            'prototype_success_rate': self._calculate_prototype_success_rate(cycle),
            'objectives_achieved': self._evaluate_objectives(cycle)
        }
        
        cycle.status = "completed"
        self.metrics['completed_cycles'] += 1
        
        # è®¡ç®—é£é™©ç¼“è§£
        mitigated_risks = sum(1 for risk in cycle.risks 
                             if risk.status == "mitigated")
        self.metrics['mitigated_risks'] += mitigated_risks
        
        print(f"èºæ—‹å‘¨æœŸ '{cycle.name}' å·²å®Œæˆ")
        print(f"é£é™©è¯„ä¼°: {risk_assessment['total_risk']:.2f}")
    
    def _find_cycle(self, cycle_id: str) -> Optional[SpiralCycle]:
        """æŸ¥æ‰¾å‘¨æœŸ"""
        for cycle in self.cycles:
            if cycle.id == cycle_id:
                return cycle
        return None
    
    def _calculate_prototype_success_rate(self, cycle: SpiralCycle) -> float:
        """è®¡ç®—åŸå‹æˆåŠŸç‡"""
        if not cycle.prototypes:
            return 0.0
        
        successful = sum(1 for p in cycle.prototypes 
                        if p.status == "successful")
        return successful / len(cycle.prototypes)
    
    def _evaluate_objectives(self, cycle: SpiralCycle) -> List[str]:
        """è¯„ä¼°ç›®æ ‡è¾¾æˆæƒ…å†µ"""
        # ç®€åŒ–å®ç°ï¼šå‡è®¾æ‰€æœ‰ç›®æ ‡éƒ½è¾¾æˆ
        return cycle.objectives
    
    def generate_cycle_report(self, cycle_id: str) -> str:
        """ç”Ÿæˆå‘¨æœŸæŠ¥å‘Š"""
        cycle = self._find_cycle(cycle_id)
        if not cycle:
            return "å‘¨æœŸæœªæ‰¾åˆ°"
        
        report = f"èºæ—‹å‘¨æœŸæŠ¥å‘Š: {cycle.name}\n"
        report += "=" * 40 + "\n\n"
        
        report += f"çŠ¶æ€: {cycle.status}\n"
        report += f"ç›®æ ‡: {', '.join(cycle.objectives)}\n\n"
        
        # é£é™©ä¿¡æ¯
        report += f"é£é™©ä¿¡æ¯:\n"
        report += f"  æ€»é£é™©æ•°: {len(cycle.risks)}\n"
        mitigated = sum(1 for risk in cycle.risks 
                       if risk.status == "mitigated")
        report += f"  å·²ç¼“è§£é£é™©: {mitigated}\n"
        
        if cycle.evaluation:
            total_risk = cycle.evaluation['risk_assessment'].get('total_risk', 0)
            report += f"  æ€»é£é™©è¯„åˆ†: {total_risk:.2f}\n"
        
        report += "\n"
        
        # åŸå‹ä¿¡æ¯
        report += f"åŸå‹ä¿¡æ¯:\n"
        report += f"  æ€»åŸå‹æ•°: {len(cycle.prototypes)}\n"
        successful = sum(1 for p in cycle.prototypes 
                        if p.status == "successful")
        report += f"  æˆåŠŸåŸå‹: {successful}\n"
        
        if cycle.evaluation:
            success_rate = cycle.evaluation['prototype_success_rate']
            report += f"  æˆåŠŸç‡: {success_rate:.1%}\n"
        
        return report
    
    def generate_model_report(self) -> str:
        """ç”Ÿæˆæ¨¡å‹æŠ¥å‘Š"""
        report = f"èºæ—‹æ¨¡å‹æŠ¥å‘Š: {self.name}\n"
        report += "=" * 40 + "\n\n"
        
        report += f"æ€»å‘¨æœŸæ•°: {self.metrics['total_cycles']}\n"
        report += f"å®Œæˆå‘¨æœŸæ•°: {self.metrics['completed_cycles']}\n"
        report += f"å®Œæˆç‡: {self.metrics['completed_cycles']/self.metrics['total_cycles']:.1%}\n\n"
        
        report += f"æ€»é£é™©æ•°: {self.metrics['total_risks']}\n"
        report += f"å·²ç¼“è§£é£é™©: {self.metrics['mitigated_risks']}\n"
        report += f"é£é™©ç¼“è§£ç‡: {self.metrics['mitigated_risks']/self.metrics['total_risks']:.1%}\n\n"
        
        report += f"æ€»åŸå‹æ•°: {self.metrics['total_prototypes']}\n"
        report += f"æˆåŠŸåŸå‹: {self.metrics['successful_prototypes']}\n"
        report += f"åŸå‹æˆåŠŸç‡: {self.metrics['successful_prototypes']/self.metrics['total_prototypes']:.1%}\n"
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
spiral = SpiralModel("å¤æ‚ç³»ç»Ÿå¼€å‘")

# åˆ›å»ºèºæ—‹å‘¨æœŸ
cycle1 = SpiralCycle(
    id="cycle1",
    name="éœ€æ±‚æ¢ç´¢å‘¨æœŸ",
    objectives=["æ˜ç¡®ç”¨æˆ·éœ€æ±‚", "éªŒè¯æŠ€æœ¯å¯è¡Œæ€§"]
)

cycle2 = SpiralCycle(
    id="cycle2", 
    name="æ¶æ„è®¾è®¡å‘¨æœŸ",
    objectives=["è®¾è®¡ç³»ç»Ÿæ¶æ„", "éªŒè¯æ¶æ„æ–¹æ¡ˆ"]
)

cycle3 = SpiralCycle(
    id="cycle3",
    name="å®ç°éªŒè¯å‘¨æœŸ", 
    objectives=["å®ç°æ ¸å¿ƒåŠŸèƒ½", "éªŒè¯ç³»ç»Ÿæ€§èƒ½"]
)

spiral.add_cycle(cycle1)
spiral.add_cycle(cycle2)
spiral.add_cycle(cycle3)

# ç¬¬ä¸€ä¸ªå‘¨æœŸ
spiral.start_cycle("cycle1")

# æ·»åŠ é£é™©
risk1 = Risk("R001", "éœ€æ±‚ä¸æ˜ç¡®", "ç”¨æˆ·éœ€æ±‚å¯èƒ½ä¸å¤Ÿæ¸…æ™°", 0.6, 0.8, "è¿›è¡Œç”¨æˆ·è®¿è°ˆ")
risk2 = Risk("R002", "æŠ€æœ¯é£é™©", "æ–°æŠ€æœ¯å¯èƒ½ä¸å¯é ", 0.4, 0.9, "æŠ€æœ¯è°ƒç ”å’ŒåŸå‹éªŒè¯")

spiral.add_risk("cycle1", risk1)
spiral.add_risk("cycle1", risk2)

# åˆ›å»ºåŸå‹
prototype1 = Prototype("P001", "éœ€æ±‚åŸå‹", "éªŒè¯ç”¨æˆ·éœ€æ±‚", ["ç”¨æˆ·ç•Œé¢", "åŸºæœ¬æµç¨‹"])
spiral.create_prototype("cycle1", prototype1)

# è¯„ä¼°åŸå‹
spiral.evaluate_prototype("cycle1", "P001", {
    'success': True,
    'feedback': ['ç•Œé¢å‹å¥½', 'æµç¨‹æ¸…æ™°']
})

# å®Œæˆç¬¬ä¸€ä¸ªå‘¨æœŸ
spiral.complete_cycle("cycle1")

# ç¬¬äºŒä¸ªå‘¨æœŸ
spiral.start_cycle("cycle2")
prototype2 = Prototype("P002", "æ¶æ„åŸå‹", "éªŒè¯æ¶æ„è®¾è®¡", ["ç³»ç»Ÿæ¶æ„", "æ¥å£è®¾è®¡"])
spiral.create_prototype("cycle2", prototype2)
spiral.evaluate_prototype("cycle2", "P002", {
    'success': True,
    'feedback': ['æ¶æ„åˆç†', 'æ‰©å±•æ€§å¥½']
})
spiral.complete_cycle("cycle2")

# ç”ŸæˆæŠ¥å‘Š
print(spiral.generate_cycle_report("cycle1"))
print(spiral.generate_cycle_report("cycle2"))
print(spiral.generate_model_report())
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. ç”Ÿå‘½å‘¨æœŸå®Œæ•´æ€§å®šç†

**å®šç†**: è½¯ä»¶ç”Ÿå‘½å‘¨æœŸæ¨¡å‹æ˜¯å®Œæ•´çš„ï¼Œå½“ä¸”ä»…å½“æ‰€æœ‰é˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„å…¥å£å’Œå‡ºå£æ¡ä»¶ã€‚

**è¯æ˜**: é€šè¿‡å›¾è®ºä¸­çš„å¼ºè¿é€šæ€§è¯æ˜ï¼Œç¡®ä¿ä»åˆå§‹çŠ¶æ€åˆ°æœ€ç»ˆçŠ¶æ€å­˜åœ¨è·¯å¾„ã€‚

### 2. æ•æ·è¿­ä»£æ”¶æ•›å®šç†

**å®šç†**: åœ¨æ•æ·æ¨¡å‹ä¸­ï¼Œå¦‚æœå›¢é˜Ÿé€Ÿåº¦ç¨³å®šï¼Œåˆ™é¡¹ç›®å°†åœ¨æœ‰é™æ¬¡è¿­ä»£åæ”¶æ•›ã€‚

**è¯æ˜**: åŸºäºæ•°å­¦å½’çº³æ³•ï¼Œè¯æ˜æ¯æ¬¡è¿­ä»£çš„å‰©ä½™å·¥ä½œé‡é€’å‡ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. é¡¹ç›®ç®¡ç†ç³»ç»Ÿ

```python
class ProjectManagementSystem:
    """é¡¹ç›®ç®¡ç†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.projects = {}
        self.templates = {}
    
    def create_project(self, name: str, model_type: str, **kwargs):
        """åˆ›å»ºé¡¹ç›®"""
        if model_type == "waterfall":
            project = WaterfallModel(name)
        elif model_type == "agile":
            project = AgileModel(name)
        elif model_type == "spiral":
            project = SpiralModel(name)
        else:
            raise ValueError(f"Unknown model type: {model_type}")
        
        self.projects[name] = project
        return project
    
    def get_project_status(self, name: str) -> str:
        """è·å–é¡¹ç›®çŠ¶æ€"""
        if name not in self.projects:
            return "not_found"
        
        project = self.projects[name]
        if hasattr(project, 'status'):
            return project.status
        return "unknown"
    
    def generate_portfolio_report(self) -> str:
        """ç”Ÿæˆé¡¹ç›®ç»„åˆæŠ¥å‘Š"""
        report = "é¡¹ç›®ç»„åˆæŠ¥å‘Š\n"
        report += "=" * 30 + "\n\n"
        
        for name, project in self.projects.items():
            status = self.get_project_status(name)
            report += f"{name}: {status}\n"
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
pms = ProjectManagementSystem()

# åˆ›å»ºä¸åŒç±»å‹çš„é¡¹ç›®
web_project = pms.create_project("Webåº”ç”¨", "agile")
mobile_project = pms.create_project("ç§»åŠ¨åº”ç”¨", "waterfall")
ai_project = pms.create_project("AIç³»ç»Ÿ", "spiral")

# å¯åŠ¨é¡¹ç›®
web_project.start_lifecycle()
mobile_project.start_lifecycle()
ai_project.start_cycle("cycle1")

print(pms.generate_portfolio_report())
```

### 2. ç”Ÿå‘½å‘¨æœŸåˆ†æå™¨

```python
class LifecycleAnalyzer:
    """ç”Ÿå‘½å‘¨æœŸåˆ†æå™¨"""
    
    def __init__(self):
        self.analysis_results = {}
    
    def analyze_lifecycle(self, lifecycle: SoftwareLifecycle) -> Dict[str, Any]:
        """åˆ†æç”Ÿå‘½å‘¨æœŸ"""
        analysis = {
            'total_duration': lifecycle.metrics['total_duration'],
            'phase_efficiency': {},
            'bottlenecks': [],
            'recommendations': []
        }
        
        # åˆ†æé˜¶æ®µæ•ˆç‡
        for phase_name, duration in lifecycle.metrics['phase_durations'].items():
            phase = lifecycle.phases[phase_name]
            planned_duration = phase.duration
            actual_duration = duration
            
            efficiency = planned_duration.total_seconds() / actual_duration.total_seconds()
            analysis['phase_efficiency'][phase_name] = efficiency
            
            if efficiency < 0.8:
                analysis['bottlenecks'].append(phase_name)
                analysis['recommendations'].append(f"ä¼˜åŒ–é˜¶æ®µ '{phase_name}' çš„æ‰§è¡Œæ•ˆç‡")
        
        self.analysis_results[lifecycle.name] = analysis
        return analysis
    
    def compare_lifecycles(self, lifecycles: List[SoftwareLifecycle]) -> str:
        """æ¯”è¾ƒå¤šä¸ªç”Ÿå‘½å‘¨æœŸ"""
        report = "ç”Ÿå‘½å‘¨æœŸæ¯”è¾ƒæŠ¥å‘Š\n"
        report += "=" * 40 + "\n\n"
        
        for lifecycle in lifecycles:
            analysis = self.analyze_lifecycle(lifecycle)
            
            report += f"{lifecycle.name}:\n"
            report += f"  æ€»æŒç»­æ—¶é—´: {analysis['total_duration']}\n"
            report += f"  ç“¶é¢ˆé˜¶æ®µ: {', '.join(analysis['bottlenecks'])}\n"
            report += f"  å»ºè®®: {', '.join(analysis['recommendations'])}\n\n"
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
analyzer = LifecycleAnalyzer()

# åˆ†æç”Ÿå‘½å‘¨æœŸ
waterfall_analysis = analyzer.analyze_lifecycle(waterfall)
print(f"ç€‘å¸ƒæ¨¡å‹åˆ†æ: {waterfall_analysis}")

# æ¯”è¾ƒä¸åŒæ¨¡å‹
comparison = analyzer.compare_lifecycles([waterfall, agile, spiral])
print(comparison)
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [è½¯ä»¶å·¥ç¨‹ç§‘å­¦æ¦‚è¿°](../README.md)
- [è½¯ä»¶è´¨é‡ä¿è¯](03-02-02-è½¯ä»¶è´¨é‡ä¿è¯.md)
- [è½¯ä»¶é…ç½®ç®¡ç†](03-02-03-è½¯ä»¶é…ç½®ç®¡ç†.md)
- [ç†è®ºåŸºç¡€](../02-ç†è®ºåŸºç¡€/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Pressman, R. S. (2014). Software Engineering: A Practitioner's Approach. McGraw-Hill.
2. Sommerville, I. (2015). Software Engineering. Pearson.
3. Boehm, B. W. (1988). A spiral model of software development and enhancement. Computer, 21(5), 61-72.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚* 