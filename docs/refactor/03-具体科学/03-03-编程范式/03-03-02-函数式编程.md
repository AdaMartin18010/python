# 03-03-02 函数式编程 (Functional Programming)

## 📋 概述

函数式编程是一种编程范式，它将计算过程视为数学函数的求值，避免状态和可变数据。函数式编程强调不可变性、纯函数和高阶函数的使用。本文档从形式科学角度对函数式编程进行严格的形式化定义和证明。

## 🎯 核心概念

### 1. 纯函数 (Pure Function)

**形式化定义**：
纯函数是一个映射 $f: A \rightarrow B$，满足：

- 对于相同的输入，总是产生相同的输出
- 没有副作用 (Side Effects)
- 不依赖外部状态

**数学表示**：
$$\forall x_1, x_2 \in A: x_1 = x_2 \Rightarrow f(x_1) = f(x_2)$$

**Python 实现**：

```python
from typing import Callable, TypeVar, List, Any
from functools import reduce, partial
import math

T = TypeVar('T')
U = TypeVar('U')

# 纯函数示例
def pure_add(a: int, b: int) -> int:
    """纯函数：整数加法"""
    return a + b

def pure_multiply(a: int, b: int) -> int:
    """纯函数：整数乘法"""
    return a * b

def pure_square(x: float) -> float:
    """纯函数：平方"""
    return x * x

def pure_factorial(n: int) -> int:
    """纯函数：阶乘"""
    if n <= 1:
        return 1
    return n * pure_factorial(n - 1)

# 非纯函数示例（用于对比）
total_calls = 0  # 外部状态

def impure_counter() -> int:
    """非纯函数：依赖外部状态"""
    global total_calls
    total_calls += 1
    return total_calls

def impure_random() -> float:
    """非纯函数：依赖外部状态（随机数）"""
    import random
    return random.random()
```

### 2. 高阶函数 (Higher-Order Function)

**形式化定义**：
高阶函数是接受函数作为参数或返回函数的函数。

**数学表示**：
$$H: (A \rightarrow B) \rightarrow (C \rightarrow D)$$

**Python 实现**：

```python
from typing import Callable, List, TypeVar, Any

T = TypeVar('T')
U = TypeVar('U')

def map_function(f: Callable[[T], U], xs: List[T]) -> List[U]:
    """高阶函数：map实现"""
    return [f(x) for x in xs]

def filter_function(predicate: Callable[[T], bool], xs: List[T]) -> List[T]:
    """高阶函数：filter实现"""
    return [x for x in xs if predicate(x)]

def reduce_function(f: Callable[[U, T], U], xs: List[T], initial: U) -> U:
    """高阶函数：reduce实现"""
    result = initial
    for x in xs:
        result = f(result, x)
    return result

def compose(*functions: Callable) -> Callable:
    """高阶函数：函数组合"""
    def inner(arg):
        result = arg
        for f in reversed(functions):
            result = f(result)
        return result
    return inner

def curry(f: Callable, *args, **kwargs):
    """高阶函数：柯里化"""
    def curried(*more_args, **more_kwargs):
        return f(*args, *more_args, **kwargs, **more_kwargs)
    return curried

# 使用示例
def add(x: int, y: int) -> int:
    return x + y

def multiply(x: int, y: int) -> int:
    return x * y

def square(x: int) -> int:
    return x * x

def is_even(x: int) -> bool:
    return x % 2 == 0

# 高阶函数使用
numbers = [1, 2, 3, 4, 5, 6]

# Map
squares = map_function(square, numbers)
print(f"Squares: {squares}")

# Filter
evens = filter_function(is_even, numbers)
print(f"Evens: {evens}")

# Reduce
sum_result = reduce_function(add, numbers, 0)
print(f"Sum: {sum_result}")

# Compose
composed = compose(square, lambda x: x + 1)
result = composed(5)  # (5 + 1)^2 = 36
print(f"Composed result: {result}")

# Curry
curried_add = curry(add, 10)
result = curried_add(5)  # 15
print(f"Curried result: {result}")
```

### 3. 不可变性 (Immutability)

**形式化定义**：
不可变性是指数据一旦创建就不能被修改的性质。

**数学表示**：
$$\forall x \in X: \text{create}(x) = x \land \text{modify}(x) = \text{create}(x')$$

**Python 实现**：

```python
from dataclasses import dataclass, replace
from typing import List, Tuple, NamedTuple
from collections import namedtuple

# 使用dataclass实现不可变对象
@dataclass(frozen=True)
class Point:
    """不可变点类"""
    x: float
    y: float
    
    def distance_to(self, other: 'Point') -> float:
        """计算到另一个点的距离"""
        dx = self.x - other.x
        dy = self.y - other.y
        return math.sqrt(dx * dx + dy * dy)
    
    def translate(self, dx: float, dy: float) -> 'Point':
        """平移点（返回新对象）"""
        return Point(self.x + dx, self.y + dy)

# 使用NamedTuple实现不可变对象
class Person(NamedTuple):
    """不可变人员类"""
    name: str
    age: int
    email: str
    
    def with_age(self, new_age: int) -> 'Person':
        """更新年龄（返回新对象）"""
        return self._replace(age=new_age)

# 不可变列表操作
def immutable_append(lst: List[T], item: T) -> List[T]:
    """不可变追加操作"""
    return lst + [item]

def immutable_insert(lst: List[T], index: int, item: T) -> List[T]:
    """不可变插入操作"""
    return lst[:index] + [item] + lst[index:]

def immutable_remove(lst: List[T], index: int) -> List[T]:
    """不可变删除操作"""
    return lst[:index] + lst[index+1:]

# 使用示例
point1 = Point(0.0, 0.0)
point2 = Point(3.0, 4.0)

# 计算距离
distance = point1.distance_to(point2)
print(f"Distance: {distance}")

# 平移点（创建新对象）
point3 = point1.translate(1.0, 1.0)
print(f"Original: {point1}")
print(f"Translated: {point3}")

# 人员对象
person1 = Person("Alice", 25, "alice@example.com")
person2 = person1.with_age(26)
print(f"Original: {person1}")
print(f"Updated: {person2}")

# 不可变列表操作
numbers = [1, 2, 3]
new_numbers = immutable_append(numbers, 4)
print(f"Original: {numbers}")
print(f"Appended: {new_numbers}")
```

### 4. 递归 (Recursion)

**形式化定义**：
递归是函数调用自身的过程，通常用于解决可以分解为相同子问题的问题。

**数学表示**：
$$f(n) = \begin{cases}
\text{base case} & \text{if } n \leq \text{threshold} \\
\text{recursive case} & \text{otherwise}
\end{cases}$$

**Python 实现**：

```python
from typing import List, TypeVar, Callable
from functools import lru_cache

T = TypeVar('T')

def factorial(n: int) -> int:
    """递归计算阶乘"""
    if n <= 1:
        return 1
    return n * factorial(n - 1)

def fibonacci(n: int) -> int:
    """递归计算斐波那契数"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

@lru_cache(maxsize=None)
def fibonacci_memoized(n: int) -> int:
    """记忆化递归计算斐波那契数"""
    if n <= 1:
        return n
    return fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)

def quicksort(lst: List[T]) -> List[T]:
    """递归快速排序"""
    if len(lst) <= 1:
        return lst

    pivot = lst[len(lst) // 2]
    left = [x for x in lst if x < pivot]
    middle = [x for x in lst if x == pivot]
    right = [x for x in lst if x > pivot]

    return quicksort(left) + middle + quicksort(right)

def binary_search(lst: List[T], target: T, low: int = 0, high: int = None) -> int:
    """递归二分搜索"""
    if high is None:
        high = len(lst) - 1

    if low > high:
        return -1

    mid = (low + high) // 2

    if lst[mid] == target:
        return mid
    elif lst[mid] < target:
        return binary_search(lst, target, mid + 1, high)
    else:
        return binary_search(lst, target, low, mid - 1)

def tree_traversal(node: 'TreeNode') -> List[T]:
    """递归树遍历"""
    if node is None:
        return []

    # 前序遍历
    result = [node.value]
    result.extend(tree_traversal(node.left))
    result.extend(tree_traversal(node.right))

    return result

# 使用示例
print(f"Factorial of 5: {factorial(5)}")
print(f"Fibonacci(10): {fibonacci_memoized(10)}")

numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = quicksort(numbers)
print(f"Sorted: {sorted_numbers}")

# 二分搜索
sorted_list = [1, 3, 5, 7, 9, 11, 13, 15]
index = binary_search(sorted_list, 7)
print(f"Index of 7: {index}")
```

### 5. 函数组合 (Function Composition)

**形式化定义**：
函数组合是将两个函数 $f$ 和 $g$ 组合成新函数 $h = f \circ g$ 的过程。

**数学表示**：
$$(f \circ g)(x) = f(g(x))$$

**Python 实现**：

```python
from typing import Callable, TypeVar, Any
from functools import reduce

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

def compose(*functions: Callable) -> Callable:
    """函数组合"""
    def inner(arg):
        result = arg
        for f in reversed(functions):
            result = f(result)
        return result
    return inner

def pipe(*functions: Callable) -> Callable:
    """管道操作（从左到右组合）"""
    def inner(arg):
        result = arg
        for f in functions:
            result = f(result)
        return result
    return inner

# 实用函数
def add_one(x: int) -> int:
    return x + 1

def multiply_by_two(x: int) -> int:
    return x * 2

def square(x: int) -> int:
    return x * x

def to_string(x: Any) -> str:
    return str(x)

# 函数组合示例
composed = compose(square, multiply_by_two, add_one)
result = composed(5)  # ((5 + 1) * 2)^2 = 144
print(f"Composed result: {result}")

piped = pipe(add_one, multiply_by_two, square)
result = piped(5)  # ((5 + 1) * 2)^2 = 144
print(f"Piped result: {result}")

# 数据处理管道
def process_data(data: List[int]) -> List[str]:
    """数据处理管道"""
    pipeline = pipe(
        lambda xs: map(add_one, xs),
        lambda xs: map(multiply_by_two, xs),
        lambda xs: map(square, xs),
        lambda xs: map(to_string, xs),
        list
    )
    return pipeline(data)

data = [1, 2, 3, 4, 5]
processed = process_data(data)
print(f"Processed data: {processed}")
```

## 🔬 函数式编程模式

### 1. Map-Reduce 模式

```python
from typing import List, Callable, TypeVar
from functools import reduce

T = TypeVar('T')
U = TypeVar('U')

def map_reduce(data: List[T],
               mapper: Callable[[T], U],
               reducer: Callable[[U, U], U],
               initial: U) -> U:
    """Map-Reduce模式实现"""
    mapped = map(mapper, data)
    return reduce(reducer, mapped, initial)

# 示例：计算字符串长度统计
words = ["hello", "world", "python", "functional", "programming"]

def word_length(word: str) -> int:
    return len(word)

def max_length(current_max: int, length: int) -> int:
    return max(current_max, length)

max_word_length = map_reduce(words, word_length, max_length, 0)
print(f"Max word length: {max_word_length}")

# 示例：计算平均长度
def sum_lengths(current_sum: int, length: int) -> int:
    return current_sum + length

total_length = map_reduce(words, word_length, sum_lengths, 0)
average_length = total_length / len(words)
print(f"Average word length: {average_length}")
```

### 2. 单子 (Monad) 模式

```python
from typing import TypeVar, Generic, Callable, Any
from abc import ABC, abstractmethod

T = TypeVar('T')
U = TypeVar('U')

class Maybe(Generic[T]):
    """Maybe单子实现"""

    def __init__(self, value: T = None):
        self._value = value
        self._is_just = value is not None

    @classmethod
    def just(cls, value: T) -> 'Maybe[T]':
        return cls(value)

    @classmethod
    def nothing(cls) -> 'Maybe[T]':
        return cls()

    def bind(self, f: Callable[[T], 'Maybe[U]']) -> 'Maybe[U]':
        """单子绑定操作"""
        if self._is_just:
            return f(self._value)
        return Maybe.nothing()

    def map(self, f: Callable[[T], U]) -> 'Maybe[U]':
        """函子映射操作"""
        if self._is_just:
            return Maybe.just(f(self._value))
        return Maybe.nothing()

    def get_or_else(self, default: T) -> T:
        """获取值或默认值"""
        return self._value if self._is_just else default

    def __str__(self):
        if self._is_just:
            return f"Just({self._value})"
        return "Nothing"

# 使用示例
def safe_divide(a: float, b: float) -> Maybe[float]:
    """安全除法"""
    if b == 0:
        return Maybe.nothing()
    return Maybe.just(a / b)

def safe_sqrt(x: float) -> Maybe[float]:
    """安全平方根"""
    if x < 0:
        return Maybe.nothing()
    return Maybe.just(math.sqrt(x))

# 单子链式操作
result = (Maybe.just(16.0)
          .bind(lambda x: safe_divide(x, 4.0))
          .bind(safe_sqrt)
          .map(lambda x: x * 2))

print(f"Result: {result}")  # Just(2.0)

# 处理Nothing情况
result2 = (Maybe.just(16.0)
           .bind(lambda x: safe_divide(x, 0.0))  # 除零
           .bind(safe_sqrt))

print(f"Result2: {result2}")  # Nothing
```

### 3. 函子 (Functor) 模式

```python
from typing import TypeVar, Generic, Callable
from abc import ABC, abstractmethod

T = TypeVar('T')
U = TypeVar('U')

class Functor(ABC, Generic[T]):
    """函子抽象基类"""

    @abstractmethod
    def map(self, f: Callable[[T], U]) -> 'Functor[U]':
        """函子映射"""
        pass

class ListFunctor(Functor[T]):
    """列表函子"""

    def __init__(self, values: List[T]):
        self.values = values

    def map(self, f: Callable[[T], U]) -> 'ListFunctor[U]':
        return ListFunctor([f(x) for x in self.values])

    def __str__(self):
        return f"ListFunctor({self.values})"

# 使用示例
numbers = ListFunctor([1, 2, 3, 4, 5])
squares = numbers.map(lambda x: x * x)
print(f"Original: {numbers}")
print(f"Squared: {squares}")
```

## 🧪 测试与验证

```python
import unittest
from typing import List

class FunctionalProgrammingTest(unittest.TestCase):
    """函数式编程测试类"""

    def test_pure_functions(self):
        """测试纯函数"""
        # 相同输入产生相同输出
        self.assertEqual(pure_add(2, 3), 5)
        self.assertEqual(pure_add(2, 3), 5)  # 再次调用相同结果

        # 无副作用
        result1 = pure_square(4)
        result2 = pure_square(4)
        self.assertEqual(result1, result2)

    def test_higher_order_functions(self):
        """测试高阶函数"""
        numbers = [1, 2, 3, 4, 5]

        # Map
        squares = map_function(square, numbers)
        expected_squares = [1, 4, 9, 16, 25]
        self.assertEqual(squares, expected_squares)

        # Filter
        evens = filter_function(is_even, numbers)
        expected_evens = [2, 4]
        self.assertEqual(evens, expected_evens)

        # Reduce
        sum_result = reduce_function(add, numbers, 0)
        self.assertEqual(sum_result, 15)

    def test_immutability(self):
        """测试不可变性"""
        point1 = Point(0.0, 0.0)
        point2 = point1.translate(1.0, 1.0)

        # 原对象不变
        self.assertEqual(point1.x, 0.0)
        self.assertEqual(point1.y, 0.0)

        # 新对象正确
        self.assertEqual(point2.x, 1.0)
        self.assertEqual(point2.y, 1.0)

    def test_recursion(self):
        """测试递归"""
        self.assertEqual(factorial(5), 120)
        self.assertEqual(fibonacci_memoized(10), 55)

        numbers = [64, 34, 25, 12, 22, 11, 90]
        sorted_numbers = quicksort(numbers)
        self.assertEqual(sorted_numbers, [11, 12, 22, 25, 34, 64, 90])

    def test_function_composition(self):
        """测试函数组合"""
        composed = compose(square, multiply_by_two, add_one)
        result = composed(5)
        self.assertEqual(result, 144)  # ((5 + 1) * 2)^2 = 144

if __name__ == '__main__':
    unittest.main()
```

## 🔗 相关链接

- [03-03-01-面向对象编程](./03-03-01-面向对象编程.md)
- [03-03-03-响应式编程](./03-03-03-响应式编程.md)
- [03-01-设计模式基础](../03-01-设计模式/03-01-01-设计模式基础.md)

## 📚 参考文献

1. Bird, R. (1998). Introduction to Functional Programming using Haskell.
2. Hutton, G. (2016). Programming in Haskell.
3. Okasaki, C. (1999). Purely Functional Data Structures.
4. Peyton Jones, S. (2003). The Implementation of Functional Programming Languages.

---

*本文档提供了函数式编程的完整形式化理论框架，从数学定义到Python实现，为函数式编程实践提供理论基础。*
