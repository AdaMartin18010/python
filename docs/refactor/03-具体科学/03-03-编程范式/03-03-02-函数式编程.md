# 03-03-02 å‡½æ•°å¼ç¼–ç¨‹ (Functional Programming)

## ğŸ“‹ æ¦‚è¿°

å‡½æ•°å¼ç¼–ç¨‹æ˜¯ä¸€ç§ç¼–ç¨‹èŒƒå¼ï¼Œå®ƒå°†è®¡ç®—è¿‡ç¨‹è§†ä¸ºæ•°å­¦å‡½æ•°çš„æ±‚å€¼ï¼Œé¿å…çŠ¶æ€å’Œå¯å˜æ•°æ®ã€‚å‡½æ•°å¼ç¼–ç¨‹å¼ºè°ƒä¸å¯å˜æ€§ã€çº¯å‡½æ•°å’Œé«˜é˜¶å‡½æ•°çš„ä½¿ç”¨ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼ç§‘å­¦è§’åº¦å¯¹å‡½æ•°å¼ç¼–ç¨‹è¿›è¡Œä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰å’Œè¯æ˜ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. çº¯å‡½æ•° (Pure Function)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
çº¯å‡½æ•°æ˜¯ä¸€ä¸ªæ˜ å°„ $f: A \rightarrow B$ï¼Œæ»¡è¶³ï¼š

- å¯¹äºç›¸åŒçš„è¾“å…¥ï¼Œæ€»æ˜¯äº§ç”Ÿç›¸åŒçš„è¾“å‡º
- æ²¡æœ‰å‰¯ä½œç”¨ (Side Effects)
- ä¸ä¾èµ–å¤–éƒ¨çŠ¶æ€

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\forall x_1, x_2 \in A: x_1 = x_2 \Rightarrow f(x_1) = f(x_2)$$

**Python å®ç°**ï¼š

```python
from typing import Callable, TypeVar, List, Any
from functools import reduce, partial
import math

T = TypeVar('T')
U = TypeVar('U')

# çº¯å‡½æ•°ç¤ºä¾‹
def pure_add(a: int, b: int) -> int:
    """çº¯å‡½æ•°ï¼šæ•´æ•°åŠ æ³•"""
    return a + b

def pure_multiply(a: int, b: int) -> int:
    """çº¯å‡½æ•°ï¼šæ•´æ•°ä¹˜æ³•"""
    return a * b

def pure_square(x: float) -> float:
    """çº¯å‡½æ•°ï¼šå¹³æ–¹"""
    return x * x

def pure_factorial(n: int) -> int:
    """çº¯å‡½æ•°ï¼šé˜¶ä¹˜"""
    if n <= 1:
        return 1
    return n * pure_factorial(n - 1)

# éçº¯å‡½æ•°ç¤ºä¾‹ï¼ˆç”¨äºå¯¹æ¯”ï¼‰
total_calls = 0  # å¤–éƒ¨çŠ¶æ€

def impure_counter() -> int:
    """éçº¯å‡½æ•°ï¼šä¾èµ–å¤–éƒ¨çŠ¶æ€"""
    global total_calls
    total_calls += 1
    return total_calls

def impure_random() -> float:
    """éçº¯å‡½æ•°ï¼šä¾èµ–å¤–éƒ¨çŠ¶æ€ï¼ˆéšæœºæ•°ï¼‰"""
    import random
    return random.random()
```

### 2. é«˜é˜¶å‡½æ•° (Higher-Order Function)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
é«˜é˜¶å‡½æ•°æ˜¯æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°çš„å‡½æ•°ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$H: (A \rightarrow B) \rightarrow (C \rightarrow D)$$

**Python å®ç°**ï¼š

```python
from typing import Callable, List, TypeVar, Any

T = TypeVar('T')
U = TypeVar('U')

def map_function(f: Callable[[T], U], xs: List[T]) -> List[U]:
    """é«˜é˜¶å‡½æ•°ï¼šmapå®ç°"""
    return [f(x) for x in xs]

def filter_function(predicate: Callable[[T], bool], xs: List[T]) -> List[T]:
    """é«˜é˜¶å‡½æ•°ï¼šfilterå®ç°"""
    return [x for x in xs if predicate(x)]

def reduce_function(f: Callable[[U, T], U], xs: List[T], initial: U) -> U:
    """é«˜é˜¶å‡½æ•°ï¼šreduceå®ç°"""
    result = initial
    for x in xs:
        result = f(result, x)
    return result

def compose(*functions: Callable) -> Callable:
    """é«˜é˜¶å‡½æ•°ï¼šå‡½æ•°ç»„åˆ"""
    def inner(arg):
        result = arg
        for f in reversed(functions):
            result = f(result)
        return result
    return inner

def curry(f: Callable, *args, **kwargs):
    """é«˜é˜¶å‡½æ•°ï¼šæŸ¯é‡ŒåŒ–"""
    def curried(*more_args, **more_kwargs):
        return f(*args, *more_args, **kwargs, **more_kwargs)
    return curried

# ä½¿ç”¨ç¤ºä¾‹
def add(x: int, y: int) -> int:
    return x + y

def multiply(x: int, y: int) -> int:
    return x * y

def square(x: int) -> int:
    return x * x

def is_even(x: int) -> bool:
    return x % 2 == 0

# é«˜é˜¶å‡½æ•°ä½¿ç”¨
numbers = [1, 2, 3, 4, 5, 6]

# Map
squares = map_function(square, numbers)
print(f"Squares: {squares}")

# Filter
evens = filter_function(is_even, numbers)
print(f"Evens: {evens}")

# Reduce
sum_result = reduce_function(add, numbers, 0)
print(f"Sum: {sum_result}")

# Compose
composed = compose(square, lambda x: x + 1)
result = composed(5)  # (5 + 1)^2 = 36
print(f"Composed result: {result}")

# Curry
curried_add = curry(add, 10)
result = curried_add(5)  # 15
print(f"Curried result: {result}")
```

### 3. ä¸å¯å˜æ€§ (Immutability)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
ä¸å¯å˜æ€§æ˜¯æŒ‡æ•°æ®ä¸€æ—¦åˆ›å»ºå°±ä¸èƒ½è¢«ä¿®æ”¹çš„æ€§è´¨ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\forall x \in X: \text{create}(x) = x \land \text{modify}(x) = \text{create}(x')$$

**Python å®ç°**ï¼š

```python
from dataclasses import dataclass, replace
from typing import List, Tuple, NamedTuple
from collections import namedtuple

# ä½¿ç”¨dataclasså®ç°ä¸å¯å˜å¯¹è±¡
@dataclass(frozen=True)
class Point:
    """ä¸å¯å˜ç‚¹ç±»"""
    x: float
    y: float
    
    def distance_to(self, other: 'Point') -> float:
        """è®¡ç®—åˆ°å¦ä¸€ä¸ªç‚¹çš„è·ç¦»"""
        dx = self.x - other.x
        dy = self.y - other.y
        return math.sqrt(dx * dx + dy * dy)
    
    def translate(self, dx: float, dy: float) -> 'Point':
        """å¹³ç§»ç‚¹ï¼ˆè¿”å›æ–°å¯¹è±¡ï¼‰"""
        return Point(self.x + dx, self.y + dy)

# ä½¿ç”¨NamedTupleå®ç°ä¸å¯å˜å¯¹è±¡
class Person(NamedTuple):
    """ä¸å¯å˜äººå‘˜ç±»"""
    name: str
    age: int
    email: str
    
    def with_age(self, new_age: int) -> 'Person':
        """æ›´æ–°å¹´é¾„ï¼ˆè¿”å›æ–°å¯¹è±¡ï¼‰"""
        return self._replace(age=new_age)

# ä¸å¯å˜åˆ—è¡¨æ“ä½œ
def immutable_append(lst: List[T], item: T) -> List[T]:
    """ä¸å¯å˜è¿½åŠ æ“ä½œ"""
    return lst + [item]

def immutable_insert(lst: List[T], index: int, item: T) -> List[T]:
    """ä¸å¯å˜æ’å…¥æ“ä½œ"""
    return lst[:index] + [item] + lst[index:]

def immutable_remove(lst: List[T], index: int) -> List[T]:
    """ä¸å¯å˜åˆ é™¤æ“ä½œ"""
    return lst[:index] + lst[index+1:]

# ä½¿ç”¨ç¤ºä¾‹
point1 = Point(0.0, 0.0)
point2 = Point(3.0, 4.0)

# è®¡ç®—è·ç¦»
distance = point1.distance_to(point2)
print(f"Distance: {distance}")

# å¹³ç§»ç‚¹ï¼ˆåˆ›å»ºæ–°å¯¹è±¡ï¼‰
point3 = point1.translate(1.0, 1.0)
print(f"Original: {point1}")
print(f"Translated: {point3}")

# äººå‘˜å¯¹è±¡
person1 = Person("Alice", 25, "alice@example.com")
person2 = person1.with_age(26)
print(f"Original: {person1}")
print(f"Updated: {person2}")

# ä¸å¯å˜åˆ—è¡¨æ“ä½œ
numbers = [1, 2, 3]
new_numbers = immutable_append(numbers, 4)
print(f"Original: {numbers}")
print(f"Appended: {new_numbers}")
```

### 4. é€’å½’ (Recursion)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
é€’å½’æ˜¯å‡½æ•°è°ƒç”¨è‡ªèº«çš„è¿‡ç¨‹ï¼Œé€šå¸¸ç”¨äºè§£å†³å¯ä»¥åˆ†è§£ä¸ºç›¸åŒå­é—®é¢˜çš„é—®é¢˜ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$f(n) = \begin{cases}
\text{base case} & \text{if } n \leq \text{threshold} \\
\text{recursive case} & \text{otherwise}
\end{cases}$$

**Python å®ç°**ï¼š

```python
from typing import List, TypeVar, Callable
from functools import lru_cache

T = TypeVar('T')

def factorial(n: int) -> int:
    """é€’å½’è®¡ç®—é˜¶ä¹˜"""
    if n <= 1:
        return 1
    return n * factorial(n - 1)

def fibonacci(n: int) -> int:
    """é€’å½’è®¡ç®—æ–æ³¢é‚£å¥‘æ•°"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

@lru_cache(maxsize=None)
def fibonacci_memoized(n: int) -> int:
    """è®°å¿†åŒ–é€’å½’è®¡ç®—æ–æ³¢é‚£å¥‘æ•°"""
    if n <= 1:
        return n
    return fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)

def quicksort(lst: List[T]) -> List[T]:
    """é€’å½’å¿«é€Ÿæ’åº"""
    if len(lst) <= 1:
        return lst

    pivot = lst[len(lst) // 2]
    left = [x for x in lst if x < pivot]
    middle = [x for x in lst if x == pivot]
    right = [x for x in lst if x > pivot]

    return quicksort(left) + middle + quicksort(right)

def binary_search(lst: List[T], target: T, low: int = 0, high: int = None) -> int:
    """é€’å½’äºŒåˆ†æœç´¢"""
    if high is None:
        high = len(lst) - 1

    if low > high:
        return -1

    mid = (low + high) // 2

    if lst[mid] == target:
        return mid
    elif lst[mid] < target:
        return binary_search(lst, target, mid + 1, high)
    else:
        return binary_search(lst, target, low, mid - 1)

def tree_traversal(node: 'TreeNode') -> List[T]:
    """é€’å½’æ ‘éå†"""
    if node is None:
        return []

    # å‰åºéå†
    result = [node.value]
    result.extend(tree_traversal(node.left))
    result.extend(tree_traversal(node.right))

    return result

# ä½¿ç”¨ç¤ºä¾‹
print(f"Factorial of 5: {factorial(5)}")
print(f"Fibonacci(10): {fibonacci_memoized(10)}")

numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = quicksort(numbers)
print(f"Sorted: {sorted_numbers}")

# äºŒåˆ†æœç´¢
sorted_list = [1, 3, 5, 7, 9, 11, 13, 15]
index = binary_search(sorted_list, 7)
print(f"Index of 7: {index}")
```

### 5. å‡½æ•°ç»„åˆ (Function Composition)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
å‡½æ•°ç»„åˆæ˜¯å°†ä¸¤ä¸ªå‡½æ•° $f$ å’Œ $g$ ç»„åˆæˆæ–°å‡½æ•° $h = f \circ g$ çš„è¿‡ç¨‹ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$(f \circ g)(x) = f(g(x))$$

**Python å®ç°**ï¼š

```python
from typing import Callable, TypeVar, Any
from functools import reduce

T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

def compose(*functions: Callable) -> Callable:
    """å‡½æ•°ç»„åˆ"""
    def inner(arg):
        result = arg
        for f in reversed(functions):
            result = f(result)
        return result
    return inner

def pipe(*functions: Callable) -> Callable:
    """ç®¡é“æ“ä½œï¼ˆä»å·¦åˆ°å³ç»„åˆï¼‰"""
    def inner(arg):
        result = arg
        for f in functions:
            result = f(result)
        return result
    return inner

# å®ç”¨å‡½æ•°
def add_one(x: int) -> int:
    return x + 1

def multiply_by_two(x: int) -> int:
    return x * 2

def square(x: int) -> int:
    return x * x

def to_string(x: Any) -> str:
    return str(x)

# å‡½æ•°ç»„åˆç¤ºä¾‹
composed = compose(square, multiply_by_two, add_one)
result = composed(5)  # ((5 + 1) * 2)^2 = 144
print(f"Composed result: {result}")

piped = pipe(add_one, multiply_by_two, square)
result = piped(5)  # ((5 + 1) * 2)^2 = 144
print(f"Piped result: {result}")

# æ•°æ®å¤„ç†ç®¡é“
def process_data(data: List[int]) -> List[str]:
    """æ•°æ®å¤„ç†ç®¡é“"""
    pipeline = pipe(
        lambda xs: map(add_one, xs),
        lambda xs: map(multiply_by_two, xs),
        lambda xs: map(square, xs),
        lambda xs: map(to_string, xs),
        list
    )
    return pipeline(data)

data = [1, 2, 3, 4, 5]
processed = process_data(data)
print(f"Processed data: {processed}")
```

## ğŸ”¬ å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼

### 1. Map-Reduce æ¨¡å¼

```python
from typing import List, Callable, TypeVar
from functools import reduce

T = TypeVar('T')
U = TypeVar('U')

def map_reduce(data: List[T],
               mapper: Callable[[T], U],
               reducer: Callable[[U, U], U],
               initial: U) -> U:
    """Map-Reduceæ¨¡å¼å®ç°"""
    mapped = map(mapper, data)
    return reduce(reducer, mapped, initial)

# ç¤ºä¾‹ï¼šè®¡ç®—å­—ç¬¦ä¸²é•¿åº¦ç»Ÿè®¡
words = ["hello", "world", "python", "functional", "programming"]

def word_length(word: str) -> int:
    return len(word)

def max_length(current_max: int, length: int) -> int:
    return max(current_max, length)

max_word_length = map_reduce(words, word_length, max_length, 0)
print(f"Max word length: {max_word_length}")

# ç¤ºä¾‹ï¼šè®¡ç®—å¹³å‡é•¿åº¦
def sum_lengths(current_sum: int, length: int) -> int:
    return current_sum + length

total_length = map_reduce(words, word_length, sum_lengths, 0)
average_length = total_length / len(words)
print(f"Average word length: {average_length}")
```

### 2. å•å­ (Monad) æ¨¡å¼

```python
from typing import TypeVar, Generic, Callable, Any
from abc import ABC, abstractmethod

T = TypeVar('T')
U = TypeVar('U')

class Maybe(Generic[T]):
    """Maybeå•å­å®ç°"""

    def __init__(self, value: T = None):
        self._value = value
        self._is_just = value is not None

    @classmethod
    def just(cls, value: T) -> 'Maybe[T]':
        return cls(value)

    @classmethod
    def nothing(cls) -> 'Maybe[T]':
        return cls()

    def bind(self, f: Callable[[T], 'Maybe[U]']) -> 'Maybe[U]':
        """å•å­ç»‘å®šæ“ä½œ"""
        if self._is_just:
            return f(self._value)
        return Maybe.nothing()

    def map(self, f: Callable[[T], U]) -> 'Maybe[U]':
        """å‡½å­æ˜ å°„æ“ä½œ"""
        if self._is_just:
            return Maybe.just(f(self._value))
        return Maybe.nothing()

    def get_or_else(self, default: T) -> T:
        """è·å–å€¼æˆ–é»˜è®¤å€¼"""
        return self._value if self._is_just else default

    def __str__(self):
        if self._is_just:
            return f"Just({self._value})"
        return "Nothing"

# ä½¿ç”¨ç¤ºä¾‹
def safe_divide(a: float, b: float) -> Maybe[float]:
    """å®‰å…¨é™¤æ³•"""
    if b == 0:
        return Maybe.nothing()
    return Maybe.just(a / b)

def safe_sqrt(x: float) -> Maybe[float]:
    """å®‰å…¨å¹³æ–¹æ ¹"""
    if x < 0:
        return Maybe.nothing()
    return Maybe.just(math.sqrt(x))

# å•å­é“¾å¼æ“ä½œ
result = (Maybe.just(16.0)
          .bind(lambda x: safe_divide(x, 4.0))
          .bind(safe_sqrt)
          .map(lambda x: x * 2))

print(f"Result: {result}")  # Just(2.0)

# å¤„ç†Nothingæƒ…å†µ
result2 = (Maybe.just(16.0)
           .bind(lambda x: safe_divide(x, 0.0))  # é™¤é›¶
           .bind(safe_sqrt))

print(f"Result2: {result2}")  # Nothing
```

### 3. å‡½å­ (Functor) æ¨¡å¼

```python
from typing import TypeVar, Generic, Callable
from abc import ABC, abstractmethod

T = TypeVar('T')
U = TypeVar('U')

class Functor(ABC, Generic[T]):
    """å‡½å­æŠ½è±¡åŸºç±»"""

    @abstractmethod
    def map(self, f: Callable[[T], U]) -> 'Functor[U]':
        """å‡½å­æ˜ å°„"""
        pass

class ListFunctor(Functor[T]):
    """åˆ—è¡¨å‡½å­"""

    def __init__(self, values: List[T]):
        self.values = values

    def map(self, f: Callable[[T], U]) -> 'ListFunctor[U]':
        return ListFunctor([f(x) for x in self.values])

    def __str__(self):
        return f"ListFunctor({self.values})"

# ä½¿ç”¨ç¤ºä¾‹
numbers = ListFunctor([1, 2, 3, 4, 5])
squares = numbers.map(lambda x: x * x)
print(f"Original: {numbers}")
print(f"Squared: {squares}")
```

## ğŸ§ª æµ‹è¯•ä¸éªŒè¯

```python
import unittest
from typing import List

class FunctionalProgrammingTest(unittest.TestCase):
    """å‡½æ•°å¼ç¼–ç¨‹æµ‹è¯•ç±»"""

    def test_pure_functions(self):
        """æµ‹è¯•çº¯å‡½æ•°"""
        # ç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡º
        self.assertEqual(pure_add(2, 3), 5)
        self.assertEqual(pure_add(2, 3), 5)  # å†æ¬¡è°ƒç”¨ç›¸åŒç»“æœ

        # æ— å‰¯ä½œç”¨
        result1 = pure_square(4)
        result2 = pure_square(4)
        self.assertEqual(result1, result2)

    def test_higher_order_functions(self):
        """æµ‹è¯•é«˜é˜¶å‡½æ•°"""
        numbers = [1, 2, 3, 4, 5]

        # Map
        squares = map_function(square, numbers)
        expected_squares = [1, 4, 9, 16, 25]
        self.assertEqual(squares, expected_squares)

        # Filter
        evens = filter_function(is_even, numbers)
        expected_evens = [2, 4]
        self.assertEqual(evens, expected_evens)

        # Reduce
        sum_result = reduce_function(add, numbers, 0)
        self.assertEqual(sum_result, 15)

    def test_immutability(self):
        """æµ‹è¯•ä¸å¯å˜æ€§"""
        point1 = Point(0.0, 0.0)
        point2 = point1.translate(1.0, 1.0)

        # åŸå¯¹è±¡ä¸å˜
        self.assertEqual(point1.x, 0.0)
        self.assertEqual(point1.y, 0.0)

        # æ–°å¯¹è±¡æ­£ç¡®
        self.assertEqual(point2.x, 1.0)
        self.assertEqual(point2.y, 1.0)

    def test_recursion(self):
        """æµ‹è¯•é€’å½’"""
        self.assertEqual(factorial(5), 120)
        self.assertEqual(fibonacci_memoized(10), 55)

        numbers = [64, 34, 25, 12, 22, 11, 90]
        sorted_numbers = quicksort(numbers)
        self.assertEqual(sorted_numbers, [11, 12, 22, 25, 34, 64, 90])

    def test_function_composition(self):
        """æµ‹è¯•å‡½æ•°ç»„åˆ"""
        composed = compose(square, multiply_by_two, add_one)
        result = composed(5)
        self.assertEqual(result, 144)  # ((5 + 1) * 2)^2 = 144

if __name__ == '__main__':
    unittest.main()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [03-03-01-é¢å‘å¯¹è±¡ç¼–ç¨‹](./03-03-01-é¢å‘å¯¹è±¡ç¼–ç¨‹.md)
- [03-03-03-å“åº”å¼ç¼–ç¨‹](./03-03-03-å“åº”å¼ç¼–ç¨‹.md)
- [03-01-è®¾è®¡æ¨¡å¼åŸºç¡€](../03-01-è®¾è®¡æ¨¡å¼/03-01-01-è®¾è®¡æ¨¡å¼åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Bird, R. (1998). Introduction to Functional Programming using Haskell.
2. Hutton, G. (2016). Programming in Haskell.
3. Okasaki, C. (1999). Purely Functional Data Structures.
4. Peyton Jones, S. (2003). The Implementation of Functional Programming Languages.

---

*æœ¬æ–‡æ¡£æä¾›äº†å‡½æ•°å¼ç¼–ç¨‹çš„å®Œæ•´å½¢å¼åŒ–ç†è®ºæ¡†æ¶ï¼Œä»æ•°å­¦å®šä¹‰åˆ°Pythonå®ç°ï¼Œä¸ºå‡½æ•°å¼ç¼–ç¨‹å®è·µæä¾›ç†è®ºåŸºç¡€ã€‚*
