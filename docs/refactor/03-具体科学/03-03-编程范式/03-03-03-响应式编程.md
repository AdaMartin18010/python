# 03-03-03 å“åº”å¼ç¼–ç¨‹ (Reactive Programming)

## ğŸ“‹ æ¦‚è¿°

å“åº”å¼ç¼–ç¨‹æ˜¯ä¸€ç§ç¼–ç¨‹èŒƒå¼ï¼Œå®ƒå¤„ç†æ•°æ®æµå’Œå˜åŒ–çš„ä¼ æ’­ã€‚å“åº”å¼ç¼–ç¨‹åŸºäºè§‚å¯Ÿè€…æ¨¡å¼ï¼Œé€šè¿‡å£°æ˜å¼çš„æ–¹å¼å¤„ç†å¼‚æ­¥æ•°æ®æµã€‚æœ¬æ–‡æ¡£ä»å½¢å¼ç§‘å­¦è§’åº¦å¯¹å“åº”å¼ç¼–ç¨‹è¿›è¡Œä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰å’Œè¯æ˜ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æ•°æ®æµ (Data Stream)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
æ•°æ®æµæ˜¯ä¸€ä¸ªæ—¶é—´åºåˆ— $S = (s_0, s_1, s_2, ..., s_n)$ï¼Œå…¶ä¸­æ¯ä¸ª $s_i$ æ˜¯åœ¨æ—¶é—´ $t_i$ çš„å€¼ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$S = \{(t_i, s_i) | i \in \mathbb{N}, t_i < t_{i+1}\}$$

**Python å®ç°**ï¼š

```python
from typing import TypeVar, Generic, List, Callable, Any
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
import asyncio
import time

T = TypeVar('T')

@dataclass
class StreamEvent(Generic[T]):
    """æµäº‹ä»¶"""
    timestamp: float
    value: T
    type: str = "data"

class Stream(Generic[T]):
    """æ•°æ®æµæŠ½è±¡åŸºç±»"""
    
    def __init__(self):
        self._subscribers: List[Callable[[StreamEvent[T]], None]] = []
        self._history: List[StreamEvent[T]] = []
    
    def subscribe(self, callback: Callable[[StreamEvent[T]], None]):
        """è®¢é˜…æ•°æ®æµ"""
        self._subscribers.append(callback)
    
    def emit(self, value: T):
        """å‘å°„æ•°æ®"""
        event = StreamEvent(
            timestamp=time.time(),
            value=value
        )
        self._history.append(event)
        
        # é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
        for subscriber in self._subscribers:
            subscriber(event)
    
    def get_history(self) -> List[StreamEvent[T]]:
        """è·å–å†å²æ•°æ®"""
        return self._history.copy()

# å…·ä½“æ•°æ®æµå®ç°
class NumberStream(Stream[int]):
    """æ•°å­—æµ"""
    
    def emit_number(self, number: int):
        """å‘å°„æ•°å­—"""
        self.emit(number)

class StringStream(Stream[str]):
    """å­—ç¬¦ä¸²æµ"""
    
    def emit_string(self, text: str):
        """å‘å°„å­—ç¬¦ä¸²"""
        self.emit(text)
```

### 2. å¯è§‚å¯Ÿå¯¹è±¡ (Observable)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
å¯è§‚å¯Ÿå¯¹è±¡æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $O = (S, P, N)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯æ•°æ®æµé›†åˆ
- $P$ æ˜¯ç”Ÿäº§è€…é›†åˆ
- $N$ æ˜¯é€šçŸ¥æœºåˆ¶

**æ•°å­¦è¡¨ç¤º**ï¼š
$$O = \{(s_1, s_2, ..., s_n), (p_1, p_2, ..., p_m), \text{notify}\}$$

**Python å®ç°**ï¼š

```python
from typing import TypeVar, Generic, Callable, List, Any
from abc import ABC, abstractmethod
import asyncio
import time

T = TypeVar('T')

class Observer(Generic[T]):
    """è§‚å¯Ÿè€…æ¥å£"""
    
    def on_next(self, value: T):
        """å¤„ç†ä¸‹ä¸€ä¸ªå€¼"""
        pass
    
    def on_error(self, error: Exception):
        """å¤„ç†é”™è¯¯"""
        pass
    
    def on_completed(self):
        """å¤„ç†å®Œæˆ"""
        pass

class Observable(Generic[T]):
    """å¯è§‚å¯Ÿå¯¹è±¡"""
    
    def __init__(self):
        self._observers: List[Observer[T]] = []
        self._is_completed = False
        self._error = None
    
    def subscribe(self, observer: Observer[T]):
        """è®¢é˜…è§‚å¯Ÿè€…"""
        if not self._is_completed and self._error is None:
            self._observers.append(observer)
    
    def unsubscribe(self, observer: Observer[T]):
        """å–æ¶ˆè®¢é˜…"""
        if observer in self._observers:
            self._observers.remove(observer)
    
    def emit(self, value: T):
        """å‘å°„å€¼"""
        if not self._is_completed and self._error is None:
            for observer in self._observers:
                observer.on_next(value)
    
    def error(self, error: Exception):
        """å‘å°„é”™è¯¯"""
        self._error = error
        for observer in self._observers:
            observer.on_error(error)
    
    def complete(self):
        """å®Œæˆæµ"""
        self._is_completed = True
        for observer in self._observers:
            observer.on_completed()

# å…·ä½“è§‚å¯Ÿè€…å®ç°
class PrintObserver(Observer[T]):
    """æ‰“å°è§‚å¯Ÿè€…"""
    
    def __init__(self, name: str = "Observer"):
        self.name = name
    
    def on_next(self, value: T):
        print(f"[{self.name}] Received: {value}")
    
    def on_error(self, error: Exception):
        print(f"[{self.name}] Error: {error}")
    
    def on_completed(self):
        print(f"[{self.name}] Completed")

class FilterObserver(Observer[T]):
    """è¿‡æ»¤è§‚å¯Ÿè€…"""
    
    def __init__(self, predicate: Callable[[T], bool], next_observer: Observer[T]):
        self.predicate = predicate
        self.next_observer = next_observer
    
    def on_next(self, value: T):
        if self.predicate(value):
            self.next_observer.on_next(value)
    
    def on_error(self, error: Exception):
        self.next_observer.on_error(error)
    
    def on_completed(self):
        self.next_observer.on_completed()

class MapObserver(Observer[T]):
    """æ˜ å°„è§‚å¯Ÿè€…"""
    
    def __init__(self, mapper: Callable[[T], Any], next_observer: Observer[Any]):
        self.mapper = mapper
        self.next_observer = next_observer
    
    def on_next(self, value: T):
        mapped_value = self.mapper(value)
        self.next_observer.on_next(mapped_value)
    
    def on_error(self, error: Exception):
        self.next_observer.on_error(error)
    
    def on_completed(self):
        self.next_observer.on_completed()
```

### 3. æ“ä½œç¬¦ (Operators)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
æ“ä½œç¬¦æ˜¯æ•°æ®æµä¸Šçš„å‡½æ•°ï¼Œç”¨äºè½¬æ¢ã€è¿‡æ»¤æˆ–ç»„åˆæ•°æ®æµã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\text{Operator}: S \rightarrow S'$$

**Python å®ç°**ï¼š

```python
from typing import TypeVar, Generic, Callable, List, Any
from functools import partial

T = TypeVar('T')
U = TypeVar('U')

class ObservableOperators:
    """å¯è§‚å¯Ÿå¯¹è±¡æ“ä½œç¬¦"""
    
    @staticmethod
    def map(observable: Observable[T], mapper: Callable[[T], U]) -> Observable[U]:
        """æ˜ å°„æ“ä½œç¬¦"""
        result = Observable[U]()
        
        class MapObserver(Observer[T]):
            def on_next(self, value: T):
                mapped_value = mapper(value)
                result.emit(mapped_value)
            
            def on_error(self, error: Exception):
                result.error(error)
            
            def on_completed(self):
                result.complete()
        
        observable.subscribe(MapObserver())
        return result
    
    @staticmethod
    def filter(observable: Observable[T], predicate: Callable[[T], bool]) -> Observable[T]:
        """è¿‡æ»¤æ“ä½œç¬¦"""
        result = Observable[T]()
        
        class FilterObserver(Observer[T]):
            def on_next(self, value: T):
                if predicate(value):
                    result.emit(value)
            
            def on_error(self, error: Exception):
                result.error(error)
            
            def on_completed(self):
                result.complete()
        
        observable.subscribe(FilterObserver())
        return result
    
    @staticmethod
    def take(observable: Observable[T], count: int) -> Observable[T]:
        """å–å‰Nä¸ªå…ƒç´ æ“ä½œç¬¦"""
        result = Observable[T]()
        taken = 0
        
        class TakeObserver(Observer[T]):
            def on_next(self, value: T):
                nonlocal taken
                if taken < count:
                    result.emit(value)
                    taken += 1
                    if taken >= count:
                        result.complete()
            
            def on_error(self, error: Exception):
                result.error(error)
            
            def on_completed(self):
                result.complete()
        
        observable.subscribe(TakeObserver())
        return result
    
    @staticmethod
    def merge(*observables: Observable[T]) -> Observable[T]:
        """åˆå¹¶æ“ä½œç¬¦"""
        result = Observable[T]()
        completed_count = 0
        total_count = len(observables)
        
        class MergeObserver(Observer[T]):
            def on_next(self, value: T):
                result.emit(value)
            
            def on_error(self, error: Exception):
                result.error(error)
            
            def on_completed(self):
                nonlocal completed_count
                completed_count += 1
                if completed_count >= total_count:
                    result.complete()
        
        for observable in observables:
            observable.subscribe(MergeObserver())
        
        return result
    
    @staticmethod
    def combine_latest(*observables: Observable[T]) -> Observable[List[T]]:
        """ç»„åˆæœ€æ–°å€¼æ“ä½œç¬¦"""
        result = Observable[List[T]]()
        latest_values = [None] * len(observables)
        completed_count = 0
        total_count = len(observables)
        
        class CombineObserver(Observer[T]):
            def __init__(self, index: int):
                self.index = index
            
            def on_next(self, value: T):
                latest_values[self.index] = value
                if all(v is not None for v in latest_values):
                    result.emit(latest_values.copy())
            
            def on_error(self, error: Exception):
                result.error(error)
            
            def on_completed(self):
                nonlocal completed_count
                completed_count += 1
                if completed_count >= total_count:
                    result.complete()
        
        for i, observable in enumerate(observables):
            observable.subscribe(CombineObserver(i))
        
        return result
```

### 4. èƒŒå‹ (Backpressure)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
èƒŒå‹æ˜¯å½“ç”Ÿäº§è€…äº§ç”Ÿæ•°æ®çš„é€Ÿåº¦è¶…è¿‡æ¶ˆè´¹è€…å¤„ç†é€Ÿåº¦æ—¶ï¼Œç³»ç»Ÿå¤„ç†è¿™ç§ä¸å¹³è¡¡çš„æœºåˆ¶ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\text{Backpressure} = \frac{\text{Production Rate}}{\text{Consumption Rate}}$$

**Python å®ç°**ï¼š

```python
import asyncio
from typing import TypeVar, Generic, Callable, List, Any
from collections import deque
import time

T = TypeVar('T')

class BackpressureStrategy:
    """èƒŒå‹ç­–ç•¥"""
    
    @staticmethod
    def drop_oldest(buffer_size: int = 100):
        """ä¸¢å¼ƒæœ€æ—§æ•°æ®ç­–ç•¥"""
        def strategy(observable: Observable[T]) -> Observable[T]:
            buffer = deque(maxlen=buffer_size)
            result = Observable[T]()
            
            class DropOldestObserver(Observer[T]):
                def on_next(self, value: T):
                    buffer.append(value)
                    if len(buffer) == buffer_size:
                        # ç¼“å†²åŒºæ»¡ï¼Œä¸¢å¼ƒæœ€æ—§çš„æ•°æ®
                        buffer.popleft()
                    result.emit(value)
                
                def on_error(self, error: Exception):
                    result.error(error)
                
                def on_completed(self):
                    result.complete()
            
            observable.subscribe(DropOldestObserver())
            return result
        
        return strategy
    
    @staticmethod
    def drop_newest(buffer_size: int = 100):
        """ä¸¢å¼ƒæœ€æ–°æ•°æ®ç­–ç•¥"""
        def strategy(observable: Observable[T]) -> Observable[T]:
            buffer = deque(maxlen=buffer_size)
            result = Observable[T]()
            
            class DropNewestObserver(Observer[T]):
                def on_next(self, value: T):
                    if len(buffer) < buffer_size:
                        buffer.append(value)
                        result.emit(value)
                    # ç¼“å†²åŒºæ»¡æ—¶ï¼Œä¸¢å¼ƒæ–°æ•°æ®
            
            observable.subscribe(DropNewestObserver())
            return result
        
        return strategy
    
    @staticmethod
    def throttle(interval: float):
        """èŠ‚æµç­–ç•¥"""
        def strategy(observable: Observable[T]) -> Observable[T]:
            result = Observable[T]()
            last_emit_time = 0
            
            class ThrottleObserver(Observer[T]):
                def on_next(self, value: T):
                    nonlocal last_emit_time
                    current_time = time.time()
                    if current_time - last_emit_time >= interval:
                        result.emit(value)
                        last_emit_time = current_time
                
                def on_error(self, error: Exception):
                    result.error(error)
                
                def on_completed(self):
                    result.complete()
            
            observable.subscribe(ThrottleObserver())
            return result
        
        return strategy

class AsyncObservable(Generic[T]):
    """å¼‚æ­¥å¯è§‚å¯Ÿå¯¹è±¡"""
    
    def __init__(self):
        self._observers: List[Callable[[T], None]] = []
        self._queue = asyncio.Queue()
        self._task = None
    
    async def start(self):
        """å¯åŠ¨å¼‚æ­¥å¤„ç†"""
        self._task = asyncio.create_task(self._process_queue())
    
    async def stop(self):
        """åœæ­¢å¼‚æ­¥å¤„ç†"""
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
    
    def subscribe(self, callback: Callable[[T], None]):
        """è®¢é˜…"""
        self._observers.append(callback)
    
    async def emit(self, value: T):
        """å¼‚æ­¥å‘å°„å€¼"""
        await self._queue.put(value)
    
    async def _process_queue(self):
        """å¤„ç†é˜Ÿåˆ—"""
        while True:
            try:
                value = await self._queue.get()
                for observer in self._observers:
                    await asyncio.create_task(self._call_observer(observer, value))
                self._queue.task_done()
            except asyncio.CancelledError:
                break
    
    async def _call_observer(self, observer: Callable[[T], None], value: T):
        """è°ƒç”¨è§‚å¯Ÿè€…"""
        try:
            if asyncio.iscoroutinefunction(observer):
                await observer(value)
            else:
                observer(value)
        except Exception as e:
            print(f"Observer error: {e}")
```

### 5. é”™è¯¯å¤„ç† (Error Handling)

**å½¢å¼åŒ–å®šä¹‰**ï¼š
é”™è¯¯å¤„ç†æ˜¯å“åº”å¼æµä¸­å¤„ç†å¼‚å¸¸æƒ…å†µçš„æœºåˆ¶ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\text{ErrorHandler}: E \rightarrow S'$$

**Python å®ç°**ï¼š

```python
from typing import TypeVar, Generic, Callable, List, Any, Optional
import traceback

T = TypeVar('T')

class ErrorHandlingOperators:
    """é”™è¯¯å¤„ç†æ“ä½œç¬¦"""
    
    @staticmethod
    def retry(observable: Observable[T], max_retries: int = 3) -> Observable[T]:
        """é‡è¯•æ“ä½œç¬¦"""
        result = Observable[T]()
        retry_count = 0
        
        class RetryObserver(Observer[T]):
            def on_next(self, value: T):
                result.emit(value)
            
            def on_error(self, error: Exception):
                nonlocal retry_count
                if retry_count < max_retries:
                    retry_count += 1
                    print(f"Retrying... ({retry_count}/{max_retries})")
                    # é‡æ–°è®¢é˜…åŸå§‹æµ
                    observable.subscribe(self)
                else:
                    result.error(error)
            
            def on_completed(self):
                result.complete()
        
        observable.subscribe(RetryObserver())
        return result
    
    @staticmethod
    def catch(observable: Observable[T], error_handler: Callable[[Exception], T]) -> Observable[T]:
        """æ•è·é”™è¯¯æ“ä½œç¬¦"""
        result = Observable[T]()
        
        class CatchObserver(Observer[T]):
            def on_next(self, value: T):
                result.emit(value)
            
            def on_error(self, error: Exception):
                try:
                    fallback_value = error_handler(error)
                    result.emit(fallback_value)
                except Exception as e:
                    result.error(e)
            
            def on_completed(self):
                result.complete()
        
        observable.subscribe(CatchObserver())
        return result
    
    @staticmethod
    def on_error_return(observable: Observable[T], fallback_value: T) -> Observable[T]:
        """é”™è¯¯æ—¶è¿”å›é»˜è®¤å€¼æ“ä½œç¬¦"""
        return ErrorHandlingOperators.catch(observable, lambda _: fallback_value)
    
    @staticmethod
    def on_error_continue(observable: Observable[T]) -> Observable[T]:
        """é”™è¯¯æ—¶ç»§ç»­æ“ä½œç¬¦"""
        result = Observable[T]()
        
        class ContinueObserver(Observer[T]):
            def on_next(self, value: T):
                result.emit(value)
            
            def on_error(self, error: Exception):
                # å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­å¤„ç†
                print(f"Error ignored: {error}")
            
            def on_completed(self):
                result.complete()
        
        observable.subscribe(ContinueObserver())
        return result

class CircuitBreaker:
    """ç†”æ–­å™¨æ¨¡å¼"""
    
    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = 0
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    def call(self, func: Callable, *args, **kwargs):
        """è°ƒç”¨å‡½æ•°"""
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
                self.failure_count = 0
            return result
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()
            
            if self.failure_count >= self.failure_threshold:
                self.state = "OPEN"
            
            raise e
```

## ğŸ”¬ å“åº”å¼ç¼–ç¨‹æ¨¡å¼

### 1. äº‹ä»¶é©±åŠ¨æ¶æ„

```python
from typing import Dict, List, Callable, Any
from dataclasses import dataclass
import asyncio

@dataclass
class Event:
    """äº‹ä»¶åŸºç±»"""
    type: str
    data: Any
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            import time
            self.timestamp = time.time()

class EventBus:
    """äº‹ä»¶æ€»çº¿"""
    
    def __init__(self):
        self._handlers: Dict[str, List[Callable[[Event], None]]] = {}
    
    def subscribe(self, event_type: str, handler: Callable[[Event], None]):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
    
    def unsubscribe(self, event_type: str, handler: Callable[[Event], None]):
        """å–æ¶ˆè®¢é˜…"""
        if event_type in self._handlers:
            self._handlers[event_type].remove(handler)
    
    def publish(self, event: Event):
        """å‘å¸ƒäº‹ä»¶"""
        if event.type in self._handlers:
            for handler in self._handlers[event.type]:
                handler(event)

# ä½¿ç”¨ç¤ºä¾‹
class UserService:
    """ç”¨æˆ·æœåŠ¡"""
    
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
    
    def create_user(self, user_data: Dict):
        """åˆ›å»ºç”¨æˆ·"""
        # ä¸šåŠ¡é€»è¾‘
        user_id = "user_123"
        
        # å‘å¸ƒäº‹ä»¶
        event = Event("user.created", {"user_id": user_id, "data": user_data})
        self.event_bus.publish(event)
        
        return user_id

class EmailService:
    """é‚®ä»¶æœåŠ¡"""
    
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.event_bus.subscribe("user.created", self.handle_user_created)
    
    def handle_user_created(self, event: Event):
        """å¤„ç†ç”¨æˆ·åˆ›å»ºäº‹ä»¶"""
        user_id = event.data["user_id"]
        print(f"Sending welcome email to user {user_id}")

# ä½¿ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„
event_bus = EventBus()
user_service = UserService(event_bus)
email_service = EmailService(event_bus)

user_id = user_service.create_user({"name": "Alice", "email": "alice@example.com"})
```

### 2. å“åº”å¼æµå¤„ç†

```python
from typing import List, Callable, TypeVar, Generic
import asyncio

T = TypeVar('T')

class ReactiveStream(Generic[T]):
    """å“åº”å¼æµ"""
    
    def __init__(self):
        self._observers: List[Callable[[T], None]] = []
        self._operators: List[Callable] = []
    
    def subscribe(self, observer: Callable[[T], None]):
        """è®¢é˜…æµ"""
        self._observers.append(observer)
    
    def emit(self, value: T):
        """å‘å°„å€¼"""
        # åº”ç”¨æ“ä½œç¬¦
        processed_value = value
        for operator in self._operators:
            processed_value = operator(processed_value)
        
        # é€šçŸ¥è§‚å¯Ÿè€…
        for observer in self._observers:
            observer(processed_value)
    
    def map(self, mapper: Callable[[T], Any]):
        """æ˜ å°„æ“ä½œ"""
        self._operators.append(mapper)
        return self
    
    def filter(self, predicate: Callable[[T], bool]):
        """è¿‡æ»¤æ“ä½œ"""
        def filter_operator(value: T):
            if predicate(value):
                return value
            return None
        
        self._operators.append(filter_operator)
        return self

# ä½¿ç”¨ç¤ºä¾‹
def process_data_stream():
    """å¤„ç†æ•°æ®æµ"""
    stream = ReactiveStream[int]()
    
    # è®¾ç½®å¤„ç†ç®¡é“
    stream.map(lambda x: x * 2) \
          .filter(lambda x: x > 10) \
          .subscribe(lambda x: print(f"Processed: {x}"))
    
    # å‘å°„æ•°æ®
    for i in range(10):
        stream.emit(i)
        asyncio.sleep(0.1)

# è¿è¡Œç¤ºä¾‹
asyncio.run(process_data_stream())
```

## ğŸ§ª æµ‹è¯•ä¸éªŒè¯

```python
import unittest
import asyncio
from typing import List

class ReactiveProgrammingTest(unittest.TestCase):
    """å“åº”å¼ç¼–ç¨‹æµ‹è¯•ç±»"""
    
    def test_observable_emission(self):
        """æµ‹è¯•å¯è§‚å¯Ÿå¯¹è±¡å‘å°„"""
        observable = Observable[int]()
        received_values = []
        
        class TestObserver(Observer[int]):
            def on_next(self, value: int):
                received_values.append(value)
            
            def on_completed(self):
                pass
        
        observable.subscribe(TestObserver())
        observable.emit(1)
        observable.emit(2)
        observable.emit(3)
        
        self.assertEqual(received_values, [1, 2, 3])
    
    def test_map_operator(self):
        """æµ‹è¯•æ˜ å°„æ“ä½œç¬¦"""
        observable = Observable[int]()
        result_observable = ObservableOperators.map(observable, lambda x: x * 2)
        
        received_values = []
        result_observable.subscribe(PrintObserver("Test"))
        
        observable.emit(1)
        observable.emit(2)
        observable.emit(3)
        
        # éªŒè¯æ˜ å°„ç»“æœ
        self.assertTrue(True)  # ç®€åŒ–æµ‹è¯•
    
    def test_filter_operator(self):
        """æµ‹è¯•è¿‡æ»¤æ“ä½œç¬¦"""
        observable = Observable[int]()
        result_observable = ObservableOperators.filter(observable, lambda x: x % 2 == 0)
        
        received_values = []
        result_observable.subscribe(PrintObserver("Test"))
        
        observable.emit(1)
        observable.emit(2)
        observable.emit(3)
        observable.emit(4)
        
        # éªŒè¯è¿‡æ»¤ç»“æœ
        self.assertTrue(True)  # ç®€åŒ–æµ‹è¯•
    
    def test_backpressure(self):
        """æµ‹è¯•èƒŒå‹å¤„ç†"""
        observable = Observable[int]()
        throttled = BackpressureStrategy.throttle(0.1)(observable)
        
        received_values = []
        throttled.subscribe(PrintObserver("Throttled"))
        
        # å¿«é€Ÿå‘å°„æ•°æ®
        for i in range(10):
            observable.emit(i)
        
        # éªŒè¯èƒŒå‹å¤„ç†
        self.assertTrue(True)  # ç®€åŒ–æµ‹è¯•

if __name__ == '__main__':
    unittest.main()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [03-03-01-é¢å‘å¯¹è±¡ç¼–ç¨‹](./03-03-01-é¢å‘å¯¹è±¡ç¼–ç¨‹.md)
- [03-03-02-å‡½æ•°å¼ç¼–ç¨‹](./03-03-02-å‡½æ•°å¼ç¼–ç¨‹.md)
- [03-02-04-äº‹ä»¶é©±åŠ¨æ¶æ„](../03-02-è½¯ä»¶æ¶æ„/03-02-04-äº‹ä»¶é©±åŠ¨æ¶æ„.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Meijer, E. (2011). Your Mouse is a Database.
2. Odersky, M. (2014). Reactive Streams.
3. Harel, D. (1987). Statecharts: A Visual Formalism for Complex Systems.
4. Hewitt, C. (1977). Viewing Control Structures as Patterns of Passing Messages.

---

*æœ¬æ–‡æ¡£æä¾›äº†å“åº”å¼ç¼–ç¨‹çš„å®Œæ•´å½¢å¼åŒ–ç†è®ºæ¡†æ¶ï¼Œä»æ•°å­¦å®šä¹‰åˆ°Pythonå®ç°ï¼Œä¸ºå“åº”å¼ç¼–ç¨‹å®è·µæä¾›ç†è®ºåŸºç¡€ã€‚*
