# 03.01.01 åˆ›å»ºå‹æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

åˆ›å»ºå‹æ¨¡å¼å…³æ³¨å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹ï¼Œæä¾›çµæ´»çš„å¯¹è±¡åˆ›å»ºæœºåˆ¶ã€‚æœ¬æ–‡æ¡£å°†åˆ›å»ºå‹æ¨¡å¼è¿›è¡Œå½¢å¼åŒ–å®šä¹‰ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. åˆ›å»ºå‹æ¨¡å¼çš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
åˆ›å»ºå‹æ¨¡å¼æ˜¯ä¸€ä¸ªå‡½æ•° $C: P \rightarrow O$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯åˆ›å»ºå‚æ•°é›†åˆ
- $O$ æ˜¯å¯¹è±¡é›†åˆ
- $C$ æ˜¯åˆ›å»ºå‡½æ•°ï¼Œå°†å‚æ•°æ˜ å°„åˆ°å¯¹è±¡

å¯¹äºæ¨¡å¼ $M$ï¼Œå…¶åˆ›å»ºå‡½æ•°ä¸ºï¼š
$$C_M: P_M \times S_M \rightarrow O_M$$

å…¶ä¸­ $S_M$ æ˜¯æ¨¡å¼çš„çŠ¶æ€ç©ºé—´ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, Generic, Dict, Any, Callable, Optional, List
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import threading
import time

T = TypeVar('T')
U = TypeVar('U')

class CreationPattern(Enum):
    """åˆ›å»ºå‹æ¨¡å¼æšä¸¾"""
    SINGLETON = "singleton"
    FACTORY_METHOD = "factory_method"
    ABSTRACT_FACTORY = "abstract_factory"
    BUILDER = "builder"
    PROTOTYPE = "prototype"

@dataclass
class CreationContext:
    """åˆ›å»ºä¸Šä¸‹æ–‡"""
    pattern_type: CreationPattern
    parameters: Dict[str, Any]
    constraints: List[str]
    state: Dict[str, Any]

class ObjectCreator(ABC):
    """å¯¹è±¡åˆ›å»ºå™¨æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def create(self, context: CreationContext) -> Any:
        """åˆ›å»ºå¯¹è±¡"""
        pass
    
    @abstractmethod
    def validate(self, context: CreationContext) -> bool:
        """éªŒè¯åˆ›å»ºå‚æ•°"""
        pass

class CreationPatternFramework:
    """åˆ›å»ºå‹æ¨¡å¼æ¡†æ¶"""
    
    def __init__(self):
        self.creators: Dict[CreationPattern, ObjectCreator] = {}
        self._initialize_creators()
    
    def _initialize_creators(self):
        """åˆå§‹åŒ–åˆ›å»ºå™¨"""
        self.creators[CreationPattern.SINGLETON] = SingletonCreator()
        self.creators[CreationPattern.FACTORY_METHOD] = FactoryMethodCreator()
        self.creators[CreationPattern.ABSTRACT_FACTORY] = AbstractFactoryCreator()
        self.creators[CreationPattern.BUILDER] = BuilderCreator()
        self.creators[CreationPattern.PROTOTYPE] = PrototypeCreator()
    
    def create_object(self, pattern: CreationPattern, context: CreationContext) -> Any:
        """åˆ›å»ºå¯¹è±¡"""
        creator = self.creators.get(pattern)
        if not creator:
            raise ValueError(f"Unsupported pattern: {pattern}")
        
        if not creator.validate(context):
            raise ValueError(f"Invalid context for pattern {pattern}")
        
        return creator.create(context)
    
    def analyze_pattern(self, pattern: CreationPattern) -> Dict[str, Any]:
        """åˆ†ææ¨¡å¼ç‰¹æ€§"""
        creator = self.creators.get(pattern)
        if not creator:
            return {}
        
        return {
            "pattern": pattern.value,
            "complexity": self._assess_complexity(pattern),
            "flexibility": self._assess_flexibility(pattern),
            "performance": self._assess_performance(pattern),
            "use_cases": self._get_use_cases(pattern)
        }
    
    def _assess_complexity(self, pattern: CreationPattern) -> str:
        """è¯„ä¼°å¤æ‚åº¦"""
        complexity_map = {
            CreationPattern.SINGLETON: "Low",
            CreationPattern.FACTORY_METHOD: "Medium",
            CreationPattern.ABSTRACT_FACTORY: "High",
            CreationPattern.BUILDER: "Medium",
            CreationPattern.PROTOTYPE: "Low"
        }
        return complexity_map.get(pattern, "Unknown")
    
    def _assess_flexibility(self, pattern: CreationPattern) -> str:
        """è¯„ä¼°çµæ´»æ€§"""
        flexibility_map = {
            CreationPattern.SINGLETON: "Low",
            CreationPattern.FACTORY_METHOD: "High",
            CreationPattern.ABSTRACT_FACTORY: "High",
            CreationPattern.BUILDER: "High",
            CreationPattern.PROTOTYPE: "Medium"
        }
        return flexibility_map.get(pattern, "Unknown")
    
    def _assess_performance(self, pattern: CreationPattern) -> str:
        """è¯„ä¼°æ€§èƒ½"""
        performance_map = {
            CreationPattern.SINGLETON: "High",
            CreationPattern.FACTORY_METHOD: "Medium",
            CreationPattern.ABSTRACT_FACTORY: "Medium",
            CreationPattern.BUILDER: "Low",
            CreationPattern.PROTOTYPE: "High"
        }
        return performance_map.get(pattern, "Unknown")
    
    def _get_use_cases(self, pattern: CreationPattern) -> List[str]:
        """è·å–ä½¿ç”¨åœºæ™¯"""
        use_cases_map = {
            CreationPattern.SINGLETON: ["é…ç½®ç®¡ç†", "æ—¥å¿—è®°å½•", "æ•°æ®åº“è¿æ¥"],
            CreationPattern.FACTORY_METHOD: ["æ¡†æ¶æ‰©å±•", "äº§å“æ—åˆ›å»º", "æ’ä»¶ç³»ç»Ÿ"],
            CreationPattern.ABSTRACT_FACTORY: ["è·¨å¹³å°UI", "æ•°æ®åº“æŠ½è±¡", "ä¸»é¢˜ç³»ç»Ÿ"],
            CreationPattern.BUILDER: ["å¤æ‚å¯¹è±¡æ„å»º", "é…ç½®å¯¹è±¡", "æŸ¥è¯¢æ„å»º"],
            CreationPattern.PROTOTYPE: ["å¯¹è±¡å…‹éš†", "åŸå‹ç³»ç»Ÿ", "æ¨¡æ¿ç³»ç»Ÿ"]
        }
        return use_cases_map.get(pattern, [])

# ä½¿ç”¨ç¤ºä¾‹
framework = CreationPatternFramework()
```

### 2. å•ä¾‹æ¨¡å¼ (Singleton)

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å•ä¾‹æ¨¡å¼ç¡®ä¿ç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼š
$$\forall x, y \in \text{Instance}(C): x = y$$

å…¶ä¸­ $C$ æ˜¯å•ä¾‹ç±»ï¼Œ$\text{Instance}(C)$ æ˜¯ $C$ çš„æ‰€æœ‰å®ä¾‹é›†åˆã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Optional, Any
from threading import Lock
import time

class Singleton:
    """å•ä¾‹æ¨¡å¼åŸºç¡€å®ç°"""
    
    _instance: Optional['Singleton'] = None
    _lock = Lock()
    
    def __new__(cls) -> 'Singleton':
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
            self._data = {}
    
    def set_data(self, key: str, value: Any):
        """è®¾ç½®æ•°æ®"""
        self._data[key] = value
    
    def get_data(self, key: str) -> Any:
        """è·å–æ•°æ®"""
        return self._data.get(key)

class DatabaseConnection:
    """æ•°æ®åº“è¿æ¥å•ä¾‹"""
    
    _instance: Optional['DatabaseConnection'] = None
    _lock = Lock()
    
    def __new__(cls) -> 'DatabaseConnection':
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
            self._connection = None
            self._is_connected = False
    
    def connect(self, host: str, port: int, database: str):
        """è¿æ¥æ•°æ®åº“"""
        if not self._is_connected:
            # æ¨¡æ‹Ÿæ•°æ®åº“è¿æ¥
            print(f"Connecting to {host}:{port}/{database}")
            self._connection = f"Connection to {host}:{port}/{database}"
            self._is_connected = True
            time.sleep(0.1)  # æ¨¡æ‹Ÿè¿æ¥æ—¶é—´
    
    def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        if self._is_connected:
            print("Disconnecting from database")
            self._connection = None
            self._is_connected = False
    
    def execute_query(self, query: str) -> str:
        """æ‰§è¡ŒæŸ¥è¯¢"""
        if not self._is_connected:
            raise RuntimeError("Database not connected")
        return f"Executed: {query}"
    
    @property
    def is_connected(self) -> bool:
        return self._is_connected

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_singleton():
    """æ¼”ç¤ºå•ä¾‹æ¨¡å¼"""
    # åˆ›å»ºå¤šä¸ªå®ä¾‹
    db1 = DatabaseConnection()
    db2 = DatabaseConnection()
    
    print(f"db1 is db2: {db1 is db2}")  # True
    
    # è¿æ¥æ•°æ®åº“
    db1.connect("localhost", 5432, "mydb")
    print(f"db2 is connected: {db2.is_connected}")  # True
    
    # æ‰§è¡ŒæŸ¥è¯¢
    result = db2.execute_query("SELECT * FROM users")
    print(result)
```

#### 2.2 çº¿ç¨‹å®‰å…¨å•ä¾‹

```python
import threading
from typing import Optional, TypeVar, Type

T = TypeVar('T')

class ThreadSafeSingleton:
    """çº¿ç¨‹å®‰å…¨å•ä¾‹åŸºç±»"""
    
    _instance: Optional[T] = None
    _lock = threading.Lock()
    _initialized = False
    
    def __new__(cls: Type[T]) -> T:
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not self._initialized:
            with self._lock:
                if not self._initialized:
                    self._initialize()
                    self._initialized = True
    
    def _initialize(self):
        """åˆå§‹åŒ–æ–¹æ³•ï¼Œå­ç±»å¯ä»¥é‡å†™"""
        pass

class DatabaseConnection(ThreadSafeSingleton):
    """æ•°æ®åº“è¿æ¥å•ä¾‹"""
    
    def _initialize(self):
        self.connection_string = ""
        self.is_connected = False
        self.connection_pool = []
    
    def connect(self, connection_string: str):
        """è¿æ¥æ•°æ®åº“"""
        self.connection_string = connection_string
        self.is_connected = True
        print(f"Connected to database: {connection_string}")
    
    def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        self.is_connected = False
        print("Disconnected from database")
    
    def execute_query(self, query: str):
        """æ‰§è¡ŒæŸ¥è¯¢"""
        if self.is_connected:
            print(f"Executing query: {query}")
            return f"Result of {query}"
        else:
            raise Exception("Database not connected")

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_thread_safe_singleton():
    """æ¼”ç¤ºçº¿ç¨‹å®‰å…¨å•ä¾‹"""
    print("\nçº¿ç¨‹å®‰å…¨å•ä¾‹æ¼”ç¤º:")
    
    # åˆ›å»ºå¤šä¸ªçº¿ç¨‹è®¿é—®å•ä¾‹
    def worker(worker_id: int):
        db = DatabaseConnection()
        print(f"Worker {worker_id}: {db}")
        
        if worker_id == 1:
            db.connect("postgresql://localhost:5432/mydb")
        
        time.sleep(0.1)
        
        if db.is_connected:
            result = db.execute_query(f"SELECT * FROM table_{worker_id}")
            print(f"Worker {worker_id} result: {result}")
    
    # åˆ›å»ºçº¿ç¨‹
    threads = []
    for i in range(3):
        thread = threading.Thread(target=worker, args=(i+1,))
        threads.append(thread)
        thread.start()
    
    # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for thread in threads:
        thread.join()
    
    # éªŒè¯å•ä¾‹
    db1 = DatabaseConnection()
    db2 = DatabaseConnection()
    print(f"\nå•ä¾‹éªŒè¯: {db1 is db2}")

# è¿è¡Œæ¼”ç¤º
demonstrate_thread_safe_singleton()
```

### 3. å·¥å‚æ–¹æ³•æ¨¡å¼ (Factory Method)

#### 3.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å·¥å‚æ–¹æ³•æ¨¡å¼å®šä¹‰äº†ä¸€ä¸ªåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œè®©å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»ï¼š
$$F_M: C \times P \rightarrow O$$

å…¶ä¸­ $C$ æ˜¯åˆ›å»ºè€…ç±»ï¼Œ$P$ æ˜¯äº§å“å‚æ•°ï¼Œ$O$ æ˜¯äº§å“å¯¹è±¡ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class Product(ABC):
    """äº§å“æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def operation(self) -> str:
        """äº§å“æ“ä½œ"""
        pass

class ConcreteProductA(Product):
    """å…·ä½“äº§å“A"""
    
    def operation(self) -> str:
        return "ConcreteProductA operation"

class ConcreteProductB(Product):
    """å…·ä½“äº§å“B"""
    
    def operation(self) -> str:
        return "ConcreteProductB operation"

class ConcreteProductC(Product):
    """å…·ä½“äº§å“C"""
    
    def operation(self) -> str:
        return "ConcreteProductC operation"

class Creator(ABC):
    """åˆ›å»ºè€…æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def factory_method(self, product_type: str) -> Product:
        """å·¥å‚æ–¹æ³•"""
        pass
    
    def some_operation(self, product_type: str) -> str:
        """ä½¿ç”¨å·¥å‚æ–¹æ³•åˆ›å»ºäº§å“"""
        product = self.factory_method(product_type)
        return f"Creator: {product.operation()}"

class ConcreteCreatorA(Creator):
    """å…·ä½“åˆ›å»ºè€…A"""
    
    def factory_method(self, product_type: str) -> Product:
        if product_type == "A":
            return ConcreteProductA()
        elif product_type == "B":
            return ConcreteProductB()
        else:
            raise ValueError(f"Unknown product type: {product_type}")

class ConcreteCreatorB(Creator):
    """å…·ä½“åˆ›å»ºè€…B"""
    
    def factory_method(self, product_type: str) -> Product:
        if product_type == "B":
            return ConcreteProductB()
        elif product_type == "C":
            return ConcreteProductC()
        else:
            raise ValueError(f"Unknown product type: {product_type}")

class FactoryMethodCreator(ObjectCreator):
    """å·¥å‚æ–¹æ³•æ¨¡å¼åˆ›å»ºå™¨"""
    
    def create(self, context: CreationContext) -> Any:
        """åˆ›å»ºå·¥å‚æ–¹æ³•æ¨¡å¼"""
        creator_type = context.parameters.get("creator_type", "A")
        product_type = context.parameters.get("product_type", "A")
        
        if creator_type == "A":
            creator = ConcreteCreatorA()
        elif creator_type == "B":
            creator = ConcreteCreatorB()
        else:
            raise ValueError(f"Unknown creator type: {creator_type}")
        
        return creator.some_operation(product_type)
    
    def validate(self, context: CreationContext) -> bool:
        """éªŒè¯å·¥å‚æ–¹æ³•å‚æ•°"""
        required_params = ["creator_type", "product_type"]
        return all(param in context.parameters for param in required_params)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_factory_method():
    """æ¼”ç¤ºå·¥å‚æ–¹æ³•æ¨¡å¼"""
    print("\nå·¥å‚æ–¹æ³•æ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºå·¥å‚æ–¹æ³•
    context = CreationContext(
        pattern_type=CreationPattern.FACTORY_METHOD,
        parameters={"creator_type": "A", "product_type": "B"},
        constraints=[],
        state={}
    )
    
    creator = FactoryMethodCreator()
    if creator.validate(context):
        result = creator.create(context)
        print(f"å·¥å‚æ–¹æ³•ç»“æœ: {result}")
    
    # ç›´æ¥ä½¿ç”¨
    creator_a = ConcreteCreatorA()
    creator_b = ConcreteCreatorB()
    
    print(f"åˆ›å»ºè€…A + äº§å“A: {creator_a.some_operation('A')}")
    print(f"åˆ›å»ºè€…A + äº§å“B: {creator_a.some_operation('B')}")
    print(f"åˆ›å»ºè€…B + äº§å“B: {creator_b.some_operation('B')}")
    print(f"åˆ›å»ºè€…B + äº§å“C: {creator_b.some_operation('C')}")

# è¿è¡Œæ¼”ç¤º
demonstrate_factory_method()
```

### 4. æŠ½è±¡å·¥å‚æ¨¡å¼ (Abstract Factory)

#### 4.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
æŠ½è±¡å·¥å‚æ¨¡å¼åˆ›å»ºä¸€ç³»åˆ—ç›¸å…³å¯¹è±¡ï¼š
$$AF: F_1 \times F_2 \times \cdots \times F_n \rightarrow P_1 \times P_2 \times \cdots \times P_n$$

å…¶ä¸­ $F_i$ æ˜¯ç¬¬ $i$ ä¸ªå·¥å‚ï¼Œ$P_i$ æ˜¯ç¬¬ $i$ ä¸ªäº§å“ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import List, Dict

class AbstractProductA(ABC):
    """æŠ½è±¡äº§å“A"""
    
    @abstractmethod
    def operation_a(self) -> str:
        pass

class AbstractProductB(ABC):
    """æŠ½è±¡äº§å“B"""
    
    @abstractmethod
    def operation_b(self) -> str:
        pass

class ConcreteProductA1(AbstractProductA):
    """å…·ä½“äº§å“A1"""
    
    def operation_a(self) -> str:
        return "ConcreteProductA1 operation"

class ConcreteProductA2(AbstractProductA):
    """å…·ä½“äº§å“A2"""
    
    def operation_a(self) -> str:
        return "ConcreteProductA2 operation"

class ConcreteProductB1(AbstractProductB):
    """å…·ä½“äº§å“B1"""
    
    def operation_b(self) -> str:
        return "ConcreteProductB1 operation"

class ConcreteProductB2(AbstractProductB):
    """å…·ä½“äº§å“B2"""
    
    def operation_b(self) -> str:
        return "ConcreteProductB2 operation"

class AbstractFactory(ABC):
    """æŠ½è±¡å·¥å‚"""
    
    @abstractmethod
    def create_product_a(self) -> AbstractProductA:
        pass
    
    @abstractmethod
    def create_product_b(self) -> AbstractProductB:
        pass

class ConcreteFactory1(AbstractFactory):
    """å…·ä½“å·¥å‚1"""
    
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA1()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB1()

class ConcreteFactory2(AbstractFactory):
    """å…·ä½“å·¥å‚2"""
    
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA2()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB2()

class Client:
    """å®¢æˆ·ç«¯"""
    
    def __init__(self, factory: AbstractFactory):
        self.factory = factory
    
    def run(self):
        """è¿è¡Œå®¢æˆ·ç«¯"""
        product_a = self.factory.create_product_a()
        product_b = self.factory.create_product_b()
        
        print(f"Product A: {product_a.operation_a()}")
        print(f"Product B: {product_b.operation_b()}")

class AbstractFactoryCreator(ObjectCreator):
    """æŠ½è±¡å·¥å‚æ¨¡å¼åˆ›å»ºå™¨"""
    
    def create(self, context: CreationContext) -> Any:
        """åˆ›å»ºæŠ½è±¡å·¥å‚æ¨¡å¼"""
        factory_type = context.parameters.get("factory_type", "1")
        
        if factory_type == "1":
            factory = ConcreteFactory1()
        elif factory_type == "2":
            factory = ConcreteFactory2()
        else:
            raise ValueError(f"Unknown factory type: {factory_type}")
        
        client = Client(factory)
        return client
    
    def validate(self, context: CreationContext) -> bool:
        """éªŒè¯æŠ½è±¡å·¥å‚å‚æ•°"""
        required_params = ["factory_type"]
        return all(param in context.parameters for param in required_params)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_abstract_factory():
    """æ¼”ç¤ºæŠ½è±¡å·¥å‚æ¨¡å¼"""
    print("\næŠ½è±¡å·¥å‚æ¨¡å¼æ¼”ç¤º:")
    
    # ä½¿ç”¨å·¥å‚1
    context1 = CreationContext(
        pattern_type=CreationPattern.ABSTRACT_FACTORY,
        parameters={"factory_type": "1"},
        constraints=[],
        state={}
    )
    
    creator = AbstractFactoryCreator()
    if creator.validate(context1):
        client1 = creator.create(context1)
        print("å·¥å‚1äº§å“:")
        client1.run()
    
    print("-" * 30)
    
    # ä½¿ç”¨å·¥å‚2
    context2 = CreationContext(
        pattern_type=CreationPattern.ABSTRACT_FACTORY,
        parameters={"factory_type": "2"},
        constraints=[],
        state={}
    )
    
    if creator.validate(context2):
        client2 = creator.create(context2)
        print("å·¥å‚2äº§å“:")
        client2.run()

# è¿è¡Œæ¼”ç¤º
demonstrate_abstract_factory()
```

### 5. å»ºé€ è€…æ¨¡å¼ (Builder)

#### 5.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å»ºé€ è€…æ¨¡å¼åˆ†æ­¥æ„å»ºå¤æ‚å¯¹è±¡ï¼š
$$B: S_1 \times S_2 \times \cdots \times S_n \rightarrow O$$

å…¶ä¸­ $S_i$ æ˜¯ç¬¬ $i$ ä¸ªæ„å»ºæ­¥éª¤ï¼Œ$O$ æ˜¯æœ€ç»ˆå¯¹è±¡ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class Product:
    """äº§å“ç±»"""
    
    def __init__(self):
        self.parts: List[str] = []
    
    def add_part(self, part: str):
        """æ·»åŠ éƒ¨ä»¶"""
        self.parts.append(part)
    
    def list_parts(self) -> str:
        """åˆ—å‡ºæ‰€æœ‰éƒ¨ä»¶"""
        return f"Product parts: {', '.join(self.parts)}"

class Builder(ABC):
    """æŠ½è±¡å»ºé€ è€…"""
    
    def __init__(self):
        self.reset()
    
    def reset(self):
        """é‡ç½®å»ºé€ è€…"""
        self._product = Product()
    
    @property
    def product(self) -> Product:
        """è·å–äº§å“"""
        product = self._product
        self.reset()
        return product
    
    @abstractmethod
    def build_part_a(self):
        """æ„å»ºéƒ¨ä»¶A"""
        pass
    
    @abstractmethod
    def build_part_b(self):
        """æ„å»ºéƒ¨ä»¶B"""
        pass
    
    @abstractmethod
    def build_part_c(self):
        """æ„å»ºéƒ¨ä»¶C"""
        pass

class ConcreteBuilder1(Builder):
    """å…·ä½“å»ºé€ è€…1"""
    
    def build_part_a(self):
        self._product.add_part("PartA1")
    
    def build_part_b(self):
        self._product.add_part("PartB1")
    
    def build_part_c(self):
        self._product.add_part("PartC1")

class ConcreteBuilder2(Builder):
    """å…·ä½“å»ºé€ è€…2"""
    
    def build_part_a(self):
        self._product.add_part("PartA2")
    
    def build_part_b(self):
        self._product.add_part("PartB2")
    
    def build_part_c(self):
        self._product.add_part("PartC2")

class Director:
    """æŒ‡æŒ¥è€…"""
    
    def __init__(self):
        self._builder: Builder = None
    
    @property
    def builder(self) -> Builder:
        return self._builder
    
    @builder.setter
    def builder(self, builder: Builder):
        self._builder = builder
    
    def build_minimal_viable_product(self) -> Product:
        """æ„å»ºæœ€å°å¯è¡Œäº§å“"""
        self.builder.build_part_a()
        return self.builder.product
    
    def build_full_featured_product(self) -> Product:
        """æ„å»ºå®Œæ•´åŠŸèƒ½äº§å“"""
        self.builder.build_part_a()
        self.builder.build_part_b()
        self.builder.build_part_c()
        return self.builder.product

class BuilderCreator(ObjectCreator):
    """å»ºé€ è€…æ¨¡å¼åˆ›å»ºå™¨"""
    
    def create(self, context: CreationContext) -> Any:
        """åˆ›å»ºå»ºé€ è€…æ¨¡å¼"""
        builder_type = context.parameters.get("builder_type", "1")
        build_type = context.parameters.get("build_type", "full")
        
        if builder_type == "1":
            builder = ConcreteBuilder1()
        elif builder_type == "2":
            builder = ConcreteBuilder2()
        else:
            raise ValueError(f"Unknown builder type: {builder_type}")
        
        director = Director()
        director.builder = builder
        
        if build_type == "minimal":
            return director.build_minimal_viable_product()
        else:
            return director.build_full_featured_product()
    
    def validate(self, context: CreationContext) -> bool:
        """éªŒè¯å»ºé€ è€…å‚æ•°"""
        required_params = ["builder_type", "build_type"]
        return all(param in context.parameters for param in required_params)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_builder():
    """æ¼”ç¤ºå»ºé€ è€…æ¨¡å¼"""
    print("\nå»ºé€ è€…æ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºå®Œæ•´äº§å“
    context1 = CreationContext(
        pattern_type=CreationPattern.BUILDER,
        parameters={"builder_type": "1", "build_type": "full"},
        constraints=[],
        state={}
    )
    
    creator = BuilderCreator()
    if creator.validate(context1):
        product1 = creator.create(context1)
        print(f"å®Œæ•´äº§å“1: {product1.list_parts()}")
    
    # åˆ›å»ºæœ€å°äº§å“
    context2 = CreationContext(
        pattern_type=CreationPattern.BUILDER,
        parameters={"builder_type": "2", "build_type": "minimal"},
        constraints=[],
        state={}
    )
    
    if creator.validate(context2):
        product2 = creator.create(context2)
        print(f"æœ€å°äº§å“2: {product2.list_parts()}")
    
    # ç›´æ¥ä½¿ç”¨
    director = Director()
    builder1 = ConcreteBuilder1()
    builder2 = ConcreteBuilder2()
    
    director.builder = builder1
    product3 = director.build_full_featured_product()
    print(f"ç›´æ¥æ„å»ºäº§å“1: {product3.list_parts()}")
    
    director.builder = builder2
    product4 = director.build_minimal_viable_product()
    print(f"ç›´æ¥æ„å»ºäº§å“2: {product4.list_parts()}")

# è¿è¡Œæ¼”ç¤º
demonstrate_builder()
```

### 6. åŸå‹æ¨¡å¼ (Prototype)

#### 6.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
åŸå‹æ¨¡å¼é€šè¿‡å…‹éš†åˆ›å»ºå¯¹è±¡ï¼š
$$P: O \rightarrow O'$$

å…¶ä¸­ $O$ æ˜¯åŸå‹å¯¹è±¡ï¼Œ$O'$ æ˜¯å…‹éš†å¯¹è±¡ï¼Œæ»¡è¶³ $O' \cong O$ï¼ˆåŒæ„ï¼‰ã€‚

**Pythonå®ç°**ï¼š

```python
import copy
from abc import ABC, abstractmethod
from typing import Dict, Any

class Prototype(ABC):
    """åŸå‹æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def clone(self) -> 'Prototype':
        """å…‹éš†æ–¹æ³•"""
        pass

class ConcretePrototype1(Prototype):
    """å…·ä½“åŸå‹1"""
    
    def __init__(self, data: Dict[str, Any]):
        self.data = data
    
    def clone(self) -> 'ConcretePrototype1':
        """æµ…å…‹éš†"""
        return copy.copy(self)
    
    def deep_clone(self) -> 'ConcretePrototype1':
        """æ·±å…‹éš†"""
        return copy.deepcopy(self)
    
    def __str__(self):
        return f"ConcretePrototype1(data={self.data})"

class ConcretePrototype2(Prototype):
    """å…·ä½“åŸå‹2"""
    
    def __init__(self, name: str, value: int):
        self.name = name
        self.value = value
    
    def clone(self) -> 'ConcretePrototype2':
        """å…‹éš†"""
        return ConcretePrototype2(self.name, self.value)
    
    def __str__(self):
        return f"ConcretePrototype2(name={self.name}, value={self.value})"

class PrototypeRegistry:
    """åŸå‹æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self._prototypes: Dict[str, Prototype] = {}
    
    def register(self, name: str, prototype: Prototype):
        """æ³¨å†ŒåŸå‹"""
        self._prototypes[name] = prototype
    
    def unregister(self, name: str):
        """æ³¨é”€åŸå‹"""
        if name in self._prototypes:
            del self._prototypes[name]
    
    def clone(self, name: str) -> Prototype:
        """å…‹éš†åŸå‹"""
        if name not in self._prototypes:
            raise ValueError(f"Prototype '{name}' not found")
        return self._prototypes[name].clone()
    
    def list_prototypes(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰åŸå‹"""
        return list(self._prototypes.keys())

class PrototypeCreator(ObjectCreator):
    """åŸå‹æ¨¡å¼åˆ›å»ºå™¨"""
    
    def create(self, context: CreationContext) -> Any:
        """åˆ›å»ºåŸå‹æ¨¡å¼"""
        prototype_type = context.parameters.get("prototype_type", "1")
        clone_type = context.parameters.get("clone_type", "shallow")
        
        if prototype_type == "1":
            data = context.parameters.get("data", {"key": "value"})
            prototype = ConcretePrototype1(data)
        elif prototype_type == "2":
            name = context.parameters.get("name", "default")
            value = context.parameters.get("value", 0)
            prototype = ConcretePrototype2(name, value)
        else:
            raise ValueError(f"Unknown prototype type: {prototype_type}")
        
        if clone_type == "deep" and hasattr(prototype, 'deep_clone'):
            return prototype.deep_clone()
        else:
            return prototype.clone()
    
    def validate(self, context: CreationContext) -> bool:
        """éªŒè¯åŸå‹å‚æ•°"""
        required_params = ["prototype_type"]
        return all(param in context.parameters for param in required_params)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_prototype():
    """æ¼”ç¤ºåŸå‹æ¨¡å¼"""
    print("\nåŸå‹æ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºåŸå‹1
    context1 = CreationContext(
        pattern_type=CreationPattern.PROTOTYPE,
        parameters={
            "prototype_type": "1",
            "clone_type": "shallow",
            "data": {"name": "John", "age": 30}
        },
        constraints=[],
        state={}
    )
    
    creator = PrototypeCreator()
    if creator.validate(context1):
        clone1 = creator.create(context1)
        print(f"æµ…å…‹éš†ç»“æœ: {clone1}")
    
    # åˆ›å»ºåŸå‹2
    context2 = CreationContext(
        pattern_type=CreationPattern.PROTOTYPE,
        parameters={
            "prototype_type": "2",
            "name": "Alice",
            "value": 42
        },
        constraints=[],
        state={}
    )
    
    if creator.validate(context2):
        clone2 = creator.create(context2)
        print(f"åŸå‹2å…‹éš†: {clone2}")
    
    # ä½¿ç”¨åŸå‹æ³¨å†Œè¡¨
    registry = PrototypeRegistry()
    
    # æ³¨å†ŒåŸå‹
    prototype1 = ConcretePrototype1({"config": "default"})
    prototype2 = ConcretePrototype2("template", 100)
    
    registry.register("config", prototype1)
    registry.register("template", prototype2)
    
    print(f"\næ³¨å†Œçš„åŸå‹: {registry.list_prototypes()}")
    
    # å…‹éš†åŸå‹
    cloned_config = registry.clone("config")
    cloned_template = registry.clone("template")
    
    print(f"å…‹éš†çš„é…ç½®: {cloned_config}")
    print(f"å…‹éš†çš„æ¨¡æ¿: {cloned_template}")
    
    # æ¼”ç¤ºæ·±å…‹éš†
    original = ConcretePrototype1({"nested": {"level": 1}})
    shallow_clone = original.clone()
    deep_clone = original.deep_clone()
    
    # ä¿®æ”¹åµŒå¥—æ•°æ®
    original.data["nested"]["level"] = 2
    
    print(f"\nåŸå§‹å¯¹è±¡: {original}")
    print(f"æµ…å…‹éš†: {shallow_clone}")
    print(f"æ·±å…‹éš†: {deep_clone}")

# è¿è¡Œæ¼”ç¤º
demonstrate_prototype()
```

## ğŸ“Š æ¨¡å¼æ¯”è¾ƒåˆ†æ

```python
class CreationPatternAnalyzer:
    """åˆ›å»ºå‹æ¨¡å¼åˆ†æå™¨"""
    
    def __init__(self):
        self.framework = CreationPatternFramework()
    
    def compare_patterns(self) -> Dict[str, Dict[str, Any]]:
        """æ¯”è¾ƒæ‰€æœ‰åˆ›å»ºå‹æ¨¡å¼"""
        patterns = [
            CreationPattern.SINGLETON,
            CreationPattern.FACTORY_METHOD,
            CreationPattern.ABSTRACT_FACTORY,
            CreationPattern.BUILDER,
            CreationPattern.PROTOTYPE
        ]
        
        comparison = {}
        for pattern in patterns:
            comparison[pattern.value] = self.framework.analyze_pattern(pattern)
        
        return comparison
    
    def generate_comparison_report(self) -> str:
        """ç”Ÿæˆæ¯”è¾ƒæŠ¥å‘Š"""
        comparison = self.compare_patterns()
        
        report = "åˆ›å»ºå‹æ¨¡å¼æ¯”è¾ƒæŠ¥å‘Š:\n"
        report += "=" * 60 + "\n"
        
        for pattern_name, analysis in comparison.items():
            report += f"\n{pattern_name.upper()}:\n"
            report += f"  å¤æ‚åº¦: {analysis['complexity']}\n"
            report += f"  çµæ´»æ€§: {analysis['flexibility']}\n"
            report += f"  æ€§èƒ½: {analysis['performance']}\n"
            report += f"  ä½¿ç”¨åœºæ™¯: {', '.join(analysis['use_cases'])}\n"
        
        return report
    
    def recommend_pattern(self, requirements: Dict[str, Any]) -> str:
        """æ ¹æ®éœ€æ±‚æ¨èæ¨¡å¼"""
        recommendations = {
            "single_instance": CreationPattern.SINGLETON.value,
            "flexible_creation": CreationPattern.FACTORY_METHOD.value,
            "product_family": CreationPattern.ABSTRACT_FACTORY.value,
            "complex_object": CreationPattern.BUILDER.value,
            "object_cloning": CreationPattern.PROTOTYPE.value
        }
        
        for requirement, pattern in recommendations.items():
            if requirement in requirements and requirements[requirement]:
                return pattern
        
        return CreationPattern.FACTORY_METHOD.value  # é»˜è®¤æ¨è

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_pattern_analysis():
    """æ¼”ç¤ºæ¨¡å¼åˆ†æ"""
    analyzer = CreationPatternAnalyzer()
    
    # ç”Ÿæˆæ¯”è¾ƒæŠ¥å‘Š
    report = analyzer.generate_comparison_report()
    print(report)
    
    # æ¨èæ¨¡å¼
    requirements = {
        "single_instance": True,
        "flexible_creation": False,
        "product_family": False,
        "complex_object": False,
        "object_cloning": False
    }
    
    recommended = analyzer.recommend_pattern(requirements)
    print(f"\næ ¹æ®éœ€æ±‚æ¨èæ¨¡å¼: {recommended}")
    
    return analyzer

# è¿è¡Œåˆ†æ
analyzer = demonstrate_pattern_analysis()
```

## ğŸ“ æ€»ç»“

åˆ›å»ºå‹æ¨¡å¼æä¾›äº†çµæ´»çš„å¯¹è±¡åˆ›å»ºæœºåˆ¶ï¼š

1. **å•ä¾‹æ¨¡å¼**: ç¡®ä¿ç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œé€‚ç”¨äºå…¨å±€çŠ¶æ€ç®¡ç†
2. **å·¥å‚æ–¹æ³•æ¨¡å¼**: å®šä¹‰åˆ›å»ºæ¥å£ï¼Œè®©å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»
3. **æŠ½è±¡å·¥å‚æ¨¡å¼**: åˆ›å»ºä¸€ç³»åˆ—ç›¸å…³å¯¹è±¡ï¼Œé€‚ç”¨äºäº§å“æ—
4. **å»ºé€ è€…æ¨¡å¼**: åˆ†æ­¥æ„å»ºå¤æ‚å¯¹è±¡ï¼Œé€‚ç”¨äºå¤æ‚å¯¹è±¡åˆ›å»º
5. **åŸå‹æ¨¡å¼**: é€šè¿‡å…‹éš†åˆ›å»ºå¯¹è±¡ï¼Œé€‚ç”¨äºå¯¹è±¡å¤åˆ¶

æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶é€‚ç”¨åœºæ™¯å’Œæƒè¡¡ï¼Œé€‰æ‹©åˆé€‚çš„æ¨¡å¼éœ€è¦è€ƒè™‘å¤æ‚åº¦ã€çµæ´»æ€§ã€æ€§èƒ½ç­‰å› ç´ ã€‚

## ğŸ”— ç›¸å…³é“¾æ¥

- [ç»“æ„å‹æ¨¡å¼](03.01.02-ç»“æ„å‹æ¨¡å¼.md)
- [è¡Œä¸ºå‹æ¨¡å¼](03.01.03-è¡Œä¸ºå‹æ¨¡å¼.md)
- [è®¾è®¡åŸåˆ™](00-ç†å¿µåŸºç¡€/00.01-ç¼–ç¨‹å“²å­¦/00.01.02-è®¾è®¡åŸåˆ™.md)
- [è½¯ä»¶æ¶æ„](03-å…·ä½“ç§‘å­¦/03.02-è½¯ä»¶æ¶æ„/README.md) 