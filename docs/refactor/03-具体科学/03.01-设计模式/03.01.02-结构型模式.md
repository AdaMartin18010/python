# 03.01.02 ç»“æ„å‹æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

ç»“æ„å‹æ¨¡å¼å…³æ³¨ç±»å’Œå¯¹è±¡çš„ç»„åˆï¼Œé€šè¿‡ç»„åˆå’Œç»§æ‰¿æ¥æ„å»ºæ›´å¤§çš„ç»“æ„ã€‚æœ¬æ–‡æ¡£å°†ç»“æ„å‹æ¨¡å¼è¿›è¡Œå½¢å¼åŒ–å®šä¹‰ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç»“æ„å‹æ¨¡å¼çš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
ç»“æ„å‹æ¨¡å¼æ˜¯ä¸€ä¸ªå‡½æ•° $S: C \times R \rightarrow O$ï¼Œå…¶ä¸­ï¼š

- $C$ æ˜¯ç»„ä»¶é›†åˆ
- $R$ æ˜¯å…³ç³»é›†åˆ
- $O$ æ˜¯ç»“æ„å¯¹è±¡é›†åˆ
- $S$ æ˜¯ç»“æ„å‡½æ•°ï¼Œå°†ç»„ä»¶å’Œå…³ç³»æ˜ å°„åˆ°ç»“æ„å¯¹è±¡

å¯¹äºæ¨¡å¼ $M$ï¼Œå…¶ç»“æ„å‡½æ•°ä¸ºï¼š
$$S_M: C_M \times R_M \rightarrow O_M$$

å…¶ä¸­ $C_M$ æ˜¯æ¨¡å¼ç»„ä»¶ï¼Œ$R_M$ æ˜¯æ¨¡å¼å…³ç³»ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, Generic, Dict, Any, Callable, Optional, List
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

T = TypeVar('T')
U = TypeVar('U')

class StructuralPattern(Enum):
    """ç»“æ„å‹æ¨¡å¼æšä¸¾"""
    ADAPTER = "adapter"
    BRIDGE = "bridge"
    COMPOSITE = "composite"
    DECORATOR = "decorator"
    FACADE = "facade"
    FLYWEIGHT = "flyweight"
    PROXY = "proxy"

@dataclass
class StructuralContext:
    """ç»“æ„ä¸Šä¸‹æ–‡"""
    pattern_type: StructuralPattern
    components: Dict[str, Any]
    relationships: List[Dict[str, Any]]
    constraints: List[str]
    state: Dict[str, Any]

class StructuralComponent(ABC):
    """ç»“æ„ç»„ä»¶æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def operation(self) -> str:
        """ç»„ä»¶æ“ä½œ"""
        pass
    
    @abstractmethod
    def get_structure(self) -> Dict[str, Any]:
        """è·å–ç»“æ„ä¿¡æ¯"""
        pass

class StructuralPatternFramework:
    """ç»“æ„å‹æ¨¡å¼æ¡†æ¶"""
    
    def __init__(self):
        self.patterns: Dict[StructuralPattern, Callable] = {}
        self._initialize_patterns()
    
    def _initialize_patterns(self):
        """åˆå§‹åŒ–æ¨¡å¼"""
        self.patterns[StructuralPattern.ADAPTER] = self._create_adapter
        self.patterns[StructuralPattern.BRIDGE] = self._create_bridge
        self.patterns[StructuralPattern.COMPOSITE] = self._create_composite
        self.patterns[StructuralPattern.DECORATOR] = self._create_decorator
        self.patterns[StructuralPattern.FACADE] = self._create_facade
        self.patterns[StructuralPattern.FLYWEIGHT] = self._create_flyweight
        self.patterns[StructuralPattern.PROXY] = self._create_proxy
    
    def create_structure(self, pattern: StructuralPattern, context: StructuralContext) -> Any:
        """åˆ›å»ºç»“æ„"""
        if pattern not in self.patterns:
            raise ValueError(f"Unsupported pattern: {pattern}")
        
        return self.patterns[pattern](context)
    
    def analyze_pattern(self, pattern: StructuralPattern) -> Dict[str, Any]:
        """åˆ†ææ¨¡å¼ç‰¹æ€§"""
        return {
            "pattern": pattern.value,
            "complexity": self._assess_complexity(pattern),
            "flexibility": self._assess_flexibility(pattern),
            "performance": self._assess_performance(pattern),
            "use_cases": self._get_use_cases(pattern)
        }
    
    def _assess_complexity(self, pattern: StructuralPattern) -> str:
        """è¯„ä¼°å¤æ‚åº¦"""
        complexity_map = {
            StructuralPattern.ADAPTER: "Low",
            StructuralPattern.BRIDGE: "Medium",
            StructuralPattern.COMPOSITE: "Medium",
            StructuralPattern.DECORATOR: "Medium",
            StructuralPattern.FACADE: "Low",
            StructuralPattern.FLYWEIGHT: "High",
            StructuralPattern.PROXY: "Low"
        }
        return complexity_map.get(pattern, "Unknown")
    
    def _assess_flexibility(self, pattern: StructuralPattern) -> str:
        """è¯„ä¼°çµæ´»æ€§"""
        flexibility_map = {
            StructuralPattern.ADAPTER: "Medium",
            StructuralPattern.BRIDGE: "High",
            StructuralPattern.COMPOSITE: "High",
            StructuralPattern.DECORATOR: "High",
            StructuralPattern.FACADE: "Low",
            StructuralPattern.FLYWEIGHT: "Medium",
            StructuralPattern.PROXY: "Medium"
        }
        return flexibility_map.get(pattern, "Unknown")
    
    def _assess_performance(self, pattern: StructuralPattern) -> str:
        """è¯„ä¼°æ€§èƒ½"""
        performance_map = {
            StructuralPattern.ADAPTER: "High",
            StructuralPattern.BRIDGE: "Medium",
            StructuralPattern.COMPOSITE: "Medium",
            StructuralPattern.DECORATOR: "Medium",
            StructuralPattern.FACADE: "High",
            StructuralPattern.FLYWEIGHT: "High",
            StructuralPattern.PROXY: "Medium"
        }
        return performance_map.get(pattern, "Unknown")
    
    def _get_use_cases(self, pattern: StructuralPattern) -> List[str]:
        """è·å–ä½¿ç”¨åœºæ™¯"""
        use_cases_map = {
            StructuralPattern.ADAPTER: ["æ¥å£é€‚é…", "ç¬¬ä¸‰æ–¹åº“é›†æˆ", "é—ç•™ç³»ç»Ÿé›†æˆ"],
            StructuralPattern.BRIDGE: ["æŠ½è±¡ä¸å®ç°åˆ†ç¦»", "å¤šç»´åº¦å˜åŒ–", "å¹³å°æŠ½è±¡"],
            StructuralPattern.COMPOSITE: ["æ ‘å½¢ç»“æ„", "æ–‡ä»¶ç³»ç»Ÿ", "GUIç»„ä»¶"],
            StructuralPattern.DECORATOR: ["åŠŸèƒ½æ‰©å±•", "æ¨ªåˆ‡å…³æ³¨ç‚¹", "åŠ¨æ€è¡Œä¸º"],
            StructuralPattern.FACADE: ["å­ç³»ç»Ÿç®€åŒ–", "APIå°è£…", "å¤æ‚æ“ä½œç®€åŒ–"],
            StructuralPattern.FLYWEIGHT: ["å†…å­˜ä¼˜åŒ–", "å¯¹è±¡å…±äº«", "å¤§é‡ç›¸ä¼¼å¯¹è±¡"],
            StructuralPattern.PROXY: ["è®¿é—®æ§åˆ¶", "å»¶è¿ŸåŠ è½½", "è¿œç¨‹ä»£ç†"]
        }
        return use_cases_map.get(pattern, [])
    
    # æ¨¡å¼åˆ›å»ºæ–¹æ³•
    def _create_adapter(self, context: StructuralContext) -> Any:
        """åˆ›å»ºé€‚é…å™¨æ¨¡å¼"""
        target_interface = context.components.get("target_interface")
        adaptee = context.components.get("adaptee")
        return Adapter(target_interface, adaptee)
    
    def _create_bridge(self, context: StructuralContext) -> Any:
        """åˆ›å»ºæ¡¥æ¥æ¨¡å¼"""
        abstraction = context.components.get("abstraction")
        implementation = context.components.get("implementation")
        return Bridge(abstraction, implementation)
    
    def _create_composite(self, context: StructuralContext) -> Any:
        """åˆ›å»ºç»„åˆæ¨¡å¼"""
        return Composite()
    
    def _create_decorator(self, context: StructuralContext) -> Any:
        """åˆ›å»ºè£…é¥°å™¨æ¨¡å¼"""
        component = context.components.get("component")
        return Decorator(component)
    
    def _create_facade(self, context: StructuralContext) -> Any:
        """åˆ›å»ºå¤–è§‚æ¨¡å¼"""
        subsystems = context.components.get("subsystems", [])
        return Facade(subsystems)
    
    def _create_flyweight(self, context: StructuralContext) -> Any:
        """åˆ›å»ºäº«å…ƒæ¨¡å¼"""
        return FlyweightFactory()
    
    def _create_proxy(self, context: StructuralContext) -> Any:
        """åˆ›å»ºä»£ç†æ¨¡å¼"""
        real_subject = context.components.get("real_subject")
        return Proxy(real_subject)

# ä½¿ç”¨ç¤ºä¾‹
framework = StructuralPatternFramework()
```

### 2. é€‚é…å™¨æ¨¡å¼ (Adapter)

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
é€‚é…å™¨æ¨¡å¼å°†ä¸€ä¸ªæ¥å£è½¬æ¢ä¸ºå¦ä¸€ä¸ªæ¥å£ï¼š
$$\text{Adapter}: I_1 \rightarrow I_2$$

å…¶ä¸­ $I_1$ æ˜¯æºæ¥å£ï¼Œ$I_2$ æ˜¯ç›®æ ‡æ¥å£ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import Any

class Target(ABC):
    """ç›®æ ‡æ¥å£"""
    
    @abstractmethod
    def request(self) -> str:
        """è¯·æ±‚æ–¹æ³•"""
        pass

class Adaptee:
    """éœ€è¦é€‚é…çš„ç±»"""
    
    def specific_request(self) -> str:
        """ç‰¹å®šè¯·æ±‚æ–¹æ³•"""
        return "Adaptee specific request"

class Adapter(Target):
    """é€‚é…å™¨ - ç±»é€‚é…å™¨"""
    
    def __init__(self, adaptee: Adaptee):
        self.adaptee = adaptee
    
    def request(self) -> str:
        """é€‚é…è¯·æ±‚"""
        return f"Adapter: {self.adaptee.specific_request()}"

class ObjectAdapter:
    """å¯¹è±¡é€‚é…å™¨"""
    
    def __init__(self, adaptee: Adaptee):
        self.adaptee = adaptee
    
    def request(self) -> str:
        """é€‚é…è¯·æ±‚"""
        return f"ObjectAdapter: {self.adaptee.specific_request()}"

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_adapter():
    """æ¼”ç¤ºé€‚é…å™¨æ¨¡å¼"""
    print("é€‚é…å™¨æ¨¡å¼æ¼”ç¤º:")
    
    adaptee = Adaptee()
    
    # ç±»é€‚é…å™¨
    adapter = Adapter(adaptee)
    print(f"ç±»é€‚é…å™¨: {adapter.request()}")
    
    # å¯¹è±¡é€‚é…å™¨
    object_adapter = ObjectAdapter(adaptee)
    print(f"å¯¹è±¡é€‚é…å™¨: {object_adapter.request()}")
    
    return adapter, object_adapter

# è¿è¡Œæ¼”ç¤º
adapter, object_adapter = demonstrate_adapter()
```

### 3. æ¡¥æ¥æ¨¡å¼ (Bridge)

#### 3.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
æ¡¥æ¥æ¨¡å¼å°†æŠ½è±¡ä¸å®ç°åˆ†ç¦»ï¼š
$$\text{Bridge}: A \times I \rightarrow O$$

å…¶ä¸­ $A$ æ˜¯æŠ½è±¡ï¼Œ$I$ æ˜¯å®ç°ï¼Œ$O$ æ˜¯ç»“æœå¯¹è±¡ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import List

class Implementation(ABC):
    """å®ç°æ¥å£"""
    
    @abstractmethod
    def operation_implementation(self) -> str:
        """å®ç°æ“ä½œ"""
        pass

class ConcreteImplementationA(Implementation):
    """å…·ä½“å®ç°A"""
    
    def operation_implementation(self) -> str:
        return "ConcreteImplementationA operation"

class ConcreteImplementationB(Implementation):
    """å…·ä½“å®ç°B"""
    
    def operation_implementation(self) -> str:
        return "ConcreteImplementationB operation"

class Abstraction(ABC):
    """æŠ½è±¡åŸºç±»"""
    
    def __init__(self, implementation: Implementation):
        self.implementation = implementation
    
    @abstractmethod
    def operation(self) -> str:
        """æŠ½è±¡æ“ä½œ"""
        pass

class RefinedAbstraction(Abstraction):
    """ç²¾ç¡®æŠ½è±¡"""
    
    def operation(self) -> str:
        return f"RefinedAbstraction: {self.implementation.operation_implementation()}"

class Bridge:
    """æ¡¥æ¥æ¨¡å¼"""
    
    def __init__(self, abstraction: Abstraction, implementation: Implementation):
        self.abstraction = abstraction
        self.implementation = implementation
    
    def execute(self) -> str:
        """æ‰§è¡Œæ¡¥æ¥æ“ä½œ"""
        return self.abstraction.operation()

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_bridge():
    """æ¼”ç¤ºæ¡¥æ¥æ¨¡å¼"""
    print("\næ¡¥æ¥æ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºå®ç°
    impl_a = ConcreteImplementationA()
    impl_b = ConcreteImplementationB()
    
    # åˆ›å»ºæŠ½è±¡
    abstraction_a = RefinedAbstraction(impl_a)
    abstraction_b = RefinedAbstraction(impl_b)
    
    # ä½¿ç”¨æ¡¥æ¥
    bridge_a = Bridge(abstraction_a, impl_a)
    bridge_b = Bridge(abstraction_b, impl_b)
    
    print(f"æ¡¥æ¥A: {bridge_a.execute()}")
    print(f"æ¡¥æ¥B: {bridge_b.execute()}")
    
    return bridge_a, bridge_b

# è¿è¡Œæ¼”ç¤º
bridge_a, bridge_b = demonstrate_bridge()
```

### 4. ç»„åˆæ¨¡å¼ (Composite)

#### 4.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
ç»„åˆæ¨¡å¼æ„å»ºæ ‘å½¢ç»“æ„ï¼š
$$\text{Composite}: N \times C \rightarrow T$$

å…¶ä¸­ $N$ æ˜¯èŠ‚ç‚¹ï¼Œ$C$ æ˜¯å­èŠ‚ç‚¹é›†åˆï¼Œ$T$ æ˜¯æ ‘å½¢ç»“æ„ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import List, Optional

class Component(ABC):
    """ç»„ä»¶æŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
    
    @abstractmethod
    def operation(self) -> str:
        """æ“ä½œ"""
        pass
    
    @abstractmethod
    def add(self, component: 'Component') -> None:
        """æ·»åŠ å­ç»„ä»¶"""
        pass
    
    @abstractmethod
    def remove(self, component: 'Component') -> None:
        """ç§»é™¤å­ç»„ä»¶"""
        pass
    
    @abstractmethod
    def get_child(self, index: int) -> Optional['Component']:
        """è·å–å­ç»„ä»¶"""
        pass

class Leaf(Component):
    """å¶å­èŠ‚ç‚¹"""
    
    def operation(self) -> str:
        return f"Leaf {self.name} operation"
    
    def add(self, component: Component) -> None:
        raise NotImplementedError("Leaf cannot add children")
    
    def remove(self, component: Component) -> None:
        raise NotImplementedError("Leaf cannot remove children")
    
    def get_child(self, index: int) -> Optional[Component]:
        return None

class Composite(Component):
    """ç»„åˆèŠ‚ç‚¹"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.children: List[Component] = []
    
    def operation(self) -> str:
        results = [f"Composite {self.name} operation"]
        for child in self.children:
            results.append(f"  {child.operation()}")
        return "\n".join(results)
    
    def add(self, component: Component) -> None:
        self.children.append(component)
    
    def remove(self, component: Component) -> None:
        if component in self.children:
            self.children.remove(component)
    
    def get_child(self, index: int) -> Optional[Component]:
        if 0 <= index < len(self.children):
            return self.children[index]
        return None

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_composite():
    """æ¼”ç¤ºç»„åˆæ¨¡å¼"""
    print("\nç»„åˆæ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºå¶å­èŠ‚ç‚¹
    leaf1 = Leaf("Leaf1")
    leaf2 = Leaf("Leaf2")
    leaf3 = Leaf("Leaf3")
    
    # åˆ›å»ºç»„åˆèŠ‚ç‚¹
    composite1 = Composite("Composite1")
    composite2 = Composite("Composite2")
    root = Composite("Root")
    
    # æ„å»ºæ ‘å½¢ç»“æ„
    composite1.add(leaf1)
    composite1.add(leaf2)
    composite2.add(leaf3)
    root.add(composite1)
    root.add(composite2)
    
    # æ‰§è¡Œæ“ä½œ
    print("ç»„åˆç»“æ„æ“ä½œ:")
    print(root.operation())
    
    return root

# è¿è¡Œæ¼”ç¤º
composite_root = demonstrate_composite()
```

### 5. è£…é¥°å™¨æ¨¡å¼ (Decorator)

#### 5.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
è£…é¥°å™¨æ¨¡å¼åŠ¨æ€æ·»åŠ èŒè´£ï¼š
$$\text{Decorator}: C \times D \rightarrow C'$$

å…¶ä¸­ $C$ æ˜¯ç»„ä»¶ï¼Œ$D$ æ˜¯è£…é¥°å™¨ï¼Œ$C'$ æ˜¯è£…é¥°åçš„ç»„ä»¶ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import Any

class Component(ABC):
    """ç»„ä»¶æ¥å£"""
    
    @abstractmethod
    def operation(self) -> str:
        """æ“ä½œ"""
        pass

class ConcreteComponent(Component):
    """å…·ä½“ç»„ä»¶"""
    
    def operation(self) -> str:
        return "ConcreteComponent operation"

class Decorator(Component):
    """è£…é¥°å™¨åŸºç±»"""
    
    def __init__(self, component: Component):
        self.component = component
    
    def operation(self) -> str:
        return self.component.operation()

class ConcreteDecoratorA(Decorator):
    """å…·ä½“è£…é¥°å™¨A"""
    
    def operation(self) -> str:
        return f"ConcreteDecoratorA({super().operation()})"

class ConcreteDecoratorB(Decorator):
    """å…·ä½“è£…é¥°å™¨B"""
    
    def operation(self) -> str:
        return f"ConcreteDecoratorB({super().operation()})"

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_decorator():
    """æ¼”ç¤ºè£…é¥°å™¨æ¨¡å¼"""
    print("\nè£…é¥°å™¨æ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºç»„ä»¶
    component = ConcreteComponent()
    print(f"åŸå§‹ç»„ä»¶: {component.operation()}")
    
    # æ·»åŠ è£…é¥°å™¨A
    decorated_a = ConcreteDecoratorA(component)
    print(f"è£…é¥°å™¨A: {decorated_a.operation()}")
    
    # æ·»åŠ è£…é¥°å™¨B
    decorated_b = ConcreteDecoratorB(decorated_a)
    print(f"è£…é¥°å™¨B: {decorated_b.operation()}")
    
    # å¤šå±‚è£…é¥°
    multi_decorated = ConcreteDecoratorA(ConcreteDecoratorB(component))
    print(f"å¤šå±‚è£…é¥°: {multi_decorated.operation()}")
    
    return component, decorated_a, decorated_b

# è¿è¡Œæ¼”ç¤º
component, decorated_a, decorated_b = demonstrate_decorator()
```

### 6. å¤–è§‚æ¨¡å¼ (Facade)

#### 6.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å¤–è§‚æ¨¡å¼ä¸ºå­ç³»ç»Ÿæä¾›ç»Ÿä¸€æ¥å£ï¼š
$$\text{Facade}: S_1 \times S_2 \times \cdots \times S_n \rightarrow I$$

å…¶ä¸­ $S_i$ æ˜¯å­ç³»ç»Ÿï¼Œ$I$ æ˜¯ç»Ÿä¸€æ¥å£ã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import List

class SubsystemA:
    """å­ç³»ç»ŸA"""
    
    def operation_a1(self) -> str:
        return "SubsystemA operation1"
    
    def operation_a2(self) -> str:
        return "SubsystemA operation2"

class SubsystemB:
    """å­ç³»ç»ŸB"""
    
    def operation_b1(self) -> str:
        return "SubsystemB operation1"
    
    def operation_b2(self) -> str:
        return "SubsystemB operation2"

class SubsystemC:
    """å­ç³»ç»ŸC"""
    
    def operation_c1(self) -> str:
        return "SubsystemC operation1"
    
    def operation_c2(self) -> str:
        return "SubsystemC operation2"

class Facade:
    """å¤–è§‚ç±»"""
    
    def __init__(self, subsystems: List[Any]):
        self.subsystem_a = subsystems[0] if len(subsystems) > 0 else SubsystemA()
        self.subsystem_b = subsystems[1] if len(subsystems) > 1 else SubsystemB()
        self.subsystem_c = subsystems[2] if len(subsystems) > 2 else SubsystemC()
    
    def operation1(self) -> str:
        """æ“ä½œ1"""
        results = []
        results.append(self.subsystem_a.operation_a1())
        results.append(self.subsystem_b.operation_b1())
        return " + ".join(results)
    
    def operation2(self) -> str:
        """æ“ä½œ2"""
        results = []
        results.append(self.subsystem_b.operation_b2())
        results.append(self.subsystem_c.operation_c1())
        return " + ".join(results)
    
    def operation3(self) -> str:
        """æ“ä½œ3"""
        results = []
        results.append(self.subsystem_a.operation_a2())
        results.append(self.subsystem_c.operation_c2())
        return " + ".join(results)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_facade():
    """æ¼”ç¤ºå¤–è§‚æ¨¡å¼"""
    print("\nå¤–è§‚æ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºå­ç³»ç»Ÿ
    subsystem_a = SubsystemA()
    subsystem_b = SubsystemB()
    subsystem_c = SubsystemC()
    
    # åˆ›å»ºå¤–è§‚
    facade = Facade([subsystem_a, subsystem_b, subsystem_c])
    
    # ä½¿ç”¨å¤–è§‚
    print(f"æ“ä½œ1: {facade.operation1()}")
    print(f"æ“ä½œ2: {facade.operation2()}")
    print(f"æ“ä½œ3: {facade.operation3()}")
    
    return facade

# è¿è¡Œæ¼”ç¤º
facade = demonstrate_facade()
```

### 7. äº«å…ƒæ¨¡å¼ (Flyweight)

#### 7.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
äº«å…ƒæ¨¡å¼å…±äº«å¯¹è±¡ä»¥å‡å°‘å†…å­˜ä½¿ç”¨ï¼š
$$\text{Flyweight}: S \times I \rightarrow O$$

å…¶ä¸­ $S$ æ˜¯å…±äº«çŠ¶æ€ï¼Œ$I$ æ˜¯å†…éƒ¨çŠ¶æ€ï¼Œ$O$ æ˜¯äº«å…ƒå¯¹è±¡ã€‚

**Pythonå®ç°**ï¼š

```python
from typing import Dict, Any
from dataclasses import dataclass

@dataclass
class Flyweight:
    """äº«å…ƒç±»"""
    shared_state: str
    
    def operation(self, unique_state: str) -> str:
        """æ“ä½œ"""
        return f"Flyweight: shared={self.shared_state}, unique={unique_state}"

class FlyweightFactory:
    """äº«å…ƒå·¥å‚"""
    
    def __init__(self):
        self.flyweights: Dict[str, Flyweight] = {}
    
    def get_flyweight(self, shared_state: str) -> Flyweight:
        """è·å–äº«å…ƒ"""
        if shared_state not in self.flyweights:
            self.flyweights[shared_state] = Flyweight(shared_state)
        return self.flyweights[shared_state]
    
    def list_flyweights(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰äº«å…ƒ"""
        return list(self.flyweights.keys())

class Context:
    """ä¸Šä¸‹æ–‡"""
    
    def __init__(self, flyweight: Flyweight, unique_state: str):
        self.flyweight = flyweight
        self.unique_state = unique_state
    
    def operation(self) -> str:
        """æ“ä½œ"""
        return self.flyweight.operation(self.unique_state)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_flyweight():
    """æ¼”ç¤ºäº«å…ƒæ¨¡å¼"""
    print("\näº«å…ƒæ¨¡å¼æ¼”ç¤º:")
    
    # åˆ›å»ºäº«å…ƒå·¥å‚
    factory = FlyweightFactory()
    
    # åˆ›å»ºä¸Šä¸‹æ–‡
    contexts = []
    
    # ä½¿ç”¨ç›¸åŒå…±äº«çŠ¶æ€çš„å¤šä¸ªä¸Šä¸‹æ–‡
    shared_states = ["A", "B", "A", "B", "A"]
    unique_states = ["1", "2", "3", "4", "5"]
    
    for shared, unique in zip(shared_states, unique_states):
        flyweight = factory.get_flyweight(shared)
        context = Context(flyweight, unique)
        contexts.append(context)
    
    # æ‰§è¡Œæ“ä½œ
    for context in contexts:
        print(f"ä¸Šä¸‹æ–‡æ“ä½œ: {context.operation()}")
    
    # æ˜¾ç¤ºäº«å…ƒæ•°é‡
    print(f"åˆ›å»ºçš„äº«å…ƒæ•°é‡: {len(factory.list_flyweights())}")
    print(f"äº«å…ƒåˆ—è¡¨: {factory.list_flyweights()}")
    
    return factory, contexts

# è¿è¡Œæ¼”ç¤º
flyweight_factory, contexts = demonstrate_flyweight()
```

### 8. ä»£ç†æ¨¡å¼ (Proxy)

#### 8.1 å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
ä»£ç†æ¨¡å¼æ§åˆ¶å¯¹å¯¹è±¡çš„è®¿é—®ï¼š
$$\text{Proxy}: R \times C \rightarrow A$$

å…¶ä¸­ $R$ æ˜¯çœŸå®å¯¹è±¡ï¼Œ$C$ æ˜¯æ§åˆ¶æ¡ä»¶ï¼Œ$A$ æ˜¯è®¿é—®ç»“æœã€‚

**Pythonå®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import Optional
import time

class Subject(ABC):
    """ä¸»é¢˜æ¥å£"""
    
    @abstractmethod
    def request(self) -> str:
        """è¯·æ±‚æ–¹æ³•"""
        pass

class RealSubject(Subject):
    """çœŸå®ä¸»é¢˜"""
    
    def request(self) -> str:
        return "RealSubject request"

class Proxy(Subject):
    """ä»£ç†ç±»"""
    
    def __init__(self, real_subject: RealSubject):
        self.real_subject = real_subject
        self.access_count = 0
        self.last_access_time = None
    
    def request(self) -> str:
        """ä»£ç†è¯·æ±‚"""
        # è®¿é—®æ§åˆ¶
        if not self._check_access():
            return "Access denied"
        
        # å»¶è¿ŸåŠ è½½
        if self.real_subject is None:
            self.real_subject = RealSubject()
        
        # è®°å½•è®¿é—®
        self.access_count += 1
        self.last_access_time = time.time()
        
        # è½¬å‘è¯·æ±‚
        return f"Proxy: {self.real_subject.request()}"
    
    def _check_access(self) -> bool:
        """æ£€æŸ¥è®¿é—®æƒé™"""
        # ç®€åŒ–çš„è®¿é—®æ§åˆ¶é€»è¾‘
        return self.access_count < 5  # æœ€å¤šå…è®¸5æ¬¡è®¿é—®
    
    def get_access_info(self) -> Dict[str, Any]:
        """è·å–è®¿é—®ä¿¡æ¯"""
        return {
            "access_count": self.access_count,
            "last_access_time": self.last_access_time,
            "has_access": self._check_access()
        }

class VirtualProxy(Subject):
    """è™šæ‹Ÿä»£ç†"""
    
    def __init__(self):
        self.real_subject: Optional[RealSubject] = None
    
    def request(self) -> str:
        """è™šæ‹Ÿä»£ç†è¯·æ±‚"""
        if self.real_subject is None:
            print("Creating RealSubject...")
            self.real_subject = RealSubject()
        
        return f"VirtualProxy: {self.real_subject.request()}"

class ProtectionProxy(Subject):
    """ä¿æŠ¤ä»£ç†"""
    
    def __init__(self, real_subject: RealSubject, password: str):
        self.real_subject = real_subject
        self.password = password
        self.authenticated = False
    
    def authenticate(self, password: str) -> bool:
        """è®¤è¯"""
        self.authenticated = (password == self.password)
        return self.authenticated
    
    def request(self) -> str:
        """ä¿æŠ¤ä»£ç†è¯·æ±‚"""
        if not self.authenticated:
            return "Authentication required"
        
        return f"ProtectionProxy: {self.real_subject.request()}"

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_proxy():
    """æ¼”ç¤ºä»£ç†æ¨¡å¼"""
    print("\nä»£ç†æ¨¡å¼æ¼”ç¤º:")
    
    # æ™®é€šä»£ç†
    real_subject = RealSubject()
    proxy = Proxy(real_subject)
    
    print("æ™®é€šä»£ç†:")
    for i in range(7):
        result = proxy.request()
        print(f"  è¯·æ±‚ {i+1}: {result}")
        if i == 4:
            print(f"  è®¿é—®ä¿¡æ¯: {proxy.get_access_info()}")
    
    # è™šæ‹Ÿä»£ç†
    virtual_proxy = VirtualProxy()
    print(f"\nè™šæ‹Ÿä»£ç†: {virtual_proxy.request()}")
    print(f"è™šæ‹Ÿä»£ç†: {virtual_proxy.request()}")
    
    # ä¿æŠ¤ä»£ç†
    protection_proxy = ProtectionProxy(real_subject, "secret123")
    print(f"\nä¿æŠ¤ä»£ç† (æœªè®¤è¯): {protection_proxy.request()}")
    
    protection_proxy.authenticate("wrong_password")
    print(f"ä¿æŠ¤ä»£ç† (é”™è¯¯å¯†ç ): {protection_proxy.request()}")
    
    protection_proxy.authenticate("secret123")
    print(f"ä¿æŠ¤ä»£ç† (æ­£ç¡®å¯†ç ): {protection_proxy.request()}")
    
    return proxy, virtual_proxy, protection_proxy

# è¿è¡Œæ¼”ç¤º
proxy, virtual_proxy, protection_proxy = demonstrate_proxy()
```

## ğŸ“Š æ¨¡å¼æ¯”è¾ƒåˆ†æ

```python
class StructuralPatternAnalyzer:
    """ç»“æ„å‹æ¨¡å¼åˆ†æå™¨"""
    
    def __init__(self):
        self.framework = StructuralPatternFramework()
    
    def compare_patterns(self) -> Dict[str, Dict[str, Any]]:
        """æ¯”è¾ƒæ‰€æœ‰ç»“æ„å‹æ¨¡å¼"""
        patterns = [
            StructuralPattern.ADAPTER,
            StructuralPattern.BRIDGE,
            StructuralPattern.COMPOSITE,
            StructuralPattern.DECORATOR,
            StructuralPattern.FACADE,
            StructuralPattern.FLYWEIGHT,
            StructuralPattern.PROXY
        ]
        
        comparison = {}
        for pattern in patterns:
            comparison[pattern.value] = self.framework.analyze_pattern(pattern)
        
        return comparison
    
    def generate_comparison_report(self) -> str:
        """ç”Ÿæˆæ¯”è¾ƒæŠ¥å‘Š"""
        comparison = self.compare_patterns()
        
        report = "ç»“æ„å‹æ¨¡å¼æ¯”è¾ƒæŠ¥å‘Š:\n"
        report += "=" * 60 + "\n"
        
        for pattern_name, analysis in comparison.items():
            report += f"\n{pattern_name.upper()}:\n"
            report += f"  å¤æ‚åº¦: {analysis['complexity']}\n"
            report += f"  çµæ´»æ€§: {analysis['flexibility']}\n"
            report += f"  æ€§èƒ½: {analysis['performance']}\n"
            report += f"  ä½¿ç”¨åœºæ™¯: {', '.join(analysis['use_cases'])}\n"
        
        return report
    
    def recommend_pattern(self, requirements: Dict[str, Any]) -> str:
        """æ ¹æ®éœ€æ±‚æ¨èæ¨¡å¼"""
        recommendations = {
            "interface_adaptation": StructuralPattern.ADAPTER.value,
            "abstraction_separation": StructuralPattern.BRIDGE.value,
            "tree_structure": StructuralPattern.COMPOSITE.value,
            "dynamic_behavior": StructuralPattern.DECORATOR.value,
            "subsystem_simplification": StructuralPattern.FACADE.value,
            "memory_optimization": StructuralPattern.FLYWEIGHT.value,
            "access_control": StructuralPattern.PROXY.value
        }
        
        for requirement, pattern in recommendations.items():
            if requirement in requirements and requirements[requirement]:
                return pattern
        
        return StructuralPattern.ADAPTER.value  # é»˜è®¤æ¨è

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_pattern_analysis():
    """æ¼”ç¤ºæ¨¡å¼åˆ†æ"""
    analyzer = StructuralPatternAnalyzer()
    
    # ç”Ÿæˆæ¯”è¾ƒæŠ¥å‘Š
    report = analyzer.generate_comparison_report()
    print(report)
    
    # æ¨èæ¨¡å¼
    requirements = {
        "interface_adaptation": True,
        "abstraction_separation": False,
        "tree_structure": False,
        "dynamic_behavior": False,
        "subsystem_simplification": False,
        "memory_optimization": False,
        "access_control": False
    }
    
    recommended = analyzer.recommend_pattern(requirements)
    print(f"\næ ¹æ®éœ€æ±‚æ¨èæ¨¡å¼: {recommended}")
    
    return analyzer

# è¿è¡Œåˆ†æ
structural_analyzer = demonstrate_pattern_analysis()
```

## ğŸ“ æ€»ç»“

ç»“æ„å‹æ¨¡å¼æä¾›äº†çµæ´»çš„å¯¹è±¡ç»„åˆæœºåˆ¶ï¼š

1. **é€‚é…å™¨æ¨¡å¼**: å°†ä¸€ä¸ªæ¥å£è½¬æ¢ä¸ºå¦ä¸€ä¸ªæ¥å£
2. **æ¡¥æ¥æ¨¡å¼**: å°†æŠ½è±¡ä¸å®ç°åˆ†ç¦»
3. **ç»„åˆæ¨¡å¼**: æ„å»ºæ ‘å½¢ç»“æ„
4. **è£…é¥°å™¨æ¨¡å¼**: åŠ¨æ€æ·»åŠ èŒè´£
5. **å¤–è§‚æ¨¡å¼**: ä¸ºå­ç³»ç»Ÿæä¾›ç»Ÿä¸€æ¥å£
6. **äº«å…ƒæ¨¡å¼**: å…±äº«å¯¹è±¡ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
7. **ä»£ç†æ¨¡å¼**: æ§åˆ¶å¯¹å¯¹è±¡çš„è®¿é—®

æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„åº”ç”¨åœºæ™¯å’Œä¼˜åŠ¿ï¼Œé€‰æ‹©åˆé€‚çš„æ¨¡å¼éœ€è¦è€ƒè™‘ç³»ç»Ÿçš„å¤æ‚åº¦ã€æ€§èƒ½è¦æ±‚å’Œç»´æŠ¤æ€§ç­‰å› ç´ ã€‚

## ğŸ”— ç›¸å…³é“¾æ¥

- [åˆ›å»ºå‹æ¨¡å¼](03.01.01-åˆ›å»ºå‹æ¨¡å¼.md)
- [è¡Œä¸ºå‹æ¨¡å¼](03.01.03-è¡Œä¸ºå‹æ¨¡å¼.md)
- [è®¾è®¡åŸåˆ™](00-ç†å¿µåŸºç¡€/00.01-ç¼–ç¨‹å“²å­¦/00.01.02-è®¾è®¡åŸåˆ™.md)
- [è½¯ä»¶æ¶æ„](03-å…·ä½“ç§‘å­¦/03.02-è½¯ä»¶æ¶æ„/README.md) 