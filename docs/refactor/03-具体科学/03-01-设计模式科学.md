# 03-01-设计模式科学

## 概述

设计模式科学是软件工程中的具体科学，研究软件设计中常见问题的标准化解决方案。本文档建立完整的设计模式科学体系，包括理论基础、分类和实现方法。

## 1. 设计模式基础

### 1.1 设计模式的定义

**设计模式** (Design Pattern) 是对软件设计中常见问题的典型解决方案的描述。

#### 1.1.1 设计模式的特征

1. **可重用性**: 可以在不同场景中重复使用
2. **可维护性**: 提高代码的可维护性
3. **可扩展性**: 支持系统的扩展
4. **可理解性**: 提供清晰的解决方案

#### 1.1.2 Python实现

```python
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass
from abc import ABC, abstractmethod
from enum import Enum

class PatternType(Enum):
    """设计模式类型"""
    CREATIONAL = "创建型"
    STRUCTURAL = "结构型"
    BEHAVIORAL = "行为型"

@dataclass
class PatternSpecification:
    """设计模式规格说明"""
    name: str
    type: PatternType
    intent: str
    problem: str
    solution: str
    consequences: List[str]
    participants: List[str]

class DesignPattern(ABC):
    """设计模式抽象基类"""
    
    def __init__(self, spec: PatternSpecification):
        self.spec = spec
        self.implementation = None
    
    @abstractmethod
    def implement(self) -> Any:
        """实现设计模式"""
        pass
    
    def get_specification(self) -> PatternSpecification:
        """获取模式规格"""
        return self.spec
    
    def apply_pattern(self, context: Dict[str, Any]) -> Any:
        """应用设计模式"""
        return self.implement()

# 使用示例
def test_design_pattern_base():
    """测试设计模式基础"""
    spec = PatternSpecification(
        name="单例模式",
        type=PatternType.CREATIONAL,
        intent="确保一个类只有一个实例",
        problem="如何确保一个类只有一个实例？",
        solution="提供一个全局访问点",
        consequences=["控制实例数量", "全局访问点"],
        participants=["Singleton类"]
    )
    
    print(f"设计模式规格: {spec}")

if __name__ == "__main__":
    test_design_pattern_base()
```

### 1.2 设计模式分类

#### 1.2.1 创建型模式

```python
class CreationalPatterns:
    """创建型模式"""
    
    class Singleton:
        """单例模式"""
        
        _instance = None
        _lock = None
        
        def __new__(cls):
            if cls._instance is None:
                cls._instance = super().__new__(cls)
            return cls._instance
        
        def __init__(self):
            if not hasattr(self, 'initialized'):
                self.data = {}
                self.initialized = True
        
        def set_data(self, key: str, value: Any):
            """设置数据"""
            self.data[key] = value
        
        def get_data(self, key: str) -> Any:
            """获取数据"""
            return self.data.get(key)
    
    class FactoryMethod:
        """工厂方法模式"""
        
        @abstractmethod
        def create_product(self) -> 'Product':
            """创建产品"""
            pass
    
    class AbstractFactory:
        """抽象工厂模式"""
        
        @abstractmethod
        def create_product_a(self) -> 'ProductA':
            """创建产品A"""
            pass
        
        @abstractmethod
        def create_product_b(self) -> 'ProductB':
            """创建产品B"""
            pass
    
    class Builder:
        """建造者模式"""
        
        def __init__(self):
            self.product = {}
        
        def build_part_a(self, part_a: Any):
            """构建部件A"""
            self.product['part_a'] = part_a
            return self
        
        def build_part_b(self, part_b: Any):
            """构建部件B"""
            self.product['part_b'] = part_b
            return self
        
        def build(self) -> Dict[str, Any]:
            """构建产品"""
            return self.product.copy()
    
    class Prototype:
        """原型模式"""
        
        def __init__(self, data: Dict[str, Any]):
            self.data = data.copy()
        
        def clone(self) -> 'Prototype':
            """克隆对象"""
            return Prototype(self.data.copy())
        
        def get_data(self) -> Dict[str, Any]:
            """获取数据"""
            return self.data.copy()

# 使用示例
def test_creational_patterns():
    """测试创建型模式"""
    
    # 单例模式
    singleton1 = CreationalPatterns.Singleton()
    singleton2 = CreationalPatterns.Singleton()
    print(f"单例模式测试: {singleton1 is singleton2}")
    
    # 建造者模式
    builder = CreationalPatterns.Builder()
    product = builder.build_part_a("部件A").build_part_b("部件B").build()
    print(f"建造者模式结果: {product}")
    
    # 原型模式
    original = CreationalPatterns.Prototype({"name": "原始对象"})
    clone = original.clone()
    print(f"原型模式测试: {original.get_data() == clone.get_data()}")

if __name__ == "__main__":
    test_creational_patterns()
```

#### 1.2.2 结构型模式

```python
class StructuralPatterns:
    """结构型模式"""
    
    class Adapter:
        """适配器模式"""
        
        def __init__(self, adaptee: Any):
            self.adaptee = adaptee
        
        def request(self) -> str:
            """适配请求"""
            return f"适配后的: {self.adaptee.specific_request()}"
    
    class Bridge:
        """桥接模式"""
        
        def __init__(self, implementation: 'Implementation'):
            self.implementation = implementation
        
        def operation(self) -> str:
            """操作"""
            return self.implementation.operation_impl()
    
    class Composite:
        """组合模式"""
        
        def __init__(self, name: str):
            self.name = name
            self.children: List['Composite'] = []
        
        def add(self, component: 'Composite'):
            """添加子组件"""
            self.children.append(component)
        
        def remove(self, component: 'Composite'):
            """移除子组件"""
            self.children.remove(component)
        
        def operation(self) -> str:
            """操作"""
            result = [f"组合: {self.name}"]
            for child in self.children:
                result.append(child.operation())
            return "\n".join(result)
    
    class Decorator:
        """装饰器模式"""
        
        def __init__(self, component: 'Component'):
            self.component = component
        
        def operation(self) -> str:
            """操作"""
            return f"装饰后的: {self.component.operation()}"
    
    class Facade:
        """外观模式"""
        
        def __init__(self):
            self.subsystem_a = SubsystemA()
            self.subsystem_b = SubsystemB()
        
        def operation(self) -> str:
            """简化操作"""
            return f"{self.subsystem_a.operation_a()} + {self.subsystem_b.operation_b()}"
    
    class Flyweight:
        """享元模式"""
        
        def __init__(self):
            self.flyweights: Dict[str, Any] = {}
        
        def get_flyweight(self, key: str) -> Any:
            """获取享元对象"""
            if key not in self.flyweights:
                self.flyweights[key] = FlyweightObject(key)
            return self.flyweights[key]
    
    class Proxy:
        """代理模式"""
        
        def __init__(self, real_subject: 'RealSubject'):
            self.real_subject = real_subject
        
        def request(self) -> str:
            """代理请求"""
            return f"代理: {self.real_subject.request()}"

class SubsystemA:
    def operation_a(self) -> str:
        return "子系统A操作"

class SubsystemB:
    def operation_b(self) -> str:
        return "子系统B操作"

class FlyweightObject:
    def __init__(self, key: str):
        self.key = key
    
    def operation(self) -> str:
        return f"享元对象: {self.key}"

# 使用示例
def test_structural_patterns():
    """测试结构型模式"""
    
    # 适配器模式
    class OldSystem:
        def specific_request(self) -> str:
            return "旧系统请求"
    
    adapter = StructuralPatterns.Adapter(OldSystem())
    print(f"适配器模式: {adapter.request()}")
    
    # 组合模式
    root = StructuralPatterns.Composite("根")
    leaf1 = StructuralPatterns.Composite("叶子1")
    leaf2 = StructuralPatterns.Composite("叶子2")
    root.add(leaf1)
    root.add(leaf2)
    print(f"组合模式:\n{root.operation()}")
    
    # 装饰器模式
    class ConcreteComponent:
        def operation(self) -> str:
            return "具体组件"
    
    decorator = StructuralPatterns.Decorator(ConcreteComponent())
    print(f"装饰器模式: {decorator.operation()}")

if __name__ == "__main__":
    test_structural_patterns()
```

#### 1.2.3 行为型模式

```python
class BehavioralPatterns:
    """行为型模式"""
    
    class ChainOfResponsibility:
        """责任链模式"""
        
        def __init__(self):
            self.next_handler = None
        
        def set_next(self, handler: 'ChainOfResponsibility'):
            """设置下一个处理器"""
            self.next_handler = handler
            return handler
        
        def handle(self, request: str) -> str:
            """处理请求"""
            if self.can_handle(request):
                return self.process_request(request)
            elif self.next_handler:
                return self.next_handler.handle(request)
            else:
                return "无法处理请求"
        
        def can_handle(self, request: str) -> bool:
            """是否可以处理"""
            return False
        
        def process_request(self, request: str) -> str:
            """处理请求"""
            return "处理请求"
    
    class Command:
        """命令模式"""
        
        def __init__(self, receiver: 'Receiver'):
            self.receiver = receiver
        
        def execute(self) -> str:
            """执行命令"""
            return self.receiver.action()
    
    class Interpreter:
        """解释器模式"""
        
        def interpret(self, context: str) -> str:
            """解释上下文"""
            return f"解释: {context}"
    
    class Iterator:
        """迭代器模式"""
        
        def __init__(self, collection: List[Any]):
            self.collection = collection
            self.index = 0
        
        def has_next(self) -> bool:
            """是否有下一个"""
            return self.index < len(self.collection)
        
        def next(self) -> Any:
            """下一个元素"""
            if self.has_next():
                item = self.collection[self.index]
                self.index += 1
                return item
            raise StopIteration
    
    class Mediator:
        """中介者模式"""
        
        def __init__(self):
            self.colleagues: List['Colleague'] = []
        
        def add_colleague(self, colleague: 'Colleague'):
            """添加同事"""
            self.colleagues.append(colleague)
        
        def send_message(self, message: str, sender: 'Colleague') -> str:
            """发送消息"""
            responses = []
            for colleague in self.colleagues:
                if colleague != sender:
                    responses.append(colleague.receive_message(message))
            return "; ".join(responses)
    
    class Memento:
        """备忘录模式"""
        
        def __init__(self, state: Dict[str, Any]):
            self.state = state.copy()
        
        def get_state(self) -> Dict[str, Any]:
            """获取状态"""
            return self.state.copy()
    
    class Observer:
        """观察者模式"""
        
        def __init__(self):
            self.observers: List['Observer'] = []
        
        def attach(self, observer: 'Observer'):
            """添加观察者"""
            self.observers.append(observer)
        
        def detach(self, observer: 'Observer'):
            """移除观察者"""
            self.observers.remove(observer)
        
        def notify(self, message: str):
            """通知观察者"""
            for observer in self.observers:
                observer.update(message)
    
    class State:
        """状态模式"""
        
        def __init__(self):
            self.state = None
        
        def set_state(self, state: 'State'):
            """设置状态"""
            self.state = state
        
        def request(self) -> str:
            """请求"""
            if self.state:
                return self.state.handle()
            return "无状态"
    
    class Strategy:
        """策略模式"""
        
        def __init__(self, strategy: 'Strategy'):
            self.strategy = strategy
        
        def execute_strategy(self) -> str:
            """执行策略"""
            return self.strategy.execute()
    
    class TemplateMethod:
        """模板方法模式"""
        
        def template_method(self) -> str:
            """模板方法"""
            return f"{self.primitive_operation1()} + {self.primitive_operation2()}"
        
        def primitive_operation1(self) -> str:
            """基本操作1"""
            return "基本操作1"
        
        def primitive_operation2(self) -> str:
            """基本操作2"""
            return "基本操作2"
    
    class Visitor:
        """访问者模式"""
        
        def visit_element_a(self, element: 'ElementA') -> str:
            """访问元素A"""
            return f"访问元素A: {element.operation_a()}"
        
        def visit_element_b(self, element: 'ElementB') -> str:
            """访问元素B"""
            return f"访问元素B: {element.operation_b()}"

class Receiver:
    def action(self) -> str:
        return "接收者动作"

class Colleague:
    def __init__(self, mediator: BehavioralPatterns.Mediator):
        self.mediator = mediator
    
    def send_message(self, message: str) -> str:
        return self.mediator.send_message(message, self)
    
    def receive_message(self, message: str) -> str:
        return f"收到消息: {message}"

class ElementA:
    def operation_a(self) -> str:
        return "元素A操作"
    
    def accept(self, visitor: BehavioralPatterns.Visitor) -> str:
        return visitor.visit_element_a(self)

class ElementB:
    def operation_b(self) -> str:
        return "元素B操作"
    
    def accept(self, visitor: BehavioralPatterns.Visitor) -> str:
        return visitor.visit_element_b(self)

# 使用示例
def test_behavioral_patterns():
    """测试行为型模式"""
    
    # 迭代器模式
    collection = [1, 2, 3, 4, 5]
    iterator = BehavioralPatterns.Iterator(collection)
    items = []
    while iterator.has_next():
        items.append(iterator.next())
    print(f"迭代器模式: {items}")
    
    # 观察者模式
    subject = BehavioralPatterns.Observer()
    observer1 = type('Observer1', (), {'update': lambda self, msg: f"观察者1: {msg}"})()
    observer2 = type('Observer2', (), {'update': lambda self, msg: f"观察者2: {msg}"})()
    subject.attach(observer1)
    subject.attach(observer2)
    subject.notify("测试消息")
    
    # 策略模式
    class ConcreteStrategy:
        def execute(self) -> str:
            return "具体策略"
    
    strategy = BehavioralPatterns.Strategy(ConcreteStrategy())
    print(f"策略模式: {strategy.execute_strategy()}")

if __name__ == "__main__":
    test_behavioral_patterns()
```

## 2. 设计模式分析

### 2.1 模式关系分析

```python
class PatternAnalysis:
    """设计模式分析"""
    
    def __init__(self):
        self.pattern_relationships = {
            'Adapter': ['Target', 'Adaptee', 'Client'],
            'Bridge': ['Abstraction', 'Implementation', 'RefinedAbstraction'],
            'Composite': ['Component', 'Leaf', 'Composite'],
            'Decorator': ['Component', 'ConcreteComponent', 'Decorator'],
            'Facade': ['Facade', 'Subsystem'],
            'Flyweight': ['Flyweight', 'ConcreteFlyweight', 'FlyweightFactory'],
            'Proxy': ['Subject', 'RealSubject', 'Proxy'],
            'ChainOfResponsibility': ['Handler', 'ConcreteHandler'],
            'Command': ['Command', 'ConcreteCommand', 'Invoker', 'Receiver'],
            'Interpreter': ['AbstractExpression', 'TerminalExpression', 'Context'],
            'Iterator': ['Iterator', 'ConcreteIterator', 'Aggregate'],
            'Mediator': ['Mediator', 'Colleague'],
            'Memento': ['Originator', 'Memento', 'Caretaker'],
            'Observer': ['Subject', 'Observer'],
            'State': ['Context', 'State', 'ConcreteState'],
            'Strategy': ['Context', 'Strategy', 'ConcreteStrategy'],
            'TemplateMethod': ['AbstractClass', 'ConcreteClass'],
            'Visitor': ['Visitor', 'Element', 'ConcreteElement']
        }
    
    def analyze_pattern_structure(self, pattern_name: str) -> Dict[str, Any]:
        """分析模式结构"""
        if pattern_name not in self.pattern_relationships:
            return {}
        
        participants = self.pattern_relationships[pattern_name]
        
        return {
            'pattern_name': pattern_name,
            'participants': participants,
            'participant_count': len(participants),
            'complexity': self._calculate_complexity(participants),
            'relationships': self._analyze_relationships(participants)
        }
    
    def _calculate_complexity(self, participants: List[str]) -> str:
        """计算复杂度"""
        if len(participants) <= 2:
            return "简单"
        elif len(participants) <= 4:
            return "中等"
        else:
            return "复杂"
    
    def _analyze_relationships(self, participants: List[str]) -> Dict[str, int]:
        """分析关系"""
        return {
            'inheritance': len([p for p in participants if 'Abstract' in p or 'Base' in p]),
            'composition': len([p for p in participants if 'Component' in p or 'Part' in p]),
            'association': len(participants) - 1
        }
    
    def compare_patterns(self, pattern1: str, pattern2: str) -> Dict[str, Any]:
        """比较两个模式"""
        analysis1 = self.analyze_pattern_structure(pattern1)
        analysis2 = self.analyze_pattern_structure(pattern2)
        
        return {
            'pattern1': analysis1,
            'pattern2': analysis2,
            'similarities': self._find_similarities(analysis1, analysis2),
            'differences': self._find_differences(analysis1, analysis2)
        }
    
    def _find_similarities(self, analysis1: Dict, analysis2: Dict) -> List[str]:
        """找出相似性"""
        similarities = []
        
        if analysis1.get('complexity') == analysis2.get('complexity'):
            similarities.append(f"复杂度相同: {analysis1.get('complexity')}")
        
        if analysis1.get('participant_count') == analysis2.get('participant_count'):
            similarities.append(f"参与者数量相同: {analysis1.get('participant_count')}")
        
        return similarities
    
    def _find_differences(self, analysis1: Dict, analysis2: Dict) -> List[str]:
        """找出差异性"""
        differences = []
        
        if analysis1.get('complexity') != analysis2.get('complexity'):
            differences.append(f"复杂度不同: {analysis1.get('complexity')} vs {analysis2.get('complexity')}")
        
        if analysis1.get('participant_count') != analysis2.get('participant_count'):
            differences.append(f"参与者数量不同: {analysis1.get('participant_count')} vs {analysis2.get('participant_count')}")
        
        return differences

# 使用示例
def test_pattern_analysis():
    """测试模式分析"""
    analyzer = PatternAnalysis()
    
    # 分析模式结构
    adapter_analysis = analyzer.analyze_pattern_structure('Adapter')
    print(f"适配器模式分析: {adapter_analysis}")
    
    # 比较模式
    comparison = analyzer.compare_patterns('Adapter', 'Bridge')
    print(f"模式比较: {comparison}")

if __name__ == "__main__":
    test_pattern_analysis()
```

### 2.2 模式应用分析

```python
class PatternApplication:
    """设计模式应用分析"""
    
    def __init__(self):
        self.application_scenarios = {
            'Singleton': ['配置管理', '日志记录', '数据库连接'],
            'Factory': ['对象创建', '产品族管理', '插件系统'],
            'Observer': ['事件处理', 'GUI更新', '数据同步'],
            'Strategy': ['算法选择', '支付方式', '排序方法'],
            'Decorator': ['功能扩展', '权限控制', '缓存包装'],
            'Adapter': ['接口适配', '第三方库集成', '遗留系统改造'],
            'Facade': ['系统简化', 'API封装', '子系统集成'],
            'Command': ['撤销重做', '宏命令', '队列处理'],
            'State': ['状态管理', '工作流', '游戏状态'],
            'Template': ['算法框架', '流程模板', '代码生成']
        }
    
    def analyze_application_scenario(self, scenario: str) -> List[str]:
        """分析应用场景"""
        suitable_patterns = []
        
        for pattern, scenarios in self.application_scenarios.items():
            if scenario in scenarios:
                suitable_patterns.append(pattern)
        
        return suitable_patterns
    
    def get_pattern_scenarios(self, pattern: str) -> List[str]:
        """获取模式的应用场景"""
        return self.application_scenarios.get(pattern, [])
    
    def evaluate_pattern_suitability(self, pattern: str, requirements: List[str]) -> float:
        """评估模式适用性"""
        if pattern not in self.application_scenarios:
            return 0.0
        
        scenarios = self.application_scenarios[pattern]
        matches = sum(1 for req in requirements if req in scenarios)
        
        return matches / len(requirements) if requirements else 0.0
    
    def recommend_patterns(self, requirements: List[str]) -> List[tuple]:
        """推荐设计模式"""
        recommendations = []
        
        for pattern in self.application_scenarios.keys():
            suitability = self.evaluate_pattern_suitability(pattern, requirements)
            if suitability > 0:
                recommendations.append((pattern, suitability))
        
        # 按适用性排序
        recommendations.sort(key=lambda x: x[1], reverse=True)
        return recommendations

# 使用示例
def test_pattern_application():
    """测试模式应用分析"""
    app_analyzer = PatternApplication()
    
    # 分析应用场景
    scenario = "配置管理"
    patterns = app_analyzer.analyze_application_scenario(scenario)
    print(f"场景 '{scenario}' 适用的模式: {patterns}")
    
    # 获取模式场景
    pattern = "Observer"
    scenarios = app_analyzer.get_pattern_scenarios(pattern)
    print(f"模式 '{pattern}' 的应用场景: {scenarios}")
    
    # 推荐模式
    requirements = ["事件处理", "数据同步", "功能扩展"]
    recommendations = app_analyzer.recommend_patterns(requirements)
    print(f"需求 {requirements} 的模式推荐: {recommendations}")

if __name__ == "__main__":
    test_pattern_application()
```

## 3. 设计模式实现

### 3.1 模式实现框架

```python
class PatternImplementationFramework:
    """设计模式实现框架"""
    
    def __init__(self):
        self.patterns: Dict[str, DesignPattern] = {}
        self.implementations: Dict[str, Any] = {}
    
    def register_pattern(self, pattern: DesignPattern):
        """注册设计模式"""
        self.patterns[pattern.spec.name] = pattern
    
    def implement_pattern(self, pattern_name: str, context: Dict[str, Any]) -> Any:
        """实现设计模式"""
        if pattern_name not in self.patterns:
            raise ValueError(f"模式 {pattern_name} 未注册")
        
        pattern = self.patterns[pattern_name]
        implementation = pattern.apply_pattern(context)
        self.implementations[pattern_name] = implementation
        
        return implementation
    
    def get_implementation(self, pattern_name: str) -> Any:
        """获取实现"""
        return self.implementations.get(pattern_name)
    
    def list_patterns(self) -> List[str]:
        """列出所有模式"""
        return list(self.patterns.keys())
    
    def get_pattern_info(self, pattern_name: str) -> Optional[PatternSpecification]:
        """获取模式信息"""
        if pattern_name in self.patterns:
            return self.patterns[pattern_name].get_specification()
        return None

# 使用示例
def test_pattern_implementation_framework():
    """测试模式实现框架"""
    framework = PatternImplementationFramework()
    
    # 注册模式
    singleton_spec = PatternSpecification(
        name="Singleton",
        type=PatternType.CREATIONAL,
        intent="确保一个类只有一个实例",
        problem="如何确保一个类只有一个实例？",
        solution="提供一个全局访问点",
        consequences=["控制实例数量", "全局访问点"],
        participants=["Singleton类"]
    )
    
    class SingletonPattern(DesignPattern):
        def implement(self):
            return CreationalPatterns.Singleton()
    
    singleton_pattern = SingletonPattern(singleton_spec)
    framework.register_pattern(singleton_pattern)
    
    # 实现模式
    context = {"data": "test"}
    implementation = framework.implement_pattern("Singleton", context)
    print(f"模式实现: {implementation}")
    
    # 获取模式信息
    info = framework.get_pattern_info("Singleton")
    print(f"模式信息: {info}")

if __name__ == "__main__":
    test_pattern_implementation_framework()
```

## 4. 总结

设计模式科学为软件工程提供了系统性的设计解决方案，包括：

1. **创建型模式**: 解决对象创建问题
2. **结构型模式**: 解决对象组合问题
3. **行为型模式**: 解决对象交互问题

这些模式相互关联，共同构成了现代软件设计的科学基础，为后续的架构领域层提供了设计支撑。

## 相关链接

- [00-01-编程哲学](../00-理念基础/00-01-编程哲学.md)
- [02-01-算法理论](../02-理论基础/02-01-算法理论.md)
- [05-01-微服务架构](../05-架构领域/05-01-微服务架构.md)
- [06-03-设计模式实现](../06-组件算法/06-03-设计模式实现.md)
