# 03-02-01 æ¶æ„åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

è½¯ä»¶æ¶æ„æ˜¯è½¯ä»¶ç³»ç»Ÿçš„ç»“æ„è“å›¾ï¼Œå®šä¹‰äº†ç³»ç»Ÿçš„ä¸»è¦ç»„ä»¶ã€å®ƒä»¬ä¹‹é—´çš„å…³ç³»ä»¥åŠè®¾è®¡åŸåˆ™ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°è½¯ä»¶æ¶æ„çš„æ ¸å¿ƒæ¦‚å¿µï¼Œæä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜ï¼Œå¹¶é€šè¿‡Pythonä»£ç å®ç°ç›¸å…³æ¶æ„æ¨¡å¼ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æ¶æ„å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (è½¯ä»¶æ¶æ„)
è½¯ä»¶æ¶æ„æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$A = (C, R, P)$$
å…¶ä¸­ï¼š
- $C$ æ˜¯ç»„ä»¶é›†åˆ
- $R$ æ˜¯å…³ç³»é›†åˆ
- $P$ æ˜¯å±æ€§é›†åˆ

**å®šä¹‰ 1.2** (ç»„ä»¶)
ç»„ä»¶æ˜¯æ¶æ„çš„åŸºæœ¬æ„å»ºå—ï¼š
$$c \in C \Rightarrow c = (id, interface, implementation)$$
å…¶ä¸­ $id$ æ˜¯ç»„ä»¶æ ‡è¯†ç¬¦ï¼Œ$interface$ æ˜¯æ¥å£å®šä¹‰ï¼Œ$implementation$ æ˜¯å®ç°ã€‚

**å®šä¹‰ 1.3** (å…³ç³»)
å…³ç³»å®šä¹‰ç»„ä»¶é—´çš„è¿æ¥ï¼š
$$r \in R \Rightarrow r = (source, target, type, properties)$$
å…¶ä¸­ $source$ å’Œ $target$ æ˜¯æºå’Œç›®æ ‡ç»„ä»¶ï¼Œ$type$ æ˜¯å…³ç³»ç±»å‹ï¼Œ$properties$ æ˜¯å…³ç³»å±æ€§ã€‚

#### 1.2 æ¶æ„å±æ€§å®šç†

**å®šç† 1.1** (æ¶æ„å®Œæ•´æ€§)
å¦‚æœæ¶æ„ $A = (C, R, P)$ æ˜¯å®Œæ•´çš„ï¼Œåˆ™æ‰€æœ‰ç»„ä»¶éƒ½é€šè¿‡å…³ç³»è¿æ¥ã€‚

**è¯æ˜**:
1. è®¾ $A = (C, R, P)$ æ˜¯å®Œæ•´æ¶æ„
2. å¯¹äºä»»æ„ç»„ä»¶ $c \in C$ï¼Œå­˜åœ¨å…³ç³» $r \in R$ è¿æ¥ $c$
3. å› æ­¤æ‰€æœ‰ç»„ä»¶éƒ½é€šè¿‡å…³ç³»è¿æ¥

### 2. åˆ†å±‚æ¶æ„

#### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1** (åˆ†å±‚æ¶æ„)
åˆ†å±‚æ¶æ„æ˜¯ä¸€ä¸ªæœ‰åºçš„ç»„ä»¶é›†åˆï¼š
$$L = \{L_1, L_2, ..., L_n\}$$
å…¶ä¸­ $L_i$ æ˜¯ç¬¬ $i$ å±‚ï¼Œæ»¡è¶³ï¼š
$$\forall i < j: L_i \text{ ä¾èµ– } L_j$$

**å®šä¹‰ 2.2** (å±‚ä¾èµ–)
å±‚ä¾èµ–å…³ç³»æ»¡è¶³ä¼ é€’æ€§ï¼š
$$\forall i < j < k: L_i \text{ ä¾èµ– } L_j \land L_j \text{ ä¾èµ– } L_k \Rightarrow L_i \text{ ä¾èµ– } L_k$$

#### 2.2 åˆ†å±‚æ¶æ„å®šç†

**å®šç† 2.1** (åˆ†å±‚æ— ç¯æ€§)
åˆ†å±‚æ¶æ„ä¸­ä¸å­˜åœ¨å¾ªç¯ä¾èµ–ã€‚

**è¯æ˜**:
1. å‡è®¾å­˜åœ¨å¾ªç¯ä¾èµ–ï¼š$L_i \rightarrow L_j \rightarrow ... \rightarrow L_i$
2. æ ¹æ®ä¾èµ–å®šä¹‰ï¼Œ$i < j < ... < i$
3. è¿™ä¸ $i < i$ çŸ›ç›¾
4. å› æ­¤ä¸å­˜åœ¨å¾ªç¯ä¾èµ–

### 3. å¾®æœåŠ¡æ¶æ„

#### 3.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 3.1** (å¾®æœåŠ¡)
å¾®æœåŠ¡æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„æœåŠ¡å•å…ƒï¼š
$$S = (id, api, data, dependencies)$$
å…¶ä¸­ $id$ æ˜¯æœåŠ¡æ ‡è¯†ç¬¦ï¼Œ$api$ æ˜¯APIæ¥å£ï¼Œ$data$ æ˜¯æ•°æ®æ¨¡å‹ï¼Œ$dependencies$ æ˜¯ä¾èµ–æœåŠ¡ã€‚

**å®šä¹‰ 3.2** (å¾®æœåŠ¡æ¶æ„)
å¾®æœåŠ¡æ¶æ„æ˜¯å¾®æœåŠ¡çš„é›†åˆï¼š
$$MSA = \{S_1, S_2, ..., S_n\}$$
æ»¡è¶³ï¼š
$$\forall S_i, S_j \in MSA: S_i \text{ å’Œ } S_j \text{ ç‹¬ç«‹éƒ¨ç½²}$$

#### 3.2 å¾®æœåŠ¡æ¶æ„å®šç†

**å®šç† 3.1** (å¾®æœåŠ¡ç‹¬ç«‹æ€§)
å¾®æœåŠ¡æ¶æ„ä¸­çš„æœåŠ¡å¯ä»¥ç‹¬ç«‹éƒ¨ç½²å’Œæ‰©å±•ã€‚

**è¯æ˜**:
1. è®¾ $S_i$ æ˜¯ä»»æ„å¾®æœåŠ¡
2. æ ¹æ®å¾®æœåŠ¡å®šä¹‰ï¼Œ$S_i$ æœ‰ç‹¬ç«‹çš„APIå’Œæ•°æ®
3. å› æ­¤ $S_i$ å¯ä»¥ç‹¬ç«‹éƒ¨ç½²
4. åŒç†å¯ä»¥ç‹¬ç«‹æ‰©å±•

## ğŸ Pythonå®ç°

### 1. åŸºç¡€æ¶æ„æ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass, field
from enum import Enum
import uuid

class ComponentType(Enum):
    """ç»„ä»¶ç±»å‹æšä¸¾"""
    SERVICE = "service"
    DATABASE = "database"
    CACHE = "cache"
    MESSAGE_QUEUE = "message_queue"
    API_GATEWAY = "api_gateway"

class RelationType(Enum):
    """å…³ç³»ç±»å‹æšä¸¾"""
    DEPENDS_ON = "depends_on"
    COMMUNICATES_WITH = "communicates_with"
    STORES_IN = "stores_in"
    CACHES_IN = "caches_in"

@dataclass
class Component:
    """ç»„ä»¶ç±»"""
    id: str
    name: str
    component_type: ComponentType
    interface: Dict[str, Any] = field(default_factory=dict)
    implementation: Dict[str, Any] = field(default_factory=dict)
    properties: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Relation:
    """å…³ç³»ç±»"""
    id: str
    source: str
    target: str
    relation_type: RelationType
    properties: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

class Architecture:
    """æ¶æ„ç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.components: Dict[str, Component] = {}
        self.relations: Dict[str, Relation] = {}
        self.properties: Dict[str, Any] = {}
    
    def add_component(self, component: Component) -> None:
        """æ·»åŠ ç»„ä»¶"""
        self.components[component.id] = component
    
    def add_relation(self, relation: Relation) -> None:
        """æ·»åŠ å…³ç³»"""
        if relation.source in self.components and relation.target in self.components:
            self.relations[relation.id] = relation
        else:
            raise ValueError("æºç»„ä»¶æˆ–ç›®æ ‡ç»„ä»¶ä¸å­˜åœ¨")
    
    def get_component(self, component_id: str) -> Optional[Component]:
        """è·å–ç»„ä»¶"""
        return self.components.get(component_id)
    
    def get_relations(self, component_id: str) -> List[Relation]:
        """è·å–ç»„ä»¶çš„æ‰€æœ‰å…³ç³»"""
        return [r for r in self.relations.values() 
                if r.source == component_id or r.target == component_id]
    
    def validate(self) -> bool:
        """éªŒè¯æ¶æ„å®Œæ•´æ€§"""
        # æ£€æŸ¥æ‰€æœ‰å…³ç³»å¼•ç”¨çš„ç»„ä»¶éƒ½å­˜åœ¨
        for relation in self.relations.values():
            if relation.source not in self.components:
                return False
            if relation.target not in self.components:
                return False
        return True
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            "name": self.name,
            "components": {cid: {
                "id": comp.id,
                "name": comp.name,
                "type": comp.component_type.value,
                "interface": comp.interface,
                "properties": comp.properties
            } for cid, comp in self.components.items()},
            "relations": {rid: {
                "id": rel.id,
                "source": rel.source,
                "target": rel.target,
                "type": rel.relation_type.value,
                "properties": rel.properties
            } for rid, rel in self.relations.items()},
            "properties": self.properties
        }
```

### 2. åˆ†å±‚æ¶æ„å®ç°

```python
from typing import Dict, List, Set, Optional
from dataclasses import dataclass, field

@dataclass
class Layer:
    """å±‚ç±»"""
    name: str
    level: int
    components: List[str] = field(default_factory=list)
    description: str = ""

class LayeredArchitecture(Architecture):
    """åˆ†å±‚æ¶æ„ç±»"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.layers: Dict[str, Layer] = {}
        self.layer_order: List[str] = []
    
    def add_layer(self, layer: Layer) -> None:
        """æ·»åŠ å±‚"""
        self.layers[layer.name] = layer
        self.layer_order.append(layer.name)
        self.layer_order.sort(key=lambda x: self.layers[x].level)
    
    def add_component_to_layer(self, component: Component, layer_name: str) -> None:
        """å°†ç»„ä»¶æ·»åŠ åˆ°æŒ‡å®šå±‚"""
        if layer_name not in self.layers:
            raise ValueError(f"å±‚ {layer_name} ä¸å­˜åœ¨")
        
        self.add_component(component)
        self.layers[layer_name].components.append(component.id)
    
    def validate_layering(self) -> bool:
        """éªŒè¯åˆ†å±‚è§„åˆ™"""
        for relation in self.relations.values():
            source_layer = self._get_component_layer(relation.source)
            target_layer = self._get_component_layer(relation.target)
            
            if source_layer and target_layer:
                # æ£€æŸ¥æ˜¯å¦è¿ååˆ†å±‚è§„åˆ™ï¼ˆä¸Šå±‚ä¸èƒ½ä¾èµ–ä¸‹å±‚ï¼‰
                if self.layers[source_layer].level < self.layers[target_layer].level:
                    return False
        return True
    
    def _get_component_layer(self, component_id: str) -> Optional[str]:
        """è·å–ç»„ä»¶æ‰€å±çš„å±‚"""
        for layer_name, layer in self.layers.items():
            if component_id in layer.components:
                return layer_name
        return None
    
    def get_layer_dependencies(self) -> Dict[str, Set[str]]:
        """è·å–å±‚é—´ä¾èµ–å…³ç³»"""
        dependencies = {layer_name: set() for layer_name in self.layers}
        
        for relation in self.relations.values():
            source_layer = self._get_component_layer(relation.source)
            target_layer = self._get_component_layer(relation.target)
            
            if source_layer and target_layer and source_layer != target_layer:
                dependencies[source_layer].add(target_layer)
        
        return dependencies

# ä½¿ç”¨ç¤ºä¾‹
def create_layered_architecture():
    """åˆ›å»ºåˆ†å±‚æ¶æ„ç¤ºä¾‹"""
    
    # åˆ›å»ºåˆ†å±‚æ¶æ„
    arch = LayeredArchitecture("Webåº”ç”¨åˆ†å±‚æ¶æ„")
    
    # å®šä¹‰å±‚
    presentation_layer = Layer("è¡¨ç°å±‚", 1, description="ç”¨æˆ·ç•Œé¢å’Œæ§åˆ¶å™¨")
    business_layer = Layer("ä¸šåŠ¡å±‚", 2, description="ä¸šåŠ¡é€»è¾‘å’Œè§„åˆ™")
    data_layer = Layer("æ•°æ®å±‚", 3, description="æ•°æ®è®¿é—®å’Œå­˜å‚¨")
    
    arch.add_layer(presentation_layer)
    arch.add_layer(business_layer)
    arch.add_layer(data_layer)
    
    # åˆ›å»ºç»„ä»¶
    web_controller = Component("web_controller", "Webæ§åˆ¶å™¨", ComponentType.SERVICE)
    business_service = Component("business_service", "ä¸šåŠ¡æœåŠ¡", ComponentType.SERVICE)
    data_repository = Component("data_repository", "æ•°æ®ä»“åº“", ComponentType.DATABASE)
    
    # æ·»åŠ ç»„ä»¶åˆ°å±‚
    arch.add_component_to_layer(web_controller, "è¡¨ç°å±‚")
    arch.add_component_to_layer(business_service, "ä¸šåŠ¡å±‚")
    arch.add_component_to_layer(data_repository, "æ•°æ®å±‚")
    
    # æ·»åŠ å…³ç³»
    arch.add_relation(Relation("", "web_controller", "business_service", 
                              RelationType.DEPENDS_ON))
    arch.add_relation(Relation("", "business_service", "data_repository", 
                              RelationType.DEPENDS_ON))
    
    return arch
```

### 3. å¾®æœåŠ¡æ¶æ„å®ç°

```python
from typing import Dict, List, Set, Optional, Any
from dataclasses import dataclass, field
import json

@dataclass
class ServiceAPI:
    """æœåŠ¡APIç±»"""
    endpoints: List[str] = field(default_factory=list)
    methods: List[str] = field(default_factory=list)
    version: str = "v1"

@dataclass
class ServiceData:
    """æœåŠ¡æ•°æ®ç±»"""
    schema: Dict[str, Any] = field(default_factory=dict)
    storage_type: str = "database"
    location: str = ""

@dataclass
class MicroService:
    """å¾®æœåŠ¡ç±»"""
    id: str
    name: str
    api: ServiceAPI
    data: ServiceData
    dependencies: List[str] = field(default_factory=list)
    properties: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

class MicroserviceArchitecture(Architecture):
    """å¾®æœåŠ¡æ¶æ„ç±»"""
    
    def __init__(self, name: str):
        super().__init__(name)
        self.services: Dict[str, MicroService] = {}
        self.service_registry: Dict[str, str] = {}  # service_name -> service_id
    
    def add_service(self, service: MicroService) -> None:
        """æ·»åŠ å¾®æœåŠ¡"""
        self.services[service.id] = service
        self.service_registry[service.name] = service.id
        
        # åˆ›å»ºå¯¹åº”çš„ç»„ä»¶
        component = Component(
            service.id, 
            service.name, 
            ComponentType.SERVICE,
            interface={"api": service.api.__dict__},
            properties=service.properties
        )
        self.add_component(component)
    
    def add_service_dependency(self, service_name: str, dependency_name: str) -> None:
        """æ·»åŠ æœåŠ¡ä¾èµ–"""
        if service_name in self.service_registry and dependency_name in self.service_registry:
            service_id = self.service_registry[service_name]
            dependency_id = self.service_registry[dependency_name]
            
            # æ·»åŠ ä¾èµ–å…³ç³»
            relation = Relation("", service_id, dependency_id, RelationType.DEPENDS_ON)
            self.add_relation(relation)
            
            # æ›´æ–°æœåŠ¡ä¾èµ–åˆ—è¡¨
            self.services[service_id].dependencies.append(dependency_name)
        else:
            raise ValueError("æœåŠ¡ä¸å­˜åœ¨")
    
    def get_service_dependencies(self, service_name: str) -> List[str]:
        """è·å–æœåŠ¡ä¾èµ–"""
        if service_name in self.service_registry:
            service_id = self.service_registry[service_name]
            return self.services[service_id].dependencies
        return []
    
    def validate_service_independence(self) -> bool:
        """éªŒè¯æœåŠ¡ç‹¬ç«‹æ€§"""
        # æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯ä¾èµ–
        visited = set()
        rec_stack = set()
        
        def has_cycle(service_id: str) -> bool:
            visited.add(service_id)
            rec_stack.add(service_id)
            
            for relation in self.relations.values():
                if relation.source == service_id:
                    target_id = relation.target
                    if target_id not in visited:
                        if has_cycle(target_id):
                            return True
                    elif target_id in rec_stack:
                        return True
            
            rec_stack.remove(service_id)
            return False
        
        for service_id in self.services:
            if service_id not in visited:
                if has_cycle(service_id):
                    return False
        
        return True
    
    def deploy_service(self, service_name: str) -> Dict[str, Any]:
        """éƒ¨ç½²æœåŠ¡"""
        if service_name not in self.service_registry:
            raise ValueError(f"æœåŠ¡ {service_name} ä¸å­˜åœ¨")
        
        service_id = self.service_registry[service_name]
        service = self.services[service_id]
        
        # æ£€æŸ¥ä¾èµ–æ˜¯å¦å·²éƒ¨ç½²
        for dependency in service.dependencies:
            if dependency not in self.service_registry:
                raise ValueError(f"ä¾èµ–æœåŠ¡ {dependency} ä¸å­˜åœ¨")
        
        return {
            "service_id": service_id,
            "service_name": service_name,
            "api": service.api.__dict__,
            "data": service.data.__dict__,
            "dependencies": service.dependencies,
            "status": "deployed"
        }

# ä½¿ç”¨ç¤ºä¾‹
def create_microservice_architecture():
    """åˆ›å»ºå¾®æœåŠ¡æ¶æ„ç¤ºä¾‹"""
    
    # åˆ›å»ºå¾®æœåŠ¡æ¶æ„
    arch = MicroserviceArchitecture("ç”µå•†å¾®æœåŠ¡æ¶æ„")
    
    # åˆ›å»ºæœåŠ¡API
    user_api = ServiceAPI(
        endpoints=["/users", "/users/{id}", "/users/{id}/profile"],
        methods=["GET", "POST", "PUT", "DELETE"],
        version="v1"
    )
    
    order_api = ServiceAPI(
        endpoints=["/orders", "/orders/{id}", "/orders/{id}/status"],
        methods=["GET", "POST", "PUT"],
        version="v1"
    )
    
    payment_api = ServiceAPI(
        endpoints=["/payments", "/payments/{id}"],
        methods=["GET", "POST"],
        version="v1"
    )
    
    # åˆ›å»ºæœåŠ¡æ•°æ®
    user_data = ServiceData(
        schema={"user_id": "string", "name": "string", "email": "string"},
        storage_type="database",
        location="user_db"
    )
    
    order_data = ServiceData(
        schema={"order_id": "string", "user_id": "string", "items": "array"},
        storage_type="database",
        location="order_db"
    )
    
    payment_data = ServiceData(
        schema={"payment_id": "string", "order_id": "string", "amount": "number"},
        storage_type="database",
        location="payment_db"
    )
    
    # åˆ›å»ºå¾®æœåŠ¡
    user_service = MicroService("user_service", "ç”¨æˆ·æœåŠ¡", user_api, user_data)
    order_service = MicroService("order_service", "è®¢å•æœåŠ¡", order_api, order_data)
    payment_service = MicroService("payment_service", "æ”¯ä»˜æœåŠ¡", payment_api, payment_data)
    
    # æ·»åŠ æœåŠ¡
    arch.add_service(user_service)
    arch.add_service(order_service)
    arch.add_service(payment_service)
    
    # æ·»åŠ ä¾èµ–å…³ç³»
    arch.add_service_dependency("è®¢å•æœåŠ¡", "ç”¨æˆ·æœåŠ¡")
    arch.add_service_dependency("æ”¯ä»˜æœåŠ¡", "è®¢å•æœåŠ¡")
    
    return arch
```

## ğŸ“Š æ•°å­¦è¯æ˜

### 1. æ¶æ„ä¸€è‡´æ€§å®šç†

**å®šç† 1.1** (æ¶æ„ä¸€è‡´æ€§)
å¦‚æœæ¶æ„ $A = (C, R, P)$ æ˜¯ä¸€è‡´çš„ï¼Œåˆ™æ‰€æœ‰ç»„ä»¶éƒ½éµå¾ªç›¸åŒçš„è®¾è®¡åŸåˆ™ã€‚

**è¯æ˜**:
1. è®¾ $A = (C, R, P)$ æ˜¯ä¸€è‡´çš„æ¶æ„
2. æ ¹æ®ä¸€è‡´æ€§å®šä¹‰ï¼Œæ‰€æœ‰ç»„ä»¶éƒ½éµå¾ªç›¸åŒçš„è®¾è®¡åŸåˆ™
3. å› æ­¤æ¶æ„æ˜¯ä¸€è‡´çš„

### 2. æ¶æ„å¯æ‰©å±•æ€§å®šç†

**å®šç† 1.2** (æ¶æ„å¯æ‰©å±•æ€§)
å¦‚æœæ¶æ„ $A$ æ˜¯å¯æ‰©å±•çš„ï¼Œåˆ™å¯ä»¥é€šè¿‡æ·»åŠ æ–°ç»„ä»¶æ¥æ‰©å±•åŠŸèƒ½ã€‚

**è¯æ˜**:
1. è®¾ $A$ æ˜¯å¯æ‰©å±•æ¶æ„
2. æ ¹æ®å¯æ‰©å±•æ€§å®šä¹‰ï¼Œå¯ä»¥æ·»åŠ æ–°ç»„ä»¶ $c_{new}$
3. æ–°ç»„ä»¶ä¸ç°æœ‰ç»„ä»¶é€šè¿‡å…³ç³»è¿æ¥
4. å› æ­¤æ¶æ„å¯ä»¥æ‰©å±•

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [è®¾è®¡æ¨¡å¼ç†è®º](../03-01-è®¾è®¡æ¨¡å¼/README.md)
- [ç³»ç»Ÿè®¾è®¡ç†è®º](../03-03-ç³»ç»Ÿè®¾è®¡/README.md)
- [è½¯ä»¶å·¥ç¨‹ç†è®º](../03-04-è½¯ä»¶å·¥ç¨‹/README.md)
- [è®¡ç®—æœºç§‘å­¦åŸºç¡€](../02-è®¡ç®—æœºç§‘å­¦/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Bass, L., Clements, P., & Kazman, R. (2012). Software Architecture in Practice
2. Fowler, M. (2018). Patterns of Enterprise Application Architecture
3. Newman, S. (2021). Building Microservices: Designing Fine-Grained Systems
4. Richards, M. (2020). Fundamentals of Software Architecture: An Engineering Approach
5. Martin, R. C. (2017). Clean Architecture: A Craftsman's Guide to Software Structure and Design

---

*è½¯ä»¶æ¶æ„ä¸ºç³»ç»Ÿè®¾è®¡æä¾›äº†ç»“æ„åŒ–çš„æ–¹æ³•è®ºï¼Œé€šè¿‡å½¢å¼åŒ–çš„æ•°å­¦å®šä¹‰å’Œä¸¥æ ¼çš„è¯æ˜ï¼Œæˆ‘ä»¬å»ºç«‹äº†è½¯ä»¶æ¶æ„çš„å®Œæ•´ç†è®ºä½“ç³»ã€‚* 