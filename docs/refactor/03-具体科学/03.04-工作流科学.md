# 03.04 å·¥ä½œæµç§‘å­¦

## ğŸ“– æ¦‚è¿°

å·¥ä½œæµç§‘å­¦æ˜¯ç ”ç©¶ä¸šåŠ¡æµç¨‹è‡ªåŠ¨åŒ–ã€ç¼–æ’å’Œç®¡ç†çš„ç§‘å­¦ã€‚æœ¬æ–‡æ¡£åŸºäº `/docs/model/Software/WorkFlow` ç›®å½•çš„å†…å®¹ï¼Œæä¾›å·¥ä½œæµçš„æ•°å­¦å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å·¥ä½œæµçš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰**ï¼šå·¥ä½œæµæ˜¯ä¸€ä¸ªå››å…ƒç»„ $(S, T, E, F)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $T$ æ˜¯ä»»åŠ¡é›†åˆ  
- $E$ æ˜¯äº‹ä»¶é›†åˆ
- $F$ æ˜¯æµè½¬å‡½æ•°

**æ•°å­¦è¡¨ç¤º**ï¼š
$$\text{Workflow} = \{(s, t, e, f) \mid s \in S, t \in T, e \in E, f: S \times T \times E \rightarrow S\}$$

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Set, Any, Callable, Optional
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod

class WorkflowState(Enum):
    """å·¥ä½œæµçŠ¶æ€"""
    INITIAL = "initial"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    SUSPENDED = "suspended"

@dataclass
class Task:
    """ä»»åŠ¡å®šä¹‰"""
    id: str
    name: str
    handler: Callable
    dependencies: List[str] = None
    timeout: int = 30
    retry_count: int = 3

@dataclass
class Event:
    """äº‹ä»¶å®šä¹‰"""
    type: str
    data: Dict[str, Any]
    timestamp: float

class WorkflowEngine:
    """å·¥ä½œæµå¼•æ“"""
    
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        self.current_state = WorkflowState.INITIAL
        self.execution_history: List[Dict[str, Any]] = []
        self.context: Dict[str, Any] = {}
    
    def add_task(self, task: Task):
        """æ·»åŠ ä»»åŠ¡"""
        self.tasks[task.id] = task
    
    def execute(self) -> bool:
        """æ‰§è¡Œå·¥ä½œæµ"""
        self.current_state = WorkflowState.RUNNING
        
        try:
            # æŒ‰ä¾èµ–é¡ºåºæ‰§è¡Œä»»åŠ¡
            execution_order = self._topological_sort()
            
            for task_id in execution_order:
                task = self.tasks[task_id]
                success = self._execute_task(task)
                
                if not success:
                    self.current_state = WorkflowState.FAILED
                    return False
            
            self.current_state = WorkflowState.COMPLETED
            return True
            
        except Exception as e:
            self.current_state = WorkflowState.FAILED
            return False
    
    def _execute_task(self, task: Task) -> bool:
        """æ‰§è¡Œå•ä¸ªä»»åŠ¡"""
        for attempt in range(task.retry_count):
            try:
                result = task.handler(self.context)
                self.execution_history.append({
                    "task_id": task.id,
                    "status": "success",
                    "result": result
                })
                return True
            except Exception as e:
                if attempt == task.retry_count - 1:
                    self.execution_history.append({
                        "task_id": task.id,
                        "status": "failed",
                        "error": str(e)
                    })
                    return False
        
        return False
    
    def _topological_sort(self) -> List[str]:
        """æ‹“æ‰‘æ’åºç¡®å®šæ‰§è¡Œé¡ºåº"""
        # ç®€åŒ–å®ç°
        return list(self.tasks.keys())
```

### 2. å·¥ä½œæµæ¨¡å¼

#### 2.1 é¡ºåºæ¨¡å¼ (Sequential Pattern)

**å®šä¹‰**ï¼šä»»åŠ¡æŒ‰é¡ºåºä¾æ¬¡æ‰§è¡Œã€‚

**Pythonå®ç°**ï¼š

```python
class SequentialWorkflow(WorkflowEngine):
    """é¡ºåºå·¥ä½œæµ"""
    
    def execute(self) -> bool:
        self.current_state = WorkflowState.RUNNING
        
        for task_id, task in self.tasks.items():
            success = self._execute_task(task)
            if not success:
                self.current_state = WorkflowState.FAILED
                return False
        
        self.current_state = WorkflowState.COMPLETED
        return True
```

#### 2.2 å¹¶è¡Œæ¨¡å¼ (Parallel Pattern)

**å®šä¹‰**ï¼šå¤šä¸ªä»»åŠ¡å¯ä»¥å¹¶è¡Œæ‰§è¡Œã€‚

**Pythonå®ç°**ï¼š

```python
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

class ParallelWorkflow(WorkflowEngine):
    """å¹¶è¡Œå·¥ä½œæµ"""
    
    def execute(self) -> bool:
        self.current_state = WorkflowState.RUNNING
        
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = {}
            
            # æäº¤æ‰€æœ‰ä»»åŠ¡
            for task_id, task in self.tasks.items():
                future = executor.submit(self._execute_task, task)
                futures[future] = task_id
            
            # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
            for future in as_completed(futures):
                if not future.result():
                    self.current_state = WorkflowState.FAILED
                    return False
        
        self.current_state = WorkflowState.COMPLETED
        return True
```

#### 2.3 æ¡ä»¶æ¨¡å¼ (Conditional Pattern)

**å®šä¹‰**ï¼šæ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒçš„æ‰§è¡Œè·¯å¾„ã€‚

**Pythonå®ç°**ï¼š

```python
class ConditionalWorkflow(WorkflowEngine):
    """æ¡ä»¶å·¥ä½œæµ"""
    
    def __init__(self):
        super().__init__()
        self.conditions: Dict[str, Callable] = {}
    
    def add_condition(self, task_id: str, condition: Callable):
        """æ·»åŠ æ¡ä»¶"""
        self.conditions[task_id] = condition
    
    def execute(self) -> bool:
        self.current_state = WorkflowState.RUNNING
        
        for task_id, task in self.tasks.items():
            # æ£€æŸ¥æ¡ä»¶
            if task_id in self.conditions:
                condition = self.conditions[task_id]
                if not condition(self.context):
                    continue  # è·³è¿‡æ­¤ä»»åŠ¡
            
            success = self._execute_task(task)
            if not success:
                self.current_state = WorkflowState.FAILED
                return False
        
        self.current_state = WorkflowState.COMPLETED
        return True
```

### 3. å·¥ä½œæµç¼–æ’

#### 3.1 åŸºäºPetriç½‘çš„å·¥ä½œæµ

**å®šä¹‰**ï¼šä½¿ç”¨Petriç½‘æ¨¡å‹å·¥ä½œæµã€‚

**Pythonå®ç°**ï¼š

```python
class PetriNet:
    """Petriç½‘"""
    
    def __init__(self):
        self.places: Set[str] = set()
        self.transitions: Set[str] = set()
        self.arcs: Dict[tuple, int] = {}
        self.marking: Dict[str, int] = {}
    
    def add_place(self, place: str, tokens: int = 0):
        """æ·»åŠ åº“æ‰€"""
        self.places.add(place)
        self.marking[place] = tokens
    
    def add_transition(self, transition: str):
        """æ·»åŠ å˜è¿"""
        self.transitions.add(transition)
    
    def add_arc(self, from_node: str, to_node: str, weight: int = 1):
        """æ·»åŠ å¼§"""
        self.arcs[(from_node, to_node)] = weight
    
    def can_fire(self, transition: str) -> bool:
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯ä»¥æ¿€å‘"""
        for place in self.places:
            if (place, transition) in self.arcs:
                required_tokens = self.arcs[(place, transition)]
                if self.marking.get(place, 0) < required_tokens:
                    return False
        return True
    
    def fire(self, transition: str):
        """æ¿€å‘å˜è¿"""
        if not self.can_fire(transition):
            raise ValueError(f"Transition {transition} cannot fire")
        
        # æ¶ˆè€—è¾“å…¥åº“æ‰€çš„ä»¤ç‰Œ
        for place in self.places:
            if (place, transition) in self.arcs:
                weight = self.arcs[(place, transition)]
                self.marking[place] -= weight
        
        # äº§ç”Ÿè¾“å‡ºåº“æ‰€çš„ä»¤ç‰Œ
        for place in self.places:
            if (transition, place) in self.arcs:
                weight = self.arcs[(transition, place)]
                self.marking[place] += weight

class PetriNetWorkflow(WorkflowEngine):
    """åŸºäºPetriç½‘çš„å·¥ä½œæµ"""
    
    def __init__(self):
        super().__init__()
        self.petri_net = PetriNet()
    
    def build_from_petri_net(self):
        """ä»Petriç½‘æ„å»ºå·¥ä½œæµ"""
        # å®ç°Petriç½‘åˆ°å·¥ä½œæµçš„è½¬æ¢
        pass
```

### 4. å·¥ä½œæµæŒä¹…åŒ–

#### 4.1 çŠ¶æ€æŒä¹…åŒ–

**Pythonå®ç°**ï¼š

```python
import json
import pickle
from datetime import datetime

class WorkflowPersistence:
    """å·¥ä½œæµæŒä¹…åŒ–"""
    
    @staticmethod
    def save_workflow(workflow: WorkflowEngine, filename: str):
        """ä¿å­˜å·¥ä½œæµçŠ¶æ€"""
        state = {
            "current_state": workflow.current_state.value,
            "context": workflow.context,
            "execution_history": workflow.execution_history,
            "timestamp": datetime.now().isoformat()
        }
        
        with open(filename, 'w') as f:
            json.dump(state, f, indent=2)
    
    @staticmethod
    def load_workflow(workflow: WorkflowEngine, filename: str):
        """åŠ è½½å·¥ä½œæµçŠ¶æ€"""
        with open(filename, 'r') as f:
            state = json.load(f)
        
        workflow.current_state = WorkflowState(state["current_state"])
        workflow.context = state["context"]
        workflow.execution_history = state["execution_history"]
```

### 5. å·¥ä½œæµç›‘æ§

#### 5.1 æ‰§è¡Œç›‘æ§

**Pythonå®ç°**ï¼š

```python
class WorkflowMonitor:
    """å·¥ä½œæµç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics: Dict[str, Any] = {}
    
    def record_execution_time(self, task_id: str, execution_time: float):
        """è®°å½•æ‰§è¡Œæ—¶é—´"""
        if task_id not in self.metrics:
            self.metrics[task_id] = {"execution_times": []}
        
        self.metrics[task_id]["execution_times"].append(execution_time)
    
    def get_average_execution_time(self, task_id: str) -> float:
        """è·å–å¹³å‡æ‰§è¡Œæ—¶é—´"""
        if task_id not in self.metrics:
            return 0.0
        
        times = self.metrics[task_id]["execution_times"]
        return sum(times) / len(times) if times else 0.0
    
    def get_success_rate(self, task_id: str) -> float:
        """è·å–æˆåŠŸç‡"""
        # å®ç°æˆåŠŸç‡è®¡ç®—
        return 0.95  # ç¤ºä¾‹å€¼
```

### 6. å®é™…åº”ç”¨ç¤ºä¾‹

#### 6.1 æ•°æ®å¤„ç†å·¥ä½œæµ

**Pythonå®ç°**ï¼š

```python
def create_data_processing_workflow():
    """åˆ›å»ºæ•°æ®å¤„ç†å·¥ä½œæµ"""
    
    # å®šä¹‰ä»»åŠ¡
    def load_data(context):
        print("Loading data...")
        context["data"] = [1, 2, 3, 4, 5]
        return True
    
    def process_data(context):
        print("Processing data...")
        context["processed_data"] = [x * 2 for x in context["data"]]
        return True
    
    def save_data(context):
        print("Saving data...")
        print(f"Saved: {context['processed_data']}")
        return True
    
    # åˆ›å»ºå·¥ä½œæµ
    workflow = SequentialWorkflow()
    
    workflow.add_task(Task("load", "Load Data", load_data))
    workflow.add_task(Task("process", "Process Data", process_data))
    workflow.add_task(Task("save", "Save Data", save_data))
    
    return workflow

# æ‰§è¡Œå·¥ä½œæµ
workflow = create_data_processing_workflow()
success = workflow.execute()
print(f"Workflow execution: {'Success' if success else 'Failed'}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [03.01 è®¾è®¡æ¨¡å¼ç§‘å­¦](./03.01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md)
- [03.02 å¹¶å‘ç¼–ç¨‹ç§‘å­¦](./03.02-å¹¶å‘ç¼–ç¨‹ç§‘å­¦.md)
- [03.03 åˆ†å¸ƒå¼ç³»ç»Ÿç§‘å­¦](./03.03-åˆ†å¸ƒå¼ç³»ç»Ÿç§‘å­¦.md)
- [06.05 åˆ†å¸ƒå¼ç»„ä»¶](../06-ç»„ä»¶ç®—æ³•/06.05-åˆ†å¸ƒå¼ç»„ä»¶.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. van der Aalst, W. M. (2016). Process mining: data science in action. Springer.
2. Dumas, M., La Rosa, M., Mendling, J., & Reijers, H. A. (2018). Fundamentals of business process management. Springer.
3. Russell, N., van der Aalst, W. M., & ter Hofstede, A. H. (2016). Workflow patterns: the definitive guide. MIT Press.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0.0
