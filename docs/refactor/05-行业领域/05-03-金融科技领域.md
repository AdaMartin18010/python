# 金融科技领域

## 5.3 金融科技领域

### 概念与概述

金融科技（FinTech）是金融与技术的结合，通过创新技术手段提升金融服务效率、降低成本和改善用户体验。

#### 核心领域

1. 金融数据分析
2. 量化交易
3. 风险管理
4. 区块链与加密货币
5. 智能投顾

### 金融数据分析

#### 1. 金融数据获取

```python
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

class FinancialDataCollector:
    def __init__(self):
        self.data_cache = {}
    
    def get_stock_data(self, symbol, start_date=None, end_date=None, period="1y"):
        """获取股票数据"""
        try:
            ticker = yf.Ticker(symbol)
            
            if start_date and end_date:
                data = ticker.history(start=start_date, end=end_date)
            else:
                data = ticker.history(period=period)
            
            # 计算技术指标
            data = self._add_technical_indicators(data)
            
            self.data_cache[symbol] = data
            return data
        
        except Exception as e:
            print(f"获取股票数据失败 {symbol}: {str(e)}")
            return None
    
    def get_market_data(self, symbols, start_date=None, end_date=None):
        """获取多只股票数据"""
        market_data = {}
        
        for symbol in symbols:
            data = self.get_stock_data(symbol, start_date, end_date)
            if data is not None:
                market_data[symbol] = data
        
        return market_data
    
    def _add_technical_indicators(self, data):
        """添加技术指标"""
        # 移动平均线
        data['MA5'] = data['Close'].rolling(window=5).mean()
        data['MA20'] = data['Close'].rolling(window=20).mean()
        data['MA50'] = data['Close'].rolling(window=50).mean()
        
        # 相对强弱指数 (RSI)
        data['RSI'] = self._calculate_rsi(data['Close'])
        
        # 布林带
        data['BB_upper'], data['BB_middle'], data['BB_lower'] = self._calculate_bollinger_bands(data['Close'])
        
        # MACD
        data['MACD'], data['MACD_signal'], data['MACD_hist'] = self._calculate_macd(data['Close'])
        
        return data
    
    def _calculate_rsi(self, prices, period=14):
        """计算RSI"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def _calculate_bollinger_bands(self, prices, period=20, std_dev=2):
        """计算布林带"""
        middle = prices.rolling(window=period).mean()
        std = prices.rolling(window=period).std()
        upper = middle + (std * std_dev)
        lower = middle - (std * std_dev)
        return upper, middle, lower
    
    def _calculate_macd(self, prices, fast=12, slow=26, signal=9):
        """计算MACD"""
        ema_fast = prices.ewm(span=fast).mean()
        ema_slow = prices.ewm(span=slow).mean()
        macd = ema_fast - ema_slow
        macd_signal = macd.ewm(span=signal).mean()
        macd_hist = macd - macd_signal
        return macd, macd_signal, macd_hist

def financial_data_analysis_example():
    """金融数据分析示例"""
    collector = FinancialDataCollector()
    
    # 获取股票数据
    symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA']
    market_data = collector.get_market_data(symbols, period="6mo")
    
    # 分析每只股票
    for symbol, data in market_data.items():
        print(f"\n=== {symbol} 分析 ===")
        print(f"当前价格: ${data['Close'].iloc[-1]:.2f}")
        print(f"6个月收益率: {((data['Close'].iloc[-1] / data['Close'].iloc[0]) - 1) * 100:.2f}%")
        print(f"波动率: {data['Close'].pct_change().std() * np.sqrt(252) * 100:.2f}%")
        print(f"RSI: {data['RSI'].iloc[-1]:.2f}")
    
    return market_data
```

#### 2. 投资组合分析

```python
class PortfolioAnalyzer:
    def __init__(self, market_data):
        self.market_data = market_data
        self.returns = self._calculate_returns()
    
    def _calculate_returns(self):
        """计算收益率"""
        returns = {}
        for symbol, data in self.market_data.items():
            returns[symbol] = data['Close'].pct_change().dropna()
        return pd.DataFrame(returns)
    
    def calculate_portfolio_metrics(self, weights):
        """计算投资组合指标"""
        # 投资组合收益率
        portfolio_return = np.sum(self.returns.mean() * weights) * 252
        
        # 投资组合波动率
        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.returns.cov() * 252, weights)))
        
        # 夏普比率
        risk_free_rate = 0.02  # 假设无风险利率2%
        sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_volatility
        
        # 最大回撤
        cumulative_returns = (1 + self.returns).cumprod()
        portfolio_cumulative = np.sum(cumulative_returns * weights, axis=1)
        max_drawdown = self._calculate_max_drawdown(portfolio_cumulative)
        
        return {
            'return': portfolio_return,
            'volatility': portfolio_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }
    
    def _calculate_max_drawdown(self, cumulative_returns):
        """计算最大回撤"""
        peak = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - peak) / peak
        return drawdown.min()
    
    def efficient_frontier(self, num_portfolios=10000):
        """计算有效前沿"""
        returns = self.returns.mean() * 252
        cov_matrix = self.returns.cov() * 252
        
        portfolio_returns = []
        portfolio_volatilities = []
        portfolio_weights = []
        
        for _ in range(num_portfolios):
            weights = np.random.random(len(returns))
            weights /= np.sum(weights)
            
            portfolio_return = np.sum(returns * weights)
            portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
            
            portfolio_returns.append(portfolio_return)
            portfolio_volatilities.append(portfolio_volatility)
            portfolio_weights.append(weights)
        
        return portfolio_returns, portfolio_volatilities, portfolio_weights
    
    def plot_efficient_frontier(self, portfolio_returns, portfolio_volatilities):
        """绘制有效前沿"""
        plt.figure(figsize=(12, 8))
        plt.scatter(portfolio_volatilities, portfolio_returns, alpha=0.1)
        plt.xlabel('波动率')
        plt.ylabel('收益率')
        plt.title('有效前沿')
        plt.grid(True)
        plt.show()

def portfolio_analysis_example():
    """投资组合分析示例"""
    # 获取数据
    collector = FinancialDataCollector()
    symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN']
    market_data = collector.get_market_data(symbols, period="1y")
    
    # 创建分析器
    analyzer = PortfolioAnalyzer(market_data)
    
    # 等权重投资组合
    equal_weights = np.array([0.2, 0.2, 0.2, 0.2, 0.2])
    metrics = analyzer.calculate_portfolio_metrics(equal_weights)
    
    print("等权重投资组合指标:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.4f}")
    
    # 计算有效前沿
    returns, volatilities, weights = analyzer.efficient_frontier()
    analyzer.plot_efficient_frontier(returns, volatilities)
    
    return analyzer, metrics
```

### 量化交易

#### 1. 交易策略框架

```python
class TradingStrategy:
    def __init__(self, data, initial_capital=100000):
        self.data = data
        self.initial_capital = initial_capital
        self.capital = initial_capital
        self.position = 0
        self.trades = []
        self.portfolio_values = []
    
    def generate_signals(self):
        """生成交易信号"""
        signals = pd.DataFrame(index=self.data.index)
        signals['signal'] = 0
        
        # 示例：移动平均线交叉策略
        signals.loc[self.data['MA5'] > self.data['MA20'], 'signal'] = 1
        signals.loc[self.data['MA5'] < self.data['MA20'], 'signal'] = -1
        
        return signals
    
    def backtest(self):
        """回测策略"""
        signals = self.generate_signals()
        position = 0
        
        for i in range(1, len(self.data)):
            current_signal = signals['signal'].iloc[i]
            current_price = self.data['Close'].iloc[i]
            
            # 买入信号
            if current_signal == 1 and position == 0:
                position = self.capital / current_price
                self.capital = 0
                self.trades.append({
                    'date': self.data.index[i],
                    'action': 'BUY',
                    'price': current_price,
                    'quantity': position
                })
            
            # 卖出信号
            elif current_signal == -1 and position > 0:
                self.capital = position * current_price
                self.trades.append({
                    'date': self.data.index[i],
                    'action': 'SELL',
                    'price': current_price,
                    'quantity': position
                })
                position = 0
            
            # 计算当前投资组合价值
            portfolio_value = self.capital + (position * current_price)
            self.portfolio_values.append(portfolio_value)
        
        return self._calculate_performance()
    
    def _calculate_performance(self):
        """计算策略表现"""
        if not self.portfolio_values:
            return {}
        
        portfolio_values = pd.Series(self.portfolio_values, index=self.data.index[1:])
        returns = portfolio_values.pct_change().dropna()
        
        # 计算指标
        total_return = (portfolio_values.iloc[-1] / self.initial_capital) - 1
        annual_return = total_return * (252 / len(returns))
        volatility = returns.std() * np.sqrt(252)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0
        max_drawdown = self._calculate_max_drawdown(portfolio_values)
        
        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'trades_count': len(self.trades)
        }
    
    def _calculate_max_drawdown(self, portfolio_values):
        """计算最大回撤"""
        peak = portfolio_values.expanding().max()
        drawdown = (portfolio_values - peak) / peak
        return drawdown.min()
    
    def plot_strategy(self):
        """绘制策略结果"""
        signals = self.generate_signals()
        
        plt.figure(figsize=(15, 10))
        
        # 价格和移动平均线
        plt.subplot(2, 1, 1)
        plt.plot(self.data.index, self.data['Close'], label='价格')
        plt.plot(self.data.index, self.data['MA5'], label='MA5')
        plt.plot(self.data.index, self.data['MA20'], label='MA20')
        
        # 买卖信号
        buy_signals = signals[signals['signal'] == 1]
        sell_signals = signals[signals['signal'] == -1]
        
        plt.scatter(buy_signals.index, self.data.loc[buy_signals.index, 'Close'], 
                   marker='^', color='green', s=100, label='买入信号')
        plt.scatter(sell_signals.index, self.data.loc[sell_signals.index, 'Close'], 
                   marker='v', color='red', s=100, label='卖出信号')
        
        plt.title('交易策略')
        plt.legend()
        plt.grid(True)
        
        # 投资组合价值
        plt.subplot(2, 1, 2)
        portfolio_values = pd.Series(self.portfolio_values, index=self.data.index[1:])
        plt.plot(portfolio_values.index, portfolio_values, label='投资组合价值')
        plt.axhline(y=self.initial_capital, color='r', linestyle='--', label='初始资金')
        plt.title('投资组合价值变化')
        plt.legend()
        plt.grid(True)
        
        plt.tight_layout()
        plt.show()

def trading_strategy_example():
    """交易策略示例"""
    # 获取数据
    collector = FinancialDataCollector()
    data = collector.get_stock_data('AAPL', period="2y")
    
    # 创建策略
    strategy = TradingStrategy(data)
    
    # 回测
    performance = strategy.backtest()
    
    print("策略表现:")
    for metric, value in performance.items():
        if isinstance(value, float):
            print(f"{metric}: {value:.4f}")
        else:
            print(f"{metric}: {value}")
    
    # 绘制结果
    strategy.plot_strategy()
    
    return strategy, performance
```

#### 2. 风险管理

```python
class RiskManager:
    def __init__(self, returns, confidence_level=0.95):
        self.returns = returns
        self.confidence_level = confidence_level
    
    def calculate_var(self, portfolio_value=100000):
        """计算VaR (Value at Risk)"""
        var_percentile = (1 - self.confidence_level) * 100
        var_return = np.percentile(self.returns, var_percentile)
        var_amount = portfolio_value * abs(var_return)
        
        return {
            'var_percentile': var_percentile,
            'var_return': var_return,
            'var_amount': var_amount
        }
    
    def calculate_cvar(self, portfolio_value=100000):
        """计算CVaR (Conditional Value at Risk)"""
        var_result = self.calculate_var(portfolio_value)
        var_threshold = var_result['var_return']
        
        # 计算超过VaR的损失期望
        tail_returns = self.returns[self.returns <= var_threshold]
        cvar_return = tail_returns.mean()
        cvar_amount = portfolio_value * abs(cvar_return)
        
        return {
            'cvar_return': cvar_return,
            'cvar_amount': cvar_amount
        }
    
    def calculate_stress_test(self, portfolio_value=100000, scenarios=None):
        """压力测试"""
        if scenarios is None:
            scenarios = {
                'market_crash': -0.20,  # 市场崩盘
                'moderate_decline': -0.10,  # 温和下跌
                'volatility_spike': -0.15  # 波动性飙升
            }
        
        stress_results = {}
        for scenario, return_shock in scenarios.items():
            stress_loss = portfolio_value * abs(return_shock)
            stress_results[scenario] = {
                'return_shock': return_shock,
                'loss_amount': stress_loss,
                'remaining_value': portfolio_value - stress_loss
            }
        
        return stress_results
    
    def calculate_correlation_matrix(self):
        """计算相关性矩阵"""
        return self.returns.corr()
    
    def plot_risk_metrics(self):
        """绘制风险指标"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # 收益率分布
        axes[0, 0].hist(self.returns, bins=50, alpha=0.7)
        axes[0, 0].axvline(self.returns.mean(), color='red', linestyle='--', label='均值')
        axes[0, 0].set_title('收益率分布')
        axes[0, 0].legend()
        
        # 累积收益率
        cumulative_returns = (1 + self.returns).cumprod()
        axes[0, 1].plot(cumulative_returns.index, cumulative_returns)
        axes[0, 1].set_title('累积收益率')
        axes[0, 1].grid(True)
        
        # 滚动波动率
        rolling_vol = self.returns.rolling(window=30).std() * np.sqrt(252)
        axes[1, 0].plot(rolling_vol.index, rolling_vol)
        axes[1, 0].set_title('30日滚动波动率')
        axes[1, 0].grid(True)
        
        # 相关性热图
        corr_matrix = self.calculate_correlation_matrix()
        sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', ax=axes[1, 1])
        axes[1, 1].set_title('相关性矩阵')
        
        plt.tight_layout()
        plt.show()

def risk_management_example():
    """风险管理示例"""
    # 获取多只股票数据
    collector = FinancialDataCollector()
    symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN']
    market_data = collector.get_market_data(symbols, period="1y")
    
    # 计算投资组合收益率
    portfolio_weights = np.array([0.2, 0.2, 0.2, 0.2, 0.2])
    returns_data = pd.DataFrame()
    
    for symbol, data in market_data.items():
        returns_data[symbol] = data['Close'].pct_change().dropna()
    
    portfolio_returns = returns_data.dot(portfolio_weights)
    
    # 创建风险管理器
    risk_manager = RiskManager(portfolio_returns)
    
    # 计算风险指标
    var_result = risk_manager.calculate_var()
    cvar_result = risk_manager.calculate_cvar()
    stress_results = risk_manager.calculate_stress_test()
    
    print("风险指标:")
    print(f"VaR ({var_result['var_percentile']:.1f}%): ${var_result['var_amount']:.2f}")
    print(f"CVaR: ${cvar_result['cvar_amount']:.2f}")
    
    print("\n压力测试结果:")
    for scenario, result in stress_results.items():
        print(f"{scenario}: 损失 ${result['loss_amount']:.2f}")
    
    # 绘制风险指标
    risk_manager.plot_risk_metrics()
    
    return risk_manager, var_result, cvar_result
```

### 区块链与加密货币

#### 1. 区块链基础实现

```python
import hashlib
import json
import time
from typing import List, Dict, Any

class Block:
    def __init__(self, index: int, transactions: List[Dict], timestamp: float, previous_hash: str):
        self.index = index
        self.transactions = transactions
        self.timestamp = timestamp
        self.previous_hash = previous_hash
        self.nonce = 0
        self.hash = self.calculate_hash()
    
    def calculate_hash(self) -> str:
        """计算区块哈希"""
        block_string = json.dumps({
            'index': self.index,
            'transactions': self.transactions,
            'timestamp': self.timestamp,
            'previous_hash': self.previous_hash,
            'nonce': self.nonce
        }, sort_keys=True)
        
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def mine_block(self, difficulty: int) -> None:
        """挖矿"""
        target = '0' * difficulty
        
        while self.hash[:difficulty] != target:
            self.nonce += 1
            self.hash = self.calculate_hash()

class Blockchain:
    def __init__(self):
        self.chain: List[Block] = []
        self.difficulty = 4
        self.pending_transactions: List[Dict] = []
        self.mining_reward = 10
        
        # 创建创世区块
        self.create_genesis_block()
    
    def create_genesis_block(self) -> None:
        """创建创世区块"""
        genesis_block = Block(0, [], time.time(), "0")
        genesis_block.hash = genesis_block.calculate_hash()
        self.chain.append(genesis_block)
    
    def get_latest_block(self) -> Block:
        """获取最新区块"""
        return self.chain[-1]
    
    def add_transaction(self, sender: str, recipient: str, amount: float) -> int:
        """添加交易"""
        self.pending_transactions.append({
            'sender': sender,
            'recipient': recipient,
            'amount': amount,
            'timestamp': time.time()
        })
        
        return self.get_latest_block().index + 1
    
    def mine_pending_transactions(self, miner_address: str) -> None:
        """挖矿待处理交易"""
        block = Block(
            len(self.chain),
            self.pending_transactions,
            time.time(),
            self.get_latest_block().hash
        )
        
        block.mine_block(self.difficulty)
        
        print(f"区块已挖出! 哈希: {block.hash}")
        self.chain.append(block)
        
        # 重置待处理交易并添加挖矿奖励
        self.pending_transactions = [
            {
                'sender': "区块链网络",
                'recipient': miner_address,
                'amount': self.mining_reward,
                'timestamp': time.time()
            }
        ]
    
    def is_chain_valid(self) -> bool:
        """验证区块链"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            # 验证当前区块哈希
            if current_block.hash != current_block.calculate_hash():
                return False
            
            # 验证区块链连续性
            if current_block.previous_hash != previous_block.hash:
                return False
        
        return True
    
    def get_balance(self, address: str) -> float:
        """获取地址余额"""
        balance = 0
        
        for block in self.chain:
            for transaction in block.transactions:
                if transaction['sender'] == address:
                    balance -= transaction['amount']
                if transaction['recipient'] == address:
                    balance += transaction['amount']
        
        return balance

def blockchain_example():
    """区块链示例"""
    # 创建区块链
    my_blockchain = Blockchain()
    
    # 添加交易
    my_blockchain.add_transaction("Alice", "Bob", 50)
    my_blockchain.add_transaction("Bob", "Charlie", 30)
    
    # 挖矿
    print("开始挖矿...")
    my_blockchain.mine_pending_transactions("miner_address")
    
    # 添加更多交易
    my_blockchain.add_transaction("Charlie", "David", 20)
    my_blockchain.add_transaction("David", "Eve", 10)
    
    # 再次挖矿
    print("开始挖矿...")
    my_blockchain.mine_pending_transactions("miner_address")
    
    # 检查余额
    print(f"Alice余额: {my_blockchain.get_balance('Alice')}")
    print(f"Bob余额: {my_blockchain.get_balance('Bob')}")
    print(f"Charlie余额: {my_blockchain.get_balance('Charlie')}")
    print(f"David余额: {my_blockchain.get_balance('David')}")
    print(f"Eve余额: {my_blockchain.get_balance('Eve')}")
    print(f"矿工余额: {my_blockchain.get_balance('miner_address')}")
    
    # 验证区块链
    print(f"区块链是否有效: {my_blockchain.is_chain_valid()}")
    
    return my_blockchain
```

#### 2. 加密货币价格分析

```python
class CryptocurrencyAnalyzer:
    def __init__(self):
        self.data_collector = FinancialDataCollector()
    
    def get_crypto_data(self, symbol, period="1y"):
        """获取加密货币数据"""
        # 添加USD后缀
        if not symbol.endswith('-USD'):
            symbol = f"{symbol}-USD"
        
        return self.data_collector.get_stock_data(symbol, period=period)
    
    def analyze_crypto(self, symbol):
        """分析加密货币"""
        data = self.get_crypto_data(symbol)
        if data is None:
            return None
        
        # 计算指标
        current_price = data['Close'].iloc[-1]
        price_change = data['Close'].pct_change()
        
        analysis = {
            'current_price': current_price,
            'daily_return': price_change.iloc[-1],
            'volatility': price_change.std() * np.sqrt(252),
            'max_price': data['High'].max(),
            'min_price': data['Low'].min(),
            'volume_avg': data['Volume'].mean(),
            'price_momentum': (current_price / data['Close'].iloc[-20] - 1) * 100
        }
        
        return analysis
    
    def compare_cryptocurrencies(self, symbols):
        """比较多个加密货币"""
        comparison = {}
        
        for symbol in symbols:
            analysis = self.analyze_crypto(symbol)
            if analysis:
                comparison[symbol] = analysis
        
        return comparison
    
    def plot_crypto_analysis(self, symbol):
        """绘制加密货币分析图"""
        data = self.get_crypto_data(symbol)
        if data is None:
            return
        
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # 价格走势
        axes[0, 0].plot(data.index, data['Close'])
        axes[0, 0].set_title(f'{symbol} 价格走势')
        axes[0, 0].grid(True)
        
        # 成交量
        axes[0, 1].bar(data.index, data['Volume'], alpha=0.7)
        axes[0, 1].set_title('成交量')
        axes[0, 1].grid(True)
        
        # 收益率分布
        returns = data['Close'].pct_change().dropna()
        axes[1, 0].hist(returns, bins=50, alpha=0.7)
        axes[1, 0].set_title('日收益率分布')
        axes[1, 0].grid(True)
        
        # 滚动波动率
        rolling_vol = returns.rolling(window=30).std() * np.sqrt(252)
        axes[1, 1].plot(rolling_vol.index, rolling_vol)
        axes[1, 1].set_title('30日滚动波动率')
        axes[1, 1].grid(True)
        
        plt.tight_layout()
        plt.show()

def cryptocurrency_analysis_example():
    """加密货币分析示例"""
    analyzer = CryptocurrencyAnalyzer()
    
    # 分析单个加密货币
    btc_analysis = analyzer.analyze_crypto('BTC')
    if btc_analysis:
        print("比特币分析:")
        for metric, value in btc_analysis.items():
            if isinstance(value, float):
                print(f"{metric}: {value:.4f}")
            else:
                print(f"{metric}: {value}")
    
    # 比较多个加密货币
    symbols = ['BTC', 'ETH', 'ADA', 'DOT']
    comparison = analyzer.compare_cryptocurrencies(symbols)
    
    print("\n加密货币比较:")
    for symbol, analysis in comparison.items():
        print(f"\n{symbol}:")
        print(f"  当前价格: ${analysis['current_price']:.2f}")
        print(f"  日收益率: {analysis['daily_return']:.2%}")
        print(f"  年化波动率: {analysis['volatility']:.2%}")
    
    # 绘制分析图
    analyzer.plot_crypto_analysis('BTC')
    
    return analyzer, comparison
```

### 实战案例：智能投顾系统

```python
class RoboAdvisor:
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.data_collector = FinancialDataCollector()
        self.portfolio_analyzer = None
        self.risk_manager = None
    
    def create_portfolio(self, risk_tolerance, investment_amount, investment_horizon):
        """创建投资组合"""
        # 根据风险偏好选择资产
        if risk_tolerance == 'conservative':
            assets = ['BND', 'VTI', 'VEA', 'VWO']  # 债券 + 股票
            weights = [0.6, 0.25, 0.1, 0.05]
        elif risk_tolerance == 'moderate':
            assets = ['VTI', 'VEA', 'VWO', 'BND']
            weights = [0.5, 0.25, 0.15, 0.1]
        else:  # aggressive
            assets = ['VTI', 'VEA', 'VWO', 'QQQ']
            weights = [0.4, 0.25, 0.25, 0.1]
        
        # 获取资产数据
        market_data = self.data_collector.get_market_data(assets, period="1y")
        
        # 创建投资组合分析器
        self.portfolio_analyzer = PortfolioAnalyzer(market_data)
        
        # 计算投资组合指标
        weights = np.array(weights)
        metrics = self.portfolio_analyzer.calculate_portfolio_metrics(weights)
        
        # 创建风险管理器
        returns_data = pd.DataFrame()
        for asset, data in market_data.items():
            returns_data[asset] = data['Close'].pct_change().dropna()
        portfolio_returns = returns_data.dot(weights)
        self.risk_manager = RiskManager(portfolio_returns)
        
        # 计算风险指标
        var_result = self.risk_manager.calculate_var(investment_amount)
        cvar_result = self.risk_manager.calculate_cvar(investment_amount)
        
        return {
            'assets': assets,
            'weights': weights,
            'metrics': metrics,
            'risk_metrics': {
                'var': var_result,
                'cvar': cvar_result
            },
            'allocation': {
                asset: weight * investment_amount 
                for asset, weight in zip(assets, weights)
            }
        }
    
    def rebalance_portfolio(self, current_allocation, target_allocation, threshold=0.05):
        """重新平衡投资组合"""
        rebalancing_trades = []
        
        for asset in target_allocation:
            current_weight = current_allocation.get(asset, 0)
            target_weight = target_allocation[asset]
            
            weight_diff = abs(target_weight - current_weight)
            
            if weight_diff > threshold:
                trade = {
                    'asset': asset,
                    'action': 'BUY' if target_weight > current_weight else 'SELL',
                    'amount': abs(target_weight - current_weight)
                }
                rebalancing_trades.append(trade)
        
        return rebalancing_trades
    
    def generate_report(self, portfolio_data):
        """生成投资报告"""
        report = {
            'summary': {
                'expected_return': f"{portfolio_data['metrics']['return']:.2%}",
                'volatility': f"{portfolio_data['metrics']['volatility']:.2%}",
                'sharpe_ratio': f"{portfolio_data['metrics']['sharpe_ratio']:.2f}",
                'max_drawdown': f"{portfolio_data['metrics']['max_drawdown']:.2%}"
            },
            'risk_analysis': {
                'var_95': f"${portfolio_data['risk_metrics']['var']['var_amount']:.2f}",
                'cvar_95': f"${portfolio_data['risk_metrics']['cvar']['cvar_amount']:.2f}"
            },
            'allocation': portfolio_data['allocation']
        }
        
        return report

def robo_advisor_example():
    """智能投顾示例"""
    config_manager = ConfigManager()
    advisor = RoboAdvisor(config_manager)
    
    # 创建投资组合
    portfolio = advisor.create_portfolio(
        risk_tolerance='moderate',
        investment_amount=100000,
        investment_horizon=10
    )
    
    # 生成报告
    report = advisor.generate_report(portfolio)
    
    print("智能投顾投资报告")
    print("=" * 50)
    
    print("\n投资组合摘要:")
    for metric, value in report['summary'].items():
        print(f"{metric}: {value}")
    
    print("\n风险分析:")
    for metric, value in report['risk_analysis'].items():
        print(f"{metric}: {value}")
    
    print("\n资产配置:")
    for asset, amount in report['allocation'].items():
        print(f"{asset}: ${amount:.2f}")
    
    return advisor, portfolio, report

# 运行示例
if __name__ == "__main__":
    print("=== 金融科技实战示例 ===")
    
    # 金融数据分析
    print("\n1. 金融数据分析")
    market_data = financial_data_analysis_example()
    
    # 投资组合分析
    print("\n2. 投资组合分析")
    analyzer, metrics = portfolio_analysis_example()
    
    # 交易策略
    print("\n3. 交易策略")
    strategy, performance = trading_strategy_example()
    
    # 风险管理
    print("\n4. 风险管理")
    risk_manager, var_result, cvar_result = risk_management_example()
    
    # 区块链
    print("\n5. 区块链")
    blockchain = blockchain_example()
    
    # 加密货币分析
    print("\n6. 加密货币分析")
    crypto_analyzer, comparison = cryptocurrency_analysis_example()
    
    # 智能投顾
    print("\n7. 智能投顾")
    advisor, portfolio, report = robo_advisor_example()
    
    print("\n金融科技实战完成！")
```

### 理论总结

金融科技是金融行业数字化转型的核心驱动力，通过数据分析、量化交易、风险管理和区块链技术，能够提升金融服务效率、降低风险、改善用户体验，为金融行业的创新发展提供技术支撑。
