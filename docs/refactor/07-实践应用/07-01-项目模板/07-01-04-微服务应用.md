# å¾®æœåŠ¡åº”ç”¨

## ğŸ“‹ æ¦‚è¿°

å¾®æœåŠ¡åº”ç”¨æ˜¯ç°ä»£åˆ†å¸ƒå¼ç³»ç»Ÿçš„é‡è¦æ¶æ„æ¨¡å¼ï¼Œæ¶‰åŠæœåŠ¡æ‹†åˆ†ã€é€šä¿¡ã€éƒ¨ç½²ç­‰æŠ€æœ¯ã€‚æœ¬æ–‡æ¡£æä¾›å¾®æœåŠ¡åº”ç”¨çš„å½¢å¼åŒ–å®šä¹‰ã€æŠ€æœ¯æ¶æ„å’Œæœ€ä½³å®è·µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 å¾®æœåŠ¡ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (å¾®æœåŠ¡ç³»ç»Ÿ)
å¾®æœåŠ¡ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $\mathcal{M} = (S, N, D, C, R, L, M)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯æœåŠ¡é›†åˆï¼Œ$S = \{s_1, s_2, \ldots, s_n\}$
- $N$ æ˜¯ç½‘ç»œå±‚ï¼Œ$N = (P, R, L)$
- $D$ æ˜¯æ•°æ®å±‚ï¼Œ$D = (DB, C, S)$
- $C$ æ˜¯é…ç½®ç®¡ç†ï¼Œ$C = (K, V, E)$
- $R$ æ˜¯æ³¨å†Œå‘ç°ï¼Œ$R = (S, H, L)$
- $L$ æ˜¯è´Ÿè½½å‡è¡¡ï¼Œ$L = (A, S, W)$
- $M$ æ˜¯ç›‘æ§ç®¡ç†ï¼Œ$M = (L, M, A)$

**å®šä¹‰ 1.2** (æœåŠ¡é€šä¿¡)
æœåŠ¡é€šä¿¡æ˜¯ä¸€ä¸ªæ˜ å°„å‡½æ•° $f: S \times S \rightarrow M$ï¼Œå…¶ä¸­ $M$ æ˜¯æ¶ˆæ¯é›†åˆã€‚

### 1.2 å¾®æœåŠ¡æ¶æ„

**å®šä¹‰ 1.3** (å¾®æœåŠ¡æ¶æ„)
å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ä¸ªåˆ†å±‚ç»“æ„ $\mathcal{A} = (L_1, L_2, L_3, L_4, L_5)$ï¼š

- $L_1$: APIç½‘å…³å±‚ (API Gateway Layer)
- $L_2$: æœåŠ¡å±‚ (Service Layer)
- $L_3$: é€šä¿¡å±‚ (Communication Layer)
- $L_4$: æ•°æ®å±‚ (Data Layer)
- $L_5$: åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)

## 2. æŠ€æœ¯å®ç°

### 2.1 å¾®æœåŠ¡æ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
import asyncio
import aiohttp
import json
import uuid
import time
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from pydantic import BaseModel
import redis
import logging

class ServiceStatus(Enum):
    """æœåŠ¡çŠ¶æ€"""
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    STARTING = "starting"
    STOPPING = "stopping"

@dataclass
class ServiceConfig:
    """æœåŠ¡é…ç½®"""
    name: str
    port: int
    host: str = "localhost"
    version: str = "1.0.0"
    health_check_interval: int = 30
    max_retries: int = 3
    timeout: int = 30

class ServiceRegistry:
    """æœåŠ¡æ³¨å†Œä¸­å¿ƒ"""
    
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis_client = redis.from_url(redis_url)
        self.services: Dict[str, Dict] = {}
    
    async def register_service(self, service_id: str, service_info: Dict) -> bool:
        """æ³¨å†ŒæœåŠ¡"""
        try:
            service_info['registered_at'] = time.time()
            service_info['last_heartbeat'] = time.time()
            
            # å­˜å‚¨åˆ°Redis
            await self.redis_client.setex(
                f"service:{service_id}",
                300,  # 5åˆ†é’Ÿè¿‡æœŸ
                json.dumps(service_info)
            )
            
            self.services[service_id] = service_info
            return True
        except Exception as e:
            logging.error(f"Failed to register service: {e}")
            return False
    
    async def unregister_service(self, service_id: str) -> bool:
        """æ³¨é”€æœåŠ¡"""
        try:
            await self.redis_client.delete(f"service:{service_id}")
            if service_id in self.services:
                del self.services[service_id]
            return True
        except Exception as e:
            logging.error(f"Failed to unregister service: {e}")
            return False
    
    async def get_service(self, service_name: str) -> Optional[Dict]:
        """è·å–æœåŠ¡ä¿¡æ¯"""
        try:
            # ä»Redisè·å–
            service_data = await self.redis_client.get(f"service:{service_name}")
            if service_data:
                return json.loads(service_data)
            
            # ä»å†…å­˜è·å–
            return self.services.get(service_name)
        except Exception as e:
            logging.error(f"Failed to get service: {e}")
            return None
    
    async def list_services(self) -> List[Dict]:
        """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
        try:
            services = []
            for key in await self.redis_client.keys("service:*"):
                service_data = await self.redis_client.get(key)
                if service_data:
                    services.append(json.loads(service_data))
            return services
        except Exception as e:
            logging.error(f"Failed to list services: {e}")
            return []
    
    async def update_heartbeat(self, service_id: str) -> bool:
        """æ›´æ–°å¿ƒè·³"""
        try:
            service_info = await self.get_service(service_id)
            if service_info:
                service_info['last_heartbeat'] = time.time()
                await self.register_service(service_id, service_info)
                return True
            return False
        except Exception as e:
            logging.error(f"Failed to update heartbeat: {e}")
            return False

class ServiceDiscovery:
    """æœåŠ¡å‘ç°"""
    
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.cache: Dict[str, Dict] = {}
        self.cache_ttl = 60  # ç¼“å­˜1åˆ†é’Ÿ
    
    async def discover_service(self, service_name: str) -> Optional[Dict]:
        """å‘ç°æœåŠ¡"""
        # æ£€æŸ¥ç¼“å­˜
        if service_name in self.cache:
            cached_service = self.cache[service_name]
            if time.time() - cached_service.get('cached_at', 0) < self.cache_ttl:
                return cached_service
        
        # ä»æ³¨å†Œä¸­å¿ƒè·å–
        service_info = await self.registry.get_service(service_name)
        if service_info:
            service_info['cached_at'] = time.time()
            self.cache[service_name] = service_info
        
        return service_info
    
    async def discover_services_by_tag(self, tag: str) -> List[Dict]:
        """æ ¹æ®æ ‡ç­¾å‘ç°æœåŠ¡"""
        all_services = await self.registry.list_services()
        return [s for s in all_services if tag in s.get('tags', [])]

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, strategy: str = "round_robin"):
        self.strategy = strategy
        self.current_index = 0
        self.service_weights: Dict[str, int] = {}
    
    def select_service(self, services: List[Dict]) -> Optional[Dict]:
        """é€‰æ‹©æœåŠ¡"""
        if not services:
            return None
        
        if self.strategy == "round_robin":
            return self._round_robin(services)
        elif self.strategy == "weighted":
            return self._weighted_round_robin(services)
        elif self.strategy == "least_connections":
            return self._least_connections(services)
        else:
            return services[0]
    
    def _round_robin(self, services: List[Dict]) -> Dict:
        """è½®è¯¢ç­–ç•¥"""
        service = services[self.current_index % len(services)]
        self.current_index += 1
        return service
    
    def _weighted_round_robin(self, services: List[Dict]) -> Dict:
        """åŠ æƒè½®è¯¢ç­–ç•¥"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è€ƒè™‘æƒé‡
        return self._round_robin(services)
    
    def _least_connections(self, services: List[Dict]) -> Dict:
        """æœ€å°‘è¿æ¥ç­–ç•¥"""
        return min(services, key=lambda s: s.get('active_connections', 0))

class CircuitBreaker:
    """ç†”æ–­å™¨"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = 0
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    def call(self, func: Callable, *args, **kwargs) -> Any:
        """è°ƒç”¨æœåŠ¡"""
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _on_success(self):
        """æˆåŠŸå›è°ƒ"""
        self.failure_count = 0
        self.state = "CLOSED"
    
    def _on_failure(self):
        """å¤±è´¥å›è°ƒ"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"

class Microservice:
    """å¾®æœåŠ¡åŸºç±»"""
    
    def __init__(self, config: ServiceConfig):
        self.config = config
        self.app = FastAPI(title=config.name, version=config.version)
        self.service_id = str(uuid.uuid4())
        self.status = ServiceStatus.STARTING
        self.registry = None
        self.discovery = None
        self.load_balancer = LoadBalancer()
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}
        
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """è®¾ç½®ä¸­é—´ä»¶"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        @self.app.get("/health")
        async def health_check():
            return {
                "status": self.status.value,
                "service_id": self.service_id,
                "timestamp": time.time()
            }
        
        @self.app.get("/info")
        async def service_info():
            return {
                "name": self.config.name,
                "version": self.config.version,
                "host": self.config.host,
                "port": self.config.port
            }
    
    async def register(self, registry: ServiceRegistry):
        """æ³¨å†ŒæœåŠ¡"""
        self.registry = registry
        service_info = {
            "name": self.config.name,
            "host": self.config.host,
            "port": self.config.port,
            "version": self.config.version,
            "status": self.status.value,
            "service_id": self.service_id
        }
        
        success = await registry.register_service(self.service_id, service_info)
        if success:
            self.status = ServiceStatus.HEALTHY
            logging.info(f"Service {self.config.name} registered successfully")
        else:
            logging.error(f"Failed to register service {self.config.name}")
    
    async def unregister(self):
        """æ³¨é”€æœåŠ¡"""
        if self.registry:
            await self.registry.unregister_service(self.service_id)
            self.status = ServiceStatus.STOPPING
    
    async def start(self):
        """å¯åŠ¨æœåŠ¡"""
        try:
            self.status = ServiceStatus.HEALTHY
            config = uvicorn.Config(
                self.app,
                host=self.config.host,
                port=self.config.port,
                log_level="info"
            )
            server = uvicorn.Server(config)
            await server.serve()
        except Exception as e:
            self.status = ServiceStatus.UNHEALTHY
            logging.error(f"Failed to start service: {e}")
            raise
    
    async def call_service(self, service_name: str, method: str, 
                          path: str, data: Dict = None) -> Dict:
        """è°ƒç”¨å…¶ä»–æœåŠ¡"""
        # è·å–æœåŠ¡ä¿¡æ¯
        service_info = await self.discovery.discover_service(service_name)
        if not service_info:
            raise Exception(f"Service {service_name} not found")
        
        # åˆ›å»ºæˆ–è·å–ç†”æ–­å™¨
        if service_name not in self.circuit_breakers:
            self.circuit_breakers[service_name] = CircuitBreaker()
        
        circuit_breaker = self.circuit_breakers[service_name]
        
        # æ„å»ºè¯·æ±‚URL
        url = f"http://{service_info['host']}:{service_info['port']}{path}"
        
        # é€šè¿‡ç†”æ–­å™¨è°ƒç”¨
        return circuit_breaker.call(self._make_request, method, url, data)
    
    async def _make_request(self, method: str, url: str, data: Dict = None) -> Dict:
        """å‘é€HTTPè¯·æ±‚"""
        async with aiohttp.ClientSession() as session:
            if method.upper() == "GET":
                async with session.get(url) as response:
                    return await response.json()
            elif method.upper() == "POST":
                async with session.post(url, json=data) as response:
                    return await response.json()
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
```

### 2.2 ç”¨æˆ·æœåŠ¡å®ç°

```python
class UserService(Microservice):
    """ç”¨æˆ·æœåŠ¡"""
    
    def __init__(self):
        config = ServiceConfig(
            name="user-service",
            port=8001,
            version="1.0.0"
        )
        super().__init__(config)
        self.users: Dict[str, Dict] = {}
        self.setup_user_routes()
    
    def setup_user_routes(self):
        """è®¾ç½®ç”¨æˆ·ç›¸å…³è·¯ç”±"""
        @self.app.post("/users")
        async def create_user(user_data: Dict):
            user_id = str(uuid.uuid4())
            user = {
                "id": user_id,
                "name": user_data["name"],
                "email": user_data["email"],
                "created_at": time.time()
            }
            self.users[user_id] = user
            return user
        
        @self.app.get("/users/{user_id}")
        async def get_user(user_id: str):
            if user_id not in self.users:
                raise HTTPException(status_code=404, detail="User not found")
            return self.users[user_id]
        
        @self.app.get("/users")
        async def list_users():
            return list(self.users.values())
        
        @self.app.put("/users/{user_id}")
        async def update_user(user_id: str, user_data: Dict):
            if user_id not in self.users:
                raise HTTPException(status_code=404, detail="User not found")
            
            self.users[user_id].update(user_data)
            return self.users[user_id]
        
        @self.app.delete("/users/{user_id}")
        async def delete_user(user_id: str):
            if user_id not in self.users:
                raise HTTPException(status_code=404, detail="User not found")
            
            del self.users[user_id]
            return {"message": "User deleted successfully"}

class OrderService(Microservice):
    """è®¢å•æœåŠ¡"""
    
    def __init__(self):
        config = ServiceConfig(
            name="order-service",
            port=8002,
            version="1.0.0"
        )
        super().__init__(config)
        self.orders: Dict[str, Dict] = {}
        self.setup_order_routes()
    
    def setup_order_routes(self):
        """è®¾ç½®è®¢å•ç›¸å…³è·¯ç”±"""
        @self.app.post("/orders")
        async def create_order(order_data: Dict):
            order_id = str(uuid.uuid4())
            order = {
                "id": order_id,
                "user_id": order_data["user_id"],
                "items": order_data["items"],
                "total": order_data["total"],
                "status": "pending",
                "created_at": time.time()
            }
            self.orders[order_id] = order
            return order
        
        @self.app.get("/orders/{order_id}")
        async def get_order(order_id: str):
            if order_id not in self.orders:
                raise HTTPException(status_code=404, detail="Order not found")
            return self.orders[order_id]
        
        @self.app.get("/orders/user/{user_id}")
        async def get_user_orders(user_id: str):
            user_orders = [
                order for order in self.orders.values() 
                if order["user_id"] == user_id
            ]
            return user_orders
        
        @self.app.put("/orders/{order_id}/status")
        async def update_order_status(order_id: str, status_data: Dict):
            if order_id not in self.orders:
                raise HTTPException(status_code=404, detail="Order not found")
            
            self.orders[order_id]["status"] = status_data["status"]
            return self.orders[order_id]

class ProductService(Microservice):
    """äº§å“æœåŠ¡"""
    
    def __init__(self):
        config = ServiceConfig(
            name="product-service",
            port=8003,
            version="1.0.0"
        )
        super().__init__(config)
        self.products: Dict[str, Dict] = {}
        self.setup_product_routes()
    
    def setup_product_routes(self):
        """è®¾ç½®äº§å“ç›¸å…³è·¯ç”±"""
        @self.app.post("/products")
        async def create_product(product_data: Dict):
            product_id = str(uuid.uuid4())
            product = {
                "id": product_id,
                "name": product_data["name"],
                "price": product_data["price"],
                "description": product_data.get("description", ""),
                "stock": product_data.get("stock", 0),
                "created_at": time.time()
            }
            self.products[product_id] = product
            return product
        
        @self.app.get("/products/{product_id}")
        async def get_product(product_id: str):
            if product_id not in self.products:
                raise HTTPException(status_code=404, detail="Product not found")
            return self.products[product_id]
        
        @self.app.get("/products")
        async def list_products():
            return list(self.products.values())
        
        @self.app.put("/products/{product_id}/stock")
        async def update_stock(product_id: str, stock_data: Dict):
            if product_id not in self.products:
                raise HTTPException(status_code=404, detail="Product not found")
            
            self.products[product_id]["stock"] = stock_data["stock"]
            return self.products[product_id]
```

### 2.3 APIç½‘å…³

```python
class APIGateway:
    """APIç½‘å…³"""
    
    def __init__(self, port: int = 8000):
        self.app = FastAPI(title="API Gateway", version="1.0.0")
        self.port = port
        self.registry = ServiceRegistry()
        self.discovery = ServiceDiscovery(self.registry)
        self.load_balancer = LoadBalancer()
        
        self.setup_routes()
    
    def setup_routes(self):
        """è®¾ç½®ç½‘å…³è·¯ç”±"""
        @self.app.get("/")
        async def root():
            return {"message": "API Gateway", "status": "running"}
        
        @self.app.get("/users/{path:path}")
        async def user_routes(path: str, request: Request):
            return await self._proxy_request("user-service", request)
        
        @self.app.post("/users/{path:path}")
        async def user_post_routes(path: str, request: Request):
            return await self._proxy_request("user-service", request)
        
        @self.app.get("/orders/{path:path}")
        async def order_routes(path: str, request: Request):
            return await self._proxy_request("order-service", request)
        
        @self.app.post("/orders/{path:path}")
        async def order_post_routes(path: str, request: Request):
            return await self._proxy_request("order-service", request)
        
        @self.app.get("/products/{path:path}")
        async def product_routes(path: str, request: Request):
            return await self._proxy_request("product-service", request)
        
        @self.app.post("/products/{path:path}")
        async def product_post_routes(path: str, request: Request):
            return await self._proxy_request("product-service", request)
    
    async def _proxy_request(self, service_name: str, request: Request):
        """ä»£ç†è¯·æ±‚åˆ°ç›®æ ‡æœåŠ¡"""
        # å‘ç°æœåŠ¡
        service_info = await self.discovery.discover_service(service_name)
        if not service_info:
            raise HTTPException(status_code=503, detail=f"Service {service_name} unavailable")
        
        # æ„å»ºç›®æ ‡URL
        target_url = f"http://{service_info['host']}:{service_info['port']}{request.url.path}"
        
        # è½¬å‘è¯·æ±‚
        async with aiohttp.ClientSession() as session:
            method = request.method
            headers = dict(request.headers)
            
            if method == "GET":
                async with session.get(target_url, headers=headers) as response:
                    return await response.json()
            elif method == "POST":
                body = await request.body()
                async with session.post(target_url, headers=headers, data=body) as response:
                    return await response.json()
            else:
                raise HTTPException(status_code=405, detail="Method not allowed")
    
    async def start(self):
        """å¯åŠ¨ç½‘å…³"""
        config = uvicorn.Config(
            self.app,
            host="0.0.0.0",
            port=self.port,
            log_level="info"
        )
        server = uvicorn.Server(config)
        await server.serve()
```

## 3. å®é™…åº”ç”¨ç¤ºä¾‹

### 3.1 å®Œæ•´çš„å¾®æœåŠ¡åº”ç”¨

```python
class MicroserviceApplication:
    """å®Œæ•´çš„å¾®æœåŠ¡åº”ç”¨"""
    
    def __init__(self):
        self.services: List[Microservice] = []
        self.gateway = None
        self.registry = ServiceRegistry()
        
        self.setup_services()
    
    def setup_services(self):
        """è®¾ç½®æœåŠ¡"""
        # åˆ›å»ºæœåŠ¡å®ä¾‹
        user_service = UserService()
        order_service = OrderService()
        product_service = ProductService()
        
        # è®¾ç½®æœåŠ¡å‘ç°
        user_service.discovery = ServiceDiscovery(self.registry)
        order_service.discovery = ServiceDiscovery(self.registry)
        product_service.discovery = ServiceDiscovery(self.registry)
        
        self.services = [user_service, order_service, product_service]
        self.gateway = APIGateway()
    
    async def start_all_services(self):
        """å¯åŠ¨æ‰€æœ‰æœåŠ¡"""
        # å¯åŠ¨æ³¨å†Œä¸­å¿ƒ
        logging.info("Starting service registry...")
        
        # æ³¨å†Œæ‰€æœ‰æœåŠ¡
        for service in self.services:
            await service.register(self.registry)
        
        # å¯åŠ¨æœåŠ¡
        service_tasks = []
        for service in self.services:
            task = asyncio.create_task(service.start())
            service_tasks.append(task)
        
        # å¯åŠ¨ç½‘å…³
        gateway_task = asyncio.create_task(self.gateway.start())
        
        # ç­‰å¾…æ‰€æœ‰æœåŠ¡å¯åŠ¨
        try:
            await asyncio.gather(*service_tasks, gateway_task)
        except KeyboardInterrupt:
            logging.info("Shutting down services...")
            await self.shutdown()
    
    async def shutdown(self):
        """å…³é—­æ‰€æœ‰æœåŠ¡"""
        for service in self.services:
            await service.unregister()
    
    async def test_services(self):
        """æµ‹è¯•æœåŠ¡"""
        # æµ‹è¯•ç”¨æˆ·æœåŠ¡
        async with aiohttp.ClientSession() as session:
            # åˆ›å»ºç”¨æˆ·
            user_data = {"name": "John Doe", "email": "john@example.com"}
            async with session.post("http://localhost:8000/users", json=user_data) as response:
                user = await response.json()
                user_id = user["id"]
                print(f"Created user: {user}")
            
            # åˆ›å»ºäº§å“
            product_data = {"name": "Laptop", "price": 999.99, "stock": 10}
            async with session.post("http://localhost:8000/products", json=product_data) as response:
                product = await response.json()
                product_id = product["id"]
                print(f"Created product: {product}")
            
            # åˆ›å»ºè®¢å•
            order_data = {
                "user_id": user_id,
                "items": [{"product_id": product_id, "quantity": 1}],
                "total": 999.99
            }
            async with session.post("http://localhost:8000/orders", json=order_data) as response:
                order = await response.json()
                print(f"Created order: {order}")
            
            # è·å–ç”¨æˆ·è®¢å•
            async with session.get(f"http://localhost:8000/orders/user/{user_id}") as response:
                orders = await response.json()
                print(f"User orders: {orders}")

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    """ä¸»å‡½æ•°"""
    app = MicroserviceApplication()
    
    # å¯åŠ¨æ‰€æœ‰æœåŠ¡
    await app.start_all_services()

if __name__ == "__main__":
    asyncio.run(main())
```

## 4. æ€»ç»“

### 4.1 æŠ€æœ¯è¦ç‚¹

1. **æœåŠ¡æ‹†åˆ†**: æŒ‰ä¸šåŠ¡é¢†åŸŸæ‹†åˆ†æœåŠ¡
2. **æœåŠ¡æ³¨å†Œå‘ç°**: åŠ¨æ€æœåŠ¡æ³¨å†Œå’Œå‘ç°æœºåˆ¶
3. **è´Ÿè½½å‡è¡¡**: å¤šç§è´Ÿè½½å‡è¡¡ç­–ç•¥
4. **ç†”æ–­å™¨**: æ•…éšœéš”ç¦»å’Œæ¢å¤æœºåˆ¶
5. **APIç½‘å…³**: ç»Ÿä¸€å…¥å£å’Œè·¯ç”±ç®¡ç†

### 4.2 æœ€ä½³å®è·µ

1. **æœåŠ¡è®¾è®¡**: å•ä¸€èŒè´£åŸåˆ™ï¼ŒæœåŠ¡é—´æ¾è€¦åˆ
2. **æ•°æ®ç®¡ç†**: æ¯ä¸ªæœåŠ¡ç‹¬ç«‹çš„æ•°æ®å­˜å‚¨
3. **é€šä¿¡æœºåˆ¶**: å¼‚æ­¥é€šä¿¡å’Œäº‹ä»¶é©±åŠ¨
4. **ç›‘æ§å‘Šè­¦**: å®Œå–„çš„ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ
5. **éƒ¨ç½²ç­–ç•¥**: å®¹å™¨åŒ–éƒ¨ç½²å’Œæ»šåŠ¨æ›´æ–°

### 4.3 æ‰©å±•æ–¹å‘

1. **æœåŠ¡ç½‘æ ¼**: Istioç­‰æœåŠ¡ç½‘æ ¼æŠ€æœ¯
2. **äº‹ä»¶æº¯æº**: äº‹ä»¶é©±åŠ¨çš„æ•°æ®ç®¡ç†
3. **CQRS**: å‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»
4. **åˆ†å¸ƒå¼äº‹åŠ¡**: Sagaæ¨¡å¼ç­‰äº‹åŠ¡ç®¡ç†
5. **æ··æ²Œå·¥ç¨‹**: ç³»ç»ŸéŸ§æ€§æµ‹è¯•

---

**ç›¸å…³æ–‡æ¡£**:
- [Webåº”ç”¨å¼€å‘](./07-01-01-Webåº”ç”¨å¼€å‘.md)
- [ç§»åŠ¨åº”ç”¨å¼€å‘](./07-01-02-ç§»åŠ¨åº”ç”¨å¼€å‘.md)
- [æ¡Œé¢åº”ç”¨å¼€å‘](./07-01-03-æ¡Œé¢åº”ç”¨å¼€å‘.md) 