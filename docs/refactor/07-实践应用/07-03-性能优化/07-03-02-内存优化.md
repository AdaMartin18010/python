# å†…å­˜ä¼˜åŒ–

## ğŸ“‹ æ¦‚è¿°

å†…å­˜ä¼˜åŒ–æ˜¯æ€§èƒ½ä¼˜åŒ–çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œæ¶‰åŠå†…å­˜ç®¡ç†ã€åƒåœ¾å›æ”¶ã€å†…å­˜æ± åŒ–ã€å†…å­˜æ³„æ¼æ£€æµ‹ç­‰æŠ€æœ¯ã€‚æœ¬æ–‡æ¡£æä¾›å†…å­˜ä¼˜åŒ–çš„å½¢å¼åŒ–å®šä¹‰ã€æŠ€æœ¯å®ç°å’Œæœ€ä½³å®è·µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 å†…å­˜ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (å†…å­˜ç³»ç»Ÿ)
å†…å­˜ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{M} = (A, F, G, P, O)$ï¼Œå…¶ä¸­ï¼š

- $A$ æ˜¯å†…å­˜åˆ†é…ï¼Œ$A = (R, S, T)$
- $F$ æ˜¯å†…å­˜é‡Šæ”¾ï¼Œ$F = (D, C, R)$
- $G$ æ˜¯åƒåœ¾å›æ”¶ï¼Œ$G = (M, S, C)$
- $P$ æ˜¯å†…å­˜æ± åŒ–ï¼Œ$P = (I, R, M)$
- $O$ æ˜¯å†…å­˜ä¼˜åŒ–ï¼Œ$O = (L, C, P)$

**å®šä¹‰ 1.2** (å†…å­˜ä½¿ç”¨æ¨¡å¼)
å†…å­˜ä½¿ç”¨æ¨¡å¼æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{U} = (A, L, F)$ï¼Œå…¶ä¸­ï¼š

- $A$ æ˜¯åˆ†é…æ¨¡å¼ï¼Œ$A = (S, F, T)$
- $L$ æ˜¯ç”Ÿå‘½å‘¨æœŸï¼Œ$L = (C, D, R)$
- $F$ æ˜¯ç¢ç‰‡åŒ–ï¼Œ$F = (I, E, C)$

### 1.2 å†…å­˜ä¼˜åŒ–ç­–ç•¥

**å®šä¹‰ 1.3** (å†…å­˜ä¼˜åŒ–ç­–ç•¥)
å†…å­˜ä¼˜åŒ–ç­–ç•¥æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{O} = (P, C, L, M)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯æ± åŒ–ç­–ç•¥ï¼Œ$P = (I, R, M)$
- $C$ æ˜¯ç¼“å­˜ç­–ç•¥ï¼Œ$C = (S, T, R)$
- $L$ æ˜¯ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œ$L = (C, D, R)$
- $M$ æ˜¯å†…å­˜æ˜ å°„ï¼Œ$M = (F, P, S)$

## 2. æŠ€æœ¯å®ç°

### 2.1 å†…å­˜ç›‘æ§ç³»ç»Ÿ

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Callable, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import psutil
import tracemalloc
import gc
import sys
import time
import threading
import weakref
from collections import defaultdict, deque
import logging

class MemoryMetric(Enum):
    """å†…å­˜æŒ‡æ ‡ç±»å‹"""
    USED = "used"
    AVAILABLE = "available"
    PERCENT = "percent"
    CACHED = "cached"
    BUFFERS = "buffers"

@dataclass
class MemorySnapshot:
    """å†…å­˜å¿«ç…§"""
    timestamp: float
    used_memory: int
    available_memory: int
    total_memory: int
    memory_percent: float
    object_count: int
    gc_stats: Dict[str, Any] = field(default_factory=dict)

@dataclass
class MemoryLeak:
    """å†…å­˜æ³„æ¼"""
    object_type: str
    count: int
    size: int
    traceback: List[str]
    first_seen: float
    last_seen: float

class MemoryMonitor:
    """å†…å­˜ç›‘æ§å™¨"""
    
    def __init__(self):
        self.snapshots: List[MemorySnapshot] = []
        self.leaks: Dict[str, MemoryLeak] = {}
        self.monitoring = False
        self.monitor_thread = None
        
    def start_monitoring(self, interval: float = 1.0):
        """å¼€å§‹ç›‘æ§"""
        if self.monitoring:
            return
        
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, args=(interval,))
        self.monitor_thread.daemon = True
        self.monitor_thread.start()
        
        logging.info("Memory monitoring started")
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join()
        
        logging.info("Memory monitoring stopped")
    
    def _monitor_loop(self, interval: float):
        """ç›‘æ§å¾ªç¯"""
        while self.monitoring:
            self.take_snapshot()
            time.sleep(interval)
    
    def take_snapshot(self) -> MemorySnapshot:
        """è·å–å†…å­˜å¿«ç…§"""
        # è·å–ç³»ç»Ÿå†…å­˜ä¿¡æ¯
        memory = psutil.virtual_memory()
        
        # è·å–Pythonå¯¹è±¡ç»Ÿè®¡
        object_count = len(gc.get_objects())
        
        # è·å–åƒåœ¾å›æ”¶ç»Ÿè®¡
        gc_stats = {
            "collections": gc.get_stats(),
            "counts": gc.get_count(),
            "thresholds": gc.get_threshold()
        }
        
        snapshot = MemorySnapshot(
            timestamp=time.time(),
            used_memory=memory.used,
            available_memory=memory.available,
            total_memory=memory.total,
            memory_percent=memory.percent,
            object_count=object_count,
            gc_stats=gc_stats
        )
        
        self.snapshots.append(snapshot)
        return snapshot
    
    def detect_memory_leaks(self) -> List[MemoryLeak]:
        """æ£€æµ‹å†…å­˜æ³„æ¼"""
        if len(self.snapshots) < 2:
            return []
        
        leaks = []
        
        # åˆ†æå†…å­˜å¢é•¿è¶‹åŠ¿
        recent_snapshots = self.snapshots[-10:]  # æœ€è¿‘10ä¸ªå¿«ç…§
        
        if len(recent_snapshots) >= 2:
            first = recent_snapshots[0]
            last = recent_snapshots[-1]
            
            # è®¡ç®—å†…å­˜å¢é•¿ç‡
            memory_growth = (last.used_memory - first.used_memory) / first.used_memory
            object_growth = (last.object_count - first.object_count) / first.object_count
            
            if memory_growth > 0.1:  # å†…å­˜å¢é•¿è¶…è¿‡10%
                leak = MemoryLeak(
                    object_type="unknown",
                    count=last.object_count - first.object_count,
                    size=last.used_memory - first.used_memory,
                    traceback=[],
                    first_seen=first.timestamp,
                    last_seen=last.timestamp
                )
                leaks.append(leak)
        
        return leaks
    
    def get_memory_report(self) -> Dict[str, Any]:
        """è·å–å†…å­˜æŠ¥å‘Š"""
        if not self.snapshots:
            return {}
        
        latest = self.snapshots[-1]
        first = self.snapshots[0]
        
        return {
            "current_memory": {
                "used_mb": latest.used_memory / 1024 / 1024,
                "available_mb": latest.available_memory / 1024 / 1024,
                "total_mb": latest.total_memory / 1024 / 1024,
                "percent": latest.memory_percent
            },
            "memory_growth": {
                "total_growth_mb": (latest.used_memory - first.used_memory) / 1024 / 1024,
                "growth_percent": (latest.used_memory - first.used_memory) / first.used_memory * 100
            },
            "object_stats": {
                "current_objects": latest.object_count,
                "object_growth": latest.object_count - first.object_count
            },
            "gc_stats": latest.gc_stats
        }

class MemoryProfiler:
    """å†…å­˜åˆ†æå™¨"""
    
    def __init__(self):
        self.tracemalloc_enabled = False
        self.snapshots = []
    
    def start_tracemalloc(self):
        """å¯åŠ¨å†…å­˜è·Ÿè¸ª"""
        if not self.tracemalloc_enabled:
            tracemalloc.start()
            self.tracemalloc_enabled = True
    
    def stop_tracemalloc(self):
        """åœæ­¢å†…å­˜è·Ÿè¸ª"""
        if self.tracemalloc_enabled:
            tracemalloc.stop()
            self.tracemalloc_enabled = False
    
    def take_tracemalloc_snapshot(self):
        """è·å–å†…å­˜è·Ÿè¸ªå¿«ç…§"""
        if not self.tracemalloc_enabled:
            self.start_tracemalloc()
        
        snapshot = tracemalloc.take_snapshot()
        self.snapshots.append(snapshot)
        return snapshot
    
    def compare_snapshots(self, snapshot1_index: int = -2, snapshot2_index: int = -1) -> Dict[str, Any]:
        """æ¯”è¾ƒä¸¤ä¸ªå¿«ç…§"""
        if len(self.snapshots) < 2:
            return {}
        
        snapshot1 = self.snapshots[snapshot1_index]
        snapshot2 = self.snapshots[snapshot2_index]
        
        # è®¡ç®—å·®å¼‚
        top_stats = snapshot2.compare_to(snapshot1, 'lineno')
        
        return {
            "top_changes": [
                {
                    "file": stat.traceback.format()[-1],
                    "size_diff": stat.size_diff,
                    "count_diff": stat.count_diff
                }
                for stat in top_stats[:10]
            ]
        }
    
    def get_top_allocations(self, limit: int = 10) -> List[Dict[str, Any]]:
        """è·å–å†…å­˜åˆ†é…æœ€å¤šçš„ä½ç½®"""
        if not self.snapshots:
            return []
        
        latest_snapshot = self.snapshots[-1]
        top_stats = latest_snapshot.statistics('lineno')
        
        return [
            {
                "file": stat.traceback.format()[-1],
                "size": stat.size,
                "count": stat.count,
                "average_size": stat.size / stat.count if stat.count > 0 else 0
            }
            for stat in top_stats[:limit]
        ]

### 2.2 å†…å­˜æ± åŒ–ç³»ç»Ÿ

```python
class MemoryPool:
    """å†…å­˜æ± """
    
    def __init__(self, block_size: int, max_blocks: int = 1000):
        self.block_size = block_size
        self.max_blocks = max_blocks
        self.available_blocks = deque()
        self.used_blocks = set()
        self.total_allocated = 0
    
    def allocate(self) -> Optional[bytearray]:
        """åˆ†é…å†…å­˜å—"""
        if self.available_blocks:
            block = self.available_blocks.popleft()
        elif self.total_allocated < self.max_blocks:
            block = bytearray(self.block_size)
            self.total_allocated += 1
        else:
            return None
        
        self.used_blocks.add(id(block))
        return block
    
    def deallocate(self, block: bytearray):
        """é‡Šæ”¾å†…å­˜å—"""
        if id(block) in self.used_blocks:
            self.used_blocks.remove(id(block))
            block.clear()  # æ¸…ç©ºå†…å®¹
            self.available_blocks.append(block)
    
    def get_stats(self) -> Dict[str, Any]:
        """è·å–æ± ç»Ÿè®¡ä¿¡æ¯"""
        return {
            "block_size": self.block_size,
            "total_blocks": self.total_allocated,
            "used_blocks": len(self.used_blocks),
            "available_blocks": len(self.available_blocks),
            "utilization": len(self.used_blocks) / self.total_allocated if self.total_allocated > 0 else 0
        }

class MemoryPoolManager:
    """å†…å­˜æ± ç®¡ç†å™¨"""
    
    def __init__(self):
        self.pools: Dict[int, MemoryPool] = {}
        self.default_sizes = [64, 128, 256, 512, 1024, 2048, 4096]
        
        # åˆå§‹åŒ–é»˜è®¤æ± 
        for size in self.default_sizes:
            self.pools[size] = MemoryPool(size)
    
    def allocate(self, size: int) -> Optional[bytearray]:
        """åˆ†é…å†…å­˜"""
        # æ‰¾åˆ°åˆé€‚çš„æ± å¤§å°
        pool_size = self._find_suitable_pool_size(size)
        
        if pool_size in self.pools:
            return self.pools[pool_size].allocate()
        
        # å¦‚æœæ²¡æœ‰åˆé€‚çš„æ± ï¼Œåˆ›å»ºæ–°çš„
        self.pools[size] = MemoryPool(size)
        return self.pools[size].allocate()
    
    def deallocate(self, block: bytearray):
        """é‡Šæ”¾å†…å­˜"""
        block_size = len(block)
        
        if block_size in self.pools:
            self.pools[block_size].deallocate(block)
    
    def _find_suitable_pool_size(self, size: int) -> int:
        """æ‰¾åˆ°åˆé€‚çš„æ± å¤§å°"""
        for pool_size in sorted(self.pools.keys()):
            if pool_size >= size:
                return pool_size
        return size
    
    def get_all_stats(self) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰æ± çš„ç»Ÿè®¡ä¿¡æ¯"""
        stats = {}
        total_used = 0
        total_allocated = 0
        
        for size, pool in self.pools.items():
            pool_stats = pool.get_stats()
            stats[f"pool_{size}"] = pool_stats
            total_used += pool_stats["used_blocks"] * size
            total_allocated += pool_stats["total_blocks"] * size
        
        stats["overall"] = {
            "total_used_memory": total_used,
            "total_allocated_memory": total_allocated,
            "memory_efficiency": total_used / total_allocated if total_allocated > 0 else 0
        }
        
        return stats

### 2.3 åƒåœ¾å›æ”¶ä¼˜åŒ–

```python
class GarbageCollectionOptimizer:
    """åƒåœ¾å›æ”¶ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.original_thresholds = gc.get_threshold()
        self.optimization_history = []
    
    def optimize_gc_thresholds(self, memory_pressure: float) -> Dict[str, Any]:
        """ä¼˜åŒ–åƒåœ¾å›æ”¶é˜ˆå€¼"""
        # æ ¹æ®å†…å­˜å‹åŠ›è°ƒæ•´é˜ˆå€¼
        if memory_pressure > 0.8:  # é«˜å†…å­˜å‹åŠ›
            new_thresholds = (
                max(1, self.original_thresholds[0] // 2),  # å‡å°‘ç¬¬0ä»£é˜ˆå€¼
                max(1, self.original_thresholds[1] // 2),  # å‡å°‘ç¬¬1ä»£é˜ˆå€¼
                max(1, self.original_thresholds[2] // 2)   # å‡å°‘ç¬¬2ä»£é˜ˆå€¼
            )
        elif memory_pressure < 0.3:  # ä½å†…å­˜å‹åŠ›
            new_thresholds = (
                self.original_thresholds[0] * 2,  # å¢åŠ ç¬¬0ä»£é˜ˆå€¼
                self.original_thresholds[1] * 2,  # å¢åŠ ç¬¬1ä»£é˜ˆå€¼
                self.original_thresholds[2] * 2   # å¢åŠ ç¬¬2ä»£é˜ˆå€¼
            )
        else:
            new_thresholds = self.original_thresholds
        
        # è®¾ç½®æ–°é˜ˆå€¼
        gc.set_threshold(*new_thresholds)
        
        optimization = {
            "memory_pressure": memory_pressure,
            "original_thresholds": self.original_thresholds,
            "new_thresholds": new_thresholds,
            "timestamp": time.time()
        }
        
        self.optimization_history.append(optimization)
        return optimization
    
    def force_garbage_collection(self) -> Dict[str, Any]:
        """å¼ºåˆ¶åƒåœ¾å›æ”¶"""
        # è·å–å›æ”¶å‰çš„ç»Ÿè®¡
        before_stats = gc.get_stats()
        before_counts = gc.get_count()
        
        # æ‰§è¡Œåƒåœ¾å›æ”¶
        collected = gc.collect()
        
        # è·å–å›æ”¶åçš„ç»Ÿè®¡
        after_stats = gc.get_stats()
        after_counts = gc.get_count()
        
        return {
            "objects_collected": collected,
            "before_stats": before_stats,
            "after_stats": after_stats,
            "before_counts": before_counts,
            "after_counts": after_counts,
            "timestamp": time.time()
        }
    
    def analyze_gc_performance(self) -> Dict[str, Any]:
        """åˆ†æåƒåœ¾å›æ”¶æ€§èƒ½"""
        stats = gc.get_stats()
        
        total_collections = sum(stat["collections"] for stat in stats)
        total_time = sum(stat["collections"] * stat["avg_time"] for stat in stats)
        
        return {
            "total_collections": total_collections,
            "total_time": total_time,
            "average_time_per_collection": total_time / total_collections if total_collections > 0 else 0,
            "generation_stats": stats
        }
    
    def restore_original_thresholds(self):
        """æ¢å¤åŸå§‹é˜ˆå€¼"""
        gc.set_threshold(*self.original_thresholds)

### 2.4 å†…å­˜æ³„æ¼æ£€æµ‹

```python
class MemoryLeakDetector:
    """å†…å­˜æ³„æ¼æ£€æµ‹å™¨"""
    
    def __init__(self):
        self.object_tracker = weakref.WeakSet()
        self.leak_suspicious = defaultdict(int)
        self.detection_history = []
    
    def track_object(self, obj: Any, obj_type: str = None):
        """è·Ÿè¸ªå¯¹è±¡"""
        if obj_type is None:
            obj_type = type(obj).__name__
        
        # ä½¿ç”¨å¼±å¼•ç”¨è·Ÿè¸ªå¯¹è±¡
        weak_ref = weakref.ref(obj, lambda ref: self._object_finalized(obj_type))
        self.object_tracker.add(weak_ref)
    
    def _object_finalized(self, obj_type: str):
        """å¯¹è±¡è¢«åƒåœ¾å›æ”¶æ—¶çš„å›è°ƒ"""
        # å‡å°‘å¯ç–‘è®¡æ•°
        if obj_type in self.leak_suspicious:
            self.leak_suspicious[obj_type] = max(0, self.leak_suspicious[obj_type] - 1)
    
    def check_for_leaks(self) -> List[Dict[str, Any]]:
        """æ£€æŸ¥å†…å­˜æ³„æ¼"""
        leaks = []
        
        # è·å–å½“å‰å¯¹è±¡ç»Ÿè®¡
        objects = gc.get_objects()
        type_counts = defaultdict(int)
        
        for obj in objects:
            obj_type = type(obj).__name__
            type_counts[obj_type] += 1
        
        # æ£€æŸ¥å¯ç–‘çš„å¯¹è±¡ç±»å‹
        for obj_type, count in type_counts.items():
            if count > 1000:  # å¯¹è±¡æ•°é‡è¿‡å¤š
                self.leak_suspicious[obj_type] += 1
                
                if self.leak_suspicious[obj_type] > 5:  # è¿ç»­å¤šæ¬¡æ£€æµ‹åˆ°
                    leak_info = {
                        "object_type": obj_type,
                        "count": count,
                        "suspicious_level": self.leak_suspicious[obj_type],
                        "timestamp": time.time()
                    }
                    leaks.append(leak_info)
        
        self.detection_history.append({
            "timestamp": time.time(),
            "total_objects": len(objects),
            "leaks_found": len(leaks)
        })
        
        return leaks
    
    def get_leak_report(self) -> Dict[str, Any]:
        """è·å–æ³„æ¼æŠ¥å‘Š"""
        return {
            "suspicious_objects": dict(self.leak_suspicious),
            "detection_history": self.detection_history,
            "current_leaks": self.check_for_leaks()
        }

# ä½¿ç”¨ç¤ºä¾‹
def main():
    """ä¸»å‡½æ•°"""
    # åˆ›å»ºå†…å­˜ç›‘æ§ç³»ç»Ÿ
    monitor = MemoryMonitor()
    profiler = MemoryProfiler()
    pool_manager = MemoryPoolManager()
    gc_optimizer = GarbageCollectionOptimizer()
    leak_detector = MemoryLeakDetector()
    
    # å¼€å§‹ç›‘æ§
    monitor.start_monitoring(interval=2.0)
    profiler.start_tracemalloc()
    
    print("Memory optimization system started...")
    
    # æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨
    objects = []
    for i in range(1000):
        # åˆ†é…å†…å­˜
        obj = bytearray(1024)  # 1KBå¯¹è±¡
        objects.append(obj)
        
        # è·Ÿè¸ªå¯¹è±¡
        leak_detector.track_object(obj, "bytearray")
        
        # æ¯100ä¸ªå¯¹è±¡æ£€æŸ¥ä¸€æ¬¡
        if i % 100 == 0:
            # è·å–å†…å­˜æŠ¥å‘Š
            memory_report = monitor.get_memory_report()
            print(f"Memory usage: {memory_report['current_memory']['used_mb']:.2f} MB")
            
            # æ£€æŸ¥æ³„æ¼
            leaks = leak_detector.check_for_leaks()
            if leaks:
                print(f"Potential leaks detected: {len(leaks)}")
            
            # ä¼˜åŒ–åƒåœ¾å›æ”¶
            memory_pressure = memory_report['current_memory']['percent'] / 100
            gc_optimization = gc_optimizer.optimize_gc_thresholds(memory_pressure)
    
    # é‡Šæ”¾éƒ¨åˆ†å¯¹è±¡
    for i in range(500):
        objects.pop()
    
    # å¼ºåˆ¶åƒåœ¾å›æ”¶
    gc_result = gc_optimizer.force_garbage_collection()
    print(f"Garbage collection collected {gc_result['objects_collected']} objects")
    
    # è·å–æœ€ç»ˆæŠ¥å‘Š
    final_report = monitor.get_memory_report()
    leak_report = leak_detector.get_leak_report()
    pool_stats = pool_manager.get_all_stats()
    
    print("\nFinal Memory Report:")
    print(f"Memory usage: {final_report['current_memory']['used_mb']:.2f} MB")
    print(f"Memory growth: {final_report['memory_growth']['growth_percent']:.2f}%")
    print(f"Object count: {final_report['object_stats']['current_objects']}")
    
    print("\nPool Statistics:")
    for pool_name, stats in pool_stats.items():
        if pool_name != "overall":
            print(f"{pool_name}: {stats['utilization']:.2%} utilization")
    
    # åœæ­¢ç›‘æ§
    monitor.stop_monitoring()
    profiler.stop_tracemalloc()
    
    print("\nMemory optimization system stopped.")

if __name__ == "__main__":
    main()
```

## 3. å®é™…åº”ç”¨æ¡ˆä¾‹

### 3.1 å¤§æ•°æ®å¤„ç†å†…å­˜ä¼˜åŒ–

```python
class BigDataMemoryOptimizer:
    """å¤§æ•°æ®å¤„ç†å†…å­˜ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.chunk_size = 10000
        self.memory_limit = 1024 * 1024 * 1024  # 1GB
    
    def process_large_dataset(self, data_generator: Callable, processor: Callable) -> List[Any]:
        """å¤„ç†å¤§æ•°æ®é›†"""
        results = []
        current_chunk = []
        current_memory = 0
        
        for item in data_generator():
            # æ£€æŸ¥å†…å­˜ä½¿ç”¨
            if current_memory > self.memory_limit or len(current_chunk) >= self.chunk_size:
                # å¤„ç†å½“å‰å—
                chunk_results = processor(current_chunk)
                results.extend(chunk_results)
                
                # æ¸…ç©ºå½“å‰å—
                current_chunk.clear()
                current_memory = 0
                
                # å¼ºåˆ¶åƒåœ¾å›æ”¶
                gc.collect()
            
            # æ·»åŠ æ–°é¡¹ç›®
            current_chunk.append(item)
            current_memory += sys.getsizeof(item)
        
        # å¤„ç†æœ€åä¸€ä¸ªå—
        if current_chunk:
            chunk_results = processor(current_chunk)
            results.extend(chunk_results)
        
        return results
```

### 3.2 ç¼“å­˜å†…å­˜ä¼˜åŒ–

```python
class CacheMemoryOptimizer:
    """ç¼“å­˜å†…å­˜ä¼˜åŒ–å™¨"""
    
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.cache = {}
        self.access_count = defaultdict(int)
        self.size_tracker = 0
    
    def get(self, key: str) -> Any:
        """è·å–ç¼“å­˜é¡¹"""
        if key in self.cache:
            self.access_count[key] += 1
            return self.cache[key]
        return None
    
    def set(self, key: str, value: Any) -> bool:
        """è®¾ç½®ç¼“å­˜é¡¹"""
        item_size = sys.getsizeof(value)
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç†
        while self.size_tracker + item_size > self.max_size and self.cache:
            self._evict_least_used()
        
        # æ·»åŠ æ–°é¡¹
        if self.size_tracker + item_size <= self.max_size:
            self.cache[key] = value
            self.size_tracker += item_size
            self.access_count[key] = 1
            return True
        
        return False
    
    def _evict_least_used(self):
        """é©±é€æœ€å°‘ä½¿ç”¨çš„é¡¹"""
        if not self.cache:
            return
        
        # æ‰¾åˆ°æœ€å°‘ä½¿ç”¨çš„é¡¹
        least_used_key = min(self.access_count.keys(), key=lambda k: self.access_count[k])
        
        # ç§»é™¤é¡¹
        item_size = sys.getsizeof(self.cache[least_used_key])
        del self.cache[least_used_key]
        del self.access_count[least_used_key]
        self.size_tracker -= item_size
```

## 4. æ€»ç»“

### 4.1 æŠ€æœ¯è¦ç‚¹

1. **å†…å­˜ç›‘æ§**: å®æ—¶å†…å­˜ä½¿ç”¨ç›‘æ§
2. **å†…å­˜æ± åŒ–**: å‡å°‘å†…å­˜åˆ†é…å¼€é”€
3. **åƒåœ¾å›æ”¶ä¼˜åŒ–**: è°ƒæ•´GCç­–ç•¥
4. **æ³„æ¼æ£€æµ‹**: åŠæ—¶å‘ç°å†…å­˜æ³„æ¼

### 4.2 æœ€ä½³å®è·µ

1. **å®šæœŸç›‘æ§**: æŒç»­ç›‘æ§å†…å­˜ä½¿ç”¨
2. **åŠæ—¶é‡Šæ”¾**: åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„å¯¹è±¡
3. **ä½¿ç”¨æ± åŒ–**: å¯¹é¢‘ç¹åˆ†é…çš„å¯¹è±¡ä½¿ç”¨å†…å­˜æ± 
4. **ä¼˜åŒ–GC**: æ ¹æ®åº”ç”¨ç‰¹ç‚¹è°ƒæ•´GCå‚æ•°

### 4.3 æ‰©å±•æ–¹å‘

1. **æ™ºèƒ½ä¼˜åŒ–**: åŸºäºæœºå™¨å­¦ä¹ çš„è‡ªåŠ¨ä¼˜åŒ–
2. **åˆ†å¸ƒå¼å†…å­˜**: é›†ç¾¤å†…å­˜ç®¡ç†
3. **å†…å­˜å‹ç¼©**: å†…å­˜å‹ç¼©æŠ€æœ¯
4. **é¢„æµ‹ä¼˜åŒ–**: å†…å­˜ä½¿ç”¨é¢„æµ‹å’Œé¢„é˜²

---

**ç›¸å…³æ–‡æ¡£**:

- [ç®—æ³•ä¼˜åŒ–](./07-03-01-ç®—æ³•ä¼˜åŒ–.md)
- [å¹¶å‘ä¼˜åŒ–](./07-03-03-å¹¶å‘ä¼˜åŒ–.md)
- [åƒåœ¾å›æ”¶ç†è®º](../02-ç†è®ºåŸºç¡€/02-03-è®¡ç®—å¤æ‚æ€§ç†è®º/)
