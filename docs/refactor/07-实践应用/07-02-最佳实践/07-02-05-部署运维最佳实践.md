# éƒ¨ç½²è¿ç»´æœ€ä½³å®è·µ

## ğŸ“‹ æ¦‚è¿°

éƒ¨ç½²è¿ç»´æ˜¯è½¯ä»¶ç”Ÿå‘½å‘¨æœŸçš„é‡è¦ç¯èŠ‚ï¼Œæ¶‰åŠå®¹å™¨åŒ–ã€CI/CDã€ç›‘æ§å‘Šè­¦ç­‰æŠ€æœ¯ã€‚æœ¬æ–‡æ¡£æä¾›éƒ¨ç½²è¿ç»´çš„å½¢å¼åŒ–å®šä¹‰ã€æŠ€æœ¯æ¶æ„å’Œæœ€ä½³å®è·µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 éƒ¨ç½²ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (éƒ¨ç½²ç³»ç»Ÿ)
éƒ¨ç½²ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $\mathcal{D} = (C, O, M, S, A, R, E)$ï¼Œå…¶ä¸­ï¼š

- $C$ æ˜¯å®¹å™¨åŒ–ï¼Œ$C = (I, R, O)$
- $O$ æ˜¯ç¼–æ’ï¼Œ$O = (S, L, B)$
- $M$ æ˜¯ç›‘æ§ï¼Œ$M = (L, M, A)$
- $S$ æ˜¯æœåŠ¡å‘ç°ï¼Œ$S = (R, H, L)$
- $A$ æ˜¯è‡ªåŠ¨åŒ–ï¼Œ$A = (C, T, D)$
- $R$ æ˜¯å›æ»šï¼Œ$R = (V, S, R)$
- $E$ æ˜¯æ‰©å±•ï¼Œ$E = (H, V, A)$

**å®šä¹‰ 1.2** (éƒ¨ç½²ç­–ç•¥)
éƒ¨ç½²ç­–ç•¥æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{S} = (M, R, T)$ï¼Œå…¶ä¸­ï¼š

- $M$ æ˜¯éƒ¨ç½²æ¨¡å¼ï¼Œ$M \in \{Blue-Green, Rolling, Canary\}$
- $R$ æ˜¯å›æ»šç­–ç•¥ï¼Œ$R = (T, C, A)$
- $T$ æ˜¯æµ‹è¯•ç­–ç•¥ï¼Œ$T = (U, I, E)$

## 2. æŠ€æœ¯å®ç°

### 2.1 å®¹å™¨åŒ–ç³»ç»Ÿ

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Callable, Tuple
from dataclasses import dataclass, field
from enum import Enum
import docker
import yaml
import json
import subprocess
import time
import logging
from pathlib import Path

class ContainerStatus(Enum):
    """å®¹å™¨çŠ¶æ€"""
    RUNNING = "running"
    STOPPED = "stopped"
    CREATED = "created"
    EXITED = "exited"

class DeploymentType(Enum):
    """éƒ¨ç½²ç±»å‹"""
    BLUE_GREEN = "blue-green"
    ROLLING = "rolling"
    CANARY = "canary"

@dataclass
class ContainerConfig:
    """å®¹å™¨é…ç½®"""
    name: str
    image: str
    ports: Dict[str, str]
    environment: Dict[str, str] = field(default_factory=dict)
    volumes: Dict[str, str] = field(default_factory=dict)
    command: Optional[str] = None
    working_dir: Optional[str] = None

@dataclass
class ServiceConfig:
    """æœåŠ¡é…ç½®"""
    name: str
    replicas: int
    containers: List[ContainerConfig]
    health_check: Optional[Dict[str, Any]] = None
    load_balancer: Optional[Dict[str, Any]] = None

class ContainerManager:
    """å®¹å™¨ç®¡ç†å™¨"""
    
    def __init__(self):
        self.client = docker.from_env()
        self.containers: Dict[str, Any] = {}
    
    def create_container(self, config: ContainerConfig) -> str:
        """åˆ›å»ºå®¹å™¨"""
        try:
            container = self.client.containers.run(
                image=config.image,
                name=config.name,
                ports=config.ports,
                environment=config.environment,
                volumes=config.volumes,
                command=config.command,
                working_dir=config.working_dir,
                detach=True
            )
            
            self.containers[config.name] = container
            return container.id
        
        except Exception as e:
            logging.error(f"Failed to create container {config.name}: {e}")
            raise
    
    def start_container(self, container_name: str) -> bool:
        """å¯åŠ¨å®¹å™¨"""
        try:
            container = self.containers.get(container_name)
            if container:
                container.start()
                return True
            return False
        except Exception as e:
            logging.error(f"Failed to start container {container_name}: {e}")
            return False
    
    def stop_container(self, container_name: str) -> bool:
        """åœæ­¢å®¹å™¨"""
        try:
            container = self.containers.get(container_name)
            if container:
                container.stop()
                return True
            return False
        except Exception as e:
            logging.error(f"Failed to stop container {container_name}: {e}")
            return False
    
    def remove_container(self, container_name: str) -> bool:
        """åˆ é™¤å®¹å™¨"""
        try:
            container = self.containers.get(container_name)
            if container:
                container.remove(force=True)
                del self.containers[container_name]
                return True
            return False
        except Exception as e:
            logging.error(f"Failed to remove container {container_name}: {e}")
            return False
    
    def get_container_status(self, container_name: str) -> Optional[ContainerStatus]:
        """è·å–å®¹å™¨çŠ¶æ€"""
        try:
            container = self.containers.get(container_name)
            if container:
                container.reload()
                return ContainerStatus(container.status)
            return None
        except Exception as e:
            logging.error(f"Failed to get container status {container_name}: {e}")
            return None
    
    def get_container_logs(self, container_name: str, tail: int = 100) -> str:
        """è·å–å®¹å™¨æ—¥å¿—"""
        try:
            container = self.containers.get(container_name)
            if container:
                return container.logs(tail=tail).decode('utf-8')
            return ""
        except Exception as e:
            logging.error(f"Failed to get container logs {container_name}: {e}")
            return ""

class DockerComposeManager:
    """Docker Composeç®¡ç†å™¨"""
    
    def __init__(self, compose_file: str):
        self.compose_file = compose_file
        self.services: Dict[str, ServiceConfig] = {}
        self.load_compose_file()
    
    def load_compose_file(self):
        """åŠ è½½Composeæ–‡ä»¶"""
        try:
            with open(self.compose_file, 'r') as f:
                compose_data = yaml.safe_load(f)
            
            services = compose_data.get('services', {})
            for service_name, service_data in services.items():
                containers = []
                
                # åˆ›å»ºå®¹å™¨é…ç½®
                container_config = ContainerConfig(
                    name=f"{service_name}_container",
                    image=service_data.get('image', ''),
                    ports=service_data.get('ports', {}),
                    environment=service_data.get('environment', {}),
                    volumes=service_data.get('volumes', {}),
                    command=service_data.get('command'),
                    working_dir=service_data.get('working_dir')
                )
                containers.append(container_config)
                
                # åˆ›å»ºæœåŠ¡é…ç½®
                service_config = ServiceConfig(
                    name=service_name,
                    replicas=service_data.get('deploy', {}).get('replicas', 1),
                    containers=containers,
                    health_check=service_data.get('healthcheck'),
                    load_balancer=service_data.get('load_balancer')
                )
                
                self.services[service_name] = service_config
        
        except Exception as e:
            logging.error(f"Failed to load compose file: {e}")
            raise
    
    def deploy_services(self) -> Dict[str, bool]:
        """éƒ¨ç½²æœåŠ¡"""
        results = {}
        container_manager = ContainerManager()
        
        for service_name, service_config in self.services.items():
            try:
                for i in range(service_config.replicas):
                    container_name = f"{service_name}_{i}"
                    container_config = service_config.containers[0]
                    container_config.name = container_name
                    
                    container_id = container_manager.create_container(container_config)
                    results[container_name] = True
                    
                    logging.info(f"Deployed container {container_name} with ID {container_id}")
            
            except Exception as e:
                logging.error(f"Failed to deploy service {service_name}: {e}")
                results[service_name] = False
        
        return results
    
    def stop_services(self) -> Dict[str, bool]:
        """åœæ­¢æœåŠ¡"""
        results = {}
        container_manager = ContainerManager()
        
        for service_name in self.services.keys():
            try:
                # æŸ¥æ‰¾å¹¶åœæ­¢ç›¸å…³å®¹å™¨
                for container_name in container_manager.containers.keys():
                    if container_name.startswith(service_name):
                        success = container_manager.stop_container(container_name)
                        results[container_name] = success
            except Exception as e:
                logging.error(f"Failed to stop service {service_name}: {e}")
                results[service_name] = False
        
        return results

class KubernetesManager:
    """Kubernetesç®¡ç†å™¨"""
    
    def __init__(self, config_file: str = None):
        self.config_file = config_file
        self.namespace = "default"
    
    def create_deployment(self, name: str, image: str, replicas: int = 1) -> bool:
        """åˆ›å»ºéƒ¨ç½²"""
        try:
            deployment_yaml = f"""
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {name}
spec:
  replicas: {replicas}
  selector:
    matchLabels:
      app: {name}
  template:
    metadata:
      labels:
        app: {name}
    spec:
      containers:
      - name: {name}
        image: {image}
        ports:
        - containerPort: 80
"""
            
            # ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
            temp_file = f"/tmp/{name}_deployment.yaml"
            with open(temp_file, 'w') as f:
                f.write(deployment_yaml)
            
            # åº”ç”¨éƒ¨ç½²
            result = subprocess.run(
                ["kubectl", "apply", "-f", temp_file],
                capture_output=True,
                text=True
            )
            
            return result.returncode == 0
        
        except Exception as e:
            logging.error(f"Failed to create deployment {name}: {e}")
            return False
    
    def create_service(self, name: str, port: int = 80) -> bool:
        """åˆ›å»ºæœåŠ¡"""
        try:
            service_yaml = f"""
apiVersion: v1
kind: Service
metadata:
  name: {name}-service
spec:
  selector:
    app: {name}
  ports:
  - port: {port}
    targetPort: 80
  type: LoadBalancer
"""
            
            temp_file = f"/tmp/{name}_service.yaml"
            with open(temp_file, 'w') as f:
                f.write(service_yaml)
            
            result = subprocess.run(
                ["kubectl", "apply", "-f", temp_file],
                capture_output=True,
                text=True
            )
            
            return result.returncode == 0
        
        except Exception as e:
            logging.error(f"Failed to create service {name}: {e}")
            return False
    
    def scale_deployment(self, name: str, replicas: int) -> bool:
        """æ‰©å±•éƒ¨ç½²"""
        try:
            result = subprocess.run(
                ["kubectl", "scale", "deployment", name, f"--replicas={replicas}"],
                capture_output=True,
                text=True
            )
            
            return result.returncode == 0
        
        except Exception as e:
            logging.error(f"Failed to scale deployment {name}: {e}")
            return False
    
    def get_pod_status(self, name: str) -> Dict[str, Any]:
        """è·å–PodçŠ¶æ€"""
        try:
            result = subprocess.run(
                ["kubectl", "get", "pods", "-l", f"app={name}", "-o", "json"],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return json.loads(result.stdout)
            return {}
        
        except Exception as e:
            logging.error(f"Failed to get pod status {name}: {e}")
            return {}
```

### 2.2 CI/CDç³»ç»Ÿ

```python
class CICDPipeline:
    """CI/CDæµæ°´çº¿"""
    
    def __init__(self):
        self.stages: List[Dict[str, Any]] = []
        self.current_stage = 0
        self.status = "pending"
    
    def add_stage(self, name: str, commands: List[str], 
                  condition: Optional[Callable] = None):
        """æ·»åŠ é˜¶æ®µ"""
        stage = {
            "name": name,
            "commands": commands,
            "condition": condition,
            "status": "pending",
            "start_time": None,
            "end_time": None,
            "output": ""
        }
        self.stages.append(stage)
    
    def run_pipeline(self) -> bool:
        """è¿è¡Œæµæ°´çº¿"""
        self.status = "running"
        
        for i, stage in enumerate(self.stages):
            self.current_stage = i
            
            # æ£€æŸ¥æ¡ä»¶
            if stage["condition"] and not stage["condition"]():
                stage["status"] = "skipped"
                continue
            
            # æ‰§è¡Œé˜¶æ®µ
            stage["status"] = "running"
            stage["start_time"] = time.time()
            
            success = self._execute_stage(stage)
            
            stage["end_time"] = time.time()
            stage["status"] = "success" if success else "failed"
            
            if not success:
                self.status = "failed"
                return False
        
        self.status = "success"
        return True
    
    def _execute_stage(self, stage: Dict[str, Any]) -> bool:
        """æ‰§è¡Œé˜¶æ®µ"""
        try:
            for command in stage["commands"]:
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True
                )
                
                stage["output"] += f"$ {command}\n"
                stage["output"] += result.stdout
                stage["output"] += result.stderr
                
                if result.returncode != 0:
                    return False
            
            return True
        
        except Exception as e:
            stage["output"] += f"Error: {e}\n"
            return False
    
    def get_pipeline_status(self) -> Dict[str, Any]:
        """è·å–æµæ°´çº¿çŠ¶æ€"""
        return {
            "status": self.status,
            "current_stage": self.current_stage,
            "total_stages": len(self.stages),
            "stages": self.stages
        }

class GitLabCICD:
    """GitLab CI/CD"""
    
    def __init__(self, project_id: str, token: str):
        self.project_id = project_id
        self.token = token
        self.api_url = "https://gitlab.com/api/v4"
    
    def create_pipeline(self, branch: str = "main") -> Dict[str, Any]:
        """åˆ›å»ºæµæ°´çº¿"""
        try:
            import requests
            
            headers = {
                "PRIVATE-TOKEN": self.token,
                "Content-Type": "application/json"
            }
            
            data = {
                "ref": branch
            }
            
            response = requests.post(
                f"{self.api_url}/projects/{self.project_id}/pipeline",
                headers=headers,
                json=data
            )
            
            if response.status_code == 201:
                return response.json()
            else:
                logging.error(f"Failed to create pipeline: {response.text}")
                return {}
        
        except Exception as e:
            logging.error(f"Failed to create GitLab pipeline: {e}")
            return {}
    
    def get_pipeline_status(self, pipeline_id: int) -> str:
        """è·å–æµæ°´çº¿çŠ¶æ€"""
        try:
            import requests
            
            headers = {"PRIVATE-TOKEN": self.token}
            
            response = requests.get(
                f"{self.api_url}/projects/{self.project_id}/pipelines/{pipeline_id}",
                headers=headers
            )
            
            if response.status_code == 200:
                return response.json()["status"]
            else:
                return "unknown"
        
        except Exception as e:
            logging.error(f"Failed to get pipeline status: {e}")
            return "unknown"

class GitHubActions:
    """GitHub Actions"""
    
    def __init__(self, repo: str, token: str):
        self.repo = repo
        self.token = token
        self.api_url = "https://api.github.com"
    
    def create_workflow_dispatch(self, workflow: str, branch: str = "main") -> bool:
        """è§¦å‘å·¥ä½œæµ"""
        try:
            import requests
            
            headers = {
                "Authorization": f"token {self.token}",
                "Accept": "application/vnd.github.v3+json"
            }
            
            data = {
                "ref": branch
            }
            
            response = requests.post(
                f"{self.api_url}/repos/{self.repo}/actions/workflows/{workflow}/dispatches",
                headers=headers,
                json=data
            )
            
            return response.status_code == 204
        
        except Exception as e:
            logging.error(f"Failed to trigger GitHub workflow: {e}")
            return False
    
    def get_workflow_runs(self, workflow: str) -> List[Dict[str, Any]]:
        """è·å–å·¥ä½œæµè¿è¡Œè®°å½•"""
        try:
            import requests
            
            headers = {
                "Authorization": f"token {self.token}",
                "Accept": "application/vnd.github.v3+json"
            }
            
            response = requests.get(
                f"{self.api_url}/repos/{self.repo}/actions/workflows/{workflow}/runs",
                headers=headers
            )
            
            if response.status_code == 200:
                return response.json()["workflow_runs"]
            else:
                return []
        
        except Exception as e:
            logging.error(f"Failed to get workflow runs: {e}")
            return []
```

### 2.3 ç›‘æ§å‘Šè­¦ç³»ç»Ÿ

```python
class MonitoringSystem:
    """ç›‘æ§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.metrics: Dict[str, List[float]] = defaultdict(list)
        self.alerts: List[Dict[str, Any]] = []
        self.thresholds: Dict[str, float] = {}
        self.monitoring = False
    
    def add_metric(self, name: str, value: float):
        """æ·»åŠ æŒ‡æ ‡"""
        self.metrics[name].append(value)
        
        # ä¿æŒæœ€è¿‘1000ä¸ªå€¼
        if len(self.metrics[name]) > 1000:
            self.metrics[name] = self.metrics[name][-1000:]
        
        # æ£€æŸ¥å‘Šè­¦
        self._check_alerts(name, value)
    
    def set_threshold(self, metric_name: str, threshold: float, 
                     alert_type: str = "high"):
        """è®¾ç½®é˜ˆå€¼"""
        self.thresholds[f"{metric_name}_{alert_type}"] = threshold
    
    def _check_alerts(self, metric_name: str, value: float):
        """æ£€æŸ¥å‘Šè­¦"""
        for threshold_key, threshold_value in self.thresholds.items():
            if threshold_key.startswith(metric_name):
                alert_type = threshold_key.split("_")[-1]
                
                if alert_type == "high" and value > threshold_value:
                    self._create_alert(metric_name, value, threshold_value, "high")
                elif alert_type == "low" and value < threshold_value:
                    self._create_alert(metric_name, value, threshold_value, "low")
    
    def _create_alert(self, metric_name: str, value: float, 
                     threshold: float, alert_type: str):
        """åˆ›å»ºå‘Šè­¦"""
        alert = {
            "metric": metric_name,
            "value": value,
            "threshold": threshold,
            "type": alert_type,
            "timestamp": time.time(),
            "message": f"{metric_name} is {alert_type}er than {threshold} (current: {value})"
        }
        
        self.alerts.append(alert)
        logging.warning(f"Alert: {alert['message']}")
    
    def get_metrics_summary(self) -> Dict[str, Dict[str, float]]:
        """è·å–æŒ‡æ ‡æ‘˜è¦"""
        summary = {}
        
        for metric_name, values in self.metrics.items():
            if values:
                summary[metric_name] = {
                    "current": values[-1],
                    "average": sum(values) / len(values),
                    "min": min(values),
                    "max": max(values),
                    "count": len(values)
                }
        
        return summary
    
    def get_recent_alerts(self, hours: int = 24) -> List[Dict[str, Any]]:
        """è·å–æœ€è¿‘å‘Šè­¦"""
        cutoff_time = time.time() - (hours * 3600)
        return [alert for alert in self.alerts if alert["timestamp"] > cutoff_time]

class LogAggregator:
    """æ—¥å¿—èšåˆå™¨"""
    
    def __init__(self):
        self.logs: List[Dict[str, Any]] = []
        self.filters: Dict[str, Callable] = {}
    
    def add_log(self, level: str, message: str, source: str = "unknown", 
                metadata: Dict[str, Any] = None):
        """æ·»åŠ æ—¥å¿—"""
        log_entry = {
            "timestamp": time.time(),
            "level": level,
            "message": message,
            "source": source,
            "metadata": metadata or {}
        }
        
        self.logs.append(log_entry)
        
        # ä¿æŒæœ€è¿‘10000æ¡æ—¥å¿—
        if len(self.logs) > 10000:
            self.logs = self.logs[-10000:]
    
    def add_filter(self, name: str, filter_func: Callable):
        """æ·»åŠ è¿‡æ»¤å™¨"""
        self.filters[name] = filter_func
    
    def get_logs(self, level: str = None, source: str = None, 
                 hours: int = 24) -> List[Dict[str, Any]]:
        """è·å–æ—¥å¿—"""
        cutoff_time = time.time() - (hours * 3600)
        filtered_logs = [log for log in self.logs if log["timestamp"] > cutoff_time]
        
        if level:
            filtered_logs = [log for log in filtered_logs if log["level"] == level]
        
        if source:
            filtered_logs = [log for log in filtered_logs if log["source"] == source]
        
        return filtered_logs
    
    def get_error_summary(self, hours: int = 24) -> Dict[str, int]:
        """è·å–é”™è¯¯æ‘˜è¦"""
        logs = self.get_logs(hours=hours)
        error_counts = defaultdict(int)
        
        for log in logs:
            if log["level"] in ["ERROR", "CRITICAL"]:
                error_counts[log["source"]] += 1
        
        return dict(error_counts)

class HealthChecker:
    """å¥åº·æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.checks: Dict[str, Callable] = {}
        self.results: Dict[str, Dict[str, Any]] = {}
    
    def add_health_check(self, name: str, check_func: Callable):
        """æ·»åŠ å¥åº·æ£€æŸ¥"""
        self.checks[name] = check_func
    
    def run_health_checks(self) -> Dict[str, Dict[str, Any]]:
        """è¿è¡Œå¥åº·æ£€æŸ¥"""
        for name, check_func in self.checks.items():
            try:
                start_time = time.time()
                result = check_func()
                end_time = time.time()
                
                self.results[name] = {
                    "status": "healthy" if result else "unhealthy",
                    "response_time": end_time - start_time,
                    "timestamp": time.time(),
                    "details": result
                }
            
            except Exception as e:
                self.results[name] = {
                    "status": "error",
                    "response_time": 0,
                    "timestamp": time.time(),
                    "details": str(e)
                }
        
        return self.results
    
    def get_overall_health(self) -> str:
        """è·å–æ•´ä½“å¥åº·çŠ¶æ€"""
        if not self.results:
            return "unknown"
        
        unhealthy_count = sum(1 for result in self.results.values() 
                            if result["status"] != "healthy")
        
        if unhealthy_count == 0:
            return "healthy"
        elif unhealthy_count < len(self.results) / 2:
            return "degraded"
        else:
            return "unhealthy"
```

## 3. å®é™…åº”ç”¨ç¤ºä¾‹

### 3.1 å®Œæ•´çš„éƒ¨ç½²è¿ç»´ç³»ç»Ÿ

```python
class CompleteDeploymentSystem:
    """å®Œæ•´çš„éƒ¨ç½²è¿ç»´ç³»ç»Ÿ"""
    
    def __init__(self):
        self.container_manager = ContainerManager()
        self.compose_manager = None
        self.k8s_manager = None
        self.cicd_pipeline = CICDPipeline()
        self.monitoring = MonitoringSystem()
        self.log_aggregator = LogAggregator()
        self.health_checker = HealthChecker()
        
        self.setup_health_checks()
    
    def setup_health_checks(self):
        """è®¾ç½®å¥åº·æ£€æŸ¥"""
        def check_web_service():
            try:
                import requests
                response = requests.get("http://localhost:8080/health", timeout=5)
                return response.status_code == 200
            except:
                return False
        
        def check_database():
            try:
                # æ¨¡æ‹Ÿæ•°æ®åº“æ£€æŸ¥
                return True
            except:
                return False
        
        self.health_checker.add_health_check("web_service", check_web_service)
        self.health_checker.add_health_check("database", check_database)
    
    def deploy_with_docker_compose(self, compose_file: str) -> Dict[str, Any]:
        """ä½¿ç”¨Docker Composeéƒ¨ç½²"""
        try:
            self.compose_manager = DockerComposeManager(compose_file)
            deployment_results = self.compose_manager.deploy_services()
            
            # è®°å½•éƒ¨ç½²æ—¥å¿—
            self.log_aggregator.add_log(
                "INFO", 
                f"Docker Compose deployment completed: {deployment_results}",
                "deployment"
            )
            
            return {
                "success": all(deployment_results.values()),
                "results": deployment_results,
                "timestamp": time.time()
            }
        
        except Exception as e:
            self.log_aggregator.add_log(
                "ERROR", 
                f"Docker Compose deployment failed: {e}",
                "deployment"
            )
            return {"success": False, "error": str(e)}
    
    def deploy_with_kubernetes(self, deployment_config: Dict[str, Any]) -> Dict[str, Any]:
        """ä½¿ç”¨Kuberneteséƒ¨ç½²"""
        try:
            self.k8s_manager = KubernetesManager()
            
            # åˆ›å»ºéƒ¨ç½²
            deployment_success = self.k8s_manager.create_deployment(
                deployment_config["name"],
                deployment_config["image"],
                deployment_config.get("replicas", 1)
            )
            
            # åˆ›å»ºæœåŠ¡
            service_success = self.k8s_manager.create_service(
                deployment_config["name"],
                deployment_config.get("port", 80)
            )
            
            success = deployment_success and service_success
            
            self.log_aggregator.add_log(
                "INFO" if success else "ERROR",
                f"Kubernetes deployment {'completed' if success else 'failed'}",
                "deployment"
            )
            
            return {
                "success": success,
                "deployment": deployment_success,
                "service": service_success
            }
        
        except Exception as e:
            self.log_aggregator.add_log(
                "ERROR", 
                f"Kubernetes deployment failed: {e}",
                "deployment"
            )
            return {"success": False, "error": str(e)}
    
    def setup_cicd_pipeline(self):
        """è®¾ç½®CI/CDæµæ°´çº¿"""
        # æ„å»ºé˜¶æ®µ
        self.cicd_pipeline.add_stage("build", [
            "docker build -t myapp:latest .",
            "docker tag myapp:latest myapp:$(git rev-parse --short HEAD)"
        ])
        
        # æµ‹è¯•é˜¶æ®µ
        self.cicd_pipeline.add_stage("test", [
            "python -m pytest tests/",
            "python -m coverage report"
        ])
        
        # éƒ¨ç½²é˜¶æ®µ
        self.cicd_pipeline.add_stage("deploy", [
            "docker-compose up -d",
            "kubectl apply -f k8s/"
        ])
        
        # å¥åº·æ£€æŸ¥é˜¶æ®µ
        def health_check_condition():
            return self.health_checker.get_overall_health() == "healthy"
        
        self.cicd_pipeline.add_stage("health_check", [
            "echo 'Health check passed'"
        ], condition=health_check_condition)
    
    def run_deployment_pipeline(self) -> Dict[str, Any]:
        """è¿è¡Œéƒ¨ç½²æµæ°´çº¿"""
        # è®¾ç½®æµæ°´çº¿
        self.setup_cicd_pipeline()
        
        # è¿è¡Œæµæ°´çº¿
        success = self.cicd_pipeline.run_pipeline()
        
        # è®°å½•ç»“æœ
        pipeline_status = self.cicd_pipeline.get_pipeline_status()
        
        self.log_aggregator.add_log(
            "INFO" if success else "ERROR",
            f"Deployment pipeline {'completed' if success else 'failed'}",
            "pipeline"
        )
        
        return {
            "success": success,
            "pipeline_status": pipeline_status,
            "health_status": self.health_checker.get_overall_health()
        }
    
    def setup_monitoring(self):
        """è®¾ç½®ç›‘æ§"""
        # è®¾ç½®é˜ˆå€¼
        self.monitoring.set_threshold("cpu_usage", 80.0, "high")
        self.monitoring.set_threshold("memory_usage", 85.0, "high")
        self.monitoring.set_threshold("response_time", 2.0, "high")
        
        # å¼€å§‹ç›‘æ§
        self.monitoring.monitoring = True
    
    def get_system_status(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        # è¿è¡Œå¥åº·æ£€æŸ¥
        health_results = self.health_checker.run_health_checks()
        
        # è·å–ç›‘æ§æŒ‡æ ‡
        metrics_summary = self.monitoring.get_metrics_summary()
        
        # è·å–æœ€è¿‘å‘Šè­¦
        recent_alerts = self.monitoring.get_recent_alerts()
        
        # è·å–é”™è¯¯æ‘˜è¦
        error_summary = self.log_aggregator.get_error_summary()
        
        return {
            "overall_health": self.health_checker.get_overall_health(),
            "health_checks": health_results,
            "metrics": metrics_summary,
            "alerts": recent_alerts,
            "errors": error_summary,
            "timestamp": time.time()
        }
    
    def generate_deployment_report(self) -> str:
        """ç”Ÿæˆéƒ¨ç½²æŠ¥å‘Š"""
        system_status = self.get_system_status()
        
        report = "# Deployment and Operations Report\n\n"
        report += f"**Generated**: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        # å¥åº·çŠ¶æ€
        report += f"## System Health\n\n"
        report += f"- **Overall Status**: {system_status['overall_health']}\n"
        report += f"- **Health Checks**: {len(system_status['health_checks'])} total\n"
        
        healthy_checks = sum(1 for check in system_status['health_checks'].values() 
                           if check['status'] == 'healthy')
        report += f"- **Healthy Services**: {healthy_checks}\n\n"
        
        # ç›‘æ§æŒ‡æ ‡
        report += f"## Monitoring Metrics\n\n"
        for metric_name, metric_data in system_status['metrics'].items():
            report += f"### {metric_name}\n"
            report += f"- Current: {metric_data['current']:.2f}\n"
            report += f"- Average: {metric_data['average']:.2f}\n"
            report += f"- Min: {metric_data['min']:.2f}\n"
            report += f"- Max: {metric_data['max']:.2f}\n\n"
        
        # å‘Šè­¦
        if system_status['alerts']:
            report += f"## Recent Alerts\n\n"
            for alert in system_status['alerts'][-5:]:  # æœ€è¿‘5ä¸ªå‘Šè­¦
                report += f"- **{alert['metric']}**: {alert['message']}\n"
            report += "\n"
        
        # é”™è¯¯
        if system_status['errors']:
            report += f"## Error Summary\n\n"
            for source, count in system_status['errors'].items():
                report += f"- **{source}**: {count} errors\n"
        
        return report

# ä½¿ç”¨ç¤ºä¾‹
def main():
    """ä¸»å‡½æ•°"""
    # åˆ›å»ºéƒ¨ç½²ç³»ç»Ÿ
    deployment_system = CompleteDeploymentSystem()
    
    # è®¾ç½®ç›‘æ§
    deployment_system.setup_monitoring()
    
    # è¿è¡Œéƒ¨ç½²æµæ°´çº¿
    pipeline_result = deployment_system.run_deployment_pipeline()
    
    print("Deployment Pipeline Result:")
    print(f"Success: {pipeline_result['success']}")
    print(f"Health Status: {pipeline_result['health_status']}")
    
    # è·å–ç³»ç»ŸçŠ¶æ€
    system_status = deployment_system.get_system_status()
    
    print(f"\nSystem Status:")
    print(f"Overall Health: {system_status['overall_health']}")
    print(f"Active Alerts: {len(system_status['alerts'])}")
    print(f"Error Count: {sum(system_status['errors'].values())}")
    
    # ç”ŸæˆæŠ¥å‘Š
    report = deployment_system.generate_deployment_report()
    print(f"\nDeployment Report:")
    print(report)

if __name__ == "__main__":
    main()
```

## 4. æ€»ç»“

### 4.1 æŠ€æœ¯è¦ç‚¹

1. **å®¹å™¨åŒ–**: Dockerå’ŒKuberneteséƒ¨ç½²
2. **CI/CD**: è‡ªåŠ¨åŒ–æ„å»ºå’Œéƒ¨ç½²æµæ°´çº¿
3. **ç›‘æ§å‘Šè­¦**: å®æ—¶ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ
4. **å¥åº·æ£€æŸ¥**: æœåŠ¡å¥åº·çŠ¶æ€ç›‘æ§
5. **æ—¥å¿—ç®¡ç†**: é›†ä¸­åŒ–æ—¥å¿—æ”¶é›†å’Œåˆ†æ

### 4.2 æœ€ä½³å®è·µ

1. **è‡ªåŠ¨åŒ–éƒ¨ç½²**: å‡å°‘äººå·¥å¹²é¢„
2. **è“ç»¿éƒ¨ç½²**: é›¶åœæœºæ—¶é—´éƒ¨ç½²
3. **ç›‘æ§å‘Šè­¦**: åŠæ—¶å‘ç°å’Œå¤„ç†é—®é¢˜
4. **æ—¥å¿—èšåˆ**: ç»Ÿä¸€æ—¥å¿—ç®¡ç†
5. **å¥åº·æ£€æŸ¥**: ç¡®ä¿æœåŠ¡å¯ç”¨æ€§

### 4.3 æ‰©å±•æ–¹å‘

1. **æœåŠ¡ç½‘æ ¼**: Istioç­‰æœåŠ¡ç½‘æ ¼æŠ€æœ¯
2. **æ··æ²Œå·¥ç¨‹**: ç³»ç»ŸéŸ§æ€§æµ‹è¯•
3. **è‡ªåŠ¨æ‰©ç¼©å®¹**: åŸºäºè´Ÿè½½çš„è‡ªåŠ¨æ‰©å±•
4. **å¤šç¯å¢ƒç®¡ç†**: å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒ
5. **å®‰å…¨æ‰«æ**: å®¹å™¨å’Œä»£ç å®‰å…¨æ‰«æ

---

**ç›¸å…³æ–‡æ¡£**:

- [APIè®¾è®¡æœ€ä½³å®è·µ](./07-02-01-APIè®¾è®¡æœ€ä½³å®è·µ.md)
- [ä»£ç è´¨é‡æœ€ä½³å®è·µ](./07-02-02-ä»£ç è´¨é‡æœ€ä½³å®è·µ.md)
- [æµ‹è¯•æœ€ä½³å®è·µ](./07-02-03-æµ‹è¯•æœ€ä½³å®è·µ.md)
