# APIè®¾è®¡æœ€ä½³å®è·µ

## ğŸ“‹ æ¦‚è¿°

APIè®¾è®¡æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­çš„å…³é”®ç¯èŠ‚ï¼Œæ¶‰åŠæ¥å£è§„èŒƒã€ç‰ˆæœ¬ç®¡ç†ã€å®‰å…¨è®¾è®¡ç­‰æŠ€æœ¯ã€‚æœ¬æ–‡æ¡£æä¾›APIè®¾è®¡çš„å½¢å¼åŒ–å®šä¹‰ã€æŠ€æœ¯æ¶æ„å’Œæœ€ä½³å®è·µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 APIç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (APIç³»ç»Ÿ)
APIç³»ç»Ÿæ˜¯ä¸€ä¸ªå…­å…ƒç»„ $\mathcal{A} = (I, V, S, D, C, M)$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯æ¥å£é›†åˆï¼Œ$I = \{i_1, i_2, \ldots, i_n\}$
- $V$ æ˜¯ç‰ˆæœ¬ç®¡ç†ï¼Œ$V = (N, C, M)$
- $S$ æ˜¯å®‰å…¨æœºåˆ¶ï¼Œ$S = (A, E, V)$
- $D$ æ˜¯æ•°æ®æ¨¡å‹ï¼Œ$D = (S, V, T)$
- $C$ æ˜¯é€šä¿¡åè®®ï¼Œ$C = (P, F, E)$
- $M$ æ˜¯ç›‘æ§ç®¡ç†ï¼Œ$M = (L, M, A)$

**å®šä¹‰ 1.2** (APIæ¥å£)
APIæ¥å£æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{I} = (M, P, R, E)$ï¼Œå…¶ä¸­ï¼š

- $M$ æ˜¯HTTPæ–¹æ³•ï¼Œ$M \in \{GET, POST, PUT, DELETE, PATCH\}$
- $P$ æ˜¯è·¯å¾„å‚æ•°ï¼Œ$P = \{p_1, p_2, \ldots, p_n\}$
- $R$ æ˜¯å“åº”æ ¼å¼ï¼Œ$R = (S, C, D)$
- $E$ æ˜¯é”™è¯¯å¤„ç†ï¼Œ$E = (C, M, D)$

### 1.2 RESTful APIè®¾è®¡

**å®šä¹‰ 1.3** (RESTful API)
RESTful APIæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{R} = (R, S, U)$ï¼Œå…¶ä¸­ï¼š

- $R$ æ˜¯èµ„æºé›†åˆï¼Œ$R = \{r_1, r_2, \ldots, r_n\}$
- $S$ æ˜¯çŠ¶æ€è½¬ç§»ï¼Œ$S: R \times M \rightarrow R'$
- $U$ æ˜¯ç»Ÿä¸€æ¥å£ï¼Œ$U = (G, P, U, D)$

## 2. æŠ€æœ¯å®ç°

### 2.1 APIæ¡†æ¶è®¾è®¡

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Union, Type
from dataclasses import dataclass, field
from enum import Enum
import json
import time
import hashlib
import hmac
import base64
from datetime import datetime, timedelta
from fastapi import FastAPI, HTTPException, Depends, Header, Query, Path
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, validator
import uvicorn
import logging

class HTTPMethod(Enum):
    """HTTPæ–¹æ³•æšä¸¾"""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"

class APIVersion(Enum):
    """APIç‰ˆæœ¬æšä¸¾"""
    V1 = "v1"
    V2 = "v2"
    V3 = "v3"

@dataclass
class APIResponse:
    """APIå“åº”æ ¼å¼"""
    success: bool
    data: Any = None
    message: str = ""
    code: int = 200
    timestamp: float = field(default_factory=time.time)
    request_id: str = ""

class ErrorCode(Enum):
    """é”™è¯¯ä»£ç æšä¸¾"""
    INVALID_PARAMETER = (400, "Invalid parameter")
    UNAUTHORIZED = (401, "Unauthorized")
    FORBIDDEN = (403, "Forbidden")
    NOT_FOUND = (404, "Resource not found")
    METHOD_NOT_ALLOWED = (405, "Method not allowed")
    CONFLICT = (409, "Resource conflict")
    INTERNAL_ERROR = (500, "Internal server error")
    SERVICE_UNAVAILABLE = (503, "Service unavailable")

class APIError(Exception):
    """APIé”™è¯¯åŸºç±»"""
    
    def __init__(self, error_code: ErrorCode, message: str = "", details: Any = None):
        self.error_code = error_code
        self.message = message or error_code.value[1]
        self.details = details
        super().__init__(self.message)

class APIRateLimiter:
    """APIé™æµå™¨"""
    
    def __init__(self, max_requests: int = 100, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests: Dict[str, List[float]] = {}
    
    def is_allowed(self, client_id: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚"""
        current_time = time.time()
        
        if client_id not in self.requests:
            self.requests[client_id] = []
        
        # æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
        self.requests[client_id] = [
            req_time for req_time in self.requests[client_id]
            if current_time - req_time < self.window_seconds
        ]
        
        # æ£€æŸ¥è¯·æ±‚æ•°é‡
        if len(self.requests[client_id]) >= self.max_requests:
            return False
        
        # è®°å½•å½“å‰è¯·æ±‚
        self.requests[client_id].append(current_time)
        return True
    
    def get_remaining_requests(self, client_id: str) -> int:
        """è·å–å‰©ä½™è¯·æ±‚æ•°é‡"""
        current_time = time.time()
        
        if client_id not in self.requests:
            return self.max_requests
        
        valid_requests = [
            req_time for req_time in self.requests[client_id]
            if current_time - req_time < self.window_seconds
        ]
        
        return max(0, self.max_requests - len(valid_requests))

class APIAuthenticator:
    """APIè®¤è¯å™¨"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.tokens: Dict[str, Dict] = {}
    
    def generate_token(self, user_id: str, expires_in: int = 3600) -> str:
        """ç”Ÿæˆè®¿é—®ä»¤ç‰Œ"""
        payload = {
            "user_id": user_id,
            "exp": time.time() + expires_in,
            "iat": time.time()
        }
        
        # ä½¿ç”¨HMACç­¾å
        message = json.dumps(payload, sort_keys=True)
        signature = hmac.new(
            self.secret_key.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        
        token = base64.b64encode(f"{message}.{signature}".encode()).decode()
        
        # å­˜å‚¨ä»¤ç‰Œä¿¡æ¯
        self.tokens[token] = {
            "user_id": user_id,
            "expires_at": payload["exp"]
        }
        
        return token
    
    def verify_token(self, token: str) -> Optional[str]:
        """éªŒè¯è®¿é—®ä»¤ç‰Œ"""
        try:
            # è§£ç ä»¤ç‰Œ
            decoded = base64.b64decode(token.encode()).decode()
            message, signature = decoded.rsplit(".", 1)
            
            # éªŒè¯ç­¾å
            expected_signature = hmac.new(
                self.secret_key.encode(),
                message.encode(),
                hashlib.sha256
            ).hexdigest()
            
            if signature != expected_signature:
                return None
            
            # è§£æè½½è·
            payload = json.loads(message)
            
            # æ£€æŸ¥è¿‡æœŸæ—¶é—´
            if payload["exp"] < time.time():
                return None
            
            return payload["user_id"]
        
        except Exception:
            return None
    
    def revoke_token(self, token: str) -> bool:
        """æ’¤é”€è®¿é—®ä»¤ç‰Œ"""
        if token in self.tokens:
            del self.tokens[token]
            return True
        return False

class APIValidator:
    """APIéªŒè¯å™¨"""
    
    @staticmethod
    def validate_email(email: str) -> bool:
        """éªŒè¯é‚®ç®±æ ¼å¼"""
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    @staticmethod
    def validate_phone(phone: str) -> bool:
        """éªŒè¯æ‰‹æœºå·æ ¼å¼"""
        import re
        pattern = r'^\+?1?\d{9,15}$'
        return re.match(pattern, phone) is not None
    
    @staticmethod
    def validate_password(password: str) -> bool:
        """éªŒè¯å¯†ç å¼ºåº¦"""
        if len(password) < 8:
            return False
        
        has_upper = any(c.isupper() for c in password)
        has_lower = any(c.islower() for c in password)
        has_digit = any(c.isdigit() for c in password)
        has_special = any(c in "!@#$%^&*()_+-=[]{}|;:,.<>?" for c in password)
        
        return has_upper and has_lower and has_digit and has_special

class APIMonitor:
    """APIç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics: Dict[str, Any] = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "response_times": [],
            "error_counts": {}
        }
    
    def record_request(self, endpoint: str, method: str, 
                      response_time: float, success: bool, 
                      error_code: Optional[str] = None):
        """è®°å½•è¯·æ±‚æŒ‡æ ‡"""
        self.metrics["total_requests"] += 1
        
        if success:
            self.metrics["successful_requests"] += 1
        else:
            self.metrics["failed_requests"] += 1
            if error_code:
                self.metrics["error_counts"][error_code] = \
                    self.metrics["error_counts"].get(error_code, 0) + 1
        
        self.metrics["response_times"].append(response_time)
        
        # ä¿æŒæœ€è¿‘1000ä¸ªå“åº”æ—¶é—´
        if len(self.metrics["response_times"]) > 1000:
            self.metrics["response_times"] = self.metrics["response_times"][-1000:]
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–ç›‘æ§æŒ‡æ ‡"""
        response_times = self.metrics["response_times"]
        avg_response_time = sum(response_times) / len(response_times) if response_times else 0
        
        return {
            "total_requests": self.metrics["total_requests"],
            "successful_requests": self.metrics["successful_requests"],
            "failed_requests": self.metrics["failed_requests"],
            "success_rate": self.metrics["successful_requests"] / max(self.metrics["total_requests"], 1),
            "average_response_time": avg_response_time,
            "error_counts": self.metrics["error_counts"]
        }

class BaseAPI:
    """APIåŸºç±»"""
    
    def __init__(self, title: str, version: str = "1.0.0"):
        self.app = FastAPI(title=title, version=version)
        self.rate_limiter = APIRateLimiter()
        self.authenticator = APIAuthenticator("your-secret-key")
        self.validator = APIValidator()
        self.monitor = APIMonitor()
        
        self.setup_middleware()
        self.setup_routes()
    
    def setup_middleware(self):
        """è®¾ç½®ä¸­é—´ä»¶"""
        @self.app.middleware("http")
        async def monitor_middleware(request, call_next):
            start_time = time.time()
            
            # é™æµæ£€æŸ¥
            client_id = request.client.host
            if not self.rate_limiter.is_allowed(client_id):
                return APIResponse(
                    success=False,
                    message="Rate limit exceeded",
                    code=429
                )
            
            # å¤„ç†è¯·æ±‚
            response = await call_next(request)
            
            # è®°å½•æŒ‡æ ‡
            response_time = time.time() - start_time
            success = 200 <= response.status_code < 400
            self.monitor.record_request(
                str(request.url.path),
                request.method,
                response_time,
                success
            )
            
            return response
    
    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        @self.app.get("/health")
        async def health_check():
            return APIResponse(
                success=True,
                data={"status": "healthy"},
                message="Service is running"
            )
        
        @self.app.get("/metrics")
        async def get_metrics():
            return APIResponse(
                success=True,
                data=self.monitor.get_metrics(),
                message="API metrics"
            )
    
    def require_auth(self, credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer())):
        """è®¤è¯ä¾èµ–"""
        user_id = self.authenticator.verify_token(credentials.credentials)
        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid token")
        return user_id
    
    def handle_error(self, exc: Exception) -> APIResponse:
        """ç»Ÿä¸€é”™è¯¯å¤„ç†"""
        if isinstance(exc, APIError):
            return APIResponse(
                success=False,
                message=exc.message,
                code=exc.error_code.value[0],
                data=exc.details
            )
        else:
            return APIResponse(
                success=False,
                message="Internal server error",
                code=500
            )
```

### 2.2 ç”¨æˆ·APIå®ç°

```python
class UserModel(BaseModel):
    """ç”¨æˆ·æ•°æ®æ¨¡å‹"""
    id: Optional[str] = None
    name: str = Field(..., min_length=1, max_length=100)
    email: str = Field(..., description="User email address")
    phone: Optional[str] = None
    created_at: Optional[datetime] = None
    
    @validator('email')
    def validate_email(cls, v):
        if not APIValidator.validate_email(v):
            raise ValueError('Invalid email format')
        return v
    
    @validator('phone')
    def validate_phone(cls, v):
        if v and not APIValidator.validate_phone(v):
            raise ValueError('Invalid phone format')
        return v

class UserAPI(BaseAPI):
    """ç”¨æˆ·API"""
    
    def __init__(self):
        super().__init__("User API", "1.0.0")
        self.users: Dict[str, UserModel] = {}
        self.setup_user_routes()
    
    def setup_user_routes(self):
        """è®¾ç½®ç”¨æˆ·è·¯ç”±"""
        @self.app.post("/users", response_model=APIResponse)
        async def create_user(user: UserModel):
            """åˆ›å»ºç”¨æˆ·"""
            # æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
            for existing_user in self.users.values():
                if existing_user.email == user.email:
                    raise APIError(ErrorCode.CONFLICT, "Email already exists")
            
            # ç”Ÿæˆç”¨æˆ·ID
            user.id = str(uuid.uuid4())
            user.created_at = datetime.now()
            
            # å­˜å‚¨ç”¨æˆ·
            self.users[user.id] = user
            
            return APIResponse(
                success=True,
                data=user.dict(),
                message="User created successfully"
            )
        
        @self.app.get("/users/{user_id}", response_model=APIResponse)
        async def get_user(user_id: str = Path(..., description="User ID")):
            """è·å–ç”¨æˆ·"""
            if user_id not in self.users:
                raise APIError(ErrorCode.NOT_FOUND, "User not found")
            
            return APIResponse(
                success=True,
                data=self.users[user_id].dict(),
                message="User retrieved successfully"
            )
        
        @self.app.get("/users", response_model=APIResponse)
        async def list_users(
            page: int = Query(1, ge=1, description="Page number"),
            size: int = Query(10, ge=1, le=100, description="Page size"),
            search: Optional[str] = Query(None, description="Search term")
        ):
            """è·å–ç”¨æˆ·åˆ—è¡¨"""
            users = list(self.users.values())
            
            # æœç´¢è¿‡æ»¤
            if search:
                users = [
                    user for user in users
                    if search.lower() in user.name.lower() or 
                       search.lower() in user.email.lower()
                ]
            
            # åˆ†é¡µ
            total = len(users)
            start = (page - 1) * size
            end = start + size
            paginated_users = users[start:end]
            
            return APIResponse(
                success=True,
                data={
                    "users": [user.dict() for user in paginated_users],
                    "pagination": {
                        "page": page,
                        "size": size,
                        "total": total,
                        "pages": (total + size - 1) // size
                    }
                },
                message="Users retrieved successfully"
            )
        
        @self.app.put("/users/{user_id}", response_model=APIResponse)
        async def update_user(
            user_id: str = Path(..., description="User ID"),
            user_update: UserModel = None,
            current_user_id: str = Depends(require_auth)
        ):
            """æ›´æ–°ç”¨æˆ·"""
            if user_id not in self.users:
                raise APIError(ErrorCode.NOT_FOUND, "User not found")
            
            # æ£€æŸ¥æƒé™
            if current_user_id != user_id:
                raise APIError(ErrorCode.FORBIDDEN, "Cannot update other user")
            
            # æ›´æ–°ç”¨æˆ·ä¿¡æ¯
            existing_user = self.users[user_id]
            update_data = user_update.dict(exclude_unset=True)
            
            for field, value in update_data.items():
                if field != "id" and field != "created_at":
                    setattr(existing_user, field, value)
            
            return APIResponse(
                success=True,
                data=existing_user.dict(),
                message="User updated successfully"
            )
        
        @self.app.delete("/users/{user_id}", response_model=APIResponse)
        async def delete_user(
            user_id: str = Path(..., description="User ID"),
            current_user_id: str = Depends(require_auth)
        ):
            """åˆ é™¤ç”¨æˆ·"""
            if user_id not in self.users:
                raise APIError(ErrorCode.NOT_FOUND, "User not found")
            
            # æ£€æŸ¥æƒé™
            if current_user_id != user_id:
                raise APIError(ErrorCode.FORBIDDEN, "Cannot delete other user")
            
            del self.users[user_id]
            
            return APIResponse(
                success=True,
                message="User deleted successfully"
            )
        
        @self.app.post("/users/login", response_model=APIResponse)
        async def login_user(email: str, password: str):
            """ç”¨æˆ·ç™»å½•"""
            # æŸ¥æ‰¾ç”¨æˆ·
            user = None
            for u in self.users.values():
                if u.email == email:
                    user = u
                    break
            
            if not user:
                raise APIError(ErrorCode.UNAUTHORIZED, "Invalid credentials")
            
            # éªŒè¯å¯†ç ï¼ˆç®€åŒ–å®ç°ï¼‰
            if password != "password":  # å®é™…åº”è¯¥ä½¿ç”¨åŠ å¯†å¯†ç 
                raise APIError(ErrorCode.UNAUTHORIZED, "Invalid credentials")
            
            # ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
            token = self.authenticator.generate_token(user.id)
            
            return APIResponse(
                success=True,
                data={
                    "token": token,
                    "user": user.dict()
                },
                message="Login successful"
            )
```

### 2.3 APIæ–‡æ¡£ç”Ÿæˆ

```python
class APIDocumentation:
    """APIæ–‡æ¡£ç”Ÿæˆå™¨"""
    
    def __init__(self, api: BaseAPI):
        self.api = api
        self.documentation = {
            "info": {
                "title": api.app.title,
                "version": api.app.version,
                "description": "API documentation"
            },
            "paths": {},
            "components": {
                "schemas": {},
                "securitySchemes": {
                    "bearerAuth": {
                        "type": "http",
                        "scheme": "bearer",
                        "bearerFormat": "JWT"
                    }
                }
            }
        }
    
    def generate_documentation(self) -> Dict[str, Any]:
        """ç”ŸæˆAPIæ–‡æ¡£"""
        # åˆ†æè·¯ç”±
        for route in self.api.app.routes:
            if hasattr(route, 'path') and hasattr(route, 'methods'):
                self._document_route(route)
        
        return self.documentation
    
    def _document_route(self, route):
        """æ–‡æ¡£åŒ–è·¯ç”±"""
        path = route.path
        if path not in self.documentation["paths"]:
            self.documentation["paths"][path] = {}
        
        for method in route.methods:
            method_lower = method.lower()
            
            # è·å–è·¯ç”±ä¿¡æ¯
            endpoint_info = {
                "summary": f"{method} {path}",
                "description": getattr(route, 'description', ''),
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "$ref": "#/components/schemas/APIResponse"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request"
                    },
                    "401": {
                        "description": "Unauthorized"
                    },
                    "404": {
                        "description": "Not found"
                    },
                    "500": {
                        "description": "Internal server error"
                    }
                }
            }
            
            # æ·»åŠ å‚æ•°ä¿¡æ¯
            if hasattr(route, 'dependencies'):
                endpoint_info["parameters"] = self._extract_parameters(route)
            
            # æ·»åŠ è¯·æ±‚ä½“ä¿¡æ¯
            if method in ["POST", "PUT", "PATCH"]:
                endpoint_info["requestBody"] = self._extract_request_body(route)
            
            # æ·»åŠ å®‰å…¨è¦æ±‚
            if self._requires_auth(route):
                endpoint_info["security"] = [{"bearerAuth": []}]
            
            self.documentation["paths"][path][method_lower] = endpoint_info
    
    def _extract_parameters(self, route) -> List[Dict]:
        """æå–å‚æ•°ä¿¡æ¯"""
        parameters = []
        
        # è·¯å¾„å‚æ•°
        if "{" in route.path:
            path_params = re.findall(r'\{([^}]+)\}', route.path)
            for param in path_params:
                parameters.append({
                    "name": param,
                    "in": "path",
                    "required": True,
                    "schema": {"type": "string"}
                })
        
        # æŸ¥è¯¢å‚æ•°
        if hasattr(route, 'dependencies'):
            for dep in route.dependencies:
                if hasattr(dep, 'dependencies'):
                    for query_dep in dep.dependencies:
                        if hasattr(query_dep, 'name'):
                            parameters.append({
                                "name": query_dep.name,
                                "in": "query",
                                "required": query_dep.required,
                                "schema": {"type": query_dep.type}
                            })
        
        return parameters
    
    def _extract_request_body(self, route) -> Dict:
        """æå–è¯·æ±‚ä½“ä¿¡æ¯"""
        return {
            "required": True,
            "content": {
                "application/json": {
                    "schema": {
                        "$ref": "#/components/schemas/UserModel"
                    }
                }
            }
        }
    
    def _requires_auth(self, route) -> bool:
        """æ£€æŸ¥æ˜¯å¦éœ€è¦è®¤è¯"""
        if hasattr(route, 'dependencies'):
            for dep in route.dependencies:
                if 'require_auth' in str(dep):
                    return True
        return False
    
    def save_documentation(self, file_path: str):
        """ä¿å­˜æ–‡æ¡£åˆ°æ–‡ä»¶"""
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(self.documentation, f, indent=2, ensure_ascii=False)
```

## 3. å®é™…åº”ç”¨ç¤ºä¾‹

### 3.1 å®Œæ•´çš„APIåº”ç”¨

```python
class CompleteAPIApplication:
    """å®Œæ•´çš„APIåº”ç”¨"""
    
    def __init__(self):
        self.user_api = UserAPI()
        self.documentation = APIDocumentation(self.user_api)
    
    def run(self, host: str = "0.0.0.0", port: int = 8000):
        """è¿è¡ŒAPIåº”ç”¨"""
        # ç”Ÿæˆæ–‡æ¡£
        docs = self.documentation.generate_documentation()
        self.documentation.save_documentation("api_documentation.json")
        
        # å¯åŠ¨æœåŠ¡å™¨
        uvicorn.run(
            self.user_api.app,
            host=host,
            port=port,
            log_level="info"
        )
    
    async def test_api(self):
        """æµ‹è¯•API"""
        import aiohttp
        
        async with aiohttp.ClientSession() as session:
            base_url = "http://localhost:8000"
            
            # æµ‹è¯•åˆ›å»ºç”¨æˆ·
            user_data = {
                "name": "John Doe",
                "email": "john@example.com",
                "phone": "+1234567890"
            }
            
            async with session.post(f"{base_url}/users", json=user_data) as response:
                result = await response.json()
                print(f"Create user: {result}")
                user_id = result["data"]["id"]
            
            # æµ‹è¯•è·å–ç”¨æˆ·
            async with session.get(f"{base_url}/users/{user_id}") as response:
                result = await response.json()
                print(f"Get user: {result}")
            
            # æµ‹è¯•ç”¨æˆ·åˆ—è¡¨
            async with session.get(f"{base_url}/users?page=1&size=10") as response:
                result = await response.json()
                print(f"List users: {result}")
            
            # æµ‹è¯•ç™»å½•
            login_data = {"email": "john@example.com", "password": "password"}
            async with session.post(f"{base_url}/users/login", json=login_data) as response:
                result = await response.json()
                print(f"Login: {result}")
                token = result["data"]["token"]
            
            # æµ‹è¯•è®¤è¯æ¥å£
            headers = {"Authorization": f"Bearer {token}"}
            async with session.put(f"{base_url}/users/{user_id}", 
                                 json={"name": "John Updated"}, 
                                 headers=headers) as response:
                result = await response.json()
                print(f"Update user: {result}")
            
            # æµ‹è¯•æŒ‡æ ‡
            async with session.get(f"{base_url}/metrics") as response:
                result = await response.json()
                print(f"Metrics: {result}")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    """ä¸»å‡½æ•°"""
    app = CompleteAPIApplication()
    app.run()

if __name__ == "__main__":
    main()
```

## 4. æ€»ç»“

### 4.1 æŠ€æœ¯è¦ç‚¹

1. **RESTfulè®¾è®¡**: éµå¾ªRESTæ¶æ„åŸåˆ™
2. **ç‰ˆæœ¬ç®¡ç†**: æ”¯æŒAPIç‰ˆæœ¬æ§åˆ¶
3. **è®¤è¯æˆæƒ**: JWTä»¤ç‰Œè®¤è¯æœºåˆ¶
4. **é™æµä¿æŠ¤**: è¯·æ±‚é¢‘ç‡é™åˆ¶
5. **ç›‘æ§æŒ‡æ ‡**: å®Œæ•´çš„APIç›‘æ§

### 4.2 æœ€ä½³å®è·µ

1. **ç»Ÿä¸€å“åº”æ ¼å¼**: æ ‡å‡†åŒ–çš„å“åº”ç»“æ„
2. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯ç å’Œæ¶ˆæ¯
3. **å‚æ•°éªŒè¯**: è¾“å…¥å‚æ•°ä¸¥æ ¼éªŒè¯
4. **æ–‡æ¡£ç”Ÿæˆ**: è‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£
5. **å®‰å…¨è®¾è®¡**: å¤šå±‚æ¬¡å®‰å…¨é˜²æŠ¤

### 4.3 æ‰©å±•æ–¹å‘

1. **GraphQL**: çµæ´»çš„æŸ¥è¯¢è¯­è¨€æ”¯æŒ
2. **gRPC**: é«˜æ€§èƒ½RPCé€šä¿¡
3. **WebSocket**: å®æ—¶åŒå‘é€šä¿¡
4. **APIç½‘å…³**: ç»Ÿä¸€å…¥å£ç®¡ç†
5. **æœåŠ¡ç½‘æ ¼**: å¾®æœåŠ¡é€šä¿¡ç®¡ç†

---

**ç›¸å…³æ–‡æ¡£**:

- [ä»£ç è´¨é‡æœ€ä½³å®è·µ](./07-02-02-ä»£ç è´¨é‡æœ€ä½³å®è·µ.md)
- [æµ‹è¯•æœ€ä½³å®è·µ](./07-02-03-æµ‹è¯•æœ€ä½³å®è·µ.md)
- [æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ](./07-02-04-æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ.md)
