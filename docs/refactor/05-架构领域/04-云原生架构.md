# 云原生架构设计

## 1. 概述

### 1.1 云原生定义

**定义 1.1.1 (云原生)**
云原生是一种构建和运行应用程序的方法，充分利用云计算模型的优势：

$$\text{CloudNative} = (C, O, S, A)$$

其中：

- $C = \{c_1, c_2, ..., c_n\}$ 是容器集合
- $O = \{o_1, o_2, ..., o_m\}$ 是编排对象集合
- $S = \{s_1, s_2, ..., s_l\}$ 是服务集合
- $A = \{a_1, a_2, ..., a_k\}$ 是自动化集合

### 1.2 云原生特性

**定理 1.1.1 (云原生复杂度定理)**
云原生系统的复杂度与容器数量、服务依赖和自动化程度呈多项式关系：

$$\text{Complexity}(CN) = O(|C| \times |O| \times |S| \times |A|)$$

*证明*：容器需要编排，服务间存在依赖，自动化需要协调所有组件。

## 2. 容器化技术

### 2.1 容器运行时

**定义 2.1.1 (容器)**
容器是轻量级的、可移植的软件包，包含运行应用程序所需的所有依赖：

```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import asyncio
import uuid
import json

@dataclass
class ContainerImage:
    """容器镜像"""
    name: str
    tag: str
    digest: str
    layers: List[str]
    size: int
    created_at: datetime
    metadata: Dict[str, Any]

@dataclass
class Container:
    """容器"""
    id: str
    name: str
    image: ContainerImage
    status: str  # created, running, stopped, exited
    ports: Dict[int, int]  # host_port -> container_port
    volumes: List[str]
    environment: Dict[str, str]
    resources: Dict[str, Any]
    created_at: datetime
    started_at: Optional[datetime]

class ContainerRuntime:
    """容器运行时"""
    
    def __init__(self):
        self.containers: Dict[str, Container] = {}
        self.images: Dict[str, ContainerImage] = {}
        self.networks: Dict[str, Dict[str, Any]] = {}
    
    async def pull_image(self, image_name: str, tag: str = "latest") -> ContainerImage:
        """拉取镜像"""
        image_id = f"{image_name}:{tag}"
        
        if image_id in self.images:
            return self.images[image_id]
        
        # 模拟镜像拉取
        await asyncio.sleep(2.0)
        
        image = ContainerImage(
            name=image_name,
            tag=tag,
            digest=f"sha256:{uuid.uuid4().hex}",
            layers=[f"layer_{i}" for i in range(5)],
            size=1024 * 1024 * 100,  # 100MB
            created_at=datetime.now(),
            metadata={
                "architecture": "amd64",
                "os": "linux",
                "author": "developer"
            }
        )
        
        self.images[image_id] = image
        print(f"Pulled image: {image_id}")
        
        return image
    
    async def create_container(self, name: str, image: ContainerImage,
                             ports: Dict[int, int] = None,
                             volumes: List[str] = None,
                             environment: Dict[str, str] = None) -> Container:
        """创建容器"""
        container_id = str(uuid.uuid4())
        
        container = Container(
            id=container_id,
            name=name,
            image=image,
            status="created",
            ports=ports or {},
            volumes=volumes or [],
            environment=environment or {},
            resources={
                "cpu": "0.5",
                "memory": "512Mi",
                "disk": "10Gi"
            },
            created_at=datetime.now(),
            started_at=None
        )
        
        self.containers[container_id] = container
        print(f"Created container: {name} ({container_id})")
        
        return container
    
    async def start_container(self, container_id: str) -> bool:
        """启动容器"""
        if container_id not in self.containers:
            return False
        
        container = self.containers[container_id]
        container.status = "running"
        container.started_at = datetime.now()
        
        print(f"Started container: {container.name}")
        return True
    
    async def stop_container(self, container_id: str) -> bool:
        """停止容器"""
        if container_id not in self.containers:
            return False
        
        container = self.containers[container_id]
        container.status = "stopped"
        
        print(f"Stopped container: {container.name}")
        return True
    
    async def remove_container(self, container_id: str) -> bool:
        """删除容器"""
        if container_id not in self.containers:
            return False
        
        container = self.containers[container_id]
        del self.containers[container_id]
        
        print(f"Removed container: {container.name}")
        return True
    
    def get_container_status(self, container_id: str) -> Optional[Dict[str, Any]]:
        """获取容器状态"""
        if container_id not in self.containers:
            return None
        
        container = self.containers[container_id]
        
        return {
            'id': container.id,
            'name': container.name,
            'status': container.status,
            'image': f"{container.image.name}:{container.image.tag}",
            'ports': container.ports,
            'created_at': container.created_at.isoformat(),
            'started_at': container.started_at.isoformat() if container.started_at else None
        }
    
    def list_containers(self) -> List[Dict[str, Any]]:
        """列出所有容器"""
        return [
            self.get_container_status(container_id)
            for container_id in self.containers.keys()
        ]

# 使用示例
async def container_runtime_example():
    """容器运行时示例"""
    runtime = ContainerRuntime()
    
    # 拉取镜像
    image = await runtime.pull_image("nginx", "1.19")
    
    # 创建容器
    container = await runtime.create_container(
        name="web-server",
        image=image,
        ports={8080: 80},
        environment={"NGINX_HOST": "localhost"}
    )
    
    # 启动容器
    await runtime.start_container(container.id)
    
    # 获取状态
    status = runtime.get_container_status(container.id)
    print(f"Container status: {status}")
    
    # 列出所有容器
    containers = runtime.list_containers()
    print(f"All containers: {containers}")
```

### 2.2 容器编排

**定义 2.2.1 (容器编排)**
容器编排是自动化容器的部署、扩展和管理：

```python
from typing import Dict, List, Any, Optional
import asyncio
import time

@dataclass
class Pod:
    """Pod定义"""
    name: str
    namespace: str
    containers: List[Container]
    labels: Dict[str, str]
    replicas: int
    status: str  # pending, running, failed, succeeded

@dataclass
class Service:
    """服务定义"""
    name: str
    namespace: str
    selector: Dict[str, str]
    ports: List[Dict[str, Any]]
    type: str  # ClusterIP, NodePort, LoadBalancer

@dataclass
class Deployment:
    """部署定义"""
    name: str
    namespace: str
    replicas: int
    template: Dict[str, Any]
    strategy: str  # RollingUpdate, Recreate

class KubernetesOrchestrator:
    """Kubernetes编排器"""
    
    def __init__(self):
        self.pods: Dict[str, Pod] = {}
        self.services: Dict[str, Service] = {}
        self.deployments: Dict[str, Deployment] = {}
        self.namespaces: Dict[str, Dict[str, Any]] = {}
        self.nodes: Dict[str, Dict[str, Any]] = {}
    
    async def create_namespace(self, name: str) -> bool:
        """创建命名空间"""
        if name in self.namespaces:
            return False
        
        self.namespaces[name] = {
            'name': name,
            'status': 'Active',
            'created_at': datetime.now()
        }
        
        print(f"Created namespace: {name}")
        return True
    
    async def create_deployment(self, name: str, namespace: str, 
                              replicas: int, template: Dict[str, Any]) -> Deployment:
        """创建部署"""
        deployment = Deployment(
            name=name,
            namespace=namespace,
            replicas=replicas,
            template=template,
            strategy="RollingUpdate"
        )
        
        deployment_key = f"{namespace}/{name}"
        self.deployments[deployment_key] = deployment
        
        # 创建Pod
        await self._create_pods_for_deployment(deployment)
        
        print(f"Created deployment: {deployment_key}")
        return deployment
    
    async def _create_pods_for_deployment(self, deployment: Deployment):
        """为部署创建Pod"""
        for i in range(deployment.replicas):
            pod_name = f"{deployment.name}-{i}"
            pod = Pod(
                name=pod_name,
                namespace=deployment.namespace,
                containers=[],
                labels=deployment.template.get('metadata', {}).get('labels', {}),
                replicas=1,
                status="pending"
            )
            
            # 创建容器
            container_specs = deployment.template.get('spec', {}).get('containers', [])
            for spec in container_specs:
                container = await self._create_container_from_spec(spec)
                pod.containers.append(container)
            
            pod.status = "running"
            pod_key = f"{deployment.namespace}/{pod_name}"
            self.pods[pod_key] = pod
    
    async def _create_container_from_spec(self, spec: Dict[str, Any]) -> Container:
        """从规范创建容器"""
        # 简化实现
        return Container(
            id=str(uuid.uuid4()),
            name=spec.get('name', 'container'),
            image=ContainerImage(
                name=spec.get('image', 'nginx'),
                tag='latest',
                digest='',
                layers=[],
                size=0,
                created_at=datetime.now(),
                metadata={}
            ),
            status="running",
            ports={},
            volumes=[],
            environment=spec.get('env', {}),
            resources=spec.get('resources', {}),
            created_at=datetime.now(),
            started_at=datetime.now()
        )
    
    async def create_service(self, name: str, namespace: str,
                           selector: Dict[str, str], ports: List[Dict[str, Any]],
                           service_type: str = "ClusterIP") -> Service:
        """创建服务"""
        service = Service(
            name=name,
            namespace=namespace,
            selector=selector,
            ports=ports,
            type=service_type
        )
        
        service_key = f"{namespace}/{name}"
        self.services[service_key] = service
        
        print(f"Created service: {service_key}")
        return service
    
    async def scale_deployment(self, name: str, namespace: str, replicas: int) -> bool:
        """扩展部署"""
        deployment_key = f"{namespace}/{name}"
        
        if deployment_key not in self.deployments:
            return False
        
        deployment = self.deployments[deployment_key]
        old_replicas = deployment.replicas
        deployment.replicas = replicas
        
        if replicas > old_replicas:
            # 增加Pod
            await self._create_pods_for_deployment(deployment)
        elif replicas < old_replicas:
            # 减少Pod
            await self._remove_pods_from_deployment(deployment, old_replicas - replicas)
        
        print(f"Scaled deployment {deployment_key} to {replicas} replicas")
        return True
    
    async def _remove_pods_from_deployment(self, deployment: Deployment, count: int):
        """从部署中移除Pod"""
        # 简化实现：随机移除Pod
        pod_keys = [key for key in self.pods.keys() if key.startswith(f"{deployment.namespace}/{deployment.name}")]
        
        for i in range(min(count, len(pod_keys))):
            pod_key = pod_keys[i]
            del self.pods[pod_key]
    
    def get_deployment_status(self, name: str, namespace: str) -> Optional[Dict[str, Any]]:
        """获取部署状态"""
        deployment_key = f"{namespace}/{name}"
        
        if deployment_key not in self.deployments:
            return None
        
        deployment = self.deployments[deployment_key]
        
        # 统计Pod状态
        pod_keys = [key for key in self.pods.keys() if key.startswith(f"{deployment.namespace}/{deployment.name}")]
        running_pods = sum(1 for key in pod_keys if self.pods[key].status == "running")
        
        return {
            'name': deployment.name,
            'namespace': deployment.namespace,
            'replicas': deployment.replicas,
            'running_replicas': running_pods,
            'available_replicas': running_pods,
            'strategy': deployment.strategy
        }
    
    def list_resources(self, namespace: str = None) -> Dict[str, List[Dict[str, Any]]]:
        """列出资源"""
        resources = {
            'pods': [],
            'services': [],
            'deployments': []
        }
        
        for pod_key, pod in self.pods.items():
            if not namespace or pod.namespace == namespace:
                resources['pods'].append({
                    'name': pod.name,
                    'namespace': pod.namespace,
                    'status': pod.status,
                    'containers': len(pod.containers)
                })
        
        for service_key, service in self.services.items():
            if not namespace or service.namespace == namespace:
                resources['services'].append({
                    'name': service.name,
                    'namespace': service.namespace,
                    'type': service.type,
                    'ports': service.ports
                })
        
        for deployment_key, deployment in self.deployments.items():
            if not namespace or deployment.namespace == namespace:
                resources['deployments'].append({
                    'name': deployment.name,
                    'namespace': deployment.namespace,
                    'replicas': deployment.replicas,
                    'strategy': deployment.strategy
                })
        
        return resources

# 使用示例
async def kubernetes_orchestrator_example():
    """Kubernetes编排器示例"""
    orchestrator = KubernetesOrchestrator()
    
    # 创建命名空间
    await orchestrator.create_namespace("default")
    
    # 创建部署
    template = {
        'metadata': {
            'labels': {'app': 'web-server'}
        },
        'spec': {
            'containers': [{
                'name': 'nginx',
                'image': 'nginx:1.19',
                'ports': [{'containerPort': 80}],
                'resources': {
                    'requests': {'memory': '64Mi', 'cpu': '250m'},
                    'limits': {'memory': '128Mi', 'cpu': '500m'}
                }
            }]
        }
    }
    
    deployment = await orchestrator.create_deployment(
        name="web-deployment",
        namespace="default",
        replicas=3,
        template=template
    )
    
    # 创建服务
    service = await orchestrator.create_service(
        name="web-service",
        namespace="default",
        selector={'app': 'web-server'},
        ports=[{'port': 80, 'targetPort': 80}],
        service_type="ClusterIP"
    )
    
    # 扩展部署
    await orchestrator.scale_deployment("web-deployment", "default", 5)
    
    # 获取状态
    status = orchestrator.get_deployment_status("web-deployment", "default")
    print(f"Deployment status: {status}")
    
    # 列出资源
    resources = orchestrator.list_resources("default")
    print(f"Resources: {resources}")
```

## 3. 服务网格

### 3.1 Istio架构

**定义 3.1.1 (服务网格)**
服务网格是处理服务间通信的基础设施层：

```python
from typing import Dict, List, Any, Optional
import asyncio
import time

@dataclass
class VirtualService:
    """虚拟服务"""
    name: str
    namespace: str
    hosts: List[str]
    routes: List[Dict[str, Any]]
    gateways: List[str]

@dataclass
class DestinationRule:
    """目标规则"""
    name: str
    namespace: str
    host: str
    subsets: List[Dict[str, Any]]
    traffic_policy: Dict[str, Any]

@dataclass
class ServiceEntry:
    """服务条目"""
    name: str
    namespace: str
    hosts: List[str]
    ports: List[Dict[str, Any]]
    location: str  # MESH_EXTERNAL, MESH_INTERNAL

class IstioServiceMesh:
    """Istio服务网格"""
    
    def __init__(self):
        self.virtual_services: Dict[str, VirtualService] = {}
        self.destination_rules: Dict[str, DestinationRule] = {}
        self.service_entries: Dict[str, ServiceEntry] = {}
        self.proxies: Dict[str, Dict[str, Any]] = {}
        self.policies: Dict[str, Dict[str, Any]] = {}
    
    async def create_virtual_service(self, name: str, namespace: str,
                                   hosts: List[str], routes: List[Dict[str, Any]]) -> VirtualService:
        """创建虚拟服务"""
        virtual_service = VirtualService(
            name=name,
            namespace=namespace,
            hosts=hosts,
            routes=routes,
            gateways=[]
        )
        
        service_key = f"{namespace}/{name}"
        self.virtual_services[service_key] = virtual_service
        
        print(f"Created virtual service: {service_key}")
        return virtual_service
    
    async def create_destination_rule(self, name: str, namespace: str,
                                    host: str, subsets: List[Dict[str, Any]]) -> DestinationRule:
        """创建目标规则"""
        destination_rule = DestinationRule(
            name=name,
            namespace=namespace,
            host=host,
            subsets=subsets,
            traffic_policy={}
        )
        
        rule_key = f"{namespace}/{name}"
        self.destination_rules[rule_key] = destination_rule
        
        print(f"Created destination rule: {rule_key}")
        return destination_rule
    
    async def configure_traffic_routing(self, virtual_service_name: str, namespace: str,
                                      routing_rules: List[Dict[str, Any]]) -> bool:
        """配置流量路由"""
        service_key = f"{namespace}/{virtual_service_name}"
        
        if service_key not in self.virtual_services:
            return False
        
        virtual_service = self.virtual_services[service_key]
        virtual_service.routes = routing_rules
        
        print(f"Configured traffic routing for {service_key}")
        return True
    
    async def apply_circuit_breaker(self, destination_rule_name: str, namespace: str,
                                  circuit_breaker_config: Dict[str, Any]) -> bool:
        """应用熔断器"""
        rule_key = f"{namespace}/{destination_rule_name}"
        
        if rule_key not in self.destination_rules:
            return False
        
        destination_rule = self.destination_rules[rule_key]
        destination_rule.traffic_policy['connectionPool'] = circuit_breaker_config
        
        print(f"Applied circuit breaker for {rule_key}")
        return True
    
    async def configure_retry_policy(self, virtual_service_name: str, namespace: str,
                                   retry_config: Dict[str, Any]) -> bool:
        """配置重试策略"""
        service_key = f"{namespace}/{virtual_service_name}"
        
        if service_key not in self.virtual_services:
            return False
        
        virtual_service = self.virtual_services[service_key]
        
        # 为每个路由添加重试配置
        for route in virtual_service.routes:
            route['retries'] = retry_config
        
        print(f"Configured retry policy for {service_key}")
        return True
    
    async def apply_fault_injection(self, virtual_service_name: str, namespace: str,
                                  fault_config: Dict[str, Any]) -> bool:
        """应用故障注入"""
        service_key = f"{namespace}/{virtual_service_name}"
        
        if service_key not in self.virtual_services:
            return False
        
        virtual_service = self.virtual_services[service_key]
        
        # 为每个路由添加故障注入配置
        for route in virtual_service.routes:
            route['fault'] = fault_config
        
        print(f"Applied fault injection for {service_key}")
        return True
    
    def get_traffic_distribution(self, service_name: str, namespace: str) -> Dict[str, Any]:
        """获取流量分布"""
        service_key = f"{namespace}/{service_name}"
        
        if service_key not in self.virtual_services:
            return {}
        
        virtual_service = self.virtual_services[service_key]
        
        distribution = {
            'service': service_key,
            'routes': []
        }
        
        for route in virtual_service.routes:
            distribution['routes'].append({
                'destination': route.get('destination', {}),
                'weight': route.get('weight', 100),
                'fault': route.get('fault', {}),
                'retries': route.get('retries', {})
            })
        
        return distribution
    
    def get_service_mesh_status(self) -> Dict[str, Any]:
        """获取服务网格状态"""
        return {
            'virtual_services': len(self.virtual_services),
            'destination_rules': len(self.destination_rules),
            'service_entries': len(self.service_entries),
            'proxies': len(self.proxies),
            'policies': len(self.policies)
        }

# 使用示例
async def istio_service_mesh_example():
    """Istio服务网格示例"""
    mesh = IstioServiceMesh()
    
    # 创建虚拟服务
    routes = [
        {
            'destination': {'host': 'web-service', 'subset': 'v1'},
            'weight': 80
        },
        {
            'destination': {'host': 'web-service', 'subset': 'v2'},
            'weight': 20
        }
    ]
    
    virtual_service = await mesh.create_virtual_service(
        name="web-virtual-service",
        namespace="default",
        hosts=["web.example.com"],
        routes=routes
    )
    
    # 创建目标规则
    subsets = [
        {'name': 'v1', 'labels': {'version': 'v1'}},
        {'name': 'v2', 'labels': {'version': 'v2'}}
    ]
    
    destination_rule = await mesh.create_destination_rule(
        name="web-destination-rule",
        namespace="default",
        host="web-service",
        subsets=subsets
    )
    
    # 配置熔断器
    circuit_breaker_config = {
        'http': {
            'http1MaxPendingRequests': 1,
            'maxRequestsPerConnection': 1
        }
    }
    
    await mesh.apply_circuit_breaker(
        "web-destination-rule",
        "default",
        circuit_breaker_config
    )
    
    # 配置重试策略
    retry_config = {
        'attempts': 3,
        'perTryTimeout': '2s'
    }
    
    await mesh.configure_retry_policy(
        "web-virtual-service",
        "default",
        retry_config
    )
    
    # 获取流量分布
    distribution = mesh.get_traffic_distribution("web-virtual-service", "default")
    print(f"Traffic distribution: {distribution}")
    
    # 获取服务网格状态
    status = mesh.get_service_mesh_status()
    print(f"Service mesh status: {status}")
```

## 4. 持续部署

### 4.1 CI/CD流水线

**定义 4.1.1 (CI/CD)**
持续集成/持续部署自动化软件交付流程：

```python
from typing import Dict, List, Any, Optional
import asyncio
import time

@dataclass
class Pipeline:
    """流水线"""
    name: str
    stages: List[Dict[str, Any]]
    status: str  # pending, running, success, failed
    created_at: datetime
    started_at: Optional[datetime]
    completed_at: Optional[datetime]

@dataclass
class Stage:
    """阶段"""
    name: str
    steps: List[Dict[str, Any]]
    status: str  # pending, running, success, failed
    duration: float

class CICDPipeline:
    """CI/CD流水线"""
    
    def __init__(self):
        self.pipelines: Dict[str, Pipeline] = {}
        self.builds: Dict[str, Dict[str, Any]] = {}
        self.deployments: Dict[str, Dict[str, Any]] = {}
        self.artifacts: Dict[str, Dict[str, Any]] = {}
    
    async def create_pipeline(self, name: str, stages: List[Dict[str, Any]]) -> Pipeline:
        """创建流水线"""
        pipeline = Pipeline(
            name=name,
            stages=stages,
            status="pending",
            created_at=datetime.now(),
            started_at=None,
            completed_at=None
        )
        
        self.pipelines[name] = pipeline
        print(f"Created pipeline: {name}")
        
        return pipeline
    
    async def run_pipeline(self, name: str) -> bool:
        """运行流水线"""
        if name not in self.pipelines:
            return False
        
        pipeline = self.pipelines[name]
        pipeline.status = "running"
        pipeline.started_at = datetime.now()
        
        print(f"Running pipeline: {name}")
        
        try:
            for stage_config in pipeline.stages:
                stage = await self._execute_stage(stage_config)
                
                if stage.status == "failed":
                    pipeline.status = "failed"
                    pipeline.completed_at = datetime.now()
                    return False
            
            pipeline.status = "success"
            pipeline.completed_at = datetime.now()
            print(f"Pipeline {name} completed successfully")
            return True
            
        except Exception as e:
            pipeline.status = "failed"
            pipeline.completed_at = datetime.now()
            print(f"Pipeline {name} failed: {e}")
            return False
    
    async def _execute_stage(self, stage_config: Dict[str, Any]) -> Stage:
        """执行阶段"""
        stage = Stage(
            name=stage_config['name'],
            steps=stage_config.get('steps', []),
            status="running",
            duration=0.0
        )
        
        start_time = time.time()
        
        try:
            for step in stage.steps:
                await self._execute_step(step)
            
            stage.status = "success"
            
        except Exception as e:
            stage.status = "failed"
            print(f"Stage {stage.name} failed: {e}")
        
        stage.duration = time.time() - start_time
        return stage
    
    async def _execute_step(self, step: Dict[str, Any]):
        """执行步骤"""
        step_type = step.get('type')
        
        if step_type == 'build':
            await self._build_step(step)
        elif step_type == 'test':
            await self._test_step(step)
        elif step_type == 'deploy':
            await self._deploy_step(step)
        else:
            await asyncio.sleep(1.0)  # 默认步骤
    
    async def _build_step(self, step: Dict[str, Any]):
        """构建步骤"""
        print(f"Building: {step.get('name', 'Unknown')}")
        await asyncio.sleep(2.0)  # 模拟构建时间
        
        # 创建构建产物
        build_id = str(uuid.uuid4())
        self.builds[build_id] = {
            'name': step.get('name'),
            'image': step.get('image'),
            'tag': step.get('tag', 'latest'),
            'created_at': datetime.now()
        }
    
    async def _test_step(self, step: Dict[str, Any]):
        """测试步骤"""
        print(f"Testing: {step.get('name', 'Unknown')}")
        await asyncio.sleep(1.0)  # 模拟测试时间
        
        # 模拟测试结果
        test_results = {
            'passed': 10,
            'failed': 0,
            'coverage': 85.5
        }
        
        print(f"Test results: {test_results}")
    
    async def _deploy_step(self, step: Dict[str, Any]):
        """部署步骤"""
        print(f"Deploying: {step.get('name', 'Unknown')}")
        await asyncio.sleep(3.0)  # 模拟部署时间
        
        # 创建部署记录
        deployment_id = str(uuid.uuid4())
        self.deployments[deployment_id] = {
            'name': step.get('name'),
            'environment': step.get('environment', 'production'),
            'deployed_at': datetime.now(),
            'status': 'success'
        }
    
    def get_pipeline_status(self, name: str) -> Optional[Dict[str, Any]]:
        """获取流水线状态"""
        if name not in self.pipelines:
            return None
        
        pipeline = self.pipelines[name]
        
        return {
            'name': pipeline.name,
            'status': pipeline.status,
            'created_at': pipeline.created_at.isoformat(),
            'started_at': pipeline.started_at.isoformat() if pipeline.started_at else None,
            'completed_at': pipeline.completed_at.isoformat() if pipeline.completed_at else None,
            'stages': len(pipeline.stages)
        }
    
    def list_pipelines(self) -> List[Dict[str, Any]]:
        """列出所有流水线"""
        return [
            self.get_pipeline_status(name)
            for name in self.pipelines.keys()
        ]

# 使用示例
async def cicd_pipeline_example():
    """CI/CD流水线示例"""
    cicd = CICDPipeline()
    
    # 定义流水线阶段
    stages = [
        {
            'name': 'Build',
            'steps': [
                {'type': 'build', 'name': 'Build Docker Image', 'image': 'web-app', 'tag': 'latest'}
            ]
        },
        {
            'name': 'Test',
            'steps': [
                {'type': 'test', 'name': 'Unit Tests'},
                {'type': 'test', 'name': 'Integration Tests'}
            ]
        },
        {
            'name': 'Deploy',
            'steps': [
                {'type': 'deploy', 'name': 'Deploy to Staging', 'environment': 'staging'},
                {'type': 'deploy', 'name': 'Deploy to Production', 'environment': 'production'}
            ]
        }
    ]
    
    # 创建流水线
    pipeline = await cicd.create_pipeline("web-app-pipeline", stages)
    
    # 运行流水线
    success = await cicd.run_pipeline("web-app-pipeline")
    print(f"Pipeline success: {success}")
    
    # 获取状态
    status = cicd.get_pipeline_status("web-app-pipeline")
    print(f"Pipeline status: {status}")
    
    # 列出所有流水线
    pipelines = cicd.list_pipelines()
    print(f"All pipelines: {pipelines}")
```

## 5. 总结

云原生架构通过容器化、编排、服务网格和持续部署等技术，构建了可扩展、可维护的现代化应用。本文档提供了容器运行时、Kubernetes编排、Istio服务网格和CI/CD流水线的完整实现。

关键成功因素包括：

1. **容器化**：标准化的应用打包和部署
2. **编排**：自动化的容器管理和扩展
3. **服务网格**：智能的服务间通信管理
4. **持续部署**：自动化的软件交付流程

---

*本文档提供了云原生架构的完整设计方法论，包含数学形式化定义、Python代码实现和最佳实践指导。*
