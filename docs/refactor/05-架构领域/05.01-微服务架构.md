# 05.01 å¾®æœåŠ¡æ¶æ„

## ğŸ“‹ æ¦‚è¿°

å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ç§å°†åº”ç”¨ç¨‹åºåˆ†è§£ä¸ºå°å‹ã€ç‹¬ç«‹æœåŠ¡çš„æ¶æ„æ¨¡å¼ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰å¾®æœåŠ¡æ¶æ„çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å¾®æœåŠ¡æ¶æ„çš„å½¢å¼åŒ–å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ä¸ªå›¾ $G = (S, E)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯æœåŠ¡é›†åˆ
- $E$ æ˜¯æœåŠ¡é—´é€šä¿¡è¾¹
- æ¯ä¸ªæœåŠ¡ $s \in S$ æ»¡è¶³ï¼š$|s| \ll |Application|$

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Set, Any, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
import asyncio
import json
import uuid
from datetime import datetime

class ServiceStatus(Enum):
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    STARTING = "starting"
    STOPPED = "stopped"

class CommunicationProtocol(Enum):
    HTTP = "http"
    GRPC = "grpc"
    MESSAGE_QUEUE = "message_queue"
    EVENT_STREAM = "event_stream"

@dataclass
class Service:
    """å¾®æœåŠ¡"""
    service_id: str
    name: str
    version: str
    status: ServiceStatus
    endpoints: List[str]
    dependencies: List[str]
    health_check_url: str
    created_at: datetime
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.service_id:
            self.service_id = str(uuid.uuid4())
        if not self.created_at:
            self.created_at = datetime.now()

@dataclass
class ServiceCommunication:
    """æœåŠ¡é—´é€šä¿¡"""
    from_service: str
    to_service: str
    protocol: CommunicationProtocol
    endpoint: str
    method: str
    timeout: float
    retry_count: int

class MicroserviceArchitecture:
    """å¾®æœåŠ¡æ¶æ„"""
    
    def __init__(self):
        self.services: Dict[str, Service] = {}
        self.communications: List[ServiceCommunication] = []
        self.service_registry: Dict[str, Service] = {}
        self.load_balancer: Optional[Callable] = None
    
    def register_service(self, service: Service) -> None:
        """æ³¨å†ŒæœåŠ¡"""
        self.services[service.service_id] = service
        self.service_registry[service.name] = service
    
    def add_communication(self, communication: ServiceCommunication) -> None:
        """æ·»åŠ æœåŠ¡é—´é€šä¿¡"""
        self.communications.append(communication)
    
    def get_service(self, service_id: str) -> Optional[Service]:
        """è·å–æœåŠ¡"""
        return self.services.get(service_id)
    
    def get_service_by_name(self, name: str) -> Optional[Service]:
        """æ ¹æ®åç§°è·å–æœåŠ¡"""
        return self.service_registry.get(name)
    
    def list_services(self) -> List[Service]:
        """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
        return list(self.services.values())
    
    def get_service_dependencies(self, service_id: str) -> List[Service]:
        """è·å–æœåŠ¡ä¾èµ–"""
        service = self.get_service(service_id)
        if not service:
            return []
        
        dependencies = []
        for dep_name in service.dependencies:
            dep_service = self.get_service_by_name(dep_name)
            if dep_service:
                dependencies.append(dep_service)
        
        return dependencies
    
    def check_service_health(self, service_id: str) -> bool:
        """æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€"""
        service = self.get_service(service_id)
        if not service:
            return False
        
        # ç®€åŒ–çš„å¥åº·æ£€æŸ¥
        return service.status == ServiceStatus.HEALTHY
    
    def get_architecture_graph(self) -> Dict[str, List[str]]:
        """è·å–æ¶æ„å›¾"""
        graph = {}
        for service in self.services.values():
            graph[service.name] = service.dependencies
        return graph

# ç¤ºä¾‹ï¼šåŸºæœ¬å¾®æœåŠ¡æ¶æ„
def demonstrate_basic_microservices():
    """æ¼”ç¤ºåŸºæœ¬å¾®æœåŠ¡æ¶æ„"""
    architecture = MicroserviceArchitecture()
    
    # åˆ›å»ºæœåŠ¡
    user_service = Service(
        service_id="",
        name="user-service",
        version="1.0.0",
        status=ServiceStatus.HEALTHY,
        endpoints=["/users", "/users/{id}"],
        dependencies=[],
        health_check_url="/health"
    )
    
    order_service = Service(
        service_id="",
        name="order-service",
        version="1.0.0",
        status=ServiceStatus.HEALTHY,
        endpoints=["/orders", "/orders/{id}"],
        dependencies=["user-service"],
        health_check_url="/health"
    )
    
    payment_service = Service(
        service_id="",
        name="payment-service",
        version="1.0.0",
        status=ServiceStatus.HEALTHY,
        endpoints=["/payments", "/payments/{id}"],
        dependencies=["user-service"],
        health_check_url="/health"
    )
    
    # æ³¨å†ŒæœåŠ¡
    architecture.register_service(user_service)
    architecture.register_service(order_service)
    architecture.register_service(payment_service)
    
    # æ·»åŠ é€šä¿¡
    order_user_comm = ServiceCommunication(
        from_service="order-service",
        to_service="user-service",
        protocol=CommunicationProtocol.HTTP,
        endpoint="/users/{id}",
        method="GET",
        timeout=5.0,
        retry_count=3
    )
    
    architecture.add_communication(order_user_comm)
    
    print("åŸºæœ¬å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹:")
    print(f"æœåŠ¡æ•°é‡: {len(architecture.list_services())}")
    print(f"é€šä¿¡æ•°é‡: {len(architecture.communications)}")
    
    for service in architecture.list_services():
        print(f"æœåŠ¡: {service.name}, ä¾èµ–: {service.dependencies}")
    
    return architecture

# è¿è¡Œç¤ºä¾‹
basic_architecture = demonstrate_basic_microservices()
```

### 2. æœåŠ¡å‘ç°ä¸æ³¨å†Œ

#### 2.1 æœåŠ¡æ³¨å†Œä¸­å¿ƒ

**æ•°å­¦å®šä¹‰**ï¼š
æœåŠ¡æ³¨å†Œä¸­å¿ƒæ˜¯ä¸€ä¸ªæ˜ å°„ $R: ServiceName \rightarrow ServiceInfo$

**Pythonå®ç°**ï¼š

```python
import asyncio
from typing import Dict, List, Optional, Callable
import aiohttp
import json

class ServiceRegistry:
    """æœåŠ¡æ³¨å†Œä¸­å¿ƒ"""
    
    def __init__(self):
        self.registered_services: Dict[str, Dict[str, Any]] = {}
        self.health_checkers: Dict[str, Callable] = {}
        self.service_watchers: List[Callable] = []
    
    def register_service(self, service_name: str, service_info: Dict[str, Any]) -> bool:
        """æ³¨å†ŒæœåŠ¡"""
        service_info['registered_at'] = datetime.now().isoformat()
        service_info['last_heartbeat'] = datetime.now().isoformat()
        self.registered_services[service_name] = service_info
        
        # é€šçŸ¥è§‚å¯Ÿè€…
        self._notify_watchers('register', service_name, service_info)
        
        return True
    
    def deregister_service(self, service_name: str) -> bool:
        """æ³¨é”€æœåŠ¡"""
        if service_name in self.registered_services:
            del self.registered_services[service_name]
            self._notify_watchers('deregister', service_name, None)
            return True
        return False
    
    def get_service(self, service_name: str) -> Optional[Dict[str, Any]]:
        """è·å–æœåŠ¡ä¿¡æ¯"""
        return self.registered_services.get(service_name)
    
    def list_services(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
        return list(self.registered_services.keys())
    
    def update_heartbeat(self, service_name: str) -> bool:
        """æ›´æ–°å¿ƒè·³"""
        if service_name in self.registered_services:
            self.registered_services[service_name]['last_heartbeat'] = datetime.now().isoformat()
            return True
        return False
    
    def add_health_checker(self, service_name: str, checker: Callable):
        """æ·»åŠ å¥åº·æ£€æŸ¥å™¨"""
        self.health_checkers[service_name] = checker
    
    def check_service_health(self, service_name: str) -> bool:
        """æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€"""
        if service_name not in self.registered_services:
            return False
        
        if service_name in self.health_checkers:
            return self.health_checkers[service_name]()
        
        # é»˜è®¤å¥åº·æ£€æŸ¥
        return True
    
    def add_watcher(self, watcher: Callable):
        """æ·»åŠ è§‚å¯Ÿè€…"""
        self.service_watchers.append(watcher)
    
    def _notify_watchers(self, event: str, service_name: str, service_info: Optional[Dict[str, Any]]):
        """é€šçŸ¥è§‚å¯Ÿè€…"""
        for watcher in self.service_watchers:
            try:
                watcher(event, service_name, service_info)
            except Exception as e:
                print(f"Watcher notification failed: {e}")

class ServiceDiscovery:
    """æœåŠ¡å‘ç°"""
    
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.cache_ttl: Dict[str, datetime] = {}
    
    async def discover_service(self, service_name: str, 
                             use_cache: bool = True) -> Optional[Dict[str, Any]]:
        """å‘ç°æœåŠ¡"""
        # æ£€æŸ¥ç¼“å­˜
        if use_cache and service_name in self.cache:
            if datetime.now() < self.cache_ttl.get(service_name, datetime.min):
                return self.cache[service_name]
        
        # ä»æ³¨å†Œä¸­å¿ƒè·å–
        service_info = self.registry.get_service(service_name)
        
        if service_info:
            # æ›´æ–°ç¼“å­˜
            self.cache[service_name] = service_info
            self.cache_ttl[service_name] = datetime.now() + timedelta(seconds=30)
        
        return service_info
    
    async def discover_all_services(self) -> List[Dict[str, Any]]:
        """å‘ç°æ‰€æœ‰æœåŠ¡"""
        services = []
        for service_name in self.registry.list_services():
            service_info = await self.discover_service(service_name)
            if service_info:
                services.append(service_info)
        return services
    
    def clear_cache(self):
        """æ¸…é™¤ç¼“å­˜"""
        self.cache.clear()
        self.cache_ttl.clear()

# ç¤ºä¾‹ï¼šæœåŠ¡å‘ç°ä¸æ³¨å†Œ
def demonstrate_service_discovery():
    """æ¼”ç¤ºæœåŠ¡å‘ç°ä¸æ³¨å†Œ"""
    registry = ServiceRegistry()
    discovery = ServiceDiscovery(registry)
    
    # æ³¨å†ŒæœåŠ¡
    user_service_info = {
        'host': 'localhost',
        'port': 8080,
        'endpoints': ['/users', '/users/{id}'],
        'version': '1.0.0'
    }
    
    registry.register_service('user-service', user_service_info)
    
    # æ·»åŠ å¥åº·æ£€æŸ¥
    def user_service_health_check():
        return True
    
    registry.add_health_checker('user-service', user_service_health_check)
    
    # æ·»åŠ è§‚å¯Ÿè€…
    def service_watcher(event: str, service_name: str, service_info: Optional[Dict[str, Any]]):
        print(f"Service event: {event} - {service_name}")
    
    registry.add_watcher(service_watcher)
    
    print("æœåŠ¡å‘ç°ä¸æ³¨å†Œç¤ºä¾‹:")
    print(f"æ³¨å†Œçš„æœåŠ¡: {registry.list_services()}")
    print(f"æœåŠ¡ä¿¡æ¯: {registry.get_service('user-service')}")
    print(f"å¥åº·çŠ¶æ€: {registry.check_service_health('user-service')}")
    
    return registry, discovery

# è¿è¡Œç¤ºä¾‹
registry, discovery = demonstrate_service_discovery()
```

#### 2.2 è´Ÿè½½å‡è¡¡

**æ•°å­¦å®šä¹‰**ï¼š
è´Ÿè½½å‡è¡¡å™¨æ˜¯ä¸€ä¸ªå‡½æ•° $LB: Request \times ServiceList \rightarrow Service$

**Pythonå®ç°**ï¼š

```python
from typing import List, Dict, Any, Callable
import random
import time
from dataclasses import dataclass

class LoadBalancingStrategy(Enum):
    ROUND_ROBIN = "round_robin"
    RANDOM = "random"
    LEAST_CONNECTIONS = "least_connections"
    WEIGHTED_ROUND_ROBIN = "weighted_round_robin"
    IP_HASH = "ip_hash"

@dataclass
class ServiceInstance:
    """æœåŠ¡å®ä¾‹"""
    instance_id: str
    host: str
    port: int
    weight: int = 1
    active_connections: int = 0
    last_response_time: float = 0.0
    is_healthy: bool = True

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, strategy: LoadBalancingStrategy = LoadBalancingStrategy.ROUND_ROBIN):
        self.strategy = strategy
        self.instances: List[ServiceInstance] = []
        self.current_index = 0
        self.connection_counts: Dict[str, int] = {}
    
    def add_instance(self, instance: ServiceInstance):
        """æ·»åŠ æœåŠ¡å®ä¾‹"""
        self.instances.append(instance)
        self.connection_counts[instance.instance_id] = 0
    
    def remove_instance(self, instance_id: str):
        """ç§»é™¤æœåŠ¡å®ä¾‹"""
        self.instances = [i for i in self.instances if i.instance_id != instance_id]
        if instance_id in self.connection_counts:
            del self.connection_counts[instance_id]
    
    def get_next_instance(self, request_info: Dict[str, Any] = None) -> Optional[ServiceInstance]:
        """è·å–ä¸‹ä¸€ä¸ªæœåŠ¡å®ä¾‹"""
        if not self.instances:
            return None
        
        # è¿‡æ»¤å¥åº·å®ä¾‹
        healthy_instances = [i for i in self.instances if i.is_healthy]
        if not healthy_instances:
            return None
        
        if self.strategy == LoadBalancingStrategy.ROUND_ROBIN:
            return self._round_robin(healthy_instances)
        elif self.strategy == LoadBalancingStrategy.RANDOM:
            return self._random(healthy_instances)
        elif self.strategy == LoadBalancingStrategy.LEAST_CONNECTIONS:
            return self._least_connections(healthy_instances)
        elif self.strategy == LoadBalancingStrategy.WEIGHTED_ROUND_ROBIN:
            return self._weighted_round_robin(healthy_instances)
        elif self.strategy == LoadBalancingStrategy.IP_HASH:
            return self._ip_hash(healthy_instances, request_info)
        else:
            return healthy_instances[0]
    
    def _round_robin(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """è½®è¯¢ç­–ç•¥"""
        instance = instances[self.current_index % len(instances)]
        self.current_index += 1
        return instance
    
    def _random(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """éšæœºç­–ç•¥"""
        return random.choice(instances)
    
    def _least_connections(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """æœ€å°‘è¿æ¥ç­–ç•¥"""
        return min(instances, key=lambda x: self.connection_counts.get(x.instance_id, 0))
    
    def _weighted_round_robin(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """åŠ æƒè½®è¯¢ç­–ç•¥"""
        # ç®€åŒ–çš„åŠ æƒè½®è¯¢å®ç°
        total_weight = sum(i.weight for i in instances)
        if total_weight == 0:
            return instances[0]
        
        # ä½¿ç”¨è½®è¯¢ç´¢å¼•å’Œæƒé‡
        instance = instances[self.current_index % len(instances)]
        self.current_index += 1
        return instance
    
    def _ip_hash(self, instances: List[ServiceInstance], 
                request_info: Dict[str, Any]) -> ServiceInstance:
        """IPå“ˆå¸Œç­–ç•¥"""
        if not request_info or 'client_ip' not in request_info:
            return instances[0]
        
        client_ip = request_info['client_ip']
        hash_value = hash(client_ip) % len(instances)
        return instances[hash_value]
    
    def record_request(self, instance_id: str, response_time: float):
        """è®°å½•è¯·æ±‚"""
        if instance_id in self.connection_counts:
            self.connection_counts[instance_id] += 1
        
        # æ›´æ–°å®ä¾‹å“åº”æ—¶é—´
        for instance in self.instances:
            if instance.instance_id == instance_id:
                instance.last_response_time = response_time
                break
    
    def get_statistics(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        stats = {
            'total_instances': len(self.instances),
            'healthy_instances': len([i for i in self.instances if i.is_healthy]),
            'connection_counts': self.connection_counts.copy(),
            'strategy': self.strategy.value
        }
        return stats

# ç¤ºä¾‹ï¼šè´Ÿè½½å‡è¡¡
def demonstrate_load_balancing():
    """æ¼”ç¤ºè´Ÿè½½å‡è¡¡"""
    load_balancer = LoadBalancer(LoadBalancingStrategy.ROUND_ROBIN)
    
    # æ·»åŠ æœåŠ¡å®ä¾‹
    instances = [
        ServiceInstance("instance-1", "localhost", 8081, weight=2),
        ServiceInstance("instance-2", "localhost", 8082, weight=1),
        ServiceInstance("instance-3", "localhost", 8083, weight=1)
    ]
    
    for instance in instances:
        load_balancer.add_instance(instance)
    
    print("è´Ÿè½½å‡è¡¡ç¤ºä¾‹:")
    
    # æ¨¡æ‹Ÿè¯·æ±‚
    for i in range(10):
        instance = load_balancer.get_next_instance()
        if instance:
            print(f"è¯·æ±‚ {i+1} -> {instance.host}:{instance.port}")
            load_balancer.record_request(instance.instance_id, 0.1)
    
    print(f"ç»Ÿè®¡ä¿¡æ¯: {load_balancer.get_statistics()}")
    
    return load_balancer

# è¿è¡Œç¤ºä¾‹
load_balancer = demonstrate_load_balancing()
```

### 3. æœåŠ¡é—´é€šä¿¡

#### 3.1 åŒæ­¥é€šä¿¡

**æ•°å­¦å®šä¹‰**ï¼š
åŒæ­¥é€šä¿¡ï¼š$Request \rightarrow Response$ï¼Œç­‰å¾…å“åº”

**Pythonå®ç°**ï¼š

```python
import aiohttp
import asyncio
from typing import Dict, Any, Optional
import json

class ServiceClient:
    """æœåŠ¡å®¢æˆ·ç«¯"""
    
    def __init__(self, service_name: str, discovery: ServiceDiscovery):
        self.service_name = service_name
        self.discovery = discovery
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def request(self, method: str, endpoint: str, 
                     data: Dict[str, Any] = None, 
                     headers: Dict[str, str] = None) -> Dict[str, Any]:
        """å‘é€è¯·æ±‚"""
        if not self.session:
            raise RuntimeError("Client not initialized")
        
        # æœåŠ¡å‘ç°
        service_info = await self.discovery.discover_service(self.service_name)
        if not service_info:
            raise RuntimeError(f"Service {self.service_name} not found")
        
        # æ„å»ºURL
        url = f"http://{service_info['host']}:{service_info['port']}{endpoint}"
        
        # å‘é€è¯·æ±‚
        try:
            async with self.session.request(
                method, url, json=data, headers=headers
            ) as response:
                response_data = await response.json()
                return {
                    'status': response.status,
                    'data': response_data,
                    'headers': dict(response.headers)
                }
        except Exception as e:
            return {
                'status': 500,
                'error': str(e),
                'data': None
            }
    
    async def get(self, endpoint: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """GETè¯·æ±‚"""
        return await self.request('GET', endpoint, data=params)
    
    async def post(self, endpoint: str, data: Dict[str, Any] = None) -> Dict[str, Any]:
        """POSTè¯·æ±‚"""
        return await self.request('POST', endpoint, data=data)
    
    async def put(self, endpoint: str, data: Dict[str, Any] = None) -> Dict[str, Any]:
        """PUTè¯·æ±‚"""
        return await self.request('PUT', endpoint, data=data)
    
    async def delete(self, endpoint: str) -> Dict[str, Any]:
        """DELETEè¯·æ±‚"""
        return await self.request('DELETE', endpoint)

class CircuitBreaker:
    """ç†”æ–­å™¨"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
    
    def call(self, func: Callable, *args, **kwargs) -> Any:
        """æ‰§è¡Œå‡½æ•°"""
        if self.state == 'OPEN':
            if self._should_attempt_reset():
                self.state = 'HALF_OPEN'
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _on_success(self):
        """æˆåŠŸå›è°ƒ"""
        self.failure_count = 0
        self.state = 'CLOSED'
    
    def _on_failure(self):
        """å¤±è´¥å›è°ƒ"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = 'OPEN'
    
    def _should_attempt_reset(self) -> bool:
        """æ˜¯å¦åº”è¯¥å°è¯•é‡ç½®"""
        if not self.last_failure_time:
            return True
        
        return time.time() - self.last_failure_time >= self.timeout

# ç¤ºä¾‹ï¼šåŒæ­¥é€šä¿¡
async def demonstrate_synchronous_communication():
    """æ¼”ç¤ºåŒæ­¥é€šä¿¡"""
    # åˆ›å»ºæœåŠ¡å‘ç°
    registry = ServiceRegistry()
    discovery = ServiceDiscovery(registry)
    
    # æ³¨å†ŒæœåŠ¡
    user_service_info = {
        'host': 'localhost',
        'port': 8080,
        'endpoints': ['/users', '/users/{id}'],
        'version': '1.0.0'
    }
    registry.register_service('user-service', user_service_info)
    
    # åˆ›å»ºå®¢æˆ·ç«¯
    async with ServiceClient('user-service', discovery) as client:
        print("åŒæ­¥é€šä¿¡ç¤ºä¾‹:")
        
        # å‘é€è¯·æ±‚
        try:
            response = await client.get('/users/1')
            print(f"å“åº”: {response}")
        except Exception as e:
            print(f"è¯·æ±‚å¤±è´¥: {e}")
    
    # ç†”æ–­å™¨ç¤ºä¾‹
    circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30)
    
    def mock_service_call():
        import random
        if random.random() < 0.3:  # 30%å¤±è´¥ç‡
            raise Exception("Service error")
        return "Success"
    
    for i in range(5):
        try:
            result = circuit_breaker.call(mock_service_call)
            print(f"è°ƒç”¨ {i+1}: {result}")
        except Exception as e:
            print(f"è°ƒç”¨ {i+1}: {e}")
    
    return discovery

# è¿è¡Œç¤ºä¾‹
# asyncio.run(demonstrate_synchronous_communication())
```

#### 3.2 å¼‚æ­¥é€šä¿¡

**æ•°å­¦å®šä¹‰**ï¼š
å¼‚æ­¥é€šä¿¡ï¼š$Event \rightarrow Publish \rightarrow Subscribe$

**Pythonå®ç°**ï¼š

```python
import asyncio
from typing import Dict, List, Callable, Any
from dataclasses import dataclass
import json

@dataclass
class Event:
    """äº‹ä»¶"""
    event_id: str
    event_type: str
    source_service: str
    data: Dict[str, Any]
    timestamp: datetime
    correlation_id: str = None
    
    def __post_init__(self):
        if not self.event_id:
            self.event_id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = datetime.now()

class EventBus:
    """äº‹ä»¶æ€»çº¿"""
    
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.event_history: List[Event] = []
        self.max_history_size = 1000
    
    def subscribe(self, event_type: str, handler: Callable):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)
    
    def unsubscribe(self, event_type: str, handler: Callable):
        """å–æ¶ˆè®¢é˜…"""
        if event_type in self.subscribers:
            try:
                self.subscribers[event_type].remove(handler)
            except ValueError:
                pass
    
    async def publish(self, event: Event):
        """å‘å¸ƒäº‹ä»¶"""
        # æ·»åŠ åˆ°å†å²è®°å½•
        self.event_history.append(event)
        if len(self.event_history) > self.max_history_size:
            self.event_history.pop(0)
        
        # é€šçŸ¥è®¢é˜…è€…
        if event.event_type in self.subscribers:
            handlers = self.subscribers[event.event_type]
            tasks = []
            
            for handler in handlers:
                try:
                    if asyncio.iscoroutinefunction(handler):
                        task = asyncio.create_task(handler(event))
                        tasks.append(task)
                    else:
                        handler(event)
                except Exception as e:
                    print(f"Event handler error: {e}")
            
            # ç­‰å¾…å¼‚æ­¥å¤„ç†å™¨å®Œæˆ
            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)
    
    def get_events_by_type(self, event_type: str) -> List[Event]:
        """æ ¹æ®ç±»å‹è·å–äº‹ä»¶"""
        return [e for e in self.event_history if e.event_type == event_type]
    
    def get_events_by_service(self, service_name: str) -> List[Event]:
        """æ ¹æ®æœåŠ¡è·å–äº‹ä»¶"""
        return [e for e in self.event_history if e.source_service == service_name]

class MessageQueue:
    """æ¶ˆæ¯é˜Ÿåˆ—"""
    
    def __init__(self):
        self.queues: Dict[str, List[Dict[str, Any]]] = {}
        self.consumers: Dict[str, List[Callable]] = {}
    
    def create_queue(self, queue_name: str):
        """åˆ›å»ºé˜Ÿåˆ—"""
        if queue_name not in self.queues:
            self.queues[queue_name] = []
            self.consumers[queue_name] = []
    
    def publish_message(self, queue_name: str, message: Dict[str, Any]):
        """å‘å¸ƒæ¶ˆæ¯"""
        if queue_name not in self.queues:
            self.create_queue(queue_name)
        
        message['timestamp'] = datetime.now().isoformat()
        message['message_id'] = str(uuid.uuid4())
        
        self.queues[queue_name].append(message)
        
        # é€šçŸ¥æ¶ˆè´¹è€…
        self._notify_consumers(queue_name, message)
    
    def subscribe(self, queue_name: str, consumer: Callable):
        """è®¢é˜…é˜Ÿåˆ—"""
        if queue_name not in self.consumers:
            self.create_queue(queue_name)
        
        self.consumers[queue_name].append(consumer)
    
    def _notify_consumers(self, queue_name: str, message: Dict[str, Any]):
        """é€šçŸ¥æ¶ˆè´¹è€…"""
        if queue_name in self.consumers:
            for consumer in self.consumers[queue_name]:
                try:
                    consumer(message)
                except Exception as e:
                    print(f"Consumer error: {e}")
    
    def get_queue_size(self, queue_name: str) -> int:
        """è·å–é˜Ÿåˆ—å¤§å°"""
        return len(self.queues.get(queue_name, []))

# ç¤ºä¾‹ï¼šå¼‚æ­¥é€šä¿¡
def demonstrate_asynchronous_communication():
    """æ¼”ç¤ºå¼‚æ­¥é€šä¿¡"""
    # äº‹ä»¶æ€»çº¿ç¤ºä¾‹
    event_bus = EventBus()
    
    # äº‹ä»¶å¤„ç†å™¨
    def user_created_handler(event: Event):
        print(f"å¤„ç†ç”¨æˆ·åˆ›å»ºäº‹ä»¶: {event.data}")
    
    def order_created_handler(event: Event):
        print(f"å¤„ç†è®¢å•åˆ›å»ºäº‹ä»¶: {event.data}")
    
    # è®¢é˜…äº‹ä»¶
    event_bus.subscribe('user.created', user_created_handler)
    event_bus.subscribe('order.created', order_created_handler)
    
    # å‘å¸ƒäº‹ä»¶
    user_event = Event(
        event_id="",
        event_type='user.created',
        source_service='user-service',
        data={'user_id': '123', 'name': 'John Doe'},
        timestamp=datetime.now()
    )
    
    order_event = Event(
        event_id="",
        event_type='order.created',
        source_service='order-service',
        data={'order_id': '456', 'user_id': '123'},
        timestamp=datetime.now()
    )
    
    print("å¼‚æ­¥é€šä¿¡ç¤ºä¾‹:")
    
    # å‘å¸ƒäº‹ä»¶
    asyncio.run(event_bus.publish(user_event))
    asyncio.run(event_bus.publish(order_event))
    
    # æ¶ˆæ¯é˜Ÿåˆ—ç¤ºä¾‹
    message_queue = MessageQueue()
    
    def email_consumer(message: Dict[str, Any]):
        print(f"å‘é€é‚®ä»¶: {message}")
    
    def notification_consumer(message: Dict[str, Any]):
        print(f"å‘é€é€šçŸ¥: {message}")
    
    # è®¢é˜…é˜Ÿåˆ—
    message_queue.subscribe('email-queue', email_consumer)
    message_queue.subscribe('notification-queue', notification_consumer)
    
    # å‘å¸ƒæ¶ˆæ¯
    message_queue.publish_message('email-queue', {
        'to': 'user@example.com',
        'subject': 'Welcome',
        'body': 'Welcome to our service!'
    })
    
    message_queue.publish_message('notification-queue', {
        'user_id': '123',
        'type': 'welcome',
        'message': 'Welcome!'
    })
    
    return event_bus, message_queue

# è¿è¡Œç¤ºä¾‹
event_bus, message_queue = demonstrate_asynchronous_communication()
```

### 4. ç›‘æ§ä¸å¯è§‚æµ‹æ€§

#### 4.1 æŒ‡æ ‡æ”¶é›†

**æ•°å­¦å®šä¹‰**ï¼š
æŒ‡æ ‡æ˜¯ä¸€ä¸ªæ—¶é—´åºåˆ—ï¼š$M(t) = \{value, timestamp, labels\}$

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Any, Optional
import time
from collections import defaultdict, deque

@dataclass
class Metric:
    """æŒ‡æ ‡"""
    name: str
    value: float
    timestamp: float
    labels: Dict[str, str]
    metric_type: str  # counter, gauge, histogram

class MetricsCollector:
    """æŒ‡æ ‡æ”¶é›†å™¨"""
    
    def __init__(self):
        self.metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        self.counters: Dict[str, int] = defaultdict(int)
        self.gauges: Dict[str, float] = defaultdict(float)
        self.histograms: Dict[str, List[float]] = defaultdict(list)
    
    def increment_counter(self, name: str, labels: Dict[str, str] = None, value: int = 1):
        """å¢åŠ è®¡æ•°å™¨"""
        self.counters[name] += value
        
        metric = Metric(
            name=name,
            value=float(self.counters[name]),
            timestamp=time.time(),
            labels=labels or {},
            metric_type='counter'
        )
        
        self.metrics[name].append(metric)
    
    def set_gauge(self, name: str, value: float, labels: Dict[str, str] = None):
        """è®¾ç½®ä»ªè¡¨"""
        self.gauges[name] = value
        
        metric = Metric(
            name=name,
            value=value,
            timestamp=time.time(),
            labels=labels or {},
            metric_type='gauge'
        )
        
        self.metrics[name].append(metric)
    
    def record_histogram(self, name: str, value: float, labels: Dict[str, str] = None):
        """è®°å½•ç›´æ–¹å›¾"""
        self.histograms[name].append(value)
        
        metric = Metric(
            name=name,
            value=value,
            timestamp=time.time(),
            labels=labels or {},
            metric_type='histogram'
        )
        
        self.metrics[name].append(metric)
    
    def get_metric_summary(self, name: str) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡æ‘˜è¦"""
        if name not in self.metrics:
            return {}
        
        metrics = list(self.metrics[name])
        if not metrics:
            return {}
        
        values = [m.value for m in metrics]
        
        return {
            'name': name,
            'count': len(values),
            'min': min(values),
            'max': max(values),
            'avg': sum(values) / len(values),
            'latest': values[-1],
            'type': metrics[0].metric_type
        }
    
    def get_all_metrics(self) -> Dict[str, Dict[str, Any]]:
        """è·å–æ‰€æœ‰æŒ‡æ ‡"""
        return {name: self.get_metric_summary(name) for name in self.metrics.keys()}

class DistributedTracing:
    """åˆ†å¸ƒå¼è¿½è¸ª"""
    
    def __init__(self):
        self.traces: Dict[str, List[Dict[str, Any]]] = {}
        self.current_trace_id: Optional[str] = None
        self.current_span_id: Optional[str] = None
    
    def start_trace(self, trace_id: str = None) -> str:
        """å¼€å§‹è¿½è¸ª"""
        if not trace_id:
            trace_id = str(uuid.uuid4())
        
        self.current_trace_id = trace_id
        self.traces[trace_id] = []
        
        return trace_id
    
    def start_span(self, span_name: str, service_name: str) -> str:
        """å¼€å§‹è·¨åº¦"""
        span_id = str(uuid.uuid4())
        
        span = {
            'span_id': span_id,
            'trace_id': self.current_trace_id,
            'name': span_name,
            'service': service_name,
            'start_time': time.time(),
            'end_time': None,
            'tags': {},
            'logs': []
        }
        
        if self.current_trace_id:
            self.traces[self.current_trace_id].append(span)
        
        self.current_span_id = span_id
        return span_id
    
    def end_span(self, span_id: str):
        """ç»“æŸè·¨åº¦"""
        if self.current_trace_id:
            for span in self.traces[self.current_trace_id]:
                if span['span_id'] == span_id:
                    span['end_time'] = time.time()
                    break
    
    def add_tag(self, key: str, value: str):
        """æ·»åŠ æ ‡ç­¾"""
        if self.current_trace_id and self.current_span_id:
            for span in self.traces[self.current_trace_id]:
                if span['span_id'] == self.current_span_id:
                    span['tags'][key] = value
                    break
    
    def add_log(self, message: str, level: str = "INFO"):
        """æ·»åŠ æ—¥å¿—"""
        if self.current_trace_id and self.current_span_id:
            for span in self.traces[self.current_trace_id]:
                if span['span_id'] == self.current_span_id:
                    span['logs'].append({
                        'timestamp': time.time(),
                        'level': level,
                        'message': message
                    })
                    break
    
    def get_trace(self, trace_id: str) -> List[Dict[str, Any]]:
        """è·å–è¿½è¸ª"""
        return self.traces.get(trace_id, [])

# ç¤ºä¾‹ï¼šç›‘æ§ä¸å¯è§‚æµ‹æ€§
def demonstrate_monitoring():
    """æ¼”ç¤ºç›‘æ§ä¸å¯è§‚æµ‹æ€§"""
    # æŒ‡æ ‡æ”¶é›†
    metrics = MetricsCollector()
    
    # è®°å½•æŒ‡æ ‡
    metrics.increment_counter('http_requests_total', {'method': 'GET', 'status': '200'})
    metrics.increment_counter('http_requests_total', {'method': 'POST', 'status': '200'})
    metrics.increment_counter('http_requests_total', {'method': 'GET', 'status': '404'})
    
    metrics.set_gauge('active_connections', 42.0, {'service': 'user-service'})
    metrics.set_gauge('memory_usage', 0.75, {'service': 'user-service'})
    
    metrics.record_histogram('request_duration', 0.1)
    metrics.record_histogram('request_duration', 0.2)
    metrics.record_histogram('request_duration', 0.15)
    
    print("ç›‘æ§ä¸å¯è§‚æµ‹æ€§ç¤ºä¾‹:")
    print("æŒ‡æ ‡æ‘˜è¦:")
    for name, summary in metrics.get_all_metrics().items():
        print(f"  {name}: {summary}")
    
    # åˆ†å¸ƒå¼è¿½è¸ª
    tracing = DistributedTracing()
    
    # å¼€å§‹è¿½è¸ª
    trace_id = tracing.start_trace()
    
    # ç”¨æˆ·æœåŠ¡è·¨åº¦
    span1 = tracing.start_span('get_user', 'user-service')
    tracing.add_tag('user_id', '123')
    tracing.add_log('Fetching user from database')
    time.sleep(0.1)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    tracing.end_span(span1)
    
    # è®¢å•æœåŠ¡è·¨åº¦
    span2 = tracing.start_span('create_order', 'order-service')
    tracing.add_tag('order_id', '456')
    tracing.add_log('Creating order')
    time.sleep(0.2)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    tracing.end_span(span2)
    
    print(f"\nè¿½è¸ªä¿¡æ¯:")
    trace = tracing.get_trace(trace_id)
    for span in trace:
        duration = span['end_time'] - span['start_time']
        print(f"  è·¨åº¦: {span['name']} ({span['service']}) - {duration:.3f}s")
        print(f"    æ ‡ç­¾: {span['tags']}")
        for log in span['logs']:
            print(f"    æ—¥å¿—: {log['message']}")
    
    return metrics, tracing

# è¿è¡Œç¤ºä¾‹
metrics, tracing = demonstrate_monitoring()
```

## ğŸ“Š å¾®æœåŠ¡æ¶æ„æ€»ç»“

### æ ¸å¿ƒç‰¹å¾

1. **æœåŠ¡ç‹¬ç«‹æ€§**ï¼šæ¯ä¸ªæœåŠ¡ç‹¬ç«‹éƒ¨ç½²å’Œæ‰©å±•
2. **æŠ€æœ¯å¤šæ ·æ€§**ï¼šä¸åŒæœåŠ¡å¯ä½¿ç”¨ä¸åŒæŠ€æœ¯æ ˆ
3. **æ•°æ®éš”ç¦»**ï¼šæ¯ä¸ªæœåŠ¡ç®¡ç†è‡ªå·±çš„æ•°æ®
4. **æ•…éšœéš”ç¦»**ï¼šå•ä¸ªæœåŠ¡æ•…éšœä¸å½±å“æ•´ä½“ç³»ç»Ÿ

### æ•°å­¦å½¢å¼åŒ–

å¾®æœåŠ¡æ¶æ„å¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦ç»“æ„è¡¨ç¤ºï¼š

$$MicroserviceArchitecture = (Services, Communication, Discovery, Monitoring)$$

### Pythonå®ç°éªŒè¯

```python
class MicroserviceArchitectureValidator:
    """å¾®æœåŠ¡æ¶æ„éªŒè¯å™¨"""
    
    def __init__(self):
        self.test_architecture = MicroserviceArchitecture()
    
    def validate_service_registration(self) -> bool:
        """éªŒè¯æœåŠ¡æ³¨å†Œ"""
        service = Service(
            service_id="",
            name="test-service",
            version="1.0.0",
            status=ServiceStatus.HEALTHY,
            endpoints=["/test"],
            dependencies=[],
            health_check_url="/health"
        )
        
        self.test_architecture.register_service(service)
        return len(self.test_architecture.list_services()) == 1
    
    def validate_service_discovery(self) -> bool:
        """éªŒè¯æœåŠ¡å‘ç°"""
        registry = ServiceRegistry()
        discovery = ServiceDiscovery(registry)
        
        service_info = {'host': 'localhost', 'port': 8080}
        registry.register_service('test-service', service_info)
        
        # æ¨¡æ‹Ÿå¼‚æ­¥è°ƒç”¨
        async def test_discovery():
            return await discovery.discover_service('test-service')
        
        result = asyncio.run(test_discovery())
        return result is not None
    
    def validate_load_balancing(self) -> bool:
        """éªŒè¯è´Ÿè½½å‡è¡¡"""
        load_balancer = LoadBalancer()
        
        instance = ServiceInstance("test", "localhost", 8080)
        load_balancer.add_instance(instance)
        
        next_instance = load_balancer.get_next_instance()
        return next_instance is not None
    
    def validate_event_bus(self) -> bool:
        """éªŒè¯äº‹ä»¶æ€»çº¿"""
        event_bus = EventBus()
        
        def test_handler(event):
            pass
        
        event_bus.subscribe('test.event', test_handler)
        return 'test.event' in event_bus.subscribers
    
    def run_all_tests(self) -> Dict[str, bool]:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        tests = {
            'service_registration': self.validate_service_registration(),
            'service_discovery': self.validate_service_discovery(),
            'load_balancing': self.validate_load_balancing(),
            'event_bus': self.validate_event_bus()
        }
        
        print("=== å¾®æœåŠ¡æ¶æ„éªŒè¯ç»“æœ ===")
        for test_name, result in tests.items():
            print(f"{test_name}: {'PASS' if result else 'FAIL'}")
        
        return tests

# ä½¿ç”¨ç¤ºä¾‹
validator = MicroserviceArchitectureValidator()
test_results = validator.run_all_tests()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [03.01 è®¾è®¡æ¨¡å¼ç§‘å­¦](../03-å…·ä½“ç§‘å­¦/03.01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md)
- [04.01 é‡‘èç§‘æŠ€](../04-è¡Œä¸šé¢†åŸŸ/04.01-é‡‘èç§‘æŠ€.md)
- [05.02 äº‹ä»¶é©±åŠ¨æ¶æ„](./05.02-äº‹ä»¶é©±åŠ¨æ¶æ„.md)

---

*å¾®æœåŠ¡æ¶æ„ä¸ºç°ä»£è½¯ä»¶ç³»ç»Ÿæä¾›äº†çµæ´»ã€å¯æ‰©å±•çš„æ¶æ„æ¨¡å¼ï¼Œé€šè¿‡å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºé«˜æ€§èƒ½ã€é«˜å¯ç”¨çš„åˆ†å¸ƒå¼ç³»ç»Ÿã€‚*
