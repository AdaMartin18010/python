# 05.1 è®¾è®¡æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

è®¾è®¡æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­è§£å†³å¸¸è§è®¾è®¡é—®é¢˜çš„æ ‡å‡†åŒ–è§£å†³æ–¹æ¡ˆã€‚æœ¬ç« èŠ‚ä»å½¢å¼åŒ–è§’åº¦åˆ†æè®¾è®¡æ¨¡å¼ï¼Œæä¾›æ•°å­¦å®šä¹‰ã€è¯æ˜å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¾è®¡æ¨¡å¼çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 æ¨¡å¼åŸºç¡€å®šä¹‰

**å®šä¹‰ 1.1.1** è®¾è®¡æ¨¡å¼æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{P} = (N, C, S, F, E)$ï¼Œå…¶ä¸­ï¼š

- $N$ æ˜¯æ¨¡å¼åç§° (Name)
- $C$ æ˜¯ä¸Šä¸‹æ–‡ (Context)
- $S$ æ˜¯è§£å†³æ–¹æ¡ˆ (Solution)
- $F$ æ˜¯å½¢å¼åŒ–æè¿° (Formal Description)
- $E$ æ˜¯æ•ˆæœ (Effects)

**å®šä¹‰ 1.1.2** æ¨¡å¼åˆ†ç±»å‡½æ•° $\mathcal{C}: \mathcal{P} \rightarrow \{C, S, B\}$ï¼Œå…¶ä¸­ï¼š

- $C$ è¡¨ç¤ºåˆ›å»ºå‹æ¨¡å¼ (Creational)
- $S$ è¡¨ç¤ºç»“æ„å‹æ¨¡å¼ (Structural)
- $B$ è¡¨ç¤ºè¡Œä¸ºå‹æ¨¡å¼ (Behavioral)

#### 1.2 æ¨¡å¼å…³ç³»å›¾

**å®šä¹‰ 1.2.1** æ¨¡å¼å…³ç³»å›¾ $\mathcal{G} = (V, E)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯æ¨¡å¼é›†åˆ
- $E$ æ˜¯æ¨¡å¼é—´çš„å…³ç³»é›†åˆ

**Python å®ç°**ï¼š

```python
from typing import Dict, List, Any, Set, Optional
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod
import networkx as nx
import matplotlib.pyplot as plt

class PatternType(Enum):
    """æ¨¡å¼ç±»å‹"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"

class PatternCategory(Enum):
    """æ¨¡å¼åˆ†ç±»"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"
    CONCURRENT = "concurrent"
    DISTRIBUTED = "distributed"
    WORKFLOW = "workflow"

@dataclass
class PatternContext:
    """æ¨¡å¼ä¸Šä¸‹æ–‡"""
    problem: str
    constraints: List[str]
    forces: List[str]

@dataclass
class PatternSolution:
    """æ¨¡å¼è§£å†³æ–¹æ¡ˆ"""
    structure: Dict[str, Any]
    participants: List[str]
    collaborations: List[str]

@dataclass
class PatternEffects:
    """æ¨¡å¼æ•ˆæœ"""
    benefits: List[str]
    liabilities: List[str]
    trade_offs: List[str]

class DesignPattern:
    """è®¾è®¡æ¨¡å¼åŸºç±»"""
    
    def __init__(self, name: str, pattern_type: PatternType, 
                 context: PatternContext, solution: PatternSolution,
                 effects: PatternEffects):
        self.name = name
        self.pattern_type = pattern_type
        self.context = context
        self.solution = solution
        self.effects = effects
        self.formal_description = self._generate_formal_description()
    
    def _generate_formal_description(self) -> str:
        """ç”Ÿæˆå½¢å¼åŒ–æè¿°"""
        return f"Pattern({self.name}, {self.pattern_type.value})"
    
    def get_classification(self) -> PatternCategory:
        """è·å–æ¨¡å¼åˆ†ç±»"""
        return PatternCategory(self.pattern_type.value)
    
    def apply(self, target: Any) -> Any:
        """åº”ç”¨æ¨¡å¼"""
        raise NotImplementedError("Subclasses must implement apply method")
    
    def validate(self, implementation: Any) -> bool:
        """éªŒè¯æ¨¡å¼å®ç°"""
        raise NotImplementedError("Subclasses must implement validate method")

class PatternRegistry:
    """æ¨¡å¼æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self.patterns: Dict[str, DesignPattern] = {}
        self.relationships: nx.DiGraph = nx.DiGraph()
    
    def register_pattern(self, pattern: DesignPattern):
        """æ³¨å†Œæ¨¡å¼"""
        self.patterns[pattern.name] = pattern
        self.relationships.add_node(pattern.name, pattern=pattern)
    
    def add_relationship(self, pattern1: str, pattern2: str, relationship_type: str):
        """æ·»åŠ æ¨¡å¼å…³ç³»"""
        self.relationships.add_edge(pattern1, pattern2, type=relationship_type)
    
    def get_pattern(self, name: str) -> Optional[DesignPattern]:
        """è·å–æ¨¡å¼"""
        return self.patterns.get(name)
    
    def get_related_patterns(self, pattern_name: str) -> List[str]:
        """è·å–ç›¸å…³æ¨¡å¼"""
        if pattern_name in self.relationships:
            return list(self.relationships.successors(pattern_name))
        return []
    
    def visualize_relationships(self):
        """å¯è§†åŒ–æ¨¡å¼å…³ç³»"""
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(self.relationships)
        nx.draw(self.relationships, pos, with_labels=True, 
                node_color='lightblue', node_size=2000, 
                font_size=8, font_weight='bold')
        plt.title("Design Pattern Relationships")
        plt.show()
```

### 2. åˆ›å»ºå‹æ¨¡å¼ (Creational Patterns)

#### 2.1 å•ä¾‹æ¨¡å¼ (Singleton)

**å®šä¹‰ 2.1.1** å•ä¾‹æ¨¡å¼ $\mathcal{S}_{singleton}$ å®šä¹‰ä¸ºï¼š

$$\mathcal{S}_{singleton} = \{s \in \mathcal{S} | \forall s' \in \mathcal{S}, s = s'\}$$

å…¶ä¸­ $\mathcal{S}$ æ˜¯ç±»çš„æ‰€æœ‰å®ä¾‹é›†åˆã€‚

**å®šç† 2.1.1** å•ä¾‹å”¯ä¸€æ€§å®šç†

å¯¹äºä»»æ„å•ä¾‹ç±» $C$ï¼Œå…¶å®ä¾‹é›†åˆ $\mathcal{I}_C$ æ»¡è¶³ï¼š

$$|\mathcal{I}_C| = 1$$

**è¯æ˜**ï¼š

1. å‡è®¾å­˜åœ¨ä¸¤ä¸ªå®ä¾‹ $i_1, i_2 \in \mathcal{I}_C$
2. æ ¹æ®å•ä¾‹æ¨¡å¼å®šä¹‰ï¼Œ$i_1 = i_2$
3. å› æ­¤ $|\mathcal{I}_C| = 1$

**Python å®ç°**ï¼š

```python
from typing import Optional, Any
import threading
from functools import wraps

class Singleton:
    """å•ä¾‹æ¨¡å¼è£…é¥°å™¨"""
    
    def __init__(self, cls):
        self._cls = cls
        self._instance: Optional[Any] = None
        self._lock = threading.Lock()
    
    def __call__(self, *args, **kwargs):
        if self._instance is None:
            with self._lock:
                if self._instance is None:
                    self._instance = self._cls(*args, **kwargs)
        return self._instance

class ThreadSafeSingleton:
    """çº¿ç¨‹å®‰å…¨å•ä¾‹æ¨¡å¼"""
    
    _instance: Optional['ThreadSafeSingleton'] = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
            self._data = {}
    
    def set_data(self, key: str, value: Any):
        """è®¾ç½®æ•°æ®"""
        self._data[key] = value
    
    def get_data(self, key: str) -> Any:
        """è·å–æ•°æ®"""
        return self._data.get(key)

# ä½¿ç”¨è£…é¥°å™¨å®ç°å•ä¾‹
@Singleton
class Configuration:
    """é…ç½®ç®¡ç†å™¨å•ä¾‹"""
    
    def __init__(self):
        self._config = {}
    
    def set_config(self, key: str, value: Any):
        """è®¾ç½®é…ç½®"""
        self._config[key] = value
    
    def get_config(self, key: str, default: Any = None) -> Any:
        """è·å–é…ç½®"""
        return self._config.get(key, default)
    
    def get_all_config(self) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰é…ç½®"""
        return self._config.copy()

# éªŒè¯å•ä¾‹æ¨¡å¼
def verify_singleton_pattern():
    """éªŒè¯å•ä¾‹æ¨¡å¼"""
    # åˆ›å»ºå¤šä¸ªå®ä¾‹
    config1 = Configuration()
    config2 = Configuration()
    
    # éªŒè¯æ˜¯å¦ä¸ºåŒä¸€å®ä¾‹
    assert config1 is config2, "Singleton pattern failed: instances are not the same"
    
    # éªŒè¯æ•°æ®å…±äº«
    config1.set_config("database_url", "localhost:5432")
    assert config2.get_config("database_url") == "localhost:5432", "Data sharing failed"
    
    print("Singleton pattern verification passed!")
    return True
```

#### 2.2 å·¥å‚æ–¹æ³•æ¨¡å¼ (Factory Method)

**å®šä¹‰ 2.2.1** å·¥å‚æ–¹æ³•æ¨¡å¼ $\mathcal{F}_{factory}$ å®šä¹‰ä¸ºï¼š

$$\mathcal{F}_{factory} = \{(C, P, F) | C \in \mathcal{C}, P \in \mathcal{P}, F: C \rightarrow P\}$$

å…¶ä¸­ï¼š

- $\mathcal{C}$ æ˜¯åˆ›å»ºè€…ç±»é›†åˆ
- $\mathcal{P}$ æ˜¯äº§å“ç±»é›†åˆ
- $F$ æ˜¯å·¥å‚æ–¹æ³•

**å®šç† 2.2.1** å·¥å‚æ–¹æ³•æ­£ç¡®æ€§å®šç†

å¯¹äºå·¥å‚æ–¹æ³• $F: C \rightarrow P$ï¼Œå¦‚æœ $c \in C$ ä¸” $p = F(c)$ï¼Œåˆ™ï¼š

$$p \in P \land \text{type}(p) \subseteq \text{type}(P)$$

**Python å®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Dict, Type

T = TypeVar('T')

class Product(ABC):
    """äº§å“æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def operation(self) -> str:
        """äº§å“æ“ä½œ"""
        pass

class ConcreteProductA(Product):
    """å…·ä½“äº§å“A"""
    
    def operation(self) -> str:
        return "ConcreteProductA operation"

class ConcreteProductB(Product):
    """å…·ä½“äº§å“B"""
    
    def operation(self) -> str:
        return "ConcreteProductB operation"

class Creator(ABC):
    """åˆ›å»ºè€…æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def factory_method(self) -> Product:
        """å·¥å‚æ–¹æ³•"""
        pass
    
    def some_operation(self) -> str:
        """ä½¿ç”¨å·¥å‚æ–¹æ³•çš„æ“ä½œ"""
        product = self.factory_method()
        return f"Creator: {product.operation()}"

class ConcreteCreatorA(Creator):
    """å…·ä½“åˆ›å»ºè€…A"""
    
    def factory_method(self) -> Product:
        return ConcreteProductA()

class ConcreteCreatorB(Creator):
    """å…·ä½“åˆ›å»ºè€…B"""
    
    def factory_method(self) -> Product:
        return ConcreteProductB()

class ProductRegistry:
    """äº§å“æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self._products: Dict[str, Type[Product]] = {}
    
    def register_product(self, name: str, product_class: Type[Product]):
        """æ³¨å†Œäº§å“"""
        self._products[name] = product_class
    
    def create_product(self, name: str) -> Product:
        """åˆ›å»ºäº§å“"""
        if name not in self._products:
            raise ValueError(f"Product {name} not registered")
        return self._products[name]()

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_factory_method():
    """æ¼”ç¤ºå·¥å‚æ–¹æ³•æ¨¡å¼"""
    # ä¼ ç»Ÿå·¥å‚æ–¹æ³•
    creator_a = ConcreteCreatorA()
    creator_b = ConcreteCreatorB()
    
    print(creator_a.some_operation())
    print(creator_b.some_operation())
    
    # ä½¿ç”¨äº§å“æ³¨å†Œè¡¨
    registry = ProductRegistry()
    registry.register_product("A", ConcreteProductA)
    registry.register_product("B", ConcreteProductB)
    
    product_a = registry.create_product("A")
    product_b = registry.create_product("B")
    
    print(product_a.operation())
    print(product_b.operation())
    
    return registry
```

### 3. ç»“æ„å‹æ¨¡å¼ (Structural Patterns)

#### 3.1 é€‚é…å™¨æ¨¡å¼ (Adapter)

**å®šä¹‰ 3.1.1** é€‚é…å™¨æ¨¡å¼ $\mathcal{A}_{adapter}$ å®šä¹‰ä¸ºï¼š

$$\mathcal{A}_{adapter} = \{(T, A, F) | T \in \mathcal{T}, A \in \mathcal{A}, F: T \rightarrow A\}$$

å…¶ä¸­ï¼š

- $\mathcal{T}$ æ˜¯ç›®æ ‡æ¥å£é›†åˆ
- $\mathcal{A}$ æ˜¯é€‚é…å™¨é›†åˆ
- $F$ æ˜¯é€‚é…å‡½æ•°

**Python å®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import Any

class Target(ABC):
    """ç›®æ ‡æ¥å£"""
    
    @abstractmethod
    def request(self) -> str:
        """ç›®æ ‡è¯·æ±‚"""
        pass

class Adaptee:
    """éœ€è¦é€‚é…çš„ç±»"""
    
    def specific_request(self) -> str:
        """ç‰¹å®šè¯·æ±‚"""
        return "Adaptee specific request"

class Adapter(Target):
    """é€‚é…å™¨"""
    
    def __init__(self, adaptee: Adaptee):
        self._adaptee = adaptee
    
    def request(self) -> str:
        """é€‚é…ç›®æ ‡è¯·æ±‚"""
        return f"Adapter: {self._adaptee.specific_request()}"

class ObjectAdapter(Target):
    """å¯¹è±¡é€‚é…å™¨"""
    
    def __init__(self, adaptee: Adaptee):
        self._adaptee = adaptee
    
    def request(self) -> str:
        """é€‚é…ç›®æ ‡è¯·æ±‚"""
        return f"Object Adapter: {self._adaptee.specific_request()}"

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_adapter():
    """æ¼”ç¤ºé€‚é…å™¨æ¨¡å¼"""
    adaptee = Adaptee()
    
    # ç±»é€‚é…å™¨
    adapter = Adapter(adaptee)
    print(adapter.request())
    
    # å¯¹è±¡é€‚é…å™¨
    object_adapter = ObjectAdapter(adaptee)
    print(object_adapter.request())
    
    return adapter, object_adapter
```

#### 3.2 è£…é¥°å™¨æ¨¡å¼ (Decorator)

**å®šä¹‰ 3.2.1** è£…é¥°å™¨æ¨¡å¼ $\mathcal{D}_{decorator}$ å®šä¹‰ä¸ºï¼š

$$\mathcal{D}_{decorator} = \{(C, D, F) | C \in \mathcal{C}, D \in \mathcal{D}, F: C \rightarrow D\}$$

å…¶ä¸­è£…é¥°å™¨ $D$ æ»¡è¶³ï¼š

$$D(c) = c \oplus \text{additional\_behavior}$$

**Python å®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import Any

class Component(ABC):
    """ç»„ä»¶æ¥å£"""
    
    @abstractmethod
    def operation(self) -> str:
        """ç»„ä»¶æ“ä½œ"""
        pass

class ConcreteComponent(Component):
    """å…·ä½“ç»„ä»¶"""
    
    def operation(self) -> str:
        return "ConcreteComponent"

class Decorator(Component):
    """è£…é¥°å™¨åŸºç±»"""
    
    def __init__(self, component: Component):
        self._component = component
    
    def operation(self) -> str:
        return self._component.operation()

class ConcreteDecoratorA(Decorator):
    """å…·ä½“è£…é¥°å™¨A"""
    
    def operation(self) -> str:
        return f"ConcreteDecoratorA({super().operation()})"

class ConcreteDecoratorB(Decorator):
    """å…·ä½“è£…é¥°å™¨B"""
    
    def operation(self) -> str:
        return f"ConcreteDecoratorB({super().operation()})"

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_decorator():
    """æ¼”ç¤ºè£…é¥°å™¨æ¨¡å¼"""
    component = ConcreteComponent()
    
    # å•ä¸ªè£…é¥°å™¨
    decorated_a = ConcreteDecoratorA(component)
    print(decorated_a.operation())
    
    # å¤šä¸ªè£…é¥°å™¨
    decorated_both = ConcreteDecoratorB(ConcreteDecoratorA(component))
    print(decorated_both.operation())
    
    return decorated_both
```

### 4. è¡Œä¸ºå‹æ¨¡å¼ (Behavioral Patterns)

#### 4.1 è§‚å¯Ÿè€…æ¨¡å¼ (Observer)

**å®šä¹‰ 4.1.1** è§‚å¯Ÿè€…æ¨¡å¼ $\mathcal{O}_{observer}$ å®šä¹‰ä¸ºï¼š

$$\mathcal{O}_{observer} = \{(S, O, N) | S \in \mathcal{S}, O \subseteq \mathcal{O}, N: S \times O \rightarrow \text{Notification}\}$$

å…¶ä¸­ï¼š

- $\mathcal{S}$ æ˜¯ä¸»é¢˜é›†åˆ
- $\mathcal{O}$ æ˜¯è§‚å¯Ÿè€…é›†åˆ
- $N$ æ˜¯é€šçŸ¥å‡½æ•°

**Python å®ç°**ï¼š

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class Event:
    """äº‹ä»¶"""
    type: str
    data: Any
    timestamp: float

class Observer(ABC):
    """è§‚å¯Ÿè€…æ¥å£"""
    
    @abstractmethod
    def update(self, event: Event):
        """æ›´æ–°æ–¹æ³•"""
        pass

class Subject(ABC):
    """ä¸»é¢˜æ¥å£"""
    
    def __init__(self):
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer):
        """æ·»åŠ è§‚å¯Ÿè€…"""
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: Observer):
        """ç§»é™¤è§‚å¯Ÿè€…"""
        self._observers.remove(observer)
    
    def notify(self, event: Event):
        """é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…"""
        for observer in self._observers:
            observer.update(event)

class ConcreteSubject(Subject):
    """å…·ä½“ä¸»é¢˜"""
    
    def __init__(self, name: str):
        super().__init__()
        self.name = name
        self._state = {}
    
    def set_state(self, key: str, value: Any):
        """è®¾ç½®çŠ¶æ€"""
        self._state[key] = value
        event = Event("state_changed", {"key": key, "value": value}, 0.0)
        self.notify(event)
    
    def get_state(self, key: str) -> Any:
        """è·å–çŠ¶æ€"""
        return self._state.get(key)

class ConcreteObserver(Observer):
    """å…·ä½“è§‚å¯Ÿè€…"""
    
    def __init__(self, name: str):
        self.name = name
        self.received_events: List[Event] = []
    
    def update(self, event: Event):
        """æ›´æ–°æ–¹æ³•"""
        self.received_events.append(event)
        print(f"Observer {self.name} received event: {event}")

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_observer():
    """æ¼”ç¤ºè§‚å¯Ÿè€…æ¨¡å¼"""
    subject = ConcreteSubject("DataStore")
    
    observer1 = ConcreteObserver("Logger")
    observer2 = ConcreteObserver("UI")
    
    subject.attach(observer1)
    subject.attach(observer2)
    
    # è§¦å‘çŠ¶æ€å˜åŒ–
    subject.set_state("user_count", 100)
    subject.set_state("status", "active")
    
    # ç§»é™¤è§‚å¯Ÿè€…
    subject.detach(observer1)
    subject.set_state("last_login", "2024-01-01")
    
    return subject, observer1, observer2
```

### 5. æ¨¡å¼éªŒè¯ä¸æµ‹è¯•

#### 5.1 æ¨¡å¼æ­£ç¡®æ€§éªŒè¯

**å®šä¹‰ 5.1.1** æ¨¡å¼æ­£ç¡®æ€§éªŒè¯å‡½æ•° $V: \mathcal{P} \rightarrow \{0, 1\}$ï¼š

$$V(p) = \begin{cases}
1 & \text{if } p \text{ is correctly implemented} \\
0 & \text{otherwise}
\end{cases}$$

**Python å®ç°**ï¼š

```python
from typing import Callable, Any, Dict
import unittest

class PatternValidator:
    """æ¨¡å¼éªŒè¯å™¨"""

    def __init__(self):
        self.validation_rules: Dict[str, Callable] = {}

    def register_validation_rule(self, pattern_name: str, rule: Callable):
        """æ³¨å†ŒéªŒè¯è§„åˆ™"""
        self.validation_rules[pattern_name] = rule

    def validate_pattern(self, pattern_name: str, implementation: Any) -> bool:
        """éªŒè¯æ¨¡å¼å®ç°"""
        if pattern_name in self.validation_rules:
            return self.validation_rules[pattern_name](implementation)
        return False

class PatternTestSuite(unittest.TestCase):
    """æ¨¡å¼æµ‹è¯•å¥—ä»¶"""

    def test_singleton_pattern(self):
        """æµ‹è¯•å•ä¾‹æ¨¡å¼"""
        config1 = Configuration()
        config2 = Configuration()

        self.assertIs(config1, config2)
        self.assertEqual(id(config1), id(config2))

    def test_factory_method_pattern(self):
        """æµ‹è¯•å·¥å‚æ–¹æ³•æ¨¡å¼"""
        creator_a = ConcreteCreatorA()
        creator_b = ConcreteCreatorB()

        product_a = creator_a.factory_method()
        product_b = creator_b.factory_method()

        self.assertIsInstance(product_a, ConcreteProductA)
        self.assertIsInstance(product_b, ConcreteProductB)

    def test_adapter_pattern(self):
        """æµ‹è¯•é€‚é…å™¨æ¨¡å¼"""
        adaptee = Adaptee()
        adapter = Adapter(adaptee)

        result = adapter.request()
        self.assertIn("Adapter", result)
        self.assertIn("specific request", result)

    def test_decorator_pattern(self):
        """æµ‹è¯•è£…é¥°å™¨æ¨¡å¼"""
        component = ConcreteComponent()
        decorated = ConcreteDecoratorA(component)

        result = decorated.operation()
        self.assertIn("ConcreteDecoratorA", result)
        self.assertIn("ConcreteComponent", result)

    def test_observer_pattern(self):
        """æµ‹è¯•è§‚å¯Ÿè€…æ¨¡å¼"""
        subject = ConcreteSubject("Test")
        observer = ConcreteObserver("TestObserver")

        subject.attach(observer)
        subject.set_state("test", "value")

        self.assertEqual(len(observer.received_events), 1)
        self.assertEqual(observer.received_events[0].type, "state_changed")

# è¿è¡Œæµ‹è¯•
def run_pattern_tests():
    """è¿è¡Œæ¨¡å¼æµ‹è¯•"""
    unittest.main(argv=[''], exit=False, verbosity=2)
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [05.2 å¾®æœåŠ¡æ¶æ„](./02-å¾®æœåŠ¡æ¶æ„.md)
- [05.3 åˆ†å¸ƒå¼ç³»ç»Ÿ](./03-åˆ†å¸ƒå¼ç³»ç»Ÿ.md)
- [06.1 æ ¸å¿ƒç®—æ³•](../06-ç»„ä»¶ç®—æ³•/01-æ ¸å¿ƒç®—æ³•.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented software. Pearson Education.
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head first design patterns. O'Reilly Media, Inc.
3. Schmidt, D., Stal, M., Rohnert, H., & Buschmann, F. (2013). Pattern-oriented software architecture, patterns for concurrent and networked objects. John Wiley & Sons.

---

**ä¸‹ä¸€èŠ‚**: [05.2 å¾®æœåŠ¡æ¶æ„](./02-å¾®æœåŠ¡æ¶æ„.md)
