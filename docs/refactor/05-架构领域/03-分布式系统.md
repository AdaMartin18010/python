# 分布式系统架构设计

## 1. 概述

### 1.1 分布式系统定义

**定义 1.1.1 (分布式系统)**
分布式系统是由多个独立节点组成的系统，节点通过网络通信协作完成任务：

$$\text{DistributedSystem} = (N, C, S, P)$$

其中：

- $N = \{n_1, n_2, ..., n_k\}$ 是节点集合
- $C = \{c_1, c_2, ..., c_m\}$ 是通信链路集合
- $S = \{s_1, s_2, ..., s_l\}$ 是状态集合
- $P = \{p_1, p_2, ..., p_n\}$ 是协议集合

### 1.2 分布式系统特性

**定理 1.1.1 (CAP定理)**
分布式系统最多只能同时满足一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)中的两个：

$$\text{CAP} = \text{Consistency} \land \text{Availability} \land \text{PartitionTolerance} = \text{False}$$

*证明*：当网络分区发生时，系统必须在一致性和可用性之间做出选择。

## 2. 一致性模型

### 2.1 强一致性

**定义 2.1.1 (强一致性)**
强一致性确保所有节点看到相同的数据状态：

```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import asyncio
import uuid

@dataclass
class DataItem:
    """数据项"""
    key: str
    value: Any
    version: int
    timestamp: datetime
    node_id: str

@dataclass
class ConsistencyRequest:
    """一致性请求"""
    id: str
    operation: str  # read, write
    key: str
    value: Any = None
    timestamp: datetime
    client_id: str

class StrongConsistencyNode:
    """强一致性节点"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.data: Dict[str, DataItem] = {}
        self.peers: List['StrongConsistencyNode'] = []
        self.pending_requests: Dict[str, ConsistencyRequest] = {}
        self.quorum_size: int = 2  # 需要多数节点确认
    
    def add_peer(self, peer: 'StrongConsistencyNode'):
        """添加对等节点"""
        if peer not in self.peers:
            self.peers.append(peer)
            peer.peers.append(self)
    
    async def write(self, key: str, value: Any) -> bool:
        """写入数据"""
        request_id = str(uuid.uuid4())
        request = ConsistencyRequest(
            id=request_id,
            operation='write',
            key=key,
            value=value,
            timestamp=datetime.now(),
            client_id='client'
        )
        
        # 准备阶段：获取多数节点确认
        prepare_responses = await self._prepare_write(request)
        
        if len(prepare_responses) < self.quorum_size:
            return False
        
        # 提交阶段：通知所有节点提交
        commit_responses = await self._commit_write(request)
        
        return len(commit_responses) >= self.quorum_size
    
    async def read(self, key: str) -> Optional[Any]:
        """读取数据"""
        request_id = str(uuid.uuid4())
        request = ConsistencyRequest(
            id=request_id,
            operation='read',
            key=key,
            timestamp=datetime.now(),
            client_id='client'
        )
        
        # 从多数节点读取最新值
        responses = await self._read_from_quorum(request)
        
        if not responses:
            return None
        
        # 选择最新版本的值
        latest_item = max(responses, key=lambda x: x.version)
        return latest_item.value
    
    async def _prepare_write(self, request: ConsistencyRequest) -> List[bool]:
        """准备阶段"""
        responses = []
        
        for peer in self.peers:
            try:
                response = await peer._handle_prepare(request)
                responses.append(response)
            except Exception as e:
                print(f"Prepare failed for peer {peer.node_id}: {e}")
        
        return responses
    
    async def _commit_write(self, request: ConsistencyRequest) -> List[bool]:
        """提交阶段"""
        responses = []
        
        for peer in self.peers:
            try:
                response = await peer._handle_commit(request)
                responses.append(response)
            except Exception as e:
                print(f"Commit failed for peer {peer.node_id}: {e}")
        
        return responses
    
    async def _read_from_quorum(self, request: ConsistencyRequest) -> List[DataItem]:
        """从多数节点读取"""
        responses = []
        
        for peer in self.peers:
            try:
                response = await peer._handle_read(request)
                if response:
                    responses.append(response)
            except Exception as e:
                print(f"Read failed for peer {peer.node_id}: {e}")
        
        return responses
    
    async def _handle_prepare(self, request: ConsistencyRequest) -> bool:
        """处理准备请求"""
        # 检查是否可以准备
        if request.key in self.data:
            current_version = self.data[request.key].version
        else:
            current_version = 0
        
        # 记录准备状态
        self.pending_requests[request.id] = request
        
        return True
    
    async def _handle_commit(self, request: ConsistencyRequest) -> bool:
        """处理提交请求"""
        if request.id not in self.pending_requests:
            return False
        
        # 执行写入
        if request.key in self.data:
            current_version = self.data[request.key].version
        else:
            current_version = 0
        
        data_item = DataItem(
            key=request.key,
            value=request.value,
            version=current_version + 1,
            timestamp=datetime.now(),
            node_id=self.node_id
        )
        
        self.data[request.key] = data_item
        
        # 清理准备状态
        del self.pending_requests[request.id]
        
        return True
    
    async def _handle_read(self, request: ConsistencyRequest) -> Optional[DataItem]:
        """处理读取请求"""
        return self.data.get(request.key)

# 使用示例
async def strong_consistency_example():
    """强一致性示例"""
    # 创建节点
    node1 = StrongConsistencyNode("node1")
    node2 = StrongConsistencyNode("node2")
    node3 = StrongConsistencyNode("node3")
    
    # 建立连接
    node1.add_peer(node2)
    node1.add_peer(node3)
    
    # 写入数据
    success = await node1.write("user:1", {"name": "Alice", "age": 30})
    print(f"Write success: {success}")
    
    # 读取数据
    value = await node1.read("user:1")
    print(f"Read value: {value}")
```

### 2.2 最终一致性

**定义 2.2.1 (最终一致性)**
最终一致性允许节点间存在短暂的不一致，但最终会收敛到一致状态：

```python
from typing import Dict, List, Any, Set
import asyncio
import time

@dataclass
class VectorClock:
    """向量时钟"""
    timestamps: Dict[str, int]
    
    def increment(self, node_id: str):
        """增加节点时间戳"""
        self.timestamps[node_id] = self.timestamps.get(node_id, 0) + 1
    
    def merge(self, other: 'VectorClock') -> 'VectorClock':
        """合并向量时钟"""
        merged = VectorClock({})
        all_nodes = set(self.timestamps.keys()) | set(other.timestamps.keys())
        
        for node in all_nodes:
            merged.timestamps[node] = max(
                self.timestamps.get(node, 0),
                other.timestamps.get(node, 0)
            )
        
        return merged
    
    def compare(self, other: 'VectorClock') -> str:
        """比较向量时钟"""
        less = False
        greater = False
        
        all_nodes = set(self.timestamps.keys()) | set(other.timestamps.keys())
        
        for node in all_nodes:
            self_time = self.timestamps.get(node, 0)
            other_time = other.timestamps.get(node, 0)
            
            if self_time < other_time:
                less = True
            elif self_time > other_time:
                greater = True
        
        if less and greater:
            return "concurrent"
        elif less:
            return "before"
        elif greater:
            return "after"
        else:
            return "equal"

@dataclass
class EventualConsistencyData:
    """最终一致性数据"""
    key: str
    value: Any
    vector_clock: VectorClock
    last_updated: float

class EventualConsistencyNode:
    """最终一致性节点"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.data: Dict[str, EventualConsistencyData] = {}
        self.peers: List['EventualConsistencyNode'] = []
        self.replication_queue: List[Dict[str, Any]] = []
        self.gossip_interval = 1.0  # 秒
    
    def add_peer(self, peer: 'EventualConsistencyNode'):
        """添加对等节点"""
        if peer not in self.peers:
            self.peers.append(peer)
            peer.peers.append(self)
    
    async def write(self, key: str, value: Any) -> bool:
        """写入数据"""
        # 更新向量时钟
        if key in self.data:
            vector_clock = self.data[key].vector_clock
        else:
            vector_clock = VectorClock({})
        
        vector_clock.increment(self.node_id)
        
        # 创建数据项
        data_item = EventualConsistencyData(
            key=key,
            value=value,
            vector_clock=vector_clock,
            last_updated=time.time()
        )
        
        self.data[key] = data_item
        
        # 添加到复制队列
        self.replication_queue.append({
            'key': key,
            'data': data_item,
            'timestamp': time.time()
        })
        
        return True
    
    async def read(self, key: str) -> Optional[Any]:
        """读取数据"""
        return self.data.get(key)
    
    async def start_gossip(self):
        """启动gossip协议"""
        while True:
            await asyncio.sleep(self.gossip_interval)
            await self._gossip()
    
    async def _gossip(self):
        """执行gossip传播"""
        if not self.peers or not self.replication_queue:
            return
        
        # 选择随机对等节点
        peer = random.choice(self.peers)
        
        # 发送待复制的数据
        for item in self.replication_queue[:5]:  # 限制每次发送的数量
            await peer._receive_gossip(item)
        
        # 清空已发送的队列
        self.replication_queue = self.replication_queue[5:]
    
    async def _receive_gossip(self, item: Dict[str, Any]):
        """接收gossip数据"""
        key = item['key']
        received_data = item['data']
        
        if key not in self.data:
            # 新数据，直接接受
            self.data[key] = received_data
        else:
            # 现有数据，需要解决冲突
            current_data = self.data[key]
            comparison = received_data.vector_clock.compare(current_data.vector_clock)
            
            if comparison == "after":
                # 接收的数据更新
                self.data[key] = received_data
            elif comparison == "concurrent":
                # 并发冲突，需要解决
                resolved_data = await self._resolve_conflict(current_data, received_data)
                self.data[key] = resolved_data
    
    async def _resolve_conflict(self, data1: EventualConsistencyData, 
                              data2: EventualConsistencyData) -> EventualConsistencyData:
        """解决冲突"""
        # 简单的冲突解决策略：选择时间戳更新的
        if data1.last_updated > data2.last_updated:
            return data1
        else:
            return data2
    
    def get_consistency_status(self) -> Dict[str, Any]:
        """获取一致性状态"""
        total_keys = len(self.data)
        replicated_keys = sum(1 for item in self.replication_queue if item['key'] in self.data)
        
        return {
            'node_id': self.node_id,
            'total_keys': total_keys,
            'pending_replication': len(self.replication_queue),
            'replication_ratio': replicated_keys / total_keys if total_keys > 0 else 0.0
        }
```

## 3. 容错机制

### 3.1 故障检测

**定义 3.1.1 (故障检测)**
故障检测机制识别系统中的故障节点：

```python
import asyncio
import time
from typing import Dict, Set, Optional

@dataclass
class NodeStatus:
    """节点状态"""
    node_id: str
    is_alive: bool
    last_heartbeat: float
    failure_count: int
    suspicion_level: float  # 0.0-1.0

class FailureDetector:
    """故障检测器"""
    
    def __init__(self, node_id: str, timeout: float = 5.0, suspicion_threshold: float = 0.8):
        self.node_id = node_id
        self.timeout = timeout
        self.suspicion_threshold = suspicion_threshold
        self.nodes: Dict[str, NodeStatus] = {}
        self.detection_callbacks: Dict[str, callable] = {}
    
    def add_node(self, node_id: str):
        """添加监控节点"""
        self.nodes[node_id] = NodeStatus(
            node_id=node_id,
            is_alive=True,
            last_heartbeat=time.time(),
            failure_count=0,
            suspicion_level=0.0
        )
    
    def remove_node(self, node_id: str):
        """移除监控节点"""
        if node_id in self.nodes:
            del self.nodes[node_id]
        if node_id in self.detection_callbacks:
            del self.detection_callbacks[node_id]
    
    def on_failure_detected(self, node_id: str, callback: callable):
        """设置故障检测回调"""
        self.detection_callbacks[node_id] = callback
    
    def receive_heartbeat(self, node_id: str):
        """接收心跳"""
        if node_id in self.nodes:
            node = self.nodes[node_id]
            node.last_heartbeat = time.time()
            node.is_alive = True
            node.failure_count = 0
            node.suspicion_level = 0.0
    
    async def start_detection(self):
        """启动故障检测"""
        while True:
            await asyncio.sleep(1.0)  # 每秒检查一次
            await self._check_nodes()
    
    async def _check_nodes(self):
        """检查节点状态"""
        current_time = time.time()
        
        for node_id, node in self.nodes.items():
            time_since_heartbeat = current_time - node.last_heartbeat
            
            if time_since_heartbeat > self.timeout:
                # 超时，增加怀疑度
                node.suspicion_level = min(1.0, node.suspicion_level + 0.2)
                node.failure_count += 1
                
                if node.suspicion_level >= self.suspicion_threshold:
                    # 标记为故障
                    if node.is_alive:
                        node.is_alive = False
                        await self._notify_failure(node_id)
            else:
                # 正常，减少怀疑度
                node.suspicion_level = max(0.0, node.suspicion_level - 0.1)
    
    async def _notify_failure(self, node_id: str):
        """通知故障"""
        print(f"Node {node_id} is suspected to be failed")
        
        if node_id in self.detection_callbacks:
            try:
                callback = self.detection_callbacks[node_id]
                if asyncio.iscoroutinefunction(callback):
                    await callback(node_id)
                else:
                    callback(node_id)
            except Exception as e:
                print(f"Error in failure callback: {e}")
    
    def get_node_status(self, node_id: str) -> Optional[NodeStatus]:
        """获取节点状态"""
        return self.nodes.get(node_id)
    
    def get_alive_nodes(self) -> Set[str]:
        """获取存活节点"""
        return {node_id for node_id, node in self.nodes.items() if node.is_alive}
    
    def get_failed_nodes(self) -> Set[str]:
        """获取故障节点"""
        return {node_id for node_id, node in self.nodes.items() if not node.is_alive}

class HeartbeatSender:
    """心跳发送器"""
    
    def __init__(self, node_id: str, interval: float = 2.0):
        self.node_id = node_id
        self.interval = interval
        self.receivers: List[FailureDetector] = []
    
    def add_receiver(self, detector: FailureDetector):
        """添加接收器"""
        self.receivers.append(detector)
    
    async def start_sending(self):
        """开始发送心跳"""
        while True:
            await asyncio.sleep(self.interval)
            await self._send_heartbeat()
    
    async def _send_heartbeat(self):
        """发送心跳"""
        for receiver in self.receivers:
            try:
                receiver.receive_heartbeat(self.node_id)
            except Exception as e:
                print(f"Failed to send heartbeat to {receiver.node_id}: {e}")
```

### 3.2 故障恢复

**定义 3.2.1 (故障恢复)**
故障恢复机制处理节点故障后的系统恢复：

```python
from typing import Dict, List, Any, Optional
import asyncio
import time

class RecoveryManager:
    """故障恢复管理器"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.failed_nodes: Set[str] = set()
        self.recovery_strategies: Dict[str, callable] = {}
        self.data_replicas: Dict[str, List[str]] = {}
    
    def register_recovery_strategy(self, failure_type: str, strategy: callable):
        """注册恢复策略"""
        self.recovery_strategies[failure_type] = strategy
    
    def add_data_replica(self, data_key: str, replica_nodes: List[str]):
        """添加数据副本"""
        self.data_replicas[data_key] = replica_nodes
    
    async def handle_node_failure(self, failed_node_id: str, failure_type: str = "general"):
        """处理节点故障"""
        self.failed_nodes.add(failed_node_id)
        
        print(f"Handling failure of node {failed_node_id}")
        
        # 执行恢复策略
        if failure_type in self.recovery_strategies:
            try:
                strategy = self.recovery_strategies[failure_type]
                if asyncio.iscoroutinefunction(strategy):
                    await strategy(failed_node_id)
                else:
                    strategy(failed_node_id)
            except Exception as e:
                print(f"Recovery strategy failed: {e}")
        
        # 重新分配数据副本
        await self._redistribute_replicas(failed_node_id)
    
    async def _redistribute_replicas(self, failed_node_id: str):
        """重新分配数据副本"""
        for data_key, replica_nodes in self.data_replicas.items():
            if failed_node_id in replica_nodes:
                # 移除故障节点
                replica_nodes.remove(failed_node_id)
                
                # 添加新的副本节点
                if len(replica_nodes) < 3:  # 保持3个副本
                    new_replica = await self._select_new_replica(data_key, replica_nodes)
                    if new_replica:
                        replica_nodes.append(new_replica)
                        print(f"Redistributed replica for {data_key} to {new_replica}")
    
    async def _select_new_replica(self, data_key: str, existing_replicas: List[str]) -> Optional[str]:
        """选择新的副本节点"""
        # 简化的选择策略：选择负载最低的节点
        # 实际实现中应该考虑节点容量、网络距离等
        available_nodes = set(self.get_available_nodes()) - set(existing_replicas)
        
        if available_nodes:
            return list(available_nodes)[0]  # 简化实现
        
        return None
    
    def get_available_nodes(self) -> List[str]:
        """获取可用节点"""
        # 简化实现，实际应该从集群管理器中获取
        return ["node1", "node2", "node3", "node4", "node5"]
    
    async def recover_node(self, node_id: str):
        """恢复节点"""
        if node_id in self.failed_nodes:
            self.failed_nodes.remove(node_id)
            print(f"Node {node_id} recovered")
            
            # 重新加入集群
            await self._rejoin_cluster(node_id)
    
    async def _rejoin_cluster(self, node_id: str):
        """重新加入集群"""
        # 同步数据状态
        await self._sync_data_state(node_id)
        
        # 更新副本分配
        await self._update_replica_assignment(node_id)
    
    async def _sync_data_state(self, node_id: str):
        """同步数据状态"""
        # 从其他节点获取最新数据
        print(f"Syncing data state for node {node_id}")
        await asyncio.sleep(1.0)  # 模拟同步过程
    
    async def _update_replica_assignment(self, node_id: str):
        """更新副本分配"""
        # 重新分配部分数据副本给恢复的节点
        print(f"Updating replica assignment for node {node_id}")
        await asyncio.sleep(0.5)  # 模拟分配过程

# 恢复策略示例
async def data_replication_strategy(failed_node_id: str):
    """数据复制恢复策略"""
    print(f"Executing data replication strategy for {failed_node_id}")
    
    # 从其他副本恢复数据
    await asyncio.sleep(2.0)  # 模拟数据恢复过程
    print(f"Data replication completed for {failed_node_id}")

async def load_balancing_strategy(failed_node_id: str):
    """负载均衡恢复策略"""
    print(f"Executing load balancing strategy for {failed_node_id}")
    
    # 重新分配负载
    await asyncio.sleep(1.0)  # 模拟负载重分配
    print(f"Load balancing completed for {failed_node_id}")
```

## 4. 共识算法

### 4.1 Paxos算法

**定义 4.1.1 (Paxos)**
Paxos是一种分布式共识算法，确保在部分节点故障时仍能达成一致：

```python
from typing import Dict, List, Any, Optional
from dataclass import dataclass
import asyncio
import random

@dataclass
class Proposal:
    """提案"""
    id: int
    value: Any
    proposer_id: str

@dataclass
class Promise:
    """承诺"""
    accepted_id: int
    accepted_value: Any
    promised_id: int

class PaxosNode:
    """Paxos节点"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.peers: List['PaxosNode'] = []
        self.proposals: Dict[int, Proposal] = {}
        self.promises: Dict[int, List[Promise]] = {}
        self.accepted_values: Dict[int, Any] = {}
        self.current_proposal_id = 0
        self.quorum_size = 2  # 多数节点数量
    
    def add_peer(self, peer: 'PaxosNode'):
        """添加对等节点"""
        if peer not in self.peers:
            self.peers.append(peer)
            peer.peers.append(self)
    
    async def propose(self, value: Any) -> bool:
        """提出提案"""
        proposal_id = self._generate_proposal_id()
        
        # 阶段1：准备阶段
        promises = await self._prepare(proposal_id)
        
        if len(promises) < self.quorum_size:
            return False
        
        # 选择值
        chosen_value = self._choose_value(promises, value)
        
        # 阶段2：接受阶段
        accepts = await self._accept(proposal_id, chosen_value)
        
        return len(accepts) >= self.quorum_size
    
    async def _prepare(self, proposal_id: int) -> List[Promise]:
        """准备阶段"""
        promises = []
        
        for peer in self.peers:
            try:
                promise = await peer._handle_prepare(proposal_id)
                if promise:
                    promises.append(promise)
            except Exception as e:
                print(f"Prepare failed for peer {peer.node_id}: {e}")
        
        return promises
    
    async def _accept(self, proposal_id: int, value: Any) -> List[bool]:
        """接受阶段"""
        accepts = []
        
        for peer in self.peers:
            try:
                accepted = await peer._handle_accept(proposal_id, value)
                accepts.append(accepted)
            except Exception as e:
                print(f"Accept failed for peer {peer.node_id}: {e}")
        
        return accepts
    
    def _generate_proposal_id(self) -> int:
        """生成提案ID"""
        self.current_proposal_id += 1
        return self.current_proposal_id
    
    def _choose_value(self, promises: List[Promise], proposed_value: Any) -> Any:
        """选择值"""
        # 如果有已接受的值，选择最高ID的值
        highest_accepted_id = -1
        chosen_value = proposed_value
        
        for promise in promises:
            if promise.accepted_id > highest_accepted_id:
                highest_accepted_id = promise.accepted_id
                chosen_value = promise.accepted_value
        
        return chosen_value
    
    async def _handle_prepare(self, proposal_id: int) -> Optional[Promise]:
        """处理准备请求"""
        # 检查是否已经承诺了更高的ID
        if proposal_id in self.promises:
            existing_promises = self.promises[proposal_id]
            for promise in existing_promises:
                if promise.promised_id > proposal_id:
                    return None  # 拒绝
        
        # 创建承诺
        promise = Promise(
            accepted_id=self.accepted_values.get(proposal_id, -1),
            accepted_value=self.accepted_values.get(proposal_id),
            promised_id=proposal_id
        )
        
        # 记录承诺
        if proposal_id not in self.promises:
            self.promises[proposal_id] = []
        self.promises[proposal_id].append(promise)
        
        return promise
    
    async def _handle_accept(self, proposal_id: int, value: Any) -> bool:
        """处理接受请求"""
        # 检查是否已经承诺了更高的ID
        if proposal_id in self.promises:
            existing_promises = self.promises[proposal_id]
            for promise in existing_promises:
                if promise.promised_id > proposal_id:
                    return False  # 拒绝
        
        # 接受提案
        self.accepted_values[proposal_id] = value
        
        return True
    
    def get_consensus_value(self, proposal_id: int) -> Optional[Any]:
        """获取共识值"""
        return self.accepted_values.get(proposal_id)

# 使用示例
async def paxos_example():
    """Paxos算法示例"""
    # 创建节点
    node1 = PaxosNode("node1")
    node2 = PaxosNode("node2")
    node3 = PaxosNode("node3")
    
    # 建立连接
    node1.add_peer(node2)
    node1.add_peer(node3)
    
    # 提出提案
    success = await node1.propose("consensus_value_1")
    print(f"Proposal success: {success}")
    
    # 获取共识值
    value = node1.get_consensus_value(1)
    print(f"Consensus value: {value}")
```

### 4.2 Raft算法

**定义 4.2.1 (Raft)**
Raft是一种更易理解的共识算法，通过领导者选举和日志复制达成一致：

```python
from enum import Enum
from typing import Dict, List, Any, Optional
import asyncio
import random
import time

class NodeState(Enum):
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    LEADER = "leader"

@dataclass
class LogEntry:
    """日志条目"""
    term: int
    index: int
    command: Any

@dataclass
class RaftNode:
    """Raft节点"""
    node_id: str
    state: NodeState = NodeState.FOLLOWER
    current_term: int = 0
    voted_for: Optional[str] = None
    log: List[LogEntry] = []
    commit_index: int = 0
    last_applied: int = 0
    
    # 领导者状态
    next_index: Dict[str, int] = None
    match_index: Dict[str, int] = None
    
    # 选举超时
    election_timeout: float = 5.0
    last_heartbeat: float = 0.0

class RaftCluster:
    """Raft集群"""
    
    def __init__(self):
        self.nodes: Dict[str, RaftNode] = {}
        self.leader_id: Optional[str] = None
        self.quorum_size: int = 2
    
    def add_node(self, node_id: str) -> RaftNode:
        """添加节点"""
        node = RaftNode(node_id=node_id)
        self.nodes[node_id] = node
        return node
    
    async def start_election(self, node_id: str):
        """开始选举"""
        node = self.nodes[node_id]
        
        # 转换为候选人状态
        node.state = NodeState.CANDIDATE
        node.current_term += 1
        node.voted_for = node_id
        
        print(f"Node {node_id} starting election for term {node.current_term}")
        
        # 请求投票
        votes_received = 1  # 自己的一票
        
        for peer_id, peer in self.nodes.items():
            if peer_id != node_id:
                try:
                    vote_granted = await self._request_vote(node_id, peer_id)
                    if vote_granted:
                        votes_received += 1
                except Exception as e:
                    print(f"Request vote failed: {e}")
        
        # 检查是否获得多数票
        if votes_received >= self.quorum_size:
            await self._become_leader(node_id)
        else:
            # 选举失败，回到跟随者状态
            node.state = NodeState.FOLLOWER
    
    async def _request_vote(self, candidate_id: str, voter_id: str) -> bool:
        """请求投票"""
        candidate = self.nodes[candidate_id]
        voter = self.nodes[voter_id]
        
        # 检查任期
        if candidate.current_term <= voter.current_term:
            return False
        
        # 检查是否已经投票
        if voter.voted_for and voter.voted_for != candidate_id:
            return False
        
        # 授予投票
        voter.voted_for = candidate_id
        voter.current_term = candidate.current_term
        voter.state = NodeState.FOLLOWER
        
        print(f"Node {voter_id} voted for {candidate_id}")
        return True
    
    async def _become_leader(self, node_id: str):
        """成为领导者"""
        node = self.nodes[node_id]
        node.state = NodeState.LEADER
        self.leader_id = node_id
        
        # 初始化领导者状态
        node.next_index = {peer_id: len(node.log) + 1 for peer_id in self.nodes.keys()}
        node.match_index = {peer_id: 0 for peer_id in self.nodes.keys()}
        
        print(f"Node {node_id} became leader for term {node.current_term}")
        
        # 开始发送心跳
        asyncio.create_task(self._send_heartbeats(node_id))
    
    async def _send_heartbeats(self, leader_id: str):
        """发送心跳"""
        while self.leader_id == leader_id:
            await asyncio.sleep(1.0)  # 心跳间隔
            
            for peer_id, peer in self.nodes.items():
                if peer_id != leader_id:
                    try:
                        await self._append_entries(leader_id, peer_id, [])
                    except Exception as e:
                        print(f"Heartbeat failed: {e}")
    
    async def _append_entries(self, leader_id: str, follower_id: str, entries: List[LogEntry]) -> bool:
        """追加日志条目"""
        leader = self.nodes[leader_id]
        follower = self.nodes[follower_id]
        
        # 检查任期
        if leader.current_term < follower.current_term:
            return False
        
        # 更新跟随者状态
        follower.current_term = leader.current_term
        follower.state = NodeState.FOLLOWER
        follower.last_heartbeat = time.time()
        
        # 追加日志条目
        if entries:
            follower.log.extend(entries)
            print(f"Node {follower_id} appended {len(entries)} entries")
        
        return True
    
    async def submit_command(self, command: Any) -> bool:
        """提交命令"""
        if not self.leader_id:
            return False
        
        leader = self.nodes[self.leader_id]
        
        # 添加日志条目
        log_entry = LogEntry(
            term=leader.current_term,
            index=len(leader.log) + 1,
            command=command
        )
        
        leader.log.append(log_entry)
        
        # 复制到其他节点
        replicated_count = 1  # 领导者自己
        
        for peer_id, peer in self.nodes.items():
            if peer_id != self.leader_id:
                try:
                    success = await self._append_entries(self.leader_id, peer_id, [log_entry])
                    if success:
                        replicated_count += 1
                except Exception as e:
                    print(f"Replication failed: {e}")
        
        # 检查是否复制到多数节点
        if replicated_count >= self.quorum_size:
            # 提交日志
            leader.commit_index = log_entry.index
            print(f"Command committed: {command}")
            return True
        
        return False
    
    def get_cluster_status(self) -> Dict[str, Any]:
        """获取集群状态"""
        return {
            'leader_id': self.leader_id,
            'total_nodes': len(self.nodes),
            'node_states': {
                node_id: node.state.value for node_id, node in self.nodes.items()
            },
            'current_term': max(node.current_term for node in self.nodes.values())
        }

# 使用示例
async def raft_example():
    """Raft算法示例"""
    # 创建集群
    cluster = RaftCluster()
    
    # 添加节点
    node1 = cluster.add_node("node1")
    node2 = cluster.add_node("node2")
    node3 = cluster.add_node("node3")
    
    # 启动选举
    await cluster.start_election("node1")
    
    # 等待选举完成
    await asyncio.sleep(2.0)
    
    # 获取集群状态
    status = cluster.get_cluster_status()
    print(f"Cluster status: {status}")
    
    # 提交命令
    if cluster.leader_id:
        success = await cluster.submit_command("set key1 value1")
        print(f"Command submission: {success}")
```

## 5. 总结

分布式系统通过一致性模型、容错机制和共识算法，构建了高可用、高可靠的分布式应用。本文档提供了强一致性、最终一致性、故障检测、故障恢复、Paxos和Raft等核心技术的完整实现。

关键成功因素包括：

1. **一致性保证**：根据业务需求选择合适的一致性模型
2. **容错设计**：完善的故障检测和恢复机制
3. **共识算法**：选择合适的共识算法确保系统一致性
4. **性能优化**：平衡一致性和性能需求

---

*本文档提供了分布式系统的完整架构设计，包含数学形式化定义、Python代码实现和最佳实践指导。*
