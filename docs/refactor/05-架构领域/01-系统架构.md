# 系统架构设计

## 1. 概述

### 1.1 架构定义

**定义 1.1.1 (系统架构)**
系统架构是软件系统的组织结构，定义了组件、组件间关系以及设计原则：

$$\text{Architecture} = (C, R, P, Q)$$

其中：

- $C = \{c_1, c_2, ..., c_n\}$ 是组件集合
- $R = \{r_1, r_2, ..., r_m\}$ 是关系集合
- $P = \{p_1, p_2, ..., p_k\}$ 是原则集合
- $Q = \{q_1, q_2, ..., q_l\}$ 是质量属性集合

### 1.2 架构设计原则

**定理 1.1.1 (架构复杂度定理)**
系统架构的复杂度与组件数量、关系密度和质量要求呈多项式关系：

$$\text{Complexity}(A) = O(|C|^2 \times |R| \times |Q|)$$

*证明*：组件间关系数量为 $O(|C|^2)$，每个关系需要考虑质量属性，复杂度为三者乘积。

## 2. 架构设计方法

### 2.1 分层架构

**定义 2.1.1 (分层架构)**
分层架构将系统按功能划分为多个层次，每层只与相邻层交互：

```python
from typing import Dict, List, Any, Protocol
from abc import ABC, abstractmethod
from dataclasses import dataclass
import asyncio

class Layer(Protocol):
    """层次接口"""
    
    @abstractmethod
    async def process(self, data: Any) -> Any:
        """处理数据"""
        pass
    
    @abstractmethod
    def get_dependencies(self) -> List[str]:
        """获取依赖层次"""
        pass

@dataclass
class ArchitectureLayer:
    """架构层次"""
    name: str
    description: str
    dependencies: List[str]
    components: List[str]
    interfaces: Dict[str, Any]

class LayeredArchitecture:
    """分层架构"""
    
    def __init__(self):
        self.layers: Dict[str, ArchitectureLayer] = {}
        self.layer_order: List[str] = []
    
    def add_layer(self, name: str, description: str, 
                  dependencies: List[str] = None) -> ArchitectureLayer:
        """添加层次"""
        layer = ArchitectureLayer(
            name=name,
            description=description,
            dependencies=dependencies or [],
            components=[],
            interfaces={}
        )
        self.layers[name] = layer
        
        # 更新层次顺序
        self._update_layer_order()
        
        return layer
    
    def _update_layer_order(self):
        """更新层次顺序（拓扑排序）"""
        # 简化的拓扑排序实现
        visited = set()
        temp_visited = set()
        order = []
        
        def dfs(layer_name: str):
            if layer_name in temp_visited:
                raise ValueError("Circular dependency detected")
            if layer_name in visited:
                return
            
            temp_visited.add(layer_name)
            
            layer = self.layers[layer_name]
            for dep in layer.dependencies:
                dfs(dep)
            
            temp_visited.remove(layer_name)
            visited.add(layer_name)
            order.append(layer_name)
        
        for layer_name in self.layers:
            if layer_name not in visited:
                dfs(layer_name)
        
        self.layer_order = order[::-1]  # 反转得到正确的顺序
    
    def add_component(self, layer_name: str, component_name: str, 
                     interface: Dict[str, Any] = None):
        """向层次添加组件"""
        if layer_name not in self.layers:
            raise ValueError(f"Layer {layer_name} not found")
        
        layer = self.layers[layer_name]
        layer.components.append(component_name)
        
        if interface:
            layer.interfaces[component_name] = interface
    
    def validate_architecture(self) -> Dict[str, Any]:
        """验证架构"""
        validation_result = {
            'is_valid': True,
            'errors': [],
            'warnings': []
        }
        
        # 检查循环依赖
        try:
            self._update_layer_order()
        except ValueError as e:
            validation_result['is_valid'] = False
            validation_result['errors'].append(str(e))
        
        # 检查层次完整性
        for layer_name, layer in self.layers.items():
            if not layer.components:
                validation_result['warnings'].append(f"Layer {layer_name} has no components")
        
        return validation_result
    
    def get_architecture_diagram(self) -> Dict[str, Any]:
        """获取架构图"""
        return {
            'layers': [
                {
                    'name': layer_name,
                    'description': self.layers[layer_name].description,
                    'components': self.layers[layer_name].components,
                    'dependencies': self.layers[layer_name].dependencies
                }
                for layer_name in self.layer_order
            ],
            'layer_order': self.layer_order
        }

# 使用示例
def create_web_application_architecture():
    """创建Web应用分层架构"""
    architecture = LayeredArchitecture()
    
    # 添加层次
    architecture.add_layer("Presentation", "用户界面层")
    architecture.add_layer("Business", "业务逻辑层", ["Presentation"])
    architecture.add_layer("Data", "数据访问层", ["Business"])
    architecture.add_layer("Infrastructure", "基础设施层", ["Data"])
    
    # 添加组件
    architecture.add_component("Presentation", "WebController")
    architecture.add_component("Presentation", "APIController")
    architecture.add_component("Business", "UserService")
    architecture.add_component("Business", "OrderService")
    architecture.add_component("Data", "UserRepository")
    architecture.add_component("Data", "OrderRepository")
    architecture.add_component("Infrastructure", "Database")
    architecture.add_component("Infrastructure", "Cache")
    
    return architecture
```

### 2.2 模块化架构

**定义 2.2.1 (模块化架构)**
模块化架构将系统分解为独立的模块，每个模块具有明确的接口和职责：

```python
from typing import Dict, Set, Any, Optional
import asyncio

@dataclass
class Module:
    """模块定义"""
    name: str
    description: str
    interfaces: Dict[str, Any]
    dependencies: Set[str]
    cohesion_score: float  # 内聚度
    coupling_score: float  # 耦合度

class ModularArchitecture:
    """模块化架构"""
    
    def __init__(self):
        self.modules: Dict[str, Module] = {}
        self.module_interfaces: Dict[str, Dict[str, Any]] = {}
    
    def create_module(self, name: str, description: str, 
                     dependencies: Set[str] = None) -> Module:
        """创建模块"""
        module = Module(
            name=name,
            description=description,
            interfaces={},
            dependencies=dependencies or set(),
            cohesion_score=0.0,
            coupling_score=0.0
        )
        self.modules[name] = module
        return module
    
    def define_interface(self, module_name: str, interface_name: str, 
                        interface_spec: Dict[str, Any]):
        """定义模块接口"""
        if module_name not in self.modules:
            raise ValueError(f"Module {module_name} not found")
        
        module = self.modules[module_name]
        module.interfaces[interface_name] = interface_spec
    
    def calculate_cohesion(self, module_name: str) -> float:
        """计算模块内聚度"""
        if module_name not in self.modules:
            return 0.0
        
        module = self.modules[module_name]
        
        # 简化的内聚度计算
        # 基于接口数量和功能相关性
        interface_count = len(module.interfaces)
        if interface_count == 0:
            return 0.0
        
        # 假设接口越多，内聚度越高（功能越完整）
        cohesion = min(interface_count / 10.0, 1.0)
        module.cohesion_score = cohesion
        
        return cohesion
    
    def calculate_coupling(self, module_name: str) -> float:
        """计算模块耦合度"""
        if module_name not in self.modules:
            return 0.0
        
        module = self.modules[module_name]
        
        # 简化的耦合度计算
        # 基于依赖数量和依赖强度
        dependency_count = len(module.dependencies)
        coupling = min(dependency_count / 5.0, 1.0)
        module.coupling_score = coupling
        
        return coupling
    
    def analyze_architecture_quality(self) -> Dict[str, Any]:
        """分析架构质量"""
        total_cohesion = 0.0
        total_coupling = 0.0
        module_count = len(self.modules)
        
        for module_name in self.modules:
            cohesion = self.calculate_cohesion(module_name)
            coupling = self.calculate_coupling(module_name)
            total_cohesion += cohesion
            total_coupling += coupling
        
        avg_cohesion = total_cohesion / module_count if module_count > 0 else 0.0
        avg_coupling = total_coupling / module_count if module_count > 0 else 0.0
        
        # 质量指标：高内聚，低耦合
        quality_score = avg_cohesion * (1.0 - avg_coupling)
        
        return {
            'average_cohesion': avg_cohesion,
            'average_coupling': avg_coupling,
            'quality_score': quality_score,
            'module_count': module_count,
            'recommendations': self._generate_recommendations(avg_cohesion, avg_coupling)
        }
    
    def _generate_recommendations(self, cohesion: float, coupling: float) -> List[str]:
        """生成改进建议"""
        recommendations = []
        
        if cohesion < 0.5:
            recommendations.append("Consider increasing module cohesion by grouping related functionality")
        
        if coupling > 0.7:
            recommendations.append("Consider reducing module coupling by introducing interfaces or abstractions")
        
        if cohesion > 0.8 and coupling < 0.3:
            recommendations.append("Architecture quality is excellent")
        
        return recommendations

# 使用示例
def create_ecommerce_modular_architecture():
    """创建电商模块化架构"""
    architecture = ModularArchitecture()
    
    # 创建模块
    user_module = architecture.create_module("User", "用户管理模块")
    product_module = architecture.create_module("Product", "商品管理模块")
    order_module = architecture.create_module("Order", "订单管理模块", {"User", "Product"})
    payment_module = architecture.create_module("Payment", "支付模块", {"Order"})
    
    # 定义接口
    architecture.define_interface("User", "UserService", {
        "methods": ["create_user", "get_user", "update_user", "delete_user"],
        "data_types": {"User": "User entity"}
    })
    
    architecture.define_interface("Product", "ProductService", {
        "methods": ["create_product", "get_product", "update_product", "search_products"],
        "data_types": {"Product": "Product entity"}
    })
    
    architecture.define_interface("Order", "OrderService", {
        "methods": ["create_order", "get_order", "update_order_status"],
        "data_types": {"Order": "Order entity"}
    })
    
    return architecture
```

## 3. 架构模式

### 3.1 客户端-服务器架构

**定义 3.1.1 (C/S架构)**
客户端-服务器架构将系统分为客户端和服务器两部分：

```python
import asyncio
from typing import Dict, Any, Optional
import json

class Server:
    """服务器"""
    
    def __init__(self, host: str = "localhost", port: int = 8080):
        self.host = host
        self.port = port
        self.clients: Dict[str, Any] = {}
        self.services: Dict[str, callable] = {}
    
    def register_service(self, service_name: str, handler: callable):
        """注册服务"""
        self.services[service_name] = handler
    
    async def handle_client_request(self, client_id: str, request: Dict[str, Any]) -> Dict[str, Any]:
        """处理客户端请求"""
        service_name = request.get('service')
        data = request.get('data', {})
        
        if service_name not in self.services:
            return {
                'status': 'error',
                'message': f'Service {service_name} not found'
            }
        
        try:
            handler = self.services[service_name]
            if asyncio.iscoroutinefunction(handler):
                result = await handler(data)
            else:
                result = handler(data)
            
            return {
                'status': 'success',
                'data': result
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }
    
    async def start(self):
        """启动服务器"""
        print(f"Server starting on {self.host}:{self.port}")
        
        # 模拟服务器启动
        await asyncio.sleep(0.1)
        print("Server started successfully")

class Client:
    """客户端"""
    
    def __init__(self, client_id: str):
        self.client_id = client_id
        self.server_connection = None
    
    async def connect_to_server(self, server: Server):
        """连接到服务器"""
        self.server_connection = server
        server.clients[self.client_id] = self
        print(f"Client {self.client_id} connected to server")
    
    async def request_service(self, service_name: str, data: Dict[str, Any] = None) -> Dict[str, Any]:
        """请求服务"""
        if not self.server_connection:
            return {
                'status': 'error',
                'message': 'Not connected to server'
            }
        
        request = {
            'client_id': self.client_id,
            'service': service_name,
            'data': data or {}
        }
        
        return await self.server_connection.handle_client_request(self.client_id, request)
    
    async def disconnect(self):
        """断开连接"""
        if self.server_connection and self.client_id in self.server_connection.clients:
            del self.server_connection.clients[self.client_id]
            self.server_connection = None
            print(f"Client {self.client_id} disconnected")

# 使用示例
async def client_server_example():
    """客户端-服务器架构示例"""
    # 创建服务器
    server = Server()
    
    # 注册服务
    async def user_service(data: Dict[str, Any]) -> Dict[str, Any]:
        return {"user_id": "123", "name": data.get("name", "Unknown")}
    
    async def product_service(data: Dict[str, Any]) -> Dict[str, Any]:
        return {"product_id": "456", "name": data.get("name", "Unknown Product")}
    
    server.register_service("user", user_service)
    server.register_service("product", product_service)
    
    # 启动服务器
    await server.start()
    
    # 创建客户端
    client1 = Client("client_1")
    client2 = Client("client_2")
    
    # 连接客户端
    await client1.connect_to_server(server)
    await client2.connect_to_server(server)
    
    # 客户端请求服务
    user_result = await client1.request_service("user", {"name": "John"})
    product_result = await client2.request_service("product", {"name": "Laptop"})
    
    print(f"User result: {user_result}")
    print(f"Product result: {product_result}")
    
    # 断开连接
    await client1.disconnect()
    await client2.disconnect()
```

### 3.2 管道-过滤器架构

**定义 3.2.1 (管道-过滤器架构)**
管道-过滤器架构通过连接多个过滤器组件处理数据流：

```python
from typing import List, Any, Callable, Optional
from abc import ABC, abstractmethod

class Filter(ABC):
    """过滤器抽象类"""
    
    def __init__(self, name: str):
        self.name = name
        self.next_filter: Optional[Filter] = None
    
    @abstractmethod
    async def process(self, data: Any) -> Any:
        """处理数据"""
        pass
    
    def set_next(self, filter_obj: 'Filter') -> 'Filter':
        """设置下一个过滤器"""
        self.next_filter = filter_obj
        return filter_obj
    
    async def execute(self, data: Any) -> Any:
        """执行过滤器链"""
        result = await self.process(data)
        
        if self.next_filter:
            return await self.next_filter.execute(result)
        
        return result

class DataValidationFilter(Filter):
    """数据验证过滤器"""
    
    def __init__(self, validation_rules: Dict[str, Callable]):
        super().__init__("DataValidation")
        self.validation_rules = validation_rules
    
    async def process(self, data: Any) -> Any:
        """验证数据"""
        if isinstance(data, dict):
            for field, validator in self.validation_rules.items():
                if field in data:
                    if not validator(data[field]):
                        raise ValueError(f"Validation failed for field: {field}")
        
        return data

class DataTransformationFilter(Filter):
    """数据转换过滤器"""
    
    def __init__(self, transformation_rules: Dict[str, Callable]):
        super().__init__("DataTransformation")
        self.transformation_rules = transformation_rules
    
    async def process(self, data: Any) -> Any:
        """转换数据"""
        if isinstance(data, dict):
            transformed_data = data.copy()
            for field, transformer in self.transformation_rules.items():
                if field in transformed_data:
                    transformed_data[field] = transformer(transformed_data[field])
            return transformed_data
        
        return data

class DataEnrichmentFilter(Filter):
    """数据丰富过滤器"""
    
    def __init__(self, enrichment_rules: Dict[str, Callable]):
        super().__init__("DataEnrichment")
        self.enrichment_rules = enrichment_rules
    
    async def process(self, data: Any) -> Any:
        """丰富数据"""
        if isinstance(data, dict):
            enriched_data = data.copy()
            for field, enricher in self.enrichment_rules.items():
                enriched_data[field] = enricher(enriched_data)
            return enriched_data
        
        return data

class Pipeline:
    """管道"""
    
    def __init__(self, name: str):
        self.name = name
        self.filters: List[Filter] = []
        self.first_filter: Optional[Filter] = None
    
    def add_filter(self, filter_obj: Filter) -> 'Pipeline':
        """添加过滤器"""
        self.filters.append(filter_obj)
        
        if not self.first_filter:
            self.first_filter = filter_obj
        else:
            # 链接过滤器
            current = self.first_filter
            while current.next_filter:
                current = current.next_filter
            current.set_next(filter_obj)
        
        return self
    
    async def execute(self, data: Any) -> Any:
        """执行管道"""
        if not self.first_filter:
            return data
        
        return await self.first_filter.execute(data)
    
    def get_pipeline_info(self) -> Dict[str, Any]:
        """获取管道信息"""
        return {
            'name': self.name,
            'filter_count': len(self.filters),
            'filters': [filter_obj.name for filter_obj in self.filters]
        }

# 使用示例
async def pipeline_example():
    """管道-过滤器架构示例"""
    # 定义验证规则
    validation_rules = {
        'age': lambda x: isinstance(x, int) and 0 <= x <= 150,
        'email': lambda x: isinstance(x, str) and '@' in x
    }
    
    # 定义转换规则
    transformation_rules = {
        'name': lambda x: x.title() if isinstance(x, str) else x,
        'email': lambda x: x.lower() if isinstance(x, str) else x
    }
    
    # 定义丰富规则
    enrichment_rules = {
        'user_id': lambda data: f"user_{hash(data.get('email', '')) % 10000}",
        'created_at': lambda data: "2024-01-01"  # 简化实现
    }
    
    # 创建过滤器
    validation_filter = DataValidationFilter(validation_rules)
    transformation_filter = DataTransformationFilter(transformation_rules)
    enrichment_filter = DataEnrichmentFilter(enrichment_rules)
    
    # 创建管道
    pipeline = Pipeline("UserDataPipeline")
    pipeline.add_filter(validation_filter)
    pipeline.add_filter(transformation_filter)
    pipeline.add_filter(enrichment_filter)
    
    # 测试数据
    test_data = {
        'name': 'john doe',
        'age': 25,
        'email': 'JOHN@EXAMPLE.COM'
    }
    
    # 执行管道
    try:
        result = await pipeline.execute(test_data)
        print(f"Pipeline result: {result}")
    except ValueError as e:
        print(f"Pipeline error: {e}")
    
    # 获取管道信息
    info = pipeline.get_pipeline_info()
    print(f"Pipeline info: {info}")
```

## 4. 架构评估

### 4.1 质量属性评估

**定义 4.1.1 (质量属性模型)**
架构质量属性包括性能、可用性、安全性、可维护性等：

```python
from typing import Dict, List, Any
from dataclasses import dataclass
import math

@dataclass
class QualityAttribute:
    """质量属性"""
    name: str
    description: str
    weight: float  # 权重 0.0-1.0
    score: float   # 得分 0.0-1.0
    metrics: Dict[str, float]

class ArchitectureEvaluator:
    """架构评估器"""
    
    def __init__(self):
        self.quality_attributes: Dict[str, QualityAttribute] = {}
        self.evaluation_criteria: Dict[str, List[str]] = {}
    
    def add_quality_attribute(self, name: str, description: str, weight: float) -> QualityAttribute:
        """添加质量属性"""
        attribute = QualityAttribute(
            name=name,
            description=description,
            weight=weight,
            score=0.0,
            metrics={}
        )
        self.quality_attributes[name] = attribute
        return attribute
    
    def evaluate_performance(self, architecture: Any) -> float:
        """评估性能"""
        # 简化的性能评估
        # 基于组件数量、层次深度等
        component_count = getattr(architecture, 'component_count', 10)
        layer_count = getattr(architecture, 'layer_count', 3)
        
        # 性能得分：组件越少，层次越浅，性能越好
        performance_score = 1.0 / (1.0 + component_count * 0.1 + layer_count * 0.2)
        
        if 'performance' in self.quality_attributes:
            self.quality_attributes['performance'].score = performance_score
            self.quality_attributes['performance'].metrics = {
                'component_count': component_count,
                'layer_count': layer_count,
                'response_time': 100 + component_count * 10
            }
        
        return performance_score
    
    def evaluate_maintainability(self, architecture: Any) -> float:
        """评估可维护性"""
        # 简化的可维护性评估
        # 基于模块化程度、耦合度等
        modularity_score = getattr(architecture, 'modularity_score', 0.5)
        coupling_score = getattr(architecture, 'coupling_score', 0.5)
        
        # 可维护性得分：模块化程度高，耦合度低
        maintainability_score = modularity_score * (1.0 - coupling_score)
        
        if 'maintainability' in self.quality_attributes:
            self.quality_attributes['maintainability'].score = maintainability_score
            self.quality_attributes['maintainability'].metrics = {
                'modularity_score': modularity_score,
                'coupling_score': coupling_score,
                'complexity': 1.0 - maintainability_score
            }
        
        return maintainability_score
    
    def evaluate_scalability(self, architecture: Any) -> float:
        """评估可扩展性"""
        # 简化的可扩展性评估
        # 基于水平扩展能力、组件独立性等
        horizontal_scaling = getattr(architecture, 'horizontal_scaling', True)
        component_independence = getattr(architecture, 'component_independence', 0.5)
        
        scalability_score = 0.0
        if horizontal_scaling:
            scalability_score += 0.5
        scalability_score += component_independence * 0.5
        
        if 'scalability' in self.quality_attributes:
            self.quality_attributes['scalability'].score = scalability_score
            self.quality_attributes['scalability'].metrics = {
                'horizontal_scaling': horizontal_scaling,
                'component_independence': component_independence,
                'max_instances': 10 if horizontal_scaling else 1
            }
        
        return scalability_score
    
    def evaluate_security(self, architecture: Any) -> float:
        """评估安全性"""
        # 简化的安全性评估
        # 基于认证、授权、加密等
        has_authentication = getattr(architecture, 'has_authentication', True)
        has_authorization = getattr(architecture, 'has_authorization', True)
        has_encryption = getattr(architecture, 'has_encryption', True)
        
        security_score = 0.0
        if has_authentication:
            security_score += 0.33
        if has_authorization:
            security_score += 0.33
        if has_encryption:
            security_score += 0.34
        
        if 'security' in self.quality_attributes:
            self.quality_attributes['security'].score = security_score
            self.quality_attributes['security'].metrics = {
                'authentication': has_authentication,
                'authorization': has_authorization,
                'encryption': has_encryption,
                'security_layers': sum([has_authentication, has_authorization, has_encryption])
            }
        
        return security_score
    
    def evaluate_architecture(self, architecture: Any) -> Dict[str, Any]:
        """评估架构"""
        # 执行各项评估
        self.evaluate_performance(architecture)
        self.evaluate_maintainability(architecture)
        self.evaluate_scalability(architecture)
        self.evaluate_security(architecture)
        
        # 计算综合得分
        total_score = 0.0
        total_weight = 0.0
        
        for attribute in self.quality_attributes.values():
            total_score += attribute.score * attribute.weight
            total_weight += attribute.weight
        
        overall_score = total_score / total_weight if total_weight > 0 else 0.0
        
        # 生成评估报告
        report = {
            'overall_score': overall_score,
            'quality_attributes': {},
            'recommendations': self._generate_recommendations(),
            'risk_assessment': self._assess_risks()
        }
        
        for name, attribute in self.quality_attributes.items():
            report['quality_attributes'][name] = {
                'score': attribute.score,
                'weight': attribute.weight,
                'description': attribute.description,
                'metrics': attribute.metrics
            }
        
        return report
    
    def _generate_recommendations(self) -> List[str]:
        """生成改进建议"""
        recommendations = []
        
        for name, attribute in self.quality_attributes.items():
            if attribute.score < 0.5:
                recommendations.append(f"Improve {name}: {attribute.description}")
        
        return recommendations
    
    def _assess_risks(self) -> Dict[str, str]:
        """评估风险"""
        risks = {}
        
        for name, attribute in self.quality_attributes.items():
            if attribute.score < 0.3:
                risks[name] = "High"
            elif attribute.score < 0.6:
                risks[name] = "Medium"
            else:
                risks[name] = "Low"
        
        return risks

# 使用示例
def evaluate_sample_architecture():
    """评估示例架构"""
    evaluator = ArchitectureEvaluator()
    
    # 添加质量属性
    evaluator.add_quality_attribute("performance", "系统性能", 0.3)
    evaluator.add_quality_attribute("maintainability", "可维护性", 0.25)
    evaluator.add_quality_attribute("scalability", "可扩展性", 0.25)
    evaluator.add_quality_attribute("security", "安全性", 0.2)
    
    # 创建示例架构对象
    class SampleArchitecture:
        def __init__(self):
            self.component_count = 15
            self.layer_count = 4
            self.modularity_score = 0.7
            self.coupling_score = 0.4
            self.horizontal_scaling = True
            self.component_independence = 0.6
            self.has_authentication = True
            self.has_authorization = True
            self.has_encryption = False
    
    architecture = SampleArchitecture()
    
    # 评估架构
    report = evaluator.evaluate_architecture(architecture)
    
    print("Architecture Evaluation Report:")
    print(f"Overall Score: {report['overall_score']:.2f}")
    print("\nQuality Attributes:")
    for name, attr in report['quality_attributes'].items():
        print(f"  {name}: {attr['score']:.2f} (weight: {attr['weight']})")
    
    print("\nRecommendations:")
    for rec in report['recommendations']:
        print(f"  - {rec}")
    
    print("\nRisk Assessment:")
    for attr, risk in report['risk_assessment'].items():
        print(f"  {attr}: {risk}")
    
    return report
```

## 5. 总结

系统架构设计是软件工程的核心，通过合理的架构设计可以确保系统的质量属性满足需求。本文档提供了分层架构、模块化架构、客户端-服务器架构、管道-过滤器架构等常见架构模式，以及相应的评估方法。

关键成功因素包括：

1. **架构原则**：遵循单一职责、开闭原则等设计原则
2. **质量属性**：平衡性能、可维护性、可扩展性、安全性等质量属性
3. **评估方法**：建立科学的架构评估体系
4. **持续改进**：根据评估结果持续优化架构设计

---

*本文档提供了系统架构设计的完整方法论，包含数学形式化定义、Python代码实现和评估框架。*
