# 系统架构设计

## 概述

系统架构是软件系统的最高层次设计，定义了系统的整体结构、组件关系、质量属性和约束条件。本文档从形式化理论到具体实现，全面阐述系统架构的设计原理和方法。

## 1. 系统架构理论基础

### 1.1 系统架构定义

**定义 1.1.1 (系统架构)**
系统架构 $A$ 是一个五元组 $(C, R, Q, S, E)$，其中：
- $C = \{c_1, c_2, ..., c_n\}$ 是组件集合
- $R = \{r_1, r_2, ..., r_m\}$ 是关系集合
- $Q = \{q_1, q_2, ..., q_k\}$ 是质量属性集合
- $S = \{s_1, s_2, ..., s_p\}$ 是约束集合
- $E = \{e_1, e_2, ..., e_q\}$ 是环境集合

**定义 1.1.2 (架构视图)**
架构视图 $V_i$ 是系统架构 $A$ 在特定关注点 $i$ 上的投影：
$$V_i = \pi_i(A) = (C_i, R_i, Q_i, S_i, E_i)$$

其中 $\pi_i$ 是投影函数，$C_i \subseteq C$，$R_i \subseteq R$，$Q_i \subseteq Q$，$S_i \subseteq S$，$E_i \subseteq E$。

### 1.2 架构质量属性

**定义 1.2.1 (质量属性)**
质量属性 $q$ 是一个函数 $q: A \rightarrow \mathbb{R}$，将架构 $A$ 映射到实数值，表示该属性在架构中的表现程度。

常见的质量属性包括：

1. **性能 (Performance)**
   $$P(A) = \frac{1}{\sum_{i=1}^{n} t_i}$$
   其中 $t_i$ 是第 $i$ 个操作的响应时间。

2. **可用性 (Availability)**
   $$A(A) = \frac{MTTF}{MTTF + MTTR}$$
   其中 MTTF 是平均无故障时间，MTTR 是平均修复时间。

3. **可扩展性 (Scalability)**
   $$S(A) = \frac{\Delta Throughput}{\Delta Resources}$$

4. **安全性 (Security)**
   $$Sec(A) = \sum_{i=1}^{m} w_i \cdot s_i$$
   其中 $w_i$ 是安全维度的权重，$s_i$ 是安全评分。

### 1.3 架构模式理论

**定义 1.3.1 (架构模式)**
架构模式 $P$ 是一个可重用的架构模板，定义为：
$$P = (I, C, S, F)$$
其中：
- $I$ 是意图 (Intent)
- $C$ 是上下文 (Context)
- $S$ 是解决方案 (Solution)
- $F$ 是力 (Forces)

**定理 1.3.1 (模式组合定理)**
如果模式 $P_1$ 和 $P_2$ 兼容，则它们的组合 $P_1 \oplus P_2$ 也是一个有效的架构模式。

*证明*：设 $P_1 = (I_1, C_1, S_1, F_1)$，$P_2 = (I_2, C_2, S_2, F_2)$
如果 $C_1 \cap C_2 = \emptyset$ 且 $F_1 \cap F_2 = \emptyset$，则：
$$P_1 \oplus P_2 = (I_1 \cup I_2, C_1 \cup C_2, S_1 \cup S_2, F_1 \cup F_2)$$
满足架构模式的定义。

## 2. 系统架构设计方法

### 2.1 分层架构设计

**定义 2.1.1 (分层架构)**
分层架构 $L$ 是一个特殊的系统架构，其中组件按层次组织：
$$L = (L_1, L_2, ..., L_n, D)$$
其中 $L_i$ 是第 $i$ 层，$D$ 是层间依赖关系。

**Python实现**：

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import asyncio
from datetime import datetime

class LayerType(Enum):
    """层类型枚举"""
    PRESENTATION = "presentation"
    BUSINESS = "business"
    DATA = "data"
    INFRASTRUCTURE = "infrastructure"

@dataclass
class Layer:
    """层定义"""
    name: str
    layer_type: LayerType
    components: List[str]
    responsibilities: List[str]
    dependencies: List[str]
    
    def __post_init__(self):
        self.created_at = datetime.now()
        self.updated_at = datetime.now()

class LayeredArchitecture:
    """分层架构实现"""
    
    def __init__(self, name: str):
        self.name = name
        self.layers: Dict[str, Layer] = {}
        self.dependency_matrix: Dict[str, List[str]] = {}
        
    def add_layer(self, layer: Layer) -> None:
        """添加层"""
        self.layers[layer.name] = layer
        self.dependency_matrix[layer.name] = layer.dependencies
        
    def validate_dependencies(self) -> bool:
        """验证依赖关系"""
        for layer_name, dependencies in self.dependency_matrix.items():
            for dep in dependencies:
                if dep not in self.layers:
                    return False
        return True
    
    def get_layer_dependencies(self, layer_name: str) -> List[str]:
        """获取层的依赖"""
        return self.dependency_matrix.get(layer_name, [])
    
    def calculate_coupling(self) -> float:
        """计算耦合度"""
        total_dependencies = sum(len(deps) for deps in self.dependency_matrix.values())
        total_possible = len(self.layers) * (len(self.layers) - 1)
        return total_dependencies / total_possible if total_possible > 0 else 0
    
    def calculate_cohesion(self) -> float:
        """计算内聚度"""
        # 简化的内聚度计算
        total_components = sum(len(layer.components) for layer in self.layers.values())
        return total_components / len(self.layers) if self.layers else 0

# 使用示例
def create_three_tier_architecture() -> LayeredArchitecture:
    """创建三层架构"""
    architecture = LayeredArchitecture("Three-Tier Architecture")
    
    # 表示层
    presentation_layer = Layer(
        name="Presentation",
        layer_type=LayerType.PRESENTATION,
        components=["Web UI", "Mobile UI", "API Gateway"],
        responsibilities=["用户界面", "请求路由", "输入验证"],
        dependencies=[]
    )
    
    # 业务层
    business_layer = Layer(
        name="Business",
        layer_type=LayerType.BUSINESS,
        components=["User Service", "Order Service", "Payment Service"],
        responsibilities=["业务逻辑", "事务处理", "规则引擎"],
        dependencies=["Presentation"]
    )
    
    # 数据层
    data_layer = Layer(
        name="Data",
        layer_type=LayerType.DATA,
        components=["User Repository", "Order Repository", "Payment Repository"],
        responsibilities=["数据持久化", "数据访问", "缓存管理"],
        dependencies=["Business"]
    )
    
    architecture.add_layer(presentation_layer)
    architecture.add_layer(business_layer)
    architecture.add_layer(data_layer)
    
    return architecture
```

### 2.2 微服务架构设计

**定义 2.2.1 (微服务)**
微服务 $M$ 是一个独立的、可部署的服务单元：
$$M = (I, D, P, C)$$
其中：
- $I$ 是接口 (Interface)
- $D$ 是数据 (Data)
- $P$ 是处理逻辑 (Processing)
- $C$ 是配置 (Configuration)

**定义 2.2.2 (微服务架构)**
微服务架构 $MS$ 是微服务的集合：
$$MS = \{M_1, M_2, ..., M_n, N\}$$
其中 $N$ 是网络拓扑。

**Python实现**：

```python
from typing import Protocol, Dict, List, Any
import asyncio
import json
from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class ServiceInterface:
    """服务接口定义"""
    name: str
    version: str
    endpoints: List[str]
    methods: List[str]
    schema: Dict[str, Any]

@dataclass
class ServiceData:
    """服务数据定义"""
    database: str
    tables: List[str]
    cache: Optional[str] = None
    message_queue: Optional[str] = None

@dataclass
class MicroService:
    """微服务定义"""
    name: str
    version: str
    interface: ServiceInterface
    data: ServiceData
    dependencies: List[str]
    health_check_url: str
    metrics_url: str
    created_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            "name": self.name,
            "version": self.version,
            "interface": {
                "name": self.interface.name,
                "version": self.interface.version,
                "endpoints": self.interface.endpoints,
                "methods": self.interface.methods,
                "schema": self.interface.schema
            },
            "data": {
                "database": self.data.database,
                "tables": self.data.tables,
                "cache": self.data.cache,
                "message_queue": self.data.message_queue
            },
            "dependencies": self.dependencies,
            "health_check_url": self.health_check_url,
            "metrics_url": self.metrics_url,
            "created_at": self.created_at.isoformat()
        }

class MicroServiceArchitecture:
    """微服务架构实现"""
    
    def __init__(self, name: str):
        self.name = name
        self.services: Dict[str, MicroService] = {}
        self.network_topology: Dict[str, List[str]] = {}
        
    def add_service(self, service: MicroService) -> None:
        """添加微服务"""
        self.services[service.name] = service
        self.network_topology[service.name] = service.dependencies
        
    def get_service_dependencies(self, service_name: str) -> List[str]:
        """获取服务依赖"""
        return self.network_topology.get(service_name, [])
    
    def calculate_service_mesh_complexity(self) -> float:
        """计算服务网格复杂度"""
        total_connections = sum(len(deps) for deps in self.network_topology.values())
        total_possible = len(self.services) * (len(self.services) - 1)
        return total_connections / total_possible if total_possible > 0 else 0
    
    def detect_circular_dependencies(self) -> List[List[str]]:
        """检测循环依赖"""
        def dfs(service: str, visited: set, path: List[str]) -> List[List[str]]:
            if service in path:
                return [path[path.index(service):]]
            
            if service in visited:
                return []
            
            visited.add(service)
            path.append(service)
            
            cycles = []
            for dep in self.get_service_dependencies(service):
                cycles.extend(dfs(dep, visited, path.copy()))
            
            return cycles
        
        all_cycles = []
        visited = set()
        
        for service in self.services:
            if service not in visited:
                cycles = dfs(service, visited, [])
                all_cycles.extend(cycles)
        
        return all_cycles
    
    def generate_service_mesh_config(self) -> Dict[str, Any]:
        """生成服务网格配置"""
        return {
            "services": [service.to_dict() for service in self.services.values()],
            "network_topology": self.network_topology,
            "complexity": self.calculate_service_mesh_complexity(),
            "circular_dependencies": self.detect_circular_dependencies()
        }

# 使用示例
def create_ecommerce_microservices() -> MicroServiceArchitecture:
    """创建电商微服务架构"""
    architecture = MicroServiceArchitecture("E-commerce Microservices")
    
    # 用户服务
    user_service = MicroService(
        name="user-service",
        version="1.0.0",
        interface=ServiceInterface(
            name="User API",
            version="v1",
            endpoints=["/users", "/users/{id}", "/users/{id}/profile"],
            methods=["GET", "POST", "PUT", "DELETE"],
            schema={"User": {"id": "string", "name": "string", "email": "string"}}
        ),
        data=ServiceData(
            database="user_db",
            tables=["users", "profiles", "preferences"],
            cache="redis",
            message_queue="rabbitmq"
        ),
        dependencies=[],
        health_check_url="/health",
        metrics_url="/metrics"
    )
    
    # 订单服务
    order_service = MicroService(
        name="order-service",
        version="1.0.0",
        interface=ServiceInterface(
            name="Order API",
            version="v1",
            endpoints=["/orders", "/orders/{id}", "/orders/{id}/status"],
            methods=["GET", "POST", "PUT"],
            schema={"Order": {"id": "string", "userId": "string", "items": "array"}}
        ),
        data=ServiceData(
            database="order_db",
            tables=["orders", "order_items", "order_status"],
            cache="redis",
            message_queue="rabbitmq"
        ),
        dependencies=["user-service"],
        health_check_url="/health",
        metrics_url="/metrics"
    )
    
    # 支付服务
    payment_service = MicroService(
        name="payment-service",
        version="1.0.0",
        interface=ServiceInterface(
            name="Payment API",
            version="v1",
            endpoints=["/payments", "/payments/{id}", "/payments/{id}/status"],
            methods=["GET", "POST", "PUT"],
            schema={"Payment": {"id": "string", "orderId": "string", "amount": "number"}}
        ),
        data=ServiceData(
            database="payment_db",
            tables=["payments", "transactions", "refunds"],
            cache="redis",
            message_queue="rabbitmq"
        ),
        dependencies=["order-service"],
        health_check_url="/health",
        metrics_url="/metrics"
    )
    
    architecture.add_service(user_service)
    architecture.add_service(order_service)
    architecture.add_service(payment_service)
    
    return architecture
```

### 2.3 事件驱动架构设计

**定义 2.3.1 (事件)**
事件 $e$ 是一个不可变的数据记录：
$$e = (id, type, data, timestamp, source)$$

**定义 2.3.2 (事件流)**
事件流 $S$ 是事件的序列：
$$S = [e_1, e_2, ..., e_n]$$

**定义 2.3.3 (事件驱动架构)**
事件驱动架构 $EDA$ 是基于事件的生产、传播、检测和消费的系统：
$$EDA = (P, C, B, R)$$
其中：
- $P$ 是生产者集合
- $C$ 是消费者集合
- $B$ 是事件总线
- $R$ 是路由规则

**Python实现**：

```python
from typing import Dict, List, Any, Callable, Optional
import asyncio
import uuid
from datetime import datetime
from dataclasses import dataclass, field
from enum import Enum
import json

class EventType(Enum):
    """事件类型枚举"""
    USER_CREATED = "user.created"
    USER_UPDATED = "user.updated"
    ORDER_CREATED = "order.created"
    ORDER_PAID = "order.paid"
    PAYMENT_PROCESSED = "payment.processed"

@dataclass
class Event:
    """事件定义"""
    id: str
    type: EventType
    data: Dict[str, Any]
    timestamp: datetime
    source: str
    version: str = "1.0"
    correlation_id: Optional[str] = None
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            "id": self.id,
            "type": self.type.value,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "source": self.source,
            "version": self.version,
            "correlation_id": self.correlation_id
        }

class EventProducer:
    """事件生产者"""
    
    def __init__(self, name: str):
        self.name = name
        self.event_bus: Optional['EventBus'] = None
        
    def set_event_bus(self, event_bus: 'EventBus') -> None:
        """设置事件总线"""
        self.event_bus = event_bus
        
    async def publish_event(self, event: Event) -> None:
        """发布事件"""
        if self.event_bus:
            await self.event_bus.publish(event)
        else:
            raise RuntimeError("Event bus not set")

class EventConsumer:
    """事件消费者"""
    
    def __init__(self, name: str, event_types: List[EventType]):
        self.name = name
        self.event_types = event_types
        self.handlers: Dict[EventType, List[Callable]] = {}
        
    def register_handler(self, event_type: EventType, handler: Callable) -> None:
        """注册事件处理器"""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        self.handlers[event_type].append(handler)
        
    async def handle_event(self, event: Event) -> None:
        """处理事件"""
        if event.type in self.handlers:
            for handler in self.handlers[event.type]:
                try:
                    await handler(event)
                except Exception as e:
                    print(f"Error handling event {event.id}: {e}")

class EventBus:
    """事件总线"""
    
    def __init__(self):
        self.producers: Dict[str, EventProducer] = {}
        self.consumers: Dict[str, EventConsumer] = {}
        self.event_queue: asyncio.Queue = asyncio.Queue()
        self.running = False
        
    def register_producer(self, producer: EventProducer) -> None:
        """注册生产者"""
        self.producers[producer.name] = producer
        producer.set_event_bus(self)
        
    def register_consumer(self, consumer: EventConsumer) -> None:
        """注册消费者"""
        self.consumers[consumer.name] = consumer
        self.event_bus.register_consumer(consumer)
        
    async def publish(self, event: Event) -> None:
        """发布事件"""
        await self.event_queue.put(event)
        
    async def start(self) -> None:
        """启动事件总线"""
        self.running = True
        asyncio.create_task(self._process_events())
        
    async def stop(self) -> None:
        """停止事件总线"""
        self.running = False
        
    async def _process_events(self) -> None:
        """处理事件"""
        while self.running:
            try:
                event = await asyncio.wait_for(self.event_queue.get(), timeout=1.0)
                await self._route_event(event)
            except asyncio.TimeoutError:
                continue
                
    async def _route_event(self, event: Event) -> None:
        """路由事件"""
        for consumer in self.consumers.values():
            if event.type in consumer.event_types:
                await consumer.handle_event(event)

class EventDrivenArchitecture:
    """事件驱动架构实现"""
    
    def __init__(self, name: str):
        self.name = name
        self.event_bus = EventBus()
        self.producers: Dict[str, EventProducer] = {}
        self.consumers: Dict[str, EventConsumer] = {}
        
    def add_producer(self, producer: EventProducer) -> None:
        """添加生产者"""
        self.producers[producer.name] = producer
        self.event_bus.register_producer(producer)
        
    def add_consumer(self, consumer: EventConsumer) -> None:
        """添加消费者"""
        self.consumers[consumer.name] = consumer
        self.event_bus.register_consumer(consumer)
        
    async def start(self) -> None:
        """启动架构"""
        await self.event_bus.start()
        
    async def stop(self) -> None:
        """停止架构"""
        await self.event_bus.stop()
        
    def get_event_flow_graph(self) -> Dict[str, List[str]]:
        """获取事件流图"""
        flow_graph = {}
        for producer in self.producers.values():
            flow_graph[producer.name] = []
            for consumer in self.consumers.values():
                # 简化的流图生成
                if producer.name in consumer.name or consumer.name in producer.name:
                    flow_graph[producer.name].append(consumer.name)
        return flow_graph

# 使用示例
async def create_event_driven_ecommerce() -> EventDrivenArchitecture:
    """创建事件驱动的电商架构"""
    architecture = EventDrivenArchitecture("Event-Driven E-commerce")
    
    # 创建生产者
    user_service = EventProducer("user-service")
    order_service = EventProducer("order-service")
    payment_service = EventProducer("payment-service")
    
    # 创建消费者
    notification_service = EventConsumer("notification-service", [
        EventType.USER_CREATED,
        EventType.ORDER_CREATED,
        EventType.ORDER_PAID
    ])
    
    analytics_service = EventConsumer("analytics-service", [
        EventType.USER_CREATED,
        EventType.ORDER_CREATED,
        EventType.PAYMENT_PROCESSED
    ])
    
    # 注册事件处理器
    async def send_welcome_email(event: Event):
        print(f"Sending welcome email for user: {event.data.get('user_id')}")
        
    async def send_order_confirmation(event: Event):
        print(f"Sending order confirmation for order: {event.data.get('order_id')}")
        
    async def track_user_activity(event: Event):
        print(f"Tracking user activity: {event.type.value}")
        
    notification_service.register_handler(EventType.USER_CREATED, send_welcome_email)
    notification_service.register_handler(EventType.ORDER_CREATED, send_order_confirmation)
    analytics_service.register_handler(EventType.USER_CREATED, track_user_activity)
    
    # 添加到架构
    architecture.add_producer(user_service)
    architecture.add_producer(order_service)
    architecture.add_producer(payment_service)
    architecture.add_consumer(notification_service)
    architecture.add_consumer(analytics_service)
    
    return architecture
```

## 3. 架构评估与优化

### 3.1 架构质量评估

**定义 3.1.1 (架构评估函数)**
架构评估函数 $E$ 将架构 $A$ 映射到质量评分：
$$E(A) = \sum_{i=1}^{n} w_i \cdot q_i(A)$$
其中 $w_i$ 是质量属性 $q_i$ 的权重。

**Python实现**：

```python
from typing import Dict, List, Tuple
import numpy as np
from dataclasses import dataclass

@dataclass
class QualityAttribute:
    """质量属性定义"""
    name: str
    weight: float
    min_value: float
    max_value: float
    target_value: float
    
    def normalize_score(self, score: float) -> float:
        """标准化评分"""
        return (score - self.min_value) / (self.max_value - self.min_value)

class ArchitectureEvaluator:
    """架构评估器"""
    
    def __init__(self):
        self.quality_attributes: Dict[str, QualityAttribute] = {}
        
    def add_quality_attribute(self, attribute: QualityAttribute) -> None:
        """添加质量属性"""
        self.quality_attributes[attribute.name] = attribute
        
    def evaluate_architecture(self, architecture: Any) -> Dict[str, float]:
        """评估架构"""
        scores = {}
        
        for name, attribute in self.quality_attributes.items():
            if hasattr(architecture, f'calculate_{name.lower()}'):
                method = getattr(architecture, f'calculate_{name.lower()}')
                raw_score = method()
                normalized_score = attribute.normalize_score(raw_score)
                scores[name] = normalized_score
            else:
                scores[name] = 0.0
                
        return scores
    
    def calculate_overall_score(self, scores: Dict[str, float]) -> float:
        """计算总体评分"""
        total_score = 0.0
        total_weight = 0.0
        
        for name, score in scores.items():
            if name in self.quality_attributes:
                weight = self.quality_attributes[name].weight
                total_score += weight * score
                total_weight += weight
                
        return total_score / total_weight if total_weight > 0 else 0.0

# 使用示例
def setup_architecture_evaluator() -> ArchitectureEvaluator:
    """设置架构评估器"""
    evaluator = ArchitectureEvaluator()
    
    # 添加质量属性
    evaluator.add_quality_attribute(QualityAttribute(
        name="Performance",
        weight=0.3,
        min_value=0.0,
        max_value=1.0,
        target_value=0.8
    ))
    
    evaluator.add_quality_attribute(QualityAttribute(
        name="Scalability",
        weight=0.25,
        min_value=0.0,
        max_value=1.0,
        target_value=0.9
    ))
    
    evaluator.add_quality_attribute(QualityAttribute(
        name="Maintainability",
        weight=0.2,
        min_value=0.0,
        max_value=1.0,
        target_value=0.7
    ))
    
    evaluator.add_quality_attribute(QualityAttribute(
        name="Security",
        weight=0.15,
        min_value=0.0,
        max_value=1.0,
        target_value=0.9
    ))
    
    evaluator.add_quality_attribute(QualityAttribute(
        name="Reliability",
        weight=0.1,
        min_value=0.0,
        max_value=1.0,
        target_value=0.95
    ))
    
    return evaluator
```

### 3.2 架构优化策略

**定义 3.2.1 (架构优化问题)**
架构优化问题是一个多目标优化问题：
$$\min_{A \in \mathcal{A}} [f_1(A), f_2(A), ..., f_m(A)]$$
其中 $f_i$ 是第 $i$ 个目标函数，$\mathcal{A}$ 是可行架构集合。

**Python实现**：

```python
from typing import List, Tuple, Callable
import random
import copy

class ArchitectureOptimizer:
    """架构优化器"""
    
    def __init__(self, evaluator: ArchitectureEvaluator):
        self.evaluator = evaluator
        self.optimization_history: List[Tuple[Any, float]] = []
        
    def optimize_architecture(self, 
                            initial_architecture: Any,
                            optimization_steps: int = 100,
                            mutation_rate: float = 0.1) -> Tuple[Any, float]:
        """优化架构"""
        current_architecture = copy.deepcopy(initial_architecture)
        current_score = self.evaluator.calculate_overall_score(
            self.evaluator.evaluate_architecture(current_architecture)
        )
        
        best_architecture = copy.deepcopy(current_architecture)
        best_score = current_score
        
        self.optimization_history = [(best_architecture, best_score)]
        
        for step in range(optimization_steps):
            # 生成候选架构
            candidate = self._mutate_architecture(current_architecture, mutation_rate)
            
            # 评估候选架构
            candidate_scores = self.evaluator.evaluate_architecture(candidate)
            candidate_score = self.evaluator.calculate_overall_score(candidate_scores)
            
            # 接受或拒绝候选架构
            if candidate_score > current_score:
                current_architecture = candidate
                current_score = candidate_score
                
                if candidate_score > best_score:
                    best_architecture = copy.deepcopy(candidate)
                    best_score = candidate_score
                    
            self.optimization_history.append((best_architecture, best_score))
            
        return best_architecture, best_score
    
    def _mutate_architecture(self, architecture: Any, mutation_rate: float) -> Any:
        """变异架构"""
        # 简化的变异操作
        mutated = copy.deepcopy(architecture)
        
        # 这里可以实现具体的变异逻辑
        # 例如：添加/删除组件、改变连接关系等
        
        return mutated
    
    def get_optimization_history(self) -> List[Tuple[Any, float]]:
        """获取优化历史"""
        return self.optimization_history

# 使用示例
async def optimize_ecommerce_architecture():
    """优化电商架构示例"""
    # 创建初始架构
    initial_architecture = create_ecommerce_microservices()
    
    # 设置评估器
    evaluator = setup_architecture_evaluator()
    
    # 创建优化器
    optimizer = ArchitectureOptimizer(evaluator)
    
    # 执行优化
    optimized_architecture, final_score = optimizer.optimize_architecture(
        initial_architecture,
        optimization_steps=50,
        mutation_rate=0.1
    )
    
    print(f"Final architecture score: {final_score:.4f}")
    
    # 分析优化历史
    history = optimizer.get_optimization_history()
    print(f"Optimization steps: {len(history)}")
    print(f"Best score achieved: {max(score for _, score in history):.4f}")
    
    return optimized_architecture, final_score
```

## 4. 架构模式应用

### 4.1 模式选择决策

**定义 4.1.1 (模式选择函数)**
模式选择函数 $S$ 根据需求 $R$ 和约束 $C$ 选择最佳模式：
$$S(R, C) = \arg\max_{P \in \mathcal{P}} U(P, R, C)$$
其中 $U$ 是效用函数，$\mathcal{P}$ 是可用模式集合。

**Python实现**：

```python
from typing import Dict, List, Any
from dataclasses import dataclass
from enum import Enum

class ArchitecturePattern(Enum):
    """架构模式枚举"""
    LAYERED = "layered"
    MICROSERVICES = "microservices"
    EVENT_DRIVEN = "event_driven"
    CQRS = "cqrs"
    SAGA = "saga"

@dataclass
class Requirement:
    """需求定义"""
    name: str
    weight: float
    value: float

@dataclass
class Constraint:
    """约束定义"""
    name: str
    type: str  # "hard" or "soft"
    value: Any

class PatternSelector:
    """模式选择器"""
    
    def __init__(self):
        self.pattern_characteristics: Dict[ArchitecturePattern, Dict[str, float]] = {
            ArchitecturePattern.LAYERED: {
                "simplicity": 0.9,
                "performance": 0.7,
                "scalability": 0.5,
                "maintainability": 0.8,
                "deployment_complexity": 0.3
            },
            ArchitecturePattern.MICROSERVICES: {
                "simplicity": 0.4,
                "performance": 0.8,
                "scalability": 0.9,
                "maintainability": 0.7,
                "deployment_complexity": 0.8
            },
            ArchitecturePattern.EVENT_DRIVEN: {
                "simplicity": 0.6,
                "performance": 0.8,
                "scalability": 0.8,
                "maintainability": 0.6,
                "deployment_complexity": 0.6
            }
        }
        
    def select_pattern(self, 
                      requirements: List[Requirement],
                      constraints: List[Constraint]) -> ArchitecturePattern:
        """选择最佳模式"""
        best_pattern = None
        best_score = -1
        
        for pattern in ArchitecturePattern:
            if self._satisfies_constraints(pattern, constraints):
                score = self._calculate_utility(pattern, requirements)
                if score > best_score:
                    best_score = score
                    best_pattern = pattern
                    
        return best_pattern
    
    def _satisfies_constraints(self, 
                              pattern: ArchitecturePattern,
                              constraints: List[Constraint]) -> bool:
        """检查是否满足约束"""
        for constraint in constraints:
            if constraint.type == "hard":
                # 硬约束必须满足
                if not self._check_hard_constraint(pattern, constraint):
                    return False
        return True
    
    def _check_hard_constraint(self, 
                              pattern: ArchitecturePattern,
                              constraint: Constraint) -> bool:
        """检查硬约束"""
        # 简化的约束检查逻辑
        if constraint.name == "team_size" and constraint.value < 5:
            return pattern != ArchitecturePattern.MICROSERVICES
        return True
    
    def _calculate_utility(self, 
                          pattern: ArchitecturePattern,
                          requirements: List[Requirement]) -> float:
        """计算效用值"""
        total_utility = 0.0
        
        for requirement in requirements:
            if requirement.name in self.pattern_characteristics[pattern]:
                pattern_value = self.pattern_characteristics[pattern][requirement.name]
                utility = requirement.weight * pattern_value
                total_utility += utility
                
        return total_utility

# 使用示例
def select_ecommerce_architecture_pattern():
    """为电商系统选择架构模式"""
    selector = PatternSelector()
    
    # 定义需求
    requirements = [
        Requirement("scalability", 0.4, 0.8),
        Requirement("performance", 0.3, 0.7),
        Requirement("maintainability", 0.2, 0.6),
        Requirement("simplicity", 0.1, 0.5)
    ]
    
    # 定义约束
    constraints = [
        Constraint("team_size", "hard", 10),
        Constraint("budget", "soft", 100000),
        Constraint("time_to_market", "soft", 6)
    ]
    
    # 选择模式
    selected_pattern = selector.select_pattern(requirements, constraints)
    
    print(f"Selected architecture pattern: {selected_pattern.value}")
    
    return selected_pattern
```

## 5. 总结

系统架构设计是一个复杂的系统工程，需要综合考虑多个维度的因素。本文档从形式化理论到具体实现，提供了完整的系统架构设计方法：

1. **理论基础**：建立了系统架构的形式化定义和数学基础
2. **设计方法**：提供了分层、微服务、事件驱动等架构模式的具体实现
3. **评估优化**：建立了架构质量评估和优化框架
4. **模式选择**：提供了基于需求和约束的模式选择方法

通过这种系统化的方法，可以设计出高质量、可维护、可扩展的软件系统架构。

---

**相关文档**：
- [02-理论基础/01-设计模式理论.md](../02-理论基础/01-设计模式理论.md)
- [03-具体科学/01-软件架构科学.md](../03-具体科学/01-软件架构科学.md)
- [04-行业领域/01-金融科技领域.md](../04-行业领域/01-金融科技领域.md)
