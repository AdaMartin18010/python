# å¾®æœåŠ¡æ¶æ„åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ç§å°†åº”ç”¨ç¨‹åºæ„å»ºä¸ºå°å‹ã€è‡ªæ²»æœåŠ¡é›†åˆçš„æ¶æ„é£æ ¼ï¼Œæ¯ä¸ªæœåŠ¡è¿è¡Œåœ¨è‡ªå·±çš„è¿›ç¨‹ä¸­ï¼Œå›´ç»•ä¸šåŠ¡èƒ½åŠ›æ„å»ºï¼Œé€šè¿‡è½»é‡çº§æœºåˆ¶é€šä¿¡ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### å¾®æœåŠ¡å®šä¹‰

**å½¢å¼åŒ–å®šä¹‰**ï¼šå¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $MS = (S, C, D, B, Q)$ï¼Œå…¶ä¸­ï¼š

- $S = \{s_1, s_2, ..., s_n\}$ æ˜¯æœåŠ¡é›†åˆ
- $C = \{c_{ij}\}$ æ˜¯æœåŠ¡é—´é€šä¿¡å…³ç³»çŸ©é˜µ
- $D = \{d_1, d_2, ..., d_n\}$ æ˜¯æ•°æ®å­˜å‚¨é›†åˆ
- $B = \{b_1, b_2, ..., b_n\}$ æ˜¯ä¸šåŠ¡è¾¹ç•Œé›†åˆ
- $Q = \{q_1, q_2, ..., q_m\}$ æ˜¯è´¨é‡å±æ€§é›†åˆ

**æœåŠ¡ç‹¬ç«‹æ€§**ï¼šå¯¹äºä»»æ„æœåŠ¡ $s_i \in S$ï¼Œå…¶ç‹¬ç«‹æ€§å®šä¹‰ä¸ºï¼š

$$Independence(s_i) = 1 - \frac{\sum_{j \neq i} |c_{ij}|}{|S| - 1}$$

å…¶ä¸­ $|c_{ij}|$ è¡¨ç¤ºæœåŠ¡ $i$ ä¸æœåŠ¡ $j$ ä¹‹é—´çš„è€¦åˆåº¦ã€‚

### æœåŠ¡ç²’åº¦

**æœåŠ¡ç²’åº¦å‡½æ•°**ï¼š$Granularity(s) = f(Complexity(s), Coupling(s), Cohesion(s))$

å…¶ä¸­ï¼š

- $Complexity(s)$ æ˜¯æœåŠ¡å¤æ‚åº¦
- $Coupling(s)$ æ˜¯æœåŠ¡é—´è€¦åˆåº¦
- $Cohesion(s)$ æ˜¯æœåŠ¡å†…èšåº¦

**æœ€ä¼˜ç²’åº¦æ¡ä»¶**ï¼šå½“ $Granularity(s)$ è¾¾åˆ°å±€éƒ¨æœ€å°å€¼æ—¶ï¼ŒæœåŠ¡ç²’åº¦æœ€ä¼˜ã€‚

## ğŸ”§ Pythonå®ç°

### å¾®æœåŠ¡åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import asyncio
import json
import logging
from datetime import datetime

# æœåŠ¡çŠ¶æ€æšä¸¾
class ServiceStatus(Enum):
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"
    STARTING = "starting"
    STOPPING = "stopping"

# æœåŠ¡é…ç½®
@dataclass
class ServiceConfig:
    name: str
    version: str
    port: int
    host: str = "localhost"
    timeout: int = 30
    retry_attempts: int = 3
    circuit_breaker_threshold: float = 0.5
    
# æœåŠ¡å¥åº·æ£€æŸ¥
@dataclass
class HealthCheck:
    status: ServiceStatus
    timestamp: datetime
    response_time: float
    error_count: int = 0
    last_error: Optional[str] = None

# åŸºç¡€å¾®æœåŠ¡ç±»
class MicroService(ABC):
    """
    å¾®æœåŠ¡åŸºç¡€æŠ½è±¡ç±»
    æä¾›å¾®æœåŠ¡çš„æ ¸å¿ƒåŠŸèƒ½å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
    """
    
    def __init__(self, config: ServiceConfig):
        self.config = config
        self.status = ServiceStatus.STARTING
        self.health_check = HealthCheck(
            status=ServiceStatus.STARTING,
            timestamp=datetime.now(),
            response_time=0.0
        )
        self.dependencies: List[str] = []
        self.metrics: Dict[str, Any] = {}
        self.logger = logging.getLogger(f"service.{config.name}")
        
    @abstractmethod
    async def start(self) -> None:
        """å¯åŠ¨æœåŠ¡"""
        pass
        
    @abstractmethod
    async def stop(self) -> None:
        """åœæ­¢æœåŠ¡"""
        pass
        
    @abstractmethod
    async def health_check_handler(self) -> HealthCheck:
        """å¥åº·æ£€æŸ¥å¤„ç†"""
        pass
        
    async def update_health(self, health: HealthCheck) -> None:
        """æ›´æ–°å¥åº·çŠ¶æ€"""
        self.health_check = health
        self.status = health.status
        self.logger.info(f"Health updated: {health.status.value}")
        
    def add_dependency(self, service_name: str) -> None:
        """æ·»åŠ æœåŠ¡ä¾èµ–"""
        if service_name not in self.dependencies:
            self.dependencies.append(service_name)
            
    def remove_dependency(self, service_name: str) -> None:
        """ç§»é™¤æœåŠ¡ä¾èµ–"""
        if service_name in self.dependencies:
            self.dependencies.remove(service_name)
            
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æœåŠ¡æŒ‡æ ‡"""
        return {
            "name": self.config.name,
            "version": self.config.version,
            "status": self.status.value,
            "health_check": {
                "status": self.health_check.status.value,
                "timestamp": self.health_check.timestamp.isoformat(),
                "response_time": self.health_check.response_time,
                "error_count": self.health_check.error_count
            },
            "dependencies": self.dependencies,
            "metrics": self.metrics
        }

# æœåŠ¡æ³¨å†Œä¸­å¿ƒ
class ServiceRegistry:
    """
    æœåŠ¡æ³¨å†Œä¸­å¿ƒ
    ç®¡ç†å¾®æœåŠ¡çš„æ³¨å†Œã€å‘ç°å’Œå¥åº·ç›‘æ§
    """
    
    def __init__(self):
        self.services: Dict[str, MicroService] = {}
        self.health_checks: Dict[str, HealthCheck] = {}
        self.logger = logging.getLogger("service_registry")
        
    def register_service(self, service: MicroService) -> None:
        """æ³¨å†ŒæœåŠ¡"""
        service_name = service.config.name
        self.services[service_name] = service
        self.logger.info(f"Service registered: {service_name}")
        
    def unregister_service(self, service_name: str) -> None:
        """æ³¨é”€æœåŠ¡"""
        if service_name in self.services:
            del self.services[service_name]
            if service_name in self.health_checks:
                del self.health_checks[service_name]
            self.logger.info(f"Service unregistered: {service_name}")
            
    def get_service(self, service_name: str) -> Optional[MicroService]:
        """è·å–æœåŠ¡å®ä¾‹"""
        return self.services.get(service_name)
        
    def list_services(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
        return list(self.services.keys())
        
    def get_healthy_services(self) -> List[str]:
        """è·å–å¥åº·æœåŠ¡åˆ—è¡¨"""
        healthy_services = []
        for name, service in self.services.items():
            if service.status == ServiceStatus.HEALTHY:
                healthy_services.append(name)
        return healthy_services
        
    async def update_service_health(self, service_name: str, health: HealthCheck) -> None:
        """æ›´æ–°æœåŠ¡å¥åº·çŠ¶æ€"""
        self.health_checks[service_name] = health
        if service_name in self.services:
            await self.services[service_name].update_health(health)
            
    def get_service_health(self, service_name: str) -> Optional[HealthCheck]:
        """è·å–æœåŠ¡å¥åº·çŠ¶æ€"""
        return self.health_checks.get(service_name)

# æœåŠ¡å‘ç°
class ServiceDiscovery:
    """
    æœåŠ¡å‘ç°ç»„ä»¶
    æä¾›æœåŠ¡çš„åŠ¨æ€å‘ç°å’Œè´Ÿè½½å‡è¡¡åŠŸèƒ½
    """
    
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.load_balancers: Dict[str, LoadBalancer] = {}
        self.logger = logging.getLogger("service_discovery")
        
    def discover_service(self, service_name: str) -> Optional[MicroService]:
        """å‘ç°æœåŠ¡"""
        return self.registry.get_service(service_name)
        
    def get_service_endpoint(self, service_name: str) -> Optional[str]:
        """è·å–æœåŠ¡ç«¯ç‚¹"""
        service = self.registry.get_service(service_name)
        if service and service.status == ServiceStatus.HEALTHY:
            return f"http://{service.config.host}:{service.config.port}"
        return None
        
    def add_load_balancer(self, service_name: str, balancer: 'LoadBalancer') -> None:
        """æ·»åŠ è´Ÿè½½å‡è¡¡å™¨"""
        self.load_balancers[service_name] = balancer
        
    def get_load_balanced_endpoint(self, service_name: str) -> Optional[str]:
        """è·å–è´Ÿè½½å‡è¡¡åçš„ç«¯ç‚¹"""
        if service_name in self.load_balancers:
            return self.load_balancers[service_name].get_next_endpoint()
        return self.get_service_endpoint(service_name)

# è´Ÿè½½å‡è¡¡å™¨
class LoadBalancer:
    """
    è´Ÿè½½å‡è¡¡å™¨
    æä¾›å¤šç§è´Ÿè½½å‡è¡¡ç­–ç•¥
    """
    
    def __init__(self, endpoints: List[str], strategy: str = "round_robin"):
        self.endpoints = endpoints
        self.strategy = strategy
        self.current_index = 0
        self.logger = logging.getLogger("load_balancer")
        
    def get_next_endpoint(self) -> Optional[str]:
        """è·å–ä¸‹ä¸€ä¸ªç«¯ç‚¹"""
        if not self.endpoints:
            return None
            
        if self.strategy == "round_robin":
            endpoint = self.endpoints[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.endpoints)
            return endpoint
        elif self.strategy == "random":
            import random
            return random.choice(self.endpoints)
        else:
            return self.endpoints[0] if self.endpoints else None
            
    def add_endpoint(self, endpoint: str) -> None:
        """æ·»åŠ ç«¯ç‚¹"""
        if endpoint not in self.endpoints:
            self.endpoints.append(endpoint)
            
    def remove_endpoint(self, endpoint: str) -> None:
        """ç§»é™¤ç«¯ç‚¹"""
        if endpoint in self.endpoints:
            self.endpoints.remove(endpoint)
```

### æœåŠ¡é€šä¿¡å®ç°

```python
import aiohttp
import asyncio
from typing import Dict, Any, Optional
from dataclasses import dataclass
import json
import time

# æœåŠ¡é€šä¿¡é…ç½®
@dataclass
class CommunicationConfig:
    timeout: int = 30
    retry_attempts: int = 3
    circuit_breaker_threshold: float = 0.5
    circuit_breaker_timeout: int = 60

# æ–­è·¯å™¨çŠ¶æ€
class CircuitBreakerState(Enum):
    CLOSED = "closed"      # æ­£å¸¸çŠ¶æ€
    OPEN = "open"          # æ–­å¼€çŠ¶æ€
    HALF_OPEN = "half_open"  # åŠå¼€çŠ¶æ€

# æ–­è·¯å™¨
class CircuitBreaker:
    """
    æ–­è·¯å™¨æ¨¡å¼å®ç°
    é˜²æ­¢çº§è”æ•…éšœï¼Œæé«˜ç³»ç»Ÿå¼¹æ€§
    """
    
    def __init__(self, config: CommunicationConfig):
        self.config = config
        self.state = CircuitBreakerState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
        self.success_count = 0
        
    def can_execute(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œè¯·æ±‚"""
        if self.state == CircuitBreakerState.CLOSED:
            return True
        elif self.state == CircuitBreakerState.OPEN:
            # æ£€æŸ¥æ˜¯å¦åº”è¯¥è¿›å…¥åŠå¼€çŠ¶æ€
            if (self.last_failure_time and 
                time.time() - self.last_failure_time > self.config.circuit_breaker_timeout):
                self.state = CircuitBreakerState.HALF_OPEN
                return True
            return False
        else:  # HALF_OPEN
            return True
            
    def on_success(self) -> None:
        """è¯·æ±‚æˆåŠŸå¤„ç†"""
        if self.state == CircuitBreakerState.HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.config.circuit_breaker_threshold:
                self.state = CircuitBreakerState.CLOSED
                self.failure_count = 0
                self.success_count = 0
                
    def on_failure(self) -> None:
        """è¯·æ±‚å¤±è´¥å¤„ç†"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.state == CircuitBreakerState.CLOSED:
            if self.failure_count >= self.config.circuit_breaker_threshold:
                self.state = CircuitBreakerState.OPEN
        elif self.state == CircuitBreakerState.HALF_OPEN:
            self.state = CircuitBreakerState.OPEN
            self.success_count = 0

# æœåŠ¡å®¢æˆ·ç«¯
class ServiceClient:
    """
    å¾®æœåŠ¡å®¢æˆ·ç«¯
    æä¾›æœåŠ¡é—´é€šä¿¡åŠŸèƒ½ï¼ŒåŒ…å«æ–­è·¯å™¨ã€é‡è¯•ç­‰æœºåˆ¶
    """
    
    def __init__(self, config: CommunicationConfig):
        self.config = config
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}
        self.session: Optional[aiohttp.ClientSession] = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
            
    def _get_circuit_breaker(self, service_name: str) -> CircuitBreaker:
        """è·å–æˆ–åˆ›å»ºæ–­è·¯å™¨"""
        if service_name not in self.circuit_breakers:
            self.circuit_breakers[service_name] = CircuitBreaker(self.config)
        return self.circuit_breakers[service_name]
        
    async def call_service(
        self, 
        service_name: str, 
        endpoint: str, 
        method: str = "GET",
        data: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """
        è°ƒç”¨å¾®æœåŠ¡
        
        Args:
            service_name: æœåŠ¡åç§°
            endpoint: æœåŠ¡ç«¯ç‚¹
            method: HTTPæ–¹æ³•
            data: è¯·æ±‚æ•°æ®
            headers: è¯·æ±‚å¤´
            
        Returns:
            å“åº”æ•°æ®
        """
        circuit_breaker = self._get_circuit_breaker(service_name)
        
        if not circuit_breaker.can_execute():
            raise Exception(f"Circuit breaker is open for service: {service_name}")
            
        for attempt in range(self.config.retry_attempts):
            try:
                if not self.session:
                    raise Exception("Client session not initialized")
                    
                request_headers = headers or {}
                request_headers.update({
                    "Content-Type": "application/json",
                    "X-Service-Name": service_name
                })
                
                if method.upper() == "GET":
                    async with self.session.get(
                        endpoint, 
                        headers=request_headers,
                        timeout=aiohttp.ClientTimeout(total=self.config.timeout)
                    ) as response:
                        result = await response.json()
                        circuit_breaker.on_success()
                        return result
                        
                elif method.upper() == "POST":
                    async with self.session.post(
                        endpoint,
                        json=data,
                        headers=request_headers,
                        timeout=aiohttp.ClientTimeout(total=self.config.timeout)
                    ) as response:
                        result = await response.json()
                        circuit_breaker.on_success()
                        return result
                        
                else:
                    raise ValueError(f"Unsupported HTTP method: {method}")
                    
            except Exception as e:
                circuit_breaker.on_failure()
                if attempt == self.config.retry_attempts - 1:
                    raise e
                await asyncio.sleep(2 ** attempt)  # æŒ‡æ•°é€€é¿
                
        raise Exception(f"Failed to call service {service_name} after {self.config.retry_attempts} attempts")

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    """å¾®æœåŠ¡æ¶æ„ä½¿ç”¨ç¤ºä¾‹"""
    
    # åˆ›å»ºæœåŠ¡æ³¨å†Œä¸­å¿ƒ
    registry = ServiceRegistry()
    
    # åˆ›å»ºæœåŠ¡å‘ç°
    discovery = ServiceDiscovery(registry)
    
    # åˆ›å»ºæœåŠ¡å®¢æˆ·ç«¯
    config = CommunicationConfig(
        timeout=30,
        retry_attempts=3,
        circuit_breaker_threshold=5
    )
    
    async with ServiceClient(config) as client:
        # æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
        try:
            result = await client.call_service(
                service_name="user-service",
                endpoint="http://localhost:8081/api/users",
                method="GET"
            )
            print(f"Service call result: {result}")
        except Exception as e:
            print(f"Service call failed: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

## ğŸ“Š æ¶æ„æ¨¡å¼

### 1. æœåŠ¡ç¼–æ’æ¨¡å¼

**å®šä¹‰**ï¼šé€šè¿‡ä¸­å¤®åè°ƒå™¨æ˜ç¡®æŒ‡å®šå¤šä¸ªæœåŠ¡ä¹‹é—´çš„äº¤äº’ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$Orchestration(S) = \{f: S \times S \rightarrow \{0,1\} | f(s_i, s_j) = 1 \text{ if } s_i \text{ orchestrates } s_j\}$$

**Pythonå®ç°**ï¼š

```python
class ServiceOrchestrator:
    """æœåŠ¡ç¼–æ’å™¨"""
    
    def __init__(self, discovery: ServiceDiscovery):
        self.discovery = discovery
        self.workflow_definitions: Dict[str, List[str]] = {}
        
    def define_workflow(self, name: str, steps: List[str]) -> None:
        """å®šä¹‰å·¥ä½œæµ"""
        self.workflow_definitions[name] = steps
        
    async def execute_workflow(self, name: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå·¥ä½œæµ"""
        if name not in self.workflow_definitions:
            raise ValueError(f"Workflow {name} not found")
            
        workflow_result = {}
        
        for step in self.workflow_definitions[name]:
            # è·å–æœåŠ¡ç«¯ç‚¹
            endpoint = self.discovery.get_service_endpoint(step)
            if not endpoint:
                raise Exception(f"Service {step} not available")
                
            # æ‰§è¡Œæ­¥éª¤
            result = await self._execute_step(endpoint, context)
            workflow_result[step] = result
            context.update(result)
            
        return workflow_result
        
    async def _execute_step(self, endpoint: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå•ä¸ªæ­¥éª¤"""
        # è¿™é‡Œåº”è¯¥å®ç°å…·ä½“çš„æ­¥éª¤æ‰§è¡Œé€»è¾‘
        return {"status": "completed", "endpoint": endpoint}
```

### 2. æœåŠ¡ç¼–èˆæ¨¡å¼

**å®šä¹‰**ï¼šæœåŠ¡ä¹‹é—´é€šè¿‡äº‹ä»¶å’Œæ¶ˆæ¯è¿›è¡Œæ¾æ•£åè°ƒã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$Choreography(S) = \{E \subset S \times S | \forall (s_i, s_j) \in E, s_i \text{ publishes events to } s_j\}$$

**Pythonå®ç°**ï¼š

```python
from typing import Callable, Dict, List
import asyncio

class EventBus:
    """äº‹ä»¶æ€»çº¿"""
    
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.event_queue = asyncio.Queue()
        
    async def publish(self, event_type: str, event_data: Dict[str, Any]) -> None:
        """å‘å¸ƒäº‹ä»¶"""
        await self.event_queue.put({
            "type": event_type,
            "data": event_data,
            "timestamp": datetime.now()
        })
        
    def subscribe(self, event_type: str, handler: Callable) -> None:
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)
        
    async def start_processing(self) -> None:
        """å¼€å§‹å¤„ç†äº‹ä»¶"""
        while True:
            event = await self.event_queue.get()
            event_type = event["type"]
            
            if event_type in self.subscribers:
                for handler in self.subscribers[event_type]:
                    try:
                        await handler(event["data"])
                    except Exception as e:
                        print(f"Error handling event {event_type}: {e}")
                        
            self.event_queue.task_done()

class ServiceChoreography:
    """æœåŠ¡ç¼–èˆ"""
    
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        
    async def publish_domain_event(self, event_type: str, event_data: Dict[str, Any]) -> None:
        """å‘å¸ƒé¢†åŸŸäº‹ä»¶"""
        await self.event_bus.publish(event_type, event_data)
        
    def subscribe_to_event(self, event_type: str, handler: Callable) -> None:
        """è®¢é˜…é¢†åŸŸäº‹ä»¶"""
        self.event_bus.subscribe(event_type, handler)
```

## ğŸ” è´¨é‡å±æ€§

### 1. å¯ç”¨æ€§

**å®šä¹‰**ï¼š$Availability = \frac{MTTF}{MTTF + MTTR}$

å…¶ä¸­ï¼š

- MTTF (Mean Time To Failure) æ˜¯å¹³å‡æ•…éšœæ—¶é—´
- MTTR (Mean Time To Repair) æ˜¯å¹³å‡ä¿®å¤æ—¶é—´

### 2. å¯æ‰©å±•æ€§

**æ°´å¹³æ‰©å±•**ï¼š$Scalability(n) = \frac{Performance(n)}{Performance(1)}$

å…¶ä¸­ $n$ æ˜¯æœåŠ¡å®ä¾‹æ•°é‡ã€‚

### 3. å¼¹æ€§

**å¼¹æ€§æŒ‡æ ‡**ï¼š$Resilience = \frac{Successful\_Requests}{Total\_Requests}$

## ğŸ“ˆ æ€§èƒ½åˆ†æ

### æœåŠ¡å“åº”æ—¶é—´

**æ•°å­¦æ¨¡å‹**ï¼š
$$ResponseTime(s) = ProcessingTime(s) + NetworkLatency(s) + QueueTime(s)$$

### ååé‡

**ååé‡è®¡ç®—**ï¼š
$$Throughput = \frac{Requests}{Time} = \frac{1}{ResponseTime}$$

## ğŸ›¡ï¸ å®‰å…¨è€ƒè™‘

### 1. æœåŠ¡é—´è®¤è¯

```python
class ServiceAuthentication:
    """æœåŠ¡é—´è®¤è¯"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        
    def generate_token(self, service_name: str) -> str:
        """ç”Ÿæˆè®¤è¯ä»¤ç‰Œ"""
        import jwt
        payload = {
            "service": service_name,
            "timestamp": datetime.now().timestamp()
        }
        return jwt.encode(payload, self.secret_key, algorithm="HS256")
        
    def verify_token(self, token: str) -> Dict[str, Any]:
        """éªŒè¯è®¤è¯ä»¤ç‰Œ"""
        import jwt
        return jwt.decode(token, self.secret_key, algorithms=["HS256"])
```

### 2. æ•°æ®åŠ å¯†

```python
class DataEncryption:
    """æ•°æ®åŠ å¯†"""
    
    def __init__(self, encryption_key: str):
        self.encryption_key = encryption_key
        
    def encrypt_data(self, data: str) -> str:
        """åŠ å¯†æ•°æ®"""
        from cryptography.fernet import Fernet
        f = Fernet(self.encryption_key.encode())
        return f.encrypt(data.encode()).decode()
        
    def decrypt_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•°æ®"""
        from cryptography.fernet import Fernet
        f = Fernet(self.encryption_key.encode())
        return f.decrypt(encrypted_data.encode()).decode()
```

## ğŸ“‹ æœ€ä½³å®è·µ

### 1. æœåŠ¡è®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªæœåŠ¡åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡èƒ½åŠ›
- **æ¾è€¦åˆåŸåˆ™**ï¼šæœåŠ¡é—´ä¾èµ–æœ€å°åŒ–
- **é«˜å†…èšåŸåˆ™**ï¼šæœåŠ¡å†…éƒ¨åŠŸèƒ½ç´§å¯†ç›¸å…³
- **è‡ªæ²»æ€§åŸåˆ™**ï¼šæœåŠ¡å¯ä»¥ç‹¬ç«‹éƒ¨ç½²å’Œè¿è¡Œ

### 2. æ•°æ®ç®¡ç†

- **æ•°æ®åº“åˆ†ç¦»**ï¼šæ¯ä¸ªæœåŠ¡ä½¿ç”¨ç‹¬ç«‹çš„æ•°æ®åº“
- **æ•°æ®ä¸€è‡´æ€§**ï¼šé€šè¿‡äº‹ä»¶é©±åŠ¨ä¿è¯æœ€ç»ˆä¸€è‡´æ€§
- **æ•°æ®è¿ç§»**ï¼šæ”¯æŒæ•°æ®ç‰ˆæœ¬åŒ–å’Œè¿ç§»

### 3. ç›‘æ§å’Œå¯è§‚æµ‹æ€§

```python
class ServiceMonitor:
    """æœåŠ¡ç›‘æ§"""
    
    def __init__(self):
        self.metrics: Dict[str, List[float]] = {}
        
    def record_metric(self, metric_name: str, value: float) -> None:
        """è®°å½•æŒ‡æ ‡"""
        if metric_name not in self.metrics:
            self.metrics[metric_name] = []
        self.metrics[metric_name].append(value)
        
    def get_average_metric(self, metric_name: str) -> float:
        """è·å–å¹³å‡æŒ‡æ ‡"""
        if metric_name not in self.metrics or not self.metrics[metric_name]:
            return 0.0
        return sum(self.metrics[metric_name]) / len(self.metrics[metric_name])
        
    def get_metric_summary(self) -> Dict[str, Dict[str, float]]:
        """è·å–æŒ‡æ ‡æ‘˜è¦"""
        summary = {}
        for metric_name, values in self.metrics.items():
            if values:
                summary[metric_name] = {
                    "average": sum(values) / len(values),
                    "min": min(values),
                    "max": max(values),
                    "count": len(values)
                }
        return summary
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md](../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md) - ç®—æ³•ç†è®ºåŸºç¡€
- [03-å…·ä½“ç§‘å­¦/03-01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md](../03-å…·ä½“ç§‘å­¦/03-01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md) - è®¾è®¡æ¨¡å¼ç§‘å­¦
- [05-æ¶æ„é¢†åŸŸ/05-01-ç³»ç»Ÿæ¶æ„/05-01-01-æ¶æ„åŸºç¡€.md](../05-æ¶æ„é¢†åŸŸ/05-01-ç³»ç»Ÿæ¶æ„/05-01-01-æ¶æ„åŸºç¡€.md) - ç³»ç»Ÿæ¶æ„åŸºç¡€

---

*æœ¬æ–‡æ¡£æä¾›äº†å¾®æœåŠ¡æ¶æ„çš„å®Œæ•´ç†è®ºåŸºç¡€å’ŒPythonå®ç°ï¼ŒåŒ…æ‹¬æ•°å­¦å½¢å¼åŒ–å®šä¹‰ã€ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µã€‚*
