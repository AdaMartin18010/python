# 微服务架构设计

## 1. 概述

### 1.1 微服务定义

**定义 1.1.1 (微服务)**
微服务是独立的、可部署的服务单元，具有明确的业务边界：

$$\text{Microservice} = (F, I, D, S)$$

其中：
- $F = \{f_1, f_2, ..., f_n\}$ 是功能集合
- $I = \{i_1, i_2, ..., i_m\}$ 是接口集合
- $D = \{d_1, d_2, ..., d_k\}$ 是数据集合
- $S = \{s_1, s_2, ..., s_l\}$ 是状态集合

### 1.2 微服务特性

**定理 1.1.1 (微服务复杂度定理)**
微服务系统的复杂度与服务数量、服务间通信和状态管理呈指数关系：

$$\text{Complexity}(M) = O(|S|^2 \times |C| \times |ST|)$$

其中 $S$ 是服务集合，$C$ 是通信模式集合，$ST$ 是状态类型集合。

## 2. 服务拆分策略

### 2.1 领域驱动设计

**定义 2.1.1 (领域边界)**
基于业务领域进行服务拆分，确保每个服务对应一个业务能力：

```python
from typing import Dict, List, Set, Any
from dataclasses import dataclass
from datetime import datetime
import asyncio
import uuid

@dataclass
class Domain:
    """业务领域"""
    name: str
    description: str
    bounded_contexts: List[str]
    entities: List[str]
    value_objects: List[str]

@dataclass
class BoundedContext:
    """限界上下文"""
    name: str
    description: str
    domain: str
    entities: List[str]
    services: List[str]
    interfaces: Dict[str, Any]

class DomainDrivenServiceSplitter:
    """领域驱动服务拆分器"""
    
    def __init__(self):
        self.domains: Dict[str, Domain] = {}
        self.bounded_contexts: Dict[str, BoundedContext] = {}
        self.services: Dict[str, Dict[str, Any]] = {}
    
    def add_domain(self, name: str, description: str) -> Domain:
        """添加业务领域"""
        domain = Domain(
            name=name,
            description=description,
            bounded_contexts=[],
            entities=[],
            value_objects=[]
        )
        self.domains[name] = domain
        return domain
    
    def add_bounded_context(self, name: str, domain: str, description: str) -> BoundedContext:
        """添加限界上下文"""
        if domain not in self.domains:
            raise ValueError(f"Domain {domain} not found")
        
        bounded_context = BoundedContext(
            name=name,
            description=description,
            domain=domain,
            entities=[],
            services=[],
            interfaces={}
        )
        self.bounded_contexts[name] = bounded_context
        self.domains[domain].bounded_contexts.append(name)
        return bounded_context
    
    def add_entity(self, bounded_context: str, entity_name: str, entity_type: str):
        """添加实体"""
        if bounded_context not in self.bounded_contexts:
            raise ValueError(f"Bounded context {bounded_context} not found")
        
        self.bounded_contexts[bounded_context].entities.append(entity_name)
        
        # 同时添加到领域
        domain = self.bounded_contexts[bounded_context].domain
        if entity_name not in self.domains[domain].entities:
            self.domains[domain].entities.append(entity_name)
    
    def create_service_from_context(self, bounded_context: str, service_name: str) -> Dict[str, Any]:
        """从限界上下文创建服务"""
        if bounded_context not in self.bounded_contexts:
            raise ValueError(f"Bounded context {bounded_context} not found")
        
        context = self.bounded_contexts[bounded_context]
        
        service = {
            'id': str(uuid.uuid4()),
            'name': service_name,
            'bounded_context': bounded_context,
            'domain': context.domain,
            'entities': context.entities.copy(),
            'interfaces': context.interfaces.copy(),
            'created_at': datetime.now()
        }
        
        self.services[service_name] = service
        context.services.append(service_name)
        
        return service
    
    def analyze_coupling(self) -> Dict[str, float]:
        """分析服务间耦合度"""
        coupling_scores = {}
        
        for service_name, service in self.services.items():
            # 计算与其他服务的耦合度
            coupling_score = 0.0
            for other_name, other_service in self.services.items():
                if service_name != other_name:
                    # 检查是否有共享实体
                    shared_entities = set(service['entities']) & set(other_service['entities'])
                    if shared_entities:
                        coupling_score += len(shared_entities) / len(service['entities'])
            
            coupling_scores[service_name] = min(coupling_score, 1.0)
        
        return coupling_scores
    
    def get_service_boundaries(self) -> Dict[str, Dict[str, Any]]:
        """获取服务边界"""
        boundaries = {}
        
        for service_name, service in self.services.items():
            boundaries[service_name] = {
                'domain': service['domain'],
                'bounded_context': service['bounded_context'],
                'entities': service['entities'],
                'interfaces': list(service['interfaces'].keys())
            }
        
        return boundaries

# 使用示例
def create_ecommerce_domain_model():
    """创建电商领域模型"""
    splitter = DomainDrivenServiceSplitter()
    
    # 添加业务领域
    splitter.add_domain("Order Management", "订单管理领域")
    splitter.add_domain("Product Catalog", "商品目录领域")
    splitter.add_domain("Customer Management", "客户管理领域")
    splitter.add_domain("Payment Processing", "支付处理领域")
    
    # 添加限界上下文
    splitter.add_bounded_context("Order Processing", "Order Management", "订单处理上下文")
    splitter.add_bounded_context("Inventory Management", "Product Catalog", "库存管理上下文")
    splitter.add_bounded_context("Customer Profile", "Customer Management", "客户档案上下文")
    splitter.add_bounded_context("Payment Gateway", "Payment Processing", "支付网关上下文")
    
    # 添加实体
    splitter.add_entity("Order Processing", "Order", "Aggregate Root")
    splitter.add_entity("Order Processing", "OrderItem", "Entity")
    splitter.add_entity("Inventory Management", "Product", "Aggregate Root")
    splitter.add_entity("Inventory Management", "Stock", "Entity")
    splitter.add_entity("Customer Profile", "Customer", "Aggregate Root")
    splitter.add_entity("Payment Gateway", "Payment", "Aggregate Root")
    
    # 创建服务
    order_service = splitter.create_service_from_context("Order Processing", "OrderService")
    inventory_service = splitter.create_service_from_context("Inventory Management", "InventoryService")
    customer_service = splitter.create_service_from_context("Customer Profile", "CustomerService")
    payment_service = splitter.create_service_from_context("Payment Gateway", "PaymentService")
    
    return splitter
```

### 2.2 服务粒度设计

**定义 2.2.1 (服务粒度)**
服务粒度影响系统的复杂性和可维护性：

```python
from typing import Dict, List, Any
import math

class ServiceGranularityAnalyzer:
    """服务粒度分析器"""
    
    def __init__(self):
        self.services: Dict[str, Dict[str, Any]] = {}
        self.metrics: Dict[str, float] = {}
    
    def add_service(self, name: str, endpoints: int, entities: int, 
                   complexity: float, team_size: int):
        """添加服务"""
        self.services[name] = {
            'endpoints': endpoints,
            'entities': entities,
            'complexity': complexity,
            'team_size': team_size,
            'granularity_score': 0.0
        }
    
    def calculate_granularity_score(self, service_name: str) -> float:
        """计算服务粒度得分"""
        if service_name not in self.services:
            return 0.0
        
        service = self.services[service_name]
        
        # 粒度得分：端点数量、实体数量、复杂度的综合评估
        endpoint_score = min(service['endpoints'] / 20.0, 1.0)  # 标准化到0-1
        entity_score = min(service['entities'] / 10.0, 1.0)
        complexity_score = service['complexity']
        
        # 综合得分
        granularity_score = (endpoint_score + entity_score + complexity_score) / 3.0
        service['granularity_score'] = granularity_score
        
        return granularity_score
    
    def analyze_all_services(self) -> Dict[str, Any]:
        """分析所有服务"""
        results = {
            'services': {},
            'overall_granularity': 0.0,
            'recommendations': []
        }
        
        total_score = 0.0
        service_count = len(self.services)
        
        for service_name in self.services:
            score = self.calculate_granularity_score(service_name)
            total_score += score
            
            results['services'][service_name] = {
                'granularity_score': score,
                'recommendation': self._get_granularity_recommendation(score)
            }
        
        results['overall_granularity'] = total_score / service_count if service_count > 0 else 0.0
        
        # 生成全局建议
        if results['overall_granularity'] > 0.8:
            results['recommendations'].append("Consider splitting some services - overall granularity is too coarse")
        elif results['overall_granularity'] < 0.3:
            results['recommendations'].append("Consider merging some services - overall granularity is too fine")
        else:
            results['recommendations'].append("Service granularity appears to be well-balanced")
        
        return results
    
    def _get_granularity_recommendation(self, score: float) -> str:
        """获取粒度建议"""
        if score > 0.8:
            return "Consider splitting - service is too large"
        elif score < 0.3:
            return "Consider merging - service is too small"
        else:
            return "Appropriate granularity"
    
    def optimize_granularity(self) -> List[Dict[str, Any]]:
        """优化服务粒度"""
        optimizations = []
        
        for service_name, service in self.services.items():
            score = service['granularity_score']
            
            if score > 0.8:
                # 服务过大，建议拆分
                optimizations.append({
                    'service': service_name,
                    'action': 'split',
                    'reason': f'Granularity score too high: {score:.2f}',
                    'suggestions': self._generate_split_suggestions(service)
                })
            elif score < 0.3:
                # 服务过小，建议合并
                optimizations.append({
                    'service': service_name,
                    'action': 'merge',
                    'reason': f'Granularity score too low: {score:.2f}',
                    'suggestions': self._generate_merge_suggestions(service)
                })
        
        return optimizations
    
    def _generate_split_suggestions(self, service: Dict[str, Any]) -> List[str]:
        """生成拆分建议"""
        suggestions = []
        
        if service['endpoints'] > 15:
            suggestions.append("Split by endpoint groups (e.g., read vs write operations)")
        
        if service['entities'] > 8:
            suggestions.append("Split by entity domains")
        
        if service['complexity'] > 0.8:
            suggestions.append("Split by business capabilities")
        
        return suggestions
    
    def _generate_merge_suggestions(self, service: Dict[str, Any]) -> List[str]:
        """生成合并建议"""
        suggestions = []
        
        if service['endpoints'] < 3:
            suggestions.append("Consider merging with related services")
        
        if service['entities'] < 2:
            suggestions.append("Service may be too focused - consider broader scope")
        
        return suggestions
```

## 3. 服务发现与注册

### 3.1 服务注册中心

**定义 3.1.1 (服务注册)**
服务注册中心管理服务的注册、发现和健康检查：

```python
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import json

@dataclass
class ServiceInstance:
    """服务实例"""
    id: str
    service_name: str
    host: str
    port: int
    health_url: str
    metadata: Dict[str, Any]
    registered_at: datetime
    last_heartbeat: datetime
    status: str  # healthy, unhealthy, unknown

class ServiceRegistry:
    """服务注册中心"""
    
    def __init__(self):
        self.services: Dict[str, List[ServiceInstance]] = defaultdict(list)
        self.instances: Dict[str, ServiceInstance] = {}
        self.health_check_interval = 30  # 秒
        self.heartbeat_timeout = 90  # 秒
    
    async def register_service(self, service_name: str, host: str, port: int,
                             health_url: str, metadata: Dict[str, Any] = None) -> str:
        """注册服务"""
        instance_id = str(uuid.uuid4())
        now = datetime.now()
        
        instance = ServiceInstance(
            id=instance_id,
            service_name=service_name,
            host=host,
            port=port,
            health_url=health_url,
            metadata=metadata or {},
            registered_at=now,
            last_heartbeat=now,
            status='healthy'
        )
        
        self.services[service_name].append(instance)
        self.instances[instance_id] = instance
        
        print(f"Service {service_name} registered at {host}:{port}")
        return instance_id
    
    async def deregister_service(self, instance_id: str) -> bool:
        """注销服务"""
        if instance_id not in self.instances:
            return False
        
        instance = self.instances[instance_id]
        service_name = instance.service_name
        
        # 从服务列表中移除
        self.services[service_name] = [
            inst for inst in self.services[service_name] 
            if inst.id != instance_id
        ]
        
        # 从实例映射中移除
        del self.instances[instance_id]
        
        print(f"Service {service_name} deregistered")
        return True
    
    async def discover_service(self, service_name: str, 
                             filters: Dict[str, Any] = None) -> List[ServiceInstance]:
        """发现服务"""
        if service_name not in self.services:
            return []
        
        instances = self.services[service_name]
        
        # 应用过滤器
        if filters:
            instances = self._apply_filters(instances, filters)
        
        # 只返回健康的实例
        healthy_instances = [
            inst for inst in instances 
            if inst.status == 'healthy'
        ]
        
        return healthy_instances
    
    def _apply_filters(self, instances: List[ServiceInstance], 
                      filters: Dict[str, Any]) -> List[ServiceInstance]:
        """应用过滤器"""
        filtered_instances = []
        
        for instance in instances:
            matches = True
            
            for key, value in filters.items():
                if key in instance.metadata:
                    if instance.metadata[key] != value:
                        matches = False
                        break
                else:
                    matches = False
                    break
            
            if matches:
                filtered_instances.append(instance)
        
        return filtered_instances
    
    async def update_heartbeat(self, instance_id: str):
        """更新心跳"""
        if instance_id in self.instances:
            self.instances[instance_id].last_heartbeat = datetime.now()
    
    async def health_check(self):
        """健康检查"""
        while True:
            await asyncio.sleep(self.health_check_interval)
            
            current_time = datetime.now()
            timeout_threshold = current_time - timedelta(seconds=self.heartbeat_timeout)
            
            for instance_id, instance in self.instances.items():
                if instance.last_heartbeat < timeout_threshold:
                    instance.status = 'unhealthy'
                    print(f"Service {instance.service_name} marked as unhealthy")
                else:
                    instance.status = 'healthy'
    
    def get_registry_status(self) -> Dict[str, Any]:
        """获取注册中心状态"""
        total_services = len(self.services)
        total_instances = len(self.instances)
        healthy_instances = sum(
            1 for inst in self.instances.values() 
            if inst.status == 'healthy'
        )
        
        return {
            'total_services': total_services,
            'total_instances': total_instances,
            'healthy_instances': healthy_instances,
            'unhealthy_instances': total_instances - healthy_instances,
            'services': list(self.services.keys())
        }

class ServiceDiscoveryClient:
    """服务发现客户端"""
    
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.cache: Dict[str, List[ServiceInstance]] = {}
        self.cache_ttl = 60  # 秒
        self.cache_timestamps: Dict[str, datetime] = {}
    
    async def get_service_instances(self, service_name: str, 
                                  filters: Dict[str, Any] = None) -> List[ServiceInstance]:
        """获取服务实例"""
        cache_key = f"{service_name}:{hash(str(filters))}"
        current_time = datetime.now()
        
        # 检查缓存
        if (cache_key in self.cache and 
            cache_key in self.cache_timestamps and
            current_time - self.cache_timestamps[cache_key] < timedelta(seconds=self.cache_ttl)):
            return self.cache[cache_key]
        
        # 从注册中心获取
        instances = await self.registry.discover_service(service_name, filters)
        
        # 更新缓存
        self.cache[cache_key] = instances
        self.cache_timestamps[cache_key] = current_time
        
        return instances
    
    async def get_service_url(self, service_name: str, 
                            filters: Dict[str, Any] = None) -> Optional[str]:
        """获取服务URL"""
        instances = await self.get_service_instances(service_name, filters)
        
        if instances:
            # 简单的负载均衡：轮询
            instance = instances[0]  # 简化实现
            return f"http://{instance.host}:{instance.port}"
        
        return None
    
    def clear_cache(self):
        """清空缓存"""
        self.cache.clear()
        self.cache_timestamps.clear()
```

### 3.2 负载均衡

**定义 3.2.1 (负载均衡策略)**
负载均衡器分发请求到多个服务实例：

```python
from typing import List, Optional, Callable
import random
import time

class LoadBalancer:
    """负载均衡器"""
    
    def __init__(self, strategy: str = "round_robin"):
        self.strategy = strategy
        self.current_index = 0
        self.instance_weights: Dict[str, float] = {}
        self.instance_stats: Dict[str, Dict[str, Any]] = {}
    
    def select_instance(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        """选择服务实例"""
        if not instances:
            return None
        
        if self.strategy == "round_robin":
            return self._round_robin(instances)
        elif self.strategy == "random":
            return self._random(instances)
        elif self.strategy == "weighted":
            return self._weighted(instances)
        elif self.strategy == "least_connections":
            return self._least_connections(instances)
        else:
            return instances[0]  # 默认返回第一个
    
    def _round_robin(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """轮询策略"""
        instance = instances[self.current_index % len(instances)]
        self.current_index += 1
        return instance
    
    def _random(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """随机策略"""
        return random.choice(instances)
    
    def _weighted(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """加权策略"""
        if not instances:
            return None
        
        # 计算总权重
        total_weight = sum(self.instance_weights.get(inst.id, 1.0) for inst in instances)
        
        # 随机选择
        random_value = random.uniform(0, total_weight)
        current_weight = 0
        
        for instance in instances:
            weight = self.instance_weights.get(instance.id, 1.0)
            current_weight += weight
            if random_value <= current_weight:
                return instance
        
        return instances[0]
    
    def _least_connections(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """最少连接策略"""
        if not instances:
            return None
        
        min_connections = float('inf')
        selected_instance = instances[0]
        
        for instance in instances:
            connections = self.instance_stats.get(instance.id, {}).get('connections', 0)
            if connections < min_connections:
                min_connections = connections
                selected_instance = instance
        
        return selected_instance
    
    def set_instance_weight(self, instance_id: str, weight: float):
        """设置实例权重"""
        self.instance_weights[instance_id] = weight
    
    def record_request(self, instance_id: str, response_time: float, success: bool):
        """记录请求统计"""
        if instance_id not in self.instance_stats:
            self.instance_stats[instance_id] = {
                'requests': 0,
                'successful_requests': 0,
                'failed_requests': 0,
                'total_response_time': 0.0,
                'connections': 0
            }
        
        stats = self.instance_stats[instance_id]
        stats['requests'] += 1
        stats['total_response_time'] += response_time
        
        if success:
            stats['successful_requests'] += 1
        else:
            stats['failed_requests'] += 1
    
    def get_instance_stats(self, instance_id: str) -> Dict[str, Any]:
        """获取实例统计"""
        if instance_id not in self.instance_stats:
            return {}
        
        stats = self.instance_stats[instance_id]
        
        return {
            'requests': stats['requests'],
            'successful_requests': stats['successful_requests'],
            'failed_requests': stats['failed_requests'],
            'success_rate': stats['successful_requests'] / stats['requests'] if stats['requests'] > 0 else 0.0,
            'avg_response_time': stats['total_response_time'] / stats['requests'] if stats['requests'] > 0 else 0.0,
            'connections': stats['connections']
        }
```

## 4. API网关

### 4.1 网关架构

**定义 4.1.1 (API网关)**
API网关是微服务架构的统一入口，负责路由、认证、限流等功能：

```python
from typing import Dict, List, Any, Optional, Callable
import asyncio
import json
import time

@dataclass
class Route:
    """路由定义"""
    path: str
    method: str
    service_name: str
    timeout: float
    retries: int
    rate_limit: int  # 每分钟请求数

@dataclass
class Request:
    """请求对象"""
    id: str
    path: str
    method: str
    headers: Dict[str, str]
    body: Any
    timestamp: float
    client_ip: str

@dataclass
class Response:
    """响应对象"""
    status_code: int
    headers: Dict[str, str]
    body: Any
    response_time: float

class APIGateway:
    """API网关"""
    
    def __init__(self, service_discovery: ServiceDiscoveryClient, load_balancer: LoadBalancer):
        self.service_discovery = service_discovery
        self.load_balancer = load_balancer
        self.routes: Dict[str, Route] = {}
        self.middleware: List[Callable] = []
        self.rate_limiters: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        self.circuit_breakers: Dict[str, Dict[str, Any]] = defaultdict(dict)
    
    def add_route(self, path: str, method: str, service_name: str, 
                 timeout: float = 30.0, retries: int = 3, rate_limit: int = 1000) -> Route:
        """添加路由"""
        route_key = f"{method}:{path}"
        route = Route(
            path=path,
            method=method,
            service_name=service_name,
            timeout=timeout,
            retries=retries,
            rate_limit=rate_limit
        )
        self.routes[route_key] = route
        return route
    
    def add_middleware(self, middleware: Callable):
        """添加中间件"""
        self.middleware.append(middleware)
    
    async def handle_request(self, request: Request) -> Response:
        """处理请求"""
        start_time = time.time()
        
        # 查找路由
        route_key = f"{request.method}:{request.path}"
        if route_key not in self.routes:
            return Response(
                status_code=404,
                headers={'Content-Type': 'application/json'},
                body={'error': 'Route not found'},
                response_time=time.time() - start_time
            )
        
        route = self.routes[route_key]
        
        # 执行中间件
        for middleware in self.middleware:
            try:
                result = await middleware(request, route)
                if result:  # 中间件返回响应
                    return Response(
                        status_code=result.get('status_code', 200),
                        headers=result.get('headers', {}),
                        body=result.get('body', {}),
                        response_time=time.time() - start_time
                    )
            except Exception as e:
                return Response(
                    status_code=500,
                    headers={'Content-Type': 'application/json'},
                    body={'error': f'Middleware error: {str(e)}'},
                    response_time=time.time() - start_time
                )
        
        # 检查限流
        if not self._check_rate_limit(route, request.client_ip):
            return Response(
                status_code=429,
                headers={'Content-Type': 'application/json'},
                body={'error': 'Rate limit exceeded'},
                response_time=time.time() - start_time
            )
        
        # 检查熔断器
        if self._is_circuit_open(route.service_name):
            return Response(
                status_code=503,
                headers={'Content-Type': 'application/json'},
                body={'error': 'Service temporarily unavailable'},
                response_time=time.time() - start_time
            )
        
        # 转发请求
        try:
            response = await self._forward_request(request, route)
            self._record_success(route.service_name)
            return response
        except Exception as e:
            self._record_failure(route.service_name)
            return Response(
                status_code=500,
                headers={'Content-Type': 'application/json'},
                body={'error': f'Service error: {str(e)}'},
                response_time=time.time() - start_time
            )
    
    def _check_rate_limit(self, route: Route, client_ip: str) -> bool:
        """检查限流"""
        current_minute = int(time.time() / 60)
        key = f"{client_ip}:{current_minute}"
        
        if self.rate_limiters[route.service_name][key] >= route.rate_limit:
            return False
        
        self.rate_limiters[route.service_name][key] += 1
        return True
    
    def _is_circuit_open(self, service_name: str) -> bool:
        """检查熔断器状态"""
        if service_name not in self.circuit_breakers:
            return False
        
        circuit = self.circuit_breakers[service_name]
        failure_count = circuit.get('failure_count', 0)
        last_failure_time = circuit.get('last_failure_time', 0)
        
        # 如果失败次数超过阈值且时间在窗口内，打开熔断器
        if failure_count >= 5 and time.time() - last_failure_time < 60:
            return True
        
        return False
    
    async def _forward_request(self, request: Request, route: Route) -> Response:
        """转发请求"""
        # 获取服务实例
        instances = await self.service_discovery.get_service_instances(route.service_name)
        if not instances:
            raise Exception(f"No instances available for service {route.service_name}")
        
        # 选择实例
        instance = self.load_balancer.select_instance(instances)
        if not instance:
            raise Exception("No instance selected by load balancer")
        
        # 构建目标URL
        target_url = f"http://{instance.host}:{instance.port}{request.path}"
        
        # 模拟请求转发
        await asyncio.sleep(0.1)  # 模拟网络延迟
        
        # 记录请求统计
        response_time = time.time() - time.time()  # 简化实现
        self.load_balancer.record_request(instance.id, response_time, True)
        
        return Response(
            status_code=200,
            headers={'Content-Type': 'application/json'},
            body={'message': f'Request forwarded to {route.service_name}'},
            response_time=response_time
        )
    
    def _record_success(self, service_name: str):
        """记录成功"""
        if service_name in self.circuit_breakers:
            self.circuit_breakers[service_name]['failure_count'] = 0
    
    def _record_failure(self, service_name: str):
        """记录失败"""
        if service_name not in self.circuit_breakers:
            self.circuit_breakers[service_name] = {
                'failure_count': 0,
                'last_failure_time': 0
            }
        
        circuit = self.circuit_breakers[service_name]
        circuit['failure_count'] += 1
        circuit['last_failure_time'] = time.time()

# 中间件示例
async def authentication_middleware(request: Request, route: Route) -> Optional[Dict[str, Any]]:
    """认证中间件"""
    auth_header = request.headers.get('Authorization')
    if not auth_header:
        return {
            'status_code': 401,
            'headers': {'Content-Type': 'application/json'},
            'body': {'error': 'Authentication required'}
        }
    return None

async def logging_middleware(request: Request, route: Route) -> Optional[Dict[str, Any]]:
    """日志中间件"""
    print(f"Request: {request.method} {request.path} -> {route.service_name}")
    return None

# 使用示例
async def api_gateway_example():
    """API网关示例"""
    # 创建服务发现和负载均衡器
    registry = ServiceRegistry()
    discovery_client = ServiceDiscoveryClient(registry)
    load_balancer = LoadBalancer(strategy="round_robin")
    
    # 创建API网关
    gateway = APIGateway(discovery_client, load_balancer)
    
    # 添加中间件
    gateway.add_middleware(authentication_middleware)
    gateway.add_middleware(logging_middleware)
    
    # 添加路由
    gateway.add_route("/users", "GET", "user-service", rate_limit=100)
    gateway.add_route("/orders", "POST", "order-service", rate_limit=50)
    
    # 注册服务实例
    await registry.register_service("user-service", "localhost", 8081, "/health")
    await registry.register_service("order-service", "localhost", 8082, "/health")
    
    # 处理请求
    request = Request(
        id=str(uuid.uuid4()),
        path="/users",
        method="GET",
        headers={'Authorization': 'Bearer token123'},
        body=None,
        timestamp=time.time(),
        client_ip="192.168.1.1"
    )
    
    response = await gateway.handle_request(request)
    print(f"Response: {response.status_code} - {response.body}")
```

## 5. 总结

微服务架构通过服务拆分、服务发现、负载均衡和API网关等核心组件，构建了可扩展、可维护的分布式系统。本文档提供了完整的微服务架构设计方法论，包括领域驱动设计、服务粒度优化、服务发现机制和API网关实现。

关键成功因素包括：
1. **服务拆分**：基于业务领域进行合理的服务拆分
2. **服务治理**：完善的服务注册、发现和监控机制
3. **负载均衡**：多种负载均衡策略确保系统可用性
4. **API网关**：统一的入口和治理点

---

*本文档提供了微服务架构的完整设计方法论，包含数学形式化定义、Python代码实现和最佳实践指导。* 