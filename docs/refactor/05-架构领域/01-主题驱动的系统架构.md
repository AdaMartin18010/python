# 01-主题驱动的系统架构

**文件路径**: `docs/refactor/05-架构领域/01-主题驱动的系统架构.md`  
**树形编号**: 05-01-01  
**相关文件**: 
- [01-理念基础/01-主题的哲学与认知](../01-理念基础/01-主题的哲学与认知.md)
- [02-形式科学/01-主题的集合论基础](../02-形式科学/01-主题的集合论基础.md)
- [03-理论基础/01-主题在计算理论中的角色](../03-理论基础/01-主题在计算理论中的角色.md)

---

## 1. 主题驱动的架构模型

### 1.1 主题架构的数学定义

#### 数学形式化定义

**定义 1.1** (主题驱动架构)
主题驱动架构是一个六元组 $A_T = (T, C, R, E, P, M)$，其中：

- $T$ 为主题集合
- $C$ 为组件集合
- $R$ 为关系集合
- $E$ 为事件集合
- $P$ 为策略集合
- $M$ 为映射函数集合

**定义 1.2** (主题-组件映射)
主题到组件的映射函数 $f_{TC}: T \rightarrow \mathcal{P}(C)$ 定义为：

$$f_{TC}(t) = \{c \in C | \text{component } c \text{ handles topic } t\}$$

#### Python架构实现

```python
from typing import Set, Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import uuid
import asyncio
from abc import ABC, abstractmethod

class ArchitectureEvent(Enum):
    """架构事件类型"""
    TOPIC_CREATED = "topic_created"
    TOPIC_UPDATED = "topic_updated"
    TOPIC_DELETED = "topic_deleted"
    COMPONENT_ADDED = "component_added"
    COMPONENT_REMOVED = "component_removed"
    RELATION_ESTABLISHED = "relation_established"

@dataclass
class Topic:
    """主题定义"""
    id: str
    name: str
    content: Set[str]
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __init__(self, name: str, content: Optional[Set[str]] = None):
        self.id = str(uuid.uuid4())
        self.name = name
        self.content = content or set()

@dataclass
class Component:
    """组件定义"""
    id: str
    name: str
    type: str
    capabilities: Set[str]
    topics: Set[str] = field(default_factory=set)
    
    def __init__(self, name: str, component_type: str, capabilities: Set[str]):
        self.id = str(uuid.uuid4())
        self.name = name
        self.type = component_type
        self.capabilities = capabilities

@dataclass
class Relation:
    """关系定义"""
    source_id: str
    target_id: str
    relation_type: str
    weight: float = 1.0
    metadata: Dict[str, Any] = field(default_factory=dict)

class TopicDrivenArchitecture:
    """主题驱动架构实现"""
    
    def __init__(self):
        self.topics: Dict[str, Topic] = {}
        self.components: Dict[str, Component] = {}
        self.relations: List[Relation] = []
        self.events: List[ArchitectureEvent] = []
        self.topic_component_mapping: Dict[str, Set[str]] = {}
        
    def add_topic(self, topic: Topic) -> None:
        """添加主题"""
        self.topics[topic.id] = topic
        self.topic_component_mapping[topic.id] = set()
        self.events.append(ArchitectureEvent.TOPIC_CREATED)
        
    def add_component(self, component: Component) -> None:
        """添加组件"""
        self.components[component.id] = component
        self.events.append(ArchitectureEvent.COMPONENT_ADDED)
        
    def establish_relation(self, relation: Relation) -> None:
        """建立关系"""
        if (relation.source_id in self.topics or relation.source_id in self.components) and \
           (relation.target_id in self.topics or relation.target_id in self.components):
            self.relations.append(relation)
            self.events.append(ArchitectureEvent.RELATION_ESTABLISHED)
            
    def map_topic_to_component(self, topic_id: str, component_id: str) -> None:
        """映射主题到组件"""
        if topic_id in self.topics and component_id in self.components:
            self.topic_component_mapping[topic_id].add(component_id)
            self.components[component_id].topics.add(topic_id)
            
    def get_components_for_topic(self, topic_id: str) -> Set[Component]:
        """获取处理指定主题的组件"""
        component_ids = self.topic_component_mapping.get(topic_id, set())
        return {self.components[cid] for cid in component_ids if cid in self.components}
        
    def get_topics_for_component(self, component_id: str) -> Set[Topic]:
        """获取组件处理的主题"""
        if component_id in self.components:
            topic_ids = self.components[component_id].topics
            return {self.topics[tid] for tid in topic_ids if tid in self.topics}
        return set()
        
    def analyze_architecture(self) -> Dict[str, Any]:
        """分析架构"""
        return {
            "topic_count": len(self.topics),
            "component_count": len(self.components),
            "relation_count": len(self.relations),
            "event_count": len(self.events),
            "avg_components_per_topic": sum(len(comps) for comps in self.topic_component_mapping.values()) / len(self.topics) if self.topics else 0,
            "avg_topics_per_component": sum(len(comp.topics) for comp in self.components.values()) / len(self.components) if self.components else 0
        }

# 示例：主题驱动架构
def demonstrate_topic_driven_architecture():
    """演示主题驱动架构"""
    architecture = TopicDrivenArchitecture()
    
    # 创建主题
    topics = [
        Topic("用户管理", {"用户", "认证", "授权"}),
        Topic("订单处理", {"订单", "支付", "库存"}),
        Topic("数据分析", {"统计", "报表", "预测"})
    ]
    
    for topic in topics:
        architecture.add_topic(topic)
    
    # 创建组件
    components = [
        Component("用户服务", "service", {"用户管理", "认证"}),
        Component("订单服务", "service", {"订单处理", "支付"}),
        Component("数据服务", "service", {"数据分析", "统计"}),
        Component("API网关", "gateway", {"路由", "负载均衡"})
    ]
    
    for component in components:
        architecture.add_component(component)
    
    # 建立映射关系
    architecture.map_topic_to_component(topics[0].id, components[0].id)
    architecture.map_topic_to_component(topics[1].id, components[1].id)
    architecture.map_topic_to_component(topics[2].id, components[2].id)
    
    # 分析架构
    analysis = architecture.analyze_architecture()
    print("架构分析:", analysis)
```

### 1.2 主题驱动的微服务架构

#### 数学定义

**定义 1.3** (主题微服务)
主题微服务是一个四元组 $MS_T = (S, T, I, D)$，其中：

- $S$ 为服务集合
- $T$ 为主题集合
- $I$ 为接口集合
- $D$ 为数据集合

**定义 1.4** (服务间通信)
服务间通信函数 $f_{comm}: S \times T \rightarrow S^*$ 定义为：

$$f_{comm}(s, t) = \{s' \in S | s' \text{ subscribes to topic } t \text{ from service } s\}$$

#### Python微服务实现

```python
import asyncio
from typing import Dict, List, Set, Optional, Callable, Any
from dataclasses import dataclass
import json
import aiohttp
from datetime import datetime

@dataclass
class Microservice:
    """微服务定义"""
    id: str
    name: str
    topics: Set[str]
    endpoints: Dict[str, str]
    dependencies: Set[str] = field(default_factory=set)
    
    def __init__(self, name: str, topics: Set[str], endpoints: Dict[str, str]):
        self.id = str(uuid.uuid4())
        self.name = name
        self.topics = topics
        self.endpoints = endpoints

class TopicDrivenMicroservice:
    """主题驱动微服务实现"""
    
    def __init__(self, service: Microservice):
        self.service = service
        self.subscribers: Dict[str, List[Callable]] = {}
        self.publishers: Dict[str, List[Callable]] = {}
        self.message_queue: asyncio.Queue = asyncio.Queue()
        
    async def start(self):
        """启动服务"""
        print(f"启动微服务: {self.service.name}")
        await asyncio.gather(
            self._message_processor(),
            self._health_checker()
        )
        
    async def _message_processor(self):
        """消息处理器"""
        while True:
            try:
                message = await self.message_queue.get()
                await self._process_message(message)
            except Exception as e:
                print(f"消息处理错误: {e}")
                
    async def _process_message(self, message: Dict[str, Any]):
        """处理消息"""
        topic = message.get('topic')
        data = message.get('data')
        
        if topic in self.subscribers:
            for callback in self.subscribers[topic]:
                try:
                    await callback(data)
                except Exception as e:
                    print(f"回调执行错误: {e}")
                    
    async def _health_checker(self):
        """健康检查"""
        while True:
            await asyncio.sleep(30)
            print(f"服务 {self.service.name} 健康检查通过")
            
    def subscribe(self, topic: str, callback: Callable):
        """订阅主题"""
        if topic not in self.subscribers:
            self.subscribers[topic] = []
        self.subscribers[topic].append(callback)
        
    def publish(self, topic: str, data: Any):
        """发布消息"""
        message = {
            'topic': topic,
            'data': data,
            'timestamp': datetime.now().isoformat(),
            'service': self.service.name
        }
        asyncio.create_task(self.message_queue.put(message))
        
    async def call_endpoint(self, endpoint: str, method: str = 'GET', data: Any = None):
        """调用端点"""
        if endpoint in self.service.endpoints:
            url = self.service.endpoints[endpoint]
            async with aiohttp.ClientSession() as session:
                if method == 'GET':
                    async with session.get(url) as response:
                        return await response.json()
                elif method == 'POST':
                    async with session.post(url, json=data) as response:
                        return await response.json()

# 示例：微服务架构
async def demonstrate_microservice_architecture():
    """演示微服务架构"""
    # 创建微服务
    user_service = Microservice(
        "用户服务",
        {"用户管理", "认证"},
        {
            "create_user": "http://localhost:8001/users",
            "authenticate": "http://localhost:8001/auth"
        }
    )
    
    order_service = Microservice(
        "订单服务",
        {"订单处理", "支付"},
        {
            "create_order": "http://localhost:8002/orders",
            "process_payment": "http://localhost:8002/payments"
        }
    )
    
    # 创建服务实例
    user_ms = TopicDrivenMicroservice(user_service)
    order_ms = TopicDrivenMicroservice(order_service)
    
    # 设置订阅
    async def handle_user_created(data):
        print(f"订单服务收到用户创建事件: {data}")
        
    order_ms.subscribe("用户管理", handle_user_created)
    
    # 发布消息
    user_ms.publish("用户管理", {"user_id": "123", "action": "created"})
    
    # 启动服务
    await asyncio.gather(
        user_ms.start(),
        order_ms.start()
    )
```

## 2. 主题驱动的事件驱动架构

### 2.1 事件驱动模型

#### 数学定义

**定义 2.1** (主题事件)
主题事件是一个五元组 $E_T = (id, topic, data, timestamp, source)$，其中：

- $id$ 为事件唯一标识符
- $topic$ 为主题标识符
- $data$ 为事件数据
- $timestamp$ 为时间戳
- $source$ 为事件源

**定义 2.2** (事件流)
事件流是一个序列 $S_E = (e_1, e_2, ..., e_n)$，其中每个 $e_i$ 都是一个主题事件。

#### Python事件驱动实现

```python
from typing import Dict, List, Set, Optional, Any, Callable
import asyncio
from datetime import datetime
import json

@dataclass
class TopicEvent:
    """主题事件定义"""
    id: str
    topic: str
    data: Any
    timestamp: datetime
    source: str
    
    def __init__(self, topic: str, data: Any, source: str):
        self.id = str(uuid.uuid4())
        self.topic = topic
        self.data = data
        self.timestamp = datetime.now()
        self.source = source

class EventBus:
    """事件总线"""
    
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.event_history: List[TopicEvent] = []
        self.running = False
        
    async def start(self):
        """启动事件总线"""
        self.running = True
        print("事件总线已启动")
        
    async def stop(self):
        """停止事件总线"""
        self.running = False
        print("事件总线已停止")
        
    def subscribe(self, topic: str, callback: Callable):
        """订阅主题"""
        if topic not in self.subscribers:
            self.subscribers[topic] = []
        self.subscribers[topic].append(callback)
        
    def unsubscribe(self, topic: str, callback: Callable):
        """取消订阅"""
        if topic in self.subscribers:
            self.subscribers[topic] = [cb for cb in self.subscribers[topic] if cb != callback]
            
    async def publish(self, event: TopicEvent):
        """发布事件"""
        self.event_history.append(event)
        
        if event.topic in self.subscribers:
            for callback in self.subscribers[event.topic]:
                try:
                    await callback(event)
                except Exception as e:
                    print(f"事件处理错误: {e}")
                    
    def get_events_by_topic(self, topic: str) -> List[TopicEvent]:
        """获取指定主题的事件"""
        return [event for event in self.event_history if event.topic == topic]
        
    def get_events_by_source(self, source: str) -> List[TopicEvent]:
        """获取指定源的事件"""
        return [event for event in self.event_history if event.source == source]

class EventDrivenService:
    """事件驱动服务"""
    
    def __init__(self, name: str, event_bus: EventBus):
        self.name = name
        self.event_bus = event_bus
        self.subscribed_topics: Set[str] = set()
        
    async def start(self):
        """启动服务"""
        print(f"启动事件驱动服务: {self.name}")
        
    def subscribe_to_topic(self, topic: str, handler: Callable):
        """订阅主题"""
        self.subscribed_topics.add(topic)
        self.event_bus.subscribe(topic, handler)
        
    async def publish_event(self, topic: str, data: Any):
        """发布事件"""
        event = TopicEvent(topic, data, self.name)
        await self.event_bus.publish(event)

# 示例：事件驱动架构
async def demonstrate_event_driven_architecture():
    """演示事件驱动架构"""
    # 创建事件总线
    event_bus = EventBus()
    await event_bus.start()
    
    # 创建服务
    user_service = EventDrivenService("用户服务", event_bus)
    order_service = EventDrivenService("订单服务", event_bus)
    notification_service = EventDrivenService("通知服务", event_bus)
    
    # 设置事件处理器
    async def handle_user_created(event: TopicEvent):
        print(f"订单服务处理用户创建事件: {event.data}")
        # 创建默认购物车
        await order_service.publish_event("购物车创建", {"user_id": event.data["user_id"]})
        
    async def handle_order_created(event: TopicEvent):
        print(f"通知服务处理订单创建事件: {event.data}")
        # 发送通知
        await notification_service.publish_event("发送通知", {"order_id": event.data["order_id"]})
        
    # 订阅事件
    order_service.subscribe_to_topic("用户创建", handle_user_created)
    notification_service.subscribe_to_topic("订单创建", handle_order_created)
    
    # 启动服务
    await asyncio.gather(
        user_service.start(),
        order_service.start(),
        notification_service.start()
    )
    
    # 发布事件
    await user_service.publish_event("用户创建", {"user_id": "123", "email": "user@example.com"})
    
    # 等待事件处理
    await asyncio.sleep(1)
    
    # 停止事件总线
    await event_bus.stop()
```

### 2.2 主题驱动的响应式架构

#### 数学定义

**定义 2.3** (响应式流)
响应式流是一个三元组 $RS = (Publisher, Subscriber, Processor)$，其中：

- $Publisher$ 为发布者集合
- $Subscriber$ 为订阅者集合
- $Processor$ 为处理器集合

**定义 2.4** (背压控制)
背压控制函数 $f_{backpressure}: Publisher \times Subscriber \rightarrow \mathbb{R}$ 定义为：

$$f_{backpressure}(p, s) = \frac{\text{processing_rate}(s)}{\text{publishing_rate}(p)}$$

#### Python响应式实现

```python
from typing import Dict, List, Set, Optional, Any, Callable
import asyncio
from dataclasses import dataclass
import time

@dataclass
class ReactiveStream:
    """响应式流定义"""
    id: str
    topic: str
    buffer_size: int
    processing_rate: float
    
    def __init__(self, topic: str, buffer_size: int = 100):
        self.id = str(uuid.uuid4())
        self.topic = topic
        self.buffer_size = buffer_size
        self.processing_rate = 0.0

class ReactivePublisher:
    """响应式发布者"""
    
    def __init__(self, name: str, stream: ReactiveStream):
        self.name = name
        self.stream = stream
        self.subscribers: List[Callable] = []
        self.buffer: asyncio.Queue = asyncio.Queue(maxsize=stream.buffer_size)
        self.publishing_rate = 0.0
        
    async def publish(self, data: Any):
        """发布数据"""
        try:
            await self.buffer.put(data)
            self.publishing_rate += 1
        except asyncio.QueueFull:
            print(f"发布者 {self.name} 缓冲区已满，丢弃数据")
            
    async def _process_buffer(self):
        """处理缓冲区"""
        while True:
            try:
                data = await self.buffer.get()
                for subscriber in self.subscribers:
                    await subscriber(data)
                self.buffer.task_done()
            except Exception as e:
                print(f"处理数据错误: {e}")
                
    def add_subscriber(self, subscriber: Callable):
        """添加订阅者"""
        self.subscribers.append(subscriber)
        
    async def start(self):
        """启动发布者"""
        asyncio.create_task(self._process_buffer())

class ReactiveSubscriber:
    """响应式订阅者"""
    
    def __init__(self, name: str, processing_delay: float = 0.1):
        self.name = name
        self.processing_delay = processing_delay
        self.processed_count = 0
        
    async def process(self, data: Any):
        """处理数据"""
        await asyncio.sleep(self.processing_delay)
        self.processed_count += 1
        print(f"订阅者 {self.name} 处理数据: {data}")

class BackpressureController:
    """背压控制器"""
    
    def __init__(self):
        self.publishers: Dict[str, ReactivePublisher] = {}
        self.subscribers: Dict[str, ReactiveSubscriber] = {}
        
    def add_publisher(self, publisher: ReactivePublisher):
        """添加发布者"""
        self.publishers[publisher.name] = publisher
        
    def add_subscriber(self, subscriber: ReactiveSubscriber):
        """添加订阅者"""
        self.subscribers[subscriber.name] = subscriber
        
    def calculate_backpressure(self, publisher_name: str, subscriber_name: str) -> float:
        """计算背压"""
        if publisher_name in self.publishers and subscriber_name in self.subscribers:
            publisher = self.publishers[publisher_name]
            subscriber = self.subscribers[subscriber_name]
            
            if publisher.publishing_rate > 0:
                return subscriber.processed_count / publisher.publishing_rate
        return 0.0
        
    def adjust_processing_rate(self, publisher_name: str, target_backpressure: float = 1.0):
        """调整处理速率"""
        if publisher_name in self.publishers:
            publisher = self.publishers[publisher_name]
            current_backpressure = self.calculate_backpressure(publisher_name, list(self.subscribers.keys())[0])
            
            if current_backpressure < target_backpressure:
                # 增加处理速率
                publisher.stream.processing_rate *= 1.1
            else:
                # 减少处理速率
                publisher.stream.processing_rate *= 0.9

# 示例：响应式架构
async def demonstrate_reactive_architecture():
    """演示响应式架构"""
    # 创建流
    data_stream = ReactiveStream("传感器数据", buffer_size=50)
    
    # 创建发布者
    publisher = ReactivePublisher("传感器", data_stream)
    
    # 创建订阅者
    subscriber1 = ReactiveSubscriber("数据处理器1", processing_delay=0.05)
    subscriber2 = ReactiveSubscriber("数据处理器2", processing_delay=0.1)
    
    # 设置订阅关系
    publisher.add_subscriber(subscriber1.process)
    publisher.add_subscriber(subscriber2.process)
    
    # 创建背压控制器
    controller = BackpressureController()
    controller.add_publisher(publisher)
    controller.add_subscriber(subscriber1)
    controller.add_subscriber(subscriber2)
    
    # 启动发布者
    await publisher.start()
    
    # 模拟数据发布
    for i in range(100):
        await publisher.publish(f"数据点_{i}")
        await asyncio.sleep(0.01)
        
        # 检查背压
        if i % 10 == 0:
            backpressure = controller.calculate_backpressure("传感器", "数据处理器1")
            print(f"背压: {backpressure:.2f}")
            controller.adjust_processing_rate("传感器")
```

## 3. 主题驱动的分布式架构

### 3.1 分布式主题管理

#### 数学定义

**定义 3.1** (分布式主题)
分布式主题是一个四元组 $DT = (T, N, P, R)$，其中：

- $T$ 为主题集合
- $N$ 为节点集合
- $P$ 为分区函数
- $R$ 为复制策略

**定义 3.2** (一致性哈希)
一致性哈希函数 $h: T \rightarrow N$ 定义为：

$$h(t) = \arg\min_{n \in N} \text{distance}(hash(t), hash(n))$$

#### Python分布式实现

```python
import hashlib
import bisect
from typing import Dict, List, Set, Optional, Any, Tuple
import asyncio
import aiohttp

class DistributedNode:
    """分布式节点"""
    
    def __init__(self, node_id: str, host: str, port: int):
        self.node_id = node_id
        self.host = host
        self.port = port
        self.topics: Set[str] = set()
        self.replicas: Dict[str, str] = {}
        
    def add_topic(self, topic: str):
        """添加主题"""
        self.topics.add(topic)
        
    def remove_topic(self, topic: str):
        """移除主题"""
        self.topics.discard(topic)
        
    def get_url(self) -> str:
        """获取节点URL"""
        return f"http://{self.host}:{self.port}"

class ConsistentHashRing:
    """一致性哈希环"""
    
    def __init__(self, virtual_nodes: int = 150):
        self.virtual_nodes = virtual_nodes
        self.ring: List[int] = []
        self.node_map: Dict[int, DistributedNode] = {}
        
    def add_node(self, node: DistributedNode):
        """添加节点"""
        for i in range(self.virtual_nodes):
            virtual_key = self._hash(f"{node.node_id}:{i}")
            self.ring.append(virtual_key)
            self.node_map[virtual_key] = node
            
        self.ring.sort()
        
    def remove_node(self, node: DistributedNode):
        """移除节点"""
        for i in range(self.virtual_nodes):
            virtual_key = self._hash(f"{node.node_id}:{i}")
            if virtual_key in self.ring:
                self.ring.remove(virtual_key)
                del self.node_map[virtual_key]
                
    def get_node(self, topic: str) -> Optional[DistributedNode]:
        """获取负责主题的节点"""
        if not self.ring:
            return None
            
        key = self._hash(topic)
        idx = bisect.bisect_right(self.ring, key)
        
        if idx == len(self.ring):
            idx = 0
            
        return self.node_map[self.ring[idx]]
        
    def _hash(self, key: str) -> int:
        """计算哈希值"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)

class DistributedTopicManager:
    """分布式主题管理器"""
    
    def __init__(self, replication_factor: int = 3):
        self.hash_ring = ConsistentHashRing()
        self.nodes: Dict[str, DistributedNode] = {}
        self.replication_factor = replication_factor
        
    def add_node(self, node: DistributedNode):
        """添加节点"""
        self.nodes[node.node_id] = node
        self.hash_ring.add_node(node)
        
    def remove_node(self, node_id: str):
        """移除节点"""
        if node_id in self.nodes:
            node = self.nodes[node_id]
            self.hash_ring.remove_node(node)
            del self.nodes[node_id]
            
    def assign_topic(self, topic: str) -> List[DistributedNode]:
        """分配主题到节点"""
        primary_node = self.hash_ring.get_node(topic)
        if not primary_node:
            return []
            
        # 添加主节点
        assigned_nodes = [primary_node]
        primary_node.add_topic(topic)
        
        # 添加副本节点
        node_list = list(self.nodes.values())
        primary_index = node_list.index(primary_node)
        
        for i in range(1, self.replication_factor):
            replica_index = (primary_index + i) % len(node_list)
            replica_node = node_list[replica_index]
            assigned_nodes.append(replica_node)
            replica_node.add_topic(topic)
            primary_node.replicas[topic] = replica_node.node_id
            
        return assigned_nodes
        
    async def publish_to_topic(self, topic: str, data: Any) -> bool:
        """发布到主题"""
        assigned_nodes = self.assign_topic(topic)
        
        success_count = 0
        for node in assigned_nodes:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        f"{node.get_url()}/topics/{topic}",
                        json=data
                    ) as response:
                        if response.status == 200:
                            success_count += 1
            except Exception as e:
                print(f"发布到节点 {node.node_id} 失败: {e}")
                
        return success_count > 0
        
    def get_topic_nodes(self, topic: str) -> List[DistributedNode]:
        """获取主题的节点列表"""
        return [node for node in self.nodes.values() if topic in node.topics]

# 示例：分布式架构
async def demonstrate_distributed_architecture():
    """演示分布式架构"""
    # 创建分布式主题管理器
    manager = DistributedTopicManager(replication_factor=2)
    
    # 创建节点
    nodes = [
        DistributedNode("node1", "localhost", 8001),
        DistributedNode("node2", "localhost", 8002),
        DistributedNode("node3", "localhost", 8003),
        DistributedNode("node4", "localhost", 8004)
    ]
    
    # 添加节点
    for node in nodes:
        manager.add_node(node)
    
    # 分配主题
    topics = ["用户管理", "订单处理", "数据分析", "通知服务"]
    
    for topic in topics:
        assigned_nodes = manager.assign_topic(topic)
        print(f"主题 '{topic}' 分配到节点: {[node.node_id for node in assigned_nodes]}")
    
    # 发布数据
    await manager.publish_to_topic("用户管理", {"user_id": "123", "action": "created"})
    
    # 查看节点状态
    for node in nodes:
        print(f"节点 {node.node_id} 处理的主题: {node.topics}")
```

## 4. 总结与展望

### 4.1 架构基础总结

主题驱动的系统架构涵盖了：

1. **基础架构模型**: 主题-组件映射和关系管理
2. **微服务架构**: 基于主题的服务分解和通信
3. **事件驱动架构**: 主题事件的生产、消费和处理
4. **响应式架构**: 主题流的背压控制和流处理
5. **分布式架构**: 主题的分布式存储和一致性管理

### 4.2 与后续章节的关联

本架构基础为后续章节提供了：

- [06-组件算法/01-主题相关的算法实现](../06-组件算法/01-主题相关的算法实现.md) 提供架构框架
- [07-实践应用/01-主题驱动的工程实践](../07-实践应用/01-主题驱动的工程实践.md) 提供设计模式
- [04-行业领域/01-主题在金融科技中的应用](../04-行业领域/01-主题在金融科技中的应用.md) 提供技术基础

### 4.3 未来研究方向

1. **主题网格**: 主题在网格计算中的分布和调度
2. **主题云原生**: 主题在云原生架构中的容器化和编排
3. **主题边缘计算**: 主题在边缘计算中的本地化处理
4. **主题量子架构**: 主题在量子计算中的量子态表示

---

**相关链接**:
- [返回目录](../../README.md)
- [上一章：主题在计算理论中的角色](../03-理论基础/01-主题在计算理论中的角色.md)
- [下一章：主题相关的算法实现](../06-组件算法/01-主题相关的算法实现.md) 