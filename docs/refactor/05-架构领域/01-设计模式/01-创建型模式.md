# 创建型设计模式

## 目录

- [创建型设计模式](#创建型设计模式)
  - [目录](#目录)
  - [1. 单例模式](#1-单例模式)
    - [1.1 定义与概念](#11-定义与概念)
    - [1.2 Python 实现](#12-python-实现)
  - [2. 工厂方法模式](#2-工厂方法模式)
    - [2.1 定义与概念](#21-定义与概念)
    - [2.2 Python 实现](#22-python-实现)
  - [3. 抽象工厂模式](#3-抽象工厂模式)
    - [3.1 定义与概念](#31-定义与概念)
    - [3.2 Python 实现](#32-python-实现)
  - [4. 建造者模式](#4-建造者模式)
    - [4.1 定义与概念](#41-定义与概念)
    - [4.2 Python 实现](#42-python-实现)
  - [5. 原型模式](#5-原型模式)
    - [5.1 定义与概念](#51-定义与概念)
    - [5.2 Python 实现](#52-python-实现)

---

## 1. 单例模式

### 1.1 定义与概念

**定义**: 确保一个类只有一个实例，并提供全局访问点。

**数学形式**: 设 $C$ 为类，$I$ 为实例集合，则单例模式满足：
$$\forall i_1, i_2 \in I: i_1 = i_2$$

### 1.2 Python 实现

```python
from typing import Any, Optional
from threading import Lock
import weakref

class Singleton:
    """单例模式基类"""
    
    _instances: weakref.WeakValueDictionary = weakref.WeakValueDictionary()
    _lock = Lock()
    
    def __new__(cls, *args, **kwargs):
        if cls not in cls._instances:
            with cls._lock:
                if cls not in cls._instances:
                    cls._instances[cls] = super().__new__(cls)
        return cls._instances[cls]

class Logger(Singleton):
    """日志记录器单例"""
    
    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = True
            self.logs = []
    
    def log(self, message: str) -> None:
        self.logs.append(message)
        print(f"[LOG] {message}")
    
    def get_logs(self) -> list:
        return self.logs.copy()

# 使用示例
logger1 = Logger()
logger2 = Logger()
print(f"Same instance: {logger1 is logger2}")  # True
```

## 2. 工厂方法模式

### 2.1 定义与概念

**定义**: 定义一个创建对象的接口，让子类决定实例化哪个类。

**数学形式**: 设 $F$ 为工厂，$P$ 为产品，则：
$$F: \text{Context} \rightarrow P$$

### 2.2 Python 实现

```python
from abc import ABC, abstractmethod
from typing import Dict, Type

class Product(ABC):
    """产品抽象基类"""
    
    @abstractmethod
    def operation(self) -> str:
        pass

class ConcreteProductA(Product):
    def operation(self) -> str:
        return "ConcreteProductA operation"

class ConcreteProductB(Product):
    def operation(self) -> str:
        return "ConcreteProductB operation"

class Creator(ABC):
    """创建者抽象基类"""
    
    @abstractmethod
    def factory_method(self) -> Product:
        pass
    
    def some_operation(self) -> str:
        product = self.factory_method()
        return f"Creator: {product.operation()}"

class ConcreteCreatorA(Creator):
    def factory_method(self) -> Product:
        return ConcreteProductA()

class ConcreteCreatorB(Creator):
    def factory_method(self) -> Product:
        return ConcreteProductB()

# 使用示例
def client_code(creator: Creator) -> None:
    print(creator.some_operation())

client_code(ConcreteCreatorA())
client_code(ConcreteCreatorB())
```

## 3. 抽象工厂模式

### 3.1 定义与概念

**定义**: 提供一个创建一系列相关对象的接口，而无需指定具体类。

**数学形式**: 设 $AF$ 为抽象工厂，$P_1, P_2, ..., P_n$ 为产品族，则：
$$AF: \text{Context} \rightarrow (P_1, P_2, ..., P_n)$$

### 3.2 Python 实现

```python
class AbstractProductA(ABC):
    @abstractmethod
    def operation_a(self) -> str:
        pass

class AbstractProductB(ABC):
    @abstractmethod
    def operation_b(self) -> str:
        pass

class ConcreteProductA1(AbstractProductA):
    def operation_a(self) -> str:
        return "ConcreteProductA1"

class ConcreteProductA2(AbstractProductA):
    def operation_a(self) -> str:
        return "ConcreteProductA2"

class ConcreteProductB1(AbstractProductB):
    def operation_b(self) -> str:
        return "ConcreteProductB1"

class ConcreteProductB2(AbstractProductB):
    def operation_b(self) -> str:
        return "ConcreteProductB2"

class AbstractFactory(ABC):
    @abstractmethod
    def create_product_a(self) -> AbstractProductA:
        pass
    
    @abstractmethod
    def create_product_b(self) -> AbstractProductB:
        pass

class ConcreteFactory1(AbstractFactory):
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA1()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB1()

class ConcreteFactory2(AbstractFactory):
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA2()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB2()

# 使用示例
def client_code(factory: AbstractFactory) -> None:
    product_a = factory.create_product_a()
    product_b = factory.create_product_b()
    print(f"{product_a.operation_a()} + {product_b.operation_b()}")

client_code(ConcreteFactory1())
client_code(ConcreteFactory2())
```

## 4. 建造者模式

### 4.1 定义与概念

**定义**: 将一个复杂对象的构建与表示分离，使同样的构建过程可以创建不同的表示。

**数学形式**: 设 $B$ 为建造者，$P$ 为产品，则：
$$B: \text{Steps} \rightarrow P$$

### 4.2 Python 实现

```python
class Product:
    def __init__(self):
        self.parts = []
    
    def add(self, part: str) -> None:
        self.parts.append(part)
    
    def list_parts(self) -> str:
        return f"Product parts: {', '.join(self.parts)}"

class Builder(ABC):
    @abstractmethod
    def reset(self) -> None:
        pass
    
    @abstractmethod
    def build_part_a(self) -> None:
        pass
    
    @abstractmethod
    def build_part_b(self) -> None:
        pass
    
    @abstractmethod
    def build_part_c(self) -> None:
        pass

class ConcreteBuilder(Builder):
    def __init__(self):
        self.reset()
    
    def reset(self) -> None:
        self._product = Product()
    
    def build_part_a(self) -> None:
        self._product.add("PartA")
    
    def build_part_b(self) -> None:
        self._product.add("PartB")
    
    def build_part_c(self) -> None:
        self._product.add("PartC")
    
    def get_product(self) -> Product:
        product = self._product
        self.reset()
        return product

class Director:
    def __init__(self):
        self._builder = None
    
    def set_builder(self, builder: Builder) -> None:
        self._builder = builder
    
    def build_minimal_viable_product(self) -> Product:
        self._builder.build_part_a()
        return self._builder.get_product()
    
    def build_full_featured_product(self) -> Product:
        self._builder.build_part_a()
        self._builder.build_part_b()
        self._builder.build_part_c()
        return self._builder.get_product()

# 使用示例
director = Director()
builder = ConcreteBuilder()
director.set_builder(builder)

print("Minimal product:")
minimal_product = director.build_minimal_viable_product()
print(minimal_product.list_parts())

print("\nFull product:")
full_product = director.build_full_featured_product()
print(full_product.list_parts())
```

## 5. 原型模式

### 5.1 定义与概念

**定义**: 用原型实例指定创建对象的种类，通过复制这些原型创建新对象。

**数学形式**: 设 $P$ 为原型，$C$ 为克隆函数，则：
$$C: P \rightarrow P$$

### 5.2 Python 实现

```python
import copy
from abc import ABC, abstractmethod

class Prototype(ABC):
    @abstractmethod
    def clone(self) -> 'Prototype':
        pass

class ConcretePrototype(Prototype):
    def __init__(self, data: str):
        self.data = data
    
    def clone(self) -> 'ConcretePrototype':
        return copy.deepcopy(self)
    
    def __str__(self) -> str:
        return f"ConcretePrototype(data='{self.data}')"

# 使用示例
prototype = ConcretePrototype("original")
clone1 = prototype.clone()
clone2 = prototype.clone()

print(f"Original: {prototype}")
print(f"Clone 1: {clone1}")
print(f"Clone 2: {clone2}")
print(f"Original is clone1: {prototype is clone1}")  # False
print(f"Clone1 is clone2: {clone1 is clone2}")      # False
```

---

**总结**: 创建型模式关注对象的创建过程，提供了灵活的对象创建机制，使系统更加灵活和可扩展。
