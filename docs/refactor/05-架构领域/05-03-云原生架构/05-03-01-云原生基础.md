# äº‘åŸç”Ÿæ¶æ„åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

äº‘åŸç”Ÿæ¶æ„æ˜¯ä¸€ç§æ„å»ºå’Œè¿è¡Œåº”ç”¨ç¨‹åºçš„æ–¹æ³•ï¼Œå……åˆ†åˆ©ç”¨äº‘è®¡ç®—æ¨¡å‹çš„ä¼˜åŠ¿ã€‚å®ƒåŸºäºå®¹å™¨åŒ–ã€å¾®æœåŠ¡ã€DevOpså’ŒæŒç»­äº¤ä»˜ç­‰æ ¸å¿ƒæŠ€æœ¯ï¼Œå®ç°é«˜å¯ç”¨æ€§ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 äº‘åŸç”Ÿç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (äº‘åŸç”Ÿç³»ç»Ÿ)
äº‘åŸç”Ÿç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $\mathcal{C} = (S, C, O, D, M, A, R)$ï¼Œå…¶ä¸­ï¼š

- $S = \{s_1, s_2, \ldots, s_n\}$ æ˜¯æœåŠ¡é›†åˆ
- $C = \{c_1, c_2, \ldots, c_m\}$ æ˜¯å®¹å™¨é›†åˆ
- $O = \{o_1, o_2, \ldots, o_k\}$ æ˜¯ç¼–æ’å™¨é›†åˆ
- $D = \{d_1, d_2, \ldots, d_p\}$ æ˜¯æ•°æ®å­˜å‚¨é›†åˆ
- $M = \{m_1, m_2, \ldots, m_q\}$ æ˜¯ç›‘æ§ç³»ç»Ÿé›†åˆ
- $A = \{a_1, a_2, \ldots, a_r\}$ æ˜¯è‡ªåŠ¨åŒ–å·¥å…·é›†åˆ
- $R: S \times C \rightarrow \{0, 1\}$ æ˜¯æœåŠ¡åˆ°å®¹å™¨çš„æ˜ å°„å…³ç³»

### 1.2 å®¹å™¨åŒ–æ¨¡å‹

**å®šä¹‰ 1.2** (å®¹å™¨)
å®¹å™¨æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{T} = (I, R, E, N)$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯é•œåƒæ ‡è¯†ç¬¦
- $R$ æ˜¯èµ„æºé™åˆ¶é›†åˆ
- $E$ æ˜¯ç¯å¢ƒå˜é‡é›†åˆ
- $N$ æ˜¯ç½‘ç»œé…ç½®

**å®šä¹‰ 1.3** (å®¹å™¨ç¼–æ’)
å®¹å™¨ç¼–æ’æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{O} = (C, S, P)$ï¼Œå…¶ä¸­ï¼š

- $C$ æ˜¯å®¹å™¨é›†åˆ
- $S$ æ˜¯è°ƒåº¦ç­–ç•¥
- $P: C \times N \rightarrow \{0, 1\}$ æ˜¯å®¹å™¨åˆ°èŠ‚ç‚¹çš„åˆ†é…å‡½æ•°

### 1.3 å¾®æœåŠ¡æ¶æ„æ¨¡å‹

**å®šä¹‰ 1.4** (å¾®æœåŠ¡)
å¾®æœåŠ¡æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{M} = (N, I, D, C, L)$ï¼Œå…¶ä¸­ï¼š

- $N$ æ˜¯æœåŠ¡åç§°
- $I$ æ˜¯æ¥å£å®šä¹‰
- $D$ æ˜¯æ•°æ®æ¨¡å‹
- $C$ æ˜¯é…ç½®ä¿¡æ¯
- $L$ æ˜¯ç”Ÿå‘½å‘¨æœŸç®¡ç†

**å®šç† 1.1** (å¾®æœåŠ¡ç‹¬ç«‹æ€§)
å¯¹äºä»»æ„ä¸¤ä¸ªå¾®æœåŠ¡ $m_1, m_2$ï¼Œå¦‚æœ $m_1 \neq m_2$ï¼Œåˆ™å®ƒä»¬çš„éƒ¨ç½²å’Œæ‰©å±•æ˜¯ç‹¬ç«‹çš„ã€‚

**è¯æ˜**:

1. å¾®æœåŠ¡é€šè¿‡å®šä¹‰æ˜¯ç‹¬ç«‹çš„æœåŠ¡å•å…ƒ
2. æ¯ä¸ªå¾®æœåŠ¡æœ‰è‡ªå·±çš„å®¹å™¨å’Œèµ„æº
3. å› æ­¤éƒ¨ç½²å’Œæ‰©å±•æ“ä½œä¸ä¼šç›¸äº’å½±å“

## 2. Pythonå®ç°

### 2.1 å®¹å™¨æŠ½è±¡

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any, Tuple
from enum import Enum
import time
import uuid
import json
import subprocess
import threading
from collections import defaultdict

class ContainerState(Enum):
    """å®¹å™¨çŠ¶æ€"""
    CREATED = "created"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    REMOVED = "removed"

class ResourceType(Enum):
    """èµ„æºç±»å‹"""
    CPU = "cpu"
    MEMORY = "memory"
    STORAGE = "storage"
    NETWORK = "network"

@dataclass
class ResourceLimit:
    """èµ„æºé™åˆ¶"""
    resource_type: ResourceType
    limit: float
    request: float = 0.0
    unit: str = ""

@dataclass
class ContainerConfig:
    """å®¹å™¨é…ç½®"""
    image: str
    command: List[str] = field(default_factory=list)
    args: List[str] = field(default_factory=list)
    env_vars: Dict[str, str] = field(default_factory=dict)
    ports: Dict[int, int] = field(default_factory=dict)
    volumes: Dict[str, str] = field(default_factory=dict)
    resource_limits: List[ResourceLimit] = field(default_factory=list)
    health_check: Optional[str] = None
    restart_policy: str = "always"

class Container:
    """å®¹å™¨æŠ½è±¡"""
    
    def __init__(self, container_id: str, config: ContainerConfig):
        self.container_id = container_id
        self.config = config
        self.state = ContainerState.CREATED
        self.created_at = time.time()
        self.started_at: Optional[float] = None
        self.stopped_at: Optional[float] = None
        self.exit_code: Optional[int] = None
        self.process: Optional[subprocess.Popen] = None
        self.logs: List[str] = []
        
    def start(self) -> bool:
        """å¯åŠ¨å®¹å™¨"""
        try:
            # æ„å»ºDockerå‘½ä»¤
            cmd = ["docker", "run", "-d"]
            
            # æ·»åŠ ç¯å¢ƒå˜é‡
            for key, value in self.config.env_vars.items():
                cmd.extend(["-e", f"{key}={value}"])
                
            # æ·»åŠ ç«¯å£æ˜ å°„
            for host_port, container_port in self.config.ports.items():
                cmd.extend(["-p", f"{host_port}:{container_port}"])
                
            # æ·»åŠ å·æŒ‚è½½
            for host_path, container_path in self.config.volumes.items():
                cmd.extend(["-v", f"{host_path}:{container_path}"])
                
            # æ·»åŠ èµ„æºé™åˆ¶
            for limit in self.config.resource_limits:
                if limit.resource_type == ResourceType.CPU:
                    cmd.extend(["--cpus", str(limit.limit)])
                elif limit.resource_type == ResourceType.MEMORY:
                    cmd.extend(["--memory", f"{limit.limit}{limit.unit}"])
                    
            # æ·»åŠ é•œåƒå’Œå‘½ä»¤
            cmd.append(self.config.image)
            cmd.extend(self.config.command)
            cmd.extend(self.config.args)
            
            # å¯åŠ¨å®¹å™¨
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.state = ContainerState.RUNNING
                self.started_at = time.time()
                self.container_id = result.stdout.strip()
                return True
            else:
                self.logs.append(f"å¯åŠ¨å¤±è´¥: {result.stderr}")
                return False
                
        except Exception as e:
            self.logs.append(f"å¯åŠ¨å¼‚å¸¸: {str(e)}")
            return False
            
    def stop(self) -> bool:
        """åœæ­¢å®¹å™¨"""
        try:
            if self.state == ContainerState.RUNNING:
                result = subprocess.run(
                    ["docker", "stop", self.container_id],
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    self.state = ContainerState.STOPPED
                    self.stopped_at = time.time()
                    return True
                else:
                    self.logs.append(f"åœæ­¢å¤±è´¥: {result.stderr}")
                    return False
            return True
            
        except Exception as e:
            self.logs.append(f"åœæ­¢å¼‚å¸¸: {str(e)}")
            return False
            
    def remove(self) -> bool:
        """åˆ é™¤å®¹å™¨"""
        try:
            if self.state != ContainerState.REMOVED:
                result = subprocess.run(
                    ["docker", "rm", "-f", self.container_id],
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    self.state = ContainerState.REMOVED
                    return True
                else:
                    self.logs.append(f"åˆ é™¤å¤±è´¥: {result.stderr}")
                    return False
            return True
            
        except Exception as e:
            self.logs.append(f"åˆ é™¤å¼‚å¸¸: {str(e)}")
            return False
            
    def get_logs(self, tail: int = 100) -> List[str]:
        """è·å–æ—¥å¿—"""
        try:
            result = subprocess.run(
                ["docker", "logs", "--tail", str(tail), self.container_id],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return result.stdout.splitlines()
            else:
                return []
                
        except Exception:
            return []
            
    def get_stats(self) -> Dict[str, Any]:
        """è·å–å®¹å™¨ç»Ÿè®¡ä¿¡æ¯"""
        try:
            result = subprocess.run(
                ["docker", "stats", "--no-stream", "--format", "json", self.container_id],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return {}
                
        except Exception:
            return {}
```

### 2.2 å®¹å™¨ç¼–æ’å™¨

```python
class ContainerOrchestrator:
    """å®¹å™¨ç¼–æ’å™¨"""
    
    def __init__(self):
        self.containers: Dict[str, Container] = {}
        self.services: Dict[str, List[str]] = defaultdict(list)
        self.nodes: Dict[str, Dict[str, Any]] = {}
        self.scheduling_policy = "round_robin"
        
    def register_node(self, node_id: str, capacity: Dict[str, float]) -> None:
        """æ³¨å†ŒèŠ‚ç‚¹"""
        self.nodes[node_id] = {
            "capacity": capacity,
            "used_resources": defaultdict(float),
            "containers": set()
        }
        
    def create_service(self, service_name: str, config: ContainerConfig, replicas: int = 1) -> List[str]:
        """åˆ›å»ºæœåŠ¡"""
        container_ids = []
        
        for i in range(replicas):
            container_id = f"{service_name}-{i}-{uuid.uuid4().hex[:8]}"
            container = Container(container_id, config)
            
            # é€‰æ‹©èŠ‚ç‚¹
            selected_node = self._select_node(config.resource_limits)
            if selected_node:
                # åˆ†é…èµ„æº
                self._allocate_resources(selected_node, config.resource_limits)
                self.nodes[selected_node]["containers"].add(container_id)
                
                # å¯åŠ¨å®¹å™¨
                if container.start():
                    self.containers[container_id] = container
                    self.services[service_name].append(container_id)
                    container_ids.append(container_id)
                    
        return container_ids
        
    def scale_service(self, service_name: str, target_replicas: int) -> bool:
        """æ‰©ç¼©å®¹æœåŠ¡"""
        current_replicas = len(self.services.get(service_name, []))
        
        if target_replicas > current_replicas:
            # æ‰©å®¹
            config = self._get_service_config(service_name)
            if config:
                new_containers = self.create_service(
                    service_name, config, target_replicas - current_replicas
                )
                return len(new_containers) == target_replicas - current_replicas
        elif target_replicas < current_replicas:
            # ç¼©å®¹
            containers_to_remove = current_replicas - target_replicas
            service_containers = self.services.get(service_name, [])
            
            for i in range(containers_to_remove):
                if service_containers:
                    container_id = service_containers.pop()
                    self._remove_container(container_id)
                    
        return True
        
    def update_service(self, service_name: str, new_config: ContainerConfig) -> bool:
        """æ›´æ–°æœåŠ¡"""
        service_containers = self.services.get(service_name, [])
        if not service_containers:
            return False
            
        # åˆ›å»ºæ–°å®¹å™¨
        new_containers = self.create_service(service_name, new_config, len(service_containers))
        
        if len(new_containers) == len(service_containers):
            # åœæ­¢æ—§å®¹å™¨
            for container_id in service_containers:
                self._remove_container(container_id)
                
            # æ›´æ–°æœåŠ¡åˆ—è¡¨
            self.services[service_name] = new_containers
            return True
            
        return False
        
    def _select_node(self, resource_limits: List[ResourceLimit]) -> Optional[str]:
        """é€‰æ‹©èŠ‚ç‚¹"""
        if self.scheduling_policy == "round_robin":
            return self._round_robin_select()
        elif self.scheduling_policy == "least_loaded":
            return self._least_loaded_select(resource_limits)
        else:
            return self._random_select()
            
    def _round_robin_select(self) -> Optional[str]:
        """è½®è¯¢é€‰æ‹©"""
        available_nodes = [
            node_id for node_id, node_info in self.nodes.items()
            if self._has_capacity(node_id)
        ]
        
        if not available_nodes:
            return None
            
        # ç®€å•çš„è½®è¯¢å®ç°
        return available_nodes[hash(time.time()) % len(available_nodes)]
        
    def _least_loaded_select(self, resource_limits: List[ResourceLimit]) -> Optional[str]:
        """æœ€å°‘è´Ÿè½½é€‰æ‹©"""
        best_node = None
        min_load = float('inf')
        
        for node_id, node_info in self.nodes.items():
            if not self._has_capacity(node_id, resource_limits):
                continue
                
            # è®¡ç®—è´Ÿè½½
            load = sum(
                node_info["used_resources"].get(limit.resource_type.value, 0) / 
                node_info["capacity"].get(limit.resource_type.value, 1)
                for limit in resource_limits
            )
            
            if load < min_load:
                min_load = load
                best_node = node_id
                
        return best_node
        
    def _random_select(self) -> Optional[str]:
        """éšæœºé€‰æ‹©"""
        import random
        available_nodes = [
            node_id for node_id, node_info in self.nodes.items()
            if self._has_capacity(node_id)
        ]
        
        return random.choice(available_nodes) if available_nodes else None
        
    def _has_capacity(self, node_id: str, resource_limits: List[ResourceLimit] = None) -> bool:
        """æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æœ‰è¶³å¤Ÿå®¹é‡"""
        node_info = self.nodes[node_id]
        
        if resource_limits is None:
            return True
            
        for limit in resource_limits:
            used = node_info["used_resources"].get(limit.resource_type.value, 0)
            capacity = node_info["capacity"].get(limit.resource_type.value, 0)
            
            if used + limit.request > capacity:
                return False
                
        return True
        
    def _allocate_resources(self, node_id: str, resource_limits: List[ResourceLimit]) -> None:
        """åˆ†é…èµ„æº"""
        node_info = self.nodes[node_id]
        
        for limit in resource_limits:
            resource_key = limit.resource_type.value
            node_info["used_resources"][resource_key] += limit.request
            
    def _deallocate_resources(self, node_id: str, resource_limits: List[ResourceLimit]) -> None:
        """é‡Šæ”¾èµ„æº"""
        node_info = self.nodes[node_id]
        
        for limit in resource_limits:
            resource_key = limit.resource_type.value
            node_info["used_resources"][resource_key] -= limit.request
            
    def _remove_container(self, container_id: str) -> None:
        """ç§»é™¤å®¹å™¨"""
        if container_id in self.containers:
            container = self.containers[container_id]
            
            # åœæ­¢å¹¶åˆ é™¤å®¹å™¨
            container.stop()
            container.remove()
            
            # é‡Šæ”¾èµ„æº
            self._deallocate_resources(container_id, container.config.resource_limits)
            
            # ä»èŠ‚ç‚¹ä¸­ç§»é™¤
            for node_info in self.nodes.values():
                node_info["containers"].discard(container_id)
                
            del self.containers[container_id]
            
    def _get_service_config(self, service_name: str) -> Optional[ContainerConfig]:
        """è·å–æœåŠ¡é…ç½®"""
        service_containers = self.services.get(service_name, [])
        if service_containers:
            container_id = service_containers[0]
            if container_id in self.containers:
                return self.containers[container_id].config
        return None
```

### 2.3 æœåŠ¡ç½‘æ ¼

```python
@dataclass
class ServiceMeshConfig:
    """æœåŠ¡ç½‘æ ¼é…ç½®"""
    service_name: str
    version: str
    endpoints: List[str]
    load_balancer: str = "round_robin"
    circuit_breaker: bool = True
    retry_policy: Dict[str, Any] = field(default_factory=dict)
    timeout: float = 30.0

class ServiceMesh:
    """æœåŠ¡ç½‘æ ¼"""
    
    def __init__(self):
        self.services: Dict[str, ServiceMeshConfig] = {}
        self.routes: Dict[str, List[str]] = defaultdict(list)
        self.circuit_breakers: Dict[str, Dict[str, Any]] = defaultdict(dict)
        
    def register_service(self, config: ServiceMeshConfig) -> None:
        """æ³¨å†ŒæœåŠ¡"""
        service_key = f"{config.service_name}-{config.version}"
        self.services[service_key] = config
        
        # åˆå§‹åŒ–æ–­è·¯å™¨
        if config.circuit_breaker:
            self.circuit_breakers[service_key] = {
                "failures": 0,
                "successes": 0,
                "state": "closed",  # closed, open, half-open
                "threshold": 5,
                "timeout": 60.0,
                "last_failure_time": 0
            }
            
    def route_request(self, service_name: str, request_data: Any) -> Optional[Any]:
        """è·¯ç”±è¯·æ±‚"""
        # æŸ¥æ‰¾å¯ç”¨ç‰ˆæœ¬
        available_versions = []
        for service_key, config in self.services.items():
            if config.service_name == service_name:
                if self._is_service_available(service_key):
                    available_versions.append(service_key)
                    
        if not available_versions:
            return None
            
        # é€‰æ‹©ç‰ˆæœ¬
        selected_version = self._select_version(available_versions)
        
        # æ£€æŸ¥æ–­è·¯å™¨
        if not self._check_circuit_breaker(selected_version):
            return None
            
        # å‘é€è¯·æ±‚
        try:
            result = self._send_request(selected_version, request_data)
            self._record_success(selected_version)
            return result
        except Exception as e:
            self._record_failure(selected_version)
            raise e
            
    def _is_service_available(self, service_key: str) -> bool:
        """æ£€æŸ¥æœåŠ¡æ˜¯å¦å¯ç”¨"""
        config = self.services.get(service_key)
        if not config:
            return False
            
        # æ£€æŸ¥ç«¯ç‚¹å¯ç”¨æ€§
        for endpoint in config.endpoints:
            if self._check_endpoint_health(endpoint):
                return True
        return False
        
    def _select_version(self, available_versions: List[str]) -> str:
        """é€‰æ‹©ç‰ˆæœ¬"""
        # ç®€å•çš„è½®è¯¢é€‰æ‹©
        return available_versions[hash(time.time()) % len(available_versions)]
        
    def _check_circuit_breaker(self, service_key: str) -> bool:
        """æ£€æŸ¥æ–­è·¯å™¨"""
        breaker = self.circuit_breakers.get(service_key)
        if not breaker:
            return True
            
        if breaker["state"] == "open":
            # æ£€æŸ¥æ˜¯å¦åº”è¯¥å°è¯•åŠå¼€
            if time.time() - breaker["last_failure_time"] > breaker["timeout"]:
                breaker["state"] = "half-open"
                return True
            return False
        elif breaker["state"] == "half-open":
            return True
        else:  # closed
            return True
            
    def _record_success(self, service_key: str) -> None:
        """è®°å½•æˆåŠŸ"""
        breaker = self.circuit_breakers.get(service_key)
        if breaker:
            breaker["successes"] += 1
            breaker["failures"] = 0
            
            if breaker["state"] == "half-open":
                breaker["state"] = "closed"
                
    def _record_failure(self, service_key: str) -> None:
        """è®°å½•å¤±è´¥"""
        breaker = self.circuit_breakers.get(service_key)
        if breaker:
            breaker["failures"] += 1
            breaker["last_failure_time"] = time.time()
            
            if breaker["failures"] >= breaker["threshold"]:
                breaker["state"] = "open"
                
    def _check_endpoint_health(self, endpoint: str) -> bool:
        """æ£€æŸ¥ç«¯ç‚¹å¥åº·çŠ¶æ€"""
        # ç®€åŒ–çš„å¥åº·æ£€æŸ¥
        try:
            import requests
            response = requests.get(f"{endpoint}/health", timeout=5)
            return response.status_code == 200
        except:
            return False
            
    def _send_request(self, service_key: str, request_data: Any) -> Any:
        """å‘é€è¯·æ±‚"""
        config = self.services[service_key]
        
        # é€‰æ‹©ç«¯ç‚¹
        endpoint = config.endpoints[hash(time.time()) % len(config.endpoints)]
        
        # å‘é€è¯·æ±‚
        import requests
        response = requests.post(
            f"{endpoint}/api",
            json=request_data,
            timeout=config.timeout
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Request failed with status {response.status_code}")
```

## 3. ç†è®ºè¯æ˜

### 3.1 å®¹å™¨éš”ç¦»æ€§

**å®šç† 3.1** (å®¹å™¨éš”ç¦»æ€§)
å¯¹äºä»»æ„ä¸¤ä¸ªå®¹å™¨ $c_1, c_2$ï¼Œå®ƒä»¬çš„èµ„æºä½¿ç”¨æ˜¯ç›¸äº’éš”ç¦»çš„ã€‚

**è¯æ˜**:

1. å®¹å™¨é€šè¿‡å‘½åç©ºé—´å®ç°èµ„æºéš”ç¦»
2. æ¯ä¸ªå®¹å™¨æœ‰ç‹¬ç«‹çš„æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œå’Œè¿›ç¨‹ç©ºé—´
3. èµ„æºé™åˆ¶é€šè¿‡cgroupså®ç°
4. å› æ­¤å®¹å™¨é—´èµ„æºä½¿ç”¨ç›¸äº’ç‹¬ç«‹

### 3.2 æœåŠ¡å‘ç°æ­£ç¡®æ€§

**å®šç† 3.2** (æœåŠ¡å‘ç°æ­£ç¡®æ€§)
æœåŠ¡ç½‘æ ¼èƒ½å¤Ÿæ­£ç¡®è·¯ç”±è¯·æ±‚åˆ°å¯ç”¨çš„æœåŠ¡å®ä¾‹ã€‚

**è¯æ˜**:

1. æœåŠ¡æ³¨å†Œæ—¶è®°å½•æ‰€æœ‰ç«¯ç‚¹
2. å¥åº·æ£€æŸ¥ç¡®ä¿ç«¯ç‚¹å¯ç”¨æ€§
3. è´Ÿè½½å‡è¡¡ç®—æ³•é€‰æ‹©åˆé€‚ç«¯ç‚¹
4. å› æ­¤è¯·æ±‚èƒ½å¤Ÿæ­£ç¡®è·¯ç”±

## 4. æ€§èƒ½åˆ†æ

### 4.1 å®¹å™¨æ€§èƒ½

- å¯åŠ¨æ—¶é—´: $O(1)$ (ç›¸æ¯”è™šæ‹Ÿæœº)
- èµ„æºå¼€é”€: $O(1)$ (å…±äº«å†…æ ¸)
- ç½‘ç»œæ€§èƒ½: $O(1)$ (ç›´æ¥ç½‘ç»œ)

### 4.2 ç¼–æ’æ€§èƒ½

- è°ƒåº¦æ—¶é—´: $O(n \log n)$ (nä¸ºèŠ‚ç‚¹æ•°)
- æ‰©å±•æ—¶é—´: $O(r)$ (rä¸ºå‰¯æœ¬æ•°)
- æ•…éšœæ¢å¤: $O(1)$ (è‡ªåŠ¨é‡å¯)

### 4.3 æœåŠ¡ç½‘æ ¼æ€§èƒ½

- è·¯ç”±å¼€é”€: $O(1)$
- æ–­è·¯å™¨å¼€é”€: $O(1)$
- ç›‘æ§å¼€é”€: $O(1)$

## 5. å®é™…åº”ç”¨

### 5.1 Kuberneteséƒ¨ç½²

```python
class KubernetesDeployment:
    """Kuberneteséƒ¨ç½²"""
    
    def __init__(self, namespace: str = "default"):
        self.namespace = namespace
        self.deployments: Dict[str, Dict[str, Any]] = {}
        self.services: Dict[str, Dict[str, Any]] = {}
        
    def create_deployment(self, name: str, image: str, replicas: int = 1) -> bool:
        """åˆ›å»ºéƒ¨ç½²"""
        deployment = {
            "apiVersion": "apps/v1",
            "kind": "Deployment",
            "metadata": {
                "name": name,
                "namespace": self.namespace
            },
            "spec": {
                "replicas": replicas,
                "selector": {
                    "matchLabels": {
                        "app": name
                    }
                },
                "template": {
                    "metadata": {
                        "labels": {
                            "app": name
                        }
                    },
                    "spec": {
                        "containers": [
                            {
                                "name": name,
                                "image": image,
                                "ports": [
                                    {
                                        "containerPort": 80
                                    }
                                ]
                            }
                        ]
                    }
                }
            }
        }
        
        self.deployments[name] = deployment
        return True
        
    def create_service(self, name: str, deployment_name: str, port: int = 80) -> bool:
        """åˆ›å»ºæœåŠ¡"""
        service = {
            "apiVersion": "v1",
            "kind": "Service",
            "metadata": {
                "name": name,
                "namespace": self.namespace
            },
            "spec": {
                "selector": {
                    "app": deployment_name
                },
                "ports": [
                    {
                        "protocol": "TCP",
                        "port": port,
                        "targetPort": port
                    }
                ],
                "type": "ClusterIP"
            }
        }
        
        self.services[name] = service
        return True
        
    def scale_deployment(self, name: str, replicas: int) -> bool:
        """æ‰©ç¼©å®¹éƒ¨ç½²"""
        if name in self.deployments:
            self.deployments[name]["spec"]["replicas"] = replicas
            return True
        return False
```

### 5.2 æŒç»­éƒ¨ç½²æµæ°´çº¿

```python
class CI_CD_Pipeline:
    """æŒç»­é›†æˆ/æŒç»­éƒ¨ç½²æµæ°´çº¿"""
    
    def __init__(self):
        self.stages: List[str] = ["build", "test", "deploy"]
        self.current_stage = 0
        self.build_artifacts: Dict[str, Any] = {}
        
    def run_pipeline(self, source_code: str, config: Dict[str, Any]) -> bool:
        """è¿è¡Œæµæ°´çº¿"""
        try:
            # æ„å»ºé˜¶æ®µ
            if not self._build_stage(source_code, config):
                return False
                
            # æµ‹è¯•é˜¶æ®µ
            if not self._test_stage(config):
                return False
                
            # éƒ¨ç½²é˜¶æ®µ
            if not self._deploy_stage(config):
                return False
                
            return True
            
        except Exception as e:
            print(f"æµæ°´çº¿å¤±è´¥: {str(e)}")
            return False
            
    def _build_stage(self, source_code: str, config: Dict[str, Any]) -> bool:
        """æ„å»ºé˜¶æ®µ"""
        print("å¼€å§‹æ„å»º...")
        
        # æ„å»ºDockeré•œåƒ
        image_name = config.get("image_name", "app")
        image_tag = config.get("image_tag", "latest")
        
        # æ¨¡æ‹Ÿæ„å»ºè¿‡ç¨‹
        import time
        time.sleep(2)
        
        self.build_artifacts["image"] = f"{image_name}:{image_tag}"
        print(f"æ„å»ºå®Œæˆ: {self.build_artifacts['image']}")
        return True
        
    def _test_stage(self, config: Dict[str, Any]) -> bool:
        """æµ‹è¯•é˜¶æ®µ"""
        print("å¼€å§‹æµ‹è¯•...")
        
        # è¿è¡Œå•å…ƒæµ‹è¯•
        test_results = self._run_unit_tests()
        
        # è¿è¡Œé›†æˆæµ‹è¯•
        integration_results = self._run_integration_tests()
        
        # æ£€æŸ¥æµ‹è¯•ç»“æœ
        if test_results and integration_results:
            print("æµ‹è¯•é€šè¿‡")
            return True
        else:
            print("æµ‹è¯•å¤±è´¥")
            return False
            
    def _deploy_stage(self, config: Dict[str, Any]) -> bool:
        """éƒ¨ç½²é˜¶æ®µ"""
        print("å¼€å§‹éƒ¨ç½²...")
        
        # éƒ¨ç½²åˆ°Kubernetes
        deployment_name = config.get("deployment_name", "app")
        replicas = config.get("replicas", 3)
        
        k8s = KubernetesDeployment()
        success = k8s.create_deployment(
            deployment_name,
            self.build_artifacts["image"],
            replicas
        )
        
        if success:
            print("éƒ¨ç½²æˆåŠŸ")
            return True
        else:
            print("éƒ¨ç½²å¤±è´¥")
            return False
            
    def _run_unit_tests(self) -> bool:
        """è¿è¡Œå•å…ƒæµ‹è¯•"""
        # æ¨¡æ‹Ÿå•å…ƒæµ‹è¯•
        import random
        return random.random() > 0.1  # 90%æˆåŠŸç‡
        
    def _run_integration_tests(self) -> bool:
        """è¿è¡Œé›†æˆæµ‹è¯•"""
        # æ¨¡æ‹Ÿé›†æˆæµ‹è¯•
        import random
        return random.random() > 0.05  # 95%æˆåŠŸç‡
```

## 6. æ€»ç»“

äº‘åŸç”Ÿæ¶æ„åŸºç¡€æä¾›äº†æ„å»ºç°ä»£åŒ–åº”ç”¨ç¨‹åºçš„å®Œæ•´æ¡†æ¶ã€‚é€šè¿‡å®¹å™¨åŒ–ã€ç¼–æ’ã€æœåŠ¡ç½‘æ ¼å’ŒæŒç»­éƒ¨ç½²ï¼Œå®ç°äº†é«˜å¯ç”¨æ€§ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

### å…³é”®è¦ç‚¹

1. **å®¹å™¨åŒ–**: è½»é‡çº§ã€å¯ç§»æ¤çš„åº”ç”¨æ‰“åŒ…æ–¹å¼
2. **ç¼–æ’**: è‡ªåŠ¨åŒ–å®¹å™¨éƒ¨ç½²ã€æ‰©å±•å’Œç®¡ç†
3. **æœåŠ¡ç½‘æ ¼**: æœåŠ¡é—´é€šä¿¡çš„é€æ˜åŒ–ç®¡ç†
4. **æŒç»­éƒ¨ç½²**: è‡ªåŠ¨åŒ–è½¯ä»¶äº¤ä»˜æµç¨‹

### åº”ç”¨åœºæ™¯

- å¾®æœåŠ¡æ¶æ„
- äº‘åŸç”Ÿåº”ç”¨
- å¤§è§„æ¨¡åˆ†å¸ƒå¼ç³»ç»Ÿ
- DevOpså®è·µ

---

**ç›¸å…³æ–‡æ¡£**:

- [å¾®æœåŠ¡æ¶æ„åŸºç¡€](../05-01-å¾®æœåŠ¡æ¶æ„/05-01-01-å¾®æœåŠ¡åŸºç¡€.md)
- [åˆ†å¸ƒå¼æ¶æ„åŸºç¡€](../05-02-åˆ†å¸ƒå¼æ¶æ„/05-02-01-åˆ†å¸ƒå¼æ¶æ„åŸºç¡€.md)
- [å®¹å™¨ç¼–æ’æŠ€æœ¯](../05-03-äº‘åŸç”Ÿæ¶æ„/05-03-02-å®¹å™¨ç¼–æ’.md)
