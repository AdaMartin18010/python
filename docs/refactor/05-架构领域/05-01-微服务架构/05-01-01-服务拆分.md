# å¾®æœåŠ¡æ¶æ„ï¼šæœåŠ¡æ‹†åˆ†ç†è®º

## ğŸ“‹ æ¦‚è¿°

æœåŠ¡æ‹†åˆ†æ˜¯å¾®æœåŠ¡æ¶æ„è®¾è®¡çš„æ ¸å¿ƒé—®é¢˜ï¼Œæ¶‰åŠå¦‚ä½•å°†ä¸€ä¸ªå•ä½“åº”ç”¨åˆ†è§£ä¸ºå¤šä¸ªç‹¬ç«‹çš„å¾®æœåŠ¡ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†ææœåŠ¡æ‹†åˆ†çš„ç†è®ºåŸºç¡€ã€è®¾è®¡åŸåˆ™å’Œå®ç°æ–¹æ³•ã€‚

## 1. æ¦‚å¿µåŸºç¡€

### 1.1 æœåŠ¡æ‹†åˆ†å®šä¹‰

**æœåŠ¡æ‹†åˆ†**æ˜¯å°†ä¸€ä¸ªå¤§å‹è½¯ä»¶ç³»ç»Ÿåˆ†è§£ä¸ºå¤šä¸ªç›¸å¯¹ç‹¬ç«‹ã€å¯ç‹¬ç«‹éƒ¨ç½²å’Œæ‰©å±•çš„æœåŠ¡çš„è¿‡ç¨‹ã€‚

#### å½¢å¼åŒ–å®šä¹‰

è®¾ $S$ ä¸ºåŸå§‹ç³»ç»Ÿï¼Œ$S = \{c_1, c_2, ..., c_n\}$ å…¶ä¸­ $c_i$ ä¸ºç³»ç»Ÿç»„ä»¶ã€‚

æœåŠ¡æ‹†åˆ†å‡½æ•° $Split: S \rightarrow \{S_1, S_2, ..., S_m\}$ æ»¡è¶³ï¼š

1. **å®Œæ•´æ€§**: $\bigcup_{i=1}^{m} S_i = S$
2. **äº’æ–¥æ€§**: $\forall i \neq j, S_i \cap S_j = \emptyset$
3. **ç‹¬ç«‹æ€§**: $\forall i, S_i$ å¯ç‹¬ç«‹éƒ¨ç½²å’Œè¿è¡Œ

### 1.2 æœåŠ¡æ‹†åˆ†ç›®æ ‡

#### 1.2.1 å†…èšæ€§æœ€å¤§åŒ–

å†…èšæ€§åº¦é‡æœåŠ¡å†…éƒ¨ç»„ä»¶é—´çš„å…³è”å¼ºåº¦ï¼š

$$Cohesion(S_i) = \frac{\sum_{c_j, c_k \in S_i} Coupling(c_j, c_k)}{|S_i| \times (|S_i| - 1) / 2}$$

å…¶ä¸­ $Coupling(c_j, c_k)$ è¡¨ç¤ºç»„ä»¶ $c_j$ å’Œ $c_k$ é—´çš„è€¦åˆåº¦ã€‚

#### 1.2.2 è€¦åˆæ€§æœ€å°åŒ–

è€¦åˆæ€§åº¦é‡æœåŠ¡é—´çš„ä¾èµ–å¼ºåº¦ï¼š

$$Coupling(S_i, S_j) = \sum_{c_p \in S_i, c_q \in S_j} Coupling(c_p, c_q)$$

#### 1.2.3 æ‹†åˆ†è´¨é‡å‡½æ•°

$$Quality(Split) = \alpha \cdot \sum_{i=1}^{m} Cohesion(S_i) - \beta \cdot \sum_{i \neq j} Coupling(S_i, S_j)$$

å…¶ä¸­ $\alpha, \beta$ ä¸ºæƒé‡ç³»æ•°ã€‚

## 2. æœåŠ¡æ‹†åˆ†ç­–ç•¥

### 2.1 åŸºäºä¸šåŠ¡é¢†åŸŸçš„æ‹†åˆ†

#### 2.1.1 é¢†åŸŸé©±åŠ¨è®¾è®¡ (DDD)

**å®šä¹‰**: æ ¹æ®ä¸šåŠ¡é¢†åŸŸè¾¹ç•Œè¿›è¡ŒæœåŠ¡æ‹†åˆ†ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:

è®¾ $D = \{d_1, d_2, ..., d_k\}$ ä¸ºä¸šåŠ¡é¢†åŸŸé›†åˆï¼Œæ¯ä¸ªé¢†åŸŸ $d_i$ åŒ…å«ï¼š

- **å®ä½“** (Entities): $E_i = \{e_1, e_2, ...\}$
- **å€¼å¯¹è±¡** (Value Objects): $V_i = \{v_1, v_2, ...\}$
- **æœåŠ¡** (Services): $S_i = \{s_1, s_2, ...\}$
- **èšåˆ** (Aggregates): $A_i = \{a_1, a_2, ...\}$

æœåŠ¡æ‹†åˆ†å‡½æ•°ï¼š
$$Split_{DDD}(S) = \{Service(d_i) | d_i \in D\}$$

å…¶ä¸­ $Service(d_i) = E_i \cup V_i \cup S_i \cup A_i$

### 2.2 åŸºäºæŠ€æœ¯æ¶æ„çš„æ‹†åˆ†

#### 2.2.1 åˆ†å±‚æ¶æ„æ‹†åˆ†

**å®šä¹‰**: æŒ‰ç…§æŠ€æœ¯å±‚æ¬¡è¿›è¡ŒæœåŠ¡æ‹†åˆ†ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:

è®¾ $L = \{l_1, l_2, ..., l_p\}$ ä¸ºæŠ€æœ¯å±‚æ¬¡é›†åˆï¼Œæ¯ä¸ªå±‚æ¬¡ $l_i$ åŒ…å«ï¼š

$$Layer(l_i) = \{c_j | Technology(c_j) = l_i\}$$

æœåŠ¡æ‹†åˆ†å‡½æ•°ï¼š
$$Split_{Layer}(S) = \{Layer(l_i) | l_i \in L\}$$

## 3. æœåŠ¡æ‹†åˆ†ç®—æ³•

### 3.1 è´ªå¿ƒç®—æ³•

#### 3.1.1 ç®—æ³•æè¿°

```python
def greedy_service_split(system: System) -> List[Service]:
    """
    è´ªå¿ƒæœåŠ¡æ‹†åˆ†ç®—æ³•
    
    Args:
        system: åŸå§‹ç³»ç»Ÿ
        
    Returns:
        æ‹†åˆ†åçš„æœåŠ¡åˆ—è¡¨
    """
    services = []
    remaining_components = set(system.components)
    
    while remaining_components:
        # é€‰æ‹©å†…èšæ€§æœ€é«˜çš„ç»„ä»¶ç»„åˆ
        best_service = find_best_service(remaining_components)
        services.append(best_service)
        remaining_components -= set(best_service.components)
    
    return services
```

#### 3.1.2 å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**: $O(n^3)$ å…¶ä¸­ $n$ ä¸ºç»„ä»¶æ•°é‡
- **ç©ºé—´å¤æ‚åº¦**: $O(n^2)$
- **è¿‘ä¼¼æ¯”**: æ— æ³•ä¿è¯æœ€ä¼˜è§£

### 3.2 èšç±»ç®—æ³•

#### 3.2.1 K-Meansèšç±»

**ç®—æ³•æ­¥éª¤**:

1. åˆå§‹åŒ– $k$ ä¸ªèšç±»ä¸­å¿ƒ
2. å°†æ¯ä¸ªç»„ä»¶åˆ†é…åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
3. é‡æ–°è®¡ç®—èšç±»ä¸­å¿ƒ
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°æ”¶æ•›

**å½¢å¼åŒ–è¡¨ç¤º**:

è®¾ $C = \{c_1, c_2, ..., c_n\}$ ä¸ºç»„ä»¶é›†åˆï¼Œ$K$ ä¸ºæœåŠ¡æ•°é‡ã€‚

èšç±»ç›®æ ‡å‡½æ•°ï¼š
$$J = \sum_{i=1}^{K} \sum_{c_j \in S_i} \|c_j - \mu_i\|^2$$

å…¶ä¸­ $\mu_i$ ä¸ºèšç±» $S_i$ çš„ä¸­å¿ƒã€‚

## 4. Pythonå®ç°

### 4.1 æœåŠ¡æ‹†åˆ†æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Set, Dict, Tuple
import numpy as np
from enum import Enum

class ComponentType(Enum):
    """ç»„ä»¶ç±»å‹æšä¸¾"""
    ENTITY = "entity"
    SERVICE = "service"
    REPOSITORY = "repository"
    CONTROLLER = "controller"

@dataclass
class Component:
    """ç³»ç»Ÿç»„ä»¶"""
    id: str
    name: str
    type: ComponentType
    dependencies: Set[str]
    data_entities: Set[str]
    functions: Set[str]
    
    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = set()
        if self.data_entities is None:
            self.data_entities = set()
        if self.functions is None:
            self.functions = set()

@dataclass
class Service:
    """å¾®æœåŠ¡"""
    id: str
    name: str
    components: Set[Component]
    interfaces: Dict[str, str]
    
    def __post_init__(self):
        if self.components is None:
            self.components = set()
        if self.interfaces is None:
            self.interfaces = {}

@dataclass
class System:
    """ç³»ç»Ÿå®šä¹‰"""
    components: List[Component]
    dependencies: Dict[Tuple[str, str], float]
    
    def __post_init__(self):
        if self.components is None:
            self.components = []
        if self.dependencies is None:
            self.dependencies = {}

class ServiceSplitter(ABC):
    """æœåŠ¡æ‹†åˆ†å™¨æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def split(self, system: System) -> List[Service]:
        """æ‰§è¡ŒæœåŠ¡æ‹†åˆ†"""
        pass
    
    def calculate_cohesion(self, components: Set[Component]) -> float:
        """è®¡ç®—å†…èšæ€§"""
        if len(components) <= 1:
            return 1.0
        
        total_coupling = 0
        total_pairs = 0
        
        component_list = list(components)
        for i in range(len(component_list)):
            for j in range(i + 1, len(component_list)):
                comp1, comp2 = component_list[i], component_list[j]
                coupling = self._calculate_component_coupling(comp1, comp2)
                total_coupling += coupling
                total_pairs += 1
        
        return total_coupling / total_pairs if total_pairs > 0 else 0.0
    
    def calculate_coupling(self, service1: Service, service2: Service) -> float:
        """è®¡ç®—æœåŠ¡é—´è€¦åˆæ€§"""
        total_coupling = 0
        
        for comp1 in service1.components:
            for comp2 in service2.components:
                coupling = self._calculate_component_coupling(comp1, comp2)
                total_coupling += coupling
        
        return total_coupling
    
    def _calculate_component_coupling(self, comp1: Component, comp2: Component) -> float:
        """è®¡ç®—ç»„ä»¶é—´è€¦åˆæ€§"""
        # ä¾èµ–å…³ç³»è€¦åˆ
        dependency_coupling = 0
        if comp2.id in comp1.dependencies:
            dependency_coupling = 1.0
        
        # æ•°æ®è€¦åˆ
        shared_data = comp1.data_entities & comp2.data_entities
        data_coupling = len(shared_data) / max(len(comp1.data_entities), len(comp2.data_entities), 1)
        
        # åŠŸèƒ½è€¦åˆ
        shared_functions = comp1.functions & comp2.functions
        function_coupling = len(shared_functions) / max(len(comp1.functions), len(comp2.functions), 1)
        
        return dependency_coupling * 0.5 + data_coupling * 0.3 + function_coupling * 0.2
```

### 4.2 è´ªå¿ƒæ‹†åˆ†ç®—æ³•å®ç°

```python
class GreedyServiceSplitter(ServiceSplitter):
    """è´ªå¿ƒæœåŠ¡æ‹†åˆ†ç®—æ³•"""
    
    def __init__(self, max_services: int = 10, min_cohesion: float = 0.3):
        self.max_services = max_services
        self.min_cohesion = min_cohesion
    
    def split(self, system: System) -> List[Service]:
        """æ‰§è¡Œè´ªå¿ƒæœåŠ¡æ‹†åˆ†"""
        services = []
        remaining_components = set(system.components)
        
        while remaining_components and len(services) < self.max_services:
            # æ‰¾åˆ°æœ€ä½³æœåŠ¡ç»„åˆ
            best_service_components = self._find_best_service(remaining_components)
            
            if not best_service_components:
                break
            
            # åˆ›å»ºæœåŠ¡
            service = self._create_service(best_service_components, len(services))
            services.append(service)
            
            # ç§»é™¤å·²åˆ†é…çš„ç»„ä»¶
            remaining_components -= best_service_components
        
        # å¤„ç†å‰©ä½™ç»„ä»¶
        if remaining_components:
            service = self._create_service(remaining_components, len(services))
            services.append(service)
        
        return services
    
    def _find_best_service(self, components: Set[Component]) -> Set[Component]:
        """æ‰¾åˆ°æœ€ä½³æœåŠ¡ç»„ä»¶ç»„åˆ"""
        best_service = set()
        best_score = 0
        
        # å°è¯•ä¸åŒçš„ç»„ä»¶ç»„åˆ
        for size in range(1, min(len(components) + 1, 10)):
            for component_subset in self._get_component_subsets(components, size):
                cohesion = self.calculate_cohesion(component_subset)
                
                if cohesion >= self.min_cohesion and cohesion > best_score:
                    best_score = cohesion
                    best_service = component_subset
        
        return best_service
    
    def _get_component_subsets(self, components: Set[Component], size: int) -> List[Set[Component]]:
        """è·å–æŒ‡å®šå¤§å°çš„ç»„ä»¶å­é›†"""
        components_list = list(components)
        subsets = []
        
        def backtrack(start: int, current: Set[Component]):
            if len(current) == size:
                subsets.append(current.copy())
                return
            
            for i in range(start, len(components_list)):
                current.add(components_list[i])
                backtrack(i + 1, current)
                current.remove(components_list[i])
        
        backtrack(0, set())
        return subsets
    
    def _create_service(self, components: Set[Component], service_id: int) -> Service:
        """åˆ›å»ºæœåŠ¡"""
        service_name = f"service_{service_id}"
        interfaces = self._extract_interfaces(components)
        
        return Service(
            id=f"svc_{service_id}",
            name=service_name,
            components=components,
            interfaces=interfaces
        )
    
    def _extract_interfaces(self, components: Set[Component]) -> Dict[str, str]:
        """æå–æœåŠ¡æ¥å£"""
        interfaces = {}
        
        for component in components:
            if component.type == ComponentType.CONTROLLER:
                for function in component.functions:
                    interfaces[function] = f"POST /api/{function}"
        
        return interfaces
```

## 5. å®é™…åº”ç”¨ç¤ºä¾‹

### 5.1 ç”µå•†ç³»ç»ŸæœåŠ¡æ‹†åˆ†

```python
def create_ecommerce_system() -> System:
    """åˆ›å»ºç”µå•†ç³»ç»Ÿç¤ºä¾‹"""
    components = [
        # ç”¨æˆ·ç®¡ç†ç»„ä»¶
        Component(
            id="user_controller",
            name="UserController",
            type=ComponentType.CONTROLLER,
            dependencies={"user_service", "auth_service"},
            data_entities={"user", "profile"},
            functions={"register", "login", "update_profile"}
        ),
        Component(
            id="user_service",
            name="UserService",
            type=ComponentType.SERVICE,
            dependencies={"user_repository"},
            data_entities={"user", "profile"},
            functions={"create_user", "get_user", "update_user"}
        ),
        Component(
            id="user_repository",
            name="UserRepository",
            type=ComponentType.REPOSITORY,
            dependencies=set(),
            data_entities={"user", "profile"},
            functions={"save", "find_by_id", "find_by_email"}
        ),
        
        # å•†å“ç®¡ç†ç»„ä»¶
        Component(
            id="product_controller",
            name="ProductController",
            type=ComponentType.CONTROLLER,
            dependencies={"product_service"},
            data_entities={"product", "category"},
            functions={"create_product", "get_product", "list_products"}
        ),
        Component(
            id="product_service",
            name="ProductService",
            type=ComponentType.SERVICE,
            dependencies={"product_repository", "category_repository"},
            data_entities={"product", "category"},
            functions={"create_product", "get_product", "search_products"}
        ),
        Component(
            id="product_repository",
            name="ProductRepository",
            type=ComponentType.REPOSITORY,
            dependencies=set(),
            data_entities={"product"},
            functions={"save", "find_by_id", "find_by_category"}
        ),
        
        # è®¢å•ç®¡ç†ç»„ä»¶
        Component(
            id="order_controller",
            name="OrderController",
            type=ComponentType.CONTROLLER,
            dependencies={"order_service", "payment_service"},
            data_entities={"order", "order_item"},
            functions={"create_order", "get_order", "cancel_order"}
        ),
        Component(
            id="order_service",
            name="OrderService",
            type=ComponentType.SERVICE,
            dependencies={"order_repository", "product_service"},
            data_entities={"order", "order_item"},
            functions={"create_order", "get_order", "update_order_status"}
        ),
        Component(
            id="order_repository",
            name="OrderRepository",
            type=ComponentType.REPOSITORY,
            dependencies=set(),
            data_entities={"order", "order_item"},
            functions={"save", "find_by_id", "find_by_user"}
        ),
        
        # æ”¯ä»˜ç»„ä»¶
        Component(
            id="payment_controller",
            name="PaymentController",
            type=ComponentType.CONTROLLER,
            dependencies={"payment_service"},
            data_entities={"payment", "transaction"},
            functions={"process_payment", "get_payment_status"}
        ),
        Component(
            id="payment_service",
            name="PaymentService",
            type=ComponentType.SERVICE,
            dependencies={"payment_repository", "external_payment_gateway"},
            data_entities={"payment", "transaction"},
            functions={"process_payment", "refund", "get_transaction"}
        ),
        Component(
            id="payment_repository",
            name="PaymentRepository",
            type=ComponentType.REPOSITORY,
            dependencies=set(),
            data_entities={"payment", "transaction"},
            functions={"save", "find_by_id", "find_by_order"}
        ),
    ]
    
    # æ„å»ºä¾èµ–å…³ç³»
    dependencies = {
        ("user_controller", "user_service"): 0.8,
        ("user_controller", "auth_service"): 0.6,
        ("user_service", "user_repository"): 0.9,
        ("product_controller", "product_service"): 0.8,
        ("product_service", "product_repository"): 0.9,
        ("product_service", "category_repository"): 0.7,
        ("order_controller", "order_service"): 0.8,
        ("order_controller", "payment_service"): 0.6,
        ("order_service", "order_repository"): 0.9,
        ("order_service", "product_service"): 0.5,
        ("payment_controller", "payment_service"): 0.8,
        ("payment_service", "payment_repository"): 0.9,
    }
    
    return System(components=components, dependencies=dependencies)

def demonstrate_service_splitting():
    """æ¼”ç¤ºæœåŠ¡æ‹†åˆ†è¿‡ç¨‹"""
    # åˆ›å»ºç”µå•†ç³»ç»Ÿ
    system = create_ecommerce_system()
    
    print("=== ç”µå•†ç³»ç»ŸæœåŠ¡æ‹†åˆ†æ¼”ç¤º ===\n")
    
    # ä½¿ç”¨è´ªå¿ƒç®—æ³•æ‹†åˆ†
    print("1. è´ªå¿ƒç®—æ³•æ‹†åˆ†ç»“æœ:")
    greedy_splitter = GreedyServiceSplitter(max_services=5, min_cohesion=0.3)
    greedy_services = greedy_splitter.split(system)
    
    for i, service in enumerate(greedy_services):
        print(f"  æœåŠ¡ {i+1}: {service.name}")
        print(f"    ç»„ä»¶: {[comp.name for comp in service.components]}")
        print(f"    æ¥å£: {list(service.interfaces.keys())}")
        print()

if __name__ == "__main__":
    demonstrate_service_splitting()
```

## 6. æœ€ä½³å®è·µ

### 6.1 æ‹†åˆ†åŸåˆ™

1. **å•ä¸€èŒè´£åŸåˆ™**: æ¯ä¸ªæœåŠ¡åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡é¢†åŸŸ
2. **é«˜å†…èšä½è€¦åˆ**: æœåŠ¡å†…éƒ¨ç»„ä»¶ç´§å¯†ç›¸å…³ï¼ŒæœåŠ¡é—´ä¾èµ–æœ€å°
3. **æ•°æ®æ‰€æœ‰æƒ**: æ¯ä¸ªæœåŠ¡æ‹¥æœ‰è‡ªå·±çš„æ•°æ®ï¼Œé¿å…æ•°æ®å…±äº«
4. **æ¥å£è®¾è®¡**: è®¾è®¡æ¸…æ™°çš„APIæ¥å£ï¼Œéšè—å†…éƒ¨å®ç°ç»†èŠ‚

### 6.2 æ‹†åˆ†ç­–ç•¥

1. **ä¸šåŠ¡é©±åŠ¨**: ä¼˜å…ˆè€ƒè™‘ä¸šåŠ¡é¢†åŸŸè¾¹ç•Œ
2. **æŠ€æœ¯é©±åŠ¨**: è€ƒè™‘æŠ€æœ¯æ ˆå’Œå›¢é˜Ÿèƒ½åŠ›
3. **æ•°æ®é©±åŠ¨**: åˆ†ææ•°æ®è®¿é—®æ¨¡å¼å’Œä¾èµ–å…³ç³»
4. **æ¼”è¿›å¼æ‹†åˆ†**: é€æ­¥æ‹†åˆ†ï¼Œé¿å…ä¸€æ¬¡æ€§å¤§è§„æ¨¡é‡æ„

### 6.3 è¯„ä¼°æ ‡å‡†

1. **å†…èšæ€§**: æœåŠ¡å†…éƒ¨ç»„ä»¶å…³è”åº¦
2. **è€¦åˆæ€§**: æœåŠ¡é—´ä¾èµ–ç¨‹åº¦
3. **å¤æ‚åº¦**: æœåŠ¡å†…éƒ¨å¤æ‚åº¦
4. **å¯ç»´æŠ¤æ€§**: ä»£ç ç»´æŠ¤å’Œä¿®æ”¹çš„éš¾æ˜“ç¨‹åº¦
5. **å¯æ‰©å±•æ€§**: æœåŠ¡ç‹¬ç«‹æ‰©å±•çš„èƒ½åŠ›

## 7. æ€»ç»“

æœåŠ¡æ‹†åˆ†æ˜¯å¾®æœåŠ¡æ¶æ„è®¾è®¡çš„æ ¸å¿ƒé—®é¢˜ï¼Œéœ€è¦ç»¼åˆè€ƒè™‘ä¸šåŠ¡éœ€æ±‚ã€æŠ€æœ¯çº¦æŸå’Œç³»ç»Ÿç‰¹æ€§ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†æäº†æœåŠ¡æ‹†åˆ†çš„ç†è®ºåŸºç¡€ï¼Œæä¾›äº†å¤šç§æ‹†åˆ†ç®—æ³•å’Œè¯„ä¼°æ–¹æ³•ï¼Œå¹¶é€šè¿‡Pythonå®ç°å±•ç¤ºäº†å…·ä½“çš„åº”ç”¨ã€‚

### å…³é”®è¦ç‚¹

1. **ç†è®ºåŸºç¡€**: æœåŠ¡æ‹†åˆ†éœ€è¦ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œå½¢å¼åŒ–åˆ†æ
2. **ç®—æ³•é€‰æ‹©**: ä¸åŒç®—æ³•é€‚ç”¨äºä¸åŒåœºæ™¯ï¼Œéœ€è¦æ ¹æ®å…·ä½“æƒ…å†µé€‰æ‹©
3. **è´¨é‡è¯„ä¼°**: å»ºç«‹å®Œæ•´çš„è¯„ä¼°ä½“ç³»ï¼Œç¡®ä¿æ‹†åˆ†è´¨é‡
4. **å®è·µæŒ‡å¯¼**: æä¾›å…·ä½“çš„æœ€ä½³å®è·µå’ŒæŒ‡å¯¼åŸåˆ™

---

*æœ€åæ›´æ–°: 2024-12-19*
*æ–‡æ¡£çŠ¶æ€: å®Œæˆ*
