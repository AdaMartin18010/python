# 05-01-01 æœåŠ¡æ‹†åˆ†

## ðŸ“‹ æ¦‚è¿°

æœåŠ¡æ‹†åˆ†æ˜¯å¾®æœåŠ¡æž¶æž„è®¾è®¡çš„æ ¸å¿ƒï¼Œå°†å•ä½“åº”ç”¨åˆ†è§£ä¸ºå¤šä¸ªç‹¬ç«‹ã€å¯éƒ¨ç½²çš„æœåŠ¡ã€‚æœ¬æ–‡æ¡£ä»Žå½¢å¼åŒ–è§’åº¦å®šä¹‰æœåŠ¡æ‹†åˆ†ï¼Œå»ºç«‹å®Œæ•´çš„ç†è®ºä½“ç³»ï¼Œå¹¶æä¾›é«˜æ•ˆçš„Pythonå®žçŽ°ã€‚

## ðŸŽ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æœåŠ¡æ‹†åˆ†çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1** (å¾®æœåŠ¡ç³»ç»Ÿ)
å¾®æœåŠ¡ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$MS = (S, I, D, C, N)$$

å…¶ä¸­ï¼š

- $S$ ä¸ºæœåŠ¡é›†åˆ
- $I$ ä¸ºæŽ¥å£é›†åˆ
- $D$ ä¸ºä¾èµ–å…³ç³»ï¼š$D \subseteq S \times S$
- $C$ ä¸ºé€šä¿¡åè®®é›†åˆ
- $N$ ä¸ºç½‘ç»œæ‹“æ‰‘

**å®šä¹‰ 1.2** (æœåŠ¡)
æœåŠ¡æ˜¯ä¸€ä¸ªå…­å…ƒç»„ï¼š
$$s = (id, name, domain, api, data, config)$$

å…¶ä¸­ï¼š

- $id \in \mathbb{N}$ ä¸ºæœåŠ¡æ ‡è¯†
- $name \in \Sigma^*$ ä¸ºæœåŠ¡åç§°
- $domain \in \Sigma^*$ ä¸ºä¸šåŠ¡é¢†åŸŸ
- $api \subseteq I$ ä¸ºæœåŠ¡æŽ¥å£
- $data \subseteq \mathbb{D}$ ä¸ºæ•°æ®æ¨¡åž‹
- $config \subseteq \mathbb{C}$ ä¸ºé…ç½®ä¿¡æ¯

**å®šä¹‰ 1.3** (æœåŠ¡ä¾èµ–)
æœåŠ¡ä¾èµ–å…³ç³»å®šä¹‰ä¸ºï¼š
$$D(s_i, s_j) = \begin{cases}
1 & \text{if } s_i \text{ depends on } s_j \\
0 & \text{otherwise}
\end{cases}$$

#### 1.2 Pythonå®žçŽ°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import uuid
import json
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict
import asyncio
import aiohttp
import logging

class ServiceType(Enum):
    """æœåŠ¡ç±»åž‹"""
    API_GATEWAY = "api_gateway"
    BUSINESS_SERVICE = "business_service"
    DATA_SERVICE = "data_service"
    INFRASTRUCTURE_SERVICE = "infrastructure_service"

class CommunicationProtocol(Enum):
    """é€šä¿¡åè®®"""
    HTTP_REST = "http_rest"
    HTTP_GRAPHQL = "http_graphql"
    GRPC = "grpc"
    MESSAGE_QUEUE = "message_queue"
    EVENT_STREAM = "event_stream"

class ServiceStatus(Enum):
    """æœåŠ¡çŠ¶æ€"""
    RUNNING = "running"
    STOPPED = "stopped"
    STARTING = "starting"
    STOPPING = "stopping"
    ERROR = "error"

@dataclass
class ServiceInterface:
    """æœåŠ¡æŽ¥å£"""
    name: str
    method: str  # GET, POST, PUT, DELETE
    path: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    response_schema: Dict[str, Any] = field(default_factory=dict)

    def __str__(self) -> str:
        return f"{self.method} {self.path}"

@dataclass
class ServiceConfig:
    """æœåŠ¡é…ç½®"""
    port: int
    host: str = "localhost"
    protocol: CommunicationProtocol = CommunicationProtocol.HTTP_REST
    timeout: int = 30
    retry_count: int = 3
    circuit_breaker_enabled: bool = True
    load_balancer_enabled: bool = True

    def to_dict(self) -> Dict[str, Any]:
        return {
            'port': self.port,
            'host': self.host,
            'protocol': self.protocol.value,
            'timeout': self.timeout,
            'retry_count': self.retry_count,
            'circuit_breaker_enabled': self.circuit_breaker_enabled,
            'load_balancer_enabled': self.load_balancer_enabled
        }

@dataclass
class Service:
    """æœåŠ¡å®žä½“"""
    id: str
    name: str
    service_type: ServiceType
    domain: str
    interfaces: List[ServiceInterface] = field(default_factory=list)
    dependencies: Set[str] = field(default_factory=set)
    dependents: Set[str] = field(default_factory=set)
    config: ServiceConfig = field(default_factory=lambda: ServiceConfig(port=8080))
    status: ServiceStatus = ServiceStatus.STOPPED
    health_check_url: Optional[str] = None
    metrics: Dict[str, Any] = field(default_factory=dict)

    def __str__(self) -> str:
        return f"Service({self.name}, {self.domain})"

    def add_interface(self, interface: ServiceInterface) -> None:
        """æ·»åŠ æŽ¥å£"""
        self.interfaces.append(interface)

    def add_dependency(self, service_id: str) -> None:
        """æ·»åŠ ä¾èµ–"""
        self.dependencies.add(service_id)

    def remove_dependency(self, service_id: str) -> None:
        """ç§»é™¤ä¾èµ–"""
        self.dependencies.discard(service_id)

    def get_endpoint(self) -> str:
        """èŽ·å–æœåŠ¡ç«¯ç‚¹"""
        return f"http://{self.config.host}:{self.config.port}"

    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'id': self.id,
            'name': self.name,
            'service_type': self.service_type.value,
            'domain': self.domain,
            'interfaces': [str(interface) for interface in self.interfaces],
            'dependencies': list(self.dependencies),
            'config': self.config.to_dict(),
            'status': self.status.value,
            'health_check_url': self.health_check_url
        }

class ServiceRegistry:
    """æœåŠ¡æ³¨å†Œä¸­å¿ƒ"""

    def __init__(self):
        self.services: Dict[str, Service] = {}
        self.dependency_graph = nx.DiGraph()
        self.logger = logging.getLogger(__name__)

    def register_service(self, service: Service) -> None:
        """æ³¨å†ŒæœåŠ¡"""
        self.services[service.id] = service
        self.dependency_graph.add_node(service.id, service=service)
        self.logger.info(f"Registered service: {service}")

    def unregister_service(self, service_id: str) -> None:
        """æ³¨é”€æœåŠ¡"""
        if service_id in self.services:
            service = self.services[service_id]
            self.dependency_graph.remove_node(service_id)
            del self.services[service_id]
            self.logger.info(f"Unregistered service: {service}")

    def add_dependency(self, from_service_id: str, to_service_id: str) -> None:
        """æ·»åŠ æœåŠ¡ä¾èµ–"""
        if from_service_id in self.services and to_service_id in self.services:
            self.services[from_service_id].add_dependency(to_service_id)
            self.services[to_service_id].dependents.add(from_service_id)
            self.dependency_graph.add_edge(from_service_id, to_service_id)
            self.logger.info(f"Added dependency: {from_service_id} -> {to_service_id}")

    def remove_dependency(self, from_service_id: str, to_service_id: str) -> None:
        """ç§»é™¤æœåŠ¡ä¾èµ–"""
        if from_service_id in self.services and to_service_id in self.services:
            self.services[from_service_id].remove_dependency(to_service_id)
            self.services[to_service_id].dependents.discard(from_service_id)
            self.dependency_graph.remove_edge(from_service_id, to_service_id)
            self.logger.info(f"Removed dependency: {from_service_id} -> {to_service_id}")

    def get_service(self, service_id: str) -> Optional[Service]:
        """èŽ·å–æœåŠ¡"""
        return self.services.get(service_id)

    def get_services_by_domain(self, domain: str) -> List[Service]:
        """æ ¹æ®é¢†åŸŸèŽ·å–æœåŠ¡"""
        return [service for service in self.services.values() if service.domain == domain]

    def get_dependencies(self, service_id: str) -> Set[str]:
        """èŽ·å–æœåŠ¡ä¾èµ–"""
        service = self.get_service(service_id)
        return service.dependencies if service else set()

    def get_dependents(self, service_id: str) -> Set[str]:
        """èŽ·å–ä¾èµ–è¯¥æœåŠ¡çš„æœåŠ¡"""
        service = self.get_service(service_id)
        return service.dependents if service else set()

    def detect_circular_dependencies(self) -> List[List[str]]:
        """æ£€æµ‹å¾ªçŽ¯ä¾èµ–"""
        try:
            cycles = list(nx.simple_cycles(self.dependency_graph))
            return cycles
        except nx.NetworkXNoCycle:
            return []

    def get_topological_order(self) -> List[str]:
        """èŽ·å–æ‹“æ‰‘æŽ’åº"""
        try:
            return list(nx.topological_sort(self.dependency_graph))
        except nx.NetworkXError:
            return []

    def get_service_layers(self) -> Dict[int, List[str]]:
        """èŽ·å–æœåŠ¡åˆ†å±‚"""
        layers = defaultdict(list)
        in_degrees = dict(self.dependency_graph.in_degree())

        # æ‰¾åˆ°æ‰€æœ‰å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ï¼ˆç¬¬ä¸€å±‚ï¼‰
        current_layer = [node for node, degree in in_degrees.items() if degree == 0]
        layer_num = 0

        while current_layer:
            layers[layer_num] = current_layer

            # æ›´æ–°å…¥åº¦
            for node in current_layer:
                for neighbor in self.dependency_graph.successors(node):
                    in_degrees[neighbor] -= 1

            # æ‰¾åˆ°ä¸‹ä¸€å±‚
            current_layer = [node for node, degree in in_degrees.items() if degree == 0 and node not in layers[layer_num-1] if layer_num > 0 else True]
            layer_num += 1

        return dict(layers)

class ServiceSplitter:
    """æœåŠ¡æ‹†åˆ†å™¨"""

    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.logger = logging.getLogger(__name__)

    def split_by_domain(self, services: List[Service]) -> Dict[str, List[Service]]:
        """æŒ‰é¢†åŸŸæ‹†åˆ†æœåŠ¡"""
        domains = defaultdict(list)
        for service in services:
            domains[service.domain].append(service)
        return dict(domains)

    def split_by_bounded_context(self, services: List[Service], contexts: Dict[str, Set[str]]) -> Dict[str, List[Service]]:
        """æŒ‰é™ç•Œä¸Šä¸‹æ–‡æ‹†åˆ†æœåŠ¡"""
        context_services = defaultdict(list)

        for service in services:
            # æ‰¾åˆ°æœåŠ¡æ‰€å±žçš„ä¸Šä¸‹æ–‡
            for context_name, context_services_set in contexts.items():
                if service.name in context_services_set:
                    context_services[context_name].append(service)
                    break
            else:
                # å¦‚æžœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ä¸Šä¸‹æ–‡ï¼Œæ”¾å…¥é»˜è®¤ä¸Šä¸‹æ–‡
                context_services['default'].append(service)

        return dict(context_services)

    def split_by_data_ownership(self, services: List[Service], data_ownership: Dict[str, str]) -> Dict[str, List[Service]]:
        """æŒ‰æ•°æ®æ‰€æœ‰æƒæ‹†åˆ†æœåŠ¡"""
        ownership_services = defaultdict(list)

        for service in services:
            owner = data_ownership.get(service.name, 'shared')
            ownership_services[owner].append(service)

        return dict(ownership_services)

    def calculate_cohesion(self, services: List[Service]) -> float:
        """è®¡ç®—æœåŠ¡å†…èšåº¦"""
        if not services:
            return 0.0

        total_interfaces = sum(len(service.interfaces) for service in services)
        if total_interfaces == 0:
            return 0.0

        # è®¡ç®—æŽ¥å£ä¹‹é—´çš„ç›¸ä¼¼åº¦
        cohesion_score = 0.0
        interface_count = 0

        for i, service1 in enumerate(services):
            for j, service2 in enumerate(services[i+1:], i+1):
                for interface1 in service1.interfaces:
                    for interface2 in service2.interfaces:
                        # ç®€å•çš„ç›¸ä¼¼åº¦è®¡ç®—ï¼ˆåŸºäºŽè·¯å¾„å‰ç¼€ï¼‰
                        similarity = self._calculate_interface_similarity(interface1, interface2)
                        cohesion_score += similarity
                        interface_count += 1

        return cohesion_score / interface_count if interface_count > 0 else 0.0

    def calculate_coupling(self, services: List[Service]) -> float:
        """è®¡ç®—æœåŠ¡è€¦åˆåº¦"""
        if not services:
            return 0.0

        total_dependencies = sum(len(service.dependencies) for service in services)
        max_possible_dependencies = len(services) * (len(services) - 1)

        return total_dependencies / max_possible_dependencies if max_possible_dependencies > 0 else 0.0

    def _calculate_interface_similarity(self, interface1: ServiceInterface, interface2: ServiceInterface) -> float:
        """è®¡ç®—æŽ¥å£ç›¸ä¼¼åº¦"""
        # åŸºäºŽè·¯å¾„å‰ç¼€çš„ç›¸ä¼¼åº¦
        path1_parts = interface1.path.split('/')
        path2_parts = interface2.path.split('/')

        common_prefix_length = 0
        for part1, part2 in zip(path1_parts, path2_parts):
            if part1 == part2:
                common_prefix_length += 1
            else:
                break

        max_length = max(len(path1_parts), len(path2_parts))
        return common_prefix_length / max_length if max_length > 0 else 0.0

class ServiceAnalyzer:
    """æœåŠ¡åˆ†æžå™¨"""

    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.logger = logging.getLogger(__name__)

    def analyze_service_metrics(self) -> Dict[str, Any]:
        """åˆ†æžæœåŠ¡æŒ‡æ ‡"""
        total_services = len(self.registry.services)
        total_dependencies = sum(len(service.dependencies) for service in self.registry.services.values())
        total_interfaces = sum(len(service.interfaces) for service in self.registry.services.values())

        # è®¡ç®—å¹³å‡ä¾èµ–æ•°
        avg_dependencies = total_dependencies / total_services if total_services > 0 else 0

        # è®¡ç®—å¹³å‡æŽ¥å£æ•°
        avg_interfaces = total_interfaces / total_services if total_services > 0 else 0

        # æ£€æµ‹å¾ªçŽ¯ä¾èµ–
        circular_dependencies = self.registry.detect_circular_dependencies()

        # èŽ·å–æœåŠ¡åˆ†å±‚
        service_layers = self.registry.get_service_layers()

        return {
            'total_services': total_services,
            'total_dependencies': total_dependencies,
            'total_interfaces': total_interfaces,
            'average_dependencies': avg_dependencies,
            'average_interfaces': avg_interfaces,
            'circular_dependencies': len(circular_dependencies),
            'service_layers': len(service_layers),
            'topological_order': self.registry.get_topological_order()
        }

    def find_highly_coupled_services(self, threshold: float = 0.5) -> List[Tuple[str, int]]:
        """æ‰¾åˆ°é«˜è€¦åˆæœåŠ¡"""
        service_coupling = []

        for service in self.registry.services.values():
            coupling_ratio = len(service.dependencies) / (len(self.registry.services) - 1) if len(self.registry.services) > 1 else 0
            if coupling_ratio > threshold:
                service_coupling.append((service.name, len(service.dependencies)))

        return sorted(service_coupling, key=lambda x: x[1], reverse=True)

    def find_isolated_services(self) -> List[str]:
        """æ‰¾åˆ°å­¤ç«‹æœåŠ¡"""
        isolated_services = []

        for service in self.registry.services.values():
            if len(service.dependencies) == 0 and len(service.dependents) == 0:
                isolated_services.append(service.name)

        return isolated_services

    def suggest_service_merges(self) -> List[Tuple[str, str, float]]:
        """å»ºè®®æœåŠ¡åˆå¹¶"""
        suggestions = []

        services = list(self.registry.services.values())
        for i, service1 in enumerate(services):
            for j, service2 in enumerate(services[i+1:], i+1):
                # è®¡ç®—ç›¸ä¼¼åº¦
                similarity = self._calculate_service_similarity(service1, service2)
                if similarity > 0.7:  # ç›¸ä¼¼åº¦é˜ˆå€¼
                    suggestions.append((service1.name, service2.name, similarity))

        return sorted(suggestions, key=lambda x: x[2], reverse=True)

    def _calculate_service_similarity(self, service1: Service, service2: Service) -> float:
        """è®¡ç®—æœåŠ¡ç›¸ä¼¼åº¦"""
        # åŸºäºŽé¢†åŸŸå’ŒæŽ¥å£çš„ç›¸ä¼¼åº¦è®¡ç®—
        domain_similarity = 1.0 if service1.domain == service2.domain else 0.0

        # æŽ¥å£ç›¸ä¼¼åº¦
        interface_similarity = 0.0
        if service1.interfaces and service2.interfaces:
            total_similarity = 0.0
            for interface1 in service1.interfaces:
                for interface2 in service2.interfaces:
                    similarity = self._calculate_interface_similarity(interface1, interface2)
                    total_similarity = max(total_similarity, similarity)
            interface_similarity = total_similarity

        # åŠ æƒå¹³å‡
        return 0.6 * domain_similarity + 0.4 * interface_similarity

    def _calculate_interface_similarity(self, interface1: ServiceInterface, interface2: ServiceInterface) -> float:
        """è®¡ç®—æŽ¥å£ç›¸ä¼¼åº¦"""
        # åŸºäºŽè·¯å¾„å’Œæ–¹æ³•çš„ç›¸ä¼¼åº¦
        path_similarity = 1.0 if interface1.path == interface2.path else 0.0
        method_similarity = 1.0 if interface1.method == interface2.method else 0.0

        return 0.7 * path_similarity + 0.3 * method_similarity

class ServiceVisualizer:
    """æœåŠ¡å¯è§†åŒ–å™¨"""

    def __init__(self, registry: ServiceRegistry):
        self.registry = registry

    def visualize_dependency_graph(self, filename: str = "service_dependencies.png") -> None:
        """å¯è§†åŒ–ä¾èµ–å›¾"""
        plt.figure(figsize=(12, 8))

        # ä½¿ç”¨NetworkXç»˜åˆ¶å›¾
        pos = nx.spring_layout(self.registry.dependency_graph)

        # ç»˜åˆ¶èŠ‚ç‚¹
        nx.draw_networkx_nodes(self.registry.dependency_graph, pos,
                             node_color='lightblue', node_size=1000)

        # ç»˜åˆ¶è¾¹
        nx.draw_networkx_edges(self.registry.dependency_graph, pos,
                             edge_color='gray', arrows=True, arrowsize=20)

        # ç»˜åˆ¶æ ‡ç­¾
        labels = {node: self.registry.services[node].name
                 for node in self.registry.dependency_graph.nodes()}
        nx.draw_networkx_labels(self.registry.dependency_graph, pos, labels)

        plt.title("Service Dependency Graph")
        plt.axis('off')
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()

    def visualize_service_layers(self, filename: str = "service_layers.png") -> None:
        """å¯è§†åŒ–æœåŠ¡åˆ†å±‚"""
        layers = self.registry.get_service_layers()

        plt.figure(figsize=(12, 8))

        y_positions = {}
        for layer_num, services in layers.items():
            for i, service_id in enumerate(services):
                y_positions[service_id] = layer_num

        # ç»˜åˆ¶èŠ‚ç‚¹
        for service_id, y_pos in y_positions.items():
            x_pos = list(y_positions.values()).count(y_pos) / 2
            plt.scatter(x_pos, y_pos, s=1000, c='lightblue', alpha=0.7)
            plt.text(x_pos, y_pos, self.registry.services[service_id].name,
                    ha='center', va='center')

        # ç»˜åˆ¶ä¾èµ–è¾¹
        for edge in self.registry.dependency_graph.edges():
            from_service, to_service = edge
            from_y = y_positions[from_service]
            to_y = y_positions[to_service]
            plt.arrow(from_y, from_y, to_y - from_y, to_y - from_y,
                     head_width=0.1, head_length=0.1, fc='gray', ec='gray')

        plt.title("Service Layers")
        plt.xlabel("Layer")
        plt.ylabel("Services")
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()

# æ¼”ç¤ºå’Œæµ‹è¯•
def demonstrate_service_splitting():
    """æ¼”ç¤ºæœåŠ¡æ‹†åˆ†"""

    print("=== æœåŠ¡æ‹†åˆ†æ¼”ç¤º ===\n")

    # è®¾ç½®æ—¥å¿—
    logging.basicConfig(level=logging.INFO)

    # åˆ›å»ºæœåŠ¡æ³¨å†Œä¸­å¿ƒ
    registry = ServiceRegistry()

    # 1. åˆ›å»ºæœåŠ¡
    print("1. åˆ›å»ºæœåŠ¡")

    # ç”¨æˆ·æœåŠ¡
    user_service = Service(
        id=str(uuid.uuid4()),
        name="user-service",
        service_type=ServiceType.BUSINESS_SERVICE,
        domain="user-management",
        config=ServiceConfig(port=8081)
    )
    user_service.add_interface(ServiceInterface("getUser", "GET", "/users/{id}"))
    user_service.add_interface(ServiceInterface("createUser", "POST", "/users"))
    user_service.add_interface(ServiceInterface("updateUser", "PUT", "/users/{id}"))

    # è®¢å•æœåŠ¡
    order_service = Service(
        id=str(uuid.uuid4()),
        name="order-service",
        service_type=ServiceType.BUSINESS_SERVICE,
        domain="order-management",
        config=ServiceConfig(port=8082)
    )
    order_service.add_interface(ServiceInterface("getOrder", "GET", "/orders/{id}"))
    order_service.add_interface(ServiceInterface("createOrder", "POST", "/orders"))
    order_service.add_interface(ServiceInterface("updateOrder", "PUT", "/orders/{id}"))

    # æ”¯ä»˜æœåŠ¡
    payment_service = Service(
        id=str(uuid.uuid4()),
        name="payment-service",
        service_type=ServiceType.BUSINESS_SERVICE,
        domain="payment",
        config=ServiceConfig(port=8083)
    )
    payment_service.add_interface(ServiceInterface("processPayment", "POST", "/payments"))
    payment_service.add_interface(ServiceInterface("getPayment", "GET", "/payments/{id}"))

    # åº“å­˜æœåŠ¡
    inventory_service = Service(
        id=str(uuid.uuid4()),
        name="inventory-service",
        service_type=ServiceType.BUSINESS_SERVICE,
        domain="inventory",
        config=ServiceConfig(port=8084)
    )
    inventory_service.add_interface(ServiceInterface("getStock", "GET", "/inventory/{productId}"))
    inventory_service.add_interface(ServiceInterface("updateStock", "PUT", "/inventory/{productId}"))

    # é€šçŸ¥æœåŠ¡
    notification_service = Service(
        id=str(uuid.uuid4()),
        name="notification-service",
        service_type=ServiceType.INFRASTRUCTURE_SERVICE,
        domain="notification",
        config=ServiceConfig(port=8085)
    )
    notification_service.add_interface(ServiceInterface("sendEmail", "POST", "/notifications/email"))
    notification_service.add_interface(ServiceInterface("sendSMS", "POST", "/notifications/sms"))

    # æ³¨å†ŒæœåŠ¡
    services = [user_service, order_service, payment_service, inventory_service, notification_service]
    for service in services:
        registry.register_service(service)

    print(f"åˆ›å»ºäº† {len(services)} ä¸ªæœåŠ¡\n")

    # 2. å»ºç«‹ä¾èµ–å…³ç³»
    print("2. å»ºç«‹ä¾èµ–å…³ç³»")

    # è®¢å•æœåŠ¡ä¾èµ–ç”¨æˆ·æœåŠ¡
    registry.add_dependency(order_service.id, user_service.id)

    # è®¢å•æœåŠ¡ä¾èµ–åº“å­˜æœåŠ¡
    registry.add_dependency(order_service.id, inventory_service.id)

    # æ”¯ä»˜æœåŠ¡ä¾èµ–ç”¨æˆ·æœåŠ¡
    registry.add_dependency(payment_service.id, user_service.id)

    # è®¢å•æœåŠ¡ä¾èµ–æ”¯ä»˜æœåŠ¡
    registry.add_dependency(order_service.id, payment_service.id)

    # é€šçŸ¥æœåŠ¡è¢«å¤šä¸ªæœåŠ¡ä¾èµ–
    registry.add_dependency(user_service.id, notification_service.id)
    registry.add_dependency(order_service.id, notification_service.id)
    registry.add_dependency(payment_service.id, notification_service.id)

    print("å»ºç«‹äº†æœåŠ¡ä¾èµ–å…³ç³»\n")

    # 3. æœåŠ¡æ‹†åˆ†åˆ†æž
    print("3. æœåŠ¡æ‹†åˆ†åˆ†æž")

    splitter = ServiceSplitter(registry)
    analyzer = ServiceAnalyzer(registry)

    # æŒ‰é¢†åŸŸæ‹†åˆ†
    domain_split = splitter.split_by_domain(services)
    print("æŒ‰é¢†åŸŸæ‹†åˆ†:")
    for domain, domain_services in domain_split.items():
        print(f"  {domain}: {[s.name for s in domain_services]}")
    print()

    # åˆ†æžæœåŠ¡æŒ‡æ ‡
    metrics = analyzer.analyze_service_metrics()
    print("æœåŠ¡æŒ‡æ ‡:")
    for key, value in metrics.items():
        print(f"  {key}: {value}")
    print()

    # æ£€æµ‹é«˜è€¦åˆæœåŠ¡
    high_coupling = analyzer.find_highly_coupled_services(threshold=0.3)
    print("é«˜è€¦åˆæœåŠ¡:")
    for service_name, dependency_count in high_coupling:
        print(f"  {service_name}: {dependency_count} ä¸ªä¾èµ–")
    print()

    # æ£€æµ‹å­¤ç«‹æœåŠ¡
    isolated = analyzer.find_isolated_services()
    print("å­¤ç«‹æœåŠ¡:")
    for service_name in isolated:
        print(f"  {service_name}")
    print()

    # 4. æœåŠ¡åˆå¹¶å»ºè®®
    print("4. æœåŠ¡åˆå¹¶å»ºè®®")

    suggestions = analyzer.suggest_service_merges()
    print("åˆå¹¶å»ºè®®:")
    for service1, service2, similarity in suggestions:
        print(f"  {service1} + {service2}: ç›¸ä¼¼åº¦ {similarity:.2f}")
    print()

    # 5. æ£€æµ‹å¾ªçŽ¯ä¾èµ–
    print("5. å¾ªçŽ¯ä¾èµ–æ£€æµ‹")

    circular_deps = registry.detect_circular_dependencies()
    if circular_deps:
        print("å‘çŽ°å¾ªçŽ¯ä¾èµ–:")
        for cycle in circular_deps:
            cycle_names = [registry.services[service_id].name for service_id in cycle]
            print(f"  {' -> '.join(cycle_names)}")
    else:
        print("æ²¡æœ‰å‘çŽ°å¾ªçŽ¯ä¾èµ–")
    print()

    # 6. æœåŠ¡åˆ†å±‚
    print("6. æœåŠ¡åˆ†å±‚")

    layers = registry.get_service_layers()
    print("æœåŠ¡åˆ†å±‚:")
    for layer_num, service_ids in layers.items():
        service_names = [registry.services[service_id].name for service_id in service_ids]
        print(f"  ç¬¬{layer_num}å±‚: {service_names}")
    print()

    # 7. å¯è§†åŒ–
    print("7. ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨")

    visualizer = ServiceVisualizer(registry)
    visualizer.visualize_dependency_graph("service_dependencies.png")
    visualizer.visualize_service_layers("service_layers.png")
    print("ç”Ÿæˆäº†ä¾èµ–å›¾å’Œåˆ†å±‚å›¾\n")

if __name__ == "__main__":
    demonstrate_service_splitting()
```

## ðŸ“Š æœåŠ¡æ‹†åˆ†ç­–ç•¥

### 2.1 æ‹†åˆ†åŽŸåˆ™

#### 2.1.1 å•ä¸€èŒè´£åŽŸåˆ™

**å®šä¹‰ 2.1** (å•ä¸€èŒè´£)
æ¯ä¸ªæœåŠ¡åº”è¯¥åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡åŠŸèƒ½ï¼š
$$SRP(s) = |Responsibilities(s)| = 1$$

**å®šç† 2.1** (èŒè´£åˆ†ç¦»)
å¦‚æžœæœåŠ¡ $s$ æ»¡è¶³å•ä¸€èŒè´£åŽŸåˆ™ï¼Œåˆ™ï¼š
$$Cohesion(s) > Coupling(s)$$

#### 2.1.2 é«˜å†…èšä½Žè€¦åˆ

**å®šä¹‰ 2.2** (å†…èšåº¦)
æœåŠ¡å†…èšåº¦å®šä¹‰ä¸ºï¼š
$$Cohesion(s) = \frac{InternalRelations(s)}{TotalRelations(s)}$$

**å®šä¹‰ 2.3** (è€¦åˆåº¦)
æœåŠ¡è€¦åˆåº¦å®šä¹‰ä¸ºï¼š
$$Coupling(s) = \frac{ExternalRelations(s)}{TotalRelations(s)}$$

**å®šç† 2.2** (å†…èšè€¦åˆå…³ç³»)
å¯¹äºŽä»»ä½•æœåŠ¡ $s$ï¼š
$$Cohesion(s) + Coupling(s) = 1$$

### 2.2 æ‹†åˆ†æ–¹æ³•

#### 2.2.1 æŒ‰ä¸šåŠ¡é¢†åŸŸæ‹†åˆ†

**å®šä¹‰ 2.4** (ä¸šåŠ¡é¢†åŸŸ)
ä¸šåŠ¡é¢†åŸŸæ˜¯ç›¸å…³ä¸šåŠ¡åŠŸèƒ½çš„é›†åˆï¼š
$$Domain = \{f_1, f_2, ..., f_n\}$$

**å®šç† 2.3** (é¢†åŸŸè¾¹ç•Œ)
é¢†åŸŸå†…åŠŸèƒ½çš„å†…èšåº¦åº”è¯¥å¤§äºŽé¢†åŸŸé—´åŠŸèƒ½çš„è€¦åˆåº¦ï¼š
$$\forall d_i, d_j \in Domains, Cohesion(d_i) > Coupling(d_i, d_j)$$

#### 2.2.2 æŒ‰æ•°æ®è¾¹ç•Œæ‹†åˆ†

**å®šä¹‰ 2.5** (æ•°æ®è¾¹ç•Œ)
æ•°æ®è¾¹ç•Œæ˜¯æ•°æ®æ‰€æœ‰æƒå’Œè®¿é—®æƒé™çš„åˆ’åˆ†ï¼š
$$DataBoundary = (Owner, Access, Consistency)$$

**å®šç† 2.4** (æ•°æ®ä¸€è‡´æ€§)
æ¯ä¸ªæ•°æ®å®žä½“åº”è¯¥åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼š
$$\forall e \in Entities, |Owners(e)| = 1$$

## ðŸ” æ€§èƒ½åˆ†æž

### 3.1 ç½‘ç»œæ€§èƒ½

#### 3.1.1 å»¶è¿Ÿåˆ†æž

**å®šä¹‰ 3.1** (ç½‘ç»œå»¶è¿Ÿ)
æœåŠ¡é—´é€šä¿¡å»¶è¿ŸåŒ…æ‹¬ï¼š
$$Latency = T_{network} + T_{serialization} + T_{processing} + T_{deserialization}$$

**å®šç† 3.1** (å»¶è¿Ÿç´¯ç§¯)
å¯¹äºŽ $n$ ä¸ªæœåŠ¡çš„è°ƒç”¨é“¾ï¼š
$$TotalLatency = \sum_{i=1}^{n} Latency_i$$

#### 3.1.2 åžåé‡åˆ†æž

**å®šä¹‰ 3.2** (ç³»ç»Ÿåžåé‡)
å¾®æœåŠ¡ç³»ç»Ÿçš„åžåé‡å—é™äºŽæœ€æ…¢çš„æœåŠ¡ï¼š
$$Throughput = \min_{i=1}^{n} Throughput_i$$

### 3.2 èµ„æºåˆ©ç”¨çŽ‡

#### 3.2.1 CPUåˆ©ç”¨çŽ‡

**å®šä¹‰ 3.3** (CPUåˆ©ç”¨çŽ‡)
æœåŠ¡ $s$ çš„CPUåˆ©ç”¨çŽ‡ï¼š
$$CPU_{utilization}(s) = \frac{CPU_{used}(s)}{CPU_{total}(s)}$$

#### 3.2.2 å†…å­˜åˆ©ç”¨çŽ‡

**å®šä¹‰ 3.4** (å†…å­˜åˆ©ç”¨çŽ‡)
æœåŠ¡ $s$ çš„å†…å­˜åˆ©ç”¨çŽ‡ï¼š
$$Memory_{utilization}(s) = \frac{Memory_{used}(s)}{Memory_{total}(s)}$$

## ðŸŽ¯ è®¾è®¡æ¨¡å¼

### 4.1 æœåŠ¡å‘çŽ°

#### 4.1.1 æœåŠ¡æ³¨å†Œ

**å®šä¹‰ 4.1** (æœåŠ¡æ³¨å†Œ)
æœåŠ¡æ³¨å†Œæ˜¯æœåŠ¡å‘æ³¨å†Œä¸­å¿ƒæŠ¥å‘Šå…¶ä½ç½®å’ŒçŠ¶æ€ï¼š
$$Register(s) = (id, endpoint, status, metadata)$$

#### 4.1.2 æœåŠ¡å‘çŽ°

**å®šä¹‰ 4.2** (æœåŠ¡å‘çŽ°)
æœåŠ¡å‘çŽ°æ˜¯å®¢æˆ·ç«¯æŸ¥æ‰¾æœåŠ¡å®žä¾‹çš„è¿‡ç¨‹ï¼š
$$Discover(serviceName) = [instance_1, instance_2, ..., instance_n]$$

### 4.2 è´Ÿè½½å‡è¡¡

#### 4.2.1 è´Ÿè½½å‡è¡¡ç®—æ³•

**å®šä¹‰ 4.3** (è½®è¯¢ç®—æ³•)
è½®è¯¢è´Ÿè½½å‡è¡¡ï¼š
$$RoundRobin(i) = i \bmod n$$

**å®šä¹‰ 4.4** (åŠ æƒè½®è¯¢)
åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡ï¼š
$$WeightedRoundRobin(i, w) = \arg\max_j w_j$$

### 4.3 ç†”æ–­å™¨æ¨¡å¼

#### 4.3.1 ç†”æ–­å™¨çŠ¶æ€

**å®šä¹‰ 4.5** (ç†”æ–­å™¨)
ç†”æ–­å™¨æœ‰ä¸‰ä¸ªçŠ¶æ€ï¼š
$$CircuitBreaker = \{Closed, Open, HalfOpen\}$$

**å®šç† 4.1** (ç†”æ–­å™¨è½¬æ¢)
ç†”æ–­å™¨çŠ¶æ€è½¬æ¢è§„åˆ™ï¼š
1. $Closed \rightarrow Open$: å½“å¤±è´¥çŽ‡è¶…è¿‡é˜ˆå€¼
2. $Open \rightarrow HalfOpen$: ç»è¿‡è¶…æ—¶æ—¶é—´
3. $HalfOpen \rightarrow Closed$: æˆåŠŸè¯·æ±‚
4. $HalfOpen \rightarrow Open$: å¤±è´¥è¯·æ±‚

## ðŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### 5.1 æ°´å¹³æ‰©å±•

#### 5.1.1 è‡ªåŠ¨æ‰©ç¼©å®¹

**å®šä¹‰ 5.1** (æ‰©ç¼©å®¹ç­–ç•¥)
è‡ªåŠ¨æ‰©ç¼©å®¹åŸºäºŽæŒ‡æ ‡ï¼š
$$Scale(metric) = \begin{cases}
ScaleUp & \text{if } metric > threshold_{high} \\
ScaleDown & \text{if } metric < threshold_{low} \\
NoChange & \text{otherwise}
\end{cases}$$

#### 5.1.2 åˆ†ç‰‡ç­–ç•¥

**å®šä¹‰ 5.2** (æ•°æ®åˆ†ç‰‡)
æ•°æ®åˆ†ç‰‡ç­–ç•¥ï¼š
$$Shard(data) = hash(data.key) \bmod numShards$$

### 5.2 åž‚ç›´æ‰©å±•

#### 5.2.1 èµ„æºä¼˜åŒ–

**å®šç† 5.1** (èµ„æºåˆ†é…)
æœ€ä¼˜èµ„æºåˆ†é…æ»¡è¶³ï¼š
$$\forall s \in Services, \frac{CPU(s)}{Memory(s)} = \frac{CPU_{total}}{Memory_{total}}$$

## ðŸ”— ç›¸å…³é“¾æŽ¥

- [05-01-02 æœåŠ¡é€šä¿¡](./05-01-02-æœåŠ¡é€šä¿¡.md)
- [05-01-03 æœåŠ¡æ²»ç†](./05-01-03-æœåŠ¡æ²»ç†.md)
- [05-02-01 ä¸€è‡´æ€§ç†è®º](../../05-02-åˆ†å¸ƒå¼ç³»ç»Ÿ/05-02-01-ä¸€è‡´æ€§ç†è®º.md)
- [06-01-01 åˆ›å»ºåž‹æ¨¡å¼å®žçŽ°](../../06-ç»„ä»¶ç®—æ³•/06-01-è®¾è®¡æ¨¡å¼å®žçŽ°/06-01-01-åˆ›å»ºåž‹æ¨¡å¼å®žçŽ°.md)

---

*æœ¬æ–‡æ¡£å»ºç«‹äº†æœåŠ¡æ‹†åˆ†çš„å®Œæ•´ç†è®ºæ¡†æž¶ï¼Œä»Žå½¢å¼åŒ–å®šä¹‰åˆ°å®žé™…å®žçŽ°ï¼Œä¸ºå¾®æœåŠ¡æž¶æž„è®¾è®¡å¥ å®šäº†åšå®žçš„åŸºç¡€ã€‚*
