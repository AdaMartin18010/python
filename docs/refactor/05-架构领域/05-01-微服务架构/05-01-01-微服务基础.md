# å¾®æœåŠ¡åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ç§å°†åº”ç”¨ç¨‹åºæ„å»ºä¸ºä¸€ç»„å°å‹ã€ç‹¬ç«‹æœåŠ¡çš„æ¶æ„é£æ ¼ã€‚æœ¬æ–‡æ¡£æä¾›å¾®æœåŠ¡æ¶æ„çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å¾®æœåŠ¡æ¶æ„å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å¾®æœåŠ¡æ¶æ„å…­å…ƒç»„**:
$$\mathcal{MS} = (S, I, D, C, N, M)$$

å…¶ä¸­ï¼š

- $S = \{s_1, s_2, ..., s_n\}$ æ˜¯æœåŠ¡é›†åˆ
- $I = \{i_1, i_2, ..., i_m\}$ æ˜¯æ¥å£é›†åˆ
- $D = \{d_1, d_2, ..., d_k\}$ æ˜¯æ•°æ®å­˜å‚¨é›†åˆ
- $C = \{c_1, c_2, ..., c_p\}$ æ˜¯é…ç½®é›†åˆ
- $N = \{n_1, n_2, ..., n_q\}$ æ˜¯ç½‘ç»œèŠ‚ç‚¹é›†åˆ
- $M: S \times I \rightarrow S$ æ˜¯æœåŠ¡æ˜ å°„å‡½æ•°

#### 1.2 æ¶æ„åŸåˆ™

**å•ä¸€èŒè´£åŸåˆ™**:
$$\forall s \in S: |responsibility(s)| = 1$$

**æœåŠ¡è‡ªæ²»åŸåˆ™**:
$$\forall s \in S: independent(s) = true$$

**æ•°æ®éš”ç¦»åŸåˆ™**:
$$\forall s_i, s_j \in S, i \neq j: d_i \cap d_j = \emptyset$$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Set, Optional, Any, Tuple, Callable
from collections import defaultdict
import time
import uuid
import asyncio
import json
import logging
import threading
from concurrent.futures import ThreadPoolExecutor
import aiohttp
import uvicorn
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
import redis
import sqlite3
from contextlib import asynccontextmanager

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ServiceStatus(Enum):
    """æœåŠ¡çŠ¶æ€æšä¸¾"""
    RUNNING = "running"
    STOPPED = "stopped"
    STARTING = "starting"
    STOPPING = "stopping"
    ERROR = "error"

class ServiceType(Enum):
    """æœåŠ¡ç±»å‹æšä¸¾"""
    API = "api"
    WORKER = "worker"
    DATABASE = "database"
    CACHE = "cache"
    MESSAGE_QUEUE = "message_queue"

@dataclass
class ServiceConfig:
    """æœåŠ¡é…ç½®"""
    name: str
    port: int
    host: str = "localhost"
    service_type: ServiceType = ServiceType.API
    dependencies: List[str] = field(default_factory=list)
    environment: Dict[str, str] = field(default_factory=dict)
    health_check_path: str = "/health"
    timeout: int = 30

@dataclass
class ServiceInstance:
    """æœåŠ¡å®ä¾‹"""
    id: str
    config: ServiceConfig
    status: ServiceStatus
    start_time: float
    metrics: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.start_time:
            self.start_time = time.time()

class ServiceRegistry:
    """æœåŠ¡æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self.services: Dict[str, ServiceInstance] = {}
        self.service_instances: Dict[str, List[ServiceInstance]] = defaultdict(list)
        self.lock = threading.Lock()
    
    def register_service(self, service: ServiceInstance):
        """æ³¨å†ŒæœåŠ¡"""
        with self.lock:
            self.services[service.id] = service
            self.service_instances[service.config.name].append(service)
            logger.info(f"Registered service: {service.config.name} ({service.id})")
    
    def unregister_service(self, service_id: str):
        """æ³¨é”€æœåŠ¡"""
        with self.lock:
            if service_id in self.services:
                service = self.services[service_id]
                del self.services[service_id]
                self.service_instances[service.config.name].remove(service)
                logger.info(f"Unregistered service: {service.config.name} ({service_id})")
    
    def get_service(self, service_name: str) -> Optional[ServiceInstance]:
        """è·å–æœåŠ¡"""
        with self.lock:
            instances = self.service_instances.get(service_name, [])
            if instances:
                return instances[0]  # è¿”å›ç¬¬ä¸€ä¸ªå¯ç”¨å®ä¾‹
            return None
    
    def get_all_services(self) -> List[ServiceInstance]:
        """è·å–æ‰€æœ‰æœåŠ¡"""
        with self.lock:
            return list(self.services.values())

class ServiceDiscovery:
    """æœåŠ¡å‘ç°"""
    
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.cache: Dict[str, ServiceInstance] = {}
        self.cache_ttl = 60  # ç¼“å­˜60ç§’
        self.cache_timestamps: Dict[str, float] = {}
    
    def discover_service(self, service_name: str) -> Optional[ServiceInstance]:
        """å‘ç°æœåŠ¡"""
        current_time = time.time()
        
        # æ£€æŸ¥ç¼“å­˜
        if service_name in self.cache:
            if current_time - self.cache_timestamps[service_name] < self.cache_ttl:
                return self.cache[service_name]
        
        # ä»æ³¨å†Œè¡¨è·å–
        service = self.registry.get_service(service_name)
        if service:
            self.cache[service_name] = service
            self.cache_timestamps[service_name] = current_time
        
        return service
    
    def refresh_cache(self):
        """åˆ·æ–°ç¼“å­˜"""
        self.cache.clear()
        self.cache_timestamps.clear()

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, discovery: ServiceDiscovery):
        self.discovery = discovery
        self.algorithm = "round_robin"
        self.current_index: Dict[str, int] = defaultdict(int)
    
    def get_service_instance(self, service_name: str) -> Optional[ServiceInstance]:
        """è·å–æœåŠ¡å®ä¾‹"""
        instances = self.discovery.registry.service_instances.get(service_name, [])
        if not instances:
            return None
        
        if self.algorithm == "round_robin":
            index = self.current_index[service_name] % len(instances)
            self.current_index[service_name] += 1
            return instances[index]
        
        elif self.algorithm == "random":
            import random
            return random.choice(instances)
        
        elif self.algorithm == "least_connections":
            return min(instances, key=lambda x: x.metrics.get("connections", 0))
        
        return instances[0]

class CircuitBreaker:
    """ç†”æ–­å™¨"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = 0
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    def call(self, func: Callable, *args, **kwargs):
        """è°ƒç”¨å‡½æ•°"""
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
                self.failure_count = 0
            return result
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()
            
            if self.failure_count >= self.failure_threshold:
                self.state = "OPEN"
            
            raise e

class Microservice(ABC):
    """å¾®æœåŠ¡æŠ½è±¡åŸºç±»"""
    
    def __init__(self, config: ServiceConfig):
        self.config = config
        self.app = FastAPI(title=config.name)
        self.status = ServiceStatus.STOPPED
        self.registry = None
        self.discovery = None
        self.load_balancer = None
        self.circuit_breaker = CircuitBreaker()
        
    @abstractmethod
    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        pass
    
    @abstractmethod
    async def startup(self):
        """å¯åŠ¨æœåŠ¡"""
        pass
    
    @abstractmethod
    async def shutdown(self):
        """å…³é—­æœåŠ¡"""
        pass
    
    def register_health_check(self):
        """æ³¨å†Œå¥åº·æ£€æŸ¥"""
        @self.app.get(self.config.health_check_path)
        async def health_check():
            return {
                "status": self.status.value,
                "service": self.config.name,
                "uptime": time.time() - getattr(self, 'start_time', time.time())
            }

class UserService(Microservice):
    """ç”¨æˆ·æœåŠ¡"""
    
    def __init__(self):
        config = ServiceConfig(
            name="user-service",
            port=8001,
            service_type=ServiceType.API
        )
        super().__init__(config)
        self.users: Dict[str, Dict] = {}
        self.setup_routes()
        self.register_health_check()
    
    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        @self.app.post("/users")
        async def create_user(user_data: dict):
            user_id = str(uuid.uuid4())
            user = {
                "id": user_id,
                "name": user_data.get("name"),
                "email": user_data.get("email"),
                "created_at": time.time()
            }
            self.users[user_id] = user
            return user
        
        @self.app.get("/users/{user_id}")
        async def get_user(user_id: str):
            if user_id not in self.users:
                raise HTTPException(status_code=404, detail="User not found")
            return self.users[user_id]
        
        @self.app.get("/users")
        async def list_users():
            return list(self.users.values())
    
    async def startup(self):
        """å¯åŠ¨æœåŠ¡"""
        self.status = ServiceStatus.STARTING
        self.start_time = time.time()
        
        # æ³¨å†Œåˆ°æœåŠ¡æ³¨å†Œè¡¨
        if self.registry:
            instance = ServiceInstance(
                config=self.config,
                status=ServiceStatus.RUNNING,
                start_time=self.start_time
            )
            self.registry.register_service(instance)
        
        self.status = ServiceStatus.RUNNING
        logger.info(f"User service started on port {self.config.port}")
    
    async def shutdown(self):
        """å…³é—­æœåŠ¡"""
        self.status = ServiceStatus.STOPPING
        
        # ä»æœåŠ¡æ³¨å†Œè¡¨æ³¨é”€
        if self.registry:
            for service_id, service in self.registry.services.items():
                if service.config.name == self.config.name:
                    self.registry.unregister_service(service_id)
        
        self.status = ServiceStatus.STOPPED
        logger.info("User service stopped")

class OrderService(Microservice):
    """è®¢å•æœåŠ¡"""
    
    def __init__(self):
        config = ServiceConfig(
            name="order-service",
            port=8002,
            service_type=ServiceType.API,
            dependencies=["user-service"]
        )
        super().__init__(config)
        self.orders: Dict[str, Dict] = {}
        self.setup_routes()
        self.register_health_check()
    
    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        @self.app.post("/orders")
        async def create_order(order_data: dict):
            order_id = str(uuid.uuid4())
            order = {
                "id": order_id,
                "user_id": order_data.get("user_id"),
                "items": order_data.get("items", []),
                "total": order_data.get("total", 0),
                "status": "pending",
                "created_at": time.time()
            }
            self.orders[order_id] = order
            return order
        
        @self.app.get("/orders/{order_id}")
        async def get_order(order_id: str):
            if order_id not in self.orders:
                raise HTTPException(status_code=404, detail="Order not found")
            return self.orders[order_id]
        
        @self.app.get("/orders/user/{user_id}")
        async def get_user_orders(user_id: str):
            user_orders = [
                order for order in self.orders.values()
                if order["user_id"] == user_id
            ]
            return user_orders
    
    async def startup(self):
        """å¯åŠ¨æœåŠ¡"""
        self.status = ServiceStatus.STARTING
        self.start_time = time.time()
        
        # æ³¨å†Œåˆ°æœåŠ¡æ³¨å†Œè¡¨
        if self.registry:
            instance = ServiceInstance(
                config=self.config,
                status=ServiceStatus.RUNNING,
                start_time=self.start_time
            )
            self.registry.register_service(instance)
        
        self.status = ServiceStatus.RUNNING
        logger.info(f"Order service started on port {self.config.port}")
    
    async def shutdown(self):
        """å…³é—­æœåŠ¡"""
        self.status = ServiceStatus.STOPPING
        
        # ä»æœåŠ¡æ³¨å†Œè¡¨æ³¨é”€
        if self.registry:
            for service_id, service in self.registry.services.items():
                if service.config.name == self.config.name:
                    self.registry.unregister_service(service_id)
        
        self.status = ServiceStatus.STOPPED
        logger.info("Order service stopped")

class PaymentService(Microservice):
    """æ”¯ä»˜æœåŠ¡"""
    
    def __init__(self):
        config = ServiceConfig(
            name="payment-service",
            port=8003,
            service_type=ServiceType.API,
            dependencies=["user-service", "order-service"]
        )
        super().__init__(config)
        self.payments: Dict[str, Dict] = {}
        self.setup_routes()
        self.register_health_check()
    
    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        @self.app.post("/payments")
        async def process_payment(payment_data: dict):
            payment_id = str(uuid.uuid4())
            payment = {
                "id": payment_id,
                "order_id": payment_data.get("order_id"),
                "user_id": payment_data.get("user_id"),
                "amount": payment_data.get("amount"),
                "method": payment_data.get("method"),
                "status": "processing",
                "created_at": time.time()
            }
            
            # æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
            await asyncio.sleep(1)
            payment["status"] = "completed"
            
            self.payments[payment_id] = payment
            return payment
        
        @self.app.get("/payments/{payment_id}")
        async def get_payment(payment_id: str):
            if payment_id not in self.payments:
                raise HTTPException(status_code=404, detail="Payment not found")
            return self.payments[payment_id]
    
    async def startup(self):
        """å¯åŠ¨æœåŠ¡"""
        self.status = ServiceStatus.STARTING
        self.start_time = time.time()
        
        # æ³¨å†Œåˆ°æœåŠ¡æ³¨å†Œè¡¨
        if self.registry:
            instance = ServiceInstance(
                config=self.config,
                status=ServiceStatus.RUNNING,
                start_time=self.start_time
            )
            self.registry.register_service(instance)
        
        self.status = ServiceStatus.RUNNING
        logger.info(f"Payment service started on port {self.config.port}")
    
    async def shutdown(self):
        """å…³é—­æœåŠ¡"""
        self.status = ServiceStatus.STOPPING
        
        # ä»æœåŠ¡æ³¨å†Œè¡¨æ³¨é”€
        if self.registry:
            for service_id, service in self.registry.services.items():
                if service.config.name == self.config.name:
                    self.registry.unregister_service(service_id)
        
        self.status = ServiceStatus.STOPPED
        logger.info("Payment service stopped")

class MicroserviceOrchestrator:
    """å¾®æœåŠ¡ç¼–æ’å™¨"""
    
    def __init__(self):
        self.registry = ServiceRegistry()
        self.discovery = ServiceDiscovery(self.registry)
        self.load_balancer = LoadBalancer(self.discovery)
        self.services: List[Microservice] = []
        self.running = False
    
    def add_service(self, service: Microservice):
        """æ·»åŠ æœåŠ¡"""
        service.registry = self.registry
        service.discovery = self.discovery
        service.load_balancer = self.load_balancer
        self.services.append(service)
    
    async def start_all_services(self):
        """å¯åŠ¨æ‰€æœ‰æœåŠ¡"""
        self.running = True
        
        # å¯åŠ¨æ‰€æœ‰æœåŠ¡
        for service in self.services:
            await service.startup()
        
        logger.info(f"Started {len(self.services)} services")
    
    async def stop_all_services(self):
        """åœæ­¢æ‰€æœ‰æœåŠ¡"""
        self.running = False
        
        # åœæ­¢æ‰€æœ‰æœåŠ¡
        for service in self.services:
            await service.shutdown()
        
        logger.info("Stopped all services")
    
    def get_service_status(self) -> Dict[str, Any]:
        """è·å–æœåŠ¡çŠ¶æ€"""
        return {
            "total_services": len(self.services),
            "running_services": len([s for s in self.services if s.status == ServiceStatus.RUNNING]),
            "registered_services": len(self.registry.services),
            "services": [
                {
                    "name": service.config.name,
                    "status": service.status.value,
                    "port": service.config.port
                }
                for service in self.services
            ]
        }

class ServiceClient:
    """æœåŠ¡å®¢æˆ·ç«¯"""
    
    def __init__(self, orchestrator: MicroserviceOrchestrator):
        self.orchestrator = orchestrator
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def call_service(self, service_name: str, method: str, path: str, data: dict = None) -> dict:
        """è°ƒç”¨æœåŠ¡"""
        service = self.orchestrator.load_balancer.get_service_instance(service_name)
        if not service:
            raise Exception(f"Service {service_name} not found")
        
        url = f"http://{service.config.host}:{service.config.port}{path}"
        
        if method.upper() == "GET":
            async with self.session.get(url) as response:
                return await response.json()
        elif method.upper() == "POST":
            async with self.session.post(url, json=data) as response:
                return await response.json()
        else:
            raise ValueError(f"Unsupported method: {method}")
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
async def demonstrate_microservices():
    """æ¼”ç¤ºå¾®æœåŠ¡æ¶æ„"""
    # åˆ›å»ºç¼–æ’å™¨
    orchestrator = MicroserviceOrchestrator()
    
    # æ·»åŠ æœåŠ¡
    user_service = UserService()
    order_service = OrderService()
    payment_service = PaymentService()
    
    orchestrator.add_service(user_service)
    orchestrator.add_service(order_service)
    orchestrator.add_service(payment_service)
    
    # å¯åŠ¨æ‰€æœ‰æœåŠ¡
    await orchestrator.start_all_services()
    
    # åˆ›å»ºå®¢æˆ·ç«¯
    async with ServiceClient(orchestrator) as client:
        # åˆ›å»ºç”¨æˆ·
        user_data = {"name": "John Doe", "email": "john@example.com"}
        user = await client.call_service("user-service", "POST", "/users", user_data)
        print(f"Created user: {user}")
        
        # åˆ›å»ºè®¢å•
        order_data = {
            "user_id": user["id"],
            "items": [{"name": "Product 1", "price": 100}],
            "total": 100
        }
        order = await client.call_service("order-service", "POST", "/orders", order_data)
        print(f"Created order: {order}")
        
        # å¤„ç†æ”¯ä»˜
        payment_data = {
            "order_id": order["id"],
            "user_id": user["id"],
            "amount": order["total"],
            "method": "credit_card"
        }
        payment = await client.call_service("payment-service", "POST", "/payments", payment_data)
        print(f"Processed payment: {payment}")
        
        # è·å–ç”¨æˆ·è®¢å•
        user_orders = await client.call_service("order-service", "GET", f"/orders/user/{user['id']}")
        print(f"User orders: {user_orders}")
    
    # æ˜¾ç¤ºæœåŠ¡çŠ¶æ€
    status = orchestrator.get_service_status()
    print(f"Service status: {status}")
    
    # åœæ­¢æ‰€æœ‰æœåŠ¡
    await orchestrator.stop_all_services()

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    asyncio.run(demonstrate_microservices())
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**æœåŠ¡å‘ç°**: $O(1)$ (ä½¿ç”¨ç¼“å­˜)
**è´Ÿè½½å‡è¡¡**: $O(n)$ å…¶ä¸­ $n$ æ˜¯æœåŠ¡å®ä¾‹æ•°
**ç†”æ–­å™¨**: $O(1)$
**æœåŠ¡æ³¨å†Œ**: $O(1)$

#### 4.2 ç©ºé—´å¤æ‚åº¦

**æœåŠ¡æ³¨å†Œè¡¨**: $O(s)$ å…¶ä¸­ $s$ æ˜¯æœåŠ¡æ•°é‡
**æœåŠ¡å‘ç°ç¼“å­˜**: $O(s)$
**è´Ÿè½½å‡è¡¡å™¨**: $O(s)$

### 5. æ¶æ„ä¼˜åŠ¿

#### 5.1 å¯æ‰©å±•æ€§

**æ°´å¹³æ‰©å±•**: å¯ä»¥ç‹¬ç«‹æ‰©å±•æ¯ä¸ªæœåŠ¡
**å‚ç›´æ‰©å±•**: å¯ä»¥ä¸ºä¸åŒæœåŠ¡åˆ†é…ä¸åŒèµ„æº
**æŒ‰éœ€æ‰©å±•**: æ ¹æ®è´Ÿè½½åŠ¨æ€è°ƒæ•´æœåŠ¡å®ä¾‹æ•°

#### 5.2 å¯ç»´æŠ¤æ€§

**ç‹¬ç«‹éƒ¨ç½²**: æ¯ä¸ªæœåŠ¡å¯ä»¥ç‹¬ç«‹éƒ¨ç½²
**æŠ€æœ¯å¤šæ ·æ€§**: ä¸åŒæœåŠ¡å¯ä»¥ä½¿ç”¨ä¸åŒæŠ€æœ¯æ ˆ
**æ•…éšœéš”ç¦»**: å•ä¸ªæœåŠ¡æ•…éšœä¸å½±å“æ•´ä¸ªç³»ç»Ÿ

#### 5.3 å¯æµ‹è¯•æ€§

**å•å…ƒæµ‹è¯•**: æ¯ä¸ªæœåŠ¡å¯ä»¥ç‹¬ç«‹æµ‹è¯•
**é›†æˆæµ‹è¯•**: å¯ä»¥æµ‹è¯•æœåŠ¡é—´çš„äº¤äº’
**ç«¯åˆ°ç«¯æµ‹è¯•**: å¯ä»¥æµ‹è¯•å®Œæ•´çš„ä¸šåŠ¡æµç¨‹

## ğŸ”— ç›¸å…³é“¾æ¥

- [è½¯ä»¶æ¶æ„åŸºç¡€](../03-02-è½¯ä»¶æ¶æ„/03-02-01-è½¯ä»¶æ¶æ„åŸºç¡€.md)
- [å¾®æœåŠ¡æ¶æ„](../03-02-è½¯ä»¶æ¶æ„/03-02-03-å¾®æœåŠ¡æ¶æ„.md)
- [æœåŠ¡æ‹†åˆ†](./05-01-02-æœåŠ¡æ‹†åˆ†.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Newman, S. (2021). "Building Microservices". O'Reilly Media.
2. Richardson, C. (2018). "Microservices Patterns". Manning Publications.
3. Fowler, M. (2014). "Microservices". Martin Fowler's Blog.

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant
