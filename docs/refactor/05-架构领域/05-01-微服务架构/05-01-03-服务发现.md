# æœåŠ¡å‘ç°

## ğŸ“‹ æ¦‚è¿°

æœåŠ¡å‘ç°æ˜¯å¾®æœåŠ¡æ¶æ„ä¸­çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£è‡ªåŠ¨å‘ç°å’Œæ³¨å†ŒæœåŠ¡å®ä¾‹ï¼Œä½¿æœåŠ¡ä¹‹é—´èƒ½å¤ŸåŠ¨æ€åœ°ç›¸äº’å‘ç°å’Œé€šä¿¡ã€‚æœ¬æ–‡æ¡£æä¾›æœåŠ¡å‘ç°çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æœåŠ¡å‘ç°å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**æœåŠ¡å‘ç°å››å…ƒç»„**:
$$\mathcal{SD} = (S, R, D, U)$$

å…¶ä¸­ï¼š
- $S = \{s_1, s_2, ..., s_n\}$ æ˜¯æœåŠ¡å®ä¾‹é›†åˆ
- $R = \{r_1, r_2, ..., r_m\}$ æ˜¯æ³¨å†Œè¡¨é›†åˆ
- $D: S \times R \rightarrow \{true, false\}$ æ˜¯å‘ç°å‡½æ•°
- $U: S \times R \rightarrow \{true, false\}$ æ˜¯æ›´æ–°å‡½æ•°

#### 1.2 æœåŠ¡å‘ç°æ¨¡å¼

**å®¢æˆ·ç«¯å‘ç°æ¨¡å¼**:
$$\text{Client} \rightarrow \text{Service Registry} \rightarrow \text{Service Instance}$$

**æœåŠ¡ç«¯å‘ç°æ¨¡å¼**:
$$\text{Client} \rightarrow \text{Load Balancer} \rightarrow \text{Service Registry} \rightarrow \text{Service Instance}$$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Set, Optional, Any, Tuple, Callable
from collections import defaultdict
import time
import uuid
import asyncio
import json
import logging
import threading
from concurrent.futures import ThreadPoolExecutor
import aiohttp
import redis
import sqlite3
from contextlib import asynccontextmanager
import socket
import ssl
import hashlib

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ServiceStatus(Enum):
    """æœåŠ¡çŠ¶æ€æšä¸¾"""
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    UNKNOWN = "unknown"
    STARTING = "starting"
    STOPPING = "stopping"

class DiscoveryMode(Enum):
    """å‘ç°æ¨¡å¼æšä¸¾"""
    CLIENT_SIDE = "client_side"
    SERVER_SIDE = "server_side"

@dataclass
class ServiceInstance:
    """æœåŠ¡å®ä¾‹"""
    id: str
    service_name: str
    host: str
    port: int
    status: ServiceStatus
    metadata: Dict[str, Any] = field(default_factory=dict)
    last_heartbeat: float = field(default_factory=time.time)
    created_at: float = field(default_factory=time.time)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.last_heartbeat:
            self.last_heartbeat = time.time()
        if not self.created_at:
            self.created_at = time.time()
    
    @property
    def endpoint(self) -> str:
        """è·å–æœåŠ¡ç«¯ç‚¹"""
        return f"{self.host}:{self.port}"
    
    @property
    def url(self) -> str:
        """è·å–æœåŠ¡URL"""
        return f"http://{self.host}:{self.port}"

@dataclass
class ServiceRegistration:
    """æœåŠ¡æ³¨å†Œä¿¡æ¯"""
    service_name: str
    instance: ServiceInstance
    ttl: int = 30  # ç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰
    tags: List[str] = field(default_factory=list)

class ServiceRegistry(ABC):
    """æœåŠ¡æ³¨å†Œè¡¨æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    async def register(self, registration: ServiceRegistration) -> bool:
        """æ³¨å†ŒæœåŠ¡"""
        pass
    
    @abstractmethod
    async def deregister(self, service_name: str, instance_id: str) -> bool:
        """æ³¨é”€æœåŠ¡"""
        pass
    
    @abstractmethod
    async def get_instances(self, service_name: str) -> List[ServiceInstance]:
        """è·å–æœåŠ¡å®ä¾‹"""
        pass
    
    @abstractmethod
    async def get_all_services(self) -> Dict[str, List[ServiceInstance]]:
        """è·å–æ‰€æœ‰æœåŠ¡"""
        pass

class InMemoryServiceRegistry(ServiceRegistry):
    """å†…å­˜æœåŠ¡æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self.services: Dict[str, List[ServiceInstance]] = defaultdict(list)
        self.instances: Dict[str, ServiceInstance] = {}
        self.lock = threading.RLock()
        self.cleanup_task = None
    
    async def register(self, registration: ServiceRegistration) -> bool:
        """æ³¨å†ŒæœåŠ¡"""
        with self.lock:
            instance = registration.instance
            self.instances[instance.id] = instance
            self.services[registration.service_name].append(instance)
            
            logger.info(f"Registered service {registration.service_name}: {instance.endpoint}")
            return True
    
    async def deregister(self, service_name: str, instance_id: str) -> bool:
        """æ³¨é”€æœåŠ¡"""
        with self.lock:
            if instance_id in self.instances:
                instance = self.instances[instance_id]
                if service_name in self.services:
                    self.services[service_name] = [
                        inst for inst in self.services[service_name]
                        if inst.id != instance_id
                    ]
                del self.instances[instance_id]
                
                logger.info(f"Deregistered service {service_name}: {instance.endpoint}")
                return True
            return False
    
    async def get_instances(self, service_name: str) -> List[ServiceInstance]:
        """è·å–æœåŠ¡å®ä¾‹"""
        with self.lock:
            instances = self.services.get(service_name, [])
            # è¿‡æ»¤æ‰ä¸å¥åº·çš„å®ä¾‹
            healthy_instances = [
                inst for inst in instances
                if inst.status == ServiceStatus.HEALTHY
            ]
            return healthy_instances
    
    async def get_all_services(self) -> Dict[str, List[ServiceInstance]]:
        """è·å–æ‰€æœ‰æœåŠ¡"""
        with self.lock:
            return dict(self.services)
    
    async def update_heartbeat(self, instance_id: str) -> bool:
        """æ›´æ–°å¿ƒè·³"""
        with self.lock:
            if instance_id in self.instances:
                self.instances[instance_id].last_heartbeat = time.time()
                return True
            return False
    
    async def cleanup_expired_instances(self, ttl: int = 30):
        """æ¸…ç†è¿‡æœŸå®ä¾‹"""
        with self.lock:
            current_time = time.time()
            expired_instances = []
            
            for instance_id, instance in self.instances.items():
                if current_time - instance.last_heartbeat > ttl:
                    expired_instances.append((instance.service_name, instance_id))
            
            for service_name, instance_id in expired_instances:
                await self.deregister(service_name, instance_id)
            
            if expired_instances:
                logger.info(f"Cleaned up {len(expired_instances)} expired instances")

class RedisServiceRegistry(ServiceRegistry):
    """RedisæœåŠ¡æ³¨å†Œè¡¨"""
    
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis_url = redis_url
        self.redis = redis.from_url(redis_url)
        self.service_key_prefix = "service:"
        self.instance_key_prefix = "instance:"
    
    async def register(self, registration: ServiceRegistration) -> bool:
        """æ³¨å†ŒæœåŠ¡"""
        try:
            instance = registration.instance
            instance_data = {
                "id": instance.id,
                "service_name": instance.service_name,
                "host": instance.host,
                "port": instance.port,
                "status": instance.status.value,
                "metadata": json.dumps(instance.metadata),
                "last_heartbeat": instance.last_heartbeat,
                "created_at": instance.created_at
            }
            
            # å­˜å‚¨å®ä¾‹ä¿¡æ¯
            instance_key = f"{self.instance_key_prefix}{instance.id}"
            self.redis.hmset(instance_key, instance_data)
            self.redis.expire(instance_key, registration.ttl)
            
            # æ·»åŠ åˆ°æœåŠ¡åˆ—è¡¨
            service_key = f"{self.service_key_prefix}{registration.service_name}"
            self.redis.sadd(service_key, instance.id)
            self.redis.expire(service_key, registration.ttl)
            
            logger.info(f"Registered service {registration.service_name}: {instance.endpoint}")
            return True
        except Exception as e:
            logger.error(f"Failed to register service: {e}")
            return False
    
    async def deregister(self, service_name: str, instance_id: str) -> bool:
        """æ³¨é”€æœåŠ¡"""
        try:
            # ä»æœåŠ¡åˆ—è¡¨ä¸­ç§»é™¤
            service_key = f"{self.service_key_prefix}{service_name}"
            self.redis.srem(service_key, instance_id)
            
            # åˆ é™¤å®ä¾‹ä¿¡æ¯
            instance_key = f"{self.instance_key_prefix}{instance_id}"
            self.redis.delete(instance_key)
            
            logger.info(f"Deregistered service {service_name}: {instance_id}")
            return True
        except Exception as e:
            logger.error(f"Failed to deregister service: {e}")
            return False
    
    async def get_instances(self, service_name: str) -> List[ServiceInstance]:
        """è·å–æœåŠ¡å®ä¾‹"""
        try:
            service_key = f"{self.service_key_prefix}{service_name}"
            instance_ids = self.redis.smembers(service_key)
            
            instances = []
            for instance_id in instance_ids:
                instance_key = f"{self.instance_key_prefix}{instance_id.decode()}"
                instance_data = self.redis.hgetall(instance_key)
                
                if instance_data:
                    instance = ServiceInstance(
                        id=instance_data[b'id'].decode(),
                        service_name=instance_data[b'service_name'].decode(),
                        host=instance_data[b'host'].decode(),
                        port=int(instance_data[b'port']),
                        status=ServiceStatus(instance_data[b'status'].decode()),
                        metadata=json.loads(instance_data[b'metadata'].decode()),
                        last_heartbeat=float(instance_data[b'last_heartbeat']),
                        created_at=float(instance_data[b'created_at'])
                    )
                    instances.append(instance)
            
            return instances
        except Exception as e:
            logger.error(f"Failed to get instances: {e}")
            return []
    
    async def get_all_services(self) -> Dict[str, List[ServiceInstance]]:
        """è·å–æ‰€æœ‰æœåŠ¡"""
        try:
            services = {}
            service_keys = self.redis.keys(f"{self.service_key_prefix}*")
            
            for service_key in service_keys:
                service_name = service_key.decode().replace(self.service_key_prefix, "")
                instances = await self.get_instances(service_name)
                if instances:
                    services[service_name] = instances
            
            return services
        except Exception as e:
            logger.error(f"Failed to get all services: {e}")
            return {}

class ServiceDiscovery:
    """æœåŠ¡å‘ç°å®¢æˆ·ç«¯"""
    
    def __init__(self, registry: ServiceRegistry, mode: DiscoveryMode = DiscoveryMode.CLIENT_SIDE):
        self.registry = registry
        self.mode = mode
        self.cache: Dict[str, List[ServiceInstance]] = {}
        self.cache_ttl = 30  # ç¼“å­˜30ç§’
        self.cache_timestamps: Dict[str, float] = {}
        self.load_balancer = None
    
    async def discover_service(self, service_name: str) -> List[ServiceInstance]:
        """å‘ç°æœåŠ¡"""
        current_time = time.time()
        
        # æ£€æŸ¥ç¼“å­˜
        if service_name in self.cache:
            if current_time - self.cache_timestamps[service_name] < self.cache_ttl:
                return self.cache[service_name]
        
        # ä»æ³¨å†Œè¡¨è·å–
        instances = await self.registry.get_instances(service_name)
        
        # æ›´æ–°ç¼“å­˜
        self.cache[service_name] = instances
        self.cache_timestamps[service_name] = current_time
        
        return instances
    
    async def get_service_url(self, service_name: str) -> Optional[str]:
        """è·å–æœåŠ¡URL"""
        instances = await self.discover_service(service_name)
        if instances:
            # ç®€å•çš„è´Ÿè½½å‡è¡¡ï¼šé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨å®ä¾‹
            return instances[0].url
        return None
    
    def refresh_cache(self):
        """åˆ·æ–°ç¼“å­˜"""
        self.cache.clear()
        self.cache_timestamps.clear()

class ServiceRegistrationClient:
    """æœåŠ¡æ³¨å†Œå®¢æˆ·ç«¯"""
    
    def __init__(self, registry: ServiceRegistry, service_name: str, host: str, port: int):
        self.registry = registry
        self.service_name = service_name
        self.host = host
        self.port = port
        self.instance_id = str(uuid.uuid4())
        self.heartbeat_interval = 10  # å¿ƒè·³é—´éš”10ç§’
        self.heartbeat_task = None
        self.registered = False
    
    async def register(self, metadata: Dict[str, Any] = None, ttl: int = 30) -> bool:
        """æ³¨å†ŒæœåŠ¡"""
        try:
            instance = ServiceInstance(
                id=self.instance_id,
                service_name=self.service_name,
                host=self.host,
                port=self.port,
                status=ServiceStatus.HEALTHY,
                metadata=metadata or {}
            )
            
            registration = ServiceRegistration(
                service_name=self.service_name,
                instance=instance,
                ttl=ttl
            )
            
            success = await self.registry.register(registration)
            if success:
                self.registered = True
                await self._start_heartbeat()
                logger.info(f"Service {self.service_name} registered successfully")
            
            return success
        except Exception as e:
            logger.error(f"Failed to register service: {e}")
            return False
    
    async def deregister(self) -> bool:
        """æ³¨é”€æœåŠ¡"""
        try:
            if self.registered:
                await self._stop_heartbeat()
                success = await self.registry.deregister(self.service_name, self.instance_id)
                self.registered = False
                logger.info(f"Service {self.service_name} deregistered successfully")
                return success
            return True
        except Exception as e:
            logger.error(f"Failed to deregister service: {e}")
            return False
    
    async def _start_heartbeat(self):
        """å¼€å§‹å¿ƒè·³"""
        if self.heartbeat_task is None:
            self.heartbeat_task = asyncio.create_task(self._heartbeat_loop())
    
    async def _stop_heartbeat(self):
        """åœæ­¢å¿ƒè·³"""
        if self.heartbeat_task:
            self.heartbeat_task.cancel()
            try:
                await self.heartbeat_task
            except asyncio.CancelledError:
                pass
            self.heartbeat_task = None
    
    async def _heartbeat_loop(self):
        """å¿ƒè·³å¾ªç¯"""
        while self.registered:
            try:
                await self.registry.update_heartbeat(self.instance_id)
                await asyncio.sleep(self.heartbeat_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Heartbeat failed: {e}")
                await asyncio.sleep(self.heartbeat_interval)

class HealthChecker:
    """å¥åº·æ£€æŸ¥å™¨"""
    
    def __init__(self, timeout: int = 5):
        self.timeout = timeout
    
    async def check_health(self, instance: ServiceInstance) -> bool:
        """æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€"""
        try:
            url = f"{instance.url}/health"
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=self.timeout) as response:
                    return response.status == 200
        except Exception as e:
            logger.warning(f"Health check failed for {instance.endpoint}: {e}")
            return False
    
    async def check_all_instances(self, instances: List[ServiceInstance]) -> List[ServiceInstance]:
        """æ£€æŸ¥æ‰€æœ‰å®ä¾‹çš„å¥åº·çŠ¶æ€"""
        healthy_instances = []
        
        for instance in instances:
            if await self.check_health(instance):
                healthy_instances.append(instance)
            else:
                instance.status = ServiceStatus.UNHEALTHY
        
        return healthy_instances

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, strategy: str = "round_robin"):
        self.strategy = strategy
        self.current_index: Dict[str, int] = defaultdict(int)
    
    def select_instance(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        """é€‰æ‹©å®ä¾‹"""
        if not instances:
            return None
        
        if self.strategy == "round_robin":
            index = self.current_index["default"] % len(instances)
            self.current_index["default"] += 1
            return instances[index]
        
        elif self.strategy == "random":
            import random
            return random.choice(instances)
        
        elif self.strategy == "least_connections":
            # è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥åŸºäºè¿æ¥æ•°
            return instances[0]
        
        elif self.strategy == "weighted":
            # åŸºäºæƒé‡çš„é€‰æ‹©
            total_weight = sum(inst.metadata.get("weight", 1) for inst in instances)
            import random
            rand = random.uniform(0, total_weight)
            current_weight = 0
            
            for instance in instances:
                current_weight += instance.metadata.get("weight", 1)
                if rand <= current_weight:
                    return instance
            
            return instances[0]
        
        return instances[0]

class ServiceDiscoveryManager:
    """æœåŠ¡å‘ç°ç®¡ç†å™¨"""
    
    def __init__(self, registry: ServiceRegistry, discovery_mode: DiscoveryMode = DiscoveryMode.CLIENT_SIDE):
        self.registry = registry
        self.discovery = ServiceDiscovery(registry, discovery_mode)
        self.health_checker = HealthChecker()
        self.load_balancer = LoadBalancer()
        self.cleanup_task = None
    
    async def start(self):
        """å¯åŠ¨æœåŠ¡å‘ç°ç®¡ç†å™¨"""
        self.cleanup_task = asyncio.create_task(self._cleanup_loop())
        logger.info("Service discovery manager started")
    
    async def stop(self):
        """åœæ­¢æœåŠ¡å‘ç°ç®¡ç†å™¨"""
        if self.cleanup_task:
            self.cleanup_task.cancel()
            try:
                await self.cleanup_task
            except asyncio.CancelledError:
                pass
        logger.info("Service discovery manager stopped")
    
    async def get_service_instance(self, service_name: str) -> Optional[ServiceInstance]:
        """è·å–æœåŠ¡å®ä¾‹"""
        instances = await self.discovery.discover_service(service_name)
        if instances:
            # å¥åº·æ£€æŸ¥
            healthy_instances = await self.health_checker.check_all_instances(instances)
            if healthy_instances:
                # è´Ÿè½½å‡è¡¡é€‰æ‹©
                return self.load_balancer.select_instance(healthy_instances)
        return None
    
    async def _cleanup_loop(self):
        """æ¸…ç†å¾ªç¯"""
        while True:
            try:
                if isinstance(self.registry, InMemoryServiceRegistry):
                    await self.registry.cleanup_expired_instances()
                await asyncio.sleep(30)  # æ¯30ç§’æ¸…ç†ä¸€æ¬¡
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Cleanup failed: {e}")
                await asyncio.sleep(30)

class ServiceDiscoveryAPI:
    """æœåŠ¡å‘ç°API"""
    
    def __init__(self, manager: ServiceDiscoveryManager):
        self.manager = manager
        self.app = None
    
    def create_app(self):
        """åˆ›å»ºAPIåº”ç”¨"""
        from fastapi import FastAPI, HTTPException
        from pydantic import BaseModel
        
        self.app = FastAPI(title="Service Discovery API")
        
        class ServiceInfo(BaseModel):
            service_name: str
            host: str
            port: int
            metadata: Dict[str, Any] = {}
        
        @self.app.get("/services")
        async def list_services():
            """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
            services = await self.manager.registry.get_all_services()
            return {
                "services": [
                    {
                        "name": service_name,
                        "instances": [
                            {
                                "id": inst.id,
                                "host": inst.host,
                                "port": inst.port,
                                "status": inst.status.value,
                                "metadata": inst.metadata
                            }
                            for inst in instances
                        ]
                    }
                    for service_name, instances in services.items()
                ]
            }
        
        @self.app.get("/services/{service_name}")
        async def get_service(service_name: str):
            """è·å–ç‰¹å®šæœåŠ¡"""
            instances = await self.manager.discovery.discover_service(service_name)
            return {
                "service_name": service_name,
                "instances": [
                    {
                        "id": inst.id,
                        "host": inst.host,
                        "port": inst.port,
                        "status": inst.status.value,
                        "metadata": inst.metadata
                    }
                    for inst in instances
                ]
            }
        
        @self.app.get("/services/{service_name}/instance")
        async def get_service_instance(service_name: str):
            """è·å–æœåŠ¡å®ä¾‹ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰"""
            instance = await self.manager.get_service_instance(service_name)
            if instance:
                return {
                    "id": instance.id,
                    "host": instance.host,
                    "port": instance.port,
                    "status": instance.status.value,
                    "metadata": instance.metadata,
                    "url": instance.url
                }
            else:
                raise HTTPException(status_code=404, detail="Service not found")
        
        return self.app
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
async def demonstrate_service_discovery():
    """æ¼”ç¤ºæœåŠ¡å‘ç°"""
    print("=== Service Discovery Demo ===")
    
    # åˆ›å»ºæœåŠ¡æ³¨å†Œè¡¨
    registry = InMemoryServiceRegistry()
    
    # åˆ›å»ºæœåŠ¡å‘ç°ç®¡ç†å™¨
    manager = ServiceDiscoveryManager(registry)
    await manager.start()
    
    # åˆ›å»ºæœåŠ¡æ³¨å†Œå®¢æˆ·ç«¯
    user_service_client = ServiceRegistrationClient(
        registry, "user-service", "localhost", 8001
    )
    order_service_client = ServiceRegistrationClient(
        registry, "order-service", "localhost", 8002
    )
    payment_service_client = ServiceRegistrationClient(
        registry, "payment-service", "localhost", 8003
    )
    
    # æ³¨å†ŒæœåŠ¡
    print("\n1. Registering services...")
    await user_service_client.register({"version": "1.0", "weight": 1})
    await order_service_client.register({"version": "1.0", "weight": 2})
    await payment_service_client.register({"version": "1.0", "weight": 1})
    
    # ç­‰å¾…æ³¨å†Œå®Œæˆ
    await asyncio.sleep(1)
    
    # å‘ç°æœåŠ¡
    print("\n2. Discovering services...")
    user_instances = await manager.discovery.discover_service("user-service")
    order_instances = await manager.discovery.discover_service("order-service")
    payment_instances = await manager.discovery.discover_service("payment-service")
    
    print(f"User service instances: {len(user_instances)}")
    print(f"Order service instances: {len(order_instances)}")
    print(f"Payment service instances: {len(payment_instances)}")
    
    # è·å–è´Ÿè½½å‡è¡¡åçš„å®ä¾‹
    print("\n3. Load balanced service instances...")
    user_instance = await manager.get_service_instance("user-service")
    order_instance = await manager.get_service_instance("order-service")
    payment_instance = await manager.get_service_instance("payment-service")
    
    if user_instance:
        print(f"Selected user service: {user_instance.url}")
    if order_instance:
        print(f"Selected order service: {order_instance.url}")
    if payment_instance:
        print(f"Selected payment service: {payment_instance.url}")
    
    # åˆ—å‡ºæ‰€æœ‰æœåŠ¡
    print("\n4. All registered services...")
    all_services = await manager.registry.get_all_services()
    for service_name, instances in all_services.items():
        print(f"{service_name}: {len(instances)} instances")
        for instance in instances:
            print(f"  - {instance.endpoint} ({instance.status.value})")
    
    # æ³¨é”€æœåŠ¡
    print("\n5. Deregistering services...")
    await user_service_client.deregister()
    await order_service_client.deregister()
    await payment_service_client.deregister()
    
    # åœæ­¢ç®¡ç†å™¨
    await manager.stop()
    
    print("\nService discovery demo completed!")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    asyncio.run(demonstrate_service_discovery())
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**æœåŠ¡æ³¨å†Œ**: $O(1)$
**æœåŠ¡å‘ç°**: $O(1)$ (ä½¿ç”¨ç¼“å­˜)
**å¥åº·æ£€æŸ¥**: $O(n)$ å…¶ä¸­ $n$ æ˜¯å®ä¾‹æ•°é‡
**è´Ÿè½½å‡è¡¡**: $O(1)$ (ç®€å•ç­–ç•¥)

#### 4.2 ç©ºé—´å¤æ‚åº¦

**å†…å­˜æ³¨å†Œè¡¨**: $O(s \cdot i)$ å…¶ä¸­ $s$ æ˜¯æœåŠ¡æ•°é‡ï¼Œ$i$ æ˜¯å¹³å‡å®ä¾‹æ•°é‡
**Redisæ³¨å†Œè¡¨**: $O(s \cdot i)$
**ç¼“å­˜**: $O(s)$

### 5. å¯ç”¨æ€§åˆ†æ

#### 5.1 é«˜å¯ç”¨æ€§

**å¤šæ³¨å†Œè¡¨**: æ”¯æŒå¤šä¸ªæ³¨å†Œè¡¨å®ä¾‹
**ç¼“å­˜æœºåˆ¶**: å‡å°‘æ³¨å†Œè¡¨è®¿é—®
**å¥åº·æ£€æŸ¥**: è‡ªåŠ¨æ£€æµ‹æ•…éšœå®ä¾‹
**è´Ÿè½½å‡è¡¡**: åˆ†æ•£è¯·æ±‚å‹åŠ›

#### 5.2 ä¸€è‡´æ€§

**æœ€ç»ˆä¸€è‡´æ€§**: æ³¨å†Œè¡¨æœ€ç»ˆä¼šè¾¾åˆ°ä¸€è‡´çŠ¶æ€
**å¿ƒè·³æœºåˆ¶**: å®šæœŸæ›´æ–°å®ä¾‹çŠ¶æ€
**æ¸…ç†æœºåˆ¶**: è‡ªåŠ¨æ¸…ç†è¿‡æœŸå®ä¾‹

## ğŸ”— ç›¸å…³é“¾æ¥

- [å¾®æœåŠ¡åŸºç¡€](./05-01-01-å¾®æœåŠ¡åŸºç¡€.md)
- [æœåŠ¡æ‹†åˆ†](./05-01-02-æœåŠ¡æ‹†åˆ†.md)
- [è´Ÿè½½å‡è¡¡](./05-01-04-è´Ÿè½½å‡è¡¡.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Newman, S. (2021). "Building Microservices". O'Reilly Media.
2. Richardson, C. (2018). "Microservices Patterns". Manning Publications.
3. Netflix. (2016). "Netflix Eureka: Service Discovery".

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant 