# 02-04 å½¢å¼è¯­è¨€ç†è®º

## ğŸ“‹ æ¦‚è¿°

å½¢å¼è¯­è¨€ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„åŸºç¡€ç†è®ºï¼Œç ”ç©¶è¯­è¨€çš„æ•°å­¦æ€§è´¨å’Œè‡ªåŠ¨æœºç†è®ºã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°å½¢å¼è¯­è¨€çš„åŸºæœ¬æ¦‚å¿µã€è¯­æ³•ç†è®ºå’Œè‡ªåŠ¨æœºæ¨¡å‹ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å½¢å¼è¯­è¨€åŸºç¡€

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (å­—æ¯è¡¨)
å­—æ¯è¡¨æ˜¯ä¸€ä¸ªæœ‰é™çš„ç¬¦å·é›†åˆï¼š
$$\Sigma = \{a_1, a_2, \ldots, a_n\}$$

**å®šä¹‰ 1.2** (å­—ç¬¦ä¸²)
å­—ç¬¦ä¸²æ˜¯å­—æ¯è¡¨ä¸­ç¬¦å·çš„æœ‰é™åºåˆ—ï¼š
$$w = a_1 a_2 \ldots a_n, \quad a_i \in \Sigma$$

**å®šä¹‰ 1.3** (è¯­è¨€)
è¯­è¨€æ˜¯å­—ç¬¦ä¸²çš„é›†åˆï¼š
$$L \subseteq \Sigma^*$$

**å®šä¹‰ 1.4** (å­—ç¬¦ä¸²æ“ä½œ)

- è¿æ¥ï¼š$w \cdot v = wv$
- å¹‚ï¼š$w^n = \underbrace{w \cdot w \cdots w}_{n \text{æ¬¡}}$
- å…‹æ—é—­åŒ…ï¼š$\Sigma^* = \bigcup_{i=0}^{\infty} \Sigma^i$

#### 1.2 Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Set, List, Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum
import re

class Alphabet:
    """å­—æ¯è¡¨"""
    
    def __init__(self, symbols: Set[str]):
        self.symbols = symbols
    
    def __contains__(self, symbol: str) -> bool:
        return symbol in self.symbols
    
    def __str__(self) -> str:
        return f"{{{', '.join(sorted(self.symbols))}}}"
    
    def __len__(self) -> int:
        return len(self.symbols)

class String:
    """å­—ç¬¦ä¸²"""
    
    def __init__(self, content: str, alphabet: Alphabet):
        self.content = content
        self.alphabet = alphabet
        
        # éªŒè¯å­—ç¬¦ä¸²åªåŒ…å«å­—æ¯è¡¨ä¸­çš„ç¬¦å·
        for symbol in content:
            if symbol not in alphabet:
                raise ValueError(f"ç¬¦å· '{symbol}' ä¸åœ¨å­—æ¯è¡¨ {alphabet} ä¸­")
    
    def __len__(self) -> int:
        return len(self.content)
    
    def __str__(self) -> str:
        return self.content
    
    def __add__(self, other: 'String') -> 'String':
        """å­—ç¬¦ä¸²è¿æ¥"""
        if self.alphabet != other.alphabet:
            raise ValueError("ä¸åŒå­—æ¯è¡¨çš„å­—ç¬¦ä¸²ä¸èƒ½è¿æ¥")
        return String(self.content + other.content, self.alphabet)
    
    def __mul__(self, n: int) -> 'String':
        """å­—ç¬¦ä¸²å¹‚"""
        if n < 0:
            raise ValueError("å¹‚æŒ‡æ•°ä¸èƒ½ä¸ºè´Ÿæ•°")
        return String(self.content * n, self.alphabet)
    
    def reverse(self) -> 'String':
        """å­—ç¬¦ä¸²åè½¬"""
        return String(self.content[::-1], self.alphabet)
    
    def prefix(self, length: int) -> 'String':
        """å‰ç¼€"""
        if length > len(self):
            raise ValueError("å‰ç¼€é•¿åº¦ä¸èƒ½è¶…è¿‡å­—ç¬¦ä¸²é•¿åº¦")
        return String(self.content[:length], self.alphabet)
    
    def suffix(self, length: int) -> 'String':
        """åç¼€"""
        if length > len(self):
            raise ValueError("åç¼€é•¿åº¦ä¸èƒ½è¶…è¿‡å­—ç¬¦ä¸²é•¿åº¦")
        return String(self.content[-length:], self.alphabet)
    
    def substring(self, start: int, end: int) -> 'String':
        """å­ä¸²"""
        return String(self.content[start:end], self.alphabet)

class Language:
    """å½¢å¼è¯­è¨€"""
    
    def __init__(self, alphabet: Alphabet):
        self.alphabet = alphabet
        self.strings: Set[str] = set()
    
    def add_string(self, string: String) -> None:
        """æ·»åŠ å­—ç¬¦ä¸²åˆ°è¯­è¨€"""
        if string.alphabet != self.alphabet:
            raise ValueError("å­—ç¬¦ä¸²çš„å­—æ¯è¡¨ä¸è¯­è¨€ä¸åŒ¹é…")
        self.strings.add(string.content)
    
    def remove_string(self, string: String) -> None:
        """ä»è¯­è¨€ä¸­ç§»é™¤å­—ç¬¦ä¸²"""
        self.strings.discard(string.content)
    
    def contains(self, string: String) -> bool:
        """æ£€æŸ¥è¯­è¨€æ˜¯å¦åŒ…å«å­—ç¬¦ä¸²"""
        return string.content in self.strings
    
    def __len__(self) -> int:
        return len(self.strings)
    
    def __str__(self) -> str:
        if len(self.strings) <= 10:
            return f"{{{', '.join(sorted(self.strings))}}}"
        else:
            sample = sorted(list(self.strings)[:10])
            return f"{{{', '.join(sample)}, ...}} ({len(self.strings)} ä¸ªå­—ç¬¦ä¸²)"
    
    def union(self, other: 'Language') -> 'Language':
        """è¯­è¨€å¹¶é›†"""
        if self.alphabet != other.alphabet:
            raise ValueError("ä¸åŒå­—æ¯è¡¨çš„è¯­è¨€ä¸èƒ½è¿›è¡Œå¹¶é›†æ“ä½œ")
        
        result = Language(self.alphabet)
        result.strings = self.strings.union(other.strings)
        return result
    
    def intersection(self, other: 'Language') -> 'Language':
        """è¯­è¨€äº¤é›†"""
        if self.alphabet != other.alphabet:
            raise ValueError("ä¸åŒå­—æ¯è¡¨çš„è¯­è¨€ä¸èƒ½è¿›è¡Œäº¤é›†æ“ä½œ")
        
        result = Language(self.alphabet)
        result.strings = self.strings.intersection(other.strings)
        return result
    
    def complement(self) -> 'Language':
        """è¯­è¨€è¡¥é›†"""
        # æ³¨æ„ï¼šè¿™é‡Œå‡è®¾æ‰€æœ‰å¯èƒ½çš„å­—ç¬¦ä¸²é›†åˆæ˜¯æœ‰é™çš„
        # å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„å¤„ç†
        result = Language(self.alphabet)
        # ç®€åŒ–ç‰ˆæœ¬ï¼šåªè€ƒè™‘é•¿åº¦ä¸è¶…è¿‡æŸä¸ªé™åˆ¶çš„å­—ç¬¦ä¸²
        max_length = max(len(s) for s in self.strings) if self.strings else 0
        
        def generate_strings(length: int, current: str = ""):
            if length == 0:
                if current not in self.strings:
                    result.strings.add(current)
                return
            
            for symbol in self.alphabet.symbols:
                generate_strings(length - 1, current + symbol)
        
        for length in range(max_length + 2):
            generate_strings(length)
        
        return result
    
    def concatenation(self, other: 'Language') -> 'Language':
        """è¯­è¨€è¿æ¥"""
        if self.alphabet != other.alphabet:
            raise ValueError("ä¸åŒå­—æ¯è¡¨çš„è¯­è¨€ä¸èƒ½è¿›è¡Œè¿æ¥æ“ä½œ")
        
        result = Language(self.alphabet)
        for s1 in self.strings:
            for s2 in other.strings:
                result.strings.add(s1 + s2)
        return result
    
    def kleene_star(self) -> 'Language':
        """å…‹æ—é—­åŒ…"""
        result = Language(self.alphabet)
        result.strings.add("")  # ç©ºå­—ç¬¦ä¸²
        
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è¿æ¥
        current = self.strings.copy()
        result.strings.update(current)
        
        for _ in range(10):  # é™åˆ¶è¿­ä»£æ¬¡æ•°
            new_strings = set()
            for s1 in current:
                for s2 in self.strings:
                    new_strings.add(s1 + s2)
            
            if new_strings.issubset(result.strings):
                break
            
            result.strings.update(new_strings)
            current = new_strings
        
        return result

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_formal_language():
    """æ¼”ç¤ºå½¢å¼è¯­è¨€"""
    print("å½¢å¼è¯­è¨€æ¼”ç¤º")
    print("=" * 40)
    
    # åˆ›å»ºå­—æ¯è¡¨
    alphabet = Alphabet({"a", "b", "c"})
    print(f"å­—æ¯è¡¨: {alphabet}")
    
    # åˆ›å»ºå­—ç¬¦ä¸²
    s1 = String("abc", alphabet)
    s2 = String("def", alphabet)  # è¿™ä¼šæŠ›å‡ºå¼‚å¸¸
    s3 = String("ab", alphabet)
    
    print(f"å­—ç¬¦ä¸² s1: {s1}")
    print(f"å­—ç¬¦ä¸² s3: {s3}")
    print(f"è¿æ¥: {s1 + s3}")
    print(f"å¹‚: {s3 * 3}")
    print(f"åè½¬: {s1.reverse()}")
    
    # åˆ›å»ºè¯­è¨€
    lang1 = Language(alphabet)
    lang1.add_string(String("a", alphabet))
    lang1.add_string(String("ab", alphabet))
    lang1.add_string(String("abc", alphabet))
    
    lang2 = Language(alphabet)
    lang2.add_string(String("b", alphabet))
    lang2.add_string(String("bc", alphabet))
    
    print(f"è¯­è¨€ L1: {lang1}")
    print(f"è¯­è¨€ L2: {lang2}")
    print(f"å¹¶é›†: {lang1.union(lang2)}")
    print(f"è¿æ¥: {lang1.concatenation(lang2)}")

if __name__ == "__main__":
    demonstrate_formal_language()
```

### 2. è¯­æ³•ç†è®º

#### 2.1 å½¢å¼è¯­æ³•

**å®šä¹‰ 2.1** (å½¢å¼è¯­æ³•)
å½¢å¼è¯­æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$G = (V, \Sigma, P, S)$$
å…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼é›†åˆ
- $S \in V$ æ˜¯å¼€å§‹ç¬¦å·

**å®šä¹‰ 2.2** (æ¨å¯¼)
å¯¹äºäº§ç”Ÿå¼ $\alpha \rightarrow \beta$ï¼Œå¦‚æœ $w = u\alpha v$ ä¸” $w' = u\beta v$ï¼Œåˆ™ç§° $w$ ç›´æ¥æ¨å¯¼å‡º $w'$ï¼Œè®°ä½œ $w \Rightarrow w'$ã€‚

**å®šä¹‰ 2.3** (è¯­è¨€ç”Ÿæˆ)
è¯­æ³• $G$ ç”Ÿæˆçš„è¯­è¨€ï¼š
$$L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w\}$$

#### 2.2 Pythonå®ç°

```python
from typing import Dict, List, Set, Tuple, Optional, Any
from dataclasses import dataclass
import random

@dataclass
class Production:
    """äº§ç”Ÿå¼"""
    left: str  # å·¦éƒ¨ï¼ˆéç»ˆç»“ç¬¦ï¼‰
    right: List[str]  # å³éƒ¨ï¼ˆç¬¦å·åºåˆ—ï¼‰
    
    def __str__(self):
        return f"{self.left} â†’ {' '.join(self.right)}"

class Grammar:
    """å½¢å¼è¯­æ³•"""
    
    def __init__(self, 
                 non_terminals: Set[str],
                 terminals: Set[str],
                 productions: List[Production],
                 start_symbol: str):
        self.non_terminals = non_terminals
        self.terminals = terminals
        self.productions = productions
        self.start_symbol = start_symbol
        
        # æ„å»ºäº§ç”Ÿå¼ç´¢å¼•
        self.production_index: Dict[str, List[Production]] = {}
        for production in productions:
            if production.left not in self.production_index:
                self.production_index[production.left] = []
            self.production_index[production.left].append(production)
    
    def derive(self, current: List[str], max_steps: int = 100) -> List[List[str]]:
        """æ‰§è¡Œæ¨å¯¼"""
        derivation = [current.copy()]
        steps = 0
        
        while steps < max_steps:
            # æ‰¾åˆ°æœ€å·¦è¾¹çš„éç»ˆç»“ç¬¦
            leftmost_nt_index = -1
            for i, symbol in enumerate(current):
                if symbol in self.non_terminals:
                    leftmost_nt_index = i
                    break
            
            if leftmost_nt_index == -1:
                # æ²¡æœ‰éç»ˆç»“ç¬¦ï¼Œæ¨å¯¼å®Œæˆ
                break
            
            # é€‰æ‹©äº§ç”Ÿå¼
            nt = current[leftmost_nt_index]
            if nt not in self.production_index:
                break
            
            # éšæœºé€‰æ‹©ä¸€ä¸ªäº§ç”Ÿå¼
            production = random.choice(self.production_index[nt])
            
            # åº”ç”¨äº§ç”Ÿå¼
            new_current = (current[:leftmost_nt_index] + 
                          production.right + 
                          current[leftmost_nt_index + 1:])
            
            current = new_current
            derivation.append(current.copy())
            steps += 1
        
        return derivation
    
    def generate_string(self, max_steps: int = 100) -> Optional[str]:
        """ç”Ÿæˆä¸€ä¸ªå­—ç¬¦ä¸²"""
        derivation = self.derive([self.start_symbol], max_steps)
        
        if derivation:
            final = derivation[-1]
            # æ£€æŸ¥æ˜¯å¦åªåŒ…å«ç»ˆç»“ç¬¦
            if all(symbol in self.terminals for symbol in final):
                return ''.join(final)
        
        return None
    
    def generate_language(self, max_strings: int = 10, max_steps: int = 100) -> Set[str]:
        """ç”Ÿæˆè¯­è¨€"""
        language = set()
        
        for _ in range(max_strings * 2):  # å°è¯•æ›´å¤šæ¬¡æ•°
            string = self.generate_string(max_steps)
            if string is not None:
                language.add(string)
                if len(language) >= max_strings:
                    break
        
        return language
    
    def is_regular(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ­£åˆ™è¯­æ³•"""
        for production in self.productions:
            # æ£€æŸ¥å³éƒ¨æ ¼å¼
            if len(production.right) == 0:
                continue  # ç©ºäº§ç”Ÿå¼
            
            if len(production.right) == 1:
                if production.right[0] in self.terminals:
                    continue  # A â†’ a
                elif production.right[0] in self.non_terminals:
                    continue  # A â†’ B
            
            if len(production.right) == 2:
                if (production.right[0] in self.terminals and 
                    production.right[1] in self.non_terminals):
                    continue  # A â†’ aB
            
            # ä¸æ»¡è¶³æ­£åˆ™è¯­æ³•æ¡ä»¶
            return False
        
        return True
    
    def is_context_free(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºä¸Šä¸‹æ–‡æ— å…³è¯­æ³•"""
        for production in self.productions:
            # å·¦éƒ¨å¿…é¡»æ˜¯å•ä¸ªéç»ˆç»“ç¬¦
            if len(production.left) != 1 or production.left not in self.non_terminals:
                return False
        
        return True

class RegularGrammar(Grammar):
    """æ­£åˆ™è¯­æ³•"""
    
    def __init__(self, 
                 non_terminals: Set[str],
                 terminals: Set[str],
                 productions: List[Production],
                 start_symbol: str):
        super().__init__(non_terminals, terminals, productions, start_symbol)
        
        if not self.is_regular():
            raise ValueError("ä¸æ˜¯æ­£åˆ™è¯­æ³•")
    
    def to_finite_automaton(self) -> 'FiniteAutomaton':
        """è½¬æ¢ä¸ºæœ‰é™è‡ªåŠ¨æœº"""
        states = self.non_terminals.copy()
        states.add("FINAL")  # æ¥å—çŠ¶æ€
        
        transitions = {}
        initial_state = self.start_symbol
        accept_states = {"FINAL"}
        
        for production in self.productions:
            if len(production.right) == 0:
                # A â†’ Îµ
                if production.left not in transitions:
                    transitions[production.left] = {}
                transitions[production.left]["Îµ"] = {"FINAL"}
            
            elif len(production.right) == 1:
                if production.right[0] in self.terminals:
                    # A â†’ a
                    if production.left not in transitions:
                        transitions[production.left] = {}
                    transitions[production.left][production.right[0]] = {"FINAL"}
                else:
                    # A â†’ B
                    if production.left not in transitions:
                        transitions[production.left] = {}
                    transitions[production.left]["Îµ"] = {production.right[0]}
            
            elif len(production.right) == 2:
                # A â†’ aB
                if production.left not in transitions:
                    transitions[production.left] = {}
                if production.right[0] not in transitions[production.left]:
                    transitions[production.left][production.right[0]] = set()
                transitions[production.left][production.right[0]].add(production.right[1])
        
        return FiniteAutomaton(states, self.terminals, transitions, initial_state, accept_states)

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_grammar():
    """æ¼”ç¤ºè¯­æ³•ç†è®º"""
    print("è¯­æ³•ç†è®ºæ¼”ç¤º")
    print("=" * 40)
    
    # åˆ›å»ºæ­£åˆ™è¯­æ³•ï¼ša*b*
    non_terminals = {"S", "A", "B"}
    terminals = {"a", "b"}
    
    productions = [
        Production("S", ["A"]),
        Production("A", ["a", "A"]),
        Production("A", ["B"]),
        Production("B", ["b", "B"]),
        Production("B", [])  # ç©ºäº§ç”Ÿå¼
    ]
    
    grammar = RegularGrammar(non_terminals, terminals, productions, "S")
    
    print("è¯­æ³•äº§ç”Ÿå¼:")
    for production in grammar.productions:
        print(f"  {production}")
    
    print(f"\næ˜¯å¦ä¸ºæ­£åˆ™è¯­æ³•: {grammar.is_regular()}")
    print(f"æ˜¯å¦ä¸ºä¸Šä¸‹æ–‡æ— å…³è¯­æ³•: {grammar.is_context_free()}")
    
    # ç”Ÿæˆè¯­è¨€
    language = grammar.generate_language(max_strings=5)
    print(f"\nç”Ÿæˆçš„è¯­è¨€: {language}")
    
    # æ¼”ç¤ºæ¨å¯¼
    print(f"\næ¨å¯¼è¿‡ç¨‹:")
    derivation = grammar.derive(["S"], max_steps=10)
    for i, step in enumerate(derivation):
        print(f"  æ­¥éª¤ {i}: {''.join(step) if step else 'Îµ'}")

if __name__ == "__main__":
    demonstrate_grammar()
```

### 3. è‡ªåŠ¨æœºç†è®º

#### 3.1 æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 3.1** (ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº)
DFAæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$M = (Q, \Sigma, \delta, q_0, F)$$
å…¶ä¸­ï¼š

- $Q$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

**å®šä¹‰ 3.2** (éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº)
NFAçš„è½¬ç§»å‡½æ•°ä¸ºï¼š
$$\delta: Q \times \Sigma \rightarrow \mathcal{P}(Q)$$

#### 3.2 Pythonå®ç°

```python
from typing import Dict, Set, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

class AutomatonType(Enum):
    """è‡ªåŠ¨æœºç±»å‹"""
    DFA = "DFA"
    NFA = "NFA"
    PDA = "PDA"
    TM = "TM"

@dataclass
class Transition:
    """è½¬ç§»"""
    from_state: str
    symbol: str
    to_states: Set[str]
    
    def __str__(self):
        return f"Î´({self.from_state}, {self.symbol}) = {self.to_states}"

class FiniteAutomaton:
    """æœ‰é™è‡ªåŠ¨æœº"""
    
    def __init__(self,
                 states: Set[str],
                 alphabet: Set[str],
                 transitions: Dict[str, Dict[str, Set[str]]],
                 initial_state: str,
                 accept_states: Set[str],
                 automaton_type: AutomatonType = AutomatonType.DFA):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.initial_state = initial_state
        self.accept_states = accept_states
        self.automaton_type = automaton_type
    
    def get_transition(self, state: str, symbol: str) -> Set[str]:
        """è·å–è½¬ç§»"""
        if state in self.transitions and symbol in self.transitions[state]:
            return self.transitions[state][symbol]
        return set()
    
    def epsilon_closure(self, states: Set[str]) -> Set[str]:
        """Îµé—­åŒ…"""
        closure = states.copy()
        changed = True
        
        while changed:
            changed = False
            for state in closure.copy():
                epsilon_transitions = self.get_transition(state, "Îµ")
                for next_state in epsilon_transitions:
                    if next_state not in closure:
                        closure.add(next_state)
                        changed = True
        
        return closure
    
    def accept(self, input_string: str) -> bool:
        """æ¥å—è¾“å…¥å­—ç¬¦ä¸²"""
        if self.automaton_type == AutomatonType.DFA:
            return self._accept_dfa(input_string)
        else:
            return self._accept_nfa(input_string)
    
    def _accept_dfa(self, input_string: str) -> bool:
        """DFAæ¥å—"""
        current_state = self.initial_state
        
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            
            transitions = self.get_transition(current_state, symbol)
            if not transitions:
                return False
            
            current_state = next(iter(transitions))
        
        return current_state in self.accept_states
    
    def _accept_nfa(self, input_string: str) -> bool:
        """NFAæ¥å—"""
        current_states = {self.initial_state}
        current_states = self.epsilon_closure(current_states)
        
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            
            next_states = set()
            for state in current_states:
                transitions = self.get_transition(state, symbol)
                next_states.update(transitions)
            
            current_states = self.epsilon_closure(next_states)
            
            if not current_states:
                return False
        
        return bool(current_states.intersection(self.accept_states))
    
    def to_dfa(self) -> 'FiniteAutomaton':
        """NFAè½¬DFA"""
        if self.automaton_type == AutomatonType.DFA:
            return self
        
        # å­é›†æ„é€ æ³•
        dfa_states = set()
        dfa_transitions = {}
        dfa_accept_states = set()
        
        # åˆå§‹çŠ¶æ€
        initial_dfa_state = tuple(sorted(self.epsilon_closure({self.initial_state})))
        dfa_states.add(initial_dfa_state)
        
        unprocessed_states = [initial_dfa_state]
        
        while unprocessed_states:
            current_dfa_state = unprocessed_states.pop(0)
            current_nfa_states = set(current_dfa_state)
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€
            if current_nfa_states.intersection(self.accept_states):
                dfa_accept_states.add(current_dfa_state)
            
            # ä¸ºæ¯ä¸ªè¾“å…¥ç¬¦å·è®¡ç®—è½¬ç§»
            for symbol in self.alphabet:
                next_nfa_states = set()
                
                for nfa_state in current_nfa_states:
                    transitions = self.get_transition(nfa_state, symbol)
                    next_nfa_states.update(transitions)
                
                next_nfa_states = self.epsilon_closure(next_nfa_states)
                
                if next_nfa_states:
                    next_dfa_state = tuple(sorted(next_nfa_states))
                    
                    if next_dfa_state not in dfa_states:
                        dfa_states.add(next_dfa_state)
                        unprocessed_states.append(next_dfa_state)
                    
                    if current_dfa_state not in dfa_transitions:
                        dfa_transitions[current_dfa_state] = {}
                    dfa_transitions[current_dfa_state][symbol] = {next_dfa_state}
        
        return FiniteAutomaton(
            states=dfa_states,
            alphabet=self.alphabet,
            transitions=dfa_transitions,
            initial_state=initial_dfa_state,
            accept_states=dfa_accept_states,
            automaton_type=AutomatonType.DFA
        )
    
    def minimize(self) -> 'FiniteAutomaton':
        """æœ€å°åŒ–DFA"""
        if self.automaton_type != AutomatonType.DFA:
            raise ValueError("åªèƒ½æœ€å°åŒ–DFA")
        
        # ç§»é™¤ä¸å¯è¾¾çŠ¶æ€
        reachable_states = {self.initial_state}
        unprocessed = {self.initial_state}
        
        while unprocessed:
            state = unprocessed.pop()
            for symbol in self.alphabet:
                transitions = self.get_transition(state, symbol)
                for next_state in transitions:
                    if next_state not in reachable_states:
                        reachable_states.add(next_state)
                        unprocessed.add(next_state)
        
        # ç­‰ä»·çŠ¶æ€åˆ’åˆ†
        partitions = [reachable_states.intersection(self.accept_states),
                     reachable_states - self.accept_states]
        partitions = [p for p in partitions if p]
        
        changed = True
        while changed:
            changed = False
            new_partitions = []
            
            for partition in partitions:
                if len(partition) <= 1:
                    new_partitions.append(partition)
                    continue
                
                # å°è¯•è¿›ä¸€æ­¥åˆ’åˆ†
                partition_list = list(partition)
                first_state = partition_list[0]
                new_partition = {first_state}
                
                for state in partition_list[1:]:
                    equivalent = True
                    
                    for symbol in self.alphabet:
                        first_transitions = self.get_transition(first_state, symbol)
                        state_transitions = self.get_transition(state, symbol)
                        
                        # æ£€æŸ¥è½¬ç§»æ˜¯å¦æŒ‡å‘åŒä¸€åˆ†åŒº
                        first_partition_index = -1
                        state_partition_index = -1
                        
                        for i, p in enumerate(partitions):
                            if first_transitions.intersection(p):
                                first_partition_index = i
                            if state_transitions.intersection(p):
                                state_partition_index = i
                        
                        if first_partition_index != state_partition_index:
                            equivalent = False
                            break
                    
                    if equivalent:
                        new_partition.add(state)
                    else:
                        if len(new_partition) == 1:
                            new_partitions.append(new_partition)
                            new_partition = {state}
                        else:
                            new_partitions.append(new_partition)
                            new_partition = {state}
                            changed = True
                
                if new_partition:
                    new_partitions.append(new_partition)
            
            partitions = new_partitions
        
        # æ„å»ºæœ€å°åŒ–DFA
        min_states = set()
        min_transitions = {}
        min_accept_states = set()
        
        # åˆ›å»ºçŠ¶æ€æ˜ å°„
        state_to_partition = {}
        for partition in partitions:
            partition_tuple = tuple(sorted(partition))
            min_states.add(partition_tuple)
            
            for state in partition:
                state_to_partition[state] = partition_tuple
            
            if partition.intersection(self.accept_states):
                min_accept_states.add(partition_tuple)
        
        # æ„å»ºè½¬ç§»
        for partition in partitions:
            partition_tuple = tuple(sorted(partition))
            representative = next(iter(partition))
            
            min_transitions[partition_tuple] = {}
            for symbol in self.alphabet:
                transitions = self.get_transition(representative, symbol)
                if transitions:
                    next_state = next(iter(transitions))
                    next_partition = state_to_partition[next_state]
                    min_transitions[partition_tuple][symbol] = {next_partition}
        
        return FiniteAutomaton(
            states=min_states,
            alphabet=self.alphabet,
            transitions=min_transitions,
            initial_state=state_to_partition[self.initial_state],
            accept_states=min_accept_states,
            automaton_type=AutomatonType.DFA
        )

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_automata():
    """æ¼”ç¤ºè‡ªåŠ¨æœºç†è®º"""
    print("è‡ªåŠ¨æœºç†è®ºæ¼”ç¤º")
    print("=" * 40)
    
    # åˆ›å»ºNFAï¼šæ¥å—åŒ…å«"ab"çš„å­—ç¬¦ä¸²
    states = {"q0", "q1", "q2"}
    alphabet = {"a", "b"}
    
    transitions = {
        "q0": {
            "a": {"q0", "q1"},
            "b": {"q0"}
        },
        "q1": {
            "b": {"q2"}
        },
        "q2": {
            "a": {"q2"},
            "b": {"q2"}
        }
    }
    
    nfa = FiniteAutomaton(
        states=states,
        alphabet=alphabet,
        transitions=transitions,
        initial_state="q0",
        accept_states={"q2"},
        automaton_type=AutomatonType.NFA
    )
    
    # æµ‹è¯•å­—ç¬¦ä¸²
    test_strings = ["ab", "aab", "abb", "ba", "abc"]
    print("NFAæµ‹è¯•:")
    for string in test_strings:
        accepted = nfa.accept(string)
        print(f"  '{string}': {'æ¥å—' if accepted else 'æ‹’ç»'}")
    
    # è½¬æ¢ä¸ºDFA
    dfa = nfa.to_dfa()
    print(f"\nè½¬æ¢ä¸ºDFA:")
    print(f"  çŠ¶æ€æ•°: {len(dfa.states)}")
    
    # æµ‹è¯•DFA
    print("DFAæµ‹è¯•:")
    for string in test_strings:
        accepted = dfa.accept(string)
        print(f"  '{string}': {'æ¥å—' if accepted else 'æ‹’ç»'}")
    
    # æœ€å°åŒ–DFA
    min_dfa = dfa.minimize()
    print(f"\næœ€å°åŒ–DFA:")
    print(f"  çŠ¶æ€æ•°: {len(min_dfa.states)}")

if __name__ == "__main__":
    demonstrate_automata()
```

### 4. ä¸‹æ¨è‡ªåŠ¨æœº

#### 4.1 ä¸‹æ¨è‡ªåŠ¨æœºå®šä¹‰

**å®šä¹‰ 4.1** (ä¸‹æ¨è‡ªåŠ¨æœº)
PDAæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$$
å…¶ä¸­ï¼š

- $Q$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯æ ˆå­—æ¯è¡¨
- $\delta: Q \times \Sigma \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $Z_0 \in \Gamma$ æ˜¯åˆå§‹æ ˆç¬¦å·
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

#### 4.2 Pythonå®ç°

```python
from typing import Dict, Set, List, Optional, Tuple, Any
from dataclasses import dataclass

@dataclass
class PDAConfiguration:
    """PDAé…ç½®"""
    state: str
    input_remaining: str
    stack: List[str]
    
    def __str__(self):
        return f"({self.state}, {self.input_remaining}, {''.join(self.stack)})"

@dataclass
class PDATransition:
    """PDAè½¬ç§»"""
    from_state: str
    input_symbol: str
    stack_top: str
    to_state: str
    stack_push: List[str]
    
    def __str__(self):
        return f"Î´({self.from_state}, {self.input_symbol}, {self.stack_top}) = ({self.to_state}, {''.join(self.stack_push)})"

class PushdownAutomaton:
    """ä¸‹æ¨è‡ªåŠ¨æœº"""
    
    def __init__(self,
                 states: Set[str],
                 input_alphabet: Set[str],
                 stack_alphabet: Set[str],
                 transitions: List[PDATransition],
                 initial_state: str,
                 initial_stack_symbol: str,
                 accept_states: Set[str]):
        self.states = states
        self.input_alphabet = input_alphabet
        self.stack_alphabet = stack_alphabet
        self.transitions = transitions
        self.initial_state = initial_state
        self.initial_stack_symbol = initial_stack_symbol
        self.accept_states = accept_states
        
        # æ„å»ºè½¬ç§»ç´¢å¼•
        self.transition_index: Dict[Tuple[str, str, str], List[PDATransition]] = {}
        for transition in transitions:
            key = (transition.from_state, transition.input_symbol, transition.stack_top)
            if key not in self.transition_index:
                self.transition_index[key] = []
            self.transition_index[key].append(transition)
    
    def get_transitions(self, state: str, input_symbol: str, stack_top: str) -> List[PDATransition]:
        """è·å–å¯èƒ½çš„è½¬ç§»"""
        key = (state, input_symbol, stack_top)
        return self.transition_index.get(key, [])
    
    def accept(self, input_string: str) -> bool:
        """æ¥å—è¾“å…¥å­—ç¬¦ä¸²"""
        initial_config = PDAConfiguration(
            state=self.initial_state,
            input_remaining=input_string,
            stack=[self.initial_stack_symbol]
        )
        
        return self._accept_recursive(initial_config, set())
    
    def _accept_recursive(self, config: PDAConfiguration, visited: Set[str]) -> bool:
        """é€’å½’æ£€æŸ¥æ¥å—"""
        config_key = f"{config.state},{config.input_remaining},{''.join(config.stack)}"
        
        if config_key in visited:
            return False
        
        visited.add(config_key)
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºç©ºæ ˆæ¥å—
        if not config.input_remaining and config.state in self.accept_states:
            return True
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºç©ºè¾“å…¥æ¥å—
        if not config.input_remaining and not config.stack:
            return True
        
        # å°è¯•æ‰€æœ‰å¯èƒ½çš„è½¬ç§»
        input_symbol = config.input_remaining[0] if config.input_remaining else "Îµ"
        stack_top = config.stack[-1] if config.stack else ""
        
        transitions = self.get_transitions(config.state, input_symbol, stack_top)
        
        for transition in transitions:
            # åˆ›å»ºæ–°é…ç½®
            new_state = transition.to_state
            new_input = config.input_remaining[1:] if input_symbol != "Îµ" else config.input_remaining
            new_stack = config.stack[:-1] + transition.stack_push
            
            new_config = PDAConfiguration(
                state=new_state,
                input_remaining=new_input,
                stack=new_stack
            )
            
            if self._accept_recursive(new_config, visited):
                return True
        
        return False
    
    def to_context_free_grammar(self) -> Grammar:
        """è½¬æ¢ä¸ºä¸Šä¸‹æ–‡æ— å…³è¯­æ³•"""
        # è¿™é‡Œæä¾›ç®€åŒ–ç‰ˆæœ¬
        # å®é™…è½¬æ¢éœ€è¦æ›´å¤æ‚çš„æ„é€ 
        
        non_terminals = set()
        terminals = self.input_alphabet.copy()
        productions = []
        
        # ä¸ºæ¯ä¸ªçŠ¶æ€å’Œæ ˆç¬¦å·åˆ›å»ºéç»ˆç»“ç¬¦
        for state in self.states:
            for stack_symbol in self.stack_alphabet:
                non_terminal = f"[{state},{stack_symbol},{state}]"
                non_terminals.add(non_terminal)
        
        # æ·»åŠ äº§ç”Ÿå¼
        for transition in self.transitions:
            # ç®€åŒ–ï¼šåªå¤„ç†åŸºæœ¬çš„è½¬ç§»
            if len(transition.stack_push) == 1:
                left = f"[{transition.from_state},{transition.stack_top},{transition.to_state}]"
                right = [transition.input_symbol, f"[{transition.to_state},{transition.stack_push[0]},{transition.to_state}]"]
                productions.append(Production(left, right))
        
        return Grammar(
            non_terminals=non_terminals,
            terminals=terminals,
            productions=productions,
            start_symbol=f"[{self.initial_state},{self.initial_stack_symbol},{self.initial_state}]"
        )

# ç¤ºä¾‹ï¼šè¯†åˆ«å›æ–‡ä¸²çš„PDA
def create_palindrome_pda() -> PushdownAutomaton:
    """åˆ›å»ºè¯†åˆ«å›æ–‡ä¸²çš„PDA"""
    states = {"q0", "q1", "q2", "q3"}
    input_alphabet = {"a", "b"}
    stack_alphabet = {"Z", "A", "B"}
    
    transitions = [
        # è¯»å–å¹¶å‹æ ˆ
        PDATransition("q0", "a", "Z", "q0", ["A", "Z"]),
        PDATransition("q0", "b", "Z", "q0", ["B", "Z"]),
        PDATransition("q0", "a", "A", "q0", ["A", "A"]),
        PDATransition("q0", "b", "A", "q0", ["B", "A"]),
        PDATransition("q0", "a", "B", "q0", ["A", "B"]),
        PDATransition("q0", "b", "B", "q0", ["B", "B"]),
        
        # ç§»åŠ¨åˆ°ä¸­é—´
        PDATransition("q0", "Îµ", "Z", "q1", ["Z"]),
        PDATransition("q0", "Îµ", "A", "q1", ["A"]),
        PDATransition("q0", "Îµ", "B", "q1", ["B"]),
        
        # æ¯”è¾ƒå¹¶å¼¹æ ˆ
        PDATransition("q1", "a", "A", "q1", []),
        PDATransition("q1", "b", "B", "q1", []),
        
        # æ¥å—
        PDATransition("q1", "Îµ", "Z", "q3", ["Z"]),
    ]
    
    return PushdownAutomaton(
        states=states,
        input_alphabet=input_alphabet,
        stack_alphabet=stack_alphabet,
        transitions=transitions,
        initial_state="q0",
        initial_stack_symbol="Z",
        accept_states={"q3"}
    )

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_pda():
    """æ¼”ç¤ºä¸‹æ¨è‡ªåŠ¨æœº"""
    print("ä¸‹æ¨è‡ªåŠ¨æœºæ¼”ç¤º")
    print("=" * 40)
    
    pda = create_palindrome_pda()
    
    # æµ‹è¯•å›æ–‡ä¸²
    test_strings = ["aa", "abba", "aba", "ab", "a", ""]
    
    print("PDAæµ‹è¯•:")
    for string in test_strings:
        accepted = pda.accept(string)
        print(f"  '{string}': {'æ¥å—' if accepted else 'æ‹’ç»'}")

if __name__ == "__main__":
    demonstrate_pda()
```

## ğŸ“Š è¯­è¨€å±‚æ¬¡

### 1. ä¹”å§†æ–¯åŸºå±‚æ¬¡

| ç±»å‹ | è¯­æ³•ç±»å‹ | è‡ªåŠ¨æœº | ç¤ºä¾‹è¯­è¨€ |
|------|---------|--------|----------|
| 0å‹ | æ— é™åˆ¶è¯­æ³• | å›¾çµæœº | æ‰€æœ‰å¯è®¡ç®—è¯­è¨€ |
| 1å‹ | ä¸Šä¸‹æ–‡ç›¸å…³è¯­æ³• | çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº | a^n b^n c^n |
| 2å‹ | ä¸Šä¸‹æ–‡æ— å…³è¯­æ³• | ä¸‹æ¨è‡ªåŠ¨æœº | a^n b^n |
| 3å‹ | æ­£åˆ™è¯­æ³• | æœ‰é™è‡ªåŠ¨æœº | a*b* |

### 2. è¯­è¨€æ“ä½œ

- **å¹¶é›†**ï¼š$L_1 \cup L_2$
- **äº¤é›†**ï¼š$L_1 \cap L_2$
- **è¡¥é›†**ï¼š$\overline{L}$
- **è¿æ¥**ï¼š$L_1 \cdot L_2$
- **å…‹æ—é—­åŒ…**ï¼š$L^*$

### 3. è¯­è¨€æ€§è´¨

- **æ­£åˆ™è¯­è¨€**ï¼šåœ¨å¹¶é›†ã€äº¤é›†ã€è¡¥é›†ã€è¿æ¥ã€å…‹æ—é—­åŒ…ä¸‹å°é—­
- **ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€**ï¼šåœ¨å¹¶é›†ã€è¿æ¥ã€å…‹æ—é—­åŒ…ä¸‹å°é—­ï¼Œåœ¨äº¤é›†ã€è¡¥é›†ä¸‹ä¸å°é—­
- **é€’å½’è¯­è¨€**ï¼šåœ¨å¸ƒå°”è¿ç®—ä¸‹å°é—­

## ğŸ“ˆ æ€»ç»“

å½¢å¼è¯­è¨€ç†è®ºä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†ï¼š

1. **è¯­è¨€è®¾è®¡åŸºç¡€**ï¼šç¼–ç¨‹è¯­è¨€è¯­æ³•è®¾è®¡
2. **ç¼–è¯‘å™¨ç†è®º**ï¼šè¯æ³•åˆ†æã€è¯­æ³•åˆ†æ
3. **æ¨¡å¼åŒ¹é…**ï¼šæ­£åˆ™è¡¨è¾¾å¼ã€å­—ç¬¦ä¸²å¤„ç†
4. **è‡ªåŠ¨æœºåº”ç”¨**ï¼šçŠ¶æ€æœºã€åè®®éªŒè¯
5. **è®¡ç®—æ¨¡å‹**ï¼šæŠ½è±¡è®¡ç®—æ¨¡å‹

é€šè¿‡ç³»ç»Ÿæ€§çš„å½¢å¼è¯­è¨€ç†è®ºï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

- è®¾è®¡ç¼–ç¨‹è¯­è¨€è¯­æ³•
- æ„å»ºç¼–è¯‘å™¨å‰ç«¯
- å®ç°æ¨¡å¼åŒ¹é…ç®—æ³•
- éªŒè¯ç³»ç»Ÿåè®®
- åˆ†æè®¡ç®—å¤æ‚æ€§

å½¢å¼è¯­è¨€ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„åŸºç¡€ï¼Œä¸ºç°ä»£è½¯ä»¶å·¥ç¨‹æä¾›äº†é‡è¦çš„ç†è®ºæ”¯æ’‘ã€‚
