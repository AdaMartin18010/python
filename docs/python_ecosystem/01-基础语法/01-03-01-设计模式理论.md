# 03-01 è®¾è®¡æ¨¡å¼ç†è®º (Design Pattern Theory)

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. è®¾è®¡æ¨¡å¼åŸºç¡€](#1-è®¾è®¡æ¨¡å¼åŸºç¡€)
- [2. æ¨¡å¼åˆ†ç±»ç†è®º](#2-æ¨¡å¼åˆ†ç±»ç†è®º)
- [3. æ¨¡å¼å…³ç³»ç†è®º](#3-æ¨¡å¼å…³ç³»ç†è®º)
- [4. æ¨¡å¼é€‰æ‹©ç†è®º](#4-æ¨¡å¼é€‰æ‹©ç†è®º)
- [5. å½¢å¼åŒ–è¡¨ç¤º](#5-å½¢å¼åŒ–è¡¨ç¤º)
- [6. Pythonå®ç°](#6-pythonå®ç°)
- [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## æ¦‚è¿°

è®¾è®¡æ¨¡å¼ç†è®ºæ˜¯è½¯ä»¶å·¥ç¨‹ä¸­å…³äºå¯é‡ç”¨è®¾è®¡è§£å†³æ–¹æ¡ˆçš„ç³»ç»Ÿæ€§ç ”ç©¶ã€‚æœ¬æ–‡æ¡£ä»ç†è®ºè§’åº¦å®šä¹‰è®¾è®¡æ¨¡å¼ï¼Œå»ºç«‹æ¨¡å¼åˆ†ç±»ä½“ç³»ï¼Œå¹¶åˆ†ææ¨¡å¼é—´çš„å…³ç³»ã€‚

## 1. è®¾è®¡æ¨¡å¼åŸºç¡€

### 1.1 è®¾è®¡æ¨¡å¼çš„å®šä¹‰

è®¾è®¡æ¨¡å¼å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$\text{Pattern} = \langle \text{Name}, \text{Problem}, \text{Solution}, \text{Consequences} \rangle$$

å…¶ä¸­ï¼š

- **Name**: æ¨¡å¼çš„æ ‡è¯†ç¬¦
- **Problem**: æ¨¡å¼è¦è§£å†³çš„é—®é¢˜
- **Solution**: æ¨¡å¼æä¾›çš„è§£å†³æ–¹æ¡ˆ
- **Consequences**: åº”ç”¨æ¨¡å¼çš„åæœ

### 1.2 æ¨¡å¼çš„åŸºæœ¬è¦ç´ 

**æ„å›¾ (Intent)**: æ¨¡å¼çš„ç›®çš„å’Œé€‚ç”¨åœºæ™¯

**åŠ¨æœº (Motivation)**: æ¨¡å¼äº§ç”Ÿçš„èƒŒæ™¯å’ŒåŸå› 

**ç»“æ„ (Structure)**: æ¨¡å¼çš„ç±»å›¾å’Œå¯¹è±¡å›¾

**å‚ä¸è€… (Participants)**: æ¨¡å¼ä¸­æ¶‰åŠçš„ç±»å’Œå¯¹è±¡

**åä½œ (Collaborations)**: å‚ä¸è€…ä¹‹é—´çš„äº¤äº’

**å®ç° (Implementation)**: æ¨¡å¼çš„å…·ä½“å®ç°æ–¹æ³•

## 2. æ¨¡å¼åˆ†ç±»ç†è®º

### 2.1 æŒ‰ç›®çš„åˆ†ç±»

**åˆ›å»ºå‹æ¨¡å¼ (Creational Patterns)**: å¤„ç†å¯¹è±¡åˆ›å»ºæœºåˆ¶

$$\text{Creational} = \{\text{Singleton}, \text{Factory}, \text{Builder}, \text{Prototype}, \text{Abstract Factory}\}$$

**ç»“æ„å‹æ¨¡å¼ (Structural Patterns)**: å¤„ç†ç±»å’Œå¯¹è±¡çš„ç»„åˆ

$$\text{Structural} = \{\text{Adapter}, \text{Bridge}, \text{Composite}, \text{Decorator}, \text{Facade}, \text{Flyweight}, \text{Proxy}\}$$

**è¡Œä¸ºå‹æ¨¡å¼ (Behavioral Patterns)**: å¤„ç†å¯¹è±¡é—´çš„é€šä¿¡

$$\text{Behavioral} = \{\text{Chain of Responsibility}, \text{Command}, \text{Interpreter}, \text{Iterator}, \text{Mediator}, \text{Memento}, \text{Observer}, \text{State}, \text{Strategy}, \text{Template Method}, \text{Visitor}\}$$

### 2.2 æŒ‰èŒƒå›´åˆ†ç±»

**ç±»æ¨¡å¼ (Class Patterns)**: å¤„ç†ç±»ä¹‹é—´çš„å…³ç³»

**å¯¹è±¡æ¨¡å¼ (Object Patterns)**: å¤„ç†å¯¹è±¡ä¹‹é—´çš„å…³ç³»

### 2.3 æŒ‰å¤æ‚åº¦åˆ†ç±»

**åŸºç¡€æ¨¡å¼**: ç®€å•ã€å¸¸ç”¨çš„æ¨¡å¼

**å¤åˆæ¨¡å¼**: ç”±å¤šä¸ªåŸºç¡€æ¨¡å¼ç»„åˆè€Œæˆ

**æ¶æ„æ¨¡å¼**: ç³»ç»Ÿçº§åˆ«çš„è®¾è®¡æ¨¡å¼

## 3. æ¨¡å¼å…³ç³»ç†è®º

### 3.1 æ¨¡å¼ç»„åˆ

æ¨¡å¼å¯ä»¥ç»„åˆä½¿ç”¨ï¼š

$$\text{Composite Pattern} = \text{Pattern}_1 \oplus \text{Pattern}_2 \oplus \cdots \oplus \text{Pattern}_n$$

### 3.2 æ¨¡å¼å±‚æ¬¡

**æŠ½è±¡å±‚æ¬¡**: ä»å…·ä½“åˆ°æŠ½è±¡çš„æ¨¡å¼å±‚æ¬¡

**åº”ç”¨å±‚æ¬¡**: ä»ç®€å•åˆ°å¤æ‚çš„åº”ç”¨å±‚æ¬¡

### 3.3 æ¨¡å¼ä¾èµ–

**ç›´æ¥ä¾èµ–**: ä¸€ä¸ªæ¨¡å¼ç›´æ¥ä½¿ç”¨å¦ä¸€ä¸ªæ¨¡å¼

**é—´æ¥ä¾èµ–**: é€šè¿‡ä¸­é—´æ¨¡å¼äº§ç”Ÿçš„ä¾èµ–å…³ç³»

## 4. æ¨¡å¼é€‰æ‹©ç†è®º

### 4.1 é€‰æ‹©æ ‡å‡†

**é—®é¢˜åŒ¹é…åº¦**: æ¨¡å¼ä¸é—®é¢˜çš„åŒ¹é…ç¨‹åº¦

**å¤æ‚åº¦**: æ¨¡å¼çš„å®ç°å¤æ‚åº¦

**å¯ç»´æŠ¤æ€§**: æ¨¡å¼çš„å¯ç»´æŠ¤æ€§

**æ€§èƒ½å½±å“**: æ¨¡å¼å¯¹æ€§èƒ½çš„å½±å“

### 4.2 é€‰æ‹©ç®—æ³•

$$\text{Pattern Selection} = \arg\max_{\text{pattern}} \text{Score}(\text{pattern}, \text{context})$$

å…¶ä¸­ $\text{Score}$ æ˜¯ç»¼åˆè€ƒè™‘å„ç§å› ç´ çš„è¯„ä»·å‡½æ•°ã€‚

## 5. å½¢å¼åŒ–è¡¨ç¤º

### 5.1 æ¨¡å¼è¯­è¨€

**æ¨¡å¼è¯­è¨€**: æè¿°æ¨¡å¼çš„ç¬¦å·ç³»ç»Ÿ

**æ¨¡å¼è¯­æ³•**: æ¨¡å¼ç»„åˆçš„è¯­æ³•è§„åˆ™

**æ¨¡å¼è¯­ä¹‰**: æ¨¡å¼çš„è¯­ä¹‰è§£é‡Š

### 5.2 æ¨¡å¼æ¼”ç®—

**æ¨¡å¼å˜æ¢**: æ¨¡å¼ä¹‹é—´çš„è½¬æ¢è§„åˆ™

**æ¨¡å¼æ¨å¯¼**: ä»å·²çŸ¥æ¨¡å¼æ¨å¯¼æ–°æ¨¡å¼

**æ¨¡å¼éªŒè¯**: éªŒè¯æ¨¡å¼æ­£ç¡®æ€§çš„æ–¹æ³•

## 6. Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Type
from enum import Enum
from dataclasses import dataclass

class PatternType(Enum):
    """æ¨¡å¼ç±»å‹æšä¸¾"""
    CREATIONAL = "creational"
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"

class PatternScope(Enum):
    """æ¨¡å¼èŒƒå›´æšä¸¾"""
    CLASS = "class"
    OBJECT = "object"

@dataclass
class Pattern:
    """è®¾è®¡æ¨¡å¼æ•°æ®ç±»"""
    name: str
    type: PatternType
    scope: PatternScope
    intent: str
    problem: str
    solution: str
    consequences: List[str]
    participants: List[str]
    collaborations: str
    implementation: str

class PatternCatalog:
    """æ¨¡å¼ç›®å½•"""
    
    def __init__(self):
        self.patterns: Dict[str, Pattern] = {}
        self._initialize_patterns()
    
    def _initialize_patterns(self):
        """åˆå§‹åŒ–æ¨¡å¼ç›®å½•"""
        # åˆ›å»ºå‹æ¨¡å¼
        self.patterns["Singleton"] = Pattern(
            name="Singleton",
            type=PatternType.CREATIONAL,
            scope=PatternScope.OBJECT,
            intent="ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹",
            problem="å¦‚ä½•ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Ÿ",
            solution="ä½¿ç”¨ç§æœ‰æ„é€ å‡½æ•°å’Œé™æ€å®ä¾‹",
            consequences=["ä¿è¯å”¯ä¸€æ€§", "å…¨å±€è®¿é—®", "å»¶è¿Ÿåˆå§‹åŒ–"],
            participants=["Singletonç±»"],
            collaborations="å®¢æˆ·ç«¯é€šè¿‡getInstance()è®¿é—®å•ä¾‹",
            implementation="ä½¿ç”¨ç§æœ‰æ„é€ å‡½æ•°å’Œé™æ€æ–¹æ³•"
        )
        
        self.patterns["Factory Method"] = Pattern(
            name="Factory Method",
            type=PatternType.CREATIONAL,
            scope=PatternScope.CLASS,
            intent="å®šä¹‰åˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œè®©å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»",
            problem="å¦‚ä½•åˆ›å»ºå¯¹è±¡è€Œä¸æŒ‡å®šå…·ä½“ç±»ï¼Ÿ",
            solution="å®šä¹‰å·¥å‚æ–¹æ³•ï¼Œå­ç±»é‡å†™ä»¥åˆ›å»ºå…·ä½“å¯¹è±¡",
            consequences=["è§£è€¦", "å¯æ‰©å±•", "ç¬¦åˆå¼€é—­åŸåˆ™"],
            participants=["Creator", "ConcreteCreator", "Product", "ConcreteProduct"],
            collaborations="Creatorè°ƒç”¨å·¥å‚æ–¹æ³•åˆ›å»ºProduct",
            implementation="æŠ½è±¡åŸºç±»å®šä¹‰å·¥å‚æ–¹æ³•ï¼Œå­ç±»å®ç°"
        )
        
        # ç»“æ„å‹æ¨¡å¼
        self.patterns["Adapter"] = Pattern(
            name="Adapter",
            type=PatternType.STRUCTURAL,
            scope=PatternScope.OBJECT,
            intent="å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·æœŸæœ›çš„å¦ä¸€ä¸ªæ¥å£",
            problem="å¦‚ä½•ä½¿ä¸å…¼å®¹çš„æ¥å£èƒ½å¤Ÿä¸€èµ·å·¥ä½œï¼Ÿ",
            solution="åˆ›å»ºé€‚é…å™¨ç±»åŒ…è£…ä¸å…¼å®¹çš„æ¥å£",
            consequences=["å…¼å®¹æ€§", "é€æ˜æ€§", "å¯å¤ç”¨æ€§"],
            participants=["Target", "Adapter", "Adaptee", "Client"],
            collaborations="Clienté€šè¿‡Targetæ¥å£ä½¿ç”¨Adaptee",
            implementation="å¯¹è±¡é€‚é…å™¨æˆ–ç±»é€‚é…å™¨"
        )
        
        # è¡Œä¸ºå‹æ¨¡å¼
        self.patterns["Observer"] = Pattern(
            name="Observer",
            type=PatternType.BEHAVIORAL,
            scope=PatternScope.OBJECT,
            intent="å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»",
            problem="å¦‚ä½•å®ç°å¯¹è±¡é—´çš„æ¾è€¦åˆé€šä¿¡ï¼Ÿ",
            solution="å®šä¹‰è§‚å¯Ÿè€…æ¥å£ï¼Œä¸»é¢˜ç»´æŠ¤è§‚å¯Ÿè€…åˆ—è¡¨",
            consequences=["æ¾è€¦åˆ", "å¯æ‰©å±•", "å¯èƒ½çš„å†…å­˜æ³„æ¼"],
            participants=["Subject", "Observer", "ConcreteSubject", "ConcreteObserver"],
            collaborations="Subjecté€šçŸ¥ObserverçŠ¶æ€å˜åŒ–",
            implementation="ä½¿ç”¨è§‚å¯Ÿè€…åˆ—è¡¨å’Œé€šçŸ¥æœºåˆ¶"
        )
    
    def get_pattern(self, name: str) -> Pattern:
        """è·å–æŒ‡å®šæ¨¡å¼"""
        return self.patterns.get(name)
    
    def get_patterns_by_type(self, pattern_type: PatternType) -> List[Pattern]:
        """æŒ‰ç±»å‹è·å–æ¨¡å¼"""
        return [p for p in self.patterns.values() if p.type == pattern_type]
    
    def get_patterns_by_scope(self, scope: PatternScope) -> List[Pattern]:
        """æŒ‰èŒƒå›´è·å–æ¨¡å¼"""
        return [p for p in self.patterns.values() if p.scope == scope]
    
    def search_patterns(self, keyword: str) -> List[Pattern]:
        """æœç´¢æ¨¡å¼"""
        keyword = keyword.lower()
        return [p for p in self.patterns.values() 
                if keyword in p.name.lower() or 
                   keyword in p.intent.lower() or 
                   keyword in p.problem.lower()]

class PatternAnalyzer:
    """æ¨¡å¼åˆ†æå™¨"""
    
    def __init__(self, catalog: PatternCatalog):
        self.catalog = catalog
    
    def analyze_pattern_relationships(self) -> Dict[str, List[str]]:
        """åˆ†ææ¨¡å¼å…³ç³»"""
        relationships = {}
        
        for pattern_name, pattern in self.catalog.patterns.items():
            relationships[pattern_name] = []
            
            # åŸºäºæ¨¡å¼ç‰¹å¾åˆ†æå…³ç³»
            if "Factory" in pattern_name:
                relationships[pattern_name].extend(["Abstract Factory", "Builder"])
            
            if "Observer" in pattern_name:
                relationships[pattern_name].extend(["Mediator", "Command"])
            
            if "Adapter" in pattern_name:
                relationships[pattern_name].extend(["Bridge", "Decorator"])
        
        return relationships
    
    def calculate_pattern_complexity(self, pattern: Pattern) -> float:
        """è®¡ç®—æ¨¡å¼å¤æ‚åº¦"""
        complexity = 0.0
        
        # åŸºäºå‚ä¸è€…æ•°é‡
        complexity += len(pattern.participants) * 0.5
        
        # åŸºäºåæœæ•°é‡
        complexity += len(pattern.consequences) * 0.3
        
        # åŸºäºç±»å‹
        if pattern.type == PatternType.BEHAVIORAL:
            complexity += 0.5
        
        # åŸºäºèŒƒå›´
        if pattern.scope == PatternScope.CLASS:
            complexity += 0.2
        
        return complexity
    
    def recommend_patterns(self, problem_description: str) -> List[Pattern]:
        """æ¨èæ¨¡å¼"""
        recommendations = []
        
        # ç®€å•çš„å…³é”®è¯åŒ¹é…
        problem_lower = problem_description.lower()
        
        for pattern in self.catalog.patterns.values():
            score = 0
            
            # åŸºäºé—®é¢˜æè¿°åŒ¹é…
            if any(keyword in problem_lower for keyword in pattern.problem.lower().split()):
                score += 2
            
            # åŸºäºæ„å›¾åŒ¹é…
            if any(keyword in problem_lower for keyword in pattern.intent.lower().split()):
                score += 1
            
            if score > 0:
                recommendations.append((pattern, score))
        
        # æŒ‰åˆ†æ•°æ’åº
        recommendations.sort(key=lambda x: x[1], reverse=True)
        return [pattern for pattern, score in recommendations]

class PatternValidator:
    """æ¨¡å¼éªŒè¯å™¨"""
    
    @staticmethod
    def validate_pattern_implementation(pattern: Pattern, implementation: Any) -> bool:
        """éªŒè¯æ¨¡å¼å®ç°"""
        # è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„éªŒè¯é€»è¾‘
        # ä¾‹å¦‚æ£€æŸ¥æ˜¯å¦åŒ…å«å¿…è¦çš„ç»„ä»¶ã€æ–¹æ³•ç­‰
        return True
    
    @staticmethod
    def check_pattern_consistency(pattern: Pattern) -> bool:
        """æ£€æŸ¥æ¨¡å¼ä¸€è‡´æ€§"""
        # æ£€æŸ¥æ¨¡å¼çš„å„ä¸ªç»„æˆéƒ¨åˆ†æ˜¯å¦ä¸€è‡´
        if not pattern.name or not pattern.intent:
            return False
        
        if pattern.type not in PatternType:
            return False
        
        if pattern.scope not in PatternScope:
            return False
        
        return True

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_pattern_theory():
    """æ¼”ç¤ºè®¾è®¡æ¨¡å¼ç†è®º"""
    
    print("=== è®¾è®¡æ¨¡å¼ç†è®ºæ¼”ç¤º ===\n")
    
    # åˆ›å»ºæ¨¡å¼ç›®å½•
    catalog = PatternCatalog()
    
    # è·å–æ‰€æœ‰æ¨¡å¼
    print("æ‰€æœ‰è®¾è®¡æ¨¡å¼:")
    for pattern in catalog.patterns.values():
        print(f"  {pattern.name} ({pattern.type.value})")
    
    print("\n=== æ¨¡å¼åˆ†ç±» ===\n")
    
    # æŒ‰ç±»å‹åˆ†ç±»
    creational_patterns = catalog.get_patterns_by_type(PatternType.CREATIONAL)
    print("åˆ›å»ºå‹æ¨¡å¼:")
    for pattern in creational_patterns:
        print(f"  {pattern.name}: {pattern.intent}")
    
    structural_patterns = catalog.get_patterns_by_type(PatternType.STRUCTURAL)
    print("\nç»“æ„å‹æ¨¡å¼:")
    for pattern in structural_patterns:
        print(f"  {pattern.name}: {pattern.intent}")
    
    behavioral_patterns = catalog.get_patterns_by_type(PatternType.BEHAVIORAL)
    print("\nè¡Œä¸ºå‹æ¨¡å¼:")
    for pattern in behavioral_patterns:
        print(f"  {pattern.name}: {pattern.intent}")
    
    print("\n=== æ¨¡å¼åˆ†æ ===\n")
    
    # æ¨¡å¼åˆ†æ
    analyzer = PatternAnalyzer(catalog)
    
    # åˆ†ææ¨¡å¼å…³ç³»
    relationships = analyzer.analyze_pattern_relationships()
    print("æ¨¡å¼å…³ç³»:")
    for pattern_name, related_patterns in relationships.items():
        if related_patterns:
            print(f"  {pattern_name} -> {related_patterns}")
    
    # è®¡ç®—æ¨¡å¼å¤æ‚åº¦
    print("\næ¨¡å¼å¤æ‚åº¦:")
    for pattern in catalog.patterns.values():
        complexity = analyzer.calculate_pattern_complexity(pattern)
        print(f"  {pattern.name}: {complexity:.2f}")
    
    # æ¨¡å¼æ¨è
    print("\n=== æ¨¡å¼æ¨è ===\n")
    
    problem = "éœ€è¦ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹"
    recommendations = analyzer.recommend_patterns(problem)
    print(f"é—®é¢˜: {problem}")
    print("æ¨èæ¨¡å¼:")
    for pattern in recommendations[:3]:
        print(f"  {pattern.name}: {pattern.intent}")
    
    print("\n=== æ¨¡å¼éªŒè¯ ===\n")
    
    # æ¨¡å¼éªŒè¯
    validator = PatternValidator()
    
    for pattern in catalog.patterns.values():
        is_consistent = validator.check_pattern_consistency(pattern)
        print(f"{pattern.name} ä¸€è‡´æ€§æ£€æŸ¥: {'é€šè¿‡' if is_consistent else 'å¤±è´¥'}")

if __name__ == "__main__":
    demonstrate_pattern_theory()
```

## 7. å‚è€ƒæ–‡çŒ®

1. Gamma, E., et al. (1994). "Design Patterns: Elements of Reusable Object-Oriented Software".
2. Freeman, E., et al. (2004). "Head First Design Patterns".
3. Martin, R. C. (2000). "Design Principles and Design Patterns".
4. Buschmann, F., et al. (1996). "Pattern-Oriented Software Architecture".

---

**ç›¸å…³æ–‡æ¡£**:

- [06-01-åˆ›å»ºå‹æ¨¡å¼](./../06-ç»„ä»¶ç®—æ³•/06-01-åˆ›å»ºå‹æ¨¡å¼.md)
- [06-02-ç»“æ„å‹æ¨¡å¼](./../06-ç»„ä»¶ç®—æ³•/06-02-ç»“æ„å‹æ¨¡å¼.md)
- [06-03-è¡Œä¸ºå‹æ¨¡å¼](./../06-ç»„ä»¶ç®—æ³•/06-03-è¡Œä¸ºå‹æ¨¡å¼.md)

**æœ€åæ›´æ–°**: 2024-01-XX  
**ç‰ˆæœ¬**: 1.0.0
