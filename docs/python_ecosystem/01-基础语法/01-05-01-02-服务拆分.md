# æœåŠ¡æ‹†åˆ†

## ğŸ“‹ æ¦‚è¿°

æœåŠ¡æ‹†åˆ†æ˜¯å¾®æœåŠ¡æ¶æ„è®¾è®¡çš„æ ¸å¿ƒç¯èŠ‚ï¼Œæ¶‰åŠå¦‚ä½•å°†å•ä½“åº”ç”¨åˆ†è§£ä¸ºå¤šä¸ªç‹¬ç«‹çš„å¾®æœåŠ¡ã€‚æœ¬æ–‡æ¡£æä¾›æœåŠ¡æ‹†åˆ†çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æœåŠ¡æ‹†åˆ†å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**æœåŠ¡æ‹†åˆ†å››å…ƒç»„**:
$$\mathcal{SS} = (M, S, R, C)$$

å…¶ä¸­ï¼š

- $M = \{m_1, m_2, ..., m_n\}$ æ˜¯æ¨¡å—é›†åˆ
- $S = \{s_1, s_2, ..., s_k\}$ æ˜¯æœåŠ¡é›†åˆ
- $R: M \times M \rightarrow [0, 1]$ æ˜¯æ¨¡å—é—´å…³ç³»å‡½æ•°
- $C: M \rightarrow S$ æ˜¯æ¨¡å—åˆ°æœåŠ¡çš„æ˜ å°„å‡½æ•°

#### 1.2 æ‹†åˆ†åŸåˆ™

**é«˜å†…èšä½è€¦åˆ**:
$$\forall s_i \in S: cohesion(s_i) > \alpha \land coupling(s_i) < \beta$$

**å•ä¸€èŒè´£**:
$$\forall s \in S: |responsibilities(s)| = 1$$

**æ•°æ®ä¸€è‡´æ€§è¾¹ç•Œ**:
$$\forall s_i, s_j \in S, i \neq j: data(s_i) \cap data(s_j) = \emptyset$$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Set, Optional, Any, Tuple, Callable
from collections import defaultdict
import time
import uuid
import asyncio
import json
import logging
import threading
from concurrent.futures import ThreadPoolExecutor
import networkx as nx
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ModuleType(Enum):
    """æ¨¡å—ç±»å‹æšä¸¾"""
    CONTROLLER = "controller"
    SERVICE = "service"
    REPOSITORY = "repository"
    MODEL = "model"
    UTILITY = "utility"

class ServiceType(Enum):
    """æœåŠ¡ç±»å‹æšä¸¾"""
    API = "api"
    WORKER = "worker"
    DATABASE = "database"
    CACHE = "cache"
    MESSAGE_QUEUE = "message_queue"

@dataclass
class Module:
    """æ¨¡å—å®šä¹‰"""
    id: str
    name: str
    module_type: ModuleType
    dependencies: List[str] = field(default_factory=list)
    dependents: List[str] = field(default_factory=list)
    data_entities: List[str] = field(default_factory=list)
    business_functions: List[str] = field(default_factory=list)
    complexity: float = 1.0
    size: int = 0
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

@dataclass
class Service:
    """æœåŠ¡å®šä¹‰"""
    id: str
    name: str
    service_type: ServiceType
    modules: List[Module] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)
    data_entities: List[str] = field(default_factory=list)
    api_endpoints: List[str] = field(default_factory=list)
    database_schemas: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())

class ServiceSplitter:
    """æœåŠ¡æ‹†åˆ†å™¨"""
    
    def __init__(self):
        self.modules: Dict[str, Module] = {}
        self.services: Dict[str, Service] = {}
        self.dependency_graph = nx.DiGraph()
        self.similarity_matrix = None
        
    def add_module(self, module: Module):
        """æ·»åŠ æ¨¡å—"""
        self.modules[module.id] = module
        
        # æ·»åŠ åˆ°ä¾èµ–å›¾
        self.dependency_graph.add_node(module.id, **module.__dict__)
        
        # æ·»åŠ ä¾èµ–è¾¹
        for dep in module.dependencies:
            if dep in self.modules:
                self.dependency_graph.add_edge(dep, module.id)
    
    def calculate_similarity_matrix(self):
        """è®¡ç®—ç›¸ä¼¼åº¦çŸ©é˜µ"""
        module_ids = list(self.modules.keys())
        n = len(module_ids)
        self.similarity_matrix = np.zeros((n, n))
        
        for i, module_id1 in enumerate(module_ids):
            for j, module_id2 in enumerate(module_ids):
                if i == j:
                    self.similarity_matrix[i][j] = 1.0
                else:
                    similarity = self._calculate_module_similarity(
                        self.modules[module_id1],
                        self.modules[module_id2]
                    )
                    self.similarity_matrix[i][j] = similarity
                    self.similarity_matrix[j][i] = similarity
    
    def _calculate_module_similarity(self, module1: Module, module2: Module) -> float:
        """è®¡ç®—æ¨¡å—ç›¸ä¼¼åº¦"""
        # æ•°æ®å®ä½“ç›¸ä¼¼åº¦
        data_similarity = self._calculate_set_similarity(
            set(module1.data_entities),
            set(module2.data_entities)
        )
        
        # ä¸šåŠ¡åŠŸèƒ½ç›¸ä¼¼åº¦
        function_similarity = self._calculate_set_similarity(
            set(module1.business_functions),
            set(module2.business_functions)
        )
        
        # ä¾èµ–å…³ç³»ç›¸ä¼¼åº¦
        dependency_similarity = self._calculate_set_similarity(
            set(module1.dependencies),
            set(module2.dependencies)
        )
        
        # åŠ æƒå¹³å‡
        weights = [0.4, 0.4, 0.2]  # æ•°æ®å®ä½“æƒé‡æœ€é«˜
        similarity = (
            weights[0] * data_similarity +
            weights[1] * function_similarity +
            weights[2] * dependency_similarity
        )
        
        return similarity
    
    def _calculate_set_similarity(self, set1: Set[str], set2: Set[str]) -> float:
        """è®¡ç®—é›†åˆç›¸ä¼¼åº¦ï¼ˆJaccardç›¸ä¼¼åº¦ï¼‰"""
        if not set1 and not set2:
            return 1.0
        intersection = len(set1.intersection(set2))
        union = len(set1.union(set2))
        return intersection / union if union > 0 else 0.0
    
    def split_by_similarity(self, num_services: int) -> Dict[str, Service]:
        """åŸºäºç›¸ä¼¼åº¦æ‹†åˆ†æœåŠ¡"""
        if self.similarity_matrix is None:
            self.calculate_similarity_matrix()
        
        module_ids = list(self.modules.keys())
        
        # ä½¿ç”¨K-meansèšç±»
        kmeans = KMeans(n_clusters=num_services, random_state=42)
        cluster_labels = kmeans.fit_predict(self.similarity_matrix)
        
        # åˆ›å»ºæœåŠ¡
        services = {}
        for i in range(num_services):
            cluster_modules = [
                module_id for j, module_id in enumerate(module_ids)
                if cluster_labels[j] == i
            ]
            
            if cluster_modules:
                service = self._create_service_from_modules(cluster_modules, f"service_{i}")
                services[service.id] = service
        
        self.services = services
        return services
    
    def split_by_dependency(self, max_services: int = 10) -> Dict[str, Service]:
        """åŸºäºä¾èµ–å…³ç³»æ‹†åˆ†æœåŠ¡"""
        # ä½¿ç”¨å¼ºè¿é€šåˆ†é‡ç®—æ³•
        strongly_connected_components = list(nx.strongly_connected_components(self.dependency_graph))
        
        # å¦‚æœå¼ºè¿é€šåˆ†é‡å¤ªå¤šï¼Œè¿›è¡Œåˆå¹¶
        if len(strongly_connected_components) > max_services:
            strongly_connected_components = self._merge_components(strongly_connected_components, max_services)
        
        # åˆ›å»ºæœåŠ¡
        services = {}
        for i, component in enumerate(strongly_connected_components):
            if component:
                service = self._create_service_from_modules(list(component), f"service_{i}")
                services[service.id] = service
        
        self.services = services
        return services
    
    def _merge_components(self, components: List[Set[str]], max_services: int) -> List[Set[str]]:
        """åˆå¹¶ç»„ä»¶"""
        while len(components) > max_services:
            # æ‰¾åˆ°æœ€å°çš„ä¸¤ä¸ªç»„ä»¶è¿›è¡Œåˆå¹¶
            min_size = float('inf')
            merge_indices = (0, 1)
            
            for i in range(len(components)):
                for j in range(i + 1, len(components)):
                    combined_size = len(components[i]) + len(components[j])
                    if combined_size < min_size:
                        min_size = combined_size
                        merge_indices = (i, j)
            
            # åˆå¹¶ç»„ä»¶
            i, j = merge_indices
            components[i] = components[i].union(components[j])
            components.pop(j)
        
        return components
    
    def split_by_business_domain(self, domain_mapping: Dict[str, str]) -> Dict[str, Service]:
        """åŸºäºä¸šåŠ¡é¢†åŸŸæ‹†åˆ†æœåŠ¡"""
        domain_modules = defaultdict(list)
        
        for module_id, module in self.modules.items():
            # æ ¹æ®ä¸šåŠ¡åŠŸèƒ½ç¡®å®šé¢†åŸŸ
            domain = self._determine_domain(module, domain_mapping)
            domain_modules[domain].append(module_id)
        
        # åˆ›å»ºæœåŠ¡
        services = {}
        for domain, module_ids in domain_modules.items():
            if module_ids:
                service = self._create_service_from_modules(module_ids, domain)
                services[service.id] = service
        
        self.services = services
        return services
    
    def _determine_domain(self, module: Module, domain_mapping: Dict[str, str]) -> str:
        """ç¡®å®šæ¨¡å—æ‰€å±é¢†åŸŸ"""
        # æ ¹æ®ä¸šåŠ¡åŠŸèƒ½åŒ¹é…é¢†åŸŸ
        for function in module.business_functions:
            for keyword, domain in domain_mapping.items():
                if keyword.lower() in function.lower():
                    return domain
        
        # æ ¹æ®æ•°æ®å®ä½“åŒ¹é…é¢†åŸŸ
        for entity in module.data_entities:
            for keyword, domain in domain_mapping.items():
                if keyword.lower() in entity.lower():
                    return domain
        
        return "general"  # é»˜è®¤é¢†åŸŸ
    
    def _create_service_from_modules(self, module_ids: List[str], service_name: str) -> Service:
        """ä»æ¨¡å—åˆ›å»ºæœåŠ¡"""
        modules = [self.modules[module_id] for module_id in module_ids]
        
        # æ”¶é›†æœåŠ¡ä¿¡æ¯
        all_data_entities = []
        all_business_functions = []
        all_dependencies = []
        
        for module in modules:
            all_data_entities.extend(module.data_entities)
            all_business_functions.extend(module.business_functions)
            all_dependencies.extend(module.dependencies)
        
        # å»é‡
        all_data_entities = list(set(all_data_entities))
        all_business_functions = list(set(all_business_functions))
        all_dependencies = list(set(all_dependencies))
        
        # ç¡®å®šæœåŠ¡ç±»å‹
        service_type = self._determine_service_type(modules)
        
        # ç”ŸæˆAPIç«¯ç‚¹
        api_endpoints = self._generate_api_endpoints(modules)
        
        # ç”Ÿæˆæ•°æ®åº“æ¨¡å¼
        database_schemas = self._generate_database_schemas(all_data_entities)
        
        service = Service(
            name=service_name,
            service_type=service_type,
            modules=modules,
            dependencies=all_dependencies,
            data_entities=all_data_entities,
            api_endpoints=api_endpoints,
            database_schemas=database_schemas
        )
        
        return service
    
    def _determine_service_type(self, modules: List[Module]) -> ServiceType:
        """ç¡®å®šæœåŠ¡ç±»å‹"""
        # æ£€æŸ¥æ˜¯å¦æœ‰æ§åˆ¶å™¨æ¨¡å—
        has_controller = any(m.module_type == ModuleType.CONTROLLER for m in modules)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æœåŠ¡æ¨¡å—
        has_service = any(m.module_type == ModuleType.SERVICE for m in modules)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®è®¿é—®æ¨¡å—
        has_repository = any(m.module_type == ModuleType.REPOSITORY for m in modules)
        
        if has_controller and has_service:
            return ServiceType.API
        elif has_repository and not has_controller:
            return ServiceType.DATABASE
        elif has_service and not has_controller:
            return ServiceType.WORKER
        else:
            return ServiceType.API  # é»˜è®¤ç±»å‹
    
    def _generate_api_endpoints(self, modules: List[Module]) -> List[str]:
        """ç”ŸæˆAPIç«¯ç‚¹"""
        endpoints = []
        
        for module in modules:
            if module.module_type == ModuleType.CONTROLLER:
                # æ ¹æ®ä¸šåŠ¡åŠŸèƒ½ç”Ÿæˆç«¯ç‚¹
                for function in module.business_functions:
                    if "create" in function.lower() or "add" in function.lower():
                        endpoints.append(f"POST /{module.name}")
                    elif "get" in function.lower() or "find" in function.lower():
                        endpoints.append(f"GET /{module.name}")
                    elif "update" in function.lower() or "modify" in function.lower():
                        endpoints.append(f"PUT /{module.name}")
                    elif "delete" in function.lower() or "remove" in function.lower():
                        endpoints.append(f"DELETE /{module.name}")
        
        return list(set(endpoints))
    
    def _generate_database_schemas(self, data_entities: List[str]) -> List[str]:
        """ç”Ÿæˆæ•°æ®åº“æ¨¡å¼"""
        schemas = []
        
        for entity in data_entities:
            # ç”Ÿæˆè¡¨ç»“æ„
            schema = f"""
            CREATE TABLE {entity.lower()} (
                id VARCHAR(36) PRIMARY KEY,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            );
            """
            schemas.append(schema)
        
        return schemas
    
    def analyze_coupling(self) -> Dict[str, float]:
        """åˆ†æè€¦åˆåº¦"""
        coupling_scores = {}
        
        for service_id, service in self.services.items():
            # è®¡ç®—æœåŠ¡é—´çš„ä¾èµ–å…³ç³»
            external_dependencies = 0
            internal_modules = {m.id for m in service.modules}
            
            for module in service.modules:
                for dep in module.dependencies:
                    if dep not in internal_modules:
                        external_dependencies += 1
            
            # è®¡ç®—è€¦åˆåº¦
            total_dependencies = sum(len(m.dependencies) for m in service.modules)
            coupling_score = external_dependencies / total_dependencies if total_dependencies > 0 else 0.0
            
            coupling_scores[service_id] = coupling_score
        
        return coupling_scores
    
    def analyze_cohesion(self) -> Dict[str, float]:
        """åˆ†æå†…èšåº¦"""
        cohesion_scores = {}
        
        for service_id, service in self.services.items():
            if not service.modules:
                cohesion_scores[service_id] = 0.0
                continue
            
            # è®¡ç®—æ¨¡å—é—´çš„ç›¸ä¼¼åº¦
            total_similarity = 0.0
            pair_count = 0
            
            for i, module1 in enumerate(service.modules):
                for j, module2 in enumerate(service.modules[i+1:], i+1):
                    similarity = self._calculate_module_similarity(module1, module2)
                    total_similarity += similarity
                    pair_count += 1
            
            cohesion_score = total_similarity / pair_count if pair_count > 0 else 1.0
            cohesion_scores[service_id] = cohesion_score
        
        return cohesion_scores
    
    def visualize_dependency_graph(self, filename: str = "dependency_graph.png"):
        """å¯è§†åŒ–ä¾èµ–å›¾"""
        plt.figure(figsize=(12, 8))
        
        # ç»˜åˆ¶ä¾èµ–å›¾
        pos = nx.spring_layout(self.dependency_graph)
        nx.draw(
            self.dependency_graph,
            pos,
            with_labels=True,
            node_color='lightblue',
            node_size=1000,
            font_size=8,
            arrows=True
        )
        
        plt.title("Module Dependency Graph")
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()
    
    def generate_split_report(self) -> Dict[str, Any]:
        """ç”Ÿæˆæ‹†åˆ†æŠ¥å‘Š"""
        coupling_scores = self.analyze_coupling()
        cohesion_scores = self.analyze_cohesion()
        
        report = {
            "summary": {
                "total_modules": len(self.modules),
                "total_services": len(self.services),
                "average_coupling": sum(coupling_scores.values()) / len(coupling_scores) if coupling_scores else 0,
                "average_cohesion": sum(cohesion_scores.values()) / len(cohesion_scores) if cohesion_scores else 0
            },
            "services": {}
        }
        
        for service_id, service in self.services.items():
            report["services"][service_id] = {
                "name": service.name,
                "type": service.service_type.value,
                "module_count": len(service.modules),
                "coupling_score": coupling_scores.get(service_id, 0.0),
                "cohesion_score": cohesion_scores.get(service_id, 0.0),
                "data_entities": service.data_entities,
                "api_endpoints": service.api_endpoints,
                "dependencies": service.dependencies
            }
        
        return report
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
def demonstrate_service_splitting():
    """æ¼”ç¤ºæœåŠ¡æ‹†åˆ†"""
    # åˆ›å»ºæœåŠ¡æ‹†åˆ†å™¨
    splitter = ServiceSplitter()
    
    # å®šä¹‰æ¨¡å—ï¼ˆæ¨¡æ‹Ÿç”µå•†ç³»ç»Ÿï¼‰
    modules = [
        Module(
            name="UserController",
            module_type=ModuleType.CONTROLLER,
            dependencies=["UserService", "UserRepository"],
            data_entities=["User", "Profile"],
            business_functions=["create_user", "get_user", "update_user", "delete_user"],
            complexity=1.0,
            size=500
        ),
        Module(
            name="UserService",
            module_type=ModuleType.SERVICE,
            dependencies=["UserRepository", "EmailService"],
            data_entities=["User", "Profile"],
            business_functions=["validate_user", "send_welcome_email"],
            complexity=1.5,
            size=800
        ),
        Module(
            name="UserRepository",
            module_type=ModuleType.REPOSITORY,
            dependencies=["Database"],
            data_entities=["User", "Profile"],
            business_functions=["save_user", "find_user", "update_user"],
            complexity=1.0,
            size=300
        ),
        Module(
            name="OrderController",
            module_type=ModuleType.CONTROLLER,
            dependencies=["OrderService", "OrderRepository"],
            data_entities=["Order", "OrderItem"],
            business_functions=["create_order", "get_order", "update_order"],
            complexity=1.2,
            size=600
        ),
        Module(
            name="OrderService",
            module_type=ModuleType.SERVICE,
            dependencies=["OrderRepository", "InventoryService", "PaymentService"],
            data_entities=["Order", "OrderItem"],
            business_functions=["process_order", "calculate_total", "check_inventory"],
            complexity=2.0,
            size=1000
        ),
        Module(
            name="OrderRepository",
            module_type=ModuleType.REPOSITORY,
            dependencies=["Database"],
            data_entities=["Order", "OrderItem"],
            business_functions=["save_order", "find_order", "update_order"],
            complexity=1.0,
            size=400
        ),
        Module(
            name="ProductController",
            module_type=ModuleType.CONTROLLER,
            dependencies=["ProductService", "ProductRepository"],
            data_entities=["Product", "Category"],
            business_functions=["create_product", "get_product", "update_product"],
            complexity=1.0,
            size=400
        ),
        Module(
            name="ProductService",
            module_type=ModuleType.SERVICE,
            dependencies=["ProductRepository"],
            data_entities=["Product", "Category"],
            business_functions=["validate_product", "calculate_price"],
            complexity=1.3,
            size=600
        ),
        Module(
            name="ProductRepository",
            module_type=ModuleType.REPOSITORY,
            dependencies=["Database"],
            data_entities=["Product", "Category"],
            business_functions=["save_product", "find_product", "update_product"],
            complexity=1.0,
            size=300
        ),
        Module(
            name="PaymentService",
            module_type=ModuleType.SERVICE,
            dependencies=["PaymentGateway"],
            data_entities=["Payment", "Transaction"],
            business_functions=["process_payment", "refund_payment"],
            complexity=2.5,
            size=1200
        ),
        Module(
            name="InventoryService",
            module_type=ModuleType.SERVICE,
            dependencies=["InventoryRepository"],
            data_entities=["Inventory", "Stock"],
            business_functions=["check_stock", "update_stock", "reserve_stock"],
            complexity=1.8,
            size=900
        )
    ]
    
    # æ·»åŠ æ¨¡å—åˆ°æ‹†åˆ†å™¨
    for module in modules:
        splitter.add_module(module)
    
    print("=== Service Splitting Demo ===")
    
    # æ–¹æ³•1: åŸºäºç›¸ä¼¼åº¦æ‹†åˆ†
    print("\n1. Splitting by Similarity:")
    services_by_similarity = splitter.split_by_similarity(num_services=4)
    for service_id, service in services_by_similarity.items():
        print(f"Service {service.name}: {len(service.modules)} modules")
        print(f"  Data entities: {service.data_entities}")
        print(f"  API endpoints: {service.api_endpoints}")
    
    # æ–¹æ³•2: åŸºäºä¾èµ–å…³ç³»æ‹†åˆ†
    print("\n2. Splitting by Dependency:")
    splitter.services.clear()  # æ¸…é™¤ä¹‹å‰çš„ç»“æœ
    services_by_dependency = splitter.split_by_dependency(max_services=5)
    for service_id, service in services_by_dependency.items():
        print(f"Service {service.name}: {len(service.modules)} modules")
        print(f"  Dependencies: {service.dependencies}")
    
    # æ–¹æ³•3: åŸºäºä¸šåŠ¡é¢†åŸŸæ‹†åˆ†
    print("\n3. Splitting by Business Domain:")
    splitter.services.clear()  # æ¸…é™¤ä¹‹å‰çš„ç»“æœ
    domain_mapping = {
        "user": "user",
        "order": "order",
        "product": "product",
        "payment": "payment",
        "inventory": "inventory"
    }
    services_by_domain = splitter.split_by_business_domain(domain_mapping)
    for service_id, service in services_by_domain.items():
        print(f"Service {service.name}: {len(service.modules)} modules")
        print(f"  Business functions: {service.data_entities}")
    
    # ç”Ÿæˆåˆ†ææŠ¥å‘Š
    print("\n4. Analysis Report:")
    report = splitter.generate_split_report()
    print(f"Total modules: {report['summary']['total_modules']}")
    print(f"Total services: {report['summary']['total_services']}")
    print(f"Average coupling: {report['summary']['average_coupling']:.3f}")
    print(f"Average cohesion: {report['summary']['average_cohesion']:.3f}")
    
    # å¯è§†åŒ–ä¾èµ–å›¾
    splitter.visualize_dependency_graph("service_splitting_dependency_graph.png")
    print("\nDependency graph saved as 'service_splitting_dependency_graph.png'")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    demonstrate_service_splitting()
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**ç›¸ä¼¼åº¦è®¡ç®—**: $O(n^2)$ å…¶ä¸­ $n$ æ˜¯æ¨¡å—æ•°é‡
**èšç±»ç®—æ³•**: $O(k \cdot n \cdot i)$ å…¶ä¸­ $k$ æ˜¯æœåŠ¡æ•°é‡ï¼Œ$i$ æ˜¯è¿­ä»£æ¬¡æ•°
**ä¾èµ–åˆ†æ**: $O(n + e)$ å…¶ä¸­ $e$ æ˜¯ä¾èµ–è¾¹æ•°é‡
**é¢†åŸŸæ‹†åˆ†**: $O(n \cdot d)$ å…¶ä¸­ $d$ æ˜¯é¢†åŸŸå…³é”®è¯æ•°é‡

#### 4.2 ç©ºé—´å¤æ‚åº¦

**ç›¸ä¼¼åº¦çŸ©é˜µ**: $O(n^2)$
**ä¾èµ–å›¾**: $O(n + e)$
**æœåŠ¡æ˜ å°„**: $O(n)$

### 5. æ‹†åˆ†è´¨é‡è¯„ä¼°

#### 5.1 è€¦åˆåº¦æŒ‡æ ‡

**å¤–éƒ¨ä¾èµ–æ¯”ä¾‹**: $\frac{external\_dependencies}{total\_dependencies}$
**æœåŠ¡é—´è°ƒç”¨é¢‘ç‡**: $\frac{inter\_service\_calls}{total\_calls}$
**æ•°æ®å…±äº«ç¨‹åº¦**: $\frac{shared\_data}{total\_data}$

#### 5.2 å†…èšåº¦æŒ‡æ ‡

**åŠŸèƒ½ç›¸ä¼¼åº¦**: æ¨¡å—é—´ä¸šåŠ¡åŠŸèƒ½çš„ç›¸ä¼¼ç¨‹åº¦
**æ•°æ®ç›¸å…³æ€§**: æ¨¡å—é—´æ•°æ®å®ä½“çš„ç›¸å…³ç¨‹åº¦
**ä¾èµ–ç´§å¯†æ€§**: æ¨¡å—é—´ä¾èµ–å…³ç³»çš„ç´§å¯†ç¨‹åº¦

## ğŸ”— ç›¸å…³é“¾æ¥

- [å¾®æœåŠ¡åŸºç¡€](./05-01-01-å¾®æœåŠ¡åŸºç¡€.md)
- [è½¯ä»¶æ¶æ„åŸºç¡€](../../03-å…·ä½“ç§‘å­¦/03-02-è½¯ä»¶æ¶æ„/03-02-01-è½¯ä»¶æ¶æ„åŸºç¡€.md)
- [è®¾è®¡æ¨¡å¼åŸºç¡€](../../03-å…·ä½“ç§‘å­¦/03-01-è®¾è®¡æ¨¡å¼/03-01-01-è®¾è®¡æ¨¡å¼åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Evans, E. (2003). "Domain-Driven Design". Addison-Wesley.
2. Vernon, V. (2013). "Implementing Domain-Driven Design". Addison-Wesley.
3. Richardson, C. (2018). "Microservices Patterns". Manning Publications.

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant
