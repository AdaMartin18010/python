# 02-04-02 è‡ªåŠ¨æœºç†è®º

## ğŸ“‹ æ¦‚è¿°

è‡ªåŠ¨æœºç†è®ºæ˜¯å½¢å¼è¯­è¨€ç†è®ºçš„æ ¸å¿ƒï¼Œç ”ç©¶æŠ½è±¡çš„è®¡ç®—æ¨¡å‹ã€‚æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨å„ç§è‡ªåŠ¨æœºçš„å½¢å¼åŒ–å®šä¹‰ã€ç­‰ä»·æ€§å…³ç³»ã€è½¬æ¢ç®—æ³•å’Œå®é™…åº”ç”¨ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.1** (è‡ªåŠ¨æœº)
è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªæŠ½è±¡çš„è®¡ç®—æ¨¡å‹ï¼Œèƒ½å¤Ÿæ ¹æ®è¾“å…¥åºåˆ—è¿›è¡ŒçŠ¶æ€è½¬æ¢å¹¶äº§ç”Ÿè¾“å‡ºã€‚

**å®šä¹‰ 1.2** (é…ç½®)
è‡ªåŠ¨æœºåœ¨æŸä¸€æ—¶åˆ»çš„é…ç½®æ˜¯ä¸€ä¸ªå…ƒç»„ $(q, w, \gamma)$ï¼Œå…¶ä¸­ï¼š

- $q$ æ˜¯å½“å‰çŠ¶æ€
- $w$ æ˜¯å‰©ä½™è¾“å…¥
- $\gamma$ æ˜¯å­˜å‚¨å†…å®¹ï¼ˆæ ˆã€å¸¦ç­‰ï¼‰

**å®šä¹‰ 1.3** (è®¡ç®—)
è‡ªåŠ¨æœºçš„è®¡ç®—æ˜¯é…ç½®åºåˆ— $C_0 \vdash C_1 \vdash \cdots \vdash C_n$ï¼Œå…¶ä¸­æ¯ä¸ª $C_i \vdash C_{i+1}$ è¡¨ç¤ºä¸€æ­¥è®¡ç®—ã€‚

### 1.2 è‡ªåŠ¨æœºå±‚æ¬¡ç»“æ„

æ ¹æ®è®¡ç®—èƒ½åŠ›ï¼Œè‡ªåŠ¨æœºå¯ä»¥åˆ†ä¸ºä»¥ä¸‹å±‚æ¬¡ï¼š

1. **æœ‰é™è‡ªåŠ¨æœº**: æ­£åˆ™è¯­è¨€
2. **ä¸‹æ¨è‡ªåŠ¨æœº**: ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
3. **çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº**: ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
4. **å›¾çµæœº**: é€’å½’å¯æšä¸¾è¯­è¨€

## 2. æœ‰é™è‡ªåŠ¨æœº

### 2.1 ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 2.1** (DFA)
ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$M = (Q, \Sigma, \delta, q_0, F)$$

å…¶ä¸­ï¼š

- $Q$ ä¸ºæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ ä¸ºæœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ ä¸ºè½¬ç§»å‡½æ•°
- $q_0 \in Q$ ä¸ºåˆå§‹çŠ¶æ€
- $F \subseteq Q$ ä¸ºæ¥å—çŠ¶æ€é›†åˆ

**å®šä¹‰ 2.2** (æ‰©å±•è½¬ç§»å‡½æ•°)
DFAçš„æ‰©å±•è½¬ç§»å‡½æ•°å®šä¹‰ä¸ºï¼š
$$\hat{\delta}(q, \epsilon) = q$$
$$\hat{\delta}(q, wa) = \delta(\hat{\delta}(q, w), a)$$

**å®šä¹‰ 2.3** (è¯­è¨€æ¥å—)
DFA $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \in F\}$$

### 2.2 éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 2.4** (NFA)
éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$M = (Q, \Sigma, \delta, q_0, F)$$

å…¶ä¸­ï¼š

- $Q$ ä¸ºæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ ä¸ºæœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times (\Sigma \cup \{\epsilon\}) \rightarrow 2^Q$ ä¸ºè½¬ç§»å‡½æ•°
- $q_0 \in Q$ ä¸ºåˆå§‹çŠ¶æ€
- $F \subseteq Q$ ä¸ºæ¥å—çŠ¶æ€é›†åˆ

**å®šä¹‰ 2.5** (Îµé—­åŒ…)
çŠ¶æ€é›†åˆ $S$ çš„Îµé—­åŒ…å®šä¹‰ä¸ºï¼š
$$\epsilon\text{-closure}(S) = \{q \mid \exists p \in S: p \stackrel{\epsilon^*}{\rightarrow} q\}$$

### 2.3 ç­‰ä»·æ€§è¯æ˜

**å®šç† 2.1** (DFAä¸NFAç­‰ä»·æ€§)
å¯¹äºä»»æ„NFA $M$ï¼Œå­˜åœ¨ç­‰ä»·çš„DFA $M'$ï¼Œä½¿å¾— $L(M) = L(M')$ã€‚

**è¯æ˜**:
ä½¿ç”¨å­é›†æ„é€ æ³•ã€‚è®¾NFA $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œæ„é€ DFA $M' = (Q', \Sigma, \delta', q_0', F')$ï¼š

1. $Q' = 2^Q$ (Qçš„å¹‚é›†)
2. $q_0' = \epsilon\text{-closure}(\{q_0\})$
3. $F' = \{S \subseteq Q \mid S \cap F \neq \emptyset\}$
4. $\delta'(S, a) = \epsilon\text{-closure}(\bigcup_{q \in S} \delta(q, a))$

**å¼•ç† 2.1** (å­é›†æ„é€ æ­£ç¡®æ€§)
å¯¹äºä»»æ„è¾“å…¥å­—ç¬¦ä¸² $w$ï¼Œ$\hat{\delta'}(q_0', w) = \epsilon\text{-closure}(\{q \mid \exists p \in q_0': p \stackrel{w}{\rightarrow} q\})$

**è¯æ˜**:
ä½¿ç”¨æ•°å­¦å½’çº³æ³•ï¼š

- åŸºç¡€æƒ…å†µï¼š$w = \epsilon$ï¼Œæ˜¾ç„¶æˆç«‹
- å½’çº³æ­¥éª¤ï¼šå‡è®¾å¯¹ $|w| = n$ æˆç«‹ï¼Œè¯æ˜å¯¹ $|w| = n+1$ æˆç«‹

## 3. ä¸‹æ¨è‡ªåŠ¨æœº

### 3.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 3.1** (PDA)
ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$$

å…¶ä¸­ï¼š

- $Q$ ä¸ºæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ ä¸ºè¾“å…¥å­—æ¯è¡¨
- $\Gamma$ ä¸ºæ ˆå­—æ¯è¡¨
- $\delta: Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow 2^{Q \times \Gamma^*}$ ä¸ºè½¬ç§»å‡½æ•°
- $q_0 \in Q$ ä¸ºåˆå§‹çŠ¶æ€
- $Z_0 \in \Gamma$ ä¸ºåˆå§‹æ ˆç¬¦å·
- $F \subseteq Q$ ä¸ºæ¥å—çŠ¶æ€é›†åˆ

**å®šä¹‰ 3.2** (PDAé…ç½®)
PDAçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, w, \gamma)$ï¼Œå…¶ä¸­ï¼š

- $q$ æ˜¯å½“å‰çŠ¶æ€
- $w$ æ˜¯å‰©ä½™è¾“å…¥
- $\gamma$ æ˜¯æ ˆå†…å®¹

**å®šä¹‰ 3.3** (PDAè½¬ç§»)
é…ç½® $(q, aw, Z\gamma)$ è½¬ç§»åˆ° $(p, w, \alpha\gamma)$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$(p, \alpha) \in \delta(q, a, Z)$$

### 3.2 ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº

**å®šä¹‰ 3.4** (DPDA)
ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„PDAï¼š

1. å¯¹äºä»»æ„ $(q, a, Z)$ï¼Œ$|\delta(q, a, Z)| \leq 1$
2. å¯¹äºä»»æ„ $(q, \epsilon, Z)$ï¼Œ$|\delta(q, \epsilon, Z)| \leq 1$
3. å¦‚æœ $\delta(q, a, Z) \neq \emptyset$ï¼Œåˆ™ $\delta(q, \epsilon, Z) = \emptyset$

### 3.3 ç­‰ä»·æ€§å…³ç³»

**å®šç† 3.1** (PDAä¸CFGç­‰ä»·æ€§)
è¯­è¨€ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨PDA $M$ ä½¿å¾— $L = L(M)$ã€‚

**è¯æ˜**:

1. **CFGåˆ°PDA**: ä½¿ç”¨è‡ªé¡¶å‘ä¸‹æˆ–è‡ªåº•å‘ä¸Šæ„é€ 
2. **PDAåˆ°CFG**: ä½¿ç”¨é…ç½®å˜é‡æ„é€ 

## 4. å›¾çµæœº

### 4.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 4.1** (å›¾çµæœº)
å›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$$

å…¶ä¸­ï¼š

- $Q$ ä¸ºæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ ä¸ºè¾“å…¥å­—æ¯è¡¨
- $\Gamma$ ä¸ºå¸¦å­—æ¯è¡¨ï¼ˆ$\Sigma \subseteq \Gamma$ï¼‰
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ ä¸ºè½¬ç§»å‡½æ•°
- $q_0 \in Q$ ä¸ºåˆå§‹çŠ¶æ€
- $q_{accept} \in Q$ ä¸ºæ¥å—çŠ¶æ€
- $q_{reject} \in Q$ ä¸ºæ‹’ç»çŠ¶æ€

**å®šä¹‰ 4.2** (å›¾çµæœºé…ç½®)
å›¾çµæœºçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, \alpha, i)$ï¼Œå…¶ä¸­ï¼š

- $q$ æ˜¯å½“å‰çŠ¶æ€
- $\alpha$ æ˜¯å¸¦å†…å®¹
- $i$ æ˜¯è¯»å†™å¤´ä½ç½®

**å®šä¹‰ 4.3** (å›¾çµæœºè®¡ç®—)
å›¾çµæœºæ¥å—è¾“å…¥ $w$ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨è®¡ç®—åºåˆ—ï¼š
$$(q_0, w, 0) \vdash^* (q_{accept}, \alpha, i)$$

### 4.2 å›¾çµæœºå˜ä½“

**å®šä¹‰ 4.4** (å¤šå¸¦å›¾çµæœº)
å¤šå¸¦å›¾çµæœºæœ‰å¤šä¸ªå¸¦ï¼Œæ¯ä¸ªå¸¦éƒ½æœ‰è‡ªå·±çš„è¯»å†™å¤´ã€‚

**å®šç† 4.1** (å¤šå¸¦å›¾çµæœºç­‰ä»·æ€§)
å¤šå¸¦å›¾çµæœºä¸å•å¸¦å›¾çµæœºç­‰ä»·ã€‚

**å®šä¹‰ 4.5** (éç¡®å®šæ€§å›¾çµæœº)
éç¡®å®šæ€§å›¾çµæœºçš„è½¬ç§»å‡½æ•°ä¸ºï¼š
$$\delta: Q \times \Gamma \rightarrow 2^{Q \times \Gamma \times \{L, R\}}$$

**å®šç† 4.2** (éç¡®å®šæ€§å›¾çµæœºç­‰ä»·æ€§)
éç¡®å®šæ€§å›¾çµæœºä¸ç¡®å®šæ€§å›¾çµæœºç­‰ä»·ã€‚

## 5. Pythonå®ç°

### 5.1 æœ‰é™è‡ªåŠ¨æœºå®ç°

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Set, List, Dict, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import re
from collections import defaultdict, deque

T = TypeVar('T')

@dataclass
class State:
    """çŠ¶æ€ç±»"""
    name: str
    is_accepting: bool = False
    
    def __hash__(self):
        return hash(self.name)
    
    def __eq__(self, other):
        return self.name == other.name
    
    def __str__(self):
        return self.name

class DFA:
    """ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº"""
    
    def __init__(self, 
                 states: Set[State],
                 alphabet: Set[str],
                 transitions: Dict[Tuple[State, str], State],
                 initial_state: State,
                 accepting_states: Set[State]):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.initial_state = initial_state
        self.accepting_states = accepting_states
    
    def get_transition(self, state: State, symbol: str) -> Optional[State]:
        """è·å–è½¬ç§»"""
        return self.transitions.get((state, symbol))
    
    def accept(self, input_string: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ¥å—è¾“å…¥å­—ç¬¦ä¸²"""
        current_state = self.initial_state
        
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            
            next_state = self.get_transition(current_state, symbol)
            if next_state is None:
                return False
            
            current_state = next_state
        
        return current_state in self.accepting_states
    
    def get_language(self, max_length: int = 5) -> Set[str]:
        """è·å–è‡ªåŠ¨æœºæ¥å—çš„è¯­è¨€ï¼ˆé™åˆ¶é•¿åº¦ï¼‰"""
        accepted_strings = set()
        
        def generate_strings(current_state: State, current_string: str, length: int):
            if length == 0:
                if current_state in self.accepting_states:
                    accepted_strings.add(current_string)
                return
            
            for symbol in self.alphabet:
                next_state = self.get_transition(current_state, symbol)
                if next_state is not None:
                    generate_strings(next_state, current_string + symbol, length - 1)
        
        for length in range(max_length + 1):
            generate_strings(self.initial_state, "", length)
        
        return accepted_strings
    
    def minimize(self) -> 'DFA':
        """æœ€å°åŒ–DFAï¼ˆHopcroftç®—æ³•ï¼‰"""
        # ç§»é™¤ä¸å¯è¾¾çŠ¶æ€
        reachable = self._get_reachable_states()
        
        # åˆå§‹åŒ–ç­‰ä»·ç±»
        accepting = reachable & self.accepting_states
        non_accepting = reachable - self.accepting_states
        
        if not accepting:
            accepting = set()
        if not non_accepting:
            non_accepting = set()
        
        partitions = [accepting, non_accepting]
        partitions = [p for p in partitions if p]
        
        # ç»†åŒ–åˆ†åŒº
        while True:
            new_partitions = []
            for partition in partitions:
                if len(partition) <= 1:
                    new_partitions.append(partition)
                    continue
                
                # æ ¹æ®è½¬ç§»å‡½æ•°ç»†åŒ–åˆ†åŒº
                refined = self._refine_partition(partition, partitions)
                new_partitions.extend(refined)
            
            if len(new_partitions) == len(partitions):
                break
            
            partitions = new_partitions
        
        # æ„å»ºæœ€å°åŒ–DFA
        return self._build_minimized_dfa(partitions)
    
    def _get_reachable_states(self) -> Set[State]:
        """è·å–å¯è¾¾çŠ¶æ€"""
        reachable = {self.initial_state}
        queue = deque([self.initial_state])
        
        while queue:
            state = queue.popleft()
            for symbol in self.alphabet:
                next_state = self.get_transition(state, symbol)
                if next_state and next_state not in reachable:
                    reachable.add(next_state)
                    queue.append(next_state)
        
        return reachable
    
    def _refine_partition(self, partition: Set[State], all_partitions: List[Set[State]]) -> List[Set[State]]:
        """ç»†åŒ–åˆ†åŒº"""
        if len(partition) <= 1:
            return [partition]
        
        # æ ¹æ®è½¬ç§»å‡½æ•°åˆ†ç»„
        groups = defaultdict(set)
        for state in partition:
            signature = []
            for symbol in self.alphabet:
                next_state = self.get_transition(state, symbol)
                if next_state:
                    # æ‰¾åˆ°next_stateæ‰€åœ¨çš„ç­‰ä»·ç±»
                    for i, p in enumerate(all_partitions):
                        if next_state in p:
                            signature.append(i)
                            break
                else:
                    signature.append(-1)
            
            groups[tuple(signature)].add(state)
        
        return list(groups.values())
    
    def _build_minimized_dfa(self, partitions: List[Set[State]]) -> 'DFA':
        """æ„å»ºæœ€å°åŒ–DFA"""
        # åˆ›å»ºæ–°çŠ¶æ€
        new_states = {}
        for i, partition in enumerate(partitions):
            representative = next(iter(partition))
            is_accepting = any(state in self.accepting_states for state in partition)
            new_states[i] = State(f"q{i}", is_accepting)
        
        # åˆ›å»ºæ–°è½¬ç§»å‡½æ•°
        new_transitions = {}
        for i, partition in enumerate(partitions):
            representative = next(iter(partition))
            for symbol in self.alphabet:
                next_state = self.get_transition(representative, symbol)
                if next_state:
                    # æ‰¾åˆ°next_stateæ‰€åœ¨çš„ç­‰ä»·ç±»
                    for j, p in enumerate(partitions):
                        if next_state in p:
                            new_transitions[(new_states[i], symbol)] = new_states[j]
                            break
        
        # æ‰¾åˆ°åˆå§‹çŠ¶æ€
        initial_partition = None
        for i, partition in enumerate(partitions):
            if self.initial_state in partition:
                initial_partition = i
                break
        
        # æ‰¾åˆ°æ¥å—çŠ¶æ€
        accepting_states = {new_states[i] for i, partition in enumerate(partitions)
                          if any(state in self.accepting_states for state in partition)}
        
        return DFA(
            states=set(new_states.values()),
            alphabet=self.alphabet,
            transitions=new_transitions,
            initial_state=new_states[initial_partition],
            accepting_states=accepting_states
        )
    
    @classmethod
    def from_regex(cls, regex: str) -> 'DFA':
        """ä»æ­£åˆ™è¡¨è¾¾å¼æ„å»ºDFA"""
        # ä½¿ç”¨Thompsonæ„é€ æ³•
        nfa = cls._regex_to_nfa(regex)
        return nfa.to_dfa()
    
    @classmethod
    def _regex_to_nfa(cls, regex: str) -> 'NFA':
        """æ­£åˆ™è¡¨è¾¾å¼è½¬NFAï¼ˆThompsonæ„é€ æ³•ï¼‰"""
        # ç®€åŒ–å®ç°
        pass

class NFA:
    """éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº"""
    
    def __init__(self, 
                 states: Set[State],
                 alphabet: Set[str],
                 transitions: Dict[Tuple[State, str], Set[State]],
                 initial_state: State,
                 accepting_states: Set[State]):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.initial_state = initial_state
        self.accepting_states = accepting_states
    
    def get_transitions(self, state: State, symbol: str) -> Set[State]:
        """è·å–è½¬ç§»"""
        return self.transitions.get((state, symbol), set())
    
    def epsilon_closure(self, states: Set[State]) -> Set[State]:
        """è®¡ç®—Îµé—­åŒ…"""
        closure = states.copy()
        stack = list(states)
        
        while stack:
            state = stack.pop()
            epsilon_transitions = self.get_transitions(state, 'Îµ')
            
            for next_state in epsilon_transitions:
                if next_state not in closure:
                    closure.add(next_state)
                    stack.append(next_state)
        
        return closure
    
    def accept(self, input_string: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ¥å—è¾“å…¥å­—ç¬¦ä¸²"""
        current_states = self.epsilon_closure({self.initial_state})
        
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            
            next_states = set()
            for state in current_states:
                next_states.update(self.get_transitions(state, symbol))
            
            current_states = self.epsilon_closure(next_states)
            
            if not current_states:
                return False
        
        return any(state in self.accepting_states for state in current_states)
    
    def to_dfa(self) -> DFA:
        """NFAè½¬DFAï¼ˆå­é›†æ„é€ æ³•ï¼‰"""
        # åˆå§‹åŒ–
        initial_dfa_state = self.epsilon_closure({self.initial_state})
        dfa_states = {frozenset(initial_dfa_state)}
        unprocessed_states = [initial_dfa_state]
        dfa_transitions = {}
        
        while unprocessed_states:
            current_nfa_states = unprocessed_states.pop(0)
            current_dfa_state = frozenset(current_nfa_states)
            
            for symbol in self.alphabet:
                # è®¡ç®—è½¬ç§»
                next_nfa_states = set()
                for state in current_nfa_states:
                    next_nfa_states.update(self.get_transitions(state, symbol))
                
                next_nfa_states = self.epsilon_closure(next_nfa_states)
                next_dfa_state = frozenset(next_nfa_states)
                
                if next_dfa_state:
                    dfa_transitions[(current_dfa_state, symbol)] = next_dfa_state
                    
                    if next_dfa_state not in dfa_states:
                        dfa_states.add(next_dfa_state)
                        unprocessed_states.append(next_nfa_states)
        
        # åˆ›å»ºDFAçŠ¶æ€
        dfa_state_map = {}
        accepting_dfa_states = set()
        
        for dfa_state in dfa_states:
            nfa_states = list(dfa_state)
            is_accepting = any(state in self.accepting_states for state in nfa_states)
            dfa_state_obj = State(f"q{len(dfa_state_map)}", is_accepting)
            dfa_state_map[dfa_state] = dfa_state_obj
            
            if is_accepting:
                accepting_dfa_states.add(dfa_state_obj)
        
        # åˆ›å»ºDFAè½¬ç§»
        dfa_transition_map = {}
        for (dfa_state, symbol), next_dfa_state in dfa_transitions.items():
            dfa_transition_map[(dfa_state_map[dfa_state], symbol)] = dfa_state_map[next_dfa_state]
        
        return DFA(
            states=set(dfa_state_map.values()),
            alphabet=self.alphabet,
            transitions=dfa_transition_map,
            initial_state=dfa_state_map[frozenset(initial_dfa_state)],
            accepting_states=accepting_dfa_states
        )
```

### 5.2 ä¸‹æ¨è‡ªåŠ¨æœºå®ç°

```python
@dataclass
class PDAConfiguration:
    """PDAé…ç½®"""
    state: State
    input_remaining: str
    stack: List[str]
    
    def __str__(self):
        return f"({self.state}, {self.input_remaining}, {''.join(reversed(self.stack))})"

class PDA:
    """ä¸‹æ¨è‡ªåŠ¨æœº"""
    
    def __init__(self, 
                 states: Set[State],
                 input_alphabet: Set[str],
                 stack_alphabet: Set[str],
                 transitions: Dict[Tuple[State, str, str], Set[Tuple[State, List[str]]]],
                 initial_state: State,
                 initial_stack_symbol: str,
                 accepting_states: Set[State]):
        self.states = states
        self.input_alphabet = input_alphabet
        self.stack_alphabet = stack_alphabet
        self.transitions = transitions
        self.initial_state = initial_state
        self.initial_stack_symbol = initial_stack_symbol
        self.accepting_states = accepting_states
    
    def get_transitions(self, state: State, input_symbol: str, stack_top: str) -> Set[Tuple[State, List[str]]]:
        """è·å–è½¬ç§»"""
        return self.transitions.get((state, input_symbol, stack_top), set())
    
    def step(self, config: PDAConfiguration) -> List[PDAConfiguration]:
        """æ‰§è¡Œä¸€æ­¥è®¡ç®—"""
        next_configs = []
        
        # è·å–å½“å‰é…ç½®ä¿¡æ¯
        current_state = config.state
        input_symbol = config.input_remaining[0] if config.input_remaining else 'Îµ'
        stack_top = config.stack[-1] if config.stack else None
        
        if stack_top is None:
            return []
        
        # å°è¯•è¾“å…¥ç¬¦å·è½¬ç§»
        if input_symbol in self.input_alphabet or input_symbol == 'Îµ':
            transitions = self.get_transitions(current_state, input_symbol, stack_top)
            for next_state, stack_push in transitions:
                new_stack = config.stack[:-1] + stack_push
                new_input = config.input_remaining[1:] if input_symbol != 'Îµ' else config.input_remaining
                next_configs.append(PDAConfiguration(next_state, new_input, new_stack))
        
        return next_configs
    
    def accept(self, input_string: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ¥å—è¾“å…¥å­—ç¬¦ä¸²"""
        initial_config = PDAConfiguration(
            self.initial_state,
            input_string,
            [self.initial_stack_symbol]
        )
        
        # ä½¿ç”¨BFSæœç´¢æ¥å—é…ç½®
        visited = set()
        queue = deque([initial_config])
        
        while queue:
            config = queue.popleft()
            config_key = (config.state, config.input_remaining, tuple(config.stack))
            
            if config_key in visited:
                continue
            
            visited.add(config_key)
            
            # æ£€æŸ¥æ˜¯å¦æ¥å—
            if (not config.input_remaining and 
                config.state in self.accepting_states):
                return True
            
            # æ‰§è¡Œè½¬ç§»
            next_configs = self.step(config)
            for next_config in next_configs:
                queue.append(next_config)
        
        return False
```

### 5.3 å›¾çµæœºå®ç°

```python
@dataclass
class TuringMachineConfiguration:
    """å›¾çµæœºé…ç½®"""
    state: State
    tape: List[str]
    head_position: int
    
    def __str__(self):
        tape_str = ''.join(self.tape)
        head_marker = ' ' * self.head_position + '^'
        return f"({self.state}, {tape_str})\n{head_marker}"

class TuringMachine:
    """å›¾çµæœº"""
    
    def __init__(self, 
                 states: Set[State],
                 input_alphabet: Set[str],
                 tape_alphabet: Set[str],
                 transitions: Dict[Tuple[State, str], Tuple[State, str, str]],
                 initial_state: State,
                 accept_state: State,
                 reject_state: State):
        self.states = states
        self.input_alphabet = input_alphabet
        self.tape_alphabet = tape_alphabet
        self.transitions = transitions
        self.initial_state = initial_state
        self.accept_state = accept_state
        self.reject_state = reject_state
        self.blank_symbol = 'B'  # ç©ºç™½ç¬¦å·
    
    def get_transition(self, state: State, symbol: str) -> Optional[Tuple[State, str, str]]:
        """è·å–è½¬ç§»"""
        return self.transitions.get((state, symbol))
    
    def step(self, config: TuringMachineConfiguration) -> Optional[TuringMachineConfiguration]:
        """æ‰§è¡Œä¸€æ­¥è®¡ç®—"""
        current_symbol = config.tape[config.head_position]
        transition = self.get_transition(config.state, current_symbol)
        
        if transition is None:
            return None
        
        next_state, write_symbol, direction = transition
        
        # åˆ›å»ºæ–°é…ç½®
        new_tape = config.tape.copy()
        new_tape[config.head_position] = write_symbol
        
        new_head_position = config.head_position
        if direction == 'L':
            new_head_position -= 1
        elif direction == 'R':
            new_head_position += 1
        
        # æ‰©å±•ç£å¸¦
        if new_head_position < 0:
            new_tape.insert(0, self.blank_symbol)
            new_head_position = 0
        elif new_head_position >= len(new_tape):
            new_tape.append(self.blank_symbol)
        
        return TuringMachineConfiguration(next_state, new_tape, new_head_position)
    
    def accept(self, input_string: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ¥å—è¾“å…¥å­—ç¬¦ä¸²"""
        # åˆå§‹åŒ–ç£å¸¦
        tape = list(input_string)
        if not tape:
            tape = [self.blank_symbol]
        
        config = TuringMachineConfiguration(
            self.initial_state,
            tape,
            0
        )
        
        # æ‰§è¡Œè®¡ç®—
        steps = 0
        max_steps = 10000  # é˜²æ­¢æ— é™å¾ªç¯
        
        while steps < max_steps:
            if config.state == self.accept_state:
                return True
            elif config.state == self.reject_state:
                return False
            
            next_config = self.step(config)
            if next_config is None:
                return False
            
            config = next_config
            steps += 1
        
        return False  # è¶…æ—¶
    
    def compute(self, input_string: str) -> Optional[str]:
        """è®¡ç®—å‡½æ•°å€¼"""
        # åˆå§‹åŒ–ç£å¸¦
        tape = list(input_string)
        if not tape:
            tape = [self.blank_symbol]
        
        config = TuringMachineConfiguration(
            self.initial_state,
            tape,
            0
        )
        
        # æ‰§è¡Œè®¡ç®—
        steps = 0
        max_steps = 10000
        
        while steps < max_steps:
            if config.state == self.accept_state:
                # è¿”å›ç£å¸¦å†…å®¹ï¼ˆå»é™¤ç©ºç™½ç¬¦å·ï¼‰
                result = ''.join(s for s in config.tape if s != self.blank_symbol)
                return result
            elif config.state == self.reject_state:
                return None
            
            next_config = self.step(config)
            if next_config is None:
                return None
            
            config = next_config
            steps += 1
        
        return None  # è¶…æ—¶
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 æ­£åˆ™è¡¨è¾¾å¼å¼•æ“

```python
class RegexEngine:
    """æ­£åˆ™è¡¨è¾¾å¼å¼•æ“"""
    
    def __init__(self, pattern: str):
        self.pattern = pattern
        self.nfa = self._build_nfa()
        self.dfa = self.nfa.to_dfa()
    
    def _build_nfa(self) -> NFA:
        """ä»æ­£åˆ™è¡¨è¾¾å¼æ„å»ºNFA"""
        # ä½¿ç”¨Thompsonæ„é€ æ³•
        # è¿™é‡Œç®€åŒ–å®ç°
        pass
    
    def match(self, text: str) -> bool:
        """åŒ¹é…æ–‡æœ¬"""
        return self.dfa.accept(text)
    
    def find_all(self, text: str) -> List[str]:
        """æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…"""
        matches = []
        for i in range(len(text)):
            for j in range(i + 1, len(text) + 1):
                substring = text[i:j]
                if self.dfa.accept(substring):
                    matches.append(substring)
        return matches

# ä½¿ç”¨ç¤ºä¾‹
regex = RegexEngine("a*b*c*")
print(regex.match("aaabbbccc"))  # True
print(regex.match("abc"))        # True
print(regex.match("ac"))         # False
```

### 6.2 è¯­æ³•åˆ†æå™¨

```python
class Parser:
    """è¯­æ³•åˆ†æå™¨"""
    
    def __init__(self, grammar: CFG):
        self.grammar = grammar
        self.pda = self._build_pda()
    
    def _build_pda(self) -> PDA:
        """ä»CFGæ„å»ºPDA"""
        # å®ç°è‡ªé¡¶å‘ä¸‹æˆ–è‡ªåº•å‘ä¸Šæ„é€ 
        pass
    
    def parse(self, input_string: str) -> bool:
        """è§£æè¾“å…¥å­—ç¬¦ä¸²"""
        return self.pda.accept(input_string)

# ä½¿ç”¨ç¤ºä¾‹
grammar_string = """
S â†’ E
E â†’ E + T | T
T â†’ T * F | F
F â†’ ( E ) | id
"""

grammar = CFG.from_string(grammar_string)
parser = Parser(grammar)
print(parser.parse("id+id*id"))  # True
print(parser.parse("id+"))       # False
```

### 6.3 è®¡ç®—æ¨¡å‹

```python
class ComputationModel:
    """è®¡ç®—æ¨¡å‹"""
    
    def __init__(self):
        self.turing_machines = {}
    
    def register_turing_machine(self, name: str, tm: TuringMachine):
        """æ³¨å†Œå›¾çµæœº"""
        self.turing_machines[name] = tm
    
    def compute(self, machine_name: str, input_string: str) -> Optional[str]:
        """ä½¿ç”¨æŒ‡å®šçš„å›¾çµæœºè®¡ç®—"""
        if machine_name not in self.turing_machines:
            return None
        
        tm = self.turing_machines[machine_name]
        return tm.compute(input_string)
    
    def is_decidable(self, language: Set[str]) -> bool:
        """åˆ¤æ–­è¯­è¨€æ˜¯å¦å¯åˆ¤å®š"""
        # ç®€åŒ–å®ç°
        return True

# ä½¿ç”¨ç¤ºä¾‹
model = ComputationModel()

# åˆ›å»ºåŠ æ³•å›¾çµæœº
addition_tm = TuringMachine(
    states={State("q0"), State("q1"), State("q2"), State("accept")},
    input_alphabet={"1", "+"},
    tape_alphabet={"1", "+", "B"},
    transitions={
        (State("q0"), "1"): (State("q0"), "1", "R"),
        (State("q0"), "+"): (State("q1"), "+", "R"),
        (State("q1"), "1"): (State("q1"), "1", "R"),
        (State("q1"), "B"): (State("q2"), "B", "L"),
        (State("q2"), "1"): (State("q2"), "1", "L"),
        (State("q2"), "+"): (State("accept"), "B", "R"),
    },
    initial_state=State("q0"),
    accept_state=State("accept"),
    reject_state=State("q2")
)

model.register_turing_machine("addition", addition_tm)
result = model.compute("addition", "111+11")
print(result)  # "11111"
```

## 7. ç†è®ºè¯æ˜

### 7.1 è‡ªåŠ¨æœºç­‰ä»·æ€§

**å®šç† 7.1** (DFAæœ€å°åŒ–å”¯ä¸€æ€§)
å¯¹äºä»»æ„DFA $M$ï¼Œå…¶æœ€å°åŒ–DFA $M'$ æ˜¯å”¯ä¸€çš„ï¼ˆåœ¨åŒæ„æ„ä¹‰ä¸‹ï¼‰ã€‚

**è¯æ˜**:
ä½¿ç”¨ç­‰ä»·å…³ç³»çš„ä¸å˜æ€§ã€‚æœ€å°åŒ–DFAçš„çŠ¶æ€å¯¹åº”äºç­‰ä»·ç±»ï¼Œè€Œç­‰ä»·ç±»æ˜¯å”¯ä¸€çš„ã€‚

**å®šç† 7.2** (PDAä¸CFGç­‰ä»·æ€§)
è¯­è¨€ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨PDA $M$ ä½¿å¾— $L = L(M)$ã€‚

**è¯æ˜**:

1. **CFGåˆ°PDA**: ä½¿ç”¨è‡ªé¡¶å‘ä¸‹æ„é€ 
2. **PDAåˆ°CFG**: ä½¿ç”¨é…ç½®å˜é‡æ„é€ 

### 7.2 è®¡ç®—èƒ½åŠ›

**å®šç† 7.3** (å›¾çµæœºé€šç”¨æ€§)
å­˜åœ¨é€šç”¨å›¾çµæœº $U$ï¼Œä½¿å¾—å¯¹äºä»»æ„å›¾çµæœº $M$ å’Œè¾“å…¥ $w$ï¼Œ$U$ å¯ä»¥æ¨¡æ‹Ÿ $M$ åœ¨ $w$ ä¸Šçš„è®¡ç®—ã€‚

**è¯æ˜**:
æ„é€ é€šç”¨å›¾çµæœºï¼Œä½¿ç”¨ç¼–ç æŠ€æœ¯å°†å›¾çµæœºæè¿°å’Œè¾“å…¥ç¼–ç åˆ°ç£å¸¦ä¸Šã€‚

**å®šç† 7.4** (åœæœºé—®é¢˜ä¸å¯åˆ¤å®šæ€§)
åœæœºé—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„ï¼Œå³ä¸å­˜åœ¨å›¾çµæœºå¯ä»¥åˆ¤å®šä»»æ„å›¾çµæœºåœ¨ä»»æ„è¾“å…¥ä¸Šæ˜¯å¦åœæœºã€‚

**è¯æ˜**:
ä½¿ç”¨å¯¹è§’åŒ–æ–¹æ³•æ„é€ çŸ›ç›¾ã€‚

## 8. æ€§èƒ½åˆ†æ

### 8.1 å¤æ‚åº¦åˆ†æ

| è‡ªåŠ¨æœºç±»å‹ | çŠ¶æ€è½¬æ¢ | ç©ºé—´å¤æ‚åº¦ | æ—¶é—´å¤æ‚åº¦ |
|------------|----------|------------|------------|
| DFA | O(1) | O(1) | O(n) |
| NFA | O(m) | O(m) | O(nÂ·mÂ²) |
| PDA | O(k) | O(n) | O(nÂ³) |
| å›¾çµæœº | O(1) | O(n) | æ— ç•Œ |

### 8.2 ä¼˜åŒ–ç­–ç•¥

1. **DFAæœ€å°åŒ–**: å‡å°‘çŠ¶æ€æ•°ï¼Œæé«˜åŒ¹é…æ•ˆç‡
2. **ç¼“å­˜æœºåˆ¶**: ç¼“å­˜ä¸­é—´ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
3. **å¹¶è¡Œå¤„ç†**: åˆ©ç”¨å¤šæ ¸å¤„ç†å™¨å¹¶è¡Œåˆ†æ
4. **å†…å­˜ä¼˜åŒ–**: ä½¿ç”¨ç´§å‡‘çš„æ•°æ®ç»“æ„

## 9. æ€»ç»“

è‡ªåŠ¨æœºç†è®ºä¸ºè®¡ç®—æœºç§‘å­¦æä¾›äº†æŠ½è±¡çš„è®¡ç®—æ¨¡å‹ï¼Œä»ç®€å•çš„æœ‰é™è‡ªåŠ¨æœºåˆ°å¤æ‚çš„å›¾çµæœºï¼Œå½¢æˆäº†å®Œæ•´çš„è®¡ç®—èƒ½åŠ›å±‚æ¬¡ç»“æ„ã€‚

### ä¸»è¦æˆæœ

1. **å®Œæ•´çš„ç†è®ºæ¡†æ¶**: ä»åŸºæœ¬æ¦‚å¿µåˆ°é«˜çº§ç†è®º
2. **å®ç”¨çš„å®ç°**: æ‰€æœ‰è‡ªåŠ¨æœºéƒ½æœ‰å¯¹åº”çš„Pythonå®ç°
3. **ä¸¥æ ¼çš„å½¢å¼åŒ–**: æ•°å­¦å®šä¹‰å’Œè¯æ˜
4. **å®é™…åº”ç”¨**: æ­£åˆ™è¡¨è¾¾å¼ã€ç¼–è¯‘å™¨ã€è®¡ç®—ç†è®ºç­‰

### æŠ€æœ¯ç‰¹è‰²

1. **å¤šè¡¨å¾æ–¹æ³•**: æ¦‚å¿µã€æ•°å­¦ã€ä»£ç ã€å›¾è¡¨
2. **å±‚æ¬¡åŒ–ç»„ç»‡**: ä»åŸºç¡€åˆ°åº”ç”¨
3. **ä¸¥æ ¼çš„å½¢å¼åŒ–**: æ•°å­¦å®šä¹‰å’Œè¯æ˜
4. **å®Œæ•´çš„å®ç°**: å¯è¿è¡Œçš„Pythonä»£ç 

---

*æœ¬æ–‡æ¡£å»ºç«‹äº†è‡ªåŠ¨æœºç†è®ºçš„å®Œæ•´æ¡†æ¶ï¼Œä¸ºåç»­çš„ç¼–è¯‘å™¨ç†è®ºã€è®¡ç®—ç†è®ºç­‰å¥ å®šäº†åŸºç¡€ã€‚*
