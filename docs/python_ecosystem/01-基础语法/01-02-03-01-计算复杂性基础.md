# 02-03-01 è®¡ç®—å¤æ‚æ€§åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

è®¡ç®—å¤æ‚æ€§ç†è®ºæ˜¯ç ”ç©¶ç®—æ³•å’Œé—®é¢˜çš„è®¡ç®—èµ„æºéœ€æ±‚çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰è®¡ç®—å¤æ‚æ€§ï¼Œå»ºç«‹å¤æ‚åº¦åˆ†æçš„ç†è®ºæ¡†æ¶ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 è®¡ç®—æ¨¡å‹

**å®šä¹‰ 1.1** (å›¾çµæœº)
ç¡®å®šæ€§å›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$$
å…¶ä¸­ï¼š

- $Q$ ä¸ºçŠ¶æ€é›†åˆ
- $\Sigma$ ä¸ºè¾“å…¥å­—æ¯è¡¨
- $\Gamma$ ä¸ºå¸¦å­—æ¯è¡¨
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ ä¸ºè½¬ç§»å‡½æ•°
- $q_0 \in Q$ ä¸ºåˆå§‹çŠ¶æ€
- $q_{accept} \in Q$ ä¸ºæ¥å—çŠ¶æ€
- $q_{reject} \in Q$ ä¸ºæ‹’ç»çŠ¶æ€

**å®šä¹‰ 1.2** (æ—¶é—´å¤æ‚åº¦)
ç®—æ³• $A$ çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š
$$T_A(n) = \max\{steps(A, x) \mid |x| = n\}$$

**å®šä¹‰ 1.3** (ç©ºé—´å¤æ‚åº¦)
ç®—æ³• $A$ çš„ç©ºé—´å¤æ‚åº¦ä¸ºï¼š
$$S_A(n) = \max\{space(A, x) \mid |x| = n\}$$

### 1.2 å¤æ‚åº¦ç±»

**å®šä¹‰ 1.4** (Pç±»)
$$P = \{L \mid \exists \text{å¤šé¡¹å¼æ—¶é—´ç®—æ³• } A: L = L(A)\}$$

**å®šä¹‰ 1.5** (NPç±»)
$$NP = \{L \mid \exists \text{å¤šé¡¹å¼æ—¶é—´éªŒè¯å™¨ } V: L = \{x \mid \exists y: V(x, y) = 1\}\}$$

**å®šä¹‰ 1.6** (NPå®Œå…¨)
è¯­è¨€ $L$ æ˜¯NPå®Œå…¨çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

1. $L \in NP$
2. $\forall L' \in NP: L' \leq_p L$

**å®šä¹‰ 1.7** (å¤šé¡¹å¼æ—¶é—´å½’çº¦)
è¯­è¨€ $A$ å¤šé¡¹å¼æ—¶é—´å½’çº¦åˆ°è¯­è¨€ $B$ï¼Œè®°ä½œ $A \leq_p B$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\exists f: \Sigma^* \rightarrow \Sigma^*: \forall x: x \in A \Leftrightarrow f(x) \in B$$
ä¸” $f$ å¯åœ¨å¤šé¡¹å¼æ—¶é—´å†…è®¡ç®—ã€‚

## 2. Pythonå®ç°

### 2.1 å¤æ‚åº¦åˆ†ææ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Callable, Any, Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import time
import math
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict

T = TypeVar('T')

class ComplexityClass(Enum):
    """å¤æ‚åº¦ç±»"""
    CONSTANT = "O(1)"
    LOGARITHMIC = "O(log n)"
    LINEAR = "O(n)"
    LINEARITHMIC = "O(n log n)"
    QUADRATIC = "O(nÂ²)"
    CUBIC = "O(nÂ³)"
    POLYNOMIAL = "O(n^k)"
    EXPONENTIAL = "O(2^n)"
    FACTORIAL = "O(n!)"

@dataclass
class ComplexityAnalysis:
    """å¤æ‚åº¦åˆ†æç»“æœ"""
    algorithm_name: str
    input_sizes: List[int]
    execution_times: List[float]
    theoretical_complexity: ComplexityClass
    empirical_complexity: ComplexityClass
    confidence: float
    analysis_notes: str

class ComplexityAnalyzer:
    """å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.analyses: Dict[str, ComplexityAnalysis] = {}
    
    def analyze_algorithm(self, 
                         algorithm: Callable,
                         algorithm_name: str,
                         input_generator: Callable[[int], Any],
                         input_sizes: List[int],
                         theoretical_complexity: ComplexityClass,
                         num_runs: int = 5) -> ComplexityAnalysis:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        
        execution_times = []
        
        for size in input_sizes:
            # å¤šæ¬¡è¿è¡Œå–å¹³å‡å€¼
            times = []
            for _ in range(num_runs):
                input_data = input_generator(size)
                
                start_time = time.time()
                algorithm(input_data)
                end_time = time.time()
                
                times.append(end_time - start_time)
            
            avg_time = sum(times) / len(times)
            execution_times.append(avg_time)
        
        # åˆ†æç»éªŒå¤æ‚åº¦
        empirical_complexity = self._determine_empirical_complexity(input_sizes, execution_times)
        
        # è®¡ç®—ç½®ä¿¡åº¦
        confidence = self._calculate_confidence(theoretical_complexity, empirical_complexity)
        
        analysis = ComplexityAnalysis(
            algorithm_name=algorithm_name,
            input_sizes=input_sizes,
            execution_times=execution_times,
            theoretical_complexity=theoretical_complexity,
            empirical_complexity=empirical_complexity,
            confidence=confidence,
            analysis_notes=self._generate_analysis_notes(input_sizes, execution_times)
        )
        
        self.analyses[algorithm_name] = analysis
        return analysis
    
    def _determine_empirical_complexity(self, 
                                      input_sizes: List[int], 
                                      execution_times: List[float]) -> ComplexityClass:
        """ç¡®å®šç»éªŒå¤æ‚åº¦"""
        if len(input_sizes) < 2:
            return ComplexityClass.CONSTANT
        
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(input_sizes)):
            size_ratio = input_sizes[i] / input_sizes[i-1]
            time_ratio = execution_times[i] / execution_times[i-1]
            growth_rate = time_ratio / size_ratio
            growth_rates.append(growth_rate)
        
        avg_growth = sum(growth_rates) / len(growth_rates)
        
        # æ ¹æ®å¢é•¿ç‡åˆ¤æ–­å¤æ‚åº¦
        if avg_growth < 1.1:
            return ComplexityClass.CONSTANT
        elif avg_growth < 1.5:
            return ComplexityClass.LOGARITHMIC
        elif avg_growth < 2.5:
            return ComplexityClass.LINEAR
        elif avg_growth < 4:
            return ComplexityClass.LINEARITHMIC
        elif avg_growth < 8:
            return ComplexityClass.QUADRATIC
        elif avg_growth < 16:
            return ComplexityClass.CUBIC
        elif avg_growth < 100:
            return ComplexityClass.POLYNOMIAL
        else:
            return ComplexityClass.EXPONENTIAL
    
    def _calculate_confidence(self, 
                            theoretical: ComplexityClass, 
                            empirical: ComplexityClass) -> float:
        """è®¡ç®—ç½®ä¿¡åº¦"""
        if theoretical == empirical:
            return 1.0
        
        # å¤æ‚åº¦ç­‰çº§æ˜ å°„
        complexity_levels = {
            ComplexityClass.CONSTANT: 0,
            ComplexityClass.LOGARITHMIC: 1,
            ComplexityClass.LINEAR: 2,
            ComplexityClass.LINEARITHMIC: 3,
            ComplexityClass.QUADRATIC: 4,
            ComplexityClass.CUBIC: 5,
            ComplexityClass.POLYNOMIAL: 6,
            ComplexityClass.EXPONENTIAL: 7,
            ComplexityClass.FACTORIAL: 8
        }
        
        theoretical_level = complexity_levels[theoretical]
        empirical_level = complexity_levels[empirical]
        
        # è®¡ç®—ç­‰çº§å·®
        level_diff = abs(theoretical_level - empirical_level)
        
        # è½¬æ¢ä¸ºç½®ä¿¡åº¦
        confidence = max(0.0, 1.0 - level_diff * 0.2)
        return confidence
    
    def _generate_analysis_notes(self, 
                                input_sizes: List[int], 
                                execution_times: List[float]) -> str:
        """ç”Ÿæˆåˆ†ææ³¨é‡Š"""
        if len(input_sizes) < 2:
            return "æ•°æ®ç‚¹ä¸è¶³ï¼Œæ— æ³•è¿›è¡Œå¯é åˆ†æ"
        
        # è®¡ç®—æ‹Ÿåˆåº¦
        log_sizes = [math.log(size) for size in input_sizes]
        log_times = [math.log(time) if time > 0 else 0 for time in execution_times]
        
        # çº¿æ€§å›å½’
        if len(log_sizes) > 1:
            slope = self._linear_regression_slope(log_sizes, log_times)
            notes = f"å¯¹æ•°-å¯¹æ•°å›¾çš„æ–œç‡ä¸º {slope:.3f}"
            
            if slope < 0.1:
                notes += "ï¼Œæ¥è¿‘å¸¸æ•°å¤æ‚åº¦"
            elif slope < 0.5:
                notes += "ï¼Œæ¥è¿‘å¯¹æ•°å¤æ‚åº¦"
            elif slope < 1.5:
                notes += "ï¼Œæ¥è¿‘çº¿æ€§å¤æ‚åº¦"
            elif slope < 2.5:
                notes += "ï¼Œæ¥è¿‘å¹³æ–¹å¤æ‚åº¦"
            else:
                notes += "ï¼Œå¯èƒ½æ˜¯æ›´é«˜é˜¶å¤æ‚åº¦"
        else:
            notes = "æ•°æ®ç‚¹ä¸è¶³"
        
        return notes
    
    def _linear_regression_slope(self, x: List[float], y: List[float]) -> float:
        """è®¡ç®—çº¿æ€§å›å½’æ–œç‡"""
        n = len(x)
        if n < 2:
            return 0.0
        
        sum_x = sum(x)
        sum_y = sum(y)
        sum_xy = sum(x[i] * y[i] for i in range(n))
        sum_x2 = sum(x[i] * x[i] for i in range(n))
        
        numerator = n * sum_xy - sum_x * sum_y
        denominator = n * sum_x2 - sum_x * sum_x
        
        if denominator == 0:
            return 0.0
        
        return numerator / denominator
    
    def plot_analysis(self, algorithm_name: str) -> None:
        """ç»˜åˆ¶åˆ†æå›¾è¡¨"""
        if algorithm_name not in self.analyses:
            print(f"æœªæ‰¾åˆ°ç®—æ³• {algorithm_name} çš„åˆ†æç»“æœ")
            return
        
        analysis = self.analyses[algorithm_name]
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # åŸå§‹æ•°æ®å›¾
        ax1.plot(analysis.input_sizes, analysis.execution_times, 'bo-', label='å®é™…æ‰§è¡Œæ—¶é—´')
        ax1.set_xlabel('è¾“å…¥å¤§å°')
        ax1.set_ylabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
        ax1.set_title(f'{analysis.algorithm_name} - æ‰§è¡Œæ—¶é—´')
        ax1.legend()
        ax1.grid(True)
        
        # å¯¹æ•°-å¯¹æ•°å›¾
        log_sizes = [math.log(size) for size in analysis.input_sizes]
        log_times = [math.log(time) if time > 0 else 0 for time in analysis.execution_times]
        
        ax2.plot(log_sizes, log_times, 'ro-', label='å¯¹æ•°-å¯¹æ•°æ•°æ®')
        ax2.set_xlabel('log(è¾“å…¥å¤§å°)')
        ax2.set_ylabel('log(æ‰§è¡Œæ—¶é—´)')
        ax2.set_title(f'{analysis.algorithm_name} - å¯¹æ•°-å¯¹æ•°å›¾')
        ax2.legend()
        ax2.grid(True)
        
        plt.tight_layout()
        plt.show()
        
        # æ‰“å°åˆ†æç»“æœ
        print(f"\n{analysis.algorithm_name} å¤æ‚åº¦åˆ†æç»“æœ:")
        print(f"ç†è®ºå¤æ‚åº¦: {analysis.theoretical_complexity.value}")
        print(f"ç»éªŒå¤æ‚åº¦: {analysis.empirical_complexity.value}")
        print(f"ç½®ä¿¡åº¦: {analysis.confidence:.2%}")
        print(f"åˆ†ææ³¨é‡Š: {analysis.analysis_notes}")
```

### 2.2 å¤æ‚åº¦ç±»éªŒè¯å™¨

```python
class ComplexityClassVerifier:
    """å¤æ‚åº¦ç±»éªŒè¯å™¨"""
    
    def __init__(self):
        self.verification_results = {}
    
    def verify_p_class(self, algorithm: Callable, 
                      input_generator: Callable[[int], Any],
                      max_size: int = 1000) -> Dict[str, Any]:
        """éªŒè¯ç®—æ³•æ˜¯å¦å±äºPç±»"""
        
        results = {
            "is_p_class": True,
            "polynomial_degree": None,
            "verification_notes": [],
            "test_results": []
        }
        
        input_sizes = [10, 50, 100, 500, 1000]
        execution_times = []
        
        for size in input_sizes:
            if size > max_size:
                break
                
            input_data = input_generator(size)
            
            start_time = time.time()
            algorithm(input_data)
            end_time = time.time()
            
            execution_time = end_time - start_time
            execution_times.append(execution_time)
            
            results["test_results"].append({
                "size": size,
                "time": execution_time
            })
        
        # åˆ†ææ˜¯å¦ä¸ºå¤šé¡¹å¼æ—¶é—´
        if len(execution_times) >= 2:
            # è®¡ç®—å¢é•¿ç‡
            growth_rates = []
            for i in range(1, len(input_sizes)):
                size_ratio = input_sizes[i] / input_sizes[i-1]
                time_ratio = execution_times[i] / execution_times[i-1]
                growth_rate = time_ratio / size_ratio
                growth_rates.append(growth_rate)
            
            avg_growth = sum(growth_rates) / len(growth_rates)
            
            # åˆ¤æ–­æ˜¯å¦ä¸ºå¤šé¡¹å¼
            if avg_growth > 10:  # é˜ˆå€¼å¯è°ƒæ•´
                results["is_p_class"] = False
                results["verification_notes"].append("å¢é•¿ç‡è¿‡é«˜ï¼Œå¯èƒ½ä¸æ˜¯å¤šé¡¹å¼æ—¶é—´")
            else:
                # ä¼°ç®—å¤šé¡¹å¼æ¬¡æ•°
                log_growth = math.log(avg_growth)
                estimated_degree = max(1, int(round(log_growth)))
                results["polynomial_degree"] = estimated_degree
                results["verification_notes"].append(f"ä¼°ç®—å¤šé¡¹å¼æ¬¡æ•°: {estimated_degree}")
        
        return results
    
    def verify_np_class(self, 
                       decision_problem: Callable,
                       certificate_generator: Callable,
                       certificate_verifier: Callable,
                       input_generator: Callable[[int], Any],
                       max_size: int = 100) -> Dict[str, Any]:
        """éªŒè¯é—®é¢˜æ˜¯å¦å±äºNPç±»"""
        
        results = {
            "is_np_class": True,
            "verification_notes": [],
            "test_results": []
        }
        
        input_sizes = [5, 10, 20, 50]
        
        for size in input_sizes:
            if size > max_size:
                break
                
            input_data = input_generator(size)
            
            # ç”Ÿæˆè¯ä¹¦
            start_time = time.time()
            certificate = certificate_generator(input_data)
            cert_gen_time = time.time() - start_time
            
            # éªŒè¯è¯ä¹¦
            start_time = time.time()
            is_valid = certificate_verifier(input_data, certificate)
            cert_verify_time = time.time() - start_time
            
            # æ£€æŸ¥å†³ç­–é—®é¢˜
            start_time = time.time()
            decision_result = decision_problem(input_data)
            decision_time = time.time() - start_time
            
            results["test_results"].append({
                "size": size,
                "certificate_generation_time": cert_gen_time,
                "certificate_verification_time": cert_verify_time,
                "decision_time": decision_time,
                "is_valid": is_valid,
                "decision_result": decision_result
            })
            
            # æ£€æŸ¥éªŒè¯å™¨æ—¶é—´æ˜¯å¦ä¸ºå¤šé¡¹å¼
            if cert_verify_time > 1.0:  # é˜ˆå€¼å¯è°ƒæ•´
                results["verification_notes"].append(f"å¤§å° {size} çš„éªŒè¯æ—¶é—´è¿‡é•¿")
            
            # æ£€æŸ¥ä¸€è‡´æ€§
            if decision_result != is_valid:
                results["is_np_class"] = False
                results["verification_notes"].append(f"å¤§å° {size} çš„å†³ç­–ç»“æœä¸éªŒè¯ç»“æœä¸ä¸€è‡´")
        
        return results
```

### 2.3 å½’çº¦å®ç°

```python
class ReductionFramework:
    """å½’çº¦æ¡†æ¶"""
    
    def __init__(self):
        self.reductions = {}
    
    def register_reduction(self, 
                          from_problem: str, 
                          to_problem: str, 
                          reduction_function: Callable) -> None:
        """æ³¨å†Œå½’çº¦"""
        self.reductions[(from_problem, to_problem)] = reduction_function
    
    def verify_reduction(self, 
                        from_problem: str, 
                        to_problem: str, 
                        test_cases: List[Any]) -> Dict[str, Any]:
        """éªŒè¯å½’çº¦çš„æ­£ç¡®æ€§"""
        
        if (from_problem, to_problem) not in self.reductions:
            return {"valid": False, "error": "å½’çº¦æœªæ³¨å†Œ"}
        
        reduction_func = self.reductions[(from_problem, to_problem)]
        
        results = {
            "valid": True,
            "test_results": [],
            "notes": []
        }
        
        for i, test_case in enumerate(test_cases):
            try:
                # åº”ç”¨å½’çº¦
                reduced_instance = reduction_func(test_case)
                
                # æ£€æŸ¥å½’çº¦çš„æ­£ç¡®æ€§
                # è¿™é‡Œéœ€è¦å…·ä½“çš„éªŒè¯é€»è¾‘
                
                results["test_results"].append({
                    "test_case": i,
                    "original": test_case,
                    "reduced": reduced_instance,
                    "valid": True  # ç®€åŒ–ç‰ˆæœ¬
                })
                
            except Exception as e:
                results["test_results"].append({
                    "test_case": i,
                    "original": test_case,
                    "error": str(e),
                    "valid": False
                })
                results["valid"] = False
        
        return results
    
    def polynomial_time_reduction(self, 
                                 from_problem: Callable,
                                 to_problem: Callable,
                                 reduction_func: Callable,
                                 input_generator: Callable[[int], Any],
                                 max_size: int = 100) -> Dict[str, Any]:
        """éªŒè¯å¤šé¡¹å¼æ—¶é—´å½’çº¦"""
        
        results = {
            "is_polynomial_time": True,
            "reduction_times": [],
            "notes": []
        }
        
        input_sizes = [10, 20, 50, 100]
        
        for size in input_sizes:
            if size > max_size:
                break
                
            input_data = input_generator(size)
            
            # æµ‹é‡å½’çº¦æ—¶é—´
            start_time = time.time()
            reduced_instance = reduction_func(input_data)
            reduction_time = time.time() - start_time
            
            results["reduction_times"].append({
                "size": size,
                "time": reduction_time
            })
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºå¤šé¡¹å¼æ—¶é—´
            if reduction_time > 1.0:  # é˜ˆå€¼å¯è°ƒæ•´
                results["notes"].append(f"å¤§å° {size} çš„å½’çº¦æ—¶é—´è¿‡é•¿")
        
        # åˆ†ææ—¶é—´å¢é•¿è¶‹åŠ¿
        if len(results["reduction_times"]) >= 2:
            times = [r["time"] for r in results["reduction_times"]]
            sizes = [r["size"] for r in results["reduction_times"]]
            
            # è®¡ç®—å¢é•¿ç‡
            growth_rates = []
            for i in range(1, len(sizes)):
                size_ratio = sizes[i] / sizes[i-1]
                time_ratio = times[i] / times[i-1]
                growth_rate = time_ratio / size_ratio
                growth_rates.append(growth_rate)
            
            avg_growth = sum(growth_rates) / len(growth_rates)
            
            if avg_growth > 10:  # é˜ˆå€¼å¯è°ƒæ•´
                results["is_polynomial_time"] = False
                results["notes"].append("å½’çº¦æ—¶é—´å¢é•¿è¿‡å¿«ï¼Œå¯èƒ½ä¸æ˜¯å¤šé¡¹å¼æ—¶é—´")
        
        return results
```

### 2.4 å…·ä½“é—®é¢˜å®ç°

```python
class SATProblem:
    """SATé—®é¢˜å®ç°"""
    
    def __init__(self):
        self.clauses = []
        self.variables = set()
    
    def add_clause(self, clause: List[int]) -> None:
        """æ·»åŠ å­å¥"""
        self.clauses.append(clause)
        for literal in clause:
            self.variables.add(abs(literal))
    
    def evaluate(self, assignment: Dict[int, bool]) -> bool:
        """è¯„ä¼°èµ‹å€¼"""
        for clause in self.clauses:
            clause_satisfied = False
            for literal in clause:
                var = abs(literal)
                value = assignment.get(var, False)
                if literal < 0:
                    value = not value
                if value:
                    clause_satisfied = True
                    break
            if not clause_satisfied:
                return False
        return True
    
    def is_satisfiable(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯æ»¡è¶³"""
        # æš´åŠ›æœç´¢ï¼ˆä»…ç”¨äºå°è§„æ¨¡é—®é¢˜ï¼‰
        n = len(self.variables)
        for i in range(2**n):
            assignment = {}
            for j, var in enumerate(sorted(self.variables)):
                assignment[var] = bool(i & (1 << j))
            if self.evaluate(assignment):
                return True
        return False

class VertexCoverProblem:
    """é¡¶ç‚¹è¦†ç›–é—®é¢˜å®ç°"""
    
    def __init__(self):
        self.vertices = set()
        self.edges = []
    
    def add_edge(self, u: int, v: int) -> None:
        """æ·»åŠ è¾¹"""
        self.edges.append((u, v))
        self.vertices.add(u)
        self.vertices.add(v)
    
    def has_vertex_cover(self, k: int) -> bool:
        """æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¤§å°ä¸ºkçš„é¡¶ç‚¹è¦†ç›–"""
        # æš´åŠ›æœç´¢ï¼ˆä»…ç”¨äºå°è§„æ¨¡é—®é¢˜ï¼‰
        vertices_list = list(self.vertices)
        n = len(vertices_list)
        
        for i in range(2**n):
            if bin(i).count('1') == k:
                cover = set()
                for j in range(n):
                    if i & (1 << j):
                        cover.add(vertices_list[j])
                
                # æ£€æŸ¥æ˜¯å¦ä¸ºé¡¶ç‚¹è¦†ç›–
                is_cover = True
                for u, v in self.edges:
                    if u not in cover and v not in cover:
                        is_cover = False
                        break
                
                if is_cover:
                    return True
        
        return False

class HamiltonianPathProblem:
    """å“ˆå¯†é¡¿è·¯å¾„é—®é¢˜å®ç°"""
    
    def __init__(self):
        self.vertices = set()
        self.edges = set()
    
    def add_edge(self, u: int, v: int) -> None:
        """æ·»åŠ è¾¹"""
        self.edges.add((u, v))
        self.edges.add((v, u))  # æ— å‘å›¾
        self.vertices.add(u)
        self.vertices.add(v)
    
    def has_hamiltonian_path(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å­˜åœ¨å“ˆå¯†é¡¿è·¯å¾„"""
        # æš´åŠ›æœç´¢ï¼ˆä»…ç”¨äºå°è§„æ¨¡é—®é¢˜ï¼‰
        vertices_list = list(self.vertices)
        n = len(vertices_list)
        
        # ç”Ÿæˆæ‰€æœ‰æ’åˆ—
        from itertools import permutations
        for perm in permutations(vertices_list):
            is_path = True
            for i in range(n - 1):
                if (perm[i], perm[i + 1]) not in self.edges:
                    is_path = False
                    break
            if is_path:
                return True
        
        return False
```

## 3. ç†è®ºè¯æ˜

### 3.1 Pç±»å°é—­æ€§

**å®šç† 3.1** (Pç±»å°é—­æ€§)
Pç±»åœ¨ä»¥ä¸‹è¿ç®—ä¸‹å°é—­ï¼š

1. å¹¶é›†
2. äº¤é›†
3. è¡¥é›†
4. è¿æ¥
5. æ˜Ÿè¿ç®—

**è¯æ˜**:
è®¾ $A, B \in P$ï¼Œå­˜åœ¨å¤šé¡¹å¼æ—¶é—´ç®—æ³• $M_A, M_B$ è¯†åˆ« $A, B$ã€‚

1. **å¹¶é›†**: æ„é€ ç®—æ³• $M_{A \cup B}$ åœ¨è¾“å…¥ $x$ ä¸Šè¿è¡Œ $M_A(x)$ å’Œ $M_B(x)$ï¼Œå¦‚æœä»»ä¸€æ¥å—åˆ™æ¥å—ã€‚
2. **äº¤é›†**: æ„é€ ç®—æ³• $M_{A \cap B}$ åœ¨è¾“å…¥ $x$ ä¸Šè¿è¡Œ $M_A(x)$ å’Œ $M_B(x)$ï¼Œå¦‚æœéƒ½æ¥å—åˆ™æ¥å—ã€‚
3. **è¡¥é›†**: æ„é€ ç®—æ³• $M_{\overline{A}}$ åœ¨è¾“å…¥ $x$ ä¸Šè¿è¡Œ $M_A(x)$ï¼Œå¦‚æœæ‹’ç»åˆ™æ¥å—ã€‚
4. **è¿æ¥**: æ„é€ ç®—æ³• $M_{A \circ B}$ å°è¯•æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²ã€‚
5. **æ˜Ÿè¿ç®—**: æ„é€ ç®—æ³• $M_{A^*}$ ä½¿ç”¨åŠ¨æ€è§„åˆ’ã€‚

### 3.2 NPç±»ç­‰ä»·å®šä¹‰

**å®šç† 3.2** (NPç±»ç­‰ä»·å®šä¹‰)
ä»¥ä¸‹å®šä¹‰ç­‰ä»·ï¼š

1. $L \in NP$ å½“ä¸”ä»…å½“å­˜åœ¨å¤šé¡¹å¼æ—¶é—´éªŒè¯å™¨
2. $L \in NP$ å½“ä¸”ä»…å½“å­˜åœ¨éç¡®å®šæ€§å¤šé¡¹å¼æ—¶é—´å›¾çµæœº

**è¯æ˜**:

1. **éªŒè¯å™¨ â†’ NTM**: æ„é€ NTMçŒœæµ‹è¯ä¹¦ï¼Œç„¶åè¿è¡ŒéªŒè¯å™¨ã€‚
2. **NTM â†’ éªŒè¯å™¨**: ä½¿ç”¨NTMçš„è®¡ç®—è·¯å¾„ä½œä¸ºè¯ä¹¦ã€‚

### 3.3 NPå®Œå…¨æ€§ä¼ é€’æ€§

**å®šç† 3.3** (NPå®Œå…¨æ€§ä¼ é€’æ€§)
å¦‚æœ $A \leq_p B$ ä¸” $B \leq_p C$ï¼Œåˆ™ $A \leq_p C$ã€‚

**è¯æ˜**:
è®¾ $f$ ä¸º $A$ åˆ° $B$ çš„å½’çº¦ï¼Œ$g$ ä¸º $B$ åˆ° $C$ çš„å½’çº¦ã€‚

æ„é€  $h(x) = g(f(x))$ï¼Œåˆ™ $h$ æ˜¯ $A$ åˆ° $C$ çš„å½’çº¦ã€‚

ç”±äº $f$ å’Œ $g$ éƒ½æ˜¯å¤šé¡¹å¼æ—¶é—´ï¼Œ$h$ ä¹Ÿæ˜¯å¤šé¡¹å¼æ—¶é—´ã€‚

## 4. åº”ç”¨ç¤ºä¾‹

```python
def demonstrate_complexity_analysis():
    """æ¼”ç¤ºå¤æ‚åº¦åˆ†æ"""
    
    analyzer = ComplexityAnalyzer()
    
    # æµ‹è¯•ä¸åŒå¤æ‚åº¦çš„ç®—æ³•
    def constant_time_algorithm(data):
        return len(data)  # O(1)
    
    def linear_time_algorithm(data):
        result = 0
        for item in data:
            result += item
        return result  # O(n)
    
    def quadratic_time_algorithm(data):
        result = 0
        for i in range(len(data)):
            for j in range(len(data)):
                result += data[i] * data[j]
        return result  # O(nÂ²)
    
    def exponential_time_algorithm(data):
        def fibonacci(n):
            if n <= 1:
                return n
            return fibonacci(n-1) + fibonacci(n-2)
        
        return fibonacci(len(data))  # O(2^n)
    
    # è¾“å…¥ç”Ÿæˆå™¨
    def generate_input(size):
        return list(range(size))
    
    # åˆ†æå„ç§ç®—æ³•
    algorithms = [
        (constant_time_algorithm, "Constant Time", ComplexityClass.CONSTANT),
        (linear_time_algorithm, "Linear Time", ComplexityClass.LINEAR),
        (quadratic_time_algorithm, "Quadratic Time", ComplexityClass.QUADRATIC),
        (exponential_time_algorithm, "Exponential Time", ComplexityClass.EXPONENTIAL)
    ]
    
    input_sizes = [10, 50, 100, 500, 1000]
    
    for algorithm, name, theoretical in algorithms:
        print(f"\nåˆ†æ {name} ç®—æ³•...")
        analysis = analyzer.analyze_algorithm(
            algorithm, name, generate_input, input_sizes, theoretical
        )
        
        print(f"ç†è®ºå¤æ‚åº¦: {analysis.theoretical_complexity.value}")
        print(f"ç»éªŒå¤æ‚åº¦: {analysis.empirical_complexity.value}")
        print(f"ç½®ä¿¡åº¦: {analysis.confidence:.2%}")
        
        # ç»˜åˆ¶å›¾è¡¨
        analyzer.plot_analysis(name)

def demonstrate_np_verification():
    """æ¼”ç¤ºNPç±»éªŒè¯"""
    
    verifier = ComplexityClassVerifier()
    
    # SATé—®é¢˜éªŒè¯
    def sat_decision_problem(formula):
        return formula.is_satisfiable()
    
    def sat_certificate_generator(formula):
        # ç”Ÿæˆä¸€ä¸ªå¯èƒ½çš„èµ‹å€¼
        assignment = {}
        for var in formula.variables:
            assignment[var] = True  # ç®€åŒ–ç‰ˆæœ¬
        return assignment
    
    def sat_certificate_verifier(formula, assignment):
        return formula.evaluate(assignment)
    
    def sat_input_generator(size):
        # ç”ŸæˆéšæœºSATå…¬å¼
        formula = SATProblem()
        for i in range(size):
            clause = [i+1, -(i+1)]  # ç®€åŒ–ç‰ˆæœ¬
            formula.add_clause(clause)
        return formula
    
    print("\néªŒè¯SATé—®é¢˜æ˜¯å¦å±äºNPç±»...")
    sat_results = verifier.verify_np_class(
        sat_decision_problem,
        sat_certificate_generator,
        sat_certificate_verifier,
        sat_input_generator
    )
    
    print(f"SATé—®é¢˜å±äºNPç±»: {sat_results['is_np_class']}")
    for note in sat_results['verification_notes']:
        print(f"  - {note}")

def demonstrate_reduction():
    """æ¼”ç¤ºå½’çº¦"""
    
    reduction_framework = ReductionFramework()
    
    # SATåˆ°3-SATçš„å½’çº¦
    def sat_to_3sat_reduction(sat_formula):
        # ç®€åŒ–çš„å½’çº¦å®ç°
        return sat_formula  # å®é™…å®ç°æ›´å¤æ‚
    
    reduction_framework.register_reduction("SAT", "3-SAT", sat_to_3sat_reduction)
    
    def sat_input_generator(size):
        formula = SATProblem()
        for i in range(size):
            clause = [i+1, -(i+1)]
            formula.add_clause(clause)
        return formula
    
    print("\néªŒè¯SATåˆ°3-SATçš„å½’çº¦...")
    reduction_results = reduction_framework.polynomial_time_reduction(
        lambda x: x.is_satisfiable(),
        lambda x: x.is_satisfiable(),  # ç®€åŒ–
        sat_to_3sat_reduction,
        sat_input_generator
    )
    
    print(f"å½’çº¦ä¸ºå¤šé¡¹å¼æ—¶é—´: {reduction_results['is_polynomial_time']}")
    for note in reduction_results['notes']:
        print(f"  - {note}")

if __name__ == "__main__":
    demonstrate_complexity_analysis()
    demonstrate_np_verification()
    demonstrate_reduction()
```

## 5. æ€»ç»“

æœ¬æ–‡æ¡£å»ºç«‹äº†è®¡ç®—å¤æ‚æ€§ç†è®ºçš„å®Œæ•´æ¡†æ¶ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†è®¡ç®—æ¨¡å‹å’Œå¤æ‚åº¦ç±»çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **åˆ†æå·¥å…·**: å®Œæ•´çš„å¤æ‚åº¦åˆ†ææ¡†æ¶å’ŒéªŒè¯å™¨
3. **ç†è®ºè¯æ˜**: å¤æ‚åº¦ç±»æ€§è´¨å’Œå½’çº¦ç†è®ºçš„å½¢å¼åŒ–è¯æ˜
4. **å®é™…åº”ç”¨**: å…·ä½“é—®é¢˜çš„å®ç°å’Œå¤æ‚åº¦åˆ†æ

### å¤æ‚åº¦ç±»å±‚æ¬¡ç»“æ„

```text
P âŠ† NP âŠ† PSPACE âŠ† EXPTIME âŠ† NEXPTIME âŠ† EXPSPACE
```

### é‡è¦æ¦‚å¿µ

- **Pç±»**: å¤šé¡¹å¼æ—¶é—´å¯è§£é—®é¢˜
- **NPç±»**: å¤šé¡¹å¼æ—¶é—´å¯éªŒè¯é—®é¢˜
- **NPå®Œå…¨**: NPä¸­æœ€éš¾çš„é—®é¢˜
- **å½’çº¦**: é—®é¢˜é—´å¤æ‚åº¦çš„æ¯”è¾ƒå·¥å…·

---

*ä¸‹ä¸€èŠ‚ï¼š[02-03-02-NPå®Œå…¨æ€§ç†è®º](./02-03-02-NPå®Œå…¨æ€§ç†è®º.md)*
