# æ•°è®ºåŸºç¡€

## ğŸ“š æ¦‚è¿°

æ•°è®ºæ˜¯ç ”ç©¶æ•´æ•°æ€§è´¨çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨è®¡ç®—æœºç§‘å­¦ã€å¯†ç å­¦å’Œç®—æ³•è®¾è®¡ä¸­å…·æœ‰é‡è¦åº”ç”¨ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼ç§‘å­¦çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»æ•°è®ºçš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. æ•´é™¤æ€§

#### 1.1 æ•´é™¤çš„æ•°å­¦å®šä¹‰

å¯¹äºæ•´æ•° $a$ å’Œ $b$ï¼Œå¦‚æœå­˜åœ¨æ•´æ•° $k$ ä½¿å¾— $a = kb$ï¼Œåˆ™ç§° $b$ æ•´é™¤ $a$ï¼Œè®°ä½œ $b \mid a$ã€‚

**æ€§è´¨**:

- ä¼ é€’æ€§: å¦‚æœ $a \mid b$ ä¸” $b \mid c$ï¼Œåˆ™ $a \mid c$
- çº¿æ€§ç»„åˆ: å¦‚æœ $a \mid b$ ä¸” $a \mid c$ï¼Œåˆ™ $a \mid (mb + nc)$

#### 1.2 æ•´é™¤æ€§çš„Pythonå®ç°

```python
from typing import List, Tuple, Optional
import math

class Divisibility:
    """æ•´é™¤æ€§ç›¸å…³æ“ä½œ"""
    
    @staticmethod
    def divides(a: int, b: int) -> bool:
        """åˆ¤æ–­aæ˜¯å¦æ•´é™¤b"""
        if a == 0:
            return False
        return b % a == 0
    
    @staticmethod
    def get_divisors(n: int) -> List[int]:
        """è·å–nçš„æ‰€æœ‰æ­£å› å­"""
        if n <= 0:
            return []
        
        divisors = []
        for i in range(1, int(math.sqrt(n)) + 1):
            if n % i == 0:
                divisors.append(i)
                if i != n // i:
                    divisors.append(n // i)
        
        return sorted(divisors)
    
    @staticmethod
    def count_divisors(n: int) -> int:
        """è®¡ç®—nçš„æ­£å› å­ä¸ªæ•°"""
        if n <= 0:
            return 0
        
        count = 0
        for i in range(1, int(math.sqrt(n)) + 1):
            if n % i == 0:
                count += 2 if i != n // i else 1
        
        return count

# ä½¿ç”¨ç¤ºä¾‹
print(f"6 | 18: {Divisibility.divides(6, 18)}")
print(f"18çš„å› å­: {Divisibility.get_divisors(18)}")
print(f"18çš„å› å­ä¸ªæ•°: {Divisibility.count_divisors(18)}")
```

### 2. æœ€å¤§å…¬çº¦æ•°

#### 2.1 æœ€å¤§å…¬çº¦æ•°çš„æ•°å­¦å®šä¹‰

ä¸¤ä¸ªæ•´æ•° $a$ å’Œ $b$ çš„æœ€å¤§å…¬çº¦æ•°ï¼ˆGCDï¼‰æ˜¯æœ€å¤§çš„æ•´æ•° $d$ï¼Œä½¿å¾— $d \mid a$ ä¸” $d \mid b$ï¼Œè®°ä½œ $\gcd(a, b)$ã€‚

**æ€§è´¨**:

- $\gcd(a, b) = \gcd(b, a)$
- $\gcd(a, 0) = |a|$
- $\gcd(a, b) = \gcd(a, b - ka)$

#### 2.2 æ¬§å‡ é‡Œå¾—ç®—æ³•

**ç®—æ³•**: å¯¹äº $a > b > 0$ï¼Œæœ‰ $\gcd(a, b) = \gcd(b, a \bmod b)$

```python
class EuclideanAlgorithm:
    """æ¬§å‡ é‡Œå¾—ç®—æ³•å®ç°"""
    
    @staticmethod
    def gcd(a: int, b: int) -> int:
        """è®¡ç®—æœ€å¤§å…¬çº¦æ•°"""
        a, b = abs(a), abs(b)
        while b:
            a, b = b, a % b
        return a
    
    @staticmethod
    def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
        """æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œè¿”å›(gcd, x, y)"""
        if b == 0:
            return a, 1, 0
        
        gcd, x1, y1 = EuclideanAlgorithm.extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return gcd, x, y
    
    @staticmethod
    def lcm(a: int, b: int) -> int:
        """è®¡ç®—æœ€å°å…¬å€æ•°"""
        return abs(a * b) // EuclideanAlgorithm.gcd(a, b)

# ä½¿ç”¨ç¤ºä¾‹
print(f"gcd(48, 18) = {EuclideanAlgorithm.gcd(48, 18)}")
print(f"lcm(12, 18) = {EuclideanAlgorithm.lcm(12, 18)}")
gcd, x, y = EuclideanAlgorithm.extended_gcd(48, 18)
print(f"48*{x} + 18*{y} = {gcd}")
```

### 3. ç´ æ•°

#### 3.1 ç´ æ•°çš„æ•°å­¦å®šä¹‰

å¤§äº1çš„æ•´æ•° $p$ æ˜¯ç´ æ•°ï¼Œå½“ä¸”ä»…å½“ $p$ çš„æ­£å› å­åªæœ‰1å’Œ $p$ æœ¬èº«ã€‚

**æ€§è´¨**:

- ç´ æ•°æœ‰æ— ç©·å¤šä¸ª
- æ¯ä¸ªå¤§äº1çš„æ•´æ•°éƒ½å¯ä»¥å”¯ä¸€åˆ†è§£ä¸ºç´ æ•°çš„ä¹˜ç§¯

#### 3.2 ç´ æ•°çš„Pythonå®ç°

```python
class PrimeNumbers:
    """ç´ æ•°ç›¸å…³æ“ä½œ"""
    
    @staticmethod
    def is_prime(n: int) -> bool:
        """åˆ¤æ–­næ˜¯å¦ä¸ºç´ æ•°"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        for i in range(3, int(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def sieve_of_eratosthenes(n: int) -> List[bool]:
        """åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•"""
        is_prime = [True] * (n + 1)
        is_prime[0] = is_prime[1] = False
        
        for i in range(2, int(math.sqrt(n)) + 1):
            if is_prime[i]:
                for j in range(i * i, n + 1, i):
                    is_prime[j] = False
        
        return is_prime
    
    @staticmethod
    def get_primes_up_to(n: int) -> List[int]:
        """è·å–å°äºç­‰äºnçš„æ‰€æœ‰ç´ æ•°"""
        is_prime = PrimeNumbers.sieve_of_eratosthenes(n)
        return [i for i in range(n + 1) if is_prime[i]]
    
    @staticmethod
    def prime_factorization(n: int) -> List[Tuple[int, int]]:
        """è´¨å› æ•°åˆ†è§£"""
        factors = []
        d = 2
        
        while d * d <= n:
            count = 0
            while n % d == 0:
                count += 1
                n //= d
            if count > 0:
                factors.append((d, count))
            d += 1
        
        if n > 1:
            factors.append((n, 1))
        
        return factors

# ä½¿ç”¨ç¤ºä¾‹
print(f"17æ˜¯ç´ æ•°: {PrimeNumbers.is_prime(17)}")
print(f"100ä»¥å†…çš„ç´ æ•°: {PrimeNumbers.get_primes_up_to(100)}")
print(f"84çš„è´¨å› æ•°åˆ†è§£: {PrimeNumbers.prime_factorization(84)}")
```

### 4. åŒä½™

#### 4.1 åŒä½™çš„æ•°å­¦å®šä¹‰

å¯¹äºæ•´æ•° $a$ã€$b$ å’Œæ­£æ•´æ•° $m$ï¼Œå¦‚æœ $m \mid (a - b)$ï¼Œåˆ™ç§° $a$ ä¸ $b$ æ¨¡ $m$ åŒä½™ï¼Œè®°ä½œ $a \equiv b \pmod{m}$ã€‚

**æ€§è´¨**:

- è‡ªåæ€§: $a \equiv a \pmod{m}$
- å¯¹ç§°æ€§: å¦‚æœ $a \equiv b \pmod{m}$ï¼Œåˆ™ $b \equiv a \pmod{m}$
- ä¼ é€’æ€§: å¦‚æœ $a \equiv b \pmod{m}$ ä¸” $b \equiv c \pmod{m}$ï¼Œåˆ™ $a \equiv c \pmod{m}$

#### 4.2 åŒä½™çš„Pythonå®ç°

```python
class Congruence:
    """åŒä½™è¿ç®—"""
    
    @staticmethod
    def mod(a: int, m: int) -> int:
        """è®¡ç®—a mod m"""
        return ((a % m) + m) % m
    
    @staticmethod
    def is_congruent(a: int, b: int, m: int) -> bool:
        """åˆ¤æ–­aä¸bæ˜¯å¦æ¨¡måŒä½™"""
        return Congruence.mod(a, m) == Congruence.mod(b, m)
    
    @staticmethod
    def modular_inverse(a: int, m: int) -> Optional[int]:
        """è®¡ç®—aåœ¨æ¨¡mä¸‹çš„ä¹˜æ³•é€†å…ƒ"""
        gcd, x, y = EuclideanAlgorithm.extended_gcd(a, m)
        if gcd != 1:
            return None
        return Congruence.mod(x, m)
    
    @staticmethod
    def chinese_remainder_theorem(remainders: List[int], moduli: List[int]) -> Optional[int]:
        """ä¸­å›½å‰©ä½™å®šç†"""
        if len(remainders) != len(moduli):
            return None
        
        n = len(remainders)
        product = 1
        for m in moduli:
            product *= m
        
        result = 0
        for i in range(n):
            pi = product // moduli[i]
            inv = Congruence.modular_inverse(pi, moduli[i])
            if inv is None:
                return None
            result = (result + remainders[i] * pi * inv) % product
        
        return result

# ä½¿ç”¨ç¤ºä¾‹
print(f"17 â‰¡ 5 (mod 6): {Congruence.is_congruent(17, 5, 6)}")
print(f"3åœ¨æ¨¡7ä¸‹çš„é€†å…ƒ: {Congruence.modular_inverse(3, 7)}")

# ä¸­å›½å‰©ä½™å®šç†ç¤ºä¾‹
remainders = [2, 3, 2]
moduli = [3, 5, 7]
result = Congruence.chinese_remainder_theorem(remainders, moduli)
print(f"x â‰¡ 2 (mod 3), x â‰¡ 3 (mod 5), x â‰¡ 2 (mod 7) çš„è§£: {result}")
```

### 5. æ¬§æ‹‰å‡½æ•°

#### 5.1 æ¬§æ‹‰å‡½æ•°çš„æ•°å­¦å®šä¹‰

æ¬§æ‹‰å‡½æ•° $\phi(n)$ è¡¨ç¤ºå°äºç­‰äº $n$ ä¸”ä¸ $n$ äº’è´¨çš„æ­£æ•´æ•°çš„ä¸ªæ•°ã€‚

**æ€§è´¨**:

- å¦‚æœ $p$ æ˜¯ç´ æ•°ï¼Œåˆ™ $\phi(p) = p - 1$
- å¦‚æœ $\gcd(m, n) = 1$ï¼Œåˆ™ $\phi(mn) = \phi(m)\phi(n)$

#### 5.2 æ¬§æ‹‰å‡½æ•°çš„Pythonå®ç°

```python
class EulerFunction:
    """æ¬§æ‹‰å‡½æ•°ç›¸å…³æ“ä½œ"""
    
    @staticmethod
    def phi(n: int) -> int:
        """è®¡ç®—æ¬§æ‹‰å‡½æ•°Ï†(n)"""
        if n <= 0:
            return 0
        
        result = n
        factors = PrimeNumbers.prime_factorization(n)
        
        for prime, _ in factors:
            result = result // prime * (prime - 1)
        
        return result
    
    @staticmethod
    def euler_theorem(a: int, n: int) -> bool:
        """æ¬§æ‹‰å®šç†éªŒè¯"""
        if EuclideanAlgorithm.gcd(a, n) != 1:
            return False
        
        phi_n = EulerFunction.phi(n)
        return Congruence.mod(pow(a, phi_n, n), n) == 1

# ä½¿ç”¨ç¤ºä¾‹
print(f"Ï†(12) = {EulerFunction.phi(12)}")
print(f"æ¬§æ‹‰å®šç†éªŒè¯ (5^Ï†(12) â‰¡ 1 (mod 12)): {EulerFunction.euler_theorem(5, 12)}")
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. æ¬§å‡ é‡Œå¾—ç®—æ³•çš„æ­£ç¡®æ€§

**å®šç†**: æ¬§å‡ é‡Œå¾—ç®—æ³•æ­£ç¡®è®¡ç®—æœ€å¤§å…¬çº¦æ•°ã€‚

**è¯æ˜**: è®¾ $a = qb + r$ï¼Œå…¶ä¸­ $0 \leq r < b$ã€‚

å¦‚æœ $d \mid a$ ä¸” $d \mid b$ï¼Œåˆ™ $d \mid r$ã€‚
å¦‚æœ $d \mid b$ ä¸” $d \mid r$ï¼Œåˆ™ $d \mid a$ã€‚

å› æ­¤ï¼Œ$a$ å’Œ $b$ çš„å…¬çº¦æ•°é›†åˆç­‰äº $b$ å’Œ $r$ çš„å…¬çº¦æ•°é›†åˆï¼Œæ‰€ä»¥ $\gcd(a, b) = \gcd(b, r)$ã€‚

### 2. ç´ æ•°åˆ†è§£çš„å”¯ä¸€æ€§

**å®šç†**: æ¯ä¸ªå¤§äº1çš„æ•´æ•°éƒ½å¯ä»¥å”¯ä¸€åˆ†è§£ä¸ºç´ æ•°çš„ä¹˜ç§¯ã€‚

**è¯æ˜**: ä½¿ç”¨æ•°å­¦å½’çº³æ³•ã€‚å‡è®¾å¯¹äºæ‰€æœ‰å°äº $n$ çš„æ•´æ•°ï¼Œåˆ†è§£å”¯ä¸€æ€§æˆç«‹ã€‚

å¦‚æœ $n$ æ˜¯ç´ æ•°ï¼Œåˆ™åˆ†è§£å”¯ä¸€ã€‚
å¦‚æœ $n$ æ˜¯åˆæ•°ï¼Œè®¾ $n = p_1p_2\cdots p_k = q_1q_2\cdots q_l$ã€‚

ç”±äº $p_1 \mid n$ï¼Œæ‰€ä»¥ $p_1$ æ•´é™¤æŸä¸ª $q_i$ã€‚ç”±äº $q_i$ æ˜¯ç´ æ•°ï¼Œæ‰€ä»¥ $p_1 = q_i$ã€‚

é€šè¿‡å½’çº³å‡è®¾ï¼Œå‰©ä½™éƒ¨åˆ†çš„åˆ†è§£å”¯ä¸€ï¼Œå› æ­¤æ•´ä¸ªåˆ†è§£å”¯ä¸€ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. RSAå¯†ç ç³»ç»Ÿ

```python
class RSACryptography:
    """RSAå¯†ç ç³»ç»Ÿå®ç°"""
    
    def __init__(self, p: int, q: int):
        """åˆå§‹åŒ–RSAå‚æ•°"""
        self.p = p
        self.q = q
        self.n = p * q
        self.phi_n = (p - 1) * (q - 1)
        
        # é€‰æ‹©å…¬é’¥e
        self.e = 65537  # å¸¸ç”¨çš„å…¬é’¥å€¼
        while EuclideanAlgorithm.gcd(self.e, self.phi_n) != 1:
            self.e += 2
        
        # è®¡ç®—ç§é’¥d
        self.d = Congruence.modular_inverse(self.e, self.phi_n)
    
    def encrypt(self, message: int) -> int:
        """åŠ å¯†æ¶ˆæ¯"""
        return pow(message, self.e, self.n)
    
    def decrypt(self, ciphertext: int) -> int:
        """è§£å¯†æ¶ˆæ¯"""
        return pow(ciphertext, self.d, self.n)

# ä½¿ç”¨ç¤ºä¾‹
rsa = RSACryptography(61, 53)
message = 123
encrypted = rsa.encrypt(message)
decrypted = rsa.decrypt(encrypted)
print(f"åŸå§‹æ¶ˆæ¯: {message}")
print(f"åŠ å¯†å: {encrypted}")
print(f"è§£å¯†å: {decrypted}")
```

### 2. çº¿æ€§åŒä½™æ–¹ç¨‹æ±‚è§£

```python
class LinearCongruence:
    """çº¿æ€§åŒä½™æ–¹ç¨‹æ±‚è§£"""
    
    @staticmethod
    def solve_linear_congruence(a: int, b: int, m: int) -> List[int]:
        """æ±‚è§£ ax â‰¡ b (mod m)"""
        gcd, x, y = EuclideanAlgorithm.extended_gcd(a, m)
        
        if b % gcd != 0:
            return []  # æ— è§£
        
        x0 = (x * (b // gcd)) % m
        solutions = []
        
        for k in range(gcd):
            solution = (x0 + k * (m // gcd)) % m
            solutions.append(solution)
        
        return sorted(solutions)

# ä½¿ç”¨ç¤ºä¾‹
solutions = LinearCongruence.solve_linear_congruence(3, 1, 7)
print(f"3x â‰¡ 1 (mod 7) çš„è§£: {solutions}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [æ•°å­¦åŸºç¡€æ¦‚è¿°](../README.md)
- [é›†åˆè®ºåŸºç¡€](01-01-01-é›†åˆè®ºåŸºç¡€.md)
- [ä»£æ•°åŸºç¡€](01-01-03-ä»£æ•°åŸºç¡€.md)
- [é€»è¾‘å­¦åŸºç¡€](../01-02-é€»è¾‘å­¦/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Hardy, G. H., & Wright, E. M. (2008). An Introduction to the Theory of Numbers. Oxford University Press.
2. Rosen, K. H. (2011). Elementary Number Theory and Its Applications. Pearson.
3. Niven, I., Zuckerman, H. S., & Montgomery, H. L. (1991). An Introduction to the Theory of Numbers. Wiley.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
