# è´Ÿè½½å‡è¡¡

## ğŸ“‹ æ¦‚è¿°

è´Ÿè½½å‡è¡¡æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å…³é”®æŠ€æœ¯ï¼Œç”¨äºå°†è¯·æ±‚åˆ†å‘åˆ°å¤šä¸ªæœåŠ¡å™¨å®ä¾‹ï¼Œä»¥æé«˜ç³»ç»Ÿçš„å¯ç”¨æ€§ã€æ€§èƒ½å’Œå¯æ‰©å±•æ€§ã€‚æœ¬æ–‡æ¡£æä¾›è´Ÿè½½å‡è¡¡çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è´Ÿè½½å‡è¡¡å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**è´Ÿè½½å‡è¡¡äº”å…ƒç»„**:
$$\mathcal{LB} = (S, R, A, W, D)$$

å…¶ä¸­ï¼š
- $S = \{s_1, s_2, ..., s_n\}$ æ˜¯æœåŠ¡å™¨å®ä¾‹é›†åˆ
- $R = \{r_1, r_2, ..., r_m\}$ æ˜¯è¯·æ±‚é›†åˆ
- $A: R \rightarrow S$ æ˜¯åˆ†é…å‡½æ•°
- $W: S \rightarrow \mathbb{R}^+$ æ˜¯æƒé‡å‡½æ•°
- $D: S \rightarrow \{true, false\}$ æ˜¯å¥åº·çŠ¶æ€å‡½æ•°

#### 1.2 è´Ÿè½½å‡è¡¡ç›®æ ‡

**è´Ÿè½½åˆ†å¸ƒ**: $\forall s_i, s_j \in S: |load(s_i) - load(s_j)| < \epsilon$

**å“åº”æ—¶é—´æœ€å°åŒ–**: $\min \sum_{r \in R} response\_time(r)$

**å¯ç”¨æ€§æœ€å¤§åŒ–**: $\max \sum_{s \in S} availability(s)$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Set, Optional, Any, Tuple, Callable
from collections import defaultdict, deque
import time
import uuid
import asyncio
import json
import logging
import threading
from concurrent.futures import ThreadPoolExecutor
import aiohttp
import statistics
import heapq
import random
import math

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class LoadBalancingStrategy(Enum):
    """è´Ÿè½½å‡è¡¡ç­–ç•¥æšä¸¾"""
    ROUND_ROBIN = "round_robin"
    WEIGHTED_ROUND_ROBIN = "weighted_round_robin"
    LEAST_CONNECTIONS = "least_connections"
    WEIGHTED_LEAST_CONNECTIONS = "weighted_least_connections"
    IP_HASH = "ip_hash"
    URL_HASH = "url_hash"
    RANDOM = "random"
    LEAST_RESPONSE_TIME = "least_response_time"
    CONSISTENT_HASH = "consistent_hash"

class ServerStatus(Enum):
    """æœåŠ¡å™¨çŠ¶æ€æšä¸¾"""
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    OVERLOADED = "overloaded"
    MAINTENANCE = "maintenance"

@dataclass
class ServerInstance:
    """æœåŠ¡å™¨å®ä¾‹"""
    id: str
    host: str
    port: int
    weight: int = 1
    max_connections: int = 1000
    status: ServerStatus = ServerStatus.HEALTHY
    current_connections: int = 0
    response_times: deque = field(default_factory=lambda: deque(maxlen=100))
    last_health_check: float = field(default_factory=time.time)
    created_at: float = field(default_factory=time.time)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.last_health_check:
            self.last_health_check = time.time()
        if not self.created_at:
            self.created_at = time.time()
    
    @property
    def endpoint(self) -> str:
        """è·å–æœåŠ¡å™¨ç«¯ç‚¹"""
        return f"{self.host}:{self.port}"
    
    @property
    def url(self) -> str:
        """è·å–æœåŠ¡å™¨URL"""
        return f"http://{self.host}:{self.port}"
    
    @property
    def average_response_time(self) -> float:
        """è·å–å¹³å‡å“åº”æ—¶é—´"""
        if not self.response_times:
            return 0.0
        return statistics.mean(self.response_times)
    
    @property
    def connection_utilization(self) -> float:
        """è·å–è¿æ¥åˆ©ç”¨ç‡"""
        return self.current_connections / self.max_connections if self.max_connections > 0 else 0.0
    
    def add_response_time(self, response_time: float):
        """æ·»åŠ å“åº”æ—¶é—´"""
        self.response_times.append(response_time)
    
    def increment_connections(self):
        """å¢åŠ è¿æ¥æ•°"""
        self.current_connections += 1
    
    def decrement_connections(self):
        """å‡å°‘è¿æ¥æ•°"""
        if self.current_connections > 0:
            self.current_connections -= 1

@dataclass
class Request:
    """è¯·æ±‚å®šä¹‰"""
    id: str
    method: str
    url: str
    headers: Dict[str, str] = field(default_factory=dict)
    data: Any = None
    client_ip: str = ""
    timestamp: float = field(default_factory=time.time)
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = time.time()

class LoadBalancer(ABC):
    """è´Ÿè½½å‡è¡¡å™¨æŠ½è±¡åŸºç±»"""
    
    def __init__(self, strategy: LoadBalancingStrategy):
        self.strategy = strategy
        self.servers: List[ServerInstance] = []
        self.healthy_servers: List[ServerInstance] = []
        self.lock = threading.RLock()
        self.stats = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "average_response_time": 0.0
        }
    
    @abstractmethod
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """é€‰æ‹©æœåŠ¡å™¨"""
        pass
    
    def add_server(self, server: ServerInstance):
        """æ·»åŠ æœåŠ¡å™¨"""
        with self.lock:
            self.servers.append(server)
            if server.status == ServerStatus.HEALTHY:
                self.healthy_servers.append(server)
            logger.info(f"Added server: {server.endpoint}")
    
    def remove_server(self, server_id: str):
        """ç§»é™¤æœåŠ¡å™¨"""
        with self.lock:
            self.servers = [s for s in self.servers if s.id != server_id]
            self.healthy_servers = [s for s in self.healthy_servers if s.id != server_id]
            logger.info(f"Removed server: {server_id}")
    
    def update_server_status(self, server_id: str, status: ServerStatus):
        """æ›´æ–°æœåŠ¡å™¨çŠ¶æ€"""
        with self.lock:
            for server in self.servers:
                if server.id == server_id:
                    old_status = server.status
                    server.status = status
                    
                    if status == ServerStatus.HEALTHY and server not in self.healthy_servers:
                        self.healthy_servers.append(server)
                    elif status != ServerStatus.HEALTHY and server in self.healthy_servers:
                        self.healthy_servers.remove(server)
                    
                    logger.info(f"Server {server.endpoint} status changed from {old_status.value} to {status.value}")
                    break
    
    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        with self.lock:
            return {
                **self.stats,
                "total_servers": len(self.servers),
                "healthy_servers": len(self.healthy_servers),
                "server_details": [
                    {
                        "id": server.id,
                        "endpoint": server.endpoint,
                        "status": server.status.value,
                        "current_connections": server.current_connections,
                        "average_response_time": server.average_response_time,
                        "connection_utilization": server.connection_utilization
                    }
                    for server in self.servers
                ]
            }

class RoundRobinLoadBalancer(LoadBalancer):
    """è½®è¯¢è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self):
        super().__init__(LoadBalancingStrategy.ROUND_ROBIN)
        self.current_index = 0
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """è½®è¯¢é€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            server = self.healthy_servers[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.healthy_servers)
            
            self.stats["total_requests"] += 1
            return server

class WeightedRoundRobinLoadBalancer(LoadBalancer):
    """åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self):
        super().__init__(LoadBalancingStrategy.WEIGHTED_ROUND_ROBIN)
        self.current_weight = 0
        self.current_index = 0
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """åŠ æƒè½®è¯¢é€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            while True:
                server = self.healthy_servers[self.current_index]
                
                if self.current_weight == 0:
                    self.current_weight = server.weight
                
                if self.current_weight > 0:
                    self.current_weight -= 1
                    if self.current_weight == 0:
                        self.current_index = (self.current_index + 1) % len(self.healthy_servers)
                    
                    self.stats["total_requests"] += 1
                    return server

class LeastConnectionsLoadBalancer(LoadBalancer):
    """æœ€å°‘è¿æ¥è´Ÿè½½å‡è¡¡å™¨"""
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """æœ€å°‘è¿æ¥é€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            # é€‰æ‹©è¿æ¥æ•°æœ€å°‘çš„æœåŠ¡å™¨
            server = min(self.healthy_servers, key=lambda s: s.current_connections)
            
            self.stats["total_requests"] += 1
            return server

class WeightedLeastConnectionsLoadBalancer(LoadBalancer):
    """åŠ æƒæœ€å°‘è¿æ¥è´Ÿè½½å‡è¡¡å™¨"""
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """åŠ æƒæœ€å°‘è¿æ¥é€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            # è®¡ç®—åŠ æƒè¿æ¥æ•°
            def weighted_connections(server):
                return server.current_connections / server.weight if server.weight > 0 else float('inf')
            
            server = min(self.healthy_servers, key=weighted_connections)
            
            self.stats["total_requests"] += 1
            return server

class IPHashLoadBalancer(LoadBalancer):
    """IPå“ˆå¸Œè´Ÿè½½å‡è¡¡å™¨"""
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """IPå“ˆå¸Œé€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            # åŸºäºå®¢æˆ·ç«¯IPè¿›è¡Œå“ˆå¸Œ
            client_ip = request.client_ip or "unknown"
            hash_value = hash(client_ip)
            index = hash_value % len(self.healthy_servers)
            
            server = self.healthy_servers[index]
            self.stats["total_requests"] += 1
            return server

class URLHashLoadBalancer(LoadBalancer):
    """URLå“ˆå¸Œè´Ÿè½½å‡è¡¡å™¨"""
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """URLå“ˆå¸Œé€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            # åŸºäºURLè¿›è¡Œå“ˆå¸Œ
            url = request.url
            hash_value = hash(url)
            index = hash_value % len(self.healthy_servers)
            
            server = self.healthy_servers[index]
            self.stats["total_requests"] += 1
            return server

class RandomLoadBalancer(LoadBalancer):
    """éšæœºè´Ÿè½½å‡è¡¡å™¨"""
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """éšæœºé€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            server = random.choice(self.healthy_servers)
            self.stats["total_requests"] += 1
            return server

class LeastResponseTimeLoadBalancer(LoadBalancer):
    """æœ€å°‘å“åº”æ—¶é—´è´Ÿè½½å‡è¡¡å™¨"""
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """æœ€å°‘å“åº”æ—¶é—´é€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            # é€‰æ‹©å¹³å‡å“åº”æ—¶é—´æœ€å°‘çš„æœåŠ¡å™¨
            server = min(self.healthy_servers, key=lambda s: s.average_response_time)
            
            self.stats["total_requests"] += 1
            return server

class ConsistentHashLoadBalancer(LoadBalancer):
    """ä¸€è‡´æ€§å“ˆå¸Œè´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, virtual_nodes: int = 150):
        super().__init__(LoadBalancingStrategy.CONSISTENT_HASH)
        self.virtual_nodes = virtual_nodes
        self.hash_ring: Dict[int, ServerInstance] = {}
        self.sorted_keys: List[int] = []
    
    def add_server(self, server: ServerInstance):
        """æ·»åŠ æœåŠ¡å™¨åˆ°å“ˆå¸Œç¯"""
        super().add_server(server)
        self._update_hash_ring()
    
    def remove_server(self, server_id: str):
        """ä»å“ˆå¸Œç¯ç§»é™¤æœåŠ¡å™¨"""
        super().remove_server(server_id)
        self._update_hash_ring()
    
    def _update_hash_ring(self):
        """æ›´æ–°å“ˆå¸Œç¯"""
        self.hash_ring.clear()
        self.sorted_keys.clear()
        
        for server in self.healthy_servers:
            for i in range(self.virtual_nodes):
                virtual_node_key = f"{server.id}:{i}"
                hash_value = hash(virtual_node_key)
                self.hash_ring[hash_value] = server
        
        self.sorted_keys = sorted(self.hash_ring.keys())
    
    def select_server(self, request: Request) -> Optional[ServerInstance]:
        """ä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©æœåŠ¡å™¨"""
        with self.lock:
            if not self.healthy_servers:
                return None
            
            # åŸºäºè¯·æ±‚IDè¿›è¡Œå“ˆå¸Œ
            request_key = request.id
            hash_value = hash(request_key)
            
            # æ‰¾åˆ°ä¸‹ä¸€ä¸ªå“ˆå¸Œå€¼
            for key in self.sorted_keys:
                if key >= hash_value:
                    server = self.hash_ring[key]
                    self.stats["total_requests"] += 1
                    return server
            
            # å¦‚æœæ²¡æ‰¾åˆ°ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
            if self.sorted_keys:
                server = self.hash_ring[self.sorted_keys[0]]
                self.stats["total_requests"] += 1
                return server
            
            return None

class HealthChecker:
    """å¥åº·æ£€æŸ¥å™¨"""
    
    def __init__(self, timeout: int = 5, interval: int = 30):
        self.timeout = timeout
        self.interval = interval
        self.check_task = None
    
    async def start_health_checking(self, load_balancer: LoadBalancer):
        """å¼€å§‹å¥åº·æ£€æŸ¥"""
        self.check_task = asyncio.create_task(self._health_check_loop(load_balancer))
    
    async def stop_health_checking(self):
        """åœæ­¢å¥åº·æ£€æŸ¥"""
        if self.check_task:
            self.check_task.cancel()
            try:
                await self.check_task
            except asyncio.CancelledError:
                pass
    
    async def _health_check_loop(self, load_balancer: LoadBalancer):
        """å¥åº·æ£€æŸ¥å¾ªç¯"""
        while True:
            try:
                await self._check_all_servers(load_balancer)
                await asyncio.sleep(self.interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Health check failed: {e}")
                await asyncio.sleep(self.interval)
    
    async def _check_all_servers(self, load_balancer: LoadBalancer):
        """æ£€æŸ¥æ‰€æœ‰æœåŠ¡å™¨"""
        for server in load_balancer.servers:
            is_healthy = await self._check_server_health(server)
            
            if is_healthy and server.status != ServerStatus.HEALTHY:
                load_balancer.update_server_status(server.id, ServerStatus.HEALTHY)
            elif not is_healthy and server.status == ServerStatus.HEALTHY:
                load_balancer.update_server_status(server.id, ServerStatus.UNHEALTHY)
    
    async def _check_server_health(self, server: ServerInstance) -> bool:
        """æ£€æŸ¥å•ä¸ªæœåŠ¡å™¨å¥åº·çŠ¶æ€"""
        try:
            url = f"{server.url}/health"
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=self.timeout) as response:
                    server.last_health_check = time.time()
                    return response.status == 200
        except Exception as e:
            logger.warning(f"Health check failed for {server.endpoint}: {e}")
            server.last_health_check = time.time()
            return False

class LoadBalancerProxy:
    """è´Ÿè½½å‡è¡¡ä»£ç†"""
    
    def __init__(self, load_balancer: LoadBalancer, health_checker: HealthChecker = None):
        self.load_balancer = load_balancer
        self.health_checker = health_checker or HealthChecker()
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        await self.health_checker.start_health_checking(self.load_balancer)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.health_checker.stop_health_checking()
        if self.session:
            await self.session.close()
    
    async def forward_request(self, request: Request) -> Tuple[int, Dict[str, Any], Any]:
        """è½¬å‘è¯·æ±‚"""
        start_time = time.time()
        
        # é€‰æ‹©æœåŠ¡å™¨
        server = self.load_balancer.select_server(request)
        if not server:
            return 503, {"error": "No available servers"}, None
        
        try:
            # å¢åŠ è¿æ¥æ•°
            server.increment_connections()
            
            # æ„å»ºè¯·æ±‚URL
            target_url = f"{server.url}{request.url}"
            
            # å‘é€è¯·æ±‚
            async with self.session.request(
                method=request.method,
                url=target_url,
                headers=request.headers,
                data=request.data,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                response_data = await response.read()
                
                # è®¡ç®—å“åº”æ—¶é—´
                response_time = time.time() - start_time
                server.add_response_time(response_time)
                
                # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                self.load_balancer.stats["successful_requests"] += 1
                self.load_balancer.stats["average_response_time"] = (
                    (self.load_balancer.stats["average_response_time"] * 
                     (self.load_balancer.stats["successful_requests"] - 1) + response_time) /
                    self.load_balancer.stats["successful_requests"]
                )
                
                return response.status, dict(response.headers), response_data
                
        except Exception as e:
            # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            self.load_balancer.stats["failed_requests"] += 1
            logger.error(f"Request failed: {e}")
            return 500, {"error": str(e)}, None
        finally:
            # å‡å°‘è¿æ¥æ•°
            server.decrement_connections()

class LoadBalancerFactory:
    """è´Ÿè½½å‡è¡¡å™¨å·¥å‚"""
    
    @staticmethod
    def create_load_balancer(strategy: LoadBalancingStrategy) -> LoadBalancer:
        """åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨"""
        if strategy == LoadBalancingStrategy.ROUND_ROBIN:
            return RoundRobinLoadBalancer()
        elif strategy == LoadBalancingStrategy.WEIGHTED_ROUND_ROBIN:
            return WeightedRoundRobinLoadBalancer()
        elif strategy == LoadBalancingStrategy.LEAST_CONNECTIONS:
            return LeastConnectionsLoadBalancer()
        elif strategy == LoadBalancingStrategy.WEIGHTED_LEAST_CONNECTIONS:
            return WeightedLeastConnectionsLoadBalancer()
        elif strategy == LoadBalancingStrategy.IP_HASH:
            return IPHashLoadBalancer()
        elif strategy == LoadBalancingStrategy.URL_HASH:
            return URLHashLoadBalancer()
        elif strategy == LoadBalancingStrategy.RANDOM:
            return RandomLoadBalancer()
        elif strategy == LoadBalancingStrategy.LEAST_RESPONSE_TIME:
            return LeastResponseTimeLoadBalancer()
        elif strategy == LoadBalancingStrategy.CONSISTENT_HASH:
            return ConsistentHashLoadBalancer()
        else:
            raise ValueError(f"Unknown load balancing strategy: {strategy}")
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
async def demonstrate_load_balancing():
    """æ¼”ç¤ºè´Ÿè½½å‡è¡¡"""
    print("=== Load Balancing Demo ===")
    
    # åˆ›å»ºæœåŠ¡å™¨å®ä¾‹
    servers = [
        ServerInstance("server1", "localhost", 8001, weight=1),
        ServerInstance("server2", "localhost", 8002, weight=2),
        ServerInstance("server3", "localhost", 8003, weight=1),
        ServerInstance("server4", "localhost", 8004, weight=3)
    ]
    
    # æµ‹è¯•ä¸åŒçš„è´Ÿè½½å‡è¡¡ç­–ç•¥
    strategies = [
        LoadBalancingStrategy.ROUND_ROBIN,
        LoadBalancingStrategy.WEIGHTED_ROUND_ROBIN,
        LoadBalancingStrategy.LEAST_CONNECTIONS,
        LoadBalancingStrategy.RANDOM,
        LoadBalancingStrategy.CONSISTENT_HASH
    ]
    
    for strategy in strategies:
        print(f"\n--- Testing {strategy.value} ---")
        
        # åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
        load_balancer = LoadBalancerFactory.create_load_balancer(strategy)
        
        # æ·»åŠ æœåŠ¡å™¨
        for server in servers:
            load_balancer.add_server(server)
        
        # æ¨¡æ‹Ÿè¯·æ±‚
        request_counts = defaultdict(int)
        for i in range(20):
            request = Request(
                method="GET",
                url=f"/api/data/{i}",
                client_ip=f"192.168.1.{i % 10}"
            )
            
            selected_server = load_balancer.select_server(request)
            if selected_server:
                request_counts[selected_server.id] += 1
                print(f"Request {i} -> {selected_server.endpoint}")
        
        # æ˜¾ç¤ºåˆ†é…ç»“æœ
        print(f"Request distribution:")
        for server_id, count in request_counts.items():
            server = next(s for s in servers if s.id == server_id)
            print(f"  {server.endpoint}: {count} requests")
        
        # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        stats = load_balancer.get_stats()
        print(f"Total requests: {stats['total_requests']}")
    
    # æ¼”ç¤ºå¥åº·æ£€æŸ¥
    print("\n--- Health Check Demo ---")
    load_balancer = RoundRobinLoadBalancer()
    for server in servers:
        load_balancer.add_server(server)
    
    health_checker = HealthChecker()
    async with LoadBalancerProxy(load_balancer, health_checker) as proxy:
        # æ¨¡æ‹Ÿä¸€äº›è¯·æ±‚
        for i in range(5):
            request = Request(
                method="GET",
                url=f"/api/health/{i}",
                client_ip="192.168.1.1"
            )
            
            status, headers, data = await proxy.forward_request(request)
            print(f"Request {i}: Status {status}")
        
        # æ˜¾ç¤ºæœ€ç»ˆç»Ÿè®¡ä¿¡æ¯
        stats = load_balancer.get_stats()
        print(f"\nFinal statistics:")
        print(f"Total requests: {stats['total_requests']}")
        print(f"Successful requests: {stats['successful_requests']}")
        print(f"Failed requests: {stats['failed_requests']}")
        print(f"Average response time: {stats['average_response_time']:.3f}s")
        
        for server_detail in stats['server_details']:
            print(f"  {server_detail['endpoint']}: {server_detail['current_connections']} connections")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    asyncio.run(demonstrate_load_balancing())
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**è½®è¯¢**: $O(1)$
**åŠ æƒè½®è¯¢**: $O(1)$
**æœ€å°‘è¿æ¥**: $O(n)$ å…¶ä¸­ $n$ æ˜¯æœåŠ¡å™¨æ•°é‡
**ä¸€è‡´æ€§å“ˆå¸Œ**: $O(\log n)$
**éšæœº**: $O(1)$

#### 4.2 ç©ºé—´å¤æ‚åº¦

**åŸºæœ¬è´Ÿè½½å‡è¡¡å™¨**: $O(n)$
**ä¸€è‡´æ€§å“ˆå¸Œ**: $O(n \cdot v)$ å…¶ä¸­ $v$ æ˜¯è™šæ‹ŸèŠ‚ç‚¹æ•°

### 5. è´Ÿè½½åˆ†å¸ƒåˆ†æ

#### 5.1 å‡åŒ€æ€§

**è½®è¯¢**: å®Œå…¨å‡åŒ€
**åŠ æƒè½®è¯¢**: æŒ‰æƒé‡å‡åŒ€
**æœ€å°‘è¿æ¥**: åŠ¨æ€å¹³è¡¡
**ä¸€è‡´æ€§å“ˆå¸Œ**: ç›¸å¯¹å‡åŒ€

#### 5.2 ç¨³å®šæ€§

**è½®è¯¢**: ç¨³å®š
**å“ˆå¸Œ**: ç¨³å®šï¼ˆç›¸åŒè¯·æ±‚æ€»æ˜¯è·¯ç”±åˆ°ç›¸åŒæœåŠ¡å™¨ï¼‰
**æœ€å°‘è¿æ¥**: åŠ¨æ€å˜åŒ–
**éšæœº**: ä¸ç¨³å®š

## ğŸ”— ç›¸å…³é“¾æ¥

- [å¾®æœåŠ¡åŸºç¡€](./05-01-01-å¾®æœåŠ¡åŸºç¡€.md)
- [æœåŠ¡æ‹†åˆ†](./05-01-02-æœåŠ¡æ‹†åˆ†.md)
- [æœåŠ¡å‘ç°](./05-01-03-æœåŠ¡å‘ç°.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Newman, S. (2021). "Building Microservices". O'Reilly Media.
2. Richardson, C. (2018). "Microservices Patterns". Manning Publications.
3. Karger, D., et al. (1997). "Consistent Hashing and Random Trees".

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant 