# é›†æˆæµ‹è¯•ç­–ç•¥

## ğŸ“‹ æ¦‚è¿°

é›†æˆæµ‹è¯•æ˜¯éªŒè¯å¤šä¸ªç»„ä»¶æˆ–æ¨¡å—ä¹‹é—´åä½œæ­£ç¡®æ€§çš„æµ‹è¯•æ–¹æ³•ï¼Œç¡®ä¿ç³»ç»Ÿå„éƒ¨åˆ†èƒ½å¤Ÿæ­£ç¡®é›†æˆå’ŒååŒå·¥ä½œã€‚

## 1. ç†è®ºåŸºç¡€

### 1.1 é›†æˆæµ‹è¯•å®šä¹‰

**å®šä¹‰ 1.1** (é›†æˆæµ‹è¯•)
é›†æˆæµ‹è¯•æ˜¯éªŒè¯å¤šä¸ªç»„ä»¶åä½œæ­£ç¡®æ€§çš„è¿‡ç¨‹ï¼š
$$\text{Integration Test} = (C, I, O, E, V)$$
å…¶ä¸­ï¼š

- $C$ æ˜¯ç»„ä»¶é›†åˆ
- $I$ æ˜¯ç»„ä»¶é—´æ¥å£
- $O$ æ˜¯é›†æˆæ“ä½œ
- $E$ æ˜¯æœŸæœ›ç»“æœ
- $V$ æ˜¯éªŒè¯å‡½æ•°

**å®šä¹‰ 1.2** (é›†æˆåº¦)
é›†æˆåº¦æ˜¯å·²æµ‹è¯•æ¥å£ä¸æ€»æ¥å£çš„æ¯”å€¼ï¼š
$$\text{Integration Coverage} = \frac{\text{Tested Interfaces}}{\text{Total Interfaces}} \times 100\%$$

**å®šä¹‰ 1.3** (æ¥å£å¤æ‚åº¦)
æ¥å£å¤æ‚åº¦æ˜¯æ¥å£å‚æ•°å’Œè¿”å›å€¼çš„å¤æ‚åº¦ï¼š
$$\text{Interface Complexity} = \sum_{i=1}^{n} (P_i + R_i)$$
å…¶ä¸­ $P_i$ æ˜¯ç¬¬ $i$ ä¸ªæ¥å£çš„å‚æ•°æ•°é‡ï¼Œ$R_i$ æ˜¯è¿”å›å€¼æ•°é‡ã€‚

### 1.2 é›†æˆç­–ç•¥æ¨¡å‹

**å®šä¹‰ 1.4** (è‡ªåº•å‘ä¸Šé›†æˆ)
ä»åº•å±‚ç»„ä»¶å¼€å§‹ï¼Œé€æ­¥å‘ä¸Šé›†æˆï¼š
$$\text{Bottom-Up} = (C_1, C_2, \ldots, C_n) \rightarrow (I_1, I_2, \ldots, I_{n-1})$$

**å®šä¹‰ 1.5** (è‡ªé¡¶å‘ä¸‹é›†æˆ)
ä»é¡¶å±‚ç»„ä»¶å¼€å§‹ï¼Œé€æ­¥å‘ä¸‹é›†æˆï¼š
$$\text{Top-Down} = (C_n, C_{n-1}, \ldots, C_1) \rightarrow (I_{n-1}, I_{n-2}, \ldots, I_1)$$

**å®šä¹‰ 1.6** (å¤§çˆ†ç‚¸é›†æˆ)
ä¸€æ¬¡æ€§é›†æˆæ‰€æœ‰ç»„ä»¶ï¼š
$$\text{Big-Bang} = (C_1, C_2, \ldots, C_n) \rightarrow I_{all}$$

## 2. Pythonå®ç°

### 2.1 é›†æˆæµ‹è¯•æ¡†æ¶

```python
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass
from abc import ABC, abstractmethod
import unittest
import pytest
import time
import threading
import queue
from concurrent.futures import ThreadPoolExecutor
from enum import Enum
import logging
import json
import requests
import sqlite3
import redis
from contextlib import contextmanager

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class IntegrationStrategy(Enum):
    """é›†æˆç­–ç•¥æšä¸¾"""
    BOTTOM_UP = "bottom_up"
    TOP_DOWN = "top_down"
    BIG_BANG = "big_bang"
    SANDWICH = "sandwich"

class ComponentStatus(Enum):
    """ç»„ä»¶çŠ¶æ€æšä¸¾"""
    READY = "ready"
    RUNNING = "running"
    FAILED = "failed"
    COMPLETED = "completed"

@dataclass
class Component:
    """ç»„ä»¶å®šä¹‰"""
    name: str
    dependencies: List[str]
    interfaces: Dict[str, Callable]
    status: ComponentStatus = ComponentStatus.READY
    
    def __post_init__(self):
        self.start_time = None
        self.end_time = None
        self.error_message = None

@dataclass
class IntegrationTestResult:
    """é›†æˆæµ‹è¯•ç»“æœ"""
    test_name: str
    strategy: IntegrationStrategy
    components: List[str]
    status: ComponentStatus
    execution_time: float = 0.0
    interface_tests: int = 0
    passed_tests: int = 0
    failed_tests: int = 0
    
    def __post_init__(self):
        self.start_time = time.time()
        self.end_time = None
    
    @property
    def duration(self) -> float:
        """æµ‹è¯•æŒç»­æ—¶é—´"""
        if self.end_time:
            return self.end_time - self.start_time
        return time.time() - self.start_time
    
    @property
    def success_rate(self) -> float:
        """æˆåŠŸç‡"""
        if self.interface_tests == 0:
            return 0.0
        return self.passed_tests / self.interface_tests

class IntegrationTestFramework:
    """é›†æˆæµ‹è¯•æ¡†æ¶"""
    
    def __init__(self):
        self.components: Dict[str, Component] = {}
        self.test_results: List[IntegrationTestResult] = []
        self.mock_services: Dict[str, Any] = {}
        self.lock = threading.Lock()
    
    def add_component(self, component: Component) -> None:
        """æ·»åŠ ç»„ä»¶"""
        with self.lock:
            self.components[component.name] = component
    
    def run_integration_test(self, strategy: IntegrationStrategy, 
                           test_name: str) -> IntegrationTestResult:
        """è¿è¡Œé›†æˆæµ‹è¯•"""
        result = IntegrationTestResult(
            test_name=test_name,
            strategy=strategy,
            components=list(self.components.keys()),
            status=ComponentStatus.RUNNING
        )
        
        try:
            if strategy == IntegrationStrategy.BOTTOM_UP:
                self._run_bottom_up_integration(result)
            elif strategy == IntegrationStrategy.TOP_DOWN:
                self._run_top_down_integration(result)
            elif strategy == IntegrationStrategy.BIG_BANG:
                self._run_big_bang_integration(result)
            elif strategy == IntegrationStrategy.SANDWICH:
                self._run_sandwich_integration(result)
            
            result.status = ComponentStatus.COMPLETED
            
        except Exception as e:
            result.status = ComponentStatus.FAILED
            result.error_message = str(e)
            logger.error(f"é›†æˆæµ‹è¯•å¤±è´¥: {e}")
        
        result.end_time = time.time()
        
        with self.lock:
            self.test_results.append(result)
        
        return result
    
    def _run_bottom_up_integration(self, result: IntegrationTestResult) -> None:
        """è‡ªåº•å‘ä¸Šé›†æˆæµ‹è¯•"""
        logger.info("å¼€å§‹è‡ªåº•å‘ä¸Šé›†æˆæµ‹è¯•")
        
        # æŒ‰ä¾èµ–å…³ç³»æ’åºç»„ä»¶
        sorted_components = self._topological_sort()
        
        for component_name in sorted_components:
            component = self.components[component_name]
            logger.info(f"æµ‹è¯•ç»„ä»¶: {component_name}")
            
            # æµ‹è¯•ç»„ä»¶æ¥å£
            interface_results = self._test_component_interfaces(component)
            result.interface_tests += len(interface_results)
            result.passed_tests += sum(1 for r in interface_results if r)
            result.failed_tests += sum(1 for r in interface_results if not r)
    
    def _run_top_down_integration(self, result: IntegrationTestResult) -> None:
        """è‡ªé¡¶å‘ä¸‹é›†æˆæµ‹è¯•"""
        logger.info("å¼€å§‹è‡ªé¡¶å‘ä¸‹é›†æˆæµ‹è¯•")
        
        # æ‰¾åˆ°é¡¶å±‚ç»„ä»¶ï¼ˆæ²¡æœ‰ä¾èµ–çš„ç»„ä»¶ï¼‰
        top_level_components = [
            name for name, component in self.components.items()
            if not component.dependencies
        ]
        
        for component_name in top_level_components:
            component = self.components[component_name]
            logger.info(f"æµ‹è¯•é¡¶å±‚ç»„ä»¶: {component_name}")
            
            # åˆ›å»ºæ¨¡æ‹Ÿä¾èµ–
            self._create_mock_dependencies(component)
            
            # æµ‹è¯•ç»„ä»¶æ¥å£
            interface_results = self._test_component_interfaces(component)
            result.interface_tests += len(interface_results)
            result.passed_tests += sum(1 for r in interface_results if r)
            result.failed_tests += sum(1 for r in interface_results if not r)
    
    def _run_big_bang_integration(self, result: IntegrationTestResult) -> None:
        """å¤§çˆ†ç‚¸é›†æˆæµ‹è¯•"""
        logger.info("å¼€å§‹å¤§çˆ†ç‚¸é›†æˆæµ‹è¯•")
        
        # ä¸€æ¬¡æ€§æµ‹è¯•æ‰€æœ‰ç»„ä»¶
        all_components = list(self.components.values())
        
        for component in all_components:
            logger.info(f"æµ‹è¯•ç»„ä»¶: {component.name}")
            
            # æµ‹è¯•ç»„ä»¶æ¥å£
            interface_results = self._test_component_interfaces(component)
            result.interface_tests += len(interface_results)
            result.passed_tests += sum(1 for r in interface_results if r)
            result.failed_tests += sum(1 for r in interface_results if not r)
    
    def _run_sandwich_integration(self, result: IntegrationTestResult) -> None:
        """ä¸‰æ˜æ²»é›†æˆæµ‹è¯•"""
        logger.info("å¼€å§‹ä¸‰æ˜æ²»é›†æˆæµ‹è¯•")
        
        # åŒæ—¶ä»é¡¶å±‚å’Œåº•å±‚å¼€å§‹é›†æˆ
        top_level = [name for name, comp in self.components.items() if not comp.dependencies]
        bottom_level = [name for name, comp in self.components.items() if not self._has_dependents(name)]
        
        # å¹¶è¡Œæµ‹è¯•é¡¶å±‚å’Œåº•å±‚ç»„ä»¶
        with ThreadPoolExecutor(max_workers=2) as executor:
            top_future = executor.submit(self._test_components, top_level)
            bottom_future = executor.submit(self._test_components, bottom_level)
            
            top_results = top_future.result()
            bottom_results = bottom_future.result()
            
            # åˆå¹¶ç»“æœ
            result.interface_tests = top_results['interface_tests'] + bottom_results['interface_tests']
            result.passed_tests = top_results['passed_tests'] + bottom_results['passed_tests']
            result.failed_tests = top_results['failed_tests'] + bottom_results['failed_tests']
    
    def _test_components(self, component_names: List[str]) -> Dict[str, int]:
        """æµ‹è¯•ç»„ä»¶é›†åˆ"""
        interface_tests = 0
        passed_tests = 0
        failed_tests = 0
        
        for component_name in component_names:
            component = self.components[component_name]
            interface_results = self._test_component_interfaces(component)
            interface_tests += len(interface_results)
            passed_tests += sum(1 for r in interface_results if r)
            failed_tests += sum(1 for r in interface_results if not r)
        
        return {
            'interface_tests': interface_tests,
            'passed_tests': passed_tests,
            'failed_tests': failed_tests
        }
    
    def _test_component_interfaces(self, component: Component) -> List[bool]:
        """æµ‹è¯•ç»„ä»¶æ¥å£"""
        results = []
        
        for interface_name, interface_func in component.interfaces.items():
            try:
                logger.info(f"æµ‹è¯•æ¥å£: {component.name}.{interface_name}")
                result = interface_func()
                results.append(result)
            except Exception as e:
                logger.error(f"æ¥å£æµ‹è¯•å¤±è´¥ {component.name}.{interface_name}: {e}")
                results.append(False)
        
        return results
    
    def _topological_sort(self) -> List[str]:
        """æ‹“æ‰‘æ’åº"""
        # ç®€åŒ–çš„æ‹“æ‰‘æ’åºå®ç°
        visited = set()
        result = []
        
        def dfs(component_name: str):
            if component_name in visited:
                return
            visited.add(component_name)
            
            component = self.components[component_name]
            for dep in component.dependencies:
                dfs(dep)
            
            result.append(component_name)
        
        for component_name in self.components:
            dfs(component_name)
        
        return result
    
    def _has_dependents(self, component_name: str) -> bool:
        """æ£€æŸ¥ç»„ä»¶æ˜¯å¦æœ‰ä¾èµ–è€…"""
        for component in self.components.values():
            if component_name in component.dependencies:
                return True
        return False
    
    def _create_mock_dependencies(self, component: Component) -> None:
        """åˆ›å»ºæ¨¡æ‹Ÿä¾èµ–"""
        for dep_name in component.dependencies:
            if dep_name not in self.mock_services:
                self.mock_services[dep_name] = MockService(dep_name)
    
    def get_test_report(self) -> Dict[str, Any]:
        """è·å–æµ‹è¯•æŠ¥å‘Š"""
        with self.lock:
            if not self.test_results:
                return {}
            
            total_tests = len(self.test_results)
            successful_tests = len([r for r in self.test_results if r.status == ComponentStatus.COMPLETED])
            failed_tests = len([r for r in self.test_results if r.status == ComponentStatus.FAILED])
            
            avg_execution_time = sum(r.duration for r in self.test_results) / total_tests
            avg_success_rate = sum(r.success_rate for r in self.test_results) / total_tests
            
            return {
                'total_tests': total_tests,
                'successful_tests': successful_tests,
                'failed_tests': failed_tests,
                'success_rate': successful_tests / total_tests,
                'average_execution_time': avg_execution_time,
                'average_interface_success_rate': avg_success_rate
            }

class MockService:
    """æ¨¡æ‹ŸæœåŠ¡"""
    
    def __init__(self, name: str):
        self.name = name
        self.responses = {}
        self.calls = []
    
    def set_response(self, method: str, response: Any) -> None:
        """è®¾ç½®å“åº”"""
        self.responses[method] = response
    
    def call(self, method: str, *args, **kwargs) -> Any:
        """æ¨¡æ‹Ÿè°ƒç”¨"""
        self.calls.append({
            'method': method,
            'args': args,
            'kwargs': kwargs,
            'timestamp': time.time()
        })
        return self.responses.get(method, None)
    
    def get_calls(self) -> List[Dict[str, Any]]:
        """è·å–è°ƒç”¨è®°å½•"""
        return self.calls.copy()

class DatabaseIntegrationTest:
    """æ•°æ®åº“é›†æˆæµ‹è¯•"""
    
    def __init__(self, db_url: str = ":memory:"):
        self.db_url = db_url
        self.connection = None
    
    def setup_database(self) -> None:
        """è®¾ç½®æ•°æ®åº“"""
        self.connection = sqlite3.connect(self.db_url)
        cursor = self.connection.cursor()
        
        # åˆ›å»ºæµ‹è¯•è¡¨
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                email TEXT UNIQUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS orders (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                amount REAL,
                status TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        """)
        
        self.connection.commit()
    
    def test_user_creation(self) -> bool:
        """æµ‹è¯•ç”¨æˆ·åˆ›å»º"""
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                "INSERT INTO users (name, email) VALUES (?, ?)",
                ("Test User", "test@example.com")
            )
            self.connection.commit()
            
            # éªŒè¯ç”¨æˆ·åˆ›å»º
            cursor.execute("SELECT * FROM users WHERE email = ?", ("test@example.com",))
            user = cursor.fetchone()
            return user is not None
        except Exception as e:
            logger.error(f"ç”¨æˆ·åˆ›å»ºæµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def test_order_creation(self) -> bool:
        """æµ‹è¯•è®¢å•åˆ›å»º"""
        try:
            cursor = self.connection.cursor()
            
            # å…ˆåˆ›å»ºç”¨æˆ·
            cursor.execute(
                "INSERT INTO users (name, email) VALUES (?, ?)",
                ("Order User", "order@example.com")
            )
            user_id = cursor.lastrowid
            
            # åˆ›å»ºè®¢å•
            cursor.execute(
                "INSERT INTO orders (user_id, amount, status) VALUES (?, ?, ?)",
                (user_id, 100.0, "pending")
            )
            self.connection.commit()
            
            # éªŒè¯è®¢å•åˆ›å»º
            cursor.execute("SELECT * FROM orders WHERE user_id = ?", (user_id,))
            order = cursor.fetchone()
            return order is not None
        except Exception as e:
            logger.error(f"è®¢å•åˆ›å»ºæµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def test_foreign_key_constraint(self) -> bool:
        """æµ‹è¯•å¤–é”®çº¦æŸ"""
        try:
            cursor = self.connection.cursor()
            
            # å°è¯•åˆ›å»ºæ— æ•ˆè®¢å•ï¼ˆä¸å­˜åœ¨çš„ç”¨æˆ·IDï¼‰
            cursor.execute(
                "INSERT INTO orders (user_id, amount, status) VALUES (?, ?, ?)",
                (99999, 100.0, "pending")
            )
            self.connection.commit()
            
            # å¦‚æœæˆåŠŸæ’å…¥ï¼Œè¯´æ˜å¤–é”®çº¦æŸå¤±æ•ˆ
            return False
        except sqlite3.IntegrityError:
            # å¤–é”®çº¦æŸæ­£å¸¸å·¥ä½œ
            return True
        except Exception as e:
            logger.error(f"å¤–é”®çº¦æŸæµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def cleanup(self) -> None:
        """æ¸…ç†æ•°æ®åº“"""
        if self.connection:
            self.connection.close()

class APIIntegrationTest:
    """APIé›†æˆæµ‹è¯•"""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.session = requests.Session()
    
    def test_user_api(self) -> bool:
        """æµ‹è¯•ç”¨æˆ·API"""
        try:
            # åˆ›å»ºç”¨æˆ·
            user_data = {
                "name": "Test User",
                "email": "test@example.com"
            }
            response = self.session.post(f"{self.base_url}/users", json=user_data)
            
            if response.status_code != 201:
                return False
            
            user_id = response.json().get("id")
            
            # è·å–ç”¨æˆ·
            response = self.session.get(f"{self.base_url}/users/{user_id}")
            if response.status_code != 200:
                return False
            
            # æ›´æ–°ç”¨æˆ·
            update_data = {"name": "Updated User"}
            response = self.session.put(f"{self.base_url}/users/{user_id}", json=update_data)
            if response.status_code != 200:
                return False
            
            # åˆ é™¤ç”¨æˆ·
            response = self.session.delete(f"{self.base_url}/users/{user_id}")
            if response.status_code != 204:
                return False
            
            return True
        except Exception as e:
            logger.error(f"ç”¨æˆ·APIæµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def test_order_api(self) -> bool:
        """æµ‹è¯•è®¢å•API"""
        try:
            # åˆ›å»ºç”¨æˆ·
            user_data = {"name": "Order User", "email": "order@example.com"}
            user_response = self.session.post(f"{self.base_url}/users", json=user_data)
            user_id = user_response.json().get("id")
            
            # åˆ›å»ºè®¢å•
            order_data = {
                "user_id": user_id,
                "amount": 100.0,
                "status": "pending"
            }
            response = self.session.post(f"{self.base_url}/orders", json=order_data)
            
            if response.status_code != 201:
                return False
            
            order_id = response.json().get("id")
            
            # è·å–è®¢å•
            response = self.session.get(f"{self.base_url}/orders/{order_id}")
            if response.status_code != 200:
                return False
            
            # æ›´æ–°è®¢å•çŠ¶æ€
            update_data = {"status": "completed"}
            response = self.session.put(f"{self.base_url}/orders/{order_id}", json=update_data)
            if response.status_code != 200:
                return False
            
            return True
        except Exception as e:
            logger.error(f"è®¢å•APIæµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def test_api_error_handling(self) -> bool:
        """æµ‹è¯•APIé”™è¯¯å¤„ç†"""
        try:
            # æµ‹è¯•æ— æ•ˆç”¨æˆ·ID
            response = self.session.get(f"{self.base_url}/users/99999")
            if response.status_code != 404:
                return False
            
            # æµ‹è¯•æ— æ•ˆæ•°æ®
            invalid_data = {"invalid": "data"}
            response = self.session.post(f"{self.base_url}/users", json=invalid_data)
            if response.status_code != 400:
                return False
            
            return True
        except Exception as e:
            logger.error(f"APIé”™è¯¯å¤„ç†æµ‹è¯•å¤±è´¥: {e}")
            return False

class MicroserviceIntegrationTest:
    """å¾®æœåŠ¡é›†æˆæµ‹è¯•"""
    
    def __init__(self):
        self.services = {}
        self.service_urls = {
            "user_service": "http://localhost:8001",
            "order_service": "http://localhost:8002",
            "payment_service": "http://localhost:8003"
        }
    
    def setup_services(self) -> None:
        """è®¾ç½®æœåŠ¡"""
        for service_name, url in self.service_urls.items():
            self.services[service_name] = requests.Session()
    
    def test_service_communication(self) -> bool:
        """æµ‹è¯•æœåŠ¡é—´é€šä¿¡"""
        try:
            # åˆ›å»ºç”¨æˆ·
            user_data = {"name": "Test User", "email": "test@example.com"}
            response = self.services["user_service"].post(
                f"{self.service_urls['user_service']}/users", 
                json=user_data
            )
            user_id = response.json().get("id")
            
            # åˆ›å»ºè®¢å•
            order_data = {"user_id": user_id, "amount": 100.0}
            response = self.services["order_service"].post(
                f"{self.service_urls['order_service']}/orders", 
                json=order_data
            )
            order_id = response.json().get("id")
            
            # å¤„ç†æ”¯ä»˜
            payment_data = {"order_id": order_id, "amount": 100.0}
            response = self.services["payment_service"].post(
                f"{self.service_urls['payment_service']}/payments", 
                json=payment_data
            )
            
            return response.status_code == 201
        except Exception as e:
            logger.error(f"æœåŠ¡é€šä¿¡æµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def test_service_discovery(self) -> bool:
        """æµ‹è¯•æœåŠ¡å‘ç°"""
        try:
            # æµ‹è¯•æœåŠ¡å¥åº·æ£€æŸ¥
            for service_name, url in self.service_urls.items():
                response = self.services[service_name].get(f"{url}/health")
                if response.status_code != 200:
                    return False
            
            return True
        except Exception as e:
            logger.error(f"æœåŠ¡å‘ç°æµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def test_circuit_breaker(self) -> bool:
        """æµ‹è¯•ç†”æ–­å™¨"""
        try:
            # æ¨¡æ‹ŸæœåŠ¡æ•…éšœ
            for i in range(5):
                try:
                    response = self.services["user_service"].get(
                        f"{self.service_urls['user_service']}/users/99999"
                    )
                except requests.exceptions.RequestException:
                    pass
            
            # éªŒè¯ç†”æ–­å™¨æ˜¯å¦è§¦å‘
            response = self.services["user_service"].get(
                f"{self.service_urls['user_service']}/users/1"
            )
            
            # ç†”æ–­å™¨åº”è¯¥è¿”å›é»˜è®¤å“åº”æˆ–é”™è¯¯
            return response.status_code in [503, 500]
        except Exception as e:
            logger.error(f"ç†”æ–­å™¨æµ‹è¯•å¤±è´¥: {e}")
            return False

# å®é™…åº”ç”¨ç¤ºä¾‹
def integration_test_example():
    """é›†æˆæµ‹è¯•ç¤ºä¾‹"""
    print("=== é›†æˆæµ‹è¯•ç¤ºä¾‹ ===")
    
    # åˆ›å»ºé›†æˆæµ‹è¯•æ¡†æ¶
    framework = IntegrationTestFramework()
    
    # å®šä¹‰ç»„ä»¶
    user_component = Component(
        name="user_service",
        dependencies=[],
        interfaces={
            "create_user": lambda: True,
            "get_user": lambda: True,
            "update_user": lambda: True
        }
    )
    
    order_component = Component(
        name="order_service",
        dependencies=["user_service"],
        interfaces={
            "create_order": lambda: True,
            "get_order": lambda: True,
            "update_order": lambda: True
        }
    )
    
    payment_component = Component(
        name="payment_service",
        dependencies=["order_service"],
        interfaces={
            "process_payment": lambda: True,
            "get_payment": lambda: True,
            "refund_payment": lambda: True
        }
    )
    
    # æ·»åŠ ç»„ä»¶
    framework.add_component(user_component)
    framework.add_component(order_component)
    framework.add_component(payment_component)
    
    # è¿è¡Œä¸åŒç­–ç•¥çš„é›†æˆæµ‹è¯•
    strategies = [
        IntegrationStrategy.BOTTOM_UP,
        IntegrationStrategy.TOP_DOWN,
        IntegrationStrategy.BIG_BANG,
        IntegrationStrategy.SANDWICH
    ]
    
    for strategy in strategies:
        print(f"\nè¿è¡Œ {strategy.value} é›†æˆæµ‹è¯•")
        result = framework.run_integration_test(strategy, f"{strategy.value}_test")
        
        print(f"  çŠ¶æ€: {result.status.value}")
        print(f"  æ‰§è¡Œæ—¶é—´: {result.duration:.3f}s")
        print(f"  æ¥å£æµ‹è¯•æ•°: {result.interface_tests}")
        print(f"  é€šè¿‡æµ‹è¯•æ•°: {result.passed_tests}")
        print(f"  å¤±è´¥æµ‹è¯•æ•°: {result.failed_tests}")
        print(f"  æˆåŠŸç‡: {result.success_rate:.2%}")
    
    # è·å–æµ‹è¯•æŠ¥å‘Š
    report = framework.get_test_report()
    print(f"\né›†æˆæµ‹è¯•æŠ¥å‘Š:")
    print(f"æ€»æµ‹è¯•æ•°: {report['total_tests']}")
    print(f"æˆåŠŸæµ‹è¯•æ•°: {report['successful_tests']}")
    print(f"å¤±è´¥æµ‹è¯•æ•°: {report['failed_tests']}")
    print(f"æˆåŠŸç‡: {report['success_rate']:.2%}")
    print(f"å¹³å‡æ‰§è¡Œæ—¶é—´: {report['average_execution_time']:.3f}s")
    print(f"å¹³å‡æ¥å£æˆåŠŸç‡: {report['average_interface_success_rate']:.2%}")

def database_integration_example():
    """æ•°æ®åº“é›†æˆæµ‹è¯•ç¤ºä¾‹"""
    print("\n=== æ•°æ®åº“é›†æˆæµ‹è¯•ç¤ºä¾‹ ===")
    
    db_test = DatabaseIntegrationTest()
    db_test.setup_database()
    
    # æµ‹è¯•ç”¨æˆ·åˆ›å»º
    print("æµ‹è¯•ç”¨æˆ·åˆ›å»º...")
    user_result = db_test.test_user_creation()
    print(f"  ç»“æœ: {'é€šè¿‡' if user_result else 'å¤±è´¥'}")
    
    # æµ‹è¯•è®¢å•åˆ›å»º
    print("æµ‹è¯•è®¢å•åˆ›å»º...")
    order_result = db_test.test_order_creation()
    print(f"  ç»“æœ: {'é€šè¿‡' if order_result else 'å¤±è´¥'}")
    
    # æµ‹è¯•å¤–é”®çº¦æŸ
    print("æµ‹è¯•å¤–é”®çº¦æŸ...")
    fk_result = db_test.test_foreign_key_constraint()
    print(f"  ç»“æœ: {'é€šè¿‡' if fk_result else 'å¤±è´¥'}")
    
    db_test.cleanup()

def api_integration_example():
    """APIé›†æˆæµ‹è¯•ç¤ºä¾‹"""
    print("\n=== APIé›†æˆæµ‹è¯•ç¤ºä¾‹ ===")
    
    api_test = APIIntegrationTest()
    
    # æµ‹è¯•ç”¨æˆ·API
    print("æµ‹è¯•ç”¨æˆ·API...")
    user_result = api_test.test_user_api()
    print(f"  ç»“æœ: {'é€šè¿‡' if user_result else 'å¤±è´¥'}")
    
    # æµ‹è¯•è®¢å•API
    print("æµ‹è¯•è®¢å•API...")
    order_result = api_test.test_order_api()
    print(f"  ç»“æœ: {'é€šè¿‡' if order_result else 'å¤±è´¥'}")
    
    # æµ‹è¯•é”™è¯¯å¤„ç†
    print("æµ‹è¯•é”™è¯¯å¤„ç†...")
    error_result = api_test.test_api_error_handling()
    print(f"  ç»“æœ: {'é€šè¿‡' if error_result else 'å¤±è´¥'}")

def microservice_integration_example():
    """å¾®æœåŠ¡é›†æˆæµ‹è¯•ç¤ºä¾‹"""
    print("\n=== å¾®æœåŠ¡é›†æˆæµ‹è¯•ç¤ºä¾‹ ===")
    
    ms_test = MicroserviceIntegrationTest()
    ms_test.setup_services()
    
    # æµ‹è¯•æœåŠ¡é€šä¿¡
    print("æµ‹è¯•æœåŠ¡é€šä¿¡...")
    comm_result = ms_test.test_service_communication()
    print(f"  ç»“æœ: {'é€šè¿‡' if comm_result else 'å¤±è´¥'}")
    
    # æµ‹è¯•æœåŠ¡å‘ç°
    print("æµ‹è¯•æœåŠ¡å‘ç°...")
    discovery_result = ms_test.test_service_discovery()
    print(f"  ç»“æœ: {'é€šè¿‡' if discovery_result else 'å¤±è´¥'}")
    
    # æµ‹è¯•ç†”æ–­å™¨
    print("æµ‹è¯•ç†”æ–­å™¨...")
    circuit_result = ms_test.test_circuit_breaker()
    print(f"  ç»“æœ: {'é€šè¿‡' if circuit_result else 'å¤±è´¥'}")

if __name__ == "__main__":
    # è¿è¡Œç¤ºä¾‹
    integration_test_example()
    database_integration_example()
    api_integration_example()
    microservice_integration_example()
```

## 3. é›†æˆç­–ç•¥

### 3.1 é›†æˆç­–ç•¥é€‰æ‹©

1. **è‡ªåº•å‘ä¸Šç­–ç•¥**
   - é€‚ç”¨åœºæ™¯ï¼šåº•å±‚ç»„ä»¶ç¨³å®šï¼Œé¡¶å±‚ç»„ä»¶ç»å¸¸å˜åŒ–
   - ä¼˜ç‚¹ï¼šå¯ä»¥åŠæ—©å‘ç°åº•å±‚é—®é¢˜
   - ç¼ºç‚¹ï¼šéœ€è¦å¤§é‡æ¨¡æ‹Ÿå¯¹è±¡

2. **è‡ªé¡¶å‘ä¸‹ç­–ç•¥**
   - é€‚ç”¨åœºæ™¯ï¼šé¡¶å±‚ç»„ä»¶ç¨³å®šï¼Œåº•å±‚ç»„ä»¶ç»å¸¸å˜åŒ–
   - ä¼˜ç‚¹ï¼šå¯ä»¥åŠæ—©éªŒè¯ç³»ç»Ÿæ¶æ„
   - ç¼ºç‚¹ï¼šéœ€è¦å¤§é‡æ¡©æ¨¡å—

3. **å¤§çˆ†ç‚¸ç­–ç•¥**
   - é€‚ç”¨åœºæ™¯ï¼šç»„ä»¶æ•°é‡å°‘ï¼Œä¾èµ–å…³ç³»ç®€å•
   - ä¼˜ç‚¹ï¼šæµ‹è¯•ç®€å•ï¼Œæ‰§è¡Œå¿«é€Ÿ
   - ç¼ºç‚¹ï¼šé—®é¢˜å®šä½å›°éš¾

4. **ä¸‰æ˜æ²»ç­–ç•¥**
   - é€‚ç”¨åœºæ™¯ï¼šç³»ç»Ÿè§„æ¨¡å¤§ï¼Œéœ€è¦å¹¶è¡Œæµ‹è¯•
   - ä¼˜ç‚¹ï¼šæµ‹è¯•æ•ˆç‡é«˜ï¼Œé—®é¢˜å®šä½å‡†ç¡®
   - ç¼ºç‚¹ï¼šå®ç°å¤æ‚

### 3.2 æµ‹è¯•æ•°æ®ç®¡ç†

1. **æµ‹è¯•æ•°æ®å‡†å¤‡**
   - ä½¿ç”¨æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
   - ç®¡ç†æµ‹è¯•æ•°æ®çš„ç”Ÿå‘½å‘¨æœŸ
   - ç¡®ä¿æµ‹è¯•æ•°æ®çš„éš”ç¦»æ€§

2. **ç¯å¢ƒç®¡ç†**
   - ä½¿ç”¨å®¹å™¨åŒ–æµ‹è¯•ç¯å¢ƒ
   - è‡ªåŠ¨åŒ–ç¯å¢ƒé…ç½®
   - ç¯å¢ƒæ¸…ç†å’Œé‡ç½®

### 3.3 æŒç»­é›†æˆ

1. **è‡ªåŠ¨åŒ–æµ‹è¯•**
   - é›†æˆåˆ°CI/CDæµæ°´çº¿
   - è‡ªåŠ¨åŒ–æµ‹è¯•æ‰§è¡Œ
   - æµ‹è¯•ç»“æœæŠ¥å‘Š

2. **æµ‹è¯•ç›‘æ§**
   - ç›‘æ§æµ‹è¯•æ‰§è¡Œæ—¶é—´
   - ç›‘æ§æµ‹è¯•æˆåŠŸç‡
   - è®¾ç½®å‘Šè­¦é˜ˆå€¼

## 4. æœ€ä½³å®è·µ

### 4.1 æµ‹è¯•è®¾è®¡åŸåˆ™

1. **æ¥å£ä¼˜å…ˆ**
   - ä¼˜å…ˆæµ‹è¯•ç»„ä»¶é—´æ¥å£
   - ç¡®ä¿æ¥å£å¥‘çº¦æ­£ç¡®
   - éªŒè¯æ•°æ®æ ¼å¼ä¸€è‡´æ€§

2. **ä¾èµ–ç®¡ç†**
   - æ˜ç¡®ç»„ä»¶ä¾èµ–å…³ç³»
   - ä½¿ç”¨ä¾èµ–æ³¨å…¥
   - é¿å…å¾ªç¯ä¾èµ–

3. **é”™è¯¯å¤„ç†**
   - æµ‹è¯•å¼‚å¸¸æƒ…å†µ
   - éªŒè¯é”™è¯¯å¤„ç†é€»è¾‘
   - ç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§

### 4.2 æµ‹è¯•æ‰§è¡Œç­–ç•¥

1. **å¹¶è¡Œæ‰§è¡Œ**
   - ç‹¬ç«‹æµ‹è¯•å¯ä»¥å¹¶è¡Œæ‰§è¡Œ
   - ä½¿ç”¨çº¿ç¨‹æ± æé«˜æ•ˆç‡
   - æ³¨æ„èµ„æºç«äº‰

2. **å¢é‡æµ‹è¯•**
   - åªæµ‹è¯•å˜æ›´çš„ç»„ä»¶
   - ä½¿ç”¨ä¾èµ–åˆ†æ
   - å‡å°‘æµ‹è¯•æ—¶é—´

3. **å›å½’æµ‹è¯•**
   - ç¡®ä¿æ–°åŠŸèƒ½ä¸ç ´åç°æœ‰åŠŸèƒ½
   - è‡ªåŠ¨åŒ–å›å½’æµ‹è¯•
   - å¿«é€Ÿåé¦ˆ

### 4.3 è´¨é‡ä¿è¯

```python
class IntegrationTestQuality:
    """é›†æˆæµ‹è¯•è´¨é‡ä¿è¯"""
    
    @staticmethod
    def validate_test_coverage(components: List[Component], 
                              test_results: List[IntegrationTestResult]) -> Dict[str, Any]:
        """éªŒè¯æµ‹è¯•è¦†ç›–ç‡"""
        total_interfaces = sum(len(comp.interfaces) for comp in components)
        tested_interfaces = sum(result.interface_tests for result in test_results)
        
        coverage = tested_interfaces / total_interfaces if total_interfaces > 0 else 0
        
        return {
            'total_interfaces': total_interfaces,
            'tested_interfaces': tested_interfaces,
            'coverage': coverage,
            'coverage_percentage': coverage * 100
        }
    
    @staticmethod
    def analyze_test_performance(test_results: List[IntegrationTestResult]) -> Dict[str, Any]:
        """åˆ†ææµ‹è¯•æ€§èƒ½"""
        if not test_results:
            return {}
        
        execution_times = [result.duration for result in test_results]
        success_rates = [result.success_rate for result in test_results]
        
        return {
            'average_execution_time': sum(execution_times) / len(execution_times),
            'max_execution_time': max(execution_times),
            'min_execution_time': min(execution_times),
            'average_success_rate': sum(success_rates) / len(success_rates),
            'total_tests': len(test_results)
        }
    
    @staticmethod
    def generate_test_report(components: List[Component], 
                           test_results: List[IntegrationTestResult]) -> str:
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        coverage = IntegrationTestQuality.validate_test_coverage(components, test_results)
        performance = IntegrationTestQuality.analyze_test_performance(test_results)
        
        report = f"""
é›†æˆæµ‹è¯•æŠ¥å‘Š
============

æµ‹è¯•è¦†ç›–ç‡
---------
æ€»æ¥å£æ•°: {coverage['total_interfaces']}
å·²æµ‹è¯•æ¥å£æ•°: {coverage['tested_interfaces']}
è¦†ç›–ç‡: {coverage['coverage_percentage']:.2f}%

æµ‹è¯•æ€§èƒ½
--------
æ€»æµ‹è¯•æ•°: {performance['total_tests']}
å¹³å‡æ‰§è¡Œæ—¶é—´: {performance['average_execution_time']:.3f}s
æœ€å¤§æ‰§è¡Œæ—¶é—´: {performance['max_execution_time']:.3f}s
æœ€å°æ‰§è¡Œæ—¶é—´: {performance['min_execution_time']:.3f}s
å¹³å‡æˆåŠŸç‡: {performance['average_success_rate']:.2%}

æµ‹è¯•ç»“æœè¯¦æƒ…
------------
"""
        
        for result in test_results:
            report += f"""
{result.test_name}:
  ç­–ç•¥: {result.strategy.value}
  çŠ¶æ€: {result.status.value}
  æ‰§è¡Œæ—¶é—´: {result.duration:.3f}s
  æ¥å£æµ‹è¯•æ•°: {result.interface_tests}
  é€šè¿‡æµ‹è¯•æ•°: {result.passed_tests}
  å¤±è´¥æµ‹è¯•æ•°: {result.failed_tests}
  æˆåŠŸç‡: {result.success_rate:.2%}
"""
        
        return report
```

## 5. æ€»ç»“

é›†æˆæµ‹è¯•æ˜¯ç¡®ä¿ç³»ç»Ÿç»„ä»¶æ­£ç¡®åä½œçš„å…³é”®æµ‹è¯•æ–¹æ³•ã€‚é€šè¿‡é€‰æ‹©åˆé€‚çš„é›†æˆç­–ç•¥ã€å»ºç«‹å®Œå–„çš„æµ‹è¯•æ¡†æ¶ã€éµå¾ªæœ€ä½³å®è·µï¼Œå¯ä»¥æœ‰æ•ˆåœ°éªŒè¯ç³»ç»Ÿçš„é›†æˆè´¨é‡ã€‚

### å…³é”®è¦ç‚¹

1. **ç†è®ºåŸºç¡€**: ç†è§£é›†æˆæµ‹è¯•çš„æ•°å­¦æ¨¡å‹å’Œç­–ç•¥
2. **å®ç°æŠ€æœ¯**: æŒæ¡é›†æˆæµ‹è¯•æ¡†æ¶å’Œå·¥å…·çš„ä½¿ç”¨
3. **æµ‹è¯•ç­–ç•¥**: æ ¹æ®ç³»ç»Ÿç‰¹ç‚¹é€‰æ‹©åˆé€‚çš„é›†æˆç­–ç•¥
4. **æœ€ä½³å®è·µ**: éµå¾ªé›†æˆæµ‹è¯•çš„è®¾è®¡å’Œæ‰§è¡ŒåŸåˆ™
5. **è´¨é‡ä¿è¯**: å»ºç«‹å®Œå–„çš„æµ‹è¯•è´¨é‡ä¿è¯ä½“ç³»

### åº”ç”¨åœºæ™¯

- **å¾®æœåŠ¡æ¶æ„**: éªŒè¯æœåŠ¡é—´åä½œ
- **æ¨¡å—åŒ–ç³»ç»Ÿ**: ç¡®ä¿æ¨¡å—æ­£ç¡®é›†æˆ
- **APIç³»ç»Ÿ**: éªŒè¯æ¥å£å¥‘çº¦
- **æ•°æ®åº“åº”ç”¨**: éªŒè¯æ•°æ®ä¸€è‡´æ€§
- **åˆ†å¸ƒå¼ç³»ç»Ÿ**: ç¡®ä¿ç³»ç»Ÿåè°ƒå·¥ä½œ

---

**ç›¸å…³æ–‡æ¡£**:

- [å•å…ƒæµ‹è¯•ç­–ç•¥](./07-04-01-å•å…ƒæµ‹è¯•ç­–ç•¥.md)
- [æ€§èƒ½æµ‹è¯•ç­–ç•¥](./07-04-03-æ€§èƒ½æµ‹è¯•ç­–ç•¥.md)
- [æµ‹è¯•æœ€ä½³å®è·µ](../07-02-æœ€ä½³å®è·µ/07-02-03-æµ‹è¯•æœ€ä½³å®è·µ.md)
