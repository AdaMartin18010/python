# 02-02-æ•°æ®ç»“æ„ç†è®º

## æ¦‚è¿°

æ•°æ®ç»“æ„ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒåŸºç¡€ï¼Œç ”ç©¶æ•°æ®çš„ç»„ç»‡ã€å­˜å‚¨å’Œæ“ä½œæ–¹å¼ã€‚å®ƒä¸ºç®—æ³•è®¾è®¡æä¾›äº†æŠ½è±¡çš„æ•°æ®æ¨¡å‹ï¼Œæ˜¯è½¯ä»¶å·¥ç¨‹ä¸­ç³»ç»Ÿè®¾è®¡å’Œæ€§èƒ½ä¼˜åŒ–çš„ç†è®ºåŸºç¡€ã€‚

## 1. æ¦‚å¿µè§£é‡Š

### 1.1 æ•°æ®ç»“æ„çš„åŸºæœ¬æ¦‚å¿µ

**æ•°æ®ç»“æ„**æ˜¯è®¡ç®—æœºä¸­å­˜å‚¨ã€ç»„ç»‡æ•°æ®çš„æ–¹å¼ï¼Œå®šä¹‰äº†æ•°æ®å…ƒç´ ä¹‹é—´çš„å…³ç³»å’Œæ“ä½œã€‚

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š

- **æ•°æ®å…ƒç´ **ï¼šæ•°æ®ç»“æ„ä¸­çš„åŸºæœ¬å•ä½
- **æ•°æ®é¡¹**ï¼šæ•°æ®å…ƒç´ çš„ç»„æˆéƒ¨åˆ†
- **å…³ç³»**ï¼šæ•°æ®å…ƒç´ ä¹‹é—´çš„é€»è¾‘å…³ç³»
- **æ“ä½œ**ï¼šå¯¹æ•°æ®ç»“æ„çš„åŸºæœ¬æ“ä½œ
- **å­˜å‚¨**ï¼šæ•°æ®åœ¨å†…å­˜ä¸­çš„ç‰©ç†è¡¨ç¤º

### 1.2 æ•°æ®ç»“æ„çš„åˆ†ç±»

1. **æŒ‰é€»è¾‘ç»“æ„**ï¼š
   - çº¿æ€§ç»“æ„ï¼šæ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—
   - éçº¿æ€§ç»“æ„ï¼šæ ‘ã€å›¾ã€é›†åˆ
   - æ–‡ä»¶ç»“æ„ï¼šé¡ºåºæ–‡ä»¶ã€ç´¢å¼•æ–‡ä»¶

2. **æŒ‰å­˜å‚¨ç»“æ„**ï¼š
   - é¡ºåºå­˜å‚¨ï¼šæ•°ç»„ã€é¡ºåºè¡¨
   - é“¾å¼å­˜å‚¨ï¼šé“¾è¡¨ã€æ ‘
   - ç´¢å¼•å­˜å‚¨ï¼šç´¢å¼•è¡¨ã€æ•£åˆ—è¡¨
   - æ•£åˆ—å­˜å‚¨ï¼šå“ˆå¸Œè¡¨

3. **æŒ‰æ“ä½œç‰¹æ€§**ï¼š
   - é™æ€ç»“æ„ï¼šå¤§å°å›ºå®š
   - åŠ¨æ€ç»“æ„ï¼šå¤§å°å¯å˜
   - å—é™ç»“æ„ï¼šæ“ä½œå—é™

### 1.3 åœ¨è½¯ä»¶å·¥ç¨‹ä¸­çš„åº”ç”¨

- **ç³»ç»Ÿè®¾è®¡**ï¼šé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
- **ç®—æ³•å®ç°**ï¼šåŸºäºæ•°æ®ç»“æ„å®ç°ç®—æ³•
- **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–æ•°æ®è®¿é—®å’Œæ“ä½œ
- **å†…å­˜ç®¡ç†**ï¼šé«˜æ•ˆçš„å†…å­˜ä½¿ç”¨

## 2. æ•°å­¦å½¢å¼

### 2.1 æ•°æ®ç»“æ„çš„æ•°å­¦å®šä¹‰

**æŠ½è±¡æ•°æ®ç±»å‹ï¼ˆADTï¼‰**ï¼š

```math
\text{ADT} = (D, O, A)
```

å…¶ä¸­ï¼š

- $D$ æ˜¯æ•°æ®å¯¹è±¡é›†
- $O$ æ˜¯æ“ä½œé›†
- $A$ æ˜¯å…¬ç†é›†

**çº¿æ€§è¡¨**ï¼š

```math
L = (a_1, a_2, \ldots, a_n)
```

å…¶ä¸­ $a_i$ æ˜¯æ•°æ®å…ƒç´ ï¼Œ$n$ æ˜¯è¡¨é•¿ã€‚

**æ ˆ**ï¼š

```math
S = (a_1, a_2, \ldots, a_n) \quad \text{with} \quad \text{top}(S) = a_n
```

**é˜Ÿåˆ—**ï¼š

```math
Q = (a_1, a_2, \ldots, a_n) \quad \text{with} \quad \text{front}(Q) = a_1, \text{rear}(Q) = a_n
```

### 2.2 æ ‘ç»“æ„çš„æ•°å­¦å®šä¹‰

**äºŒå‰æ ‘**ï¼š

```math
T = \begin{cases}
\emptyset & \text{if } T \text{ is empty} \\
(r, T_L, T_R) & \text{otherwise}
\end{cases}
```

å…¶ä¸­ $r$ æ˜¯æ ¹èŠ‚ç‚¹ï¼Œ$T_L$ å’Œ $T_R$ æ˜¯å·¦å³å­æ ‘ã€‚

**æ ‘çš„é«˜åº¦**ï¼š

```math
h(T) = \begin{cases}
0 & \text{if } T = \emptyset \\
1 + \max(h(T_L), h(T_R)) & \text{otherwise}
\end{cases}
```

**å®Œå…¨äºŒå‰æ ‘**ï¼š

```math
\text{Complete}(T) \iff \text{all levels are filled except possibly the last}
```

### 2.3 å›¾ç»“æ„çš„æ•°å­¦å®šä¹‰

**å›¾**ï¼š

```math
G = (V, E)
```

å…¶ä¸­ï¼š

- $V$ æ˜¯é¡¶ç‚¹é›†
- $E \subseteq V \times V$ æ˜¯è¾¹é›†

**é‚»æ¥çŸ©é˜µ**ï¼š

```math
A[i][j] = \begin{cases}
1 & \text{if } (v_i, v_j) \in E \\
0 & \text{otherwise}
\end{cases}
```

**é‚»æ¥è¡¨**ï¼š

```math
\text{Adj}[v] = \{u \mid (v, u) \in E\}
```

### 2.4 æ•£åˆ—è¡¨çš„æ•°å­¦å®šä¹‰

**æ•£åˆ—å‡½æ•°**ï¼š

```math
h: U \rightarrow \{0, 1, \ldots, m-1\}
```

å…¶ä¸­ $U$ æ˜¯é”®çš„å®‡å®™ï¼Œ$m$ æ˜¯è¡¨å¤§å°ã€‚

**å†²çª**ï¼š

```math
\text{Collision}(k_1, k_2) \iff h(k_1) = h(k_2) \text{ and } k_1 \neq k_2
```

**è´Ÿè½½å› å­**ï¼š

```math
\alpha = \frac{n}{m}
```

å…¶ä¸­ $n$ æ˜¯å…ƒç´ æ•°é‡ï¼Œ$m$ æ˜¯è¡¨å¤§å°ã€‚

## 3. ä»£ç å®ç°

### 3.1 åŸºæœ¬æ•°æ®ç»“æ„å®ç°

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Any, List, Optional, Dict, Set
from dataclasses import dataclass
from enum import Enum
import math

T = TypeVar('T')

class ADT(ABC, Generic[T]):
    """æŠ½è±¡æ•°æ®ç±»å‹åŸºç±»"""
    
    @abstractmethod
    def is_empty(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç©º"""
        pass
    
    @abstractmethod
    def size(self) -> int:
        """è·å–å¤§å°"""
        pass
    
    @abstractmethod
    def clear(self) -> None:
        """æ¸…ç©º"""
        pass

class Stack(ADT[T]):
    """æ ˆæŠ½è±¡æ•°æ®ç±»å‹"""
    
    @abstractmethod
    def push(self, item: T) -> None:
        """å…¥æ ˆ"""
        pass
    
    @abstractmethod
    def pop(self) -> T:
        """å‡ºæ ˆ"""
        pass
    
    @abstractmethod
    def peek(self) -> T:
        """æŸ¥çœ‹æ ˆé¡¶"""
        pass

class Queue(ADT[T]):
    """é˜Ÿåˆ—æŠ½è±¡æ•°æ®ç±»å‹"""
    
    @abstractmethod
    def enqueue(self, item: T) -> None:
        """å…¥é˜Ÿ"""
        pass
    
    @abstractmethod
    def dequeue(self) -> T:
        """å‡ºé˜Ÿ"""
        pass
    
    @abstractmethod
    def front(self) -> T:
        """æŸ¥çœ‹é˜Ÿé¦–"""
        pass

class PriorityQueue(ADT[T]):
    """ä¼˜å…ˆé˜Ÿåˆ—æŠ½è±¡æ•°æ®ç±»å‹"""
    
    @abstractmethod
    def insert(self, item: T, priority: float) -> None:
        """æ’å…¥å…ƒç´ """
        pass
    
    @abstractmethod
    def extract_max(self) -> T:
        """æå–æœ€å¤§ä¼˜å…ˆçº§å…ƒç´ """
        pass
    
    @abstractmethod
    def peek_max(self) -> T:
        """æŸ¥çœ‹æœ€å¤§ä¼˜å…ˆçº§å…ƒç´ """
        pass

class ADTValidator:
    """ADTéªŒè¯å™¨"""
    
    @staticmethod
    def validate_stack(stack: Stack[T]) -> bool:
        """éªŒè¯æ ˆçš„å…¬ç†"""
        # å…¬ç†1: ç©ºæ ˆçš„popæ“ä½œåº”è¯¥æŠ›å‡ºå¼‚å¸¸
        try:
            empty_stack = type(stack)()
            empty_stack.pop()
            return False  # åº”è¯¥æŠ›å‡ºå¼‚å¸¸
        except:
            pass
        
        # å…¬ç†2: pushåpopåº”è¯¥è¿”å›ç›¸åŒçš„å…ƒç´ 
        test_stack = type(stack)()
        test_item = "test_item"
        test_stack.push(test_item)
        popped_item = test_stack.pop()
        if popped_item != test_item:
            return False
        
        # å…¬ç†3: æ ˆçš„å¤§å°åº”è¯¥æ­£ç¡®
        test_stack = type(stack)()
        if not test_stack.is_empty():
            return False
        
        test_stack.push("item1")
        test_stack.push("item2")
        if test_stack.size() != 2:
            return False
        
        return True
    
    @staticmethod
    def validate_queue(queue: Queue[T]) -> bool:
        """éªŒè¯é˜Ÿåˆ—çš„å…¬ç†"""
        # å…¬ç†1: ç©ºé˜Ÿåˆ—çš„dequeueæ“ä½œåº”è¯¥æŠ›å‡ºå¼‚å¸¸
        try:
            empty_queue = type(queue)()
            empty_queue.dequeue()
            return False  # åº”è¯¥æŠ›å‡ºå¼‚å¸¸
        except:
            pass
        
        # å…¬ç†2: FIFOæ€§è´¨
        test_queue = type(queue)()
        test_queue.enqueue("item1")
        test_queue.enqueue("item2")
        
        if test_queue.dequeue() != "item1":
            return False
        if test_queue.dequeue() != "item2":
            return False
        
        return True

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_adt():
    """æ¼”ç¤ºæŠ½è±¡æ•°æ®ç±»å‹"""
    print("æŠ½è±¡æ•°æ®ç±»å‹æ¼”ç¤º")
    print("=" * 40)
    
    # è¿™é‡Œåªæ˜¯æ¼”ç¤ºæ¥å£ï¼Œå®é™…å®ç°ä¼šåœ¨åé¢æä¾›
    print("ADTå®šä¹‰äº†æ•°æ®ç»“æ„çš„æ¥å£è§„èŒƒ")
    print("åŒ…æ‹¬æ“ä½œé›†åˆå’Œå…¬ç†é›†åˆ")
    print("ç¡®ä¿å®ç°çš„ä¸€è‡´æ€§å’Œæ­£ç¡®æ€§")

if __name__ == "__main__":
    demonstrate_adt()
```

### 3.2 çº¿æ€§æ•°æ®ç»“æ„å®ç°

```python
from typing import List, Optional, Any
import copy

class DynamicArray:
    """åŠ¨æ€æ•°ç»„å®ç°"""
    
    def __init__(self, initial_capacity: int = 10):
        self.capacity = initial_capacity
        self.size = 0
        self.data = [None] * initial_capacity
    
    def __len__(self) -> int:
        return self.size
    
    def __getitem__(self, index: int) -> Any:
        if not 0 <= index < self.size:
            raise IndexError("Index out of bounds")
        return self.data[index]
    
    def __setitem__(self, index: int, value: Any) -> None:
        if not 0 <= index < self.size:
            raise IndexError("Index out of bounds")
        self.data[index] = value
    
    def append(self, value: Any) -> None:
        """åœ¨æœ«å°¾æ·»åŠ å…ƒç´ """
        if self.size == self.capacity:
            self._resize(2 * self.capacity)
        
        self.data[self.size] = value
        self.size += 1
    
    def insert(self, index: int, value: Any) -> None:
        """åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ """
        if not 0 <= index <= self.size:
            raise IndexError("Index out of bounds")
        
        if self.size == self.capacity:
            self._resize(2 * self.capacity)
        
        # ç§»åŠ¨å…ƒç´ 
        for i in range(self.size, index, -1):
            self.data[i] = self.data[i-1]
        
        self.data[index] = value
        self.size += 1
    
    def remove(self, index: int) -> Any:
        """åˆ é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ """
        if not 0 <= index < self.size:
            raise IndexError("Index out of bounds")
        
        value = self.data[index]
        
        # ç§»åŠ¨å…ƒç´ 
        for i in range(index, self.size - 1):
            self.data[i] = self.data[i+1]
        
        self.size -= 1
        
        # å¦‚æœå¤§å°å°äºå®¹é‡çš„1/4ï¼Œç¼©å°å®¹é‡
        if self.size < self.capacity // 4:
            self._resize(self.capacity // 2)
        
        return value
    
    def _resize(self, new_capacity: int) -> None:
        """è°ƒæ•´æ•°ç»„å®¹é‡"""
        new_data = [None] * new_capacity
        for i in range(self.size):
            new_data[i] = self.data[i]
        self.data = new_data
        self.capacity = new_capacity
    
    def __str__(self) -> str:
        return str(self.data[:self.size])
    
    def __repr__(self) -> str:
        return f"DynamicArray(size={self.size}, capacity={self.capacity})"

class StackArray(Stack[T]):
    """åŸºäºæ•°ç»„çš„æ ˆå®ç°"""
    
    def __init__(self):
        self.array = DynamicArray()
    
    def push(self, item: T) -> None:
        """å…¥æ ˆ"""
        self.array.append(item)
    
    def pop(self) -> T:
        """å‡ºæ ˆ"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.array.remove(self.array.size - 1)
    
    def peek(self) -> T:
        """æŸ¥çœ‹æ ˆé¡¶"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.array[self.array.size - 1]
    
    def is_empty(self) -> bool:
        return self.array.size == 0
    
    def size(self) -> int:
        return self.array.size
    
    def clear(self) -> None:
        self.array = DynamicArray()

class QueueArray(Queue[T]):
    """åŸºäºæ•°ç»„çš„é˜Ÿåˆ—å®ç°"""
    
    def __init__(self):
        self.array = DynamicArray()
    
    def enqueue(self, item: T) -> None:
        """å…¥é˜Ÿ"""
        self.array.append(item)
    
    def dequeue(self) -> T:
        """å‡ºé˜Ÿ"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.array.remove(0)
    
    def front(self) -> T:
        """æŸ¥çœ‹é˜Ÿé¦–"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.array[0]
    
    def is_empty(self) -> bool:
        return self.array.size == 0
    
    def size(self) -> int:
        return self.array.size
    
    def clear(self) -> None:
        self.array = DynamicArray()

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_linear_structures():
    """æ¼”ç¤ºçº¿æ€§æ•°æ®ç»“æ„"""
    print("çº¿æ€§æ•°æ®ç»“æ„æ¼”ç¤º")
    print("=" * 40)
    
    # åŠ¨æ€æ•°ç»„
    arr = DynamicArray()
    for i in range(5):
        arr.append(i)
    print(f"åŠ¨æ€æ•°ç»„: {arr}")
    
    arr.insert(2, 10)
    print(f"æ’å…¥å: {arr}")
    
    arr.remove(1)
    print(f"åˆ é™¤å: {arr}")
    
    # æ ˆ
    stack = StackArray()
    for i in range(3):
        stack.push(i)
    print(f"æ ˆ: {[stack.pop() for _ in range(3)]}")
    
    # é˜Ÿåˆ—
    queue = QueueArray()
    for i in range(3):
        queue.enqueue(i)
    print(f"é˜Ÿåˆ—: {[queue.dequeue() for _ in range(3)]}")

if __name__ == "__main__":
    demonstrate_linear_structures()
```

### 3.3 æ ‘å½¢æ•°æ®ç»“æ„å®ç°

```python
from typing import Optional, List, Any
from dataclasses import dataclass

@dataclass
class TreeNode:
    """æ ‘èŠ‚ç‚¹"""
    value: Any
    left: Optional['TreeNode'] = None
    right: Optional['TreeNode'] = None
    parent: Optional['TreeNode'] = None

class BinaryTree:
    """äºŒå‰æ ‘å®ç°"""
    
    def __init__(self):
        self.root: Optional[TreeNode] = None
        self.size = 0
    
    def insert(self, value: Any) -> None:
        """æ’å…¥èŠ‚ç‚¹"""
        if self.root is None:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)
        self.size += 1
    
    def _insert_recursive(self, node: TreeNode, value: Any) -> None:
        """é€’å½’æ’å…¥"""
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
                node.left.parent = node
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
                node.right.parent = node
            else:
                self._insert_recursive(node.right, value)
    
    def search(self, value: Any) -> Optional[TreeNode]:
        """æœç´¢èŠ‚ç‚¹"""
        return self._search_recursive(self.root, value)
    
    def _search_recursive(self, node: Optional[TreeNode], value: Any) -> Optional[TreeNode]:
        """é€’å½’æœç´¢"""
        if node is None or node.value == value:
            return node
        
        if value < node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)
    
    def delete(self, value: Any) -> bool:
        """åˆ é™¤èŠ‚ç‚¹"""
        node = self.search(value)
        if node is None:
            return False
        
        self._delete_node(node)
        self.size -= 1
        return True
    
    def _delete_node(self, node: TreeNode) -> None:
        """åˆ é™¤æŒ‡å®šèŠ‚ç‚¹"""
        # æƒ…å†µ1: å¶å­èŠ‚ç‚¹
        if node.left is None and node.right is None:
            if node.parent is None:
                self.root = None
            elif node.parent.left == node:
                node.parent.left = None
            else:
                node.parent.right = None
        
        # æƒ…å†µ2: åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹
        elif node.left is None:
            self._replace_node(node, node.right)
        elif node.right is None:
            self._replace_node(node, node.left)
        
        # æƒ…å†µ3: æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
        else:
            successor = self._find_min(node.right)
            node.value = successor.value
            self._delete_node(successor)
    
    def _replace_node(self, old_node: TreeNode, new_node: Optional[TreeNode]) -> None:
        """æ›¿æ¢èŠ‚ç‚¹"""
        if old_node.parent is None:
            self.root = new_node
        elif old_node.parent.left == old_node:
            old_node.parent.left = new_node
        else:
            old_node.parent.right = new_node
        
        if new_node is not None:
            new_node.parent = old_node.parent
    
    def _find_min(self, node: TreeNode) -> TreeNode:
        """æŸ¥æ‰¾æœ€å°å€¼èŠ‚ç‚¹"""
        while node.left is not None:
            node = node.left
        return node
    
    def height(self) -> int:
        """è®¡ç®—æ ‘çš„é«˜åº¦"""
        return self._height_recursive(self.root)
    
    def _height_recursive(self, node: Optional[TreeNode]) -> int:
        """é€’å½’è®¡ç®—é«˜åº¦"""
        if node is None:
            return -1
        return max(self._height_recursive(node.left), 
                  self._height_recursive(node.right)) + 1
    
    def inorder_traversal(self) -> List[Any]:
        """ä¸­åºéå†"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node: Optional[TreeNode], result: List[Any]) -> None:
        """é€’å½’ä¸­åºéå†"""
        if node is not None:
            self._inorder_recursive(node.left, result)
            result.append(node.value)
            self._inorder_recursive(node.right, result)
    
    def preorder_traversal(self) -> List[Any]:
        """å‰åºéå†"""
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node: Optional[TreeNode], result: List[Any]) -> None:
        """é€’å½’å‰åºéå†"""
        if node is not None:
            result.append(node.value)
            self._preorder_recursive(node.left, result)
            self._preorder_recursive(node.right, result)
    
    def postorder_traversal(self) -> List[Any]:
        """ååºéå†"""
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node: Optional[TreeNode], result: List[Any]) -> None:
        """é€’å½’ååºéå†"""
        if node is not None:
            self._postorder_recursive(node.left, result)
            self._postorder_recursive(node.right, result)
            result.append(node.value)

class AVLTree(BinaryTree):
    """AVLå¹³è¡¡äºŒå‰æ ‘"""
    
    def insert(self, value: Any) -> None:
        """æ’å…¥å¹¶å¹³è¡¡"""
        super().insert(value)
        node = self.search(value)
        self._rebalance(node)
    
    def _rebalance(self, node: TreeNode) -> None:
        """é‡æ–°å¹³è¡¡"""
        while node is not None:
            balance = self._get_balance(node)
            
            # å·¦é‡
            if balance > 1:
                if self._get_balance(node.left) < 0:
                    self._left_rotate(node.left)
                self._right_rotate(node)
            
            # å³é‡
            elif balance < -1:
                if self._get_balance(node.right) > 0:
                    self._right_rotate(node.right)
                self._left_rotate(node)
            
            node = node.parent
    
    def _get_balance(self, node: TreeNode) -> int:
        """è·å–å¹³è¡¡å› å­"""
        return self._height_recursive(node.left) - self._height_recursive(node.right)
    
    def _left_rotate(self, node: TreeNode) -> None:
        """å·¦æ—‹"""
        right_child = node.right
        if right_child is None:
            return
        
        # æ›´æ–°çˆ¶èŠ‚ç‚¹å…³ç³»
        right_child.parent = node.parent
        if node.parent is None:
            self.root = right_child
        elif node.parent.left == node:
            node.parent.left = right_child
        else:
            node.parent.right = right_child
        
        # æ›´æ–°å­èŠ‚ç‚¹å…³ç³»
        node.right = right_child.left
        if right_child.left is not None:
            right_child.left.parent = node
        
        right_child.left = node
        node.parent = right_child
    
    def _right_rotate(self, node: TreeNode) -> None:
        """å³æ—‹"""
        left_child = node.left
        if left_child is None:
            return
        
        # æ›´æ–°çˆ¶èŠ‚ç‚¹å…³ç³»
        left_child.parent = node.parent
        if node.parent is None:
            self.root = left_child
        elif node.parent.left == node:
            node.parent.left = left_child
        else:
            node.parent.right = left_child
        
        # æ›´æ–°å­èŠ‚ç‚¹å…³ç³»
        node.left = left_child.right
        if left_child.right is not None:
            left_child.right.parent = node
        
        left_child.right = node
        node.parent = left_child

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_tree_structures():
    """æ¼”ç¤ºæ ‘å½¢æ•°æ®ç»“æ„"""
    print("æ ‘å½¢æ•°æ®ç»“æ„æ¼”ç¤º")
    print("=" * 40)
    
    # æ™®é€šäºŒå‰æ ‘
    tree = BinaryTree()
    values = [5, 3, 7, 2, 4, 6, 8]
    for value in values:
        tree.insert(value)
    
    print(f"ä¸­åºéå†: {tree.inorder_traversal()}")
    print(f"å‰åºéå†: {tree.preorder_traversal()}")
    print(f"ååºéå†: {tree.postorder_traversal()}")
    print(f"æ ‘çš„é«˜åº¦: {tree.height()}")
    
    # AVLæ ‘
    avl_tree = AVLTree()
    for value in values:
        avl_tree.insert(value)
    
    print(f"AVLæ ‘ä¸­åºéå†: {avl_tree.inorder_traversal()}")
    print(f"AVLæ ‘é«˜åº¦: {avl_tree.height()}")

if __name__ == "__main__":
    demonstrate_tree_structures()
```

### 3.4 å›¾æ•°æ®ç»“æ„å®ç°

```python
from typing import Dict, List, Set, Tuple, Optional, Any
from dataclasses import dataclass
from collections import defaultdict
import heapq

@dataclass
class Edge:
    """è¾¹"""
    source: int
    target: int
    weight: float = 1.0
    
    def __str__(self):
        return f"({self.source} -> {self.target}, w={self.weight})"

class Graph:
    """å›¾å®ç°"""
    
    def __init__(self, directed: bool = False):
        self.directed = directed
        self.vertices: Set[int] = set()
        self.edges: List[Edge] = []
        self.adjacency_list: Dict[int, List[Edge]] = defaultdict(list)
    
    def add_vertex(self, vertex: int) -> None:
        """æ·»åŠ é¡¶ç‚¹"""
        self.vertices.add(vertex)
    
    def add_edge(self, source: int, target: int, weight: float = 1.0) -> None:
        """æ·»åŠ è¾¹"""
        edge = Edge(source, target, weight)
        self.edges.append(edge)
        self.adjacency_list[source].append(edge)
        
        if not self.directed:
            reverse_edge = Edge(target, source, weight)
            self.adjacency_list[target].append(reverse_edge)
    
    def get_neighbors(self, vertex: int) -> List[int]:
        """è·å–é‚»å±…"""
        return [edge.target for edge in self.adjacency_list[vertex]]
    
    def get_edge_weight(self, source: int, target: int) -> Optional[float]:
        """è·å–è¾¹æƒé‡"""
        for edge in self.adjacency_list[source]:
            if edge.target == target:
                return edge.weight
        return None
    
    def bfs(self, start: int) -> List[int]:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        queue = [start]
        result = []
        
        while queue:
            vertex = queue.pop(0)
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return result
    
    def dfs(self, start: int) -> List[int]:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        result = []
        
        def dfs_recursive(vertex: int):
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                
                for neighbor in self.get_neighbors(vertex):
                    dfs_recursive(neighbor)
        
        dfs_recursive(start)
        return result
    
    def dijkstra(self, start: int) -> Dict[int, float]:
        """Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•"""
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[start] = 0
        
        pq = [(0, start)]
        visited = set()
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_vertex in visited:
                continue
            
            visited.add(current_vertex)
            
            for neighbor in self.get_neighbors(current_vertex):
                weight = self.get_edge_weight(current_vertex, neighbor)
                if weight is None:
                    continue
                
                distance = current_distance + weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        
        return distances
    
    def bellman_ford(self, start: int) -> Optional[Dict[int, float]]:
        """Bellman-Fordæœ€çŸ­è·¯å¾„ç®—æ³•"""
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[start] = 0
        
        # æ¾å¼›æ“ä½œ
        for _ in range(len(self.vertices) - 1):
            for edge in self.edges:
                if distances[edge.source] + edge.weight < distances[edge.target]:
                    distances[edge.target] = distances[edge.source] + edge.weight
        
        # æ£€æŸ¥è´Ÿç¯
        for edge in self.edges:
            if distances[edge.source] + edge.weight < distances[edge.target]:
                return None  # å­˜åœ¨è´Ÿç¯
        
        return distances
    
    def prim_mst(self) -> List[Edge]:
        """Primæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
        if not self.vertices:
            return []
        
        start_vertex = next(iter(self.vertices))
        mst_edges = []
        visited = {start_vertex}
        pq = []
        
        # åˆå§‹åŒ–ä¼˜å…ˆé˜Ÿåˆ—
        for edge in self.adjacency_list[start_vertex]:
            heapq.heappush(pq, (edge.weight, edge))
        
        while pq and len(visited) < len(self.vertices):
            weight, edge = heapq.heappop(pq)
            
            if edge.target in visited:
                continue
            
            visited.add(edge.target)
            mst_edges.append(edge)
            
            # æ·»åŠ æ–°é¡¶ç‚¹çš„è¾¹
            for new_edge in self.adjacency_list[edge.target]:
                if new_edge.target not in visited:
                    heapq.heappush(pq, (new_edge.weight, new_edge))
        
        return mst_edges
    
    def kruskal_mst(self) -> List[Edge]:
        """Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
        # æ’åºè¾¹
        sorted_edges = sorted(self.edges, key=lambda e: e.weight)
        
        # å¹¶æŸ¥é›†
        parent = {vertex: vertex for vertex in self.vertices}
        
        def find(vertex: int) -> int:
            if parent[vertex] != vertex:
                parent[vertex] = find(parent[vertex])
            return parent[vertex]
        
        def union(u: int, v: int) -> None:
            parent[find(u)] = find(v)
        
        mst_edges = []
        
        for edge in sorted_edges:
            if find(edge.source) != find(edge.target):
                union(edge.source, edge.target)
                mst_edges.append(edge)
        
        return mst_edges

# ç¤ºä¾‹ä½¿ç”¨
def demonstrate_graph_structures():
    """æ¼”ç¤ºå›¾æ•°æ®ç»“æ„"""
    print("å›¾æ•°æ®ç»“æ„æ¼”ç¤º")
    print("=" * 40)
    
    # åˆ›å»ºå›¾
    graph = Graph(directed=False)
    
    # æ·»åŠ é¡¶ç‚¹å’Œè¾¹
    for i in range(6):
        graph.add_vertex(i)
    
    edges = [(0, 1, 4), (0, 2, 2), (1, 2, 1), (1, 3, 5), 
             (2, 3, 8), (2, 4, 10), (3, 4, 2), (3, 5, 6), (4, 5, 3)]
    
    for source, target, weight in edges:
        graph.add_edge(source, target, weight)
    
    print(f"BFSéå†: {graph.bfs(0)}")
    print(f"DFSéå†: {graph.dfs(0)}")
    
    # æœ€çŸ­è·¯å¾„
    distances = graph.dijkstra(0)
    print(f"Dijkstraæœ€çŸ­è·¯å¾„: {distances}")
    
    # æœ€å°ç”Ÿæˆæ ‘
    mst_prim = graph.prim_mst()
    mst_kruskal = graph.kruskal_mst()
    
    print(f"Prim MSTæƒé‡å’Œ: {sum(edge.weight for edge in mst_prim)}")
    print(f"Kruskal MSTæƒé‡å’Œ: {sum(edge.weight for edge in mst_kruskal)}")

if __name__ == "__main__":
    demonstrate_graph_structures()
```

## ğŸ“Š æ•°æ®ç»“æ„åˆ†æ

### 1. å¤æ‚åº¦åˆ†æ

#### 1.1 æ—¶é—´å¤æ‚åº¦

| æ•°æ®ç»“æ„ | è®¿é—® | æœç´¢ | æ’å…¥ | åˆ é™¤ |
|---------|------|------|------|------|
| æ•°ç»„ | O(1) | O(n) | O(n) | O(n) |
| é“¾è¡¨ | O(n) | O(n) | O(1) | O(1) |
| æ ˆ | O(1) | O(n) | O(1) | O(1) |
| é˜Ÿåˆ— | O(n) | O(n) | O(1) | O(1) |
| äºŒå‰æ ‘ | O(log n) | O(log n) | O(log n) | O(log n) |
| å“ˆå¸Œè¡¨ | O(1) | O(1) | O(1) | O(1) |

#### 1.2 ç©ºé—´å¤æ‚åº¦

| æ•°æ®ç»“æ„ | ç©ºé—´å¤æ‚åº¦ |
|---------|-----------|
| æ•°ç»„ | O(n) |
| é“¾è¡¨ | O(n) |
| æ ˆ | O(n) |
| é˜Ÿåˆ— | O(n) |
| äºŒå‰æ ‘ | O(n) |
| å›¾ | O(V + E) |

### 2. åº”ç”¨åœºæ™¯

#### 2.1 æ•°ç»„åº”ç”¨

- éšæœºè®¿é—®æ•°æ®
- ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„
- çŸ©é˜µè¿ç®—

#### 2.2 é“¾è¡¨åº”ç”¨

- åŠ¨æ€å†…å­˜åˆ†é…
- LRUç¼“å­˜å®ç°
- å¤šé¡¹å¼è¡¨ç¤º

#### 2.3 æ ‘åº”ç”¨

- æ–‡ä»¶ç³»ç»Ÿ
- æ•°æ®åº“ç´¢å¼•
- è¡¨è¾¾å¼æ±‚å€¼

#### 2.4 å›¾åº”ç”¨

- ç¤¾äº¤ç½‘ç»œ
- è·¯ç”±ç®—æ³•
- ä¾èµ–å…³ç³»

## ğŸ“ˆ æ€»ç»“

æ•°æ®ç»“æ„ç†è®ºä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†ï¼š

1. **æŠ½è±¡å±‚æ¬¡**ï¼šADTæä¾›æ•°æ®æ“ä½œçš„æŠ½è±¡æ¥å£
2. **æ€§èƒ½ä¿è¯**ï¼šå¤æ‚åº¦åˆ†æç¡®ä¿ç®—æ³•æ•ˆç‡
3. **è®¾è®¡æ¨¡å¼**ï¼šä¸åŒæ•°æ®ç»“æ„é€‚ç”¨äºä¸åŒåœºæ™¯
4. **å®ç°æŠ€æœ¯**ï¼šå„ç§æ•°æ®ç»“æ„çš„å®ç°æ–¹æ³•
5. **åº”ç”¨æŒ‡å¯¼**ï¼šæ•°æ®ç»“æ„åœ¨å®é™…é—®é¢˜ä¸­çš„åº”ç”¨

é€šè¿‡ç³»ç»Ÿæ€§çš„æ•°æ®ç»“æ„ç†è®ºï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

- é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
- è®¾è®¡é«˜æ•ˆçš„ç®—æ³•
- ä¼˜åŒ–ç¨‹åºæ€§èƒ½
- è§£å†³å¤æ‚é—®é¢˜
- æ„å»ºå¯ç»´æŠ¤çš„è½¯ä»¶ç³»ç»Ÿ

æ•°æ®ç»“æ„ç†è®ºæ˜¯ç®—æ³•è®¾è®¡å’Œç¨‹åºå®ç°çš„åŸºç¡€ï¼Œä¸ºç°ä»£è½¯ä»¶å·¥ç¨‹æä¾›äº†å¼ºå¤§çš„å·¥å…·å’Œæ–¹æ³•ã€‚
