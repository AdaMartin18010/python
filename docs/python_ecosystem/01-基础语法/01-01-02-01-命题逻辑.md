# å‘½é¢˜é€»è¾‘

## ğŸ“š æ¦‚è¿°

å‘½é¢˜é€»è¾‘æ˜¯å½¢å¼é€»è¾‘çš„åŸºç¡€ï¼Œç ”ç©¶å‘½é¢˜ä¹‹é—´çš„é€»è¾‘å…³ç³»ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼ç§‘å­¦çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»å‘½é¢˜é€»è¾‘çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å‘½é¢˜

#### 1.1 å‘½é¢˜çš„æ•°å­¦å®šä¹‰

å‘½é¢˜æ˜¯ä¸€ä¸ªå…·æœ‰ç¡®å®šçœŸå€¼çš„é™ˆè¿°å¥ã€‚åœ¨å½¢å¼é€»è¾‘ä¸­ï¼Œæˆ‘ä»¬ç”¨å¤§å†™å­—æ¯ $P, Q, R$ ç­‰è¡¨ç¤ºå‘½é¢˜ã€‚

**çœŸå€¼**: æ¯ä¸ªå‘½é¢˜éƒ½æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªçœŸå€¼ï¼šçœŸï¼ˆTrueï¼Œè®°ä½œ $T$ æˆ– $1$ï¼‰æˆ–å‡ï¼ˆFalseï¼Œè®°ä½œ $F$ æˆ– $0$ï¼‰ã€‚

#### 1.2 å‘½é¢˜çš„Pythonå®ç°

```python
from typing import Dict, List, Set, Callable, Any
from abc import ABC, abstractmethod
from enum import Enum
import itertools

class TruthValue(Enum):
    """çœŸå€¼æšä¸¾"""
    FALSE = 0
    TRUE = 1

class Proposition(ABC):
    """æŠ½è±¡å‘½é¢˜ç±»"""
    
    @abstractmethod
    def evaluate(self, interpretation: Dict[str, bool]) -> bool:
        """åœ¨ç»™å®šè§£é‡Šä¸‹æ±‚å€¼"""
        pass
    
    @abstractmethod
    def get_variables(self) -> Set[str]:
        """è·å–å‘½é¢˜ä¸­çš„å˜é‡"""
        pass
    
    @abstractmethod
    def __str__(self) -> str:
        """å­—ç¬¦ä¸²è¡¨ç¤º"""
        pass

class AtomicProposition(Proposition):
    """åŸå­å‘½é¢˜"""
    
    def __init__(self, name: str):
        self.name = name
    
    def evaluate(self, interpretation: Dict[str, bool]) -> bool:
        return interpretation.get(self.name, False)
    
    def get_variables(self) -> Set[str]:
        return {self.name}
    
    def __str__(self) -> str:
        return self.name

class Negation(Proposition):
    """å¦å®šå‘½é¢˜"""
    
    def __init__(self, proposition: Proposition):
        self.proposition = proposition
    
    def evaluate(self, interpretation: Dict[str, bool]) -> bool:
        return not self.proposition.evaluate(interpretation)
    
    def get_variables(self) -> Set[str]:
        return self.proposition.get_variables()
    
    def __str__(self) -> str:
        return f"Â¬{self.proposition}"

class Conjunction(Proposition):
    """åˆå–å‘½é¢˜"""
    
    def __init__(self, left: Proposition, right: Proposition):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, bool]) -> bool:
        return (self.left.evaluate(interpretation) and 
                self.right.evaluate(interpretation))
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables() | self.right.get_variables()
    
    def __str__(self) -> str:
        return f"({self.left} âˆ§ {self.right})"

class Disjunction(Proposition):
    """æå–å‘½é¢˜"""
    
    def __init__(self, left: Proposition, right: Proposition):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, bool]) -> bool:
        return (self.left.evaluate(interpretation) or 
                self.right.evaluate(interpretation))
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables() | self.right.get_variables()
    
    def __str__(self) -> str:
        return f"({self.left} âˆ¨ {self.right})"

class Implication(Proposition):
    """è•´å«å‘½é¢˜"""
    
    def __init__(self, antecedent: Proposition, consequent: Proposition):
        self.antecedent = antecedent
        self.consequent = consequent
    
    def evaluate(self, interpretation: Dict[str, bool]) -> bool:
        return (not self.antecedent.evaluate(interpretation) or 
                self.consequent.evaluate(interpretation))
    
    def get_variables(self) -> Set[str]:
        return (self.antecedent.get_variables() | 
                self.consequent.get_variables())
    
    def __str__(self) -> str:
        return f"({self.antecedent} â†’ {self.consequent})"

class Equivalence(Proposition):
    """ç­‰ä»·å‘½é¢˜"""
    
    def __init__(self, left: Proposition, right: Proposition):
        self.left = left
        self.right = right
    
    def evaluate(self, interpretation: Dict[str, bool]) -> bool:
        return (self.left.evaluate(interpretation) == 
                self.right.evaluate(interpretation))
    
    def get_variables(self) -> Set[str]:
        return self.left.get_variables() | self.right.get_variables()
    
    def __str__(self) -> str:
        return f"({self.left} â†” {self.right})"

# ä½¿ç”¨ç¤ºä¾‹
P = AtomicProposition("P")
Q = AtomicProposition("Q")
R = AtomicProposition("R")

# æ„å»ºå¤åˆå‘½é¢˜: (P âˆ§ Q) â†’ R
compound = Implication(Conjunction(P, Q), R)
print(f"å‘½é¢˜: {compound}")

# åœ¨è§£é‡Š {P: True, Q: True, R: False} ä¸‹æ±‚å€¼
interpretation = {"P": True, "Q": True, "R": False}
print(f"åœ¨è§£é‡Š {interpretation} ä¸‹çš„çœŸå€¼: {compound.evaluate(interpretation)}")
```

### 2. çœŸå€¼è¡¨

#### 2.1 çœŸå€¼è¡¨çš„æ•°å­¦å®šä¹‰

çœŸå€¼è¡¨æ˜¯æè¿°å‘½é¢˜åœ¨æ‰€æœ‰å¯èƒ½è§£é‡Šä¸‹çœŸå€¼çš„è¡¨æ ¼ã€‚å¯¹äºåŒ…å« $n$ ä¸ªå˜é‡çš„å‘½é¢˜ï¼ŒçœŸå€¼è¡¨æœ‰ $2^n$ è¡Œã€‚

#### 2.2 çœŸå€¼è¡¨çš„Pythonå®ç°

```python
class TruthTable:
    """çœŸå€¼è¡¨å®ç°"""
    
    def __init__(self, proposition: Proposition):
        self.proposition = proposition
        self.variables = sorted(list(proposition.get_variables()))
    
    def generate_interpretations(self) -> List[Dict[str, bool]]:
        """ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è§£é‡Š"""
        interpretations = []
        n = len(self.variables)
        
        for i in range(2 ** n):
            interpretation = {}
            for j in range(n):
                interpretation[self.variables[j]] = bool((i >> j) & 1)
            interpretations.append(interpretation)
        
        return interpretations
    
    def compute_truth_table(self) -> List[Dict[str, Any]]:
        """è®¡ç®—çœŸå€¼è¡¨"""
        interpretations = self.generate_interpretations()
        truth_table = []
        
        for interpretation in interpretations:
            row = interpretation.copy()
            row['result'] = self.proposition.evaluate(interpretation)
            truth_table.append(row)
        
        return truth_table
    
    def print_truth_table(self):
        """æ‰“å°çœŸå€¼è¡¨"""
        truth_table = self.compute_truth_table()
        
        # æ‰“å°è¡¨å¤´
        header = " | ".join(self.variables + ["ç»“æœ"])
        print(header)
        print("-" * len(header))
        
        # æ‰“å°æ•°æ®è¡Œ
        for row in truth_table:
            values = [str(int(row[var])) for var in self.variables]
            values.append(str(int(row['result'])))
            print(" | ".join(values))
    
    def is_tautology(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºé‡è¨€å¼"""
        return all(row['result'] for row in self.compute_truth_table())
    
    def is_contradiction(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        return not any(row['result'] for row in self.compute_truth_table())
    
    def is_satisfiable(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼"""
        return any(row['result'] for row in self.compute_truth_table())

# ä½¿ç”¨ç¤ºä¾‹
P = AtomicProposition("P")
Q = AtomicProposition("Q")

# å¾·æ‘©æ ¹å®šå¾‹: Â¬(P âˆ§ Q) â†” (Â¬P âˆ¨ Â¬Q)
demorgan = Equivalence(
    Negation(Conjunction(P, Q)),
    Disjunction(Negation(P), Negation(Q))
)

print("å¾·æ‘©æ ¹å®šå¾‹çš„çœŸå€¼è¡¨:")
tt = TruthTable(demorgan)
tt.print_truth_table()
print(f"æ˜¯é‡è¨€å¼: {tt.is_tautology()}")
```

### 3. é€»è¾‘ç­‰ä»·

#### 3.1 é€»è¾‘ç­‰ä»·çš„æ•°å­¦å®šä¹‰

ä¸¤ä¸ªå‘½é¢˜ $A$ å’Œ $B$ é€»è¾‘ç­‰ä»·ï¼Œè®°ä½œ $A \equiv B$ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬åœ¨æ‰€æœ‰è§£é‡Šä¸‹å…·æœ‰ç›¸åŒçš„çœŸå€¼ã€‚

#### 3.2 é€»è¾‘ç­‰ä»·çš„Pythonå®ç°

```python
class LogicalEquivalence:
    """é€»è¾‘ç­‰ä»·åˆ¤æ–­"""
    
    @staticmethod
    def are_equivalent(A: Proposition, B: Proposition) -> bool:
        """åˆ¤æ–­ä¸¤ä¸ªå‘½é¢˜æ˜¯å¦é€»è¾‘ç­‰ä»·"""
        # è·å–æ‰€æœ‰å˜é‡
        all_variables = A.get_variables() | B.get_variables()
        
        # ç”Ÿæˆæ‰€æœ‰è§£é‡Š
        variables = sorted(list(all_variables))
        n = len(variables)
        
        for i in range(2 ** n):
            interpretation = {}
            for j in range(n):
                interpretation[variables[j]] = bool((i >> j) & 1)
            
            if A.evaluate(interpretation) != B.evaluate(interpretation):
                return False
        
        return True
    
    @staticmethod
    def find_equivalent_form(proposition: Proposition) -> Proposition:
        """å¯»æ‰¾ç­‰ä»·çš„æ ‡å‡†å½¢å¼"""
        # è¿™é‡Œå¯ä»¥å®ç°è½¬æ¢ä¸ºåˆå–èŒƒå¼æˆ–æå–èŒƒå¼
        # ç®€åŒ–å®ç°ï¼šè¿”å›åŸå‘½é¢˜
        return proposition

# ä½¿ç”¨ç¤ºä¾‹
P = AtomicProposition("P")
Q = AtomicProposition("Q")

# éªŒè¯åˆ†é…å¾‹: P âˆ§ (Q âˆ¨ R) â‰¡ (P âˆ§ Q) âˆ¨ (P âˆ§ R)
R = AtomicProposition("R")
left = Conjunction(P, Disjunction(Q, R))
right = Disjunction(Conjunction(P, Q), Conjunction(P, R))

print(f"åˆ†é…å¾‹æˆç«‹: {LogicalEquivalence.are_equivalent(left, right)}")
```

### 4. æ¨ç†è§„åˆ™

#### 4.1 åŸºæœ¬æ¨ç†è§„åˆ™

```python
class InferenceRules:
    """æ¨ç†è§„åˆ™å®ç°"""
    
    @staticmethod
    def modus_ponens(premise1: Proposition, premise2: Proposition) -> Optional[Proposition]:
        """å‡è¨€æ¨ç†: ä» P â†’ Q å’Œ P æ¨å‡º Q"""
        if (isinstance(premise1, Implication) and 
            LogicalEquivalence.are_equivalent(premise2, premise1.antecedent)):
            return premise1.consequent
        return None
    
    @staticmethod
    def modus_tollens(premise1: Proposition, premise2: Proposition) -> Optional[Proposition]:
        """æ‹’å–å¼: ä» P â†’ Q å’Œ Â¬Q æ¨å‡º Â¬P"""
        if (isinstance(premise1, Implication) and 
            LogicalEquivalence.are_equivalent(premise2, Negation(premise1.consequent))):
            return Negation(premise1.antecedent)
        return None
    
    @staticmethod
    def hypothetical_syllogism(premise1: Proposition, premise2: Proposition) -> Optional[Proposition]:
        """å‡è¨€ä¸‰æ®µè®º: ä» P â†’ Q å’Œ Q â†’ R æ¨å‡º P â†’ R"""
        if (isinstance(premise1, Implication) and 
            isinstance(premise2, Implication) and
            LogicalEquivalence.are_equivalent(premise1.consequent, premise2.antecedent)):
            return Implication(premise1.antecedent, premise2.consequent)
        return None
    
    @staticmethod
    def disjunctive_syllogism(premise1: Proposition, premise2: Proposition) -> Optional[Proposition]:
        """æå–ä¸‰æ®µè®º: ä» P âˆ¨ Q å’Œ Â¬P æ¨å‡º Q"""
        if (isinstance(premise1, Disjunction) and 
            LogicalEquivalence.are_equivalent(premise2, Negation(premise1.left))):
            return premise1.right
        elif (isinstance(premise1, Disjunction) and 
              LogicalEquivalence.are_equivalent(premise2, Negation(premise1.right))):
            return premise1.left
        return None

# ä½¿ç”¨ç¤ºä¾‹
P = AtomicProposition("P")
Q = AtomicProposition("Q")
R = AtomicProposition("R")

# å‡è¨€æ¨ç†ç¤ºä¾‹
implication = Implication(P, Q)
conclusion = InferenceRules.modus_ponens(implication, P)
print(f"ä» {implication} å’Œ {P} æ¨å‡º: {conclusion}")

# å‡è¨€ä¸‰æ®µè®ºç¤ºä¾‹
implication1 = Implication(P, Q)
implication2 = Implication(Q, R)
conclusion = InferenceRules.hypothetical_syllogism(implication1, implication2)
print(f"ä» {implication1} å’Œ {implication2} æ¨å‡º: {conclusion}")
```

### 5. èŒƒå¼è½¬æ¢

#### 5.1 åˆå–èŒƒå¼ï¼ˆCNFï¼‰

```python
class NormalForm:
    """èŒƒå¼è½¬æ¢"""
    
    @staticmethod
    def to_cnf(proposition: Proposition) -> Proposition:
        """è½¬æ¢ä¸ºåˆå–èŒƒå¼"""
        # 1. æ¶ˆé™¤è•´å«å’Œç­‰ä»·
        proposition = NormalForm._eliminate_implications(proposition)
        
        # 2. å°†å¦å®šå†…ç§»
        proposition = NormalForm._move_negations_inward(proposition)
        
        # 3. åˆ†é…æå–
        proposition = NormalForm._distribute_disjunctions(proposition)
        
        return proposition
    
    @staticmethod
    def _eliminate_implications(proposition: Proposition) -> Proposition:
        """æ¶ˆé™¤è•´å«å’Œç­‰ä»·"""
        if isinstance(proposition, AtomicProposition):
            return proposition
        elif isinstance(proposition, Negation):
            return Negation(NormalForm._eliminate_implications(proposition.proposition))
        elif isinstance(proposition, Conjunction):
            return Conjunction(
                NormalForm._eliminate_implications(proposition.left),
                NormalForm._eliminate_implications(proposition.right)
            )
        elif isinstance(proposition, Disjunction):
            return Disjunction(
                NormalForm._eliminate_implications(proposition.left),
                NormalForm._eliminate_implications(proposition.right)
            )
        elif isinstance(proposition, Implication):
            return Disjunction(
                Negation(NormalForm._eliminate_implications(proposition.antecedent)),
                NormalForm._eliminate_implications(proposition.consequent)
            )
        elif isinstance(proposition, Equivalence):
            left = NormalForm._eliminate_implications(proposition.left)
            right = NormalForm._eliminate_implications(proposition.right)
            return Conjunction(
                Disjunction(Negation(left), right),
                Disjunction(left, Negation(right))
            )
        return proposition
    
    @staticmethod
    def _move_negations_inward(proposition: Proposition) -> Proposition:
        """å°†å¦å®šå†…ç§»"""
        if isinstance(proposition, AtomicProposition):
            return proposition
        elif isinstance(proposition, Negation):
            inner = proposition.proposition
            if isinstance(inner, Negation):
                return NormalForm._move_negations_inward(inner.proposition)
            elif isinstance(inner, Conjunction):
                return Disjunction(
                    Negation(NormalForm._move_negations_inward(inner.left)),
                    Negation(NormalForm._move_negations_inward(inner.right))
                )
            elif isinstance(inner, Disjunction):
                return Conjunction(
                    Negation(NormalForm._move_negations_inward(inner.left)),
                    Negation(NormalForm._move_negations_inward(inner.right))
                )
            else:
                return Negation(NormalForm._move_negations_inward(inner))
        elif isinstance(proposition, Conjunction):
            return Conjunction(
                NormalForm._move_negations_inward(proposition.left),
                NormalForm._move_negations_inward(proposition.right)
            )
        elif isinstance(proposition, Disjunction):
            return Disjunction(
                NormalForm._move_negations_inward(proposition.left),
                NormalForm._move_negations_inward(proposition.right)
            )
        return proposition
    
    @staticmethod
    def _distribute_disjunctions(proposition: Proposition) -> Proposition:
        """åˆ†é…æå–"""
        if isinstance(proposition, AtomicProposition):
            return proposition
        elif isinstance(proposition, Negation):
            return Negation(NormalForm._distribute_disjunctions(proposition.proposition))
        elif isinstance(proposition, Conjunction):
            return Conjunction(
                NormalForm._distribute_disjunctions(proposition.left),
                NormalForm._distribute_disjunctions(proposition.right)
            )
        elif isinstance(proposition, Disjunction):
            left = NormalForm._distribute_disjunctions(proposition.left)
            right = NormalForm._distribute_disjunctions(proposition.right)
            
            if isinstance(left, Conjunction):
                return Conjunction(
                    NormalForm._distribute_disjunctions(Disjunction(left.left, right)),
                    NormalForm._distribute_disjunctions(Disjunction(left.right, right))
                )
            elif isinstance(right, Conjunction):
                return Conjunction(
                    NormalForm._distribute_disjunctions(Disjunction(left, right.left)),
                    NormalForm._distribute_disjunctions(Disjunction(left, right.right))
                )
            else:
                return Disjunction(left, right)
        return proposition

# ä½¿ç”¨ç¤ºä¾‹
P = AtomicProposition("P")
Q = AtomicProposition("Q")
R = AtomicProposition("R")

# è½¬æ¢ (P â†’ Q) âˆ§ (Q â†’ R) ä¸ºCNF
original = Conjunction(
    Implication(P, Q),
    Implication(Q, R)
)

cnf = NormalForm.to_cnf(original)
print(f"åŸå‘½é¢˜: {original}")
print(f"CNFå½¢å¼: {cnf}")
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. å¾·æ‘©æ ¹å®šå¾‹

**å®šç†**: å¯¹äºä»»æ„å‘½é¢˜ $P$ å’Œ $Q$ï¼Œæœ‰ï¼š

$$\neg(P \land Q) \equiv \neg P \lor \neg Q$$
$$\neg(P \lor Q) \equiv \neg P \land \neg Q$$

**è¯æ˜**: é€šè¿‡çœŸå€¼è¡¨éªŒè¯ã€‚

### 2. åˆ†é…å¾‹

**å®šç†**: å¯¹äºä»»æ„å‘½é¢˜ $P$ã€$Q$ å’Œ $R$ï¼Œæœ‰ï¼š

$$P \land (Q \lor R) \equiv (P \land Q) \lor (P \land R)$$
$$P \lor (Q \land R) \equiv (P \lor Q) \land (P \lor R)$$

**è¯æ˜**: é€šè¿‡çœŸå€¼è¡¨éªŒè¯ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. é€»è¾‘ç”µè·¯è®¾è®¡

```python
class LogicCircuit:
    """é€»è¾‘ç”µè·¯å®ç°"""
    
    def __init__(self, inputs: List[str], outputs: List[str]):
        self.inputs = inputs
        self.outputs = outputs
        self.gates = {}
    
    def add_gate(self, name: str, gate_type: str, inputs: List[str]):
        """æ·»åŠ é€»è¾‘é—¨"""
        self.gates[name] = {
            'type': gate_type,
            'inputs': inputs
        }
    
    def evaluate_gate(self, gate_name: str, input_values: Dict[str, bool]) -> bool:
        """è®¡ç®—é€»è¾‘é—¨çš„è¾“å‡º"""
        gate = self.gates[gate_name]
        gate_type = gate['type']
        gate_inputs = gate['inputs']
        
        if gate_type == 'AND':
            return all(input_values[inp] for inp in gate_inputs)
        elif gate_type == 'OR':
            return any(input_values[inp] for inp in gate_inputs)
        elif gate_type == 'NOT':
            return not input_values[gate_inputs[0]]
        elif gate_type == 'NAND':
            return not all(input_values[inp] for inp in gate_inputs)
        elif gate_type == 'NOR':
            return not any(input_values[inp] for inp in gate_inputs)
        elif gate_type == 'XOR':
            return sum(input_values[inp] for inp in gate_inputs) % 2 == 1
        
        return False
    
    def evaluate_circuit(self, input_values: Dict[str, bool]) -> Dict[str, bool]:
        """è®¡ç®—æ•´ä¸ªç”µè·¯çš„è¾“å‡º"""
        # ç®€åŒ–å®ç°ï¼šå‡è®¾è¾“å‡ºç›´æ¥å¯¹åº”è¾“å…¥
        return {output: input_values.get(output, False) for output in self.outputs}

# ä½¿ç”¨ç¤ºä¾‹
# åŠåŠ å™¨ç”µè·¯
half_adder = LogicCircuit(['A', 'B'], ['S', 'C'])
half_adder.add_gate('XOR1', 'XOR', ['A', 'B'])
half_adder.add_gate('AND1', 'AND', ['A', 'B'])

print("åŠåŠ å™¨çœŸå€¼è¡¨:")
for a in [False, True]:
    for b in [False, True]:
        inputs = {'A': a, 'B': b}
        outputs = half_adder.evaluate_circuit(inputs)
        print(f"A={int(a)}, B={int(b)} -> S={int(outputs['S'])}, C={int(outputs['C'])}")
```

### 2. çŸ¥è¯†è¡¨ç¤º

```python
class KnowledgeBase:
    """çŸ¥è¯†åº“å®ç°"""
    
    def __init__(self):
        self.facts = set()
        self.rules = []
    
    def add_fact(self, fact: Proposition):
        """æ·»åŠ äº‹å®"""
        self.facts.add(fact)
    
    def add_rule(self, rule: Implication):
        """æ·»åŠ è§„åˆ™"""
        self.rules.append(rule)
    
    def query(self, query: Proposition) -> bool:
        """æŸ¥è¯¢å‘½é¢˜æ˜¯å¦ä¸ºçœŸ"""
        # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æŸ¥è¯¢æ˜¯å¦åœ¨äº‹å®ä¸­
        return query in self.facts
    
    def forward_chaining(self) -> Set[Proposition]:
        """å‰å‘æ¨ç†"""
        derived_facts = self.facts.copy()
        changed = True
        
        while changed:
            changed = False
            for rule in self.rules:
                if (rule.antecedent in derived_facts and 
                    rule.consequent not in derived_facts):
                    derived_facts.add(rule.consequent)
                    changed = True
        
        return derived_facts

# ä½¿ç”¨ç¤ºä¾‹
kb = KnowledgeBase()

# æ·»åŠ äº‹å®å’Œè§„åˆ™
P = AtomicProposition("ä¸‹é›¨")
Q = AtomicProposition("åœ°é¢æ¹¿")
R = AtomicProposition("å¸¦ä¼")

kb.add_fact(P)
kb.add_rule(Implication(P, Q))  # å¦‚æœä¸‹é›¨ï¼Œåœ°é¢ä¼šæ¹¿
kb.add_rule(Implication(Q, R))  # å¦‚æœåœ°é¢æ¹¿ï¼Œè¦å¸¦ä¼

# å‰å‘æ¨ç†
derived = kb.forward_chaining()
print(f"æ¨ç†ç»“æœ: {[str(fact) for fact in derived]}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [é€»è¾‘å­¦åŸºç¡€](../README.md)
- [è°“è¯é€»è¾‘](01-02-02-è°“è¯é€»è¾‘.md)
- [æ¨¡æ€é€»è¾‘](01-02-03-æ¨¡æ€é€»è¾‘.md)
- [æ•°å­¦åŸºç¡€](../01-01-æ•°å­¦åŸºç¡€/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Enderton, H. B. (2001). A Mathematical Introduction to Logic. Academic Press.
2. Mendelson, E. (2015). Introduction to Mathematical Logic. CRC Press.
3. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). Computability and Logic. Cambridge University Press.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
