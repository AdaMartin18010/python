# ç®—æ³•åŸºç¡€

## ğŸ“š æ¦‚è¿°

ç®—æ³•ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒåŸºç¡€ï¼Œç ”ç©¶ç®—æ³•çš„è®¾è®¡ã€åˆ†æå’Œä¼˜åŒ–ã€‚æœ¬æ–‡æ¡£ä»ç†è®ºåŸºç¡€çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»ç®—æ³•ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ç®—æ³•çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 ç®—æ³•çš„æ•°å­¦å®šä¹‰

ç®—æ³•æ˜¯ä¸€ä¸ªæœ‰é™çš„è®¡ç®—è¿‡ç¨‹ï¼Œå®ƒå°†è¾“å…¥è½¬æ¢ä¸ºè¾“å‡ºã€‚å½¢å¼åŒ–åœ°ï¼Œç®—æ³•å¯ä»¥å®šä¹‰ä¸ºï¼š

$$A: I \rightarrow O$$

å…¶ä¸­ $I$ æ˜¯è¾“å…¥é›†åˆï¼Œ$O$ æ˜¯è¾“å‡ºé›†åˆï¼Œ$A$ æ˜¯ç®—æ³•å‡½æ•°ã€‚

#### 1.2 ç®—æ³•çš„Pythonå®ç°

```python
from typing import Any, Callable, List, Dict, Optional, Tuple
from abc import ABC, abstractmethod
import time
import random
from dataclasses import dataclass

@dataclass
class AlgorithmResult:
    """ç®—æ³•æ‰§è¡Œç»“æœ"""
    output: Any
    execution_time: float
    memory_usage: int
    steps: int

class Algorithm(ABC):
    """æŠ½è±¡ç®—æ³•åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.step_count = 0
    
    @abstractmethod
    def execute(self, input_data: Any) -> Any:
        """æ‰§è¡Œç®—æ³•"""
        pass
    
    def run_with_metrics(self, input_data: Any) -> AlgorithmResult:
        """è¿è¡Œç®—æ³•å¹¶æ”¶é›†æŒ‡æ ‡"""
        start_time = time.time()
        start_memory = self._get_memory_usage()
        
        self.step_count = 0
        output = self.execute(input_data)
        
        end_time = time.time()
        end_memory = self._get_memory_usage()
        
        return AlgorithmResult(
            output=output,
            execution_time=end_time - start_time,
            memory_usage=end_memory - start_memory,
            steps=self.step_count
        )
    
    def _get_memory_usage(self) -> int:
        """è·å–å†…å­˜ä½¿ç”¨é‡ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        import psutil
        return psutil.Process().memory_info().rss
    
    def increment_step(self):
        """å¢åŠ æ­¥éª¤è®¡æ•°"""
        self.step_count += 1

class LinearSearch(Algorithm):
    """çº¿æ€§æœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Linear Search")
    
    def execute(self, input_data: Tuple[List[Any], Any]) -> Optional[int]:
        """åœ¨åˆ—è¡¨ä¸­æœç´¢ç›®æ ‡å…ƒç´ """
        array, target = input_data
        self.step_count = 0
        
        for i, element in enumerate(array):
            self.increment_step()
            if element == target:
                return i
        
        return None

class BinarySearch(Algorithm):
    """äºŒåˆ†æœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Binary Search")
    
    def execute(self, input_data: Tuple[List[Any], Any]) -> Optional[int]:
        """åœ¨æœ‰åºåˆ—è¡¨ä¸­æœç´¢ç›®æ ‡å…ƒç´ """
        array, target = input_data
        self.step_count = 0
        
        left, right = 0, len(array) - 1
        
        while left <= right:
            self.increment_step()
            mid = (left + right) // 2
            
            if array[mid] == target:
                return mid
            elif array[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return None

# ä½¿ç”¨ç¤ºä¾‹
linear_search = LinearSearch()
binary_search = BinarySearch()

data = [1, 3, 5, 7, 9, 11, 13, 15]
target = 7

linear_result = linear_search.run_with_metrics((data, target))
binary_result = binary_search.run_with_metrics((data, target))

print(f"çº¿æ€§æœç´¢: ä½ç½®={linear_result.output}, æ—¶é—´={linear_result.execution_time:.6f}s, æ­¥éª¤={linear_result.steps}")
print(f"äºŒåˆ†æœç´¢: ä½ç½®={binary_result.output}, æ—¶é—´={binary_result.execution_time:.6f}s, æ­¥éª¤={binary_result.steps}")
```

### 2. ç®—æ³•å¤æ‚åº¦åˆ†æ

#### 2.1 æ—¶é—´å¤æ‚åº¦çš„æ•°å­¦å®šä¹‰

ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ $T(n)$ æè¿°äº†ç®—æ³•æ‰§è¡Œæ—¶é—´ä¸è¾“å…¥è§„æ¨¡ $n$ çš„å…³ç³»ã€‚

**æ¸è¿‘è®°å·**:

- $O(f(n))$: ä¸Šç•Œï¼Œ$T(n) \leq c \cdot f(n)$ å¯¹äºæŸä¸ªå¸¸æ•° $c > 0$
- $\Omega(f(n))$: ä¸‹ç•Œï¼Œ$T(n) \geq c \cdot f(n)$ å¯¹äºæŸä¸ªå¸¸æ•° $c > 0$
- $\Theta(f(n))$: ç´§ç•Œï¼Œ$T(n) = O(f(n))$ ä¸” $T(n) = \Omega(f(n))$

#### 2.2 å¤æ‚åº¦åˆ†æçš„Pythonå®ç°

```python
import matplotlib.pyplot as plt
import numpy as np
from typing import List, Callable, Dict

class ComplexityAnalyzer:
    """ç®—æ³•å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.results = {}
    
    def analyze_algorithm(self, algorithm: Algorithm, 
                         input_generator: Callable[[int], Any],
                         input_sizes: List[int]) -> Dict[str, List[float]]:
        """åˆ†æç®—æ³•çš„å¤æ‚åº¦"""
        execution_times = []
        step_counts = []
        
        for size in input_sizes:
            input_data = input_generator(size)
            result = algorithm.run_with_metrics(input_data)
            execution_times.append(result.execution_time)
            step_counts.append(result.steps)
        
        return {
            'input_sizes': input_sizes,
            'execution_times': execution_times,
            'step_counts': step_counts
        }
    
    def plot_complexity(self, results: Dict[str, List[float]], 
                       title: str = "Algorithm Complexity Analysis"):
        """ç»˜åˆ¶å¤æ‚åº¦åˆ†æå›¾"""
        plt.figure(figsize=(12, 5))
        
        # æ‰§è¡Œæ—¶é—´å›¾
        plt.subplot(1, 2, 1)
        plt.plot(results['input_sizes'], results['execution_times'], 'b-o', label='Actual')
        plt.xlabel('Input Size')
        plt.ylabel('Execution Time (s)')
        plt.title('Execution Time vs Input Size')
        plt.legend()
        plt.grid(True)
        
        # æ­¥éª¤æ•°å›¾
        plt.subplot(1, 2, 2)
        plt.plot(results['input_sizes'], results['step_counts'], 'r-o', label='Steps')
        plt.xlabel('Input Size')
        plt.ylabel('Number of Steps')
        plt.title('Steps vs Input Size')
        plt.legend()
        plt.grid(True)
        
        plt.tight_layout()
        plt.show()
    
    def estimate_complexity(self, input_sizes: List[int], 
                          step_counts: List[int]) -> str:
        """ä¼°è®¡ç®—æ³•çš„å¤æ‚åº¦"""
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(input_sizes)):
            size_ratio = input_sizes[i] / input_sizes[i-1]
            step_ratio = step_counts[i] / step_counts[i-1]
            growth_rates.append(step_ratio / size_ratio)
        
        avg_growth = np.mean(growth_rates)
        
        if avg_growth < 1.1:
            return "O(1)"
        elif avg_growth < 1.5:
            return "O(log n)"
        elif avg_growth < 2.5:
            return "O(n)"
        elif avg_growth < 4:
            return "O(n log n)"
        elif avg_growth < 8:
            return "O(nÂ²)"
        else:
            return "O(n^k) where k > 2"

# ä½¿ç”¨ç¤ºä¾‹
def generate_sorted_array(size: int) -> Tuple[List[int], int]:
    """ç”Ÿæˆæœ‰åºæ•°ç»„å’Œæœç´¢ç›®æ ‡"""
    array = list(range(size))
    target = random.choice(array)
    return (array, target)

analyzer = ComplexityAnalyzer()
input_sizes = [100, 500, 1000, 5000, 10000]

# åˆ†æçº¿æ€§æœç´¢
linear_results = analyzer.analyze_algorithm(
    LinearSearch(), generate_sorted_array, input_sizes
)

# åˆ†æäºŒåˆ†æœç´¢
binary_results = analyzer.analyze_algorithm(
    BinarySearch(), generate_sorted_array, input_sizes
)

print(f"çº¿æ€§æœç´¢å¤æ‚åº¦: {analyzer.estimate_complexity(input_sizes, linear_results['step_counts'])}")
print(f"äºŒåˆ†æœç´¢å¤æ‚åº¦: {analyzer.estimate_complexity(input_sizes, binary_results['step_counts'])}")

# ç»˜åˆ¶ç»“æœ
analyzer.plot_complexity(linear_results, "Linear Search Complexity")
analyzer.plot_complexity(binary_results, "Binary Search Complexity")
```

### 3. é€’å½’ç®—æ³•

#### 3.1 é€’å½’çš„æ•°å­¦å®šä¹‰

é€’å½’ç®—æ³•é€šè¿‡å°†é—®é¢˜åˆ†è§£ä¸ºæ›´å°çš„å­é—®é¢˜æ¥è§£å†³é—®é¢˜ã€‚é€’å½’å…³ç³»å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$T(n) = aT(n/b) + f(n)$$

å…¶ä¸­ $a$ æ˜¯å­é—®é¢˜æ•°é‡ï¼Œ$b$ æ˜¯é—®é¢˜è§„æ¨¡å‡å°‘å› å­ï¼Œ$f(n)$ æ˜¯åˆ†è§£å’Œåˆå¹¶çš„æˆæœ¬ã€‚

#### 3.2 é€’å½’ç®—æ³•çš„Pythonå®ç°

```python
class RecursiveAlgorithms:
    """é€’å½’ç®—æ³•é›†åˆ"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """è®¡ç®—é˜¶ä¹˜"""
        if n <= 1:
            return 1
        return n * RecursiveAlgorithms.factorial(n - 1)
    
    @staticmethod
    def fibonacci(n: int) -> int:
        """è®¡ç®—æ–æ³¢é‚£å¥‘æ•°"""
        if n <= 1:
            return n
        return (RecursiveAlgorithms.fibonacci(n - 1) + 
                RecursiveAlgorithms.fibonacci(n - 2))
    
    @staticmethod
    def fibonacci_memoized(n: int, memo: Dict[int, int] = None) -> int:
        """å¸¦è®°å¿†åŒ–çš„æ–æ³¢é‚£å¥‘æ•°è®¡ç®—"""
        if memo is None:
            memo = {}
        
        if n in memo:
            return memo[n]
        
        if n <= 1:
            return n
        
        memo[n] = (RecursiveAlgorithms.fibonacci_memoized(n - 1, memo) + 
                   RecursiveAlgorithms.fibonacci_memoized(n - 2, memo))
        return memo[n]
    
    @staticmethod
    def merge_sort(arr: List[Any]) -> List[Any]:
        """å½’å¹¶æ’åº"""
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = RecursiveAlgorithms.merge_sort(arr[:mid])
        right = RecursiveAlgorithms.merge_sort(arr[mid:])
        
        return RecursiveAlgorithms._merge(left, right)
    
    @staticmethod
    def _merge(left: List[Any], right: List[Any]) -> List[Any]:
        """åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    @staticmethod
    def quick_sort(arr: List[Any]) -> List[Any]:
        """å¿«é€Ÿæ’åº"""
        if len(arr) <= 1:
            return arr
        
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        
        return (RecursiveAlgorithms.quick_sort(left) + 
                middle + 
                RecursiveAlgorithms.quick_sort(right))

# ä½¿ç”¨ç¤ºä¾‹
print(f"5! = {RecursiveAlgorithms.factorial(5)}")
print(f"F(10) = {RecursiveAlgorithms.fibonacci_memoized(10)}")

data = [64, 34, 25, 12, 22, 11, 90]
sorted_data = RecursiveAlgorithms.merge_sort(data)
print(f"å½’å¹¶æ’åºç»“æœ: {sorted_data}")

quick_sorted = RecursiveAlgorithms.quick_sort(data)
print(f"å¿«é€Ÿæ’åºç»“æœ: {quick_sorted}")
```

### 4. åŠ¨æ€è§„åˆ’

#### 4.1 åŠ¨æ€è§„åˆ’çš„æ•°å­¦å®šä¹‰

åŠ¨æ€è§„åˆ’é€šè¿‡å°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºé‡å å­é—®é¢˜æ¥æ±‚è§£ã€‚æœ€ä¼˜å­ç»“æ„æ€§è´¨å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$OPT(i) = \max_{j < i} \{OPT(j) + f(i, j)\}$$

å…¶ä¸­ $OPT(i)$ æ˜¯é—®é¢˜åœ¨çŠ¶æ€ $i$ ä¸‹çš„æœ€ä¼˜è§£ã€‚

#### 4.2 åŠ¨æ€è§„åˆ’çš„Pythonå®ç°

```python
class DynamicProgramming:
    """åŠ¨æ€è§„åˆ’ç®—æ³•é›†åˆ"""
    
    @staticmethod
    def fibonacci_dp(n: int) -> int:
        """åŠ¨æ€è§„åˆ’è®¡ç®—æ–æ³¢é‚£å¥‘æ•°"""
        if n <= 1:
            return n
        
        dp = [0] * (n + 1)
        dp[1] = 1
        
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
    
    @staticmethod
    def longest_common_subsequence(str1: str, str2: str) -> int:
        """æœ€é•¿å…¬å…±å­åºåˆ—"""
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n]
    
    @staticmethod
    def knapsack(values: List[int], weights: List[int], capacity: int) -> int:
        """0-1èƒŒåŒ…é—®é¢˜"""
        n = len(values)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i - 1] <= w:
                    dp[i][w] = max(dp[i - 1][w], 
                                  dp[i - 1][w - weights[i - 1]] + values[i - 1])
                else:
                    dp[i][w] = dp[i - 1][w]
        
        return dp[n][capacity]
    
    @staticmethod
    def edit_distance(str1: str, str2: str) -> int:
        """ç¼–è¾‘è·ç¦»"""
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = 1 + min(dp[i - 1][j],      # åˆ é™¤
                                      dp[i][j - 1],      # æ’å…¥
                                      dp[i - 1][j - 1])  # æ›¿æ¢
        
        return dp[m][n]

# ä½¿ç”¨ç¤ºä¾‹
print(f"F(20) = {DynamicProgramming.fibonacci_dp(20)}")

str1, str2 = "ABCDGH", "AEDFHR"
lcs_length = DynamicProgramming.longest_common_subsequence(str1, str2)
print(f"LCSé•¿åº¦: {lcs_length}")

values = [60, 100, 120]
weights = [10, 20, 30]
capacity = 50
max_value = DynamicProgramming.knapsack(values, weights, capacity)
print(f"èƒŒåŒ…æœ€å¤§ä»·å€¼: {max_value}")

edit_dist = DynamicProgramming.edit_distance("kitten", "sitting")
print(f"ç¼–è¾‘è·ç¦»: {edit_dist}")
```

### 5. è´ªå¿ƒç®—æ³•

#### 5.1 è´ªå¿ƒç®—æ³•çš„æ•°å­¦å®šä¹‰

è´ªå¿ƒç®—æ³•åœ¨æ¯ä¸€æ­¥é€‰æ‹©ä¸­éƒ½é‡‡å–å½“å‰çŠ¶æ€ä¸‹æœ€å¥½æˆ–æœ€ä¼˜çš„é€‰æ‹©ã€‚è´ªå¿ƒé€‰æ‹©æ€§è´¨å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$OPT(i) = \max_{j \in C(i)} \{f(j) + OPT(next(j))\}$$

å…¶ä¸­ $C(i)$ æ˜¯å½“å‰çŠ¶æ€ä¸‹çš„å€™é€‰é€‰æ‹©é›†åˆã€‚

#### 5.2 è´ªå¿ƒç®—æ³•çš„Pythonå®ç°

```python
class GreedyAlgorithms:
    """è´ªå¿ƒç®—æ³•é›†åˆ"""
    
    @staticmethod
    def activity_selection(start_times: List[int], 
                          finish_times: List[int]) -> List[int]:
        """æ´»åŠ¨é€‰æ‹©é—®é¢˜"""
        n = len(start_times)
        activities = list(range(n))
        
        # æŒ‰ç»“æŸæ—¶é—´æ’åº
        activities.sort(key=lambda x: finish_times[x])
        
        selected = [activities[0]]
        last_finish = finish_times[activities[0]]
        
        for i in range(1, n):
            if start_times[activities[i]] >= last_finish:
                selected.append(activities[i])
                last_finish = finish_times[activities[i]]
        
        return selected
    
    @staticmethod
    def fractional_knapsack(values: List[int], 
                           weights: List[int], 
                           capacity: int) -> float:
        """åˆ†æ•°èƒŒåŒ…é—®é¢˜"""
        items = [(values[i], weights[i], values[i] / weights[i]) 
                for i in range(len(values))]
        
        # æŒ‰å•ä½ä»·å€¼æ’åº
        items.sort(key=lambda x: x[2], reverse=True)
        
        total_value = 0.0
        remaining_capacity = capacity
        
        for value, weight, unit_value in items:
            if remaining_capacity >= weight:
                total_value += value
                remaining_capacity -= weight
            else:
                total_value += unit_value * remaining_capacity
                break
        
        return total_value
    
    @staticmethod
    def huffman_coding(frequencies: Dict[str, int]) -> Dict[str, str]:
        """éœå¤«æ›¼ç¼–ç """
        from heapq import heappush, heappop
        
        # åˆ›å»ºå¶å­èŠ‚ç‚¹
        heap = [(freq, [[char, ""]]) for char, freq in frequencies.items()]
        heap.sort()
        
        while len(heap) > 1:
            freq1, chars1 = heap.pop(0)
            freq2, chars2 = heap.pop(0)
            
            # ä¸ºå·¦å­æ ‘æ·»åŠ 0ï¼Œä¸ºå³å­æ ‘æ·»åŠ 1
            for char_code in chars1:
                char_code[1] = "0" + char_code[1]
            for char_code in chars2:
                char_code[1] = "1" + char_code[1]
            
            # åˆå¹¶èŠ‚ç‚¹
            merged_chars = chars1 + chars2
            merged_freq = freq1 + freq2
            
            # æ’å…¥åˆ°æ­£ç¡®ä½ç½®
            inserted = False
            for i, (freq, chars) in enumerate(heap):
                if merged_freq <= freq:
                    heap.insert(i, (merged_freq, merged_chars))
                    inserted = True
                    break
            
            if not inserted:
                heap.append((merged_freq, merged_chars))
        
        # æ„å»ºç¼–ç å­—å…¸
        encoding = {}
        for char, code in heap[0][1]:
            encoding[char] = code
        
        return encoding

# ä½¿ç”¨ç¤ºä¾‹
start_times = [1, 3, 0, 5, 8, 5]
finish_times = [2, 4, 6, 7, 9, 9]
selected_activities = GreedyAlgorithms.activity_selection(start_times, finish_times)
print(f"é€‰æ‹©çš„æ´»åŠ¨: {selected_activities}")

values = [60, 100, 120]
weights = [10, 20, 30]
capacity = 50
fractional_value = GreedyAlgorithms.fractional_knapsack(values, weights, capacity)
print(f"åˆ†æ•°èƒŒåŒ…æœ€å¤§ä»·å€¼: {fractional_value}")

frequencies = {'a': 5, 'b': 9, 'c': 12, 'd': 13, 'e': 16, 'f': 45}
huffman_codes = GreedyAlgorithms.huffman_coding(frequencies)
print(f"éœå¤«æ›¼ç¼–ç : {huffman_codes}")
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. ä¸»å®šç†

**å®šç†**: å¯¹äºé€’å½’å…³ç³» $T(n) = aT(n/b) + f(n)$ï¼Œå…¶ä¸­ $a \geq 1$ï¼Œ$b > 1$ï¼Œ$f(n)$ æ˜¯æ¸è¿‘æ­£å‡½æ•°ï¼Œæœ‰ï¼š

1. å¦‚æœ $f(n) = O(n^{\log_b a - \epsilon})$ å¯¹äºæŸä¸ª $\epsilon > 0$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a})$
2. å¦‚æœ $f(n) = \Theta(n^{\log_b a} \log^k n)$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a} \log^{k+1} n)$
3. å¦‚æœ $f(n) = \Omega(n^{\log_b a + \epsilon})$ å¯¹äºæŸä¸ª $\epsilon > 0$ï¼Œä¸” $af(n/b) \leq cf(n)$ å¯¹äºæŸä¸ª $c < 1$ï¼Œåˆ™ $T(n) = \Theta(f(n))$

### 2. è´ªå¿ƒé€‰æ‹©æ€§è´¨

**å®šç†**: åœ¨æ´»åŠ¨é€‰æ‹©é—®é¢˜ä¸­ï¼Œè´ªå¿ƒé€‰æ‹©ï¼ˆé€‰æ‹©æœ€æ—©ç»“æŸçš„æ´»åŠ¨ï¼‰æ€»æ˜¯æœ€ä¼˜çš„ã€‚

**è¯æ˜**: è®¾ $A$ æ˜¯è´ªå¿ƒç®—æ³•é€‰æ‹©çš„è§£ï¼Œ$O$ æ˜¯æœ€ä¼˜è§£ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ›¿æ¢è¯æ˜ $|A| = |O|$ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. ç®—æ³•æ€§èƒ½æ¯”è¾ƒ

```python
class AlgorithmBenchmark:
    """ç®—æ³•æ€§èƒ½åŸºå‡†æµ‹è¯•"""
    
    def __init__(self):
        self.algorithms = {}
    
    def register_algorithm(self, name: str, algorithm: Callable):
        """æ³¨å†Œç®—æ³•"""
        self.algorithms[name] = algorithm
    
    def benchmark(self, input_generator: Callable[[int], Any], 
                 input_sizes: List[int]) -> Dict[str, List[float]]:
        """æ‰§è¡ŒåŸºå‡†æµ‹è¯•"""
        results = {name: [] for name in self.algorithms}
        
        for size in input_sizes:
            input_data = input_generator(size)
            
            for name, algorithm in self.algorithms.items():
                start_time = time.time()
                algorithm(input_data)
                end_time = time.time()
                results[name].append(end_time - start_time)
        
        return results
    
    def plot_benchmark(self, results: Dict[str, List[float]], 
                      input_sizes: List[int]):
        """ç»˜åˆ¶åŸºå‡†æµ‹è¯•ç»“æœ"""
        plt.figure(figsize=(10, 6))
        
        for name, times in results.items():
            plt.plot(input_sizes, times, 'o-', label=name)
        
        plt.xlabel('Input Size')
        plt.ylabel('Execution Time (s)')
        plt.title('Algorithm Performance Comparison')
        plt.legend()
        plt.grid(True)
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def generate_random_array(size: int) -> List[int]:
    """ç”Ÿæˆéšæœºæ•°ç»„"""
    return [random.randint(1, 1000) for _ in range(size)]

benchmark = AlgorithmBenchmark()
benchmark.register_algorithm("Merge Sort", RecursiveAlgorithms.merge_sort)
benchmark.register_algorithm("Quick Sort", RecursiveAlgorithms.quick_sort)

input_sizes = [100, 500, 1000, 2000, 5000]
results = benchmark.benchmark(generate_random_array, input_sizes)
benchmark.plot_benchmark(results, input_sizes)
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [ç®—æ³•ç†è®ºæ¦‚è¿°](../README.md)
- [æ•°æ®ç»“æ„ç†è®º](../02-02-æ•°æ®ç»“æ„ç†è®º/README.md)
- [è®¡ç®—å¤æ‚æ€§ç†è®º](../02-03-è®¡ç®—å¤æ‚æ€§ç†è®º/README.md)
- [å½¢å¼ç§‘å­¦](../01-å½¢å¼ç§‘å­¦/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms. MIT Press.
2. Knuth, D. E. (1997). The Art of Computer Programming. Addison-Wesley.
3. Sedgewick, R., & Wayne, K. (2011). Algorithms. Addison-Wesley.

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
