# ç§»åŠ¨åº”ç”¨å¼€å‘

## ğŸ“‹ æ¦‚è¿°

ç§»åŠ¨åº”ç”¨å¼€å‘æ˜¯ç°ä»£è½¯ä»¶å·¥ç¨‹çš„é‡è¦é¢†åŸŸï¼Œæ¶‰åŠè·¨å¹³å°å¼€å‘ã€åŸç”Ÿå¼€å‘ã€æ··åˆå¼€å‘ç­‰å¤šç§æŠ€æœ¯æ–¹æ¡ˆã€‚æœ¬æ–‡æ¡£æä¾›ç§»åŠ¨åº”ç”¨å¼€å‘çš„å½¢å¼åŒ–å®šä¹‰ã€æŠ€æœ¯æ¶æ„å’Œæœ€ä½³å®è·µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 ç§»åŠ¨åº”ç”¨ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (ç§»åŠ¨åº”ç”¨ç³»ç»Ÿ)
ç§»åŠ¨åº”ç”¨ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{M} = (P, D, I, S, A)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯å¹³å°é›†åˆï¼Œ$P = \{p_1, p_2, \ldots, p_n\}$
- $D$ æ˜¯è®¾å¤‡æŠ½è±¡å±‚ï¼Œ$D = (H, S, N)$
- $I$ æ˜¯äº¤äº’æ¥å£ï¼Œ$I = (UI, UX, G)$
- $S$ æ˜¯æœåŠ¡å±‚ï¼Œ$S = (API, DB, C)$
- $A$ æ˜¯åº”ç”¨é€»è¾‘ï¼Œ$A = (B, L, V)$

**å®šä¹‰ 1.2** (è·¨å¹³å°å¼€å‘)
è·¨å¹³å°å¼€å‘æ˜¯ä¸€ä¸ªæ˜ å°„å‡½æ•° $f: \mathcal{M} \rightarrow \mathcal{P}$ï¼Œå…¶ä¸­ $\mathcal{P}$ æ˜¯å¹³å°æ— å…³çš„æŠ½è±¡å±‚ã€‚

### 1.2 ç§»åŠ¨åº”ç”¨æ¶æ„

**å®šä¹‰ 1.3** (ç§»åŠ¨åº”ç”¨æ¶æ„)
ç§»åŠ¨åº”ç”¨æ¶æ„æ˜¯ä¸€ä¸ªå››å±‚ç»“æ„ $\mathcal{A} = (L_1, L_2, L_3, L_4)$ï¼š

- $L_1$: è¡¨ç¤ºå±‚ (Presentation Layer)
- $L_2$: ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)
- $L_3$: æ•°æ®è®¿é—®å±‚ (Data Access Layer)
- $L_4$: åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)

## 2. æŠ€æœ¯å®ç°

### 2.1 ç§»åŠ¨åº”ç”¨æ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Protocol
from dataclasses import dataclass
from enum import Enum
import asyncio
import json
from pathlib import Path

class Platform(Enum):
    """ç§»åŠ¨å¹³å°æšä¸¾"""
    IOS = "ios"
    ANDROID = "android"
    WEB = "web"
    DESKTOP = "desktop"

@dataclass
class DeviceInfo:
    """è®¾å¤‡ä¿¡æ¯"""
    platform: Platform
    screen_width: int
    screen_height: int
    pixel_density: float
    os_version: str
    device_model: str

class UIComponent(ABC):
    """UIç»„ä»¶æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def render(self) -> str:
        """æ¸²æŸ“ç»„ä»¶"""
        pass
    
    @abstractmethod
    def handle_event(self, event: str, data: Any) -> None:
        """å¤„ç†äº‹ä»¶"""
        pass

class Button(UIComponent):
    """æŒ‰é’®ç»„ä»¶"""
    
    def __init__(self, text: str, on_click: callable):
        self.text = text
        self.on_click = on_click
    
    def render(self) -> str:
        return f"<button onclick='{self.on_click.__name__}'>{self.text}</button>"
    
    def handle_event(self, event: str, data: Any) -> None:
        if event == "click":
            self.on_click()

class TextInput(UIComponent):
    """æ–‡æœ¬è¾“å…¥ç»„ä»¶"""
    
    def __init__(self, placeholder: str = ""):
        self.placeholder = placeholder
        self.value = ""
    
    def render(self) -> str:
        return f"<input placeholder='{self.placeholder}' value='{self.value}'>"
    
    def handle_event(self, event: str, data: Any) -> None:
        if event == "input":
            self.value = data

class MobileApp:
    """ç§»åŠ¨åº”ç”¨åŸºç±»"""
    
    def __init__(self, name: str, platform: Platform):
        self.name = name
        self.platform = platform
        self.components: List[UIComponent] = []
        self.data_store: Dict[str, Any] = {}
    
    def add_component(self, component: UIComponent) -> None:
        """æ·»åŠ UIç»„ä»¶"""
        self.components.append(component)
    
    def render(self) -> str:
        """æ¸²æŸ“åº”ç”¨"""
        components_html = "\n".join(comp.render() for comp in self.components)
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>{self.name}</title>
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body>
            {components_html}
        </body>
        </html>
        """
    
    def save_data(self, key: str, value: Any) -> None:
        """ä¿å­˜æ•°æ®"""
        self.data_store[key] = value
    
    def load_data(self, key: str) -> Any:
        """åŠ è½½æ•°æ®"""
        return self.data_store.get(key)

class CrossPlatformFramework:
    """è·¨å¹³å°å¼€å‘æ¡†æ¶"""
    
    def __init__(self):
        self.platforms: List[Platform] = []
        self.shared_code: Dict[str, Any] = {}
    
    def add_platform(self, platform: Platform) -> None:
        """æ·»åŠ å¹³å°æ”¯æŒ"""
        self.platforms.append(platform)
    
    def compile_for_platform(self, app: MobileApp, target_platform: Platform) -> str:
        """ä¸ºæŒ‡å®šå¹³å°ç¼–è¯‘åº”ç”¨"""
        if target_platform == Platform.WEB:
            return app.render()
        elif target_platform == Platform.IOS:
            return self._generate_ios_code(app)
        elif target_platform == Platform.ANDROID:
            return self._generate_android_code(app)
        else:
            raise ValueError(f"Unsupported platform: {target_platform}")
    
    def _generate_ios_code(self, app: MobileApp) -> str:
        """ç”ŸæˆiOSä»£ç """
        return f"""
        // iOS App: {app.name}
        import UIKit
        
        class {app.name.replace(' ', '')}ViewController: UIViewController {{
            override func viewDidLoad() {{
                super.viewDidLoad()
                // iOS specific implementation
            }}
        }}
        """
    
    def _generate_android_code(self, app: MobileApp) -> str:
        """ç”ŸæˆAndroidä»£ç """
        return f"""
        // Android App: {app.name}
        package com.example.{app.name.lower().replace(' ', '')};
        
        import android.app.Activity;
        import android.os.Bundle;
        
        public class MainActivity extends Activity {{
            @Override
            protected void onCreate(Bundle savedInstanceState) {{
                super.onCreate(savedInstanceState);
                // Android specific implementation
            }}
        }}
        """

class MobileAppBuilder:
    """ç§»åŠ¨åº”ç”¨æ„å»ºå™¨"""
    
    def __init__(self):
        self.framework = CrossPlatformFramework()
        self.framework.add_platform(Platform.WEB)
        self.framework.add_platform(Platform.IOS)
        self.framework.add_platform(Platform.ANDROID)
    
    def create_todo_app(self) -> MobileApp:
        """åˆ›å»ºå¾…åŠäº‹é¡¹åº”ç”¨"""
        app = MobileApp("TodoApp", Platform.WEB)
        
        # æ·»åŠ è¾“å…¥æ¡†
        input_component = TextInput("Enter new task...")
        app.add_component(input_component)
        
        # æ·»åŠ æŒ‰é’®
        def add_task():
            task = input_component.value
            if task:
                app.save_data("tasks", app.load_data("tasks") or [])
                tasks = app.load_data("tasks")
                tasks.append(task)
                app.save_data("tasks", tasks)
                input_component.value = ""
        
        button = Button("Add Task", add_task)
        app.add_component(button)
        
        return app
    
    def build_for_all_platforms(self, app: MobileApp) -> Dict[Platform, str]:
        """ä¸ºæ‰€æœ‰å¹³å°æ„å»ºåº”ç”¨"""
        result = {}
        for platform in self.framework.platforms:
            result[platform] = self.framework.compile_for_platform(app, platform)
        return result
```

### 2.2 çŠ¶æ€ç®¡ç†

```python
from typing import Generic, TypeVar, Callable, List
from dataclasses import dataclass, field
from collections import defaultdict

T = TypeVar('T')

@dataclass
class State(Generic[T]):
    """çŠ¶æ€ç®¡ç†"""
    value: T
    listeners: List[Callable[[T], None]] = field(default_factory=list)
    
    def set_value(self, new_value: T) -> None:
        """è®¾ç½®æ–°å€¼å¹¶é€šçŸ¥ç›‘å¬å™¨"""
        self.value = new_value
        for listener in self.listeners:
            listener(new_value)
    
    def add_listener(self, listener: Callable[[T], None]) -> None:
        """æ·»åŠ ç›‘å¬å™¨"""
        self.listeners.append(listener)
    
    def remove_listener(self, listener: Callable[[T], None]) -> None:
        """ç§»é™¤ç›‘å¬å™¨"""
        if listener in self.listeners:
            self.listeners.remove(listener)

class AppState:
    """åº”ç”¨çŠ¶æ€ç®¡ç†"""
    
    def __init__(self):
        self.states: Dict[str, State] = {}
        self.history: List[Dict[str, Any]] = []
    
    def create_state(self, key: str, initial_value: Any) -> State:
        """åˆ›å»ºçŠ¶æ€"""
        state = State(initial_value)
        self.states[key] = state
        return state
    
    def get_state(self, key: str) -> Optional[State]:
        """è·å–çŠ¶æ€"""
        return self.states.get(key)
    
    def update_state(self, key: str, value: Any) -> None:
        """æ›´æ–°çŠ¶æ€"""
        if key in self.states:
            self.states[key].set_value(value)
            self._save_to_history(key, value)
    
    def _save_to_history(self, key: str, value: Any) -> None:
        """ä¿å­˜åˆ°å†å²è®°å½•"""
        self.history.append({key: value, "timestamp": time.time()})
        if len(self.history) > 100:  # é™åˆ¶å†å²è®°å½•æ•°é‡
            self.history.pop(0)
    
    def undo(self) -> bool:
        """æ’¤é”€æ“ä½œ"""
        if len(self.history) > 1:
            self.history.pop()
            last_state = self.history[-1]
            for key, value in last_state.items():
                if key != "timestamp" and key in self.states:
                    self.states[key].set_value(value)
            return True
        return False
```

### 2.3 ç½‘ç»œè¯·æ±‚å’ŒAPI

```python
import aiohttp
import asyncio
from typing import Dict, Any, Optional
from dataclasses import dataclass

@dataclass
class APIResponse:
    """APIå“åº”"""
    status_code: int
    data: Any
    headers: Dict[str, str]
    error: Optional[str] = None

class APIClient:
    """APIå®¢æˆ·ç«¯"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def get(self, endpoint: str, params: Optional[Dict] = None) -> APIResponse:
        """GETè¯·æ±‚"""
        if not self.session:
            raise RuntimeError("Session not initialized")
        
        url = f"{self.base_url}{endpoint}"
        try:
            async with self.session.get(url, params=params) as response:
                data = await response.json()
                return APIResponse(
                    status_code=response.status,
                    data=data,
                    headers=dict(response.headers)
                )
        except Exception as e:
            return APIResponse(
                status_code=500,
                data=None,
                headers={},
                error=str(e)
            )
    
    async def post(self, endpoint: str, data: Dict) -> APIResponse:
        """POSTè¯·æ±‚"""
        if not self.session:
            raise RuntimeError("Session not initialized")
        
        url = f"{self.base_url}{endpoint}"
        try:
            async with self.session.post(url, json=data) as response:
                response_data = await response.json()
                return APIResponse(
                    status_code=response.status,
                    data=response_data,
                    headers=dict(response.headers)
                )
        except Exception as e:
            return APIResponse(
                status_code=500,
                data=None,
                headers={},
                error=str(e)
            )

class MobileAPIService:
    """ç§»åŠ¨åº”ç”¨APIæœåŠ¡"""
    
    def __init__(self, api_client: APIClient):
        self.client = api_client
    
    async def fetch_user_profile(self, user_id: str) -> APIResponse:
        """è·å–ç”¨æˆ·èµ„æ–™"""
        return await self.client.get(f"/users/{user_id}")
    
    async def update_user_profile(self, user_id: str, data: Dict) -> APIResponse:
        """æ›´æ–°ç”¨æˆ·èµ„æ–™"""
        return await self.client.post(f"/users/{user_id}", data)
    
    async def fetch_todos(self, user_id: str) -> APIResponse:
        """è·å–å¾…åŠäº‹é¡¹"""
        return await self.client.get(f"/users/{user_id}/todos")
    
    async def create_todo(self, user_id: str, todo_data: Dict) -> APIResponse:
        """åˆ›å»ºå¾…åŠäº‹é¡¹"""
        return await self.client.post(f"/users/{user_id}/todos", todo_data)
```

## 3. æœ€ä½³å®è·µ

### 3.1 æ€§èƒ½ä¼˜åŒ–

```python
class PerformanceOptimizer:
    """æ€§èƒ½ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.metrics: Dict[str, float] = {}
    
    def measure_performance(self, func: Callable) -> Callable:
        """æ€§èƒ½æµ‹é‡è£…é¥°å™¨"""
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            
            execution_time = end_time - start_time
            self.metrics[func.__name__] = execution_time
            
            return result
        return wrapper
    
    def optimize_image_loading(self, images: List[str]) -> List[str]:
        """ä¼˜åŒ–å›¾ç‰‡åŠ è½½"""
        # å®ç°å›¾ç‰‡æ‡’åŠ è½½ã€å‹ç¼©ç­‰ä¼˜åŒ–ç­–ç•¥
        optimized_images = []
        for image in images:
            # æ·»åŠ å›¾ç‰‡ä¼˜åŒ–å‚æ•°
            optimized_image = f"{image}?optimize=true&quality=80"
            optimized_images.append(optimized_image)
        return optimized_images
    
    def implement_caching(self, cache_key: str, data: Any, ttl: int = 3600) -> None:
        """å®ç°ç¼“å­˜"""
        # ç®€å•çš„å†…å­˜ç¼“å­˜å®ç°
        cache_data = {
            "data": data,
            "timestamp": time.time(),
            "ttl": ttl
        }
        # è¿™é‡Œåº”è¯¥ä½¿ç”¨Redisæˆ–å…¶ä»–ç¼“å­˜ç³»ç»Ÿ
        print(f"Caching data for key: {cache_key}")
    
    def get_performance_report(self) -> Dict[str, float]:
        """è·å–æ€§èƒ½æŠ¥å‘Š"""
        return self.metrics.copy()
```

### 3.2 é”™è¯¯å¤„ç†

```python
class MobileAppError(Exception):
    """ç§»åŠ¨åº”ç”¨é”™è¯¯åŸºç±»"""
    pass

class NetworkError(MobileAppError):
    """ç½‘ç»œé”™è¯¯"""
    pass

class ValidationError(MobileAppError):
    """éªŒè¯é”™è¯¯"""
    pass

class ErrorHandler:
    """é”™è¯¯å¤„ç†å™¨"""
    
    def __init__(self):
        self.error_log: List[Dict] = []
    
    def handle_error(self, error: Exception, context: str = "") -> None:
        """å¤„ç†é”™è¯¯"""
        error_info = {
            "error_type": type(error).__name__,
            "error_message": str(error),
            "context": context,
            "timestamp": time.time()
        }
        self.error_log.append(error_info)
        
        # æ ¹æ®é”™è¯¯ç±»å‹é‡‡å–ä¸åŒå¤„ç†ç­–ç•¥
        if isinstance(error, NetworkError):
            self._handle_network_error(error)
        elif isinstance(error, ValidationError):
            self._handle_validation_error(error)
        else:
            self._handle_generic_error(error)
    
    def _handle_network_error(self, error: NetworkError) -> None:
        """å¤„ç†ç½‘ç»œé”™è¯¯"""
        print(f"Network error: {error}. Retrying...")
        # å®ç°é‡è¯•é€»è¾‘
    
    def _handle_validation_error(self, error: ValidationError) -> None:
        """å¤„ç†éªŒè¯é”™è¯¯"""
        print(f"Validation error: {error}. Showing user feedback...")
        # æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
    
    def _handle_generic_error(self, error: Exception) -> None:
        """å¤„ç†é€šç”¨é”™è¯¯"""
        print(f"Generic error: {error}. Logging for analysis...")
        # è®°å½•é”™è¯¯æ—¥å¿—
    
    def get_error_report(self) -> List[Dict]:
        """è·å–é”™è¯¯æŠ¥å‘Š"""
        return self.error_log.copy()
```

## 4. å®é™…åº”ç”¨ç¤ºä¾‹

### 4.1 å®Œæ•´çš„ç§»åŠ¨åº”ç”¨ç¤ºä¾‹

```python
class TodoMobileApp:
    """å®Œæ•´çš„å¾…åŠäº‹é¡¹ç§»åŠ¨åº”ç”¨"""
    
    def __init__(self):
        self.app_state = AppState()
        self.error_handler = ErrorHandler()
        self.performance_optimizer = PerformanceOptimizer()
        
        # åˆå§‹åŒ–çŠ¶æ€
        self.todos_state = self.app_state.create_state("todos", [])
        self.user_state = self.app_state.create_state("user", None)
        self.loading_state = self.app_state.create_state("loading", False)
    
    async def initialize_app(self) -> None:
        """åˆå§‹åŒ–åº”ç”¨"""
        try:
            self.loading_state.set_value(True)
            
            # æ¨¡æ‹ŸAPIè°ƒç”¨
            async with APIClient("https://api.example.com") as client:
                api_service = MobileAPIService(client)
                
                # è·å–ç”¨æˆ·ä¿¡æ¯
                user_response = await api_service.fetch_user_profile("user123")
                if user_response.status_code == 200:
                    self.user_state.set_value(user_response.data)
                
                # è·å–å¾…åŠäº‹é¡¹
                todos_response = await api_service.fetch_todos("user123")
                if todos_response.status_code == 200:
                    self.todos_state.set_value(todos_response.data)
            
        except Exception as e:
            self.error_handler.handle_error(e, "app_initialization")
        finally:
            self.loading_state.set_value(False)
    
    @PerformanceOptimizer.measure_performance
    def add_todo(self, title: str, description: str = "") -> None:
        """æ·»åŠ å¾…åŠäº‹é¡¹"""
        try:
            if not title.strip():
                raise ValidationError("Todo title cannot be empty")
            
            new_todo = {
                "id": str(uuid.uuid4()),
                "title": title,
                "description": description,
                "completed": False,
                "created_at": time.time()
            }
            
            current_todos = self.todos_state.value
            current_todos.append(new_todo)
            self.todos_state.set_value(current_todos)
            
        except Exception as e:
            self.error_handler.handle_error(e, "add_todo")
    
    def toggle_todo(self, todo_id: str) -> None:
        """åˆ‡æ¢å¾…åŠäº‹é¡¹çŠ¶æ€"""
        try:
            current_todos = self.todos_state.value
            for todo in current_todos:
                if todo["id"] == todo_id:
                    todo["completed"] = not todo["completed"]
                    break
            
            self.todos_state.set_value(current_todos)
            
        except Exception as e:
            self.error_handler.handle_error(e, "toggle_todo")
    
    def delete_todo(self, todo_id: str) -> None:
        """åˆ é™¤å¾…åŠäº‹é¡¹"""
        try:
            current_todos = self.todos_state.value
            current_todos = [todo for todo in current_todos if todo["id"] != todo_id]
            self.todos_state.set_value(current_todos)
            
        except Exception as e:
            self.error_handler.handle_error(e, "delete_todo")
    
    def get_completed_todos(self) -> List[Dict]:
        """è·å–å·²å®Œæˆçš„å¾…åŠäº‹é¡¹"""
        return [todo for todo in self.todos_state.value if todo["completed"]]
    
    def get_pending_todos(self) -> List[Dict]:
        """è·å–å¾…å®Œæˆçš„å¾…åŠäº‹é¡¹"""
        return [todo for todo in self.todos_state.value if not todo["completed"]]
    
    def render_ui(self) -> str:
        """æ¸²æŸ“ç”¨æˆ·ç•Œé¢"""
        if self.loading_state.value:
            return "<div>Loading...</div>"
        
        todos_html = ""
        for todo in self.todos_state.value:
            status = "âœ“" if todo["completed"] else "â—‹"
            todos_html += f"""
            <div class="todo-item">
                <span class="status">{status}</span>
                <span class="title">{todo['title']}</span>
                <button onclick="deleteTodo('{todo['id']}')">Delete</button>
            </div>
            """
        
        return f"""
        <div class="todo-app">
            <h1>Todo App</h1>
            <div class="add-todo">
                <input id="new-todo" placeholder="Enter new task...">
                <button onclick="addTodo()">Add</button>
            </div>
            <div class="todo-list">
                {todos_html}
            </div>
        </div>
        """

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    """ä¸»å‡½æ•°"""
    app = TodoMobileApp()
    await app.initialize_app()
    
    # æ·»åŠ ä¸€äº›å¾…åŠäº‹é¡¹
    app.add_todo("Learn Python", "Study Python programming language")
    app.add_todo("Build mobile app", "Create a cross-platform mobile application")
    app.add_todo("Write documentation", "Document the project")
    
    # æ¸²æŸ“åº”ç”¨
    ui_html = app.render_ui()
    print("Mobile App UI:")
    print(ui_html)
    
    # æ˜¾ç¤ºæ€§èƒ½æŠ¥å‘Š
    print("\nPerformance Report:")
    print(app.performance_optimizer.get_performance_report())
    
    # æ˜¾ç¤ºé”™è¯¯æŠ¥å‘Š
    print("\nError Report:")
    print(app.error_handler.get_error_report())

if __name__ == "__main__":
    asyncio.run(main())
```

## 5. æ€»ç»“

### 5.1 æŠ€æœ¯è¦ç‚¹

1. **è·¨å¹³å°å¼€å‘**: ä½¿ç”¨ç»Ÿä¸€çš„ä»£ç åŸºç¡€æ”¯æŒå¤šä¸ªå¹³å°
2. **çŠ¶æ€ç®¡ç†**: å®ç°å“åº”å¼çš„çŠ¶æ€ç®¡ç†ç³»ç»Ÿ
3. **æ€§èƒ½ä¼˜åŒ–**: å›¾ç‰‡ä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥ã€æ€§èƒ½ç›‘æ§
4. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆæœºåˆ¶
5. **APIé›†æˆ**: å¼‚æ­¥ç½‘ç»œè¯·æ±‚å’Œæ•°æ®ç®¡ç†

### 5.2 æœ€ä½³å®è·µ

1. **ç»„ä»¶åŒ–è®¾è®¡**: å°†UIæ‹†åˆ†ä¸ºå¯å¤ç”¨çš„ç»„ä»¶
2. **çŠ¶æ€ç®¡ç†**: ä½¿ç”¨é›†ä¸­å¼çŠ¶æ€ç®¡ç†
3. **æ€§èƒ½ç›‘æ§**: å®æ—¶ç›‘æ§åº”ç”¨æ€§èƒ½
4. **é”™è¯¯å¤„ç†**: ä¼˜é›…å¤„ç†å„ç§é”™è¯¯æƒ…å†µ
5. **ç”¨æˆ·ä½“éªŒ**: æä¾›æµç•…çš„ç”¨æˆ·äº¤äº’

### 5.3 æ‰©å±•æ–¹å‘

1. **åŸç”ŸåŠŸèƒ½**: é›†æˆè®¾å¤‡åŸç”ŸåŠŸèƒ½ï¼ˆç›¸æœºã€GPSç­‰ï¼‰
2. **ç¦»çº¿æ”¯æŒ**: å®ç°ç¦»çº¿æ•°æ®åŒæ­¥
3. **æ¨é€é€šçŸ¥**: é›†æˆæ¨é€é€šçŸ¥æœåŠ¡
4. **æ•°æ®åˆ†æ**: ç”¨æˆ·è¡Œä¸ºåˆ†æå’Œæ€§èƒ½ç›‘æ§
5. **å®‰å…¨åŠ å›º**: æ•°æ®åŠ å¯†å’Œå®‰å…¨é˜²æŠ¤

---

**ç›¸å…³æ–‡æ¡£**:

- [Webåº”ç”¨å¼€å‘](./07-01-01-Webåº”ç”¨å¼€å‘.md)
- [æ¡Œé¢åº”ç”¨å¼€å‘](./07-01-03-æ¡Œé¢åº”ç”¨å¼€å‘.md)
- [å¾®æœåŠ¡åº”ç”¨](./07-01-04-å¾®æœåŠ¡åº”ç”¨.md)
