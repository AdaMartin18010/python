# æ•°å­¦å»ºæ¨¡

## ğŸ“‹ æ¦‚è¿°

æ•°å­¦å»ºæ¨¡æ˜¯å°†ç°å®ä¸–ç•Œé—®é¢˜æŠ½è±¡ä¸ºæ•°å­¦å½¢å¼çš„è¿‡ç¨‹ï¼Œæ˜¯è½¯ä»¶å·¥ç¨‹ä¸­é—®é¢˜åˆ†æå’Œç³»ç»Ÿè®¾è®¡çš„åŸºç¡€æ–¹æ³•ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€å»ºæ¨¡æ–¹æ³•ã€Pythonå®ç°ç­‰å¤šä¸ªç»´åº¦å…¨é¢é˜è¿°æ•°å­¦å»ºæ¨¡çš„ç†è®ºä¸å®è·µã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 æ•°å­¦å»ºæ¨¡çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (æ•°å­¦å»ºæ¨¡)
æ•°å­¦å»ºæ¨¡æ˜¯ä¸€ä¸ªå››å…ƒç»„ $M = (P, A, F, V)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯é—®é¢˜åŸŸ (Problem Domain)ï¼Œè¡¨ç¤ºå¾…å»ºæ¨¡çš„ç°å®ä¸–ç•Œé—®é¢˜
- $A$ æ˜¯æŠ½è±¡åŸŸ (Abstraction Domain)ï¼Œè¡¨ç¤ºæ•°å­¦æ¦‚å¿µå’Œç»“æ„
- $F: P \rightarrow A$ æ˜¯å»ºæ¨¡å‡½æ•°ï¼Œå°†é—®é¢˜æ˜ å°„åˆ°æ•°å­¦æŠ½è±¡
- $V$ æ˜¯éªŒè¯é›† (Validation Set)ï¼Œç”¨äºéªŒè¯æ¨¡å‹çš„æœ‰æ•ˆæ€§

**å®šä¹‰ 1.2** (å»ºæ¨¡è´¨é‡)
å»ºæ¨¡è´¨é‡ $Q(M)$ å®šä¹‰ä¸ºï¼š

$$Q(M) = \alpha \cdot A(M) + \beta \cdot P(M) + \gamma \cdot V(M)$$

å…¶ä¸­ï¼š

- $A(M)$ æ˜¯æŠ½è±¡åº¦ (Abstraction Level)
- $P(M)$ æ˜¯ç²¾ç¡®åº¦ (Precision)
- $V(M)$ æ˜¯éªŒè¯åº¦ (Validation)
- $\alpha, \beta, \gamma$ æ˜¯æƒé‡ç³»æ•°ï¼Œæ»¡è¶³ $\alpha + \beta + \gamma = 1$

### 1.2 å»ºæ¨¡è¿‡ç¨‹çš„å½¢å¼åŒ–æè¿°

**å®šä¹‰ 1.3** (å»ºæ¨¡è¿‡ç¨‹)
å»ºæ¨¡è¿‡ç¨‹æ˜¯ä¸€ä¸ªå…­æ­¥åºåˆ—ï¼š

1. **é—®é¢˜è¯†åˆ«**: $I: R \rightarrow P$
2. **å‡è®¾å»ºç«‹**: $H: P \rightarrow H$
3. **æ•°å­¦æŠ½è±¡**: $M: H \rightarrow A$
4. **æ¨¡å‹æ±‚è§£**: $S: A \rightarrow S$
5. **ç»“æœè§£é‡Š**: $E: S \rightarrow I$
6. **æ¨¡å‹éªŒè¯**: $V: I \times M \rightarrow \{0,1\}$

å…¶ä¸­ $R$ æ˜¯ç°å®ä¸–ç•Œï¼Œ$H$ æ˜¯å‡è®¾é›†ï¼Œ$S$ æ˜¯è§£é›†ï¼Œ$I$ æ˜¯è§£é‡Šé›†ã€‚

## 2. å»ºæ¨¡æ–¹æ³•å­¦

### 2.1 å»ºæ¨¡æ–¹æ³•åˆ†ç±»

#### 2.1.1 ç¡®å®šæ€§å»ºæ¨¡

**å®šä¹‰ 2.1** (ç¡®å®šæ€§æ¨¡å‹)
ç¡®å®šæ€§æ¨¡å‹æ˜¯ä¸€ä¸ªå‡½æ•° $f: X \rightarrow Y$ï¼Œå…¶ä¸­ï¼š

- $X$ æ˜¯è¾“å…¥ç©ºé—´
- $Y$ æ˜¯è¾“å‡ºç©ºé—´
- å¯¹äºä»»æ„ $x \in X$ï¼Œå­˜åœ¨å”¯ä¸€çš„ $y = f(x) \in Y$

#### 2.1.2 éšæœºå»ºæ¨¡

**å®šä¹‰ 2.2** (éšæœºæ¨¡å‹)
éšæœºæ¨¡å‹æ˜¯ä¸€ä¸ªæ¦‚ç‡åˆ†å¸ƒ $P(Y|X)$ï¼Œå…¶ä¸­ï¼š

- $X$ æ˜¯è¾“å…¥éšæœºå˜é‡
- $Y$ æ˜¯è¾“å‡ºéšæœºå˜é‡
- $P(Y|X)$ æ˜¯æ¡ä»¶æ¦‚ç‡åˆ†å¸ƒ

#### 2.1.3 æ¨¡ç³Šå»ºæ¨¡

**å®šä¹‰ 2.3** (æ¨¡ç³Šæ¨¡å‹)
æ¨¡ç³Šæ¨¡å‹æ˜¯ä¸€ä¸ªæ¨¡ç³Šå…³ç³» $R: X \times Y \rightarrow [0,1]$ï¼Œå…¶ä¸­ï¼š

- $X$ æ˜¯è¾“å…¥è®ºåŸŸ
- $Y$ æ˜¯è¾“å‡ºè®ºåŸŸ
- $R(x,y)$ è¡¨ç¤ºè¾“å…¥ $x$ å’Œè¾“å‡º $y$ çš„éš¶å±åº¦

### 2.2 å»ºæ¨¡æµç¨‹

#### 2.2.1 ç³»ç»Ÿåˆ†æé˜¶æ®µ

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt

class ModelingPhase(Enum):
    """å»ºæ¨¡é˜¶æ®µæšä¸¾"""
    PROBLEM_IDENTIFICATION = "problem_identification"
    ASSUMPTION_BUILDING = "assumption_building"
    MATHEMATICAL_ABSTRACTION = "mathematical_abstraction"
    MODEL_SOLVING = "model_solving"
    RESULT_INTERPRETATION = "result_interpretation"
    MODEL_VALIDATION = "model_validation"

@dataclass
class ProblemDomain:
    """é—®é¢˜åŸŸå®šä¹‰"""
    name: str
    description: str
    constraints: List[str]
    objectives: List[str]
    stakeholders: List[str]
    
    def __post_init__(self):
        """éªŒè¯é—®é¢˜åŸŸçš„æœ‰æ•ˆæ€§"""
        if not self.name or not self.description:
            raise ValueError("é—®é¢˜åŸŸå¿…é¡»åŒ…å«åç§°å’Œæè¿°")
        if not self.objectives:
            raise ValueError("é—®é¢˜åŸŸå¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªç›®æ ‡")

@dataclass
class ModelingAssumption:
    """å»ºæ¨¡å‡è®¾"""
    id: str
    description: str
    justification: str
    impact_level: str  # "high", "medium", "low"
    
    def validate(self) -> bool:
        """éªŒè¯å‡è®¾çš„åˆç†æ€§"""
        return bool(self.description and self.justification)

class SystemAnalyzer:
    """ç³»ç»Ÿåˆ†æå™¨"""
    
    def __init__(self, problem_domain: ProblemDomain):
        self.problem_domain = problem_domain
        self.assumptions: List[ModelingAssumption] = []
        self.entities: List[str] = []
        self.relationships: List[Tuple[str, str, str]] = []
    
    def identify_entities(self) -> List[str]:
        """è¯†åˆ«ç³»ç»Ÿä¸­çš„å®ä½“"""
        # åŸºäºé—®é¢˜æè¿°è‡ªåŠ¨è¯†åˆ«å®ä½“
        # è¿™é‡Œä½¿ç”¨ç®€å•çš„å…³é”®è¯æå–
        keywords = self.problem_domain.description.lower().split()
        entities = []
        
        # å®ä½“è¯†åˆ«è§„åˆ™
        entity_patterns = [
            "system", "user", "data", "process", "service",
            "component", "module", "interface", "database"
        ]
        
        for pattern in entity_patterns:
            if pattern in keywords:
                entities.append(pattern)
        
        self.entities = entities
        return entities
    
    def identify_relationships(self) -> List[Tuple[str, str, str]]:
        """è¯†åˆ«å®ä½“é—´çš„å…³ç³»"""
        relationships = []
        
        # åŸºäºé—®é¢˜æè¿°è¯†åˆ«å…³ç³»
        # è¿™é‡Œä½¿ç”¨ç®€å•çš„è§„åˆ™
        if "user" in self.entities and "system" in self.entities:
            relationships.append(("user", "interacts_with", "system"))
        
        if "data" in self.entities and "process" in self.entities:
            relationships.append(("process", "processes", "data"))
        
        self.relationships = relationships
        return relationships
    
    def build_assumptions(self) -> List[ModelingAssumption]:
        """å»ºç«‹å»ºæ¨¡å‡è®¾"""
        assumptions = []
        
        # åŸºäºé—®é¢˜åŸŸè‡ªåŠ¨ç”Ÿæˆå‡è®¾
        if "performance" in self.problem_domain.objectives:
            assumptions.append(ModelingAssumption(
                id="A1",
                description="ç³»ç»Ÿå“åº”æ—¶é—´ç¬¦åˆç”¨æˆ·æœŸæœ›",
                justification="æ€§èƒ½æ˜¯ç³»ç»Ÿè´¨é‡çš„é‡è¦æŒ‡æ ‡",
                impact_level="high"
            ))
        
        if "scalability" in self.problem_domain.objectives:
            assumptions.append(ModelingAssumption(
                id="A2", 
                description="ç³»ç»Ÿå¯ä»¥æ°´å¹³æ‰©å±•",
                justification="å¯æ‰©å±•æ€§æ˜¯ç°ä»£ç³»ç»Ÿçš„åŸºæœ¬è¦æ±‚",
                impact_level="high"
            ))
        
        self.assumptions = assumptions
        return assumptions
```

#### 2.2.2 æ•°å­¦æŠ½è±¡é˜¶æ®µ

```python
class MathematicalAbstraction:
    """æ•°å­¦æŠ½è±¡å™¨"""
    
    def __init__(self):
        self.model_types = {
            "deterministic": DeterministicModel,
            "stochastic": StochasticModel,
            "fuzzy": FuzzyModel
        }
    
    def abstract_entities(self, entities: List[str]) -> Dict[str, Any]:
        """å°†å®ä½“æŠ½è±¡ä¸ºæ•°å­¦å¯¹è±¡"""
        abstractions = {}
        
        for entity in entities:
            if entity == "user":
                abstractions[entity] = {
                    "type": "set",
                    "cardinality": "finite",
                    "properties": ["identity", "preferences"]
                }
            elif entity == "data":
                abstractions[entity] = {
                    "type": "structure",
                    "properties": ["size", "format", "access_pattern"]
                }
            elif entity == "process":
                abstractions[entity] = {
                    "type": "function",
                    "domain": "input_space",
                    "codomain": "output_space"
                }
        
        return abstractions
    
    def abstract_relationships(self, relationships: List[Tuple[str, str, str]]) -> Dict[str, Any]:
        """å°†å…³ç³»æŠ½è±¡ä¸ºæ•°å­¦å…³ç³»"""
        abstractions = {}
        
        for rel in relationships:
            entity1, relation, entity2 = rel
            abstractions[f"{entity1}_{relation}_{entity2}"] = {
                "type": "relation",
                "domain": entity1,
                "codomain": entity2,
                "properties": ["transitive", "reflexive"]
            }
        
        return abstractions

class DeterministicModel:
    """ç¡®å®šæ€§æ¨¡å‹"""
    
    def __init__(self, function: callable, domain: Any, codomain: Any):
        self.function = function
        self.domain = domain
        self.codomain = codomain
    
    def evaluate(self, x: Any) -> Any:
        """è¯„ä¼°æ¨¡å‹"""
        if x not in self.domain:
            raise ValueError(f"è¾“å…¥ {x} ä¸åœ¨å®šä¹‰åŸŸå†…")
        return self.function(x)
    
    def validate(self, test_cases: List[Tuple[Any, Any]]) -> float:
        """éªŒè¯æ¨¡å‹å‡†ç¡®æ€§"""
        correct = 0
        total = len(test_cases)
        
        for input_val, expected_output in test_cases:
            actual_output = self.evaluate(input_val)
            if actual_output == expected_output:
                correct += 1
        
        return correct / total if total > 0 else 0.0

class StochasticModel:
    """éšæœºæ¨¡å‹"""
    
    def __init__(self, distribution: str, parameters: Dict[str, float]):
        self.distribution = distribution
        self.parameters = parameters
        self.model = self._create_distribution()
    
    def _create_distribution(self):
        """åˆ›å»ºæ¦‚ç‡åˆ†å¸ƒ"""
        if self.distribution == "normal":
            return stats.norm(loc=self.parameters.get("loc", 0), 
                            scale=self.parameters.get("scale", 1))
        elif self.distribution == "exponential":
            return stats.expon(scale=self.parameters.get("scale", 1))
        elif self.distribution == "poisson":
            return stats.poisson(mu=self.parameters.get("mu", 1))
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„åˆ†å¸ƒç±»å‹: {self.distribution}")
    
    def sample(self, size: int) -> np.ndarray:
        """ç”Ÿæˆéšæœºæ ·æœ¬"""
        return self.model.rvs(size=size)
    
    def probability(self, x: float) -> float:
        """è®¡ç®—æ¦‚ç‡å¯†åº¦"""
        return self.model.pdf(x)
    
    def cumulative_probability(self, x: float) -> float:
        """è®¡ç®—ç´¯ç§¯æ¦‚ç‡"""
        return self.model.cdf(x)

class FuzzyModel:
    """æ¨¡ç³Šæ¨¡å‹"""
    
    def __init__(self, membership_functions: Dict[str, callable]):
        self.membership_functions = membership_functions
    
    def membership_degree(self, variable: str, value: float) -> float:
        """è®¡ç®—éš¶å±åº¦"""
        if variable not in self.membership_functions:
            raise ValueError(f"å˜é‡ {variable} æ²¡æœ‰å®šä¹‰éš¶å±åº¦å‡½æ•°")
        
        return self.membership_functions[variable](value)
    
    def fuzzy_inference(self, inputs: Dict[str, float]) -> Dict[str, float]:
        """æ¨¡ç³Šæ¨ç†"""
        results = {}
        
        for variable, value in inputs.items():
            if variable in self.membership_functions:
                results[variable] = self.membership_degree(variable, value)
        
        return results
```

### 2.3 æ¨¡å‹æ±‚è§£ä¸éªŒè¯

```python
class ModelSolver:
    """æ¨¡å‹æ±‚è§£å™¨"""
    
    def __init__(self):
        self.solution_methods = {
            "analytical": self._analytical_solution,
            "numerical": self._numerical_solution,
            "simulation": self._simulation_solution
        }
    
    def solve(self, model: Any, method: str, **kwargs) -> Any:
        """æ±‚è§£æ¨¡å‹"""
        if method not in self.solution_methods:
            raise ValueError(f"ä¸æ”¯æŒçš„æ±‚è§£æ–¹æ³•: {method}")
        
        return self.solution_methods[method](model, **kwargs)
    
    def _analytical_solution(self, model: DeterministicModel, **kwargs) -> Any:
        """è§£æè§£"""
        # å¯¹äºç®€å•æ¨¡å‹ï¼Œå°è¯•æ‰¾åˆ°è§£æè§£
        if hasattr(model, 'analytical_solution'):
            return model.analytical_solution()
        else:
            raise NotImplementedError("è¯¥æ¨¡å‹æ²¡æœ‰è§£æè§£")
    
    def _numerical_solution(self, model: DeterministicModel, **kwargs) -> Any:
        """æ•°å€¼è§£"""
        # ä½¿ç”¨æ•°å€¼æ–¹æ³•æ±‚è§£
        from scipy.optimize import minimize
        
        def objective(x):
            return model.evaluate(x)
        
        initial_guess = kwargs.get('initial_guess', [0])
        result = minimize(objective, initial_guess)
        return result.x
    
    def _simulation_solution(self, model: StochasticModel, **kwargs) -> Any:
        """ä»¿çœŸè§£"""
        n_samples = kwargs.get('n_samples', 1000)
        samples = model.sample(n_samples)
        return {
            'mean': np.mean(samples),
            'std': np.std(samples),
            'samples': samples
        }

class ModelValidator:
    """æ¨¡å‹éªŒè¯å™¨"""
    
    def __init__(self):
        self.validation_metrics = {
            'accuracy': self._calculate_accuracy,
            'precision': self._calculate_precision,
            'recall': self._calculate_recall,
            'f1_score': self._calculate_f1_score,
            'mae': self._calculate_mae,
            'rmse': self._calculate_rmse
        }
    
    def validate(self, model: Any, test_data: List[Tuple[Any, Any]], 
                metrics: List[str] = None) -> Dict[str, float]:
        """éªŒè¯æ¨¡å‹"""
        if metrics is None:
            metrics = ['accuracy', 'mae']
        
        results = {}
        for metric in metrics:
            if metric in self.validation_metrics:
                results[metric] = self.validation_metrics[metric](model, test_data)
        
        return results
    
    def _calculate_accuracy(self, model: Any, test_data: List[Tuple[Any, Any]]) -> float:
        """è®¡ç®—å‡†ç¡®ç‡"""
        correct = 0
        total = len(test_data)
        
        for input_val, expected_output in test_data:
            try:
                actual_output = model.evaluate(input_val)
                if actual_output == expected_output:
                    correct += 1
            except:
                pass
        
        return correct / total if total > 0 else 0.0
    
    def _calculate_mae(self, model: Any, test_data: List[Tuple[Any, Any]]) -> float:
        """è®¡ç®—å¹³å‡ç»å¯¹è¯¯å·®"""
        errors = []
        
        for input_val, expected_output in test_data:
            try:
                actual_output = model.evaluate(input_val)
                errors.append(abs(actual_output - expected_output))
            except:
                pass
        
        return np.mean(errors) if errors else float('inf')
    
    def _calculate_rmse(self, model: Any, test_data: List[Tuple[Any, Any]]) -> float:
        """è®¡ç®—å‡æ–¹æ ¹è¯¯å·®"""
        errors = []
        
        for input_val, expected_output in test_data:
            try:
                actual_output = model.evaluate(input_val)
                errors.append((actual_output - expected_output) ** 2)
            except:
                pass
        
        return np.sqrt(np.mean(errors)) if errors else float('inf')
    
    def _calculate_precision(self, model: Any, test_data: List[Tuple[Any, Any]]) -> float:
        """è®¡ç®—ç²¾ç¡®ç‡"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ ¹æ®å…·ä½“é—®é¢˜è°ƒæ•´
        return self._calculate_accuracy(model, test_data)
    
    def _calculate_recall(self, model: Any, test_data: List[Tuple[Any, Any]]) -> float:
        """è®¡ç®—å¬å›ç‡"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ ¹æ®å…·ä½“é—®é¢˜è°ƒæ•´
        return self._calculate_accuracy(model, test_data)
    
    def _calculate_f1_score(self, model: Any, test_data: List[Tuple[Any, Any]]) -> float:
        """è®¡ç®—F1åˆ†æ•°"""
        precision = self._calculate_precision(model, test_data)
        recall = self._calculate_recall(model, test_data)
        
        if precision + recall == 0:
            return 0.0
        
        return 2 * (precision * recall) / (precision + recall)
```

## 3. å®é™…åº”ç”¨ç¤ºä¾‹

### 3.1 ç³»ç»Ÿæ€§èƒ½å»ºæ¨¡

```python
class PerformanceModel:
    """ç³»ç»Ÿæ€§èƒ½æ¨¡å‹"""
    
    def __init__(self):
        self.response_time_model = None
        self.throughput_model = None
        self.resource_utilization_model = None
    
    def build_response_time_model(self, load_data: List[Tuple[float, float]]) -> DeterministicModel:
        """æ„å»ºå“åº”æ—¶é—´æ¨¡å‹"""
        # ä½¿ç”¨çº¿æ€§å›å½’å»ºæ¨¡å“åº”æ—¶é—´ä¸è´Ÿè½½çš„å…³ç³»
        loads, response_times = zip(*load_data)
        
        # æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆ
        A = np.vstack([loads, np.ones(len(loads))]).T
        slope, intercept = np.linalg.lstsq(A, response_times, rcond=None)[0]
        
        def response_time_function(load):
            return slope * load + intercept
        
        self.response_time_model = DeterministicModel(
            function=response_time_function,
            domain=loads,
            codomain=response_times
        )
        
        return self.response_time_model
    
    def build_throughput_model(self, concurrency_data: List[Tuple[int, float]]) -> StochasticModel:
        """æ„å»ºååé‡æ¨¡å‹"""
        # ä½¿ç”¨æ³Šæ¾åˆ†å¸ƒå»ºæ¨¡ååé‡
        concurrencies, throughputs = zip(*concurrency_data)
        mean_throughput = np.mean(throughputs)
        
        self.throughput_model = StochasticModel(
            distribution="poisson",
            parameters={"mu": mean_throughput}
        )
        
        return self.throughput_model
    
    def predict_performance(self, load: float, concurrency: int) -> Dict[str, float]:
        """é¢„æµ‹ç³»ç»Ÿæ€§èƒ½"""
        predictions = {}
        
        if self.response_time_model:
            predictions['response_time'] = self.response_time_model.evaluate(load)
        
        if self.throughput_model:
            # ç”Ÿæˆå¤šä¸ªæ ·æœ¬å¹¶å–å¹³å‡å€¼
            samples = self.throughput_model.sample(100)
            predictions['throughput'] = np.mean(samples)
            predictions['throughput_std'] = np.std(samples)
        
        return predictions

# ä½¿ç”¨ç¤ºä¾‹
def performance_modeling_example():
    """æ€§èƒ½å»ºæ¨¡ç¤ºä¾‹"""
    # æ¨¡æ‹Ÿæ€§èƒ½æµ‹è¯•æ•°æ®
    load_data = [
        (10, 50), (20, 80), (30, 120), (40, 180), (50, 250)
    ]
    
    concurrency_data = [
        (1, 100), (2, 180), (3, 250), (4, 300), (5, 320)
    ]
    
    # åˆ›å»ºæ€§èƒ½æ¨¡å‹
    perf_model = PerformanceModel()
    
    # æ„å»ºæ¨¡å‹
    response_model = perf_model.build_response_time_model(load_data)
    throughput_model = perf_model.build_throughput_model(concurrency_data)
    
    # é¢„æµ‹æ€§èƒ½
    predictions = perf_model.predict_performance(load=35, concurrency=3)
    
    print("æ€§èƒ½é¢„æµ‹ç»“æœ:")
    for metric, value in predictions.items():
        print(f"{metric}: {value:.2f}")
    
    # éªŒè¯æ¨¡å‹
    validator = ModelValidator()
    test_data = [(25, 100), (45, 200)]  # æµ‹è¯•æ•°æ®
    validation_results = validator.validate(response_model, test_data)
    
    print("\næ¨¡å‹éªŒè¯ç»“æœ:")
    for metric, value in validation_results.items():
        print(f"{metric}: {value:.4f}")

if __name__ == "__main__":
    performance_modeling_example()
```

### 3.2 èµ„æºåˆ†é…å»ºæ¨¡

```python
class ResourceAllocationModel:
    """èµ„æºåˆ†é…æ¨¡å‹"""
    
    def __init__(self, resources: List[str], tasks: List[str]):
        self.resources = resources
        self.tasks = tasks
        self.allocation_matrix = None
        self.cost_matrix = None
    
    def build_cost_matrix(self, cost_data: Dict[Tuple[str, str], float]):
        """æ„å»ºæˆæœ¬çŸ©é˜µ"""
        self.cost_matrix = np.zeros((len(self.resources), len(self.tasks)))
        
        for (resource, task), cost in cost_data.items():
            if resource in self.resources and task in self.tasks:
                i = self.resources.index(resource)
                j = self.tasks.index(task)
                self.cost_matrix[i, j] = cost
    
    def optimize_allocation(self, method: str = "hungarian") -> Dict[str, str]:
        """ä¼˜åŒ–èµ„æºåˆ†é…"""
        if method == "hungarian":
            from scipy.optimize import linear_sum_assignment
            
            # ä½¿ç”¨åŒˆç‰™åˆ©ç®—æ³•æ±‚è§£æœ€ä¼˜åˆ†é…
            row_indices, col_indices = linear_sum_assignment(self.cost_matrix)
            
            allocation = {}
            total_cost = 0
            
            for i, j in zip(row_indices, col_indices):
                resource = self.resources[i]
                task = self.tasks[j]
                cost = self.cost_matrix[i, j]
                
                allocation[task] = resource
                total_cost += cost
            
            return {
                'allocation': allocation,
                'total_cost': total_cost,
                'efficiency': 1.0 / (1.0 + total_cost)  # æ•ˆç‡æŒ‡æ ‡
            }
        
        elif method == "greedy":
            # è´ªå¿ƒç®—æ³•
            allocation = {}
            total_cost = 0
            used_resources = set()
            
            for task in self.tasks:
                best_resource = None
                best_cost = float('inf')
                
                for i, resource in enumerate(self.resources):
                    if resource not in used_resources:
                        cost = self.cost_matrix[i, self.tasks.index(task)]
                        if cost < best_cost:
                            best_cost = cost
                            best_resource = resource
                
                if best_resource:
                    allocation[task] = best_resource
                    used_resources.add(best_resource)
                    total_cost += best_cost
            
            return {
                'allocation': allocation,
                'total_cost': total_cost,
                'efficiency': 1.0 / (1.0 + total_cost)
            }
    
    def analyze_allocation(self, allocation: Dict[str, str]) -> Dict[str, Any]:
        """åˆ†æåˆ†é…ç»“æœ"""
        analysis = {
            'resource_utilization': {},
            'task_coverage': {},
            'cost_distribution': {},
            'bottlenecks': []
        }
        
        # èµ„æºåˆ©ç”¨ç‡
        resource_usage = {}
        for resource in self.resources:
            resource_usage[resource] = 0
        
        for task, resource in allocation.items():
            resource_usage[resource] += 1
        
        for resource, usage in resource_usage.items():
            analysis['resource_utilization'][resource] = usage / len(self.tasks)
        
        # ä»»åŠ¡è¦†ç›–ç‡
        for task in self.tasks:
            analysis['task_coverage'][task] = task in allocation
        
        # æˆæœ¬åˆ†å¸ƒ
        for task, resource in allocation.items():
            i = self.resources.index(resource)
            j = self.tasks.index(task)
            cost = self.cost_matrix[i, j]
            analysis['cost_distribution'][task] = cost
        
        # è¯†åˆ«ç“¶é¢ˆ
        for resource, utilization in analysis['resource_utilization'].items():
            if utilization > 0.8:  # åˆ©ç”¨ç‡è¶…è¿‡80%è®¤ä¸ºæ˜¯ç“¶é¢ˆ
                analysis['bottlenecks'].append(resource)
        
        return analysis

# ä½¿ç”¨ç¤ºä¾‹
def resource_allocation_example():
    """èµ„æºåˆ†é…å»ºæ¨¡ç¤ºä¾‹"""
    # å®šä¹‰èµ„æºå’Œä»»åŠ¡
    resources = ["CPU1", "CPU2", "GPU1", "Memory1"]
    tasks = ["Task1", "Task2", "Task3", "Task4"]
    
    # åˆ›å»ºèµ„æºåˆ†é…æ¨¡å‹
    model = ResourceAllocationModel(resources, tasks)
    
    # æ„å»ºæˆæœ¬çŸ©é˜µ
    cost_data = {
        ("CPU1", "Task1"): 10, ("CPU1", "Task2"): 15, ("CPU1", "Task3"): 20, ("CPU1", "Task4"): 25,
        ("CPU2", "Task1"): 12, ("CPU2", "Task2"): 10, ("CPU2", "Task3"): 18, ("CPU2", "Task4"): 22,
        ("GPU1", "Task1"): 8,  ("GPU1", "Task2"): 12, ("GPU1", "Task3"): 15, ("GPU1", "Task4"): 20,
        ("Memory1", "Task1"): 5, ("Memory1", "Task2"): 8, ("Memory1", "Task3"): 12, ("Memory1", "Task4"): 15
    }
    
    model.build_cost_matrix(cost_data)
    
    # ä¼˜åŒ–åˆ†é…
    result_hungarian = model.optimize_allocation("hungarian")
    result_greedy = model.optimize_allocation("greedy")
    
    print("åŒˆç‰™åˆ©ç®—æ³•ç»“æœ:")
    print(f"åˆ†é…: {result_hungarian['allocation']}")
    print(f"æ€»æˆæœ¬: {result_hungarian['total_cost']}")
    print(f"æ•ˆç‡: {result_hungarian['efficiency']:.4f}")
    
    print("\nè´ªå¿ƒç®—æ³•ç»“æœ:")
    print(f"åˆ†é…: {result_greedy['allocation']}")
    print(f"æ€»æˆæœ¬: {result_greedy['total_cost']}")
    print(f"æ•ˆç‡: {result_greedy['efficiency']:.4f}")
    
    # åˆ†æåˆ†é…ç»“æœ
    analysis = model.analyze_allocation(result_hungarian['allocation'])
    
    print("\nåˆ†é…åˆ†æ:")
    print(f"èµ„æºåˆ©ç”¨ç‡: {analysis['resource_utilization']}")
    print(f"ä»»åŠ¡è¦†ç›–ç‡: {analysis['task_coverage']}")
    print(f"ç“¶é¢ˆèµ„æº: {analysis['bottlenecks']}")

if __name__ == "__main__":
    resource_allocation_example()
```

## 4. ç†è®ºè¯æ˜

### 4.1 å»ºæ¨¡è´¨é‡å®šç†

**å®šç† 4.1** (å»ºæ¨¡è´¨é‡ä¸Šç•Œ)
å¯¹äºä»»æ„æ•°å­¦å»ºæ¨¡ $M = (P, A, F, V)$ï¼Œå…¶è´¨é‡æ»¡è¶³ï¼š

$$Q(M) \leq \min\{A(M), P(M), V(M)\}$$

**è¯æ˜**:
ç”±äº $\alpha + \beta + \gamma = 1$ ä¸” $\alpha, \beta, \gamma \geq 0$ï¼Œæœ‰ï¼š

$$Q(M) = \alpha \cdot A(M) + \beta \cdot P(M) + \gamma \cdot V(M)$$

$$\leq \alpha \cdot \min\{A(M), P(M), V(M)\} + \beta \cdot \min\{A(M), P(M), V(M)\} + \gamma \cdot \min\{A(M), P(M), V(M)\}$$

$$= (\alpha + \beta + \gamma) \cdot \min\{A(M), P(M), V(M)\}$$

$$= \min\{A(M), P(M), V(M)\}$$

**å®šç† 4.2** (å»ºæ¨¡æ”¶æ•›æ€§)
å¦‚æœå»ºæ¨¡åºåˆ— $\{M_n\}$ æ»¡è¶³ï¼š

1. $A(M_n) \rightarrow A^*$
2. $P(M_n) \rightarrow P^*$
3. $V(M_n) \rightarrow V^*$

åˆ™ $Q(M_n) \rightarrow Q^* = \alpha A^* + \beta P^* + \gamma V^*$

**è¯æ˜**:
ç”±è¿ç»­æ€§å®šç†ï¼Œå¯¹äºä»»æ„ $\epsilon > 0$ï¼Œå­˜åœ¨ $N$ ä½¿å¾—å½“ $n > N$ æ—¶ï¼š

$$|A(M_n) - A^*| < \epsilon, |P(M_n) - P^*| < \epsilon, |V(M_n) - V^*| < \epsilon$$

å› æ­¤ï¼š

$$|Q(M_n) - Q^*| = |\alpha(A(M_n) - A^*) + \beta(P(M_n) - P^*) + \gamma(V(M_n) - V^*)|$$

$$\leq \alpha|A(M_n) - A^*| + \beta|P(M_n) - P^*| + \gamma|V(M_n) - V^*|$$

$$< (\alpha + \beta + \gamma)\epsilon = \epsilon$$

### 4.2 å»ºæ¨¡å¤æ‚åº¦åˆ†æ

**å®šä¹‰ 4.1** (å»ºæ¨¡å¤æ‚åº¦)
å»ºæ¨¡å¤æ‚åº¦ $C(M)$ å®šä¹‰ä¸ºï¼š

$$C(M) = O(|P| \cdot |A| \cdot |F| \cdot |V|)$$

å…¶ä¸­ $|P|, |A|, |F|, |V|$ åˆ†åˆ«è¡¨ç¤ºå„é›†åˆçš„åŸºæ•°ã€‚

**å®šç† 4.3** (å»ºæ¨¡å¤æ‚åº¦ä¸‹ç•Œ)
å¯¹äºä»»æ„éå¹³å‡¡çš„æ•°å­¦å»ºæ¨¡ï¼Œå…¶å¤æ‚åº¦æ»¡è¶³ï¼š

$$C(M) = \Omega(|P| + |A|)$$

**è¯æ˜**:
ç”±äºå»ºæ¨¡å‡½æ•° $F: P \rightarrow A$ å¿…é¡»å®šä¹‰åœ¨ $P$ çš„æ¯ä¸ªå…ƒç´ ä¸Šï¼Œä¸”æ˜ å°„åˆ° $A$ çš„å…ƒç´ ï¼Œå› æ­¤è‡³å°‘éœ€è¦ $|P|$ æ¬¡æ“ä½œæ¥å®šä¹‰æ˜ å°„ï¼Œè‡³å°‘éœ€è¦ $|A|$ æ¬¡æ“ä½œæ¥éªŒè¯ç»“æœçš„æœ‰æ•ˆæ€§ã€‚

## 5. æ€§èƒ½åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------------|------|
| é—®é¢˜è¯†åˆ« | $O(\|P\|)$ | $O(\|P\|)$ | çº¿æ€§æ‰«æé—®é¢˜åŸŸ |
| å‡è®¾å»ºç«‹ | $O(\|H\|)$ | $O(\|H\|)$ | ç”Ÿæˆå’ŒéªŒè¯å‡è®¾ |
| æ•°å­¦æŠ½è±¡ | $O(\|P\| \cdot \|A\|)$ | $O(\|P\| + \|A\|)$ | æ˜ å°„é—®é¢˜åˆ°æŠ½è±¡åŸŸ |
| æ¨¡å‹æ±‚è§£ | $O(f(n))$ | $O(g(n))$ | å–å†³äºå…·ä½“æ±‚è§£æ–¹æ³• |
| ç»“æœè§£é‡Š | $O(\|S\|)$ | $O(\|S\|)$ | è§£é‡Šæ±‚è§£ç»“æœ |
| æ¨¡å‹éªŒè¯ | $O(\|V\|)$ | $O(\|V\|)$ | éªŒè¯æ¨¡å‹æœ‰æ•ˆæ€§ |

### 5.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.1** (ç©ºé—´å¤æ‚åº¦ä¸Šç•Œ)
å¯¹äºä»»æ„æ•°å­¦å»ºæ¨¡ $M$ï¼Œå…¶ç©ºé—´å¤æ‚åº¦æ»¡è¶³ï¼š

$$S(M) = O(|P| + |A| + |F| + |V|)$$

**è¯æ˜**:
å»ºæ¨¡è¿‡ç¨‹éœ€è¦å­˜å‚¨ï¼š

1. é—®é¢˜åŸŸ $P$: $O(|P|)$
2. æŠ½è±¡åŸŸ $A$: $O(|A|)$  
3. å»ºæ¨¡å‡½æ•° $F$: $O(|F|)$
4. éªŒè¯é›† $V$: $O(|V|)$

å› æ­¤æ€»ç©ºé—´å¤æ‚åº¦ä¸º $O(|P| + |A| + |F| + |V|)$ã€‚

## 6. æµ‹è¯•éªŒè¯

```python
import unittest
from typing import List, Tuple, Dict, Any

class MathematicalModelingTest(unittest.TestCase):
    """æ•°å­¦å»ºæ¨¡æµ‹è¯•ç±»"""
    
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.problem_domain = ProblemDomain(
            name="ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–",
            description="ä¼˜åŒ–Webç³»ç»Ÿçš„å“åº”æ—¶é—´å’Œååé‡",
            constraints=["èµ„æºæœ‰é™", "å“åº”æ—¶é—´è¦æ±‚"],
            objectives=["æœ€å°åŒ–å“åº”æ—¶é—´", "æœ€å¤§åŒ–ååé‡"],
            stakeholders=["ç”¨æˆ·", "ç®¡ç†å‘˜", "å¼€å‘è€…"]
        )
        
        self.analyzer = SystemAnalyzer(self.problem_domain)
        self.abstraction = MathematicalAbstraction()
        self.solver = ModelSolver()
        self.validator = ModelValidator()
    
    def test_problem_identification(self):
        """æµ‹è¯•é—®é¢˜è¯†åˆ«"""
        entities = self.analyzer.identify_entities()
        self.assertIsInstance(entities, list)
        self.assertGreater(len(entities), 0)
        
        relationships = self.analyzer.identify_relationships()
        self.assertIsInstance(relationships, list)
    
    def test_assumption_building(self):
        """æµ‹è¯•å‡è®¾å»ºç«‹"""
        assumptions = self.analyzer.build_assumptions()
        self.assertIsInstance(assumptions, list)
        
        for assumption in assumptions:
            self.assertTrue(assumption.validate())
    
    def test_mathematical_abstraction(self):
        """æµ‹è¯•æ•°å­¦æŠ½è±¡"""
        entities = ["user", "system", "data"]
        abstractions = self.abstraction.abstract_entities(entities)
        
        self.assertIsInstance(abstractions, dict)
        self.assertEqual(len(abstractions), len(entities))
    
    def test_deterministic_model(self):
        """æµ‹è¯•ç¡®å®šæ€§æ¨¡å‹"""
        def linear_function(x):
            return 2 * x + 1
        
        model = DeterministicModel(
            function=linear_function,
            domain=[1, 2, 3, 4, 5],
            codomain=[3, 5, 7, 9, 11]
        )
        
        # æµ‹è¯•è¯„ä¼°
        result = model.evaluate(3)
        self.assertEqual(result, 7)
        
        # æµ‹è¯•éªŒè¯
        test_cases = [(1, 3), (2, 5), (3, 7)]
        accuracy = model.validate(test_cases)
        self.assertEqual(accuracy, 1.0)
    
    def test_stochastic_model(self):
        """æµ‹è¯•éšæœºæ¨¡å‹"""
        model = StochasticModel(
            distribution="normal",
            parameters={"loc": 0, "scale": 1}
        )
        
        # æµ‹è¯•é‡‡æ ·
        samples = model.sample(100)
        self.assertEqual(len(samples), 100)
        
        # æµ‹è¯•æ¦‚ç‡è®¡ç®—
        prob = model.probability(0)
        self.assertGreater(prob, 0)
    
    def test_fuzzy_model(self):
        """æµ‹è¯•æ¨¡ç³Šæ¨¡å‹"""
        def temperature_membership(x):
            if x < 0:
                return 0
            elif x <= 25:
                return x / 25
            else:
                return 1
        
        membership_functions = {"temperature": temperature_membership}
        model = FuzzyModel(membership_functions)
        
        # æµ‹è¯•éš¶å±åº¦è®¡ç®—
        degree = model.membership_degree("temperature", 12.5)
        self.assertEqual(degree, 0.5)
    
    def test_model_solving(self):
        """æµ‹è¯•æ¨¡å‹æ±‚è§£"""
        def quadratic_function(x):
            return x[0]**2 + 2*x[0] + 1
        
        model = DeterministicModel(
            function=quadratic_function,
            domain=[[-5, 5]],
            codomain=[0, 36]
        )
        
        # æµ‹è¯•æ•°å€¼æ±‚è§£
        solution = self.solver.solve(model, "numerical", initial_guess=[0])
        self.assertIsInstance(solution, np.ndarray)
    
    def test_model_validation(self):
        """æµ‹è¯•æ¨¡å‹éªŒè¯"""
        def simple_function(x):
            return x * 2
        
        model = DeterministicModel(
            function=simple_function,
            domain=[1, 2, 3],
            codomain=[2, 4, 6]
        )
        
        test_data = [(1, 2), (2, 4), (3, 6)]
        results = self.validator.validate(model, test_data, ['accuracy', 'mae'])
        
        self.assertIn('accuracy', results)
        self.assertIn('mae', results)
        self.assertEqual(results['accuracy'], 1.0)
        self.assertEqual(results['mae'], 0.0)
    
    def test_performance_modeling(self):
        """æµ‹è¯•æ€§èƒ½å»ºæ¨¡"""
        load_data = [(10, 50), (20, 80), (30, 120)]
        perf_model = PerformanceModel()
        
        response_model = perf_model.build_response_time_model(load_data)
        self.assertIsInstance(response_model, DeterministicModel)
        
        predictions = perf_model.predict_performance(25, 2)
        self.assertIsInstance(predictions, dict)
    
    def test_resource_allocation(self):
        """æµ‹è¯•èµ„æºåˆ†é…"""
        resources = ["CPU1", "CPU2"]
        tasks = ["Task1", "Task2"]
        
        model = ResourceAllocationModel(resources, tasks)
        
        cost_data = {
            ("CPU1", "Task1"): 10, ("CPU1", "Task2"): 15,
            ("CPU2", "Task1"): 12, ("CPU2", "Task2"): 10
        }
        
        model.build_cost_matrix(cost_data)
        
        result = model.optimize_allocation("hungarian")
        self.assertIn('allocation', result)
        self.assertIn('total_cost', result)
        self.assertIn('efficiency', result)

if __name__ == '__main__':
    unittest.main()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£å…¨é¢é˜è¿°äº†æ•°å­¦å»ºæ¨¡çš„ç†è®ºä¸å®è·µï¼ŒåŒ…æ‹¬ï¼š

### 7.1 æ ¸å¿ƒè´¡çŒ®

1. **å½¢å¼åŒ–å®šä¹‰**: å»ºç«‹äº†æ•°å­¦å»ºæ¨¡çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **æ–¹æ³•å­¦ä½“ç³»**: æä¾›äº†å®Œæ•´çš„å»ºæ¨¡æ–¹æ³•å­¦æ¡†æ¶
3. **Pythonå®ç°**: æ‰€æœ‰ç†è®ºéƒ½æœ‰å®Œæ•´çš„Pythonå®ç°
4. **å®é™…åº”ç”¨**: æä¾›äº†æ€§èƒ½å»ºæ¨¡å’Œèµ„æºåˆ†é…çš„å®é™…æ¡ˆä¾‹
5. **ç†è®ºè¯æ˜**: è¯æ˜äº†å»ºæ¨¡è´¨é‡å’Œå¤æ‚åº¦çš„ç†è®ºç»“æœ

### 7.2 æŠ€æœ¯ç‰¹è‰²

1. **å¤šè¡¨å¾æ–¹æ³•**: æ¦‚å¿µè§£é‡Šã€æ•°å­¦å½¢å¼ã€ä»£ç å®ç°ã€å›¾è¡¨è¯´æ˜
2. **å±‚æ¬¡åŒ–ç»„ç»‡**: ä»åŸºç¡€æ¦‚å¿µåˆ°é«˜çº§åº”ç”¨
3. **ä¸¥æ ¼å½¢å¼åŒ–**: æ¯ä¸ªæ¦‚å¿µéƒ½æœ‰ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰
4. **å®é™…åº”ç”¨å¯¼å‘**: ç´§å¯†ç»“åˆè½¯ä»¶å·¥ç¨‹å®è·µ

### 7.3 åº”ç”¨ä»·å€¼

1. **æ•™è‚²ä»·å€¼**: ç³»ç»ŸåŒ–çš„æ•°å­¦å»ºæ¨¡å­¦ä¹ èµ„æº
2. **å·¥ç¨‹ä»·å€¼**: å®ç”¨çš„å»ºæ¨¡å·¥å…·å’Œæ–¹æ³•
3. **ç ”ç©¶ä»·å€¼**: å½¢å¼åŒ–çš„ç†è®ºåŸºç¡€

æ•°å­¦å»ºæ¨¡æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­é—®é¢˜åˆ†æå’Œç³»ç»Ÿè®¾è®¡çš„åŸºç¡€æ–¹æ³•ï¼Œé€šè¿‡æœ¬æ–‡æ¡£çš„å­¦ä¹ ï¼Œè¯»è€…å¯ä»¥æŒæ¡ä»é—®é¢˜è¯†åˆ«åˆ°æ¨¡å‹éªŒè¯çš„å®Œæ•´å»ºæ¨¡æµç¨‹ï¼Œä¸ºåç»­çš„è½¯ä»¶è®¾è®¡å’Œå¼€å‘å¥ å®šåšå®çš„ç†è®ºåŸºç¡€ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*æ–‡æ¡£çŠ¶æ€: å·²å®Œæˆ*
*ä¸‹ä¸€æ­¥: é€»è¾‘æ¨ç†æ–‡æ¡£*
