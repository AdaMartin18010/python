# 00-01-ç¼–ç¨‹å“²å­¦

## ğŸ“‹ æ¦‚è¿°

ç¼–ç¨‹å“²å­¦æ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„å“²å­¦åŸºç¡€ï¼Œæ¢è®¨ç¼–ç¨‹çš„æœ¬è´¨ã€åŸåˆ™å’Œæ€ç»´æ–¹å¼ã€‚å®ƒä»å“²å­¦å±‚é¢ç†è§£è®¡ç®—ã€æŠ½è±¡ã€é€»è¾‘å’Œç³»ç»Ÿæ€ç»´ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¡ç®—æ€ç»´ (Computational Thinking)

**æ¦‚å¿µå®šä¹‰**: è®¡ç®—æ€ç»´æ˜¯ä¸€ç§è§£å†³é—®é¢˜çš„æ€ç»´æ–¹å¼ï¼Œé€šè¿‡æŠ½è±¡ã€åˆ†è§£ã€æ¨¡å¼è¯†åˆ«å’Œç®—æ³•è®¾è®¡æ¥ç†è§£å’Œè§£å†³å¤æ‚é—®é¢˜ã€‚

**æ•°å­¦å½¢å¼**:
å¯¹äºé—®é¢˜é›†åˆ $P$ å’Œè§£å†³æ–¹æ¡ˆé›†åˆ $S$ï¼Œè®¡ç®—æ€ç»´å¯ä»¥å½¢å¼åŒ–ä¸ºï¼š

$$CT: P \rightarrow S$$

å…¶ä¸­è®¡ç®—æ€ç»´å‡½æ•° $CT$ åŒ…å«ä»¥ä¸‹ç»„ä»¶ï¼š

1. **æŠ½è±¡ (Abstraction)**: $A: P \rightarrow P'$ï¼Œå…¶ä¸­ $P'$ æ˜¯æŠ½è±¡åçš„é—®é¢˜ç©ºé—´
2. **åˆ†è§£ (Decomposition)**: $D: P' \rightarrow \{p_1, p_2, ..., p_n\}$
3. **æ¨¡å¼è¯†åˆ« (Pattern Recognition)**: $PR: \{p_i\} \rightarrow \{patterns\}$
4. **ç®—æ³•è®¾è®¡ (Algorithm Design)**: $AD: \{patterns\} \rightarrow S$

**Pythonå®ç°**:

```python
from abc import ABC, abstractmethod
from typing import List, Any, Dict, Callable
from dataclasses import dataclass
import math

@dataclass
class Problem:
    """é—®é¢˜æŠ½è±¡"""
    id: str
    description: str
    complexity: float
    constraints: Dict[str, Any]
    
@dataclass
class Solution:
    """è§£å†³æ–¹æ¡ˆæŠ½è±¡"""
    id: str
    algorithm: str
    efficiency: float
    correctness: float

class ComputationalThinking:
    """è®¡ç®—æ€ç»´å®ç°"""
    
    def __init__(self):
        self.abstraction_levels = []
        self.decomposition_strategies = []
        self.pattern_library = {}
        self.algorithm_templates = {}
    
    def abstract(self, problem: Problem) -> Problem:
        """æŠ½è±¡ï¼šæå–é—®é¢˜çš„æœ¬è´¨ç‰¹å¾"""
        # ç§»é™¤å…·ä½“ç»†èŠ‚ï¼Œä¿ç•™æ ¸å¿ƒç»“æ„
        abstracted_problem = Problem(
            id=problem.id,
            description=self._extract_core_concepts(problem.description),
            complexity=math.log(problem.complexity),
            constraints=self._simplify_constraints(problem.constraints)
        )
        self.abstraction_levels.append(abstracted_problem)
        return abstracted_problem
    
    def decompose(self, problem: Problem) -> List[Problem]:
        """åˆ†è§£ï¼šå°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜"""
        sub_problems = []
        
        # åŸºäºå¤æ‚åº¦åˆ†è§£
        if problem.complexity > 10:
            # æŒ‰åŠŸèƒ½åˆ†è§£
            sub_problems.extend(self._functional_decomposition(problem))
        elif problem.complexity > 5:
            # æŒ‰æ•°æ®åˆ†è§£
            sub_problems.extend(self._data_decomposition(problem))
        else:
            # æŒ‰æ­¥éª¤åˆ†è§£
            sub_problems.extend(self._step_decomposition(problem))
        
        self.decomposition_strategies.append({
            'original': problem,
            'sub_problems': sub_problems
        })
        return sub_problems
    
    def recognize_patterns(self, problems: List[Problem]) -> Dict[str, Any]:
        """æ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«é—®é¢˜ä¸­çš„é‡å¤æ¨¡å¼"""
        patterns = {}
        
        for problem in problems:
            # è¯†åˆ«ç®—æ³•æ¨¡å¼
            if self._is_sorting_problem(problem):
                patterns['sorting'] = patterns.get('sorting', 0) + 1
            elif self._is_search_problem(problem):
                patterns['search'] = patterns.get('search', 0) + 1
            elif self._is_graph_problem(problem):
                patterns['graph'] = patterns.get('graph', 0) + 1
            elif self._is_dynamic_programming_problem(problem):
                patterns['dp'] = patterns.get('dp', 0) + 1
        
        self.pattern_library.update(patterns)
        return patterns
    
    def design_algorithm(self, patterns: Dict[str, Any]) -> Solution:
        """ç®—æ³•è®¾è®¡ï¼šåŸºäºæ¨¡å¼è®¾è®¡è§£å†³æ–¹æ¡ˆ"""
        # é€‰æ‹©æœ€é¢‘ç¹çš„æ¨¡å¼ä½œä¸ºä¸»è¦ç®—æ³•
        primary_pattern = max(patterns.items(), key=lambda x: x[1])[0]
        
        # æ ¹æ®æ¨¡å¼é€‰æ‹©ç®—æ³•æ¨¡æ¿
        algorithm_template = self._get_algorithm_template(primary_pattern)
        
        # è®¡ç®—æ•ˆç‡å’Œæ­£ç¡®æ€§
        efficiency = self._calculate_efficiency(patterns)
        correctness = self._calculate_correctness(patterns)
        
        solution = Solution(
            id=f"solution_{len(self.algorithm_templates)}",
            algorithm=algorithm_template,
            efficiency=efficiency,
            correctness=correctness
        )
        
        self.algorithm_templates[solution.id] = solution
        return solution
    
    def solve(self, problem: Problem) -> Solution:
        """å®Œæ•´çš„è®¡ç®—æ€ç»´è¿‡ç¨‹"""
        # 1. æŠ½è±¡
        abstracted = self.abstract(problem)
        
        # 2. åˆ†è§£
        sub_problems = self.decompose(abstracted)
        
        # 3. æ¨¡å¼è¯†åˆ«
        patterns = self.recognize_patterns(sub_problems)
        
        # 4. ç®—æ³•è®¾è®¡
        solution = self.design_algorithm(patterns)
        
        return solution
    
    def _extract_core_concepts(self, description: str) -> str:
        """æå–æ ¸å¿ƒæ¦‚å¿µ"""
        # ç®€åŒ–æè¿°ï¼Œä¿ç•™å…³é”®æ¦‚å¿µ
        keywords = ['sort', 'search', 'find', 'calculate', 'process', 'analyze']
        core_concepts = [word for word in description.lower().split() 
                        if word in keywords]
        return ' '.join(core_concepts) if core_concepts else description[:50]
    
    def _simplify_constraints(self, constraints: Dict[str, Any]) -> Dict[str, Any]:
        """ç®€åŒ–çº¦æŸæ¡ä»¶"""
        simplified = {}
        for key, value in constraints.items():
            if isinstance(value, (int, float, str)):
                simplified[key] = value
            elif isinstance(value, (list, tuple)) and len(value) <= 3:
                simplified[key] = value
        return simplified
    
    def _functional_decomposition(self, problem: Problem) -> List[Problem]:
        """åŠŸèƒ½åˆ†è§£"""
        return [
            Problem(f"{problem.id}_input", "Input processing", 2, {}),
            Problem(f"{problem.id}_process", "Core processing", 4, {}),
            Problem(f"{problem.id}_output", "Output generation", 2, {})
        ]
    
    def _data_decomposition(self, problem: Problem) -> List[Problem]:
        """æ•°æ®åˆ†è§£"""
        return [
            Problem(f"{problem.id}_data1", "Data subset 1", 3, {}),
            Problem(f"{problem.id}_data2", "Data subset 2", 3, {})
        ]
    
    def _step_decomposition(self, problem: Problem) -> List[Problem]:
        """æ­¥éª¤åˆ†è§£"""
        return [
            Problem(f"{problem.id}_step1", "Step 1", 2, {}),
            Problem(f"{problem.id}_step2", "Step 2", 2, {})
        ]
    
    def _is_sorting_problem(self, problem: Problem) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæ’åºé—®é¢˜"""
        return any(word in problem.description.lower() 
                  for word in ['sort', 'order', 'arrange'])
    
    def _is_search_problem(self, problem: Problem) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæœç´¢é—®é¢˜"""
        return any(word in problem.description.lower() 
                  for word in ['search', 'find', 'locate'])
    
    def _is_graph_problem(self, problem: Problem) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå›¾è®ºé—®é¢˜"""
        return any(word in problem.description.lower() 
                  for word in ['graph', 'network', 'path', 'route'])
    
    def _is_dynamic_programming_problem(self, problem: Problem) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºåŠ¨æ€è§„åˆ’é—®é¢˜"""
        return any(word in problem.description.lower() 
                  for word in ['optimal', 'maximum', 'minimum', 'best'])
    
    def _get_algorithm_template(self, pattern: str) -> str:
        """è·å–ç®—æ³•æ¨¡æ¿"""
        templates = {
            'sorting': 'QuickSort/O(n log n)',
            'search': 'BinarySearch/O(log n)',
            'graph': 'BFS/DFS/O(V+E)',
            'dp': 'DynamicProgramming/O(nÂ²)'
        }
        return templates.get(pattern, 'GenericAlgorithm/O(n)')
    
    def _calculate_efficiency(self, patterns: Dict[str, Any]) -> float:
        """è®¡ç®—æ•ˆç‡åˆ†æ•°"""
        total_patterns = sum(patterns.values())
        if total_patterns == 0:
            return 0.5
        
        # åŸºäºæ¨¡å¼å¤æ‚åº¦è®¡ç®—æ•ˆç‡
        efficiency_scores = {
            'sorting': 0.8,
            'search': 0.9,
            'graph': 0.7,
            'dp': 0.6
        }
        
        weighted_score = sum(
            patterns.get(pattern, 0) * efficiency_scores.get(pattern, 0.5)
            for pattern in patterns
        )
        return min(1.0, weighted_score / total_patterns)
    
    def _calculate_correctness(self, patterns: Dict[str, Any]) -> float:
        """è®¡ç®—æ­£ç¡®æ€§åˆ†æ•°"""
        # åŸºäºæ¨¡å¼çš„å¯éªŒè¯æ€§è®¡ç®—æ­£ç¡®æ€§
        correctness_scores = {
            'sorting': 0.95,
            'search': 0.98,
            'graph': 0.85,
            'dp': 0.90
        }
        
        total_patterns = sum(patterns.values())
        if total_patterns == 0:
            return 0.5
        
        weighted_score = sum(
            patterns.get(pattern, 0) * correctness_scores.get(pattern, 0.5)
            for pattern in patterns
        )
        return min(1.0, weighted_score / total_patterns)

# ä½¿ç”¨ç¤ºä¾‹
def demonstrate_computational_thinking():
    """æ¼”ç¤ºè®¡ç®—æ€ç»´è¿‡ç¨‹"""
    ct = ComputationalThinking()
    
    # åˆ›å»ºä¸€ä¸ªå¤æ‚é—®é¢˜
    complex_problem = Problem(
        id="sort_and_search",
        description="Sort a large dataset and then search for specific elements",
        complexity=15.0,
        constraints={"memory": "limited", "time": "fast"}
    )
    
    print("=== è®¡ç®—æ€ç»´æ¼”ç¤º ===")
    print(f"åŸå§‹é—®é¢˜: {complex_problem.description}")
    print(f"å¤æ‚åº¦: {complex_problem.complexity}")
    
    # åº”ç”¨è®¡ç®—æ€ç»´
    solution = ct.solve(complex_problem)
    
    print(f"\nè§£å†³æ–¹æ¡ˆ: {solution.algorithm}")
    print(f"æ•ˆç‡åˆ†æ•°: {solution.efficiency:.2f}")
    print(f"æ­£ç¡®æ€§åˆ†æ•°: {solution.correctness:.2f}")
    
    print(f"\næŠ½è±¡å±‚æ¬¡æ•°: {len(ct.abstraction_levels)}")
    print(f"åˆ†è§£ç­–ç•¥æ•°: {len(ct.decomposition_strategies)}")
    print(f"è¯†åˆ«æ¨¡å¼: {ct.pattern_library}")

if __name__ == "__main__":
    demonstrate_computational_thinking()
```

### 2. æŠ½è±¡æ€ç»´ (Abstract Thinking)

**æ¦‚å¿µå®šä¹‰**: æŠ½è±¡æ€ç»´æ˜¯å¿½ç•¥å…·ä½“ç»†èŠ‚ï¼Œæå–äº‹ç‰©æœ¬è´¨ç‰¹å¾å’Œè§„å¾‹çš„æ€ç»´æ–¹å¼ã€‚

**æ•°å­¦å½¢å¼**:
æŠ½è±¡å¯ä»¥å½¢å¼åŒ–ä¸ºæ˜ å°„å‡½æ•°ï¼š

$$A: D \rightarrow A$$

å…¶ä¸­ï¼š

- $D$ æ˜¯å…·ä½“é¢†åŸŸ
- $A$ æ˜¯æŠ½è±¡é¢†åŸŸ
- $A$ æ˜¯æŠ½è±¡å‡½æ•°

æŠ½è±¡å±‚æ¬¡å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$A_1 \subset A_2 \subset ... \subset A_n$$

**Pythonå®ç°**:

```python
from typing import TypeVar, Generic, Dict, Any, List
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

T = TypeVar('T')

class AbstractionLevel(Enum):
    """æŠ½è±¡å±‚æ¬¡æšä¸¾"""
    CONCRETE = 0
    IMPLEMENTATION = 1
    INTERFACE = 2
    CONCEPTUAL = 3
    PHILOSOPHICAL = 4

@dataclass
class AbstractConcept:
    """æŠ½è±¡æ¦‚å¿µ"""
    name: str
    level: AbstractionLevel
    properties: Dict[str, Any]
    relationships: List[str]

class AbstractThinking(Generic[T]):
    """æŠ½è±¡æ€ç»´å®ç°"""
    
    def __init__(self):
        self.abstraction_hierarchy = {}
        self.concept_mappings = {}
        self.pattern_extractors = {}
    
    def abstract(self, concrete_object: T, target_level: AbstractionLevel) -> AbstractConcept:
        """å°†å…·ä½“å¯¹è±¡æŠ½è±¡åˆ°æŒ‡å®šå±‚æ¬¡"""
        # æå–æœ¬è´¨ç‰¹å¾
        essential_properties = self._extract_essential_properties(concrete_object)
        
        # è¯†åˆ«æ¨¡å¼
        patterns = self._identify_patterns(concrete_object)
        
        # å»ºç«‹å…³ç³»
        relationships = self._establish_relationships(concrete_object)
        
        # åˆ›å»ºæŠ½è±¡æ¦‚å¿µ
        concept_name = self._generate_concept_name(concrete_object, target_level)
        
        abstract_concept = AbstractConcept(
            name=concept_name,
            level=target_level,
            properties=essential_properties,
            relationships=relationships
        )
        
        # å­˜å‚¨æŠ½è±¡å±‚æ¬¡
        self.abstraction_hierarchy[concept_name] = abstract_concept
        self.concept_mappings[concept_name] = concrete_object
        
        return abstract_concept
    
    def generalize(self, concepts: List[AbstractConcept]) -> AbstractConcept:
        """æ³›åŒ–ï¼šä»å¤šä¸ªæ¦‚å¿µä¸­æå–å…±åŒç‰¹å¾"""
        if not concepts:
            raise ValueError("æ¦‚å¿µåˆ—è¡¨ä¸èƒ½ä¸ºç©º")
        
        # æ‰¾åˆ°å…±åŒå±æ€§
        common_properties = self._find_common_properties(concepts)
        
        # åˆ›å»ºæ³›åŒ–æ¦‚å¿µ
        generalized_name = f"Generalized_{len(self.abstraction_hierarchy)}"
        generalized_level = max(concept.level.value for concept in concepts) + 1
        
        generalized_concept = AbstractConcept(
            name=generalized_name,
            level=AbstractionLevel(generalized_level),
            properties=common_properties,
            relationships=[f"generalizes_{concept.name}" for concept in concepts]
        )
        
        self.abstraction_hierarchy[generalized_name] = generalized_concept
        return generalized_concept
    
    def specialize(self, abstract_concept: AbstractConcept, 
                  specific_properties: Dict[str, Any]) -> AbstractConcept:
        """ç‰¹åŒ–ï¼šä¸ºæŠ½è±¡æ¦‚å¿µæ·»åŠ å…·ä½“å±æ€§"""
        # åˆ›å»ºç‰¹åŒ–æ¦‚å¿µ
        specialized_name = f"Specialized_{abstract_concept.name}"
        specialized_level = max(0, abstract_concept.level.value - 1)
        
        # åˆå¹¶å±æ€§
        specialized_properties = {
            **abstract_concept.properties,
            **specific_properties
        }
        
        specialized_concept = AbstractConcept(
            name=specialized_name,
            level=AbstractionLevel(specialized_level),
            properties=specialized_properties,
            relationships=[f"specializes_{abstract_concept.name}"]
        )
        
        self.abstraction_hierarchy[specialized_name] = specialized_concept
        return specialized_concept
    
    def _extract_essential_properties(self, obj: T) -> Dict[str, Any]:
        """æå–æœ¬è´¨å±æ€§"""
        properties = {}
        
        if hasattr(obj, '__dict__'):
            # å¯¹è±¡å±æ€§
            for key, value in obj.__dict__.items():
                if not key.startswith('_'):
                    properties[key] = type(value).__name__
        elif hasattr(obj, '__class__'):
            # ç±»å‹ä¿¡æ¯
            properties['type'] = obj.__class__.__name__
            properties['module'] = obj.__class__.__module__
        
        return properties
    
    def _identify_patterns(self, obj: T) -> Dict[str, Any]:
        """è¯†åˆ«æ¨¡å¼"""
        patterns = {}
        
        # è¯†åˆ«è®¾è®¡æ¨¡å¼
        if hasattr(obj, '__call__'):
            patterns['callable'] = True
        
        if hasattr(obj, '__iter__'):
            patterns['iterable'] = True
        
        if hasattr(obj, '__len__'):
            patterns['sized'] = True
        
        if hasattr(obj, '__getitem__'):
            patterns['indexable'] = True
        
        return patterns
    
    def _establish_relationships(self, obj: T) -> List[str]:
        """å»ºç«‹å…³ç³»"""
        relationships = []
        
        # ç»§æ‰¿å…³ç³»
        if hasattr(obj, '__class__'):
            for base in obj.__class__.__bases__:
                relationships.append(f"inherits_from_{base.__name__}")
        
        # ç»„åˆå…³ç³»
        if hasattr(obj, '__dict__'):
            for attr_name in obj.__dict__:
                if not attr_name.startswith('_'):
                    relationships.append(f"has_{attr_name}")
        
        return relationships
    
    def _generate_concept_name(self, obj: T, level: AbstractionLevel) -> str:
        """ç”Ÿæˆæ¦‚å¿µåç§°"""
        base_name = obj.__class__.__name__ if hasattr(obj, '__class__') else str(type(obj))
        
        level_suffixes = {
            AbstractionLevel.CONCRETE: "Concrete",
            AbstractionLevel.IMPLEMENTATION: "Implementation",
            AbstractionLevel.INTERFACE: "Interface",
            AbstractionLevel.CONCEPTUAL: "Concept",
            AbstractionLevel.PHILOSOPHICAL: "Philosophy"
        }
        
        return f"{base_name}_{level_suffixes[level]}"
    
    def _find_common_properties(self, concepts: List[AbstractConcept]) -> Dict[str, Any]:
        """æ‰¾åˆ°å…±åŒå±æ€§"""
        if not concepts:
            return {}
        
        # è·å–æ‰€æœ‰å±æ€§é”®
        all_keys = set()
        for concept in concepts:
            all_keys.update(concept.properties.keys())
        
        # æ‰¾åˆ°å…±åŒå±æ€§
        common_properties = {}
        for key in all_keys:
            values = [concept.properties.get(key) for concept in concepts]
            if len(set(values)) == 1:  # æ‰€æœ‰å€¼éƒ½ç›¸åŒ
                common_properties[key] = values[0]
        
        return common_properties

# ä½¿ç”¨ç¤ºä¾‹
class ConcreteExample:
    """å…·ä½“ç¤ºä¾‹ç±»"""
    def __init__(self, name: str, value: int):
        self.name = name
        self.value = value
        self._private_attr = "hidden"
    
    def method(self):
        return f"{self.name}: {self.value}"

def demonstrate_abstract_thinking():
    """æ¼”ç¤ºæŠ½è±¡æ€ç»´è¿‡ç¨‹"""
    at = AbstractThinking()
    
    # åˆ›å»ºå…·ä½“å¯¹è±¡
    obj1 = ConcreteExample("Object1", 10)
    obj2 = ConcreteExample("Object2", 20)
    obj3 = ConcreteExample("Object3", 30)
    
    print("=== æŠ½è±¡æ€ç»´æ¼”ç¤º ===")
    
    # æŠ½è±¡åˆ°æ¥å£å±‚æ¬¡
    concept1 = at.abstract(obj1, AbstractionLevel.INTERFACE)
    concept2 = at.abstract(obj2, AbstractionLevel.INTERFACE)
    concept3 = at.abstract(obj3, AbstractionLevel.INTERFACE)
    
    print(f"æŠ½è±¡æ¦‚å¿µ1: {concept1.name}")
    print(f"å±æ€§: {concept1.properties}")
    print(f"å…³ç³»: {concept1.relationships}")
    
    # æ³›åŒ–
    generalized = at.generalize([concept1, concept2, concept3])
    print(f"\næ³›åŒ–æ¦‚å¿µ: {generalized.name}")
    print(f"å…±åŒå±æ€§: {generalized.properties}")
    
    # ç‰¹åŒ–
    specialized = at.specialize(generalized, {"specific_feature": "unique"})
    print(f"\nç‰¹åŒ–æ¦‚å¿µ: {specialized.name}")
    print(f"ç‰¹åŒ–å±æ€§: {specialized.properties}")

if __name__ == "__main__":
    demonstrate_abstract_thinking()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [00-02-å½¢å¼åŒ–æ€ç»´](./00-02-å½¢å¼åŒ–æ€ç»´.md)
- [00-03-è®¡ç®—æ€ç»´](./00-03-è®¡ç®—æ€ç»´.md)
- [01-01-æ•°å­¦åŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-01-æ•°å­¦åŸºç¡€.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Wing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35.
2. Denning, P. J. (2009). The profession of IT: Beyond computational thinking. Communications of the ACM, 52(6), 28-30.
3. Knuth, D. E. (1974). Computer programming as an art. Communications of the ACM, 17(12), 667-673.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
