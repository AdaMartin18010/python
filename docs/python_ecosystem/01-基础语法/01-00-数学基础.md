# 00. æ•°å­¦åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ•°å­¦åŸºç¡€æ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—ç§‘å­¦çš„é‡è¦ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£é˜è¿°è½¯ä»¶å·¥ç¨‹ä¸­å¸¸ç”¨çš„æ•°å­¦æ¦‚å¿µã€å®šç†å’Œæ–¹æ³•ï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é›†åˆè®ºåŸºç¡€

#### 1.1 é›†åˆå®šä¹‰

**å®šä¹‰ 1.1.1** (é›†åˆ)
é›†åˆæ˜¯ä¸åŒå…ƒç´ çš„èšé›†ï¼š
$$A = \{x \mid P(x)\}$$

å…¶ä¸­ $P(x)$ æ˜¯è°“è¯ï¼Œå®šä¹‰é›†åˆä¸­å…ƒç´ çš„æ€§è´¨ã€‚

**å®šä¹‰ 1.1.2** (é›†åˆè¿ç®—)

- å¹¶é›†ï¼š$A \cup B = \{x \mid x \in A \lor x \in B\}$
- äº¤é›†ï¼š$A \cap B = \{x \mid x \in A \land x \in B\}$
- å·®é›†ï¼š$A \setminus B = \{x \mid x \in A \land x \notin B\}$
- è¡¥é›†ï¼š$A^c = \{x \mid x \notin A\}$

#### 1.2 Pythonå®ç°

```python
from typing import TypeVar, Generic, Set, List, Any, Callable
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

T = TypeVar('T')

class SetOperation(Enum):
    """é›†åˆè¿ç®—ç±»å‹"""
    UNION = "union"
    INTERSECTION = "intersection"
    DIFFERENCE = "difference"
    COMPLEMENT = "complement"
    SYMMETRIC_DIFFERENCE = "symmetric_difference"

class MathematicalSet:
    """æ•°å­¦é›†åˆç±»"""
    
    def __init__(self, elements: Set[T] = None):
        self.elements = elements or set()
    
    def add(self, element: T) -> None:
        """æ·»åŠ å…ƒç´ """
        self.elements.add(element)
    
    def remove(self, element: T) -> None:
        """ç§»é™¤å…ƒç´ """
        self.elements.discard(element)
    
    def contains(self, element: T) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦å±äºé›†åˆ"""
        return element in self.elements
    
    def union(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """å¹¶é›†"""
        return MathematicalSet(self.elements | other.elements)
    
    def intersection(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """äº¤é›†"""
        return MathematicalSet(self.elements & other.elements)
    
    def difference(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """å·®é›†"""
        return MathematicalSet(self.elements - other.elements)
    
    def complement(self, universe: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """è¡¥é›†"""
        return MathematicalSet(universe.elements - self.elements)
    
    def symmetric_difference(self, other: 'MathematicalSet[T]') -> 'MathematicalSet[T]':
        """å¯¹ç§°å·®é›†"""
        return MathematicalSet(self.elements ^ other.elements)
    
    def is_subset(self, other: 'MathematicalSet[T]') -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå­é›†"""
        return self.elements.issubset(other.elements)
    
    def is_superset(self, other: 'MathematicalSet[T]') -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºè¶…é›†"""
        return self.elements.issuperset(other.elements)
    
    def cardinality(self) -> int:
        """åŸºæ•°"""
        return len(self.elements)
    
    def is_empty(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç©ºé›†"""
        return len(self.elements) == 0
    
    def __str__(self) -> str:
        return f"{{{', '.join(map(str, self.elements))}}}"
    
    def __repr__(self) -> str:
        return f"MathematicalSet({self.elements})"

# ç¤ºä¾‹ï¼šé›†åˆè¿ç®—
set_a = MathematicalSet({1, 2, 3, 4, 5})
set_b = MathematicalSet({4, 5, 6, 7, 8})

print(f"é›†åˆA: {set_a}")
print(f"é›†åˆB: {set_b}")
print(f"å¹¶é›†: {set_a.union(set_b)}")
print(f"äº¤é›†: {set_a.intersection(set_b)}")
print(f"å·®é›†A-B: {set_a.difference(set_b)}")
print(f"å¯¹ç§°å·®é›†: {set_a.symmetric_difference(set_b)}")
print(f"Aæ˜¯Bçš„å­é›†: {set_a.is_subset(set_b)}")
```

### 2. å…³ç³»ç†è®º

#### 2.1 å…³ç³»å®šä¹‰

**å®šä¹‰ 2.1.1** (å…³ç³»)
å…³ç³»æ˜¯é›†åˆçš„ç¬›å¡å°”ç§¯çš„å­é›†ï¼š
$$R \subseteq A \times B$$

**å®šä¹‰ 2.1.2** (å…³ç³»æ€§è´¨)

- è‡ªåæ€§ï¼š$\forall x \in A, (x, x) \in R$
- å¯¹ç§°æ€§ï¼š$\forall x, y \in A, (x, y) \in R \Rightarrow (y, x) \in R$
- ä¼ é€’æ€§ï¼š$\forall x, y, z \in A, (x, y) \in R \land (y, z) \in R \Rightarrow (x, z) \in R$

#### 2.2 Pythonå®ç°

```python
from typing import Dict, List, Tuple, Any, Set
from dataclasses import dataclass

@dataclass
class Relation:
    """å…³ç³»ç±»"""
    domain: Set[Any]
    codomain: Set[Any]
    pairs: Set[Tuple[Any, Any]]
    
    def __init__(self, domain: Set[Any], codomain: Set[Any]):
        self.domain = domain
        self.codomain = codomain
        self.pairs = set()
    
    def add_pair(self, x: Any, y: Any) -> None:
        """æ·»åŠ æœ‰åºå¯¹"""
        if x in self.domain and y in self.codomain:
            self.pairs.add((x, y))
    
    def remove_pair(self, x: Any, y: Any) -> None:
        """ç§»é™¤æœ‰åºå¯¹"""
        self.pairs.discard((x, y))
    
    def contains(self, x: Any, y: Any) -> bool:
        """æ£€æŸ¥æ˜¯å¦åŒ…å«æœ‰åºå¯¹"""
        return (x, y) in self.pairs
    
    def is_reflexive(self) -> bool:
        """æ£€æŸ¥è‡ªåæ€§"""
        for x in self.domain:
            if (x, x) not in self.pairs:
                return False
        return True
    
    def is_symmetric(self) -> bool:
        """æ£€æŸ¥å¯¹ç§°æ€§"""
        for x, y in self.pairs:
            if (y, x) not in self.pairs:
                return False
        return True
    
    def is_transitive(self) -> bool:
        """æ£€æŸ¥ä¼ é€’æ€§"""
        for x, y in self.pairs:
            for z in self.codomain:
                if (y, z) in self.pairs and (x, z) not in self.pairs:
                    return False
        return True
    
    def is_equivalence(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç­‰ä»·å…³ç³»"""
        return self.is_reflexive() and self.is_symmetric() and self.is_transitive()
    
    def equivalence_classes(self) -> List[Set[Any]]:
        """è®¡ç®—ç­‰ä»·ç±»"""
        if not self.is_equivalence():
            return []
        
        classes = []
        processed = set()
        
        for x in self.domain:
            if x not in processed:
                # æ‰¾åˆ°xçš„ç­‰ä»·ç±»
                equivalence_class = {x}
                for y in self.domain:
                    if (x, y) in self.pairs:
                        equivalence_class.add(y)
                        processed.add(y)
                classes.append(equivalence_class)
        
        return classes
    
    def composition(self, other: 'Relation') -> 'Relation':
        """å…³ç³»å¤åˆ"""
        if self.codomain != other.domain:
            raise ValueError("å…³ç³»ä¸èƒ½å¤åˆ")
        
        result = Relation(self.domain, other.codomain)
        
        for x, y in self.pairs:
            for z in other.codomain:
                if (y, z) in other.pairs:
                    result.add_pair(x, z)
        
        return result
    
    def inverse(self) -> 'Relation':
        """å…³ç³»é€†"""
        result = Relation(self.codomain, self.domain)
        
        for x, y in self.pairs:
            result.add_pair(y, x)
        
        return result
    
    def __str__(self) -> str:
        return f"Relation({self.pairs})"

# ç¤ºä¾‹ï¼šå…³ç³»è¿ç®—
domain = {1, 2, 3, 4}
codomain = {1, 2, 3, 4}

# åˆ›å»ºç­‰ä»·å…³ç³»
equivalence = Relation(domain, codomain)
for x in domain:
    equivalence.add_pair(x, x)  # è‡ªåæ€§
    for y in domain:
        if x % 2 == y % 2:  # åŒä½™æ¨¡2
            equivalence.add_pair(x, y)

print(f"å…³ç³»: {equivalence}")
print(f"è‡ªåæ€§: {equivalence.is_reflexive()}")
print(f"å¯¹ç§°æ€§: {equivalence.is_symmetric()}")
print(f"ä¼ é€’æ€§: {equivalence.is_transitive()}")
print(f"ç­‰ä»·å…³ç³»: {equivalence.is_equivalence()}")
print(f"ç­‰ä»·ç±»: {equivalence.equivalence_classes()}")
```

### 3. å‡½æ•°ç†è®º

#### 3.1 å‡½æ•°å®šä¹‰

**å®šä¹‰ 3.1.1** (å‡½æ•°)
å‡½æ•°æ˜¯ç‰¹æ®Šçš„å…³ç³»ï¼Œæ»¡è¶³ï¼š
$$\forall x \in A, \exists! y \in B, (x, y) \in f$$

**å®šä¹‰ 3.1.2** (å‡½æ•°æ€§è´¨)

- å•å°„ï¼š$\forall x_1, x_2 \in A, f(x_1) = f(x_2) \Rightarrow x_1 = x_2$
- æ»¡å°„ï¼š$\forall y \in B, \exists x \in A, f(x) = y$
- åŒå°„ï¼šæ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„

#### 3.2 Pythonå®ç°

```python
from typing import Callable, Any, Dict, List, Set, Optional
from dataclasses import dataclass

@dataclass
class MathematicalFunction:
    """æ•°å­¦å‡½æ•°ç±»"""
    domain: Set[Any]
    codomain: Set[Any]
    mapping: Callable[[Any], Any]
    
    def __init__(self, domain: Set[Any], codomain: Set[Any], mapping: Callable[[Any], Any]):
        self.domain = domain
        self.codomain = codomain
        self.mapping = mapping
    
    def apply(self, x: Any) -> Any:
        """åº”ç”¨å‡½æ•°"""
        if x not in self.domain:
            raise ValueError(f"{x} ä¸åœ¨å®šä¹‰åŸŸä¸­")
        
        result = self.mapping(x)
        if result not in self.codomain:
            raise ValueError(f"å‡½æ•°å€¼ {result} ä¸åœ¨é™ªåŸŸä¸­")
        
        return result
    
    def is_injective(self) -> bool:
        """æ£€æŸ¥å•å°„æ€§"""
        values = set()
        for x in self.domain:
            try:
                y = self.apply(x)
                if y in values:
                    return False
                values.add(y)
            except (ValueError, Exception):
                continue
        return True
    
    def is_surjective(self) -> bool:
        """æ£€æŸ¥æ»¡å°„æ€§"""
        values = set()
        for x in self.domain:
            try:
                y = self.apply(x)
                values.add(y)
            except (ValueError, Exception):
                continue
        
        return values == self.codomain
    
    def is_bijective(self) -> bool:
        """æ£€æŸ¥åŒå°„æ€§"""
        return self.is_injective() and self.is_surjective()
    
    def inverse(self) -> Optional['MathematicalFunction']:
        """æ±‚é€†å‡½æ•°"""
        if not self.is_bijective():
            return None
        
        # æ„é€ é€†æ˜ å°„
        inverse_mapping = {}
        for x in self.domain:
            try:
                y = self.apply(x)
                inverse_mapping[y] = x
            except (ValueError, Exception):
                continue
        
        def inverse_func(y: Any) -> Any:
            if y not in inverse_mapping:
                raise ValueError(f"{y} ä¸åœ¨é€†å‡½æ•°çš„å®šä¹‰åŸŸä¸­")
            return inverse_mapping[y]
        
        return MathematicalFunction(self.codomain, self.domain, inverse_func)
    
    def composition(self, other: 'MathematicalFunction') -> 'MathematicalFunction':
        """å‡½æ•°å¤åˆ"""
        if self.codomain != other.domain:
            raise ValueError("å‡½æ•°ä¸èƒ½å¤åˆ")
        
        def composed_func(x: Any) -> Any:
            return other.apply(self.apply(x))
        
        return MathematicalFunction(self.domain, other.codomain, composed_func)
    
    def __str__(self) -> str:
        return f"Function: {self.domain} â†’ {self.codomain}"

# ç¤ºä¾‹ï¼šå‡½æ•°è¿ç®—
domain = {1, 2, 3, 4}
codomain = {2, 4, 6, 8}

# åˆ›å»ºåŒå°„å‡½æ•° f(x) = 2x
def double_func(x: int) -> int:
    return 2 * x

double_function = MathematicalFunction(domain, codomain, double_func)

print(f"å‡½æ•°: {double_function}")
print(f"f(2) = {double_function.apply(2)}")
print(f"å•å°„: {double_function.is_injective()}")
print(f"æ»¡å°„: {double_function.is_surjective()}")
print(f"åŒå°„: {double_function.is_bijective()}")

# æ±‚é€†å‡½æ•°
inverse_function = double_function.inverse()
if inverse_function:
    print(f"é€†å‡½æ•°: {inverse_function}")
    print(f"fâ»Â¹(4) = {inverse_function.apply(4)}")
```

### 4. å›¾è®ºåŸºç¡€

#### 4.1 å›¾å®šä¹‰

**å®šä¹‰ 4.1.1** (å›¾)
å›¾æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ $G = (V, E)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯é¡¶ç‚¹é›†åˆ
- $E$ æ˜¯è¾¹é›†åˆï¼Œ$E \subseteq V \times V$

**å®šä¹‰ 4.1.2** (å›¾çš„æ€§è´¨)

- æ— å‘å›¾ï¼š$(u, v) \in E \Rightarrow (v, u) \in E$
- æœ‰å‘å›¾ï¼šè¾¹æœ‰æ–¹å‘
- åŠ æƒå›¾ï¼šè¾¹æœ‰æƒé‡

#### 4.2 Pythonå®ç°

```python
from typing import Dict, List, Set, Tuple, Any, Optional
from dataclasses import dataclass
from enum import Enum
import heapq

class GraphType(Enum):
    """å›¾ç±»å‹"""
    UNDIRECTED = "undirected"
    DIRECTED = "directed"
    WEIGHTED = "weighted"

@dataclass
class Edge:
    """è¾¹ç±»"""
    source: Any
    target: Any
    weight: float = 1.0
    
    def __str__(self) -> str:
        if self.weight == 1.0:
            return f"({self.source} â†’ {self.target})"
        else:
            return f"({self.source} â†’ {self.target}, w={self.weight})"

class Graph:
    """å›¾ç±»"""
    
    def __init__(self, graph_type: GraphType = GraphType.UNDIRECTED):
        self.graph_type = graph_type
        self.vertices: Set[Any] = set()
        self.edges: List[Edge] = []
        self.adjacency_list: Dict[Any, List[Edge]] = {}
    
    def add_vertex(self, vertex: Any) -> None:
        """æ·»åŠ é¡¶ç‚¹"""
        self.vertices.add(vertex)
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = []
    
    def add_edge(self, source: Any, target: Any, weight: float = 1.0) -> None:
        """æ·»åŠ è¾¹"""
        edge = Edge(source, target, weight)
        self.edges.append(edge)
        
        # æ·»åŠ åˆ°é‚»æ¥è¡¨
        if source not in self.adjacency_list:
            self.adjacency_list[source] = []
        self.adjacency_list[source].append(edge)
        
        # å¦‚æœæ˜¯æ— å‘å›¾ï¼Œæ·»åŠ åå‘è¾¹
        if self.graph_type == GraphType.UNDIRECTED:
            reverse_edge = Edge(target, source, weight)
            if target not in self.adjacency_list:
                self.adjacency_list[target] = []
            self.adjacency_list[target].append(reverse_edge)
    
    def remove_vertex(self, vertex: Any) -> None:
        """ç§»é™¤é¡¶ç‚¹"""
        if vertex in self.vertices:
            self.vertices.remove(vertex)
            
            # ç§»é™¤ç›¸å…³è¾¹
            self.edges = [edge for edge in self.edges 
                         if edge.source != vertex and edge.target != vertex]
            
            # æ›´æ–°é‚»æ¥è¡¨
            if vertex in self.adjacency_list:
                del self.adjacency_list[vertex]
            
            for edges in self.adjacency_list.values():
                edges[:] = [edge for edge in edges 
                           if edge.source != vertex and edge.target != vertex]
    
    def remove_edge(self, source: Any, target: Any) -> None:
        """ç§»é™¤è¾¹"""
        self.edges = [edge for edge in self.edges 
                     if not (edge.source == source and edge.target == target)]
        
        if source in self.adjacency_list:
            self.adjacency_list[source] = [edge for edge in self.adjacency_list[source]
                                         if edge.target != target]
        
        if self.graph_type == GraphType.UNDIRECTED and target in self.adjacency_list:
            self.adjacency_list[target] = [edge for edge in self.adjacency_list[target]
                                         if edge.source != target]
    
    def get_neighbors(self, vertex: Any) -> List[Any]:
        """è·å–é‚»å±…"""
        if vertex not in self.adjacency_list:
            return []
        
        return [edge.target for edge in self.adjacency_list[vertex]]
    
    def degree(self, vertex: Any) -> int:
        """è®¡ç®—åº¦æ•°"""
        return len(self.get_neighbors(vertex))
    
    def is_connected(self) -> bool:
        """æ£€æŸ¥è¿é€šæ€§"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        visited = set()
        self._dfs(start_vertex, visited)
        
        return len(visited) == len(self.vertices)
    
    def _dfs(self, vertex: Any, visited: Set[Any]) -> None:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited.add(vertex)
        
        for neighbor in self.get_neighbors(vertex):
            if neighbor not in visited:
                self._dfs(neighbor, visited)
    
    def shortest_path(self, source: Any, target: Any) -> Optional[List[Any]]:
        """æœ€çŸ­è·¯å¾„ï¼ˆDijkstraç®—æ³•ï¼‰"""
        if source not in self.vertices or target not in self.vertices:
            return None
        
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[source] = 0
        
        previous = {}
        pq = [(0, source)]
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_distance > distances[current_vertex]:
                continue
            
            for edge in self.adjacency_list.get(current_vertex, []):
                neighbor = edge.target
                distance = current_distance + edge.weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heapq.heappush(pq, (distance, neighbor))
        
        # é‡å»ºè·¯å¾„
        if distances[target] == float('infinity'):
            return None
        
        path = []
        current = target
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        return path[::-1]
    
    def __str__(self) -> str:
        return f"Graph({self.graph_type.value}, V={len(self.vertices)}, E={len(self.edges)})"

# ç¤ºä¾‹ï¼šå›¾è¿ç®—
graph = Graph(GraphType.UNDIRECTED)

# æ·»åŠ é¡¶ç‚¹
for i in range(5):
    graph.add_vertex(i)

# æ·»åŠ è¾¹
edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4)]
for source, target in edges:
    graph.add_edge(source, target)

print(f"å›¾: {graph}")
print(f"é¡¶ç‚¹: {graph.vertices}")
print(f"è¾¹æ•°: {len(graph.edges)}")
print(f"è¿é€šæ€§: {graph.is_connected()}")

# æœ€çŸ­è·¯å¾„
path = graph.shortest_path(0, 4)
print(f"ä»0åˆ°4çš„æœ€çŸ­è·¯å¾„: {path}")

# åº¦æ•°
for vertex in graph.vertices:
    print(f"é¡¶ç‚¹{vertex}çš„åº¦æ•°: {graph.degree(vertex)}")
```

### 5. ç»„åˆæ•°å­¦

#### 5.1 æ’åˆ—ç»„åˆ

**å®šä¹‰ 5.1.1** (æ’åˆ—)
ä» $n$ ä¸ªå…ƒç´ ä¸­å– $r$ ä¸ªå…ƒç´ çš„æ’åˆ—æ•°ï¼š
$$P(n, r) = \frac{n!}{(n-r)!}$$

**å®šä¹‰ 5.1.2** (ç»„åˆ)
ä» $n$ ä¸ªå…ƒç´ ä¸­å– $r$ ä¸ªå…ƒç´ çš„ç»„åˆæ•°ï¼š
$$C(n, r) = \binom{n}{r} = \frac{n!}{r!(n-r)!}$$

#### 5.2 Pythonå®ç°

```python
import math
from typing import List, Set, Tuple, Any
from itertools import permutations, combinations

class Combinatorics:
    """ç»„åˆæ•°å­¦ç±»"""
    
    @staticmethod
    def factorial(n: int) -> int:
        """é˜¶ä¹˜"""
        if n < 0:
            raise ValueError("é˜¶ä¹˜ä¸èƒ½ç”¨äºè´Ÿæ•°")
        if n == 0 or n == 1:
            return 1
        return n * Combinatorics.factorial(n - 1)
    
    @staticmethod
    def permutation(n: int, r: int) -> int:
        """æ’åˆ—æ•°"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // Combinatorics.factorial(n - r)
    
    @staticmethod
    def combination(n: int, r: int) -> int:
        """ç»„åˆæ•°"""
        if r > n:
            return 0
        return Combinatorics.factorial(n) // (Combinatorics.factorial(r) * Combinatorics.factorial(n - r))
    
    @staticmethod
    def generate_permutations(elements: List[Any], r: int = None) -> List[Tuple[Any, ...]]:
        """ç”Ÿæˆæ’åˆ—"""
        if r is None:
            r = len(elements)
        return list(permutations(elements, r))
    
    @staticmethod
    def generate_combinations(elements: List[Any], r: int) -> List[Tuple[Any, ...]]:
        """ç”Ÿæˆç»„åˆ"""
        return list(combinations(elements, r))
    
    @staticmethod
    def catalan_number(n: int) -> int:
        """å¡ç‰¹å…°æ•°"""
        if n <= 0:
            return 1
        return Combinatorics.combination(2*n, n) // (n + 1)
    
    @staticmethod
    def fibonacci_number(n: int) -> int:
        """æ–æ³¢é‚£å¥‘æ•°"""
        if n <= 0:
            return 0
        if n == 1:
            return 1
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    
    @staticmethod
    def stirling_number_second(n: int, k: int) -> int:
        """ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°"""
        if k == 0:
            return 1 if n == 0 else 0
        if k == 1:
            return 1
        if k == n:
            return 1
        if k > n:
            return 0
        
        return k * Combinatorics.stirling_number_second(n - 1, k) + \
               Combinatorics.stirling_number_second(n - 1, k - 1)

# ç¤ºä¾‹ï¼šç»„åˆæ•°å­¦
combinatorics = Combinatorics()

# åŸºæœ¬è®¡ç®—
n, r = 5, 3
print(f"P({n}, {r}) = {combinatorics.permutation(n, r)}")
print(f"C({n}, {r}) = {combinatorics.combination(n, r)}")

# ç”Ÿæˆæ’åˆ—å’Œç»„åˆ
elements = ['A', 'B', 'C']
permutations = combinatorics.generate_permutations(elements, 2)
combinations = combinatorics.generate_combinations(elements, 2)

print(f"å…ƒç´ : {elements}")
print(f"æ’åˆ—(2): {permutations}")
print(f"ç»„åˆ(2): {combinations}")

# ç‰¹æ®Šæ•°åˆ—
print(f"å¡ç‰¹å…°æ•°C(4) = {combinatorics.catalan_number(4)}")
print(f"æ–æ³¢é‚£å¥‘æ•°F(10) = {combinatorics.fibonacci_number(10)}")
print(f"æ–¯ç‰¹æ—æ•°S(4, 2) = {combinatorics.stirling_number_second(4, 2)}")
```

## ğŸ“š ç†è®ºè¯æ˜

### 1. é›†åˆè¿ç®—æ€§è´¨å®šç†

**å®šç† 1.1** (å¾·æ‘©æ ¹å¾‹)
å¯¹äºä»»æ„é›†åˆ $A, B$ å’Œå…¨é›† $U$ï¼š
$$(A \cup B)^c = A^c \cap B^c$$
$$(A \cap B)^c = A^c \cup B^c$$

**è¯æ˜**ï¼š

1. è®¾ $x \in (A \cup B)^c$
2. åˆ™ $x \notin A \cup B$
3. å› æ­¤ $x \notin A$ ä¸” $x \notin B$
4. æ‰€ä»¥ $x \in A^c \cap B^c$
5. åä¹‹äº¦ç„¶

### 2. å‡½æ•°å¤åˆç»“åˆå¾‹

**å®šç† 2.1** (å‡½æ•°å¤åˆç»“åˆå¾‹)
å¯¹äºå‡½æ•° $f: A \rightarrow B$, $g: B \rightarrow C$, $h: C \rightarrow D$ï¼š
$$(h \circ g) \circ f = h \circ (g \circ f)$$

**è¯æ˜**ï¼š

1. å¯¹äºä»»æ„ $x \in A$
2. $((h \circ g) \circ f)(x) = (h \circ g)(f(x)) = h(g(f(x)))$
3. $(h \circ (g \circ f))(x) = h((g \circ f)(x)) = h(g(f(x)))$
4. å› æ­¤ä¸¤è€…ç›¸ç­‰

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [é€»è¾‘å­¦åŸºç¡€](../02-é€»è¾‘å­¦/00-é€»è¾‘å­¦åŸºç¡€.md)
- [é›†åˆè®ºåŸºç¡€](../03-é›†åˆè®º/00-é›†åˆè®ºåŸºç¡€.md)
- [å›¾è®ºåŸºç¡€](../04-å›¾è®º/00-å›¾è®ºåŸºç¡€.md)

## ğŸ“– å‚è€ƒæ–‡çŒ®

1. Rosen, K. H. (2018). Discrete Mathematics and Its Applications
2. Grimaldi, R. P. (2017). Discrete and Combinatorial Mathematics
3. Biggs, N. L. (2002). Discrete Mathematics
4. Epp, S. S. (2010). Discrete Mathematics with Applications

---

*æ•°å­¦åŸºç¡€ä¸ºè½¯ä»¶å·¥ç¨‹æä¾›äº†ä¸¥æ ¼çš„é€»è¾‘æ¡†æ¶å’Œç²¾ç¡®çš„åˆ†æå·¥å…·ï¼Œæ˜¯æ„å»ºå¯é è½¯ä»¶ç³»ç»Ÿçš„é‡è¦åŸºç¡€ã€‚*
