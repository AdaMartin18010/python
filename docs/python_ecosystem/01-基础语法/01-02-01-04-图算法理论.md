# 02-01-04 å›¾ç®—æ³•ç†è®º

## ğŸ“‹ æ¦‚è¿°

å›¾ç®—æ³•æ˜¯å¤„ç†å›¾ç»“æ„æ•°æ®çš„ç®—æ³•ï¼Œå¹¿æ³›åº”ç”¨äºç½‘ç»œåˆ†æã€è·¯å¾„è§„åˆ’ã€ç¤¾äº¤ç½‘ç»œç­‰é¢†åŸŸã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰å›¾ç®—æ³•ï¼Œåˆ†æå„ç§å›¾ç®—æ³•çš„ç†è®ºæ€§è´¨ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 å›¾çš„åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1** (å›¾)
å›¾æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ï¼š
$$G = (V, E)$$
å…¶ä¸­ï¼š

- $V$ ä¸ºé¡¶ç‚¹é›†åˆï¼š$V = \{v_1, v_2, ..., v_n\}$
- $E$ ä¸ºè¾¹é›†åˆï¼š$E \subseteq V \times V$

**å®šä¹‰ 1.2** (æœ‰å‘å›¾)
æœ‰å‘å›¾ $G = (V, E)$ ä¸­ï¼Œè¾¹æ˜¯æœ‰åºå¯¹ï¼š
$$E \subseteq \{(u, v) \mid u, v \in V, u \neq v\}$$

**å®šä¹‰ 1.3** (æ— å‘å›¾)
æ— å‘å›¾ $G = (V, E)$ ä¸­ï¼Œè¾¹æ˜¯æ— åºå¯¹ï¼š
$$E \subseteq \{\{u, v\} \mid u, v \in V, u \neq v\}$$

**å®šä¹‰ 1.4** (åŠ æƒå›¾)
åŠ æƒå›¾æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$G = (V, E, w)$$
å…¶ä¸­ $w: E \rightarrow \mathbb{R}$ ä¸ºæƒé‡å‡½æ•°ã€‚

### 1.2 å›¾çš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.5** (åº¦)
é¡¶ç‚¹ $v$ çš„åº¦å®šä¹‰ä¸ºï¼š
$$deg(v) = |\{e \in E \mid v \in e\}|$$

**å®šä¹‰ 1.6** (è·¯å¾„)
ä» $u$ åˆ° $v$ çš„è·¯å¾„æ˜¯é¡¶ç‚¹åºåˆ—ï¼š
$$P = (v_0, v_1, ..., v_k)$$
å…¶ä¸­ $v_0 = u, v_k = v$ï¼Œä¸” $(v_i, v_{i+1}) \in E$ã€‚

**å®šä¹‰ 1.7** (è¿é€šæ€§)
å›¾ $G$ æ˜¯è¿é€šçš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall u, v \in V: \exists P \text{ ä» } u \text{ åˆ° } v$$

## 2. Pythonå®ç°

### 2.1 å›¾çš„åŸºç¡€å®ç°

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Dict, List, Set, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import heapq
from collections import defaultdict, deque

T = TypeVar('T')

class GraphType(Enum):
    """å›¾ç±»å‹"""
    DIRECTED = "directed"
    UNDIRECTED = "undirected"
    WEIGHTED = "weighted"

@dataclass
class Edge(Generic[T]):
    """è¾¹"""
    source: T
    target: T
    weight: float = 1.0
    
    def __hash__(self):
        return hash((self.source, self.target, self.weight))

class Graph(Generic[T]):
    """å›¾æ•°æ®ç»“æ„"""
    
    def __init__(self, graph_type: GraphType = GraphType.UNDIRECTED):
        self.graph_type = graph_type
        self.vertices: Set[T] = set()
        self.edges: Dict[T, List[Edge[T]]] = defaultdict(list)
        self.edge_weights: Dict[Tuple[T, T], float] = {}
    
    def add_vertex(self, vertex: T) -> None:
        """æ·»åŠ é¡¶ç‚¹"""
        self.vertices.add(vertex)
    
    def add_edge(self, source: T, target: T, weight: float = 1.0) -> None:
        """æ·»åŠ è¾¹"""
        self.add_vertex(source)
        self.add_vertex(target)
        
        edge = Edge(source, target, weight)
        self.edges[source].append(edge)
        self.edge_weights[(source, target)] = weight
        
        if self.graph_type == GraphType.UNDIRECTED:
            reverse_edge = Edge(target, source, weight)
            self.edges[target].append(reverse_edge)
            self.edge_weights[(target, source)] = weight
    
    def remove_vertex(self, vertex: T) -> None:
        """åˆ é™¤é¡¶ç‚¹"""
        if vertex in self.vertices:
            self.vertices.remove(vertex)
            # åˆ é™¤æ‰€æœ‰ç›¸å…³è¾¹
            self.edges.pop(vertex, None)
            for edges in self.edges.values():
                edges[:] = [e for e in edges if e.target != vertex]
    
    def remove_edge(self, source: T, target: T) -> None:
        """åˆ é™¤è¾¹"""
        if source in self.edges:
            self.edges[source] = [e for e in self.edges[source] if e.target != target]
        if self.graph_type == GraphType.UNDIRECTED and target in self.edges:
            self.edges[target] = [e for e in self.edges[target] if e.target != source]
    
    def get_neighbors(self, vertex: T) -> List[T]:
        """è·å–é‚»å±…é¡¶ç‚¹"""
        return [edge.target for edge in self.edges.get(vertex, [])]
    
    def get_edge_weight(self, source: T, target: T) -> Optional[float]:
        """è·å–è¾¹æƒé‡"""
        return self.edge_weights.get((source, target))
    
    def get_degree(self, vertex: T) -> int:
        """è·å–é¡¶ç‚¹åº¦æ•°"""
        return len(self.edges.get(vertex, []))
    
    def is_connected(self) -> bool:
        """æ£€æŸ¥å›¾æ˜¯å¦è¿é€š"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        visited = set()
        self._dfs_connected(start_vertex, visited)
        return len(visited) == len(self.vertices)
    
    def _dfs_connected(self, vertex: T, visited: Set[T]) -> None:
        """DFSæ£€æŸ¥è¿é€šæ€§"""
        visited.add(vertex)
        for neighbor in self.get_neighbors(vertex):
            if neighbor not in visited:
                self._dfs_connected(neighbor, visited)
    
    def __str__(self) -> str:
        result = f"Graph({self.graph_type.value})\n"
        result += f"Vertices: {len(self.vertices)}\n"
        result += f"Edges: {sum(len(edges) for edges in self.edges.values())}\n"
        return result
```

### 2.2 å›¾çš„è¡¨ç¤ºæ–¹æ³•

```python
class AdjacencyMatrix(Generic[T]):
    """é‚»æ¥çŸ©é˜µè¡¨ç¤º"""
    
    def __init__(self, vertices: List[T]):
        self.vertices = vertices
        self.vertex_to_index = {v: i for i, v in enumerate(vertices)}
        self.matrix = [[0] * len(vertices) for _ in range(len(vertices))]
    
    def add_edge(self, source: T, target: T, weight: float = 1.0) -> None:
        """æ·»åŠ è¾¹"""
        if source in self.vertex_to_index and target in self.vertex_to_index:
            i = self.vertex_to_index[source]
            j = self.vertex_to_index[target]
            self.matrix[i][j] = weight
    
    def get_edge_weight(self, source: T, target: T) -> float:
        """è·å–è¾¹æƒé‡"""
        if source in self.vertex_to_index and target in self.vertex_to_index:
            i = self.vertex_to_index[source]
            j = self.vertex_to_index[target]
            return self.matrix[i][j]
        return 0
    
    def get_neighbors(self, vertex: T) -> List[Tuple[T, float]]:
        """è·å–é‚»å±…"""
        if vertex not in self.vertex_to_index:
            return []
        
        i = self.vertex_to_index[vertex]
        neighbors = []
        for j, weight in enumerate(self.matrix[i]):
            if weight > 0:
                neighbors.append((self.vertices[j], weight))
        return neighbors

class AdjacencyList(Generic[T]):
    """é‚»æ¥è¡¨è¡¨ç¤º"""
    
    def __init__(self):
        self.adj_list: Dict[T, List[Tuple[T, float]]] = defaultdict(list)
    
    def add_edge(self, source: T, target: T, weight: float = 1.0) -> None:
        """æ·»åŠ è¾¹"""
        self.adj_list[source].append((target, weight))
    
    def get_neighbors(self, vertex: T) -> List[Tuple[T, float]]:
        """è·å–é‚»å±…"""
        return self.adj_list.get(vertex, [])
    
    def get_vertices(self) -> Set[T]:
        """è·å–æ‰€æœ‰é¡¶ç‚¹"""
        vertices = set()
        for source in self.adj_list:
            vertices.add(source)
            for target, _ in self.adj_list[source]:
                vertices.add(target)
        return vertices
```

### 2.3 å›¾éå†ç®—æ³•

#### 2.3.1 æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)

```python
class DepthFirstSearch(Algorithm[Graph[T], List[T]]):
    """æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Depth First Search")
        self.visited: Set[T] = set()
        self.traversal_order: List[T] = []
    
    def solve(self, graph: Graph[T]) -> List[T]:
        """æ‰§è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢"""
        self.visited.clear()
        self.traversal_order.clear()
        
        # ä»æ¯ä¸ªæœªè®¿é—®çš„é¡¶ç‚¹å¼€å§‹DFS
        for vertex in graph.vertices:
            if vertex not in self.visited:
                self._dfs(graph, vertex)
        
        return self.traversal_order
    
    def _dfs(self, graph: Graph[T], vertex: T) -> None:
        """é€’å½’æ·±åº¦ä¼˜å…ˆæœç´¢"""
        self.visited.add(vertex)
        self.traversal_order.append(vertex)
        
        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in self.visited:
                self._dfs(graph, neighbor)
    
    def is_correct(self, graph: Graph[T], output: List[T]) -> bool:
        """éªŒè¯DFSæ­£ç¡®æ€§"""
        # æ£€æŸ¥æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®
        if set(output) != graph.vertices:
            return False
        
        # æ£€æŸ¥æ²¡æœ‰é‡å¤è®¿é—®
        if len(output) != len(set(output)):
            return False
        
        return True
    
    def _analyze_time_complexity(self) -> str:
        return "O(V + E) å…¶ä¸­Væ˜¯é¡¶ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°"
    
    def _analyze_space_complexity(self) -> str:
        return "O(V) - é€’å½’æ ˆæ·±åº¦"
    
    def _analyze_best_case(self) -> str:
        return "O(V) - æ²¡æœ‰è¾¹çš„æƒ…å†µ"
    
    def _analyze_worst_case(self) -> str:
        return "O(V + E) - éœ€è¦è®¿é—®æ‰€æœ‰é¡¶ç‚¹å’Œè¾¹"
    
    def _analyze_average_case(self) -> str:
        return "O(V + E) - å¹³å‡æƒ…å†µ"
```

#### 2.3.2 å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)

```python
class BreadthFirstSearch(Algorithm[Graph[T], List[T]]):
    """å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Breadth First Search")
        self.visited: Set[T] = set()
        self.traversal_order: List[T] = []
    
    def solve(self, graph: Graph[T]) -> List[T]:
        """æ‰§è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢"""
        self.visited.clear()
        self.traversal_order.clear()
        
        # ä»æ¯ä¸ªæœªè®¿é—®çš„é¡¶ç‚¹å¼€å§‹BFS
        for vertex in graph.vertices:
            if vertex not in self.visited:
                self._bfs(graph, vertex)
        
        return self.traversal_order
    
    def _bfs(self, graph: Graph[T], start_vertex: T) -> None:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
        queue = deque([start_vertex])
        self.visited.add(start_vertex)
        
        while queue:
            vertex = queue.popleft()
            self.traversal_order.append(vertex)
            
            for neighbor in graph.get_neighbors(vertex):
                if neighbor not in self.visited:
                    self.visited.add(neighbor)
                    queue.append(neighbor)
    
    def is_correct(self, graph: Graph[T], output: List[T]) -> bool:
        """éªŒè¯BFSæ­£ç¡®æ€§"""
        # æ£€æŸ¥æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®
        if set(output) != graph.vertices:
            return False
        
        # æ£€æŸ¥æ²¡æœ‰é‡å¤è®¿é—®
        if len(output) != len(set(output)):
            return False
        
        return True
    
    def _analyze_time_complexity(self) -> str:
        return "O(V + E) å…¶ä¸­Væ˜¯é¡¶ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°"
    
    def _analyze_space_complexity(self) -> str:
        return "O(V) - é˜Ÿåˆ—å¤§å°"
    
    def _analyze_best_case(self) -> str:
        return "O(V) - æ²¡æœ‰è¾¹çš„æƒ…å†µ"
    
    def _analyze_worst_case(self) -> str:
        return "O(V + E) - éœ€è¦è®¿é—®æ‰€æœ‰é¡¶ç‚¹å’Œè¾¹"
    
    def _analyze_average_case(self) -> str:
        return "O(V + E) - å¹³å‡æƒ…å†µ"
```

### 2.4 æœ€çŸ­è·¯å¾„ç®—æ³•

#### 2.4.1 Dijkstraç®—æ³•

```python
@dataclass
class DijkstraNode:
    """Dijkstraç®—æ³•èŠ‚ç‚¹"""
    vertex: T
    distance: float
    previous: Optional[T] = None
    
    def __lt__(self, other):
        return self.distance < other.distance

class DijkstraAlgorithm(Algorithm[Graph[T], Dict[T, float]]):
    """Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•"""
    
    def __init__(self, source: T):
        super().__init__("Dijkstra Algorithm")
        self.source = source
    
    def solve(self, graph: Graph[T]) -> Dict[T, float]:
        """æ‰§è¡ŒDijkstraç®—æ³•"""
        # åˆå§‹åŒ–è·ç¦»
        distances = {vertex: float('inf') for vertex in graph.vertices}
        distances[self.source] = 0
        
        # ä¼˜å…ˆé˜Ÿåˆ—
        pq = [DijkstraNode(self.source, 0)]
        visited = set()
        
        while pq:
            current = heapq.heappop(pq)
            
            if current.vertex in visited:
                continue
            
            visited.add(current.vertex)
            
            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor in graph.get_neighbors(current.vertex):
                if neighbor not in visited:
                    weight = graph.get_edge_weight(current.vertex, neighbor) or 1.0
                    new_distance = current.distance + weight
                    
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        heapq.heappush(pq, DijkstraNode(neighbor, new_distance))
        
        return distances
    
    def is_correct(self, graph: Graph[T], output: Dict[T, float]) -> bool:
        """éªŒè¯Dijkstraç®—æ³•æ­£ç¡®æ€§"""
        # æ£€æŸ¥æºç‚¹è·ç¦»ä¸º0
        if output.get(self.source, float('inf')) != 0:
            return False
        
        # æ£€æŸ¥æ‰€æœ‰è·ç¦»éƒ½æ˜¯éè´Ÿçš„
        for distance in output.values():
            if distance < 0:
                return False
        
        return True
    
    def _analyze_time_complexity(self) -> str:
        return "O((V + E) log V) ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—"
    
    def _analyze_space_complexity(self) -> str:
        return "O(V) - ä¼˜å…ˆé˜Ÿåˆ—å’Œè·ç¦»æ•°ç»„"
    
    def _analyze_best_case(self) -> str:
        return "O(V log V) - ç¨€ç–å›¾"
    
    def _analyze_worst_case(self) -> str:
        return "O((V + E) log V) - ç¨ å¯†å›¾"
    
    def _analyze_average_case(self) -> str:
        return "O((V + E) log V) - å¹³å‡æƒ…å†µ"
```

#### 2.4.2 Floyd-Warshallç®—æ³•

```python
class FloydWarshallAlgorithm(Algorithm[Graph[T], Dict[Tuple[T, T], float]]):
    """Floyd-Warshallå…¨æºæœ€çŸ­è·¯å¾„ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Floyd-Warshall Algorithm")
    
    def solve(self, graph: Graph[T]) -> Dict[Tuple[T, T], float]:
        """æ‰§è¡ŒFloyd-Warshallç®—æ³•"""
        vertices = list(graph.vertices)
        n = len(vertices)
        
        # åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
        distances = {}
        for i, u in enumerate(vertices):
            for j, v in enumerate(vertices):
                if u == v:
                    distances[(u, v)] = 0
                else:
                    weight = graph.get_edge_weight(u, v)
                    distances[(u, v)] = weight if weight is not None else float('inf')
        
        # Floyd-Warshallæ ¸å¿ƒç®—æ³•
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    u, v, w = vertices[i], vertices[j], vertices[k]
                    if (distances[(u, w)] + distances[(w, v)] < distances[(u, v)]):
                        distances[(u, v)] = distances[(u, w)] + distances[(w, v)]
        
        return distances
    
    def is_correct(self, graph: Graph[T], output: Dict[Tuple[T, T], float]) -> bool:
        """éªŒè¯Floyd-Warshallç®—æ³•æ­£ç¡®æ€§"""
        # æ£€æŸ¥å¯¹è§’çº¿ä¸º0
        for vertex in graph.vertices:
            if output.get((vertex, vertex), float('inf')) != 0:
                return False
        
        # æ£€æŸ¥æ‰€æœ‰è·ç¦»éƒ½æ˜¯éè´Ÿçš„
        for distance in output.values():
            if distance < 0:
                return False
        
        return True
    
    def _analyze_time_complexity(self) -> str:
        return "O(VÂ³) - ä¸‰é‡åµŒå¥—å¾ªç¯"
    
    def _analyze_space_complexity(self) -> str:
        return "O(VÂ²) - è·ç¦»çŸ©é˜µ"
    
    def _analyze_best_case(self) -> str:
        return "O(VÂ³) - æ€»æ˜¯éœ€è¦ä¸‰é‡å¾ªç¯"
    
    def _analyze_worst_case(self) -> str:
        return "O(VÂ³) - æ€»æ˜¯éœ€è¦ä¸‰é‡å¾ªç¯"
    
    def _analyze_average_case(self) -> str:
        return "O(VÂ³) - å¹³å‡æƒ…å†µ"
```

### 2.5 æœ€å°ç”Ÿæˆæ ‘ç®—æ³•

#### 2.5.1 Kruskalç®—æ³•

```python
@dataclass
class Edge(Generic[T]):
    """è¾¹"""
    source: T
    target: T
    weight: float
    
    def __lt__(self, other):
        return self.weight < other.weight

class UnionFind(Generic[T]):
    """å¹¶æŸ¥é›†"""
    
    def __init__(self):
        self.parent: Dict[T, T] = {}
        self.rank: Dict[T, int] = {}
    
    def make_set(self, x: T) -> None:
        """åˆ›å»ºé›†åˆ"""
        if x not in self.parent:
            self.parent[x] = x
            self.rank[x] = 0
    
    def find(self, x: T) -> T:
        """æŸ¥æ‰¾æ ¹èŠ‚ç‚¹"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x: T, y: T) -> None:
        """åˆå¹¶é›†åˆ"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x != root_y:
            if self.rank[root_x] < self.rank[root_y]:
                root_x, root_y = root_y, root_x
            
            self.parent[root_y] = root_x
            if self.rank[root_x] == self.rank[root_y]:
                self.rank[root_x] += 1

class KruskalAlgorithm(Algorithm[Graph[T], List[Edge[T]]]):
    """Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Kruskal Algorithm")
    
    def solve(self, graph: Graph[T]) -> List[Edge[T]]:
        """æ‰§è¡ŒKruskalç®—æ³•"""
        # æ”¶é›†æ‰€æœ‰è¾¹
        edges = []
        for source in graph.vertices:
            for edge in graph.edges[source]:
                if graph.graph_type == GraphType.UNDIRECTED:
                    # é¿å…é‡å¤è¾¹
                    if edge.source < edge.target:
                        edges.append(edge)
                else:
                    edges.append(edge)
        
        # æŒ‰æƒé‡æ’åº
        edges.sort()
        
        # åˆå§‹åŒ–å¹¶æŸ¥é›†
        uf = UnionFind[T]()
        for vertex in graph.vertices:
            uf.make_set(vertex)
        
        # Kruskalç®—æ³•
        mst = []
        for edge in edges:
            if uf.find(edge.source) != uf.find(edge.target):
                mst.append(edge)
                uf.union(edge.source, edge.target)
        
        return mst
    
    def is_correct(self, graph: Graph[T], output: List[Edge[T]]) -> bool:
        """éªŒè¯Kruskalç®—æ³•æ­£ç¡®æ€§"""
        if not graph.vertices:
            return len(output) == 0
        
        # æ£€æŸ¥è¾¹æ•°
        expected_edges = len(graph.vertices) - 1
        if len(output) != expected_edges:
            return False
        
        # æ£€æŸ¥è¿é€šæ€§
        mst_graph = Graph(graph.graph_type)
        for edge in output:
            mst_graph.add_edge(edge.source, edge.target, edge.weight)
        
        return mst_graph.is_connected()
    
    def _analyze_time_complexity(self) -> str:
        return "O(E log E) å…¶ä¸­Eæ˜¯è¾¹æ•°"
    
    def _analyze_space_complexity(self) -> str:
        return "O(V + E) - å¹¶æŸ¥é›†å’Œè¾¹åˆ—è¡¨"
    
    def _analyze_best_case(self) -> str:
        return "O(E log E) - æ€»æ˜¯éœ€è¦æ’åº"
    
    def _analyze_worst_case(self) -> str:
        return "O(E log E) - æ€»æ˜¯éœ€è¦æ’åº"
    
    def _analyze_average_case(self) -> str:
        return "O(E log E) - å¹³å‡æƒ…å†µ"
```

#### 2.5.2 Primç®—æ³•

```python
class PrimAlgorithm(Algorithm[Graph[T], List[Edge[T]]]):
    """Primæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    
    def __init__(self):
        super().__init__("Prim Algorithm")
    
    def solve(self, graph: Graph[T]) -> List[Edge[T]]:
        """æ‰§è¡ŒPrimç®—æ³•"""
        if not graph.vertices:
            return []
        
        # é€‰æ‹©èµ·å§‹é¡¶ç‚¹
        start_vertex = next(iter(graph.vertices))
        
        # åˆå§‹åŒ–
        mst = []
        visited = {start_vertex}
        edges = []
        
        # æ·»åŠ èµ·å§‹é¡¶ç‚¹çš„æ‰€æœ‰è¾¹
        for edge in graph.edges[start_vertex]:
            heapq.heappush(edges, edge)
        
        # Primç®—æ³•
        while edges and len(visited) < len(graph.vertices):
            edge = heapq.heappop(edges)
            
            # æ‰¾åˆ°æœªè®¿é—®çš„é¡¶ç‚¹
            if edge.source in visited and edge.target not in visited:
                next_vertex = edge.target
            elif edge.target in visited and edge.source not in visited:
                next_vertex = edge.source
            else:
                continue
            
            visited.add(next_vertex)
            mst.append(edge)
            
            # æ·»åŠ æ–°é¡¶ç‚¹çš„è¾¹
            for new_edge in graph.edges[next_vertex]:
                if (new_edge.target not in visited or 
                    new_edge.source not in visited):
                    heapq.heappush(edges, new_edge)
        
        return mst
    
    def is_correct(self, graph: Graph[T], output: List[Edge[T]]) -> bool:
        """éªŒè¯Primç®—æ³•æ­£ç¡®æ€§"""
        if not graph.vertices:
            return len(output) == 0
        
        # æ£€æŸ¥è¾¹æ•°
        expected_edges = len(graph.vertices) - 1
        if len(output) != expected_edges:
            return False
        
        # æ£€æŸ¥è¿é€šæ€§
        mst_graph = Graph(graph.graph_type)
        for edge in output:
            mst_graph.add_edge(edge.source, edge.target, edge.weight)
        
        return mst_graph.is_connected()
    
    def _analyze_time_complexity(self) -> str:
        return "O(E log V) ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—"
    
    def _analyze_space_complexity(self) -> str:
        return "O(V + E) - ä¼˜å…ˆé˜Ÿåˆ—å’Œè®¿é—®é›†åˆ"
    
    def _analyze_best_case(self) -> str:
        return "O(E log V) - ç¨€ç–å›¾"
    
    def _analyze_worst_case(self) -> str:
        return "O(E log V) - ç¨ å¯†å›¾"
    
    def _analyze_average_case(self) -> str:
        return "O(E log V) - å¹³å‡æƒ…å†µ"
```

### 2.6 ç½‘ç»œæµç®—æ³•

#### 2.6.1 Ford-Fulkersonç®—æ³•

```python
class FordFulkersonAlgorithm(Algorithm[Graph[T], float]):
    """Ford-Fulkersonæœ€å¤§æµç®—æ³•"""
    
    def __init__(self, source: T, sink: T):
        super().__init__("Ford-Fulkerson Algorithm")
        self.source = source
        self.sink = sink
    
    def solve(self, graph: Graph[T]) -> float:
        """æ‰§è¡ŒFord-Fulkersonç®—æ³•"""
        # åˆ›å»ºæ®‹å·®å›¾
        residual_graph = self._create_residual_graph(graph)
        
        max_flow = 0
        
        # å¯»æ‰¾å¢å¹¿è·¯å¾„
        while True:
            path = self._find_augmenting_path(residual_graph)
            if not path:
                break
            
            # è®¡ç®—è·¯å¾„ä¸Šçš„æœ€å°å®¹é‡
            min_capacity = float('inf')
            for i in range(len(path) - 1):
                u, v = path[i], path[i + 1]
                capacity = residual_graph.get_edge_weight(u, v) or 0
                min_capacity = min(min_capacity, capacity)
            
            # æ›´æ–°æ®‹å·®å›¾
            for i in range(len(path) - 1):
                u, v = path[i], path[i + 1]
                # å‡å°‘æ­£å‘è¾¹å®¹é‡
                current_capacity = residual_graph.get_edge_weight(u, v) or 0
                residual_graph.remove_edge(u, v)
                if current_capacity - min_capacity > 0:
                    residual_graph.add_edge(u, v, current_capacity - min_capacity)
                
                # å¢åŠ åå‘è¾¹å®¹é‡
                reverse_capacity = residual_graph.get_edge_weight(v, u) or 0
                residual_graph.remove_edge(v, u)
                residual_graph.add_edge(v, u, reverse_capacity + min_capacity)
            
            max_flow += min_capacity
        
        return max_flow
    
    def _create_residual_graph(self, graph: Graph[T]) -> Graph[T]:
        """åˆ›å»ºæ®‹å·®å›¾"""
        residual = Graph(GraphType.DIRECTED)
        
        for vertex in graph.vertices:
            residual.add_vertex(vertex)
        
        for source in graph.vertices:
            for edge in graph.edges[source]:
                weight = edge.weight
                residual.add_edge(edge.source, edge.target, weight)
                residual.add_edge(edge.target, edge.source, 0)
        
        return residual
    
    def _find_augmenting_path(self, graph: Graph[T]) -> List[T]:
        """å¯»æ‰¾å¢å¹¿è·¯å¾„ï¼ˆä½¿ç”¨BFSï¼‰"""
        if self.source not in graph.vertices or self.sink not in graph.vertices:
            return []
        
        queue = deque([(self.source, [self.source])])
        visited = {self.source}
        
        while queue:
            current, path = queue.popleft()
            
            if current == self.sink:
                return path
            
            for neighbor in graph.get_neighbors(current):
                if (neighbor not in visited and 
                    graph.get_edge_weight(current, neighbor) > 0):
                    visited.add(neighbor)
                    new_path = path + [neighbor]
                    queue.append((neighbor, new_path))
        
        return []
    
    def is_correct(self, graph: Graph[T], output: float) -> bool:
        """éªŒè¯Ford-Fulkersonç®—æ³•æ­£ç¡®æ€§"""
        # æ£€æŸ¥æµé‡éè´Ÿ
        if output < 0:
            return False
        
        # æ£€æŸ¥æµé‡ä¸è¶…è¿‡æºç‚¹å‡ºè¾¹å®¹é‡æ€»å’Œ
        source_capacity = sum(
            edge.weight for edge in graph.edges.get(self.source, [])
        )
        if output > source_capacity:
            return False
        
        return True
    
    def _analyze_time_complexity(self) -> str:
        return "O(VEÂ²) ä½¿ç”¨BFSå¯»æ‰¾å¢å¹¿è·¯å¾„"
    
    def _analyze_space_complexity(self) -> str:
        return "O(VÂ²) - æ®‹å·®å›¾"
    
    def _analyze_best_case(self) -> str:
        return "O(E) - ç®€å•è·¯å¾„"
    
    def _analyze_worst_case(self) -> str:
        return "O(VEÂ²) - å¤æ‚ç½‘ç»œ"
    
    def _analyze_average_case(self) -> str:
        return "O(VEÂ²) - å¹³å‡æƒ…å†µ"
```

## 3. ç†è®ºè¯æ˜

### 3.1 Dijkstraç®—æ³•æ­£ç¡®æ€§

**å®šç† 3.1** (Dijkstraç®—æ³•æ­£ç¡®æ€§)
Dijkstraç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°ä»æºç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

**è¯æ˜**:

1. **åˆå§‹åŒ–**: æºç‚¹è·ç¦»ä¸º0ï¼Œå…¶ä»–é¡¶ç‚¹è·ç¦»ä¸ºâˆ âœ“
2. **ä¿æŒæ€§**: æ¯æ¬¡é€‰æ‹©è·ç¦»æœ€å°çš„æœªè®¿é—®é¡¶ç‚¹ï¼Œå…¶è·ç¦»å·²ç»æ˜¯æœ€çŸ­çš„ âœ“
3. **ç»ˆæ­¢æ€§**: æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®åç®—æ³•ç»ˆæ­¢ âœ“
4. **æ­£ç¡®æ€§**: é€šè¿‡æ•°å­¦å½’çº³æ³•å¯ä»¥è¯æ˜æ‰¾åˆ°çš„è·¯å¾„æ˜¯æœ€çŸ­çš„ âœ“

### 3.2 Floyd-Warshallç®—æ³•æ­£ç¡®æ€§

**å®šç† 3.2** (Floyd-Warshallç®—æ³•æ­£ç¡®æ€§)
Floyd-Warshallç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°æ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚

**è¯æ˜**:
è®¾ $d_{ij}^{(k)}$ ä¸ºä»é¡¶ç‚¹ $i$ åˆ°é¡¶ç‚¹ $j$ ç»è¿‡é¡¶ç‚¹ $1, 2, ..., k$ çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚

é€’æ¨å…³ç³»ï¼š
$$d_{ij}^{(k)} = \min(d_{ij}^{(k-1)}, d_{ik}^{(k-1)} + d_{kj}^{(k-1)})$$

é€šè¿‡æ•°å­¦å½’çº³æ³•å¯ä»¥è¯æ˜ç®—æ³•çš„æ­£ç¡®æ€§ã€‚

### 3.3 Kruskalç®—æ³•æ­£ç¡®æ€§

**å®šç† 3.3** (Kruskalç®—æ³•æ­£ç¡®æ€§)
Kruskalç®—æ³•èƒ½å¤Ÿæ‰¾åˆ°å›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚

**è¯æ˜**:

1. **è´ªå¿ƒé€‰æ‹©**: æ¯æ¬¡é€‰æ‹©æƒé‡æœ€å°çš„è¾¹ âœ“
2. **å®‰å…¨è¾¹**: é€‰æ‹©çš„è¾¹ä¸ä¼šå½¢æˆç¯ âœ“
3. **æœ€ä¼˜æ€§**: é€šè¿‡åè¯æ³•å¯ä»¥è¯æ˜æ‰¾åˆ°çš„ç”Ÿæˆæ ‘æ˜¯æœ€å°çš„ âœ“

### 3.4 ç½‘ç»œæµæœ€å¤§æµæœ€å°å‰²å®šç†

**å®šç† 3.4** (æœ€å¤§æµæœ€å°å‰²å®šç†)
ç½‘ç»œä¸­çš„æœ€å¤§æµç­‰äºæœ€å°å‰²çš„å®¹é‡ã€‚

**è¯æ˜**:

1. æœ€å¤§æµ â‰¤ æœ€å°å‰²å®¹é‡ï¼ˆæ˜¾ç„¶ï¼‰
2. æœ€å°å‰²å®¹é‡ â‰¤ æœ€å¤§æµï¼ˆé€šè¿‡Ford-Fulkersonç®—æ³•æ„é€ ï¼‰

## 4. æ€§èƒ½æµ‹è¯•

```python
def test_graph_algorithms():
    """æµ‹è¯•å›¾ç®—æ³•æ€§èƒ½"""
    
    # åˆ›å»ºæµ‹è¯•å›¾
    graph = Graph(GraphType.WEIGHTED)
    
    # æ·»åŠ é¡¶ç‚¹
    vertices = ['A', 'B', 'C', 'D', 'E', 'F']
    for vertex in vertices:
        graph.add_vertex(vertex)
    
    # æ·»åŠ è¾¹
    edges = [
        ('A', 'B', 4), ('A', 'C', 2),
        ('B', 'C', 1), ('B', 'D', 5),
        ('C', 'D', 8), ('C', 'E', 10),
        ('D', 'E', 2), ('D', 'F', 6),
        ('E', 'F', 3)
    ]
    
    for source, target, weight in edges:
        graph.add_edge(source, target, weight)
    
    print("å›¾ç®—æ³•æ€§èƒ½æµ‹è¯•")
    print("=" * 50)
    print(f"å›¾: {graph}")
    
    # æµ‹è¯•DFS
    dfs = DepthFirstSearch()
    dfs_result = dfs.execute(graph)
    print(f"\nDFSéå†: {dfs_result}")
    
    # æµ‹è¯•BFS
    bfs = BreadthFirstSearch()
    bfs_result = bfs.execute(graph)
    print(f"BFSéå†: {bfs_result}")
    
    # æµ‹è¯•Dijkstra
    dijkstra = DijkstraAlgorithm('A')
    dijkstra_result = dijkstra.execute(graph)
    print(f"\nDijkstraæœ€çŸ­è·¯å¾„ (ä»A):")
    for vertex, distance in dijkstra_result.items():
        print(f"  A -> {vertex}: {distance}")
    
    # æµ‹è¯•Floyd-Warshall
    floyd = FloydWarshallAlgorithm()
    floyd_result = floyd.execute(graph)
    print(f"\nFloyd-Warshallå…¨æºæœ€çŸ­è·¯å¾„:")
    for (source, target), distance in floyd_result.items():
        if source != target:
            print(f"  {source} -> {target}: {distance}")
    
    # æµ‹è¯•Kruskal
    kruskal = KruskalAlgorithm()
    kruskal_result = kruskal.execute(graph)
    print(f"\nKruskalæœ€å°ç”Ÿæˆæ ‘:")
    total_weight = 0
    for edge in kruskal_result:
        print(f"  {edge.source} -- {edge.weight} -- {edge.target}")
        total_weight += edge.weight
    print(f"æ€»æƒé‡: {total_weight}")
    
    # æµ‹è¯•Prim
    prim = PrimAlgorithm()
    prim_result = prim.execute(graph)
    print(f"\nPrimæœ€å°ç”Ÿæˆæ ‘:")
    total_weight = 0
    for edge in prim_result:
        print(f"  {edge.source} -- {edge.weight} -- {edge.target}")
        total_weight += edge.weight
    print(f"æ€»æƒé‡: {total_weight}")
    
    # æµ‹è¯•Ford-Fulkerson
    # åˆ›å»ºç½‘ç»œæµå›¾
    flow_graph = Graph(GraphType.DIRECTED)
    flow_edges = [
        ('s', 'A', 10), ('s', 'B', 10),
        ('A', 'C', 8), ('B', 'C', 5),
        ('C', 't', 10)
    ]
    
    for source, target, capacity in flow_edges:
        flow_graph.add_edge(source, target, capacity)
    
    ford_fulkerson = FordFulkersonAlgorithm('s', 't')
    max_flow = ford_fulkerson.execute(flow_graph)
    print(f"\nFord-Fulkersonæœ€å¤§æµ (s -> t): {max_flow}")

def compare_graph_representations():
    """æ¯”è¾ƒå›¾çš„è¡¨ç¤ºæ–¹æ³•"""
    
    # åˆ›å»ºç›¸åŒçš„å›¾
    vertices = ['A', 'B', 'C', 'D']
    edges = [('A', 'B', 1), ('B', 'C', 2), ('C', 'D', 3), ('A', 'D', 4)]
    
    # é‚»æ¥çŸ©é˜µ
    adj_matrix = AdjacencyMatrix(vertices)
    for source, target, weight in edges:
        adj_matrix.add_edge(source, target, weight)
    
    # é‚»æ¥è¡¨
    adj_list = AdjacencyList()
    for source, target, weight in edges:
        adj_list.add_edge(source, target, weight)
    
    print("å›¾è¡¨ç¤ºæ–¹æ³•æ¯”è¾ƒ")
    print("=" * 30)
    
    print("\né‚»æ¥çŸ©é˜µ:")
    for vertex in vertices:
        neighbors = adj_matrix.get_neighbors(vertex)
        print(f"  {vertex}: {neighbors}")
    
    print("\né‚»æ¥è¡¨:")
    for vertex in adj_list.get_vertices():
        neighbors = adj_list.get_neighbors(vertex)
        print(f"  {vertex}: {neighbors}")

if __name__ == "__main__":
    test_graph_algorithms()
    compare_graph_representations()
```

## 5. æ€»ç»“

æœ¬æ–‡æ¡£å»ºç«‹äº†å›¾ç®—æ³•çš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: æä¾›äº†å›¾çš„åŸºæœ¬æ¦‚å¿µå’Œé—®é¢˜çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **ç®—æ³•å®ç°**: å®Œæ•´çš„å›¾ç®—æ³•Pythonå®ç°
3. **ç†è®ºè¯æ˜**: å›¾ç®—æ³•çš„æ­£ç¡®æ€§å’Œå¤æ‚åº¦è¯æ˜
4. **æ€§èƒ½åˆ†æ**: ä¸åŒå›¾ç®—æ³•çš„æ€§èƒ½æ¯”è¾ƒ

### å›¾ç®—æ³•ç‰¹æ€§æ€»ç»“

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ç‰¹ç‚¹ |
|------|------------|------------|----------|------|
| DFS | O(V + E) | O(V) | å›¾éå† | æ·±åº¦ä¼˜å…ˆ |
| BFS | O(V + E) | O(V) | å›¾éå†ï¼Œæœ€çŸ­è·¯å¾„ | å¹¿åº¦ä¼˜å…ˆ |
| Dijkstra | O((V + E) log V) | O(V) | å•æºæœ€çŸ­è·¯å¾„ | éè´Ÿæƒé‡ |
| Floyd-Warshall | O(VÂ³) | O(VÂ²) | å…¨æºæœ€çŸ­è·¯å¾„ | ä»»æ„æƒé‡ |
| Kruskal | O(E log E) | O(V + E) | æœ€å°ç”Ÿæˆæ ‘ | è´ªå¿ƒç®—æ³• |
| Prim | O(E log V) | O(V + E) | æœ€å°ç”Ÿæˆæ ‘ | è´ªå¿ƒç®—æ³• |
| Ford-Fulkerson | O(VEÂ²) | O(VÂ²) | æœ€å¤§æµ | ç½‘ç»œæµ |

---

*ä¸‹ä¸€èŠ‚ï¼š[02-02-02-é«˜çº§æ•°æ®ç»“æ„](./02-02-02-é«˜çº§æ•°æ®ç»“æ„.md)*
