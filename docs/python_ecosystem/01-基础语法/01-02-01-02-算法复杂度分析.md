# ç®—æ³•å¤æ‚åº¦åˆ†æ

## ğŸ“‹ æ¦‚è¿°

ç®—æ³•å¤æ‚åº¦åˆ†ææ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒæ¦‚å¿µï¼Œç”¨äºè¯„ä¼°ç®—æ³•çš„æ•ˆç‡å’Œèµ„æºæ¶ˆè€—ã€‚é€šè¿‡æ•°å­¦æ–¹æ³•åˆ†æç®—æ³•åœ¨ä¸åŒè¾“å…¥è§„æ¨¡ä¸‹çš„æ€§èƒ½è¡¨ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### æ—¶é—´å¤æ‚åº¦

**å®šä¹‰**ï¼šæ—¶é—´å¤æ‚åº¦æè¿°äº†ç®—æ³•æ‰§è¡Œæ—¶é—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„å˜åŒ–è¶‹åŠ¿ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š$T(n) = O(f(n))$ è¡¨ç¤ºå­˜åœ¨å¸¸æ•° $c > 0$ å’Œ $n_0 > 0$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $n \geq n_0$ï¼Œæœ‰ $T(n) \leq c \cdot f(n)$ã€‚

### ç©ºé—´å¤æ‚åº¦

**å®šä¹‰**ï¼šç©ºé—´å¤æ‚åº¦æè¿°äº†ç®—æ³•æ‰€éœ€å†…å­˜ç©ºé—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„å˜åŒ–è¶‹åŠ¿ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š$S(n) = O(f(n))$ è¡¨ç¤ºç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹ä½¿ç”¨çš„é¢å¤–ç©ºé—´ä¸è¶…è¿‡ $c \cdot f(n)$ã€‚

### æ¸è¿›åˆ†æ

**å¤§Oè®°å·**ï¼š$O(f(n))$ è¡¨ç¤ºä¸Šç•Œ
**å¤§Î©è®°å·**ï¼š$\Omega(f(n))$ è¡¨ç¤ºä¸‹ç•Œ  
**å¤§Î˜è®°å·**ï¼š$\Theta(f(n))$ è¡¨ç¤ºç´§ç•Œ

## ğŸ”§ Pythonå®ç°

### å¤æ‚åº¦åˆ†æå·¥å…·

```python
import time
import psutil
import os
import matplotlib.pyplot as plt
import numpy as np
from typing import Dict, List, Any, Optional, Callable, Tuple
from dataclasses import dataclass
from enum import Enum
import logging
from datetime import datetime
import functools

# å¤æ‚åº¦ç±»å‹
class ComplexityType(Enum):
    CONSTANT = "O(1)"
    LOGARITHMIC = "O(log n)"
    LINEAR = "O(n)"
    LINE_LOG = "O(n log n)"
    QUADRATIC = "O(nÂ²)"
    CUBIC = "O(nÂ³)"
    EXPONENTIAL = "O(2â¿)"
    FACTORIAL = "O(n!)"

# æ€§èƒ½æµ‹è¯•ç»“æœ
@dataclass
class PerformanceResult:
    input_size: int
    execution_time: float
    memory_usage: float
    cpu_usage: float
    timestamp: datetime

# å¤æ‚åº¦åˆ†æå™¨
class ComplexityAnalyzer:
    """ç®—æ³•å¤æ‚åº¦åˆ†æå™¨"""
    
    def __init__(self):
        self.results: Dict[str, List[PerformanceResult]] = {}
        self.logger = logging.getLogger("complexity_analyzer")
        
    def analyze_algorithm(self, algorithm: Callable, 
                         input_generator: Callable,
                         input_sizes: List[int],
                         algorithm_name: str = "algorithm") -> Dict[str, Any]:
        """åˆ†æç®—æ³•å¤æ‚åº¦"""
        self.logger.info(f"å¼€å§‹åˆ†æç®—æ³•: {algorithm_name}")
        
        results = []
        
        for size in input_sizes:
            # ç”Ÿæˆè¾“å…¥æ•°æ®
            input_data = input_generator(size)
            
            # æ‰§è¡Œç®—æ³•å¹¶æµ‹é‡æ€§èƒ½
            result = self._measure_performance(algorithm, input_data)
            result.input_size = size
            results.append(result)
            
        # ä¿å­˜ç»“æœ
        self.results[algorithm_name] = results
        
        # åˆ†æå¤æ‚åº¦
        complexity_analysis = self._analyze_complexity(results)
        
        return {
            "algorithm_name": algorithm_name,
            "results": results,
            "complexity_analysis": complexity_analysis
        }
        
    def _measure_performance(self, algorithm: Callable, input_data: Any) -> PerformanceResult:
        """æµ‹é‡ç®—æ³•æ€§èƒ½"""
        # è·å–åˆå§‹å†…å­˜ä½¿ç”¨
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        initial_cpu = process.cpu_percent()
        
        # è®°å½•å¼€å§‹æ—¶é—´
        start_time = time.time()
        
        # æ‰§è¡Œç®—æ³•
        try:
            result = algorithm(input_data)
        except Exception as e:
            self.logger.error(f"ç®—æ³•æ‰§è¡Œé”™è¯¯: {e}")
            raise
            
        # è®°å½•ç»“æŸæ—¶é—´
        end_time = time.time()
        
        # è·å–æœ€ç»ˆå†…å­˜ä½¿ç”¨
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        final_cpu = process.cpu_percent()
        
        return PerformanceResult(
            input_size=0,  # å°†åœ¨å¤–éƒ¨è®¾ç½®
            execution_time=end_time - start_time,
            memory_usage=final_memory - initial_memory,
            cpu_usage=(initial_cpu + final_cpu) / 2,
            timestamp=datetime.now()
        )
        
    def _analyze_complexity(self, results: List[PerformanceResult]) -> Dict[str, Any]:
        """åˆ†æå¤æ‚åº¦"""
        if len(results) < 2:
            return {"error": "éœ€è¦è‡³å°‘ä¸¤ä¸ªæ•°æ®ç‚¹è¿›è¡Œå¤æ‚åº¦åˆ†æ"}
            
        # æå–æ•°æ®
        sizes = [r.input_size for r in results]
        times = [r.execution_time for r in results]
        memory = [r.memory_usage for r in results]
        
        # åˆ†ææ—¶é—´å¤æ‚åº¦
        time_complexity = self._estimate_time_complexity(sizes, times)
        
        # åˆ†æç©ºé—´å¤æ‚åº¦
        space_complexity = self._estimate_space_complexity(sizes, memory)
        
        return {
            "time_complexity": time_complexity,
            "space_complexity": space_complexity,
            "growth_rate": self._calculate_growth_rate(sizes, times)
        }
        
    def _estimate_time_complexity(self, sizes: List[int], times: List[float]) -> str:
        """ä¼°è®¡æ—¶é—´å¤æ‚åº¦"""
        if len(sizes) < 2:
            return "O(1)"
            
        # è®¡ç®—å¢é•¿ç‡
        growth_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            time_ratio = times[i] / times[i-1]
            growth_rate = time_ratio / size_ratio
            growth_rates.append(growth_rate)
            
        avg_growth_rate = np.mean(growth_rates)
        
        # æ ¹æ®å¢é•¿ç‡åˆ¤æ–­å¤æ‚åº¦
        if avg_growth_rate < 0.1:
            return "O(1)"
        elif avg_growth_rate < 0.5:
            return "O(log n)"
        elif avg_growth_rate < 2:
            return "O(n)"
        elif avg_growth_rate < 5:
            return "O(n log n)"
        elif avg_growth_rate < 10:
            return "O(nÂ²)"
        elif avg_growth_rate < 50:
            return "O(nÂ³)"
        else:
            return "O(2â¿) or higher"
            
    def _estimate_space_complexity(self, sizes: List[int], memory: List[float]) -> str:
        """ä¼°è®¡ç©ºé—´å¤æ‚åº¦"""
        if len(sizes) < 2:
            return "O(1)"
            
        # è®¡ç®—å†…å­˜å¢é•¿ç‡
        memory_rates = []
        for i in range(1, len(sizes)):
            size_ratio = sizes[i] / sizes[i-1]
            memory_ratio = memory[i] / memory[i-1] if memory[i-1] > 0 else 1
            memory_rate = memory_ratio / size_ratio
            memory_rates.append(memory_rate)
            
        avg_memory_rate = np.mean(memory_rates)
        
        # æ ¹æ®å†…å­˜å¢é•¿ç‡åˆ¤æ–­å¤æ‚åº¦
        if avg_memory_rate < 0.1:
            return "O(1)"
        elif avg_memory_rate < 0.5:
            return "O(log n)"
        elif avg_memory_rate < 2:
            return "O(n)"
        elif avg_memory_rate < 5:
            return "O(n log n)"
        else:
            return "O(nÂ²) or higher"
            
    def _calculate_growth_rate(self, sizes: List[int], times: List[float]) -> float:
        """è®¡ç®—å¢é•¿ç‡"""
        if len(sizes) < 2:
            return 0.0
            
        # ä½¿ç”¨å¯¹æ•°å›å½’è®¡ç®—å¢é•¿ç‡
        log_sizes = np.log(sizes)
        log_times = np.log(times)
        
        # çº¿æ€§å›å½’
        slope, _ = np.polyfit(log_sizes, log_times, 1)
        
        return slope
        
    def plot_results(self, algorithm_name: str, save_path: Optional[str] = None) -> None:
        """ç»˜åˆ¶åˆ†æç»“æœ"""
        if algorithm_name not in self.results:
            self.logger.error(f"ç®—æ³• {algorithm_name} çš„ç»“æœä¸å­˜åœ¨")
            return
            
        results = self.results[algorithm_name]
        
        # æå–æ•°æ®
        sizes = [r.input_size for r in results]
        times = [r.execution_time for r in results]
        memory = [r.memory_usage for r in results]
        
        # åˆ›å»ºå›¾è¡¨
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # æ—¶é—´å¤æ‚åº¦å›¾
        ax1.plot(sizes, times, 'b-o', label='å®é™…æ‰§è¡Œæ—¶é—´')
        ax1.set_xlabel('è¾“å…¥è§„æ¨¡')
        ax1.set_ylabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
        ax1.set_title(f'{algorithm_name} - æ—¶é—´å¤æ‚åº¦åˆ†æ')
        ax1.legend()
        ax1.grid(True)
        
        # ç©ºé—´å¤æ‚åº¦å›¾
        ax2.plot(sizes, memory, 'r-o', label='å†…å­˜ä½¿ç”¨')
        ax2.set_xlabel('è¾“å…¥è§„æ¨¡')
        ax2.set_ylabel('å†…å­˜ä½¿ç”¨ (MB)')
        ax2.set_title(f'{algorithm_name} - ç©ºé—´å¤æ‚åº¦åˆ†æ')
        ax2.legend()
        ax2.grid(True)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path)
        else:
            plt.show()
            
    def compare_algorithms(self, algorithm_names: List[str], 
                          save_path: Optional[str] = None) -> None:
        """æ¯”è¾ƒå¤šä¸ªç®—æ³•"""
        plt.figure(figsize=(12, 8))
        
        for name in algorithm_names:
            if name in self.results:
                results = self.results[name]
                sizes = [r.input_size for r in results]
                times = [r.execution_time for r in results]
                plt.plot(sizes, times, 'o-', label=name)
                
        plt.xlabel('è¾“å…¥è§„æ¨¡')
        plt.ylabel('æ‰§è¡Œæ—¶é—´ (ç§’)')
        plt.title('ç®—æ³•æ€§èƒ½æ¯”è¾ƒ')
        plt.legend()
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path)
        else:
            plt.show()
```

### å¸¸è§ç®—æ³•å¤æ‚åº¦åˆ†æ

```python
import random
from typing import List, Any

class AlgorithmExamples:
    """ç®—æ³•ç¤ºä¾‹å’Œå¤æ‚åº¦åˆ†æ"""
    
    def __init__(self):
        self.analyzer = ComplexityAnalyzer()
        
    def analyze_sorting_algorithms(self) -> Dict[str, Any]:
        """åˆ†ææ’åºç®—æ³•å¤æ‚åº¦"""
        # ç”Ÿæˆæµ‹è¯•æ•°æ®
        def generate_random_list(size: int) -> List[int]:
            return [random.randint(1, 1000) for _ in range(size)]
            
        input_sizes = [100, 500, 1000, 2000, 5000]
        
        # åˆ†æä¸åŒæ’åºç®—æ³•
        algorithms = {
            "å†’æ³¡æ’åº": self.bubble_sort,
            "é€‰æ‹©æ’åº": self.selection_sort,
            "æ’å…¥æ’åº": self.insertion_sort,
            "å¿«é€Ÿæ’åº": self.quick_sort,
            "å½’å¹¶æ’åº": self.merge_sort
        }
        
        results = {}
        
        for name, algorithm in algorithms.items():
            result = self.analyzer.analyze_algorithm(
                algorithm, generate_random_list, input_sizes, name
            )
            results[name] = result
            
        return results
        
    def bubble_sort(self, arr: List[int]) -> List[int]:
        """å†’æ³¡æ’åº - O(nÂ²)"""
        arr = arr.copy()
        n = len(arr)
        
        for i in range(n):
            for j in range(0, n - i - 1):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
                    
        return arr
        
    def selection_sort(self, arr: List[int]) -> List[int]:
        """é€‰æ‹©æ’åº - O(nÂ²)"""
        arr = arr.copy()
        n = len(arr)
        
        for i in range(n):
            min_idx = i
            for j in range(i + 1, n):
                if arr[j] < arr[min_idx]:
                    min_idx = j
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
            
        return arr
        
    def insertion_sort(self, arr: List[int]) -> List[int]:
        """æ’å…¥æ’åº - O(nÂ²)"""
        arr = arr.copy()
        
        for i in range(1, len(arr)):
            key = arr[i]
            j = i - 1
            while j >= 0 and arr[j] > key:
                arr[j + 1] = arr[j]
                j -= 1
            arr[j + 1] = key
            
        return arr
        
    def quick_sort(self, arr: List[int]) -> List[int]:
        """å¿«é€Ÿæ’åº - O(n log n) å¹³å‡æƒ…å†µ"""
        if len(arr) <= 1:
            return arr
            
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        
        return self.quick_sort(left) + middle + self.quick_sort(right)
        
    def merge_sort(self, arr: List[int]) -> List[int]:
        """å½’å¹¶æ’åº - O(n log n)"""
        if len(arr) <= 1:
            return arr
            
        mid = len(arr) // 2
        left = self.merge_sort(arr[:mid])
        right = self.merge_sort(arr[mid:])
        
        return self._merge(left, right)
        
    def _merge(self, left: List[int], right: List[int]) -> List[int]:
        """åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
                
        result.extend(left[i:])
        result.extend(right[j:])
        
        return result
        
    def analyze_search_algorithms(self) -> Dict[str, Any]:
        """åˆ†ææœç´¢ç®—æ³•å¤æ‚åº¦"""
        def generate_sorted_list(size: int) -> List[int]:
            return sorted([random.randint(1, 1000) for _ in range(size)])
            
        input_sizes = [1000, 5000, 10000, 50000, 100000]
        
        algorithms = {
            "çº¿æ€§æœç´¢": self.linear_search,
            "äºŒåˆ†æœç´¢": self.binary_search
        }
        
        results = {}
        
        for name, algorithm in algorithms.items():
            result = self.analyzer.analyze_algorithm(
                algorithm, generate_sorted_list, input_sizes, name
            )
            results[name] = result
            
        return results
        
    def linear_search(self, arr: List[int]) -> int:
        """çº¿æ€§æœç´¢ - O(n)"""
        target = arr[len(arr) // 2]  # æœç´¢ä¸­é—´å…ƒç´ 
        
        for i, num in enumerate(arr):
            if num == target:
                return i
        return -1
        
    def binary_search(self, arr: List[int]) -> int:
        """äºŒåˆ†æœç´¢ - O(log n)"""
        target = arr[len(arr) // 2]  # æœç´¢ä¸­é—´å…ƒç´ 
        
        left, right = 0, len(arr) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
                
        return -1
```

### å¤æ‚åº¦è¯æ˜å·¥å…·

```python
from typing import Dict, List, Any, Optional, Callable
import math

class ComplexityProof:
    """å¤æ‚åº¦è¯æ˜å·¥å…·"""
    
    def __init__(self):
        self.logger = logging.getLogger("complexity_proof")
        
    def prove_time_complexity(self, algorithm_name: str, 
                            complexity: str, 
                            proof_steps: List[str]) -> Dict[str, Any]:
        """è¯æ˜æ—¶é—´å¤æ‚åº¦"""
        proof = {
            "algorithm": algorithm_name,
            "claimed_complexity": complexity,
            "proof_steps": proof_steps,
            "verification": self._verify_proof(complexity, proof_steps)
        }
        
        return proof
        
    def _verify_proof(self, complexity: str, proof_steps: List[str]) -> Dict[str, Any]:
        """éªŒè¯è¯æ˜"""
        # ç®€åŒ–éªŒè¯ï¼Œå®é™…åº”è¯¥æ›´ä¸¥æ ¼
        verification = {
            "is_valid": True,
            "confidence": 0.8,
            "notes": "è¯æ˜éªŒè¯é€šè¿‡"
        }
        
        return verification
        
    def analyze_recurrence_relation(self, recurrence: str, 
                                  initial_conditions: Dict[int, int]) -> str:
        """åˆ†æé€’æ¨å…³ç³»"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä½¿ç”¨æ›´å¤æ‚çš„æ•°å­¦æ–¹æ³•
        if "T(n) = 2T(n/2) + n" in recurrence:
            return "O(n log n)"
        elif "T(n) = T(n-1) + n" in recurrence:
            return "O(nÂ²)"
        elif "T(n) = T(n/2) + 1" in recurrence:
            return "O(log n)"
        else:
            return "O(n)"
            
    def master_theorem(self, a: int, b: int, f_n: str) -> str:
        """ä¸»å®šç†åˆ†æ"""
        # ä¸»å®šç†ï¼šT(n) = aT(n/b) + f(n)
        log_b_a = math.log(a, b)
        
        if f_n == "O(n^k)" where k < log_b_a:
            return f"O(n^{log_b_a})"
        elif f_n == "O(n^k)" where k == log_b_a:
            return f"O(n^{log_b_a} log n)"
        else:
            return f_n
            
    def prove_space_complexity(self, algorithm_name: str,
                             complexity: str,
                             analysis: str) -> Dict[str, Any]:
        """è¯æ˜ç©ºé—´å¤æ‚åº¦"""
        proof = {
            "algorithm": algorithm_name,
            "claimed_complexity": complexity,
            "analysis": analysis,
            "verification": "ç©ºé—´å¤æ‚åº¦åˆ†ææ­£ç¡®"
        }
        
        return proof
```

### æ€§èƒ½åŸºå‡†æµ‹è¯•

```python
import timeit
import cProfile
import pstats
from typing import Dict, List, Any, Optional, Callable

class PerformanceBenchmark:
    """æ€§èƒ½åŸºå‡†æµ‹è¯•"""
    
    def __init__(self):
        self.benchmarks: Dict[str, Dict[str, Any]] = {}
        self.logger = logging.getLogger("performance_benchmark")
        
    def benchmark_algorithm(self, algorithm: Callable,
                          test_cases: Dict[str, Any],
                          algorithm_name: str = "algorithm") -> Dict[str, Any]:
        """åŸºå‡†æµ‹è¯•ç®—æ³•"""
        self.logger.info(f"å¼€å§‹åŸºå‡†æµ‹è¯•: {algorithm_name}")
        
        results = {}
        
        for case_name, test_data in test_cases.items():
            # ä½¿ç”¨timeitè¿›è¡Œç²¾ç¡®æµ‹é‡
            setup_code = f"from __main__ import {algorithm.__name__}"
            stmt = f"{algorithm.__name__}({test_data})"
            
            # è¿è¡Œå¤šæ¬¡å–å¹³å‡å€¼
            times = timeit.repeat(stmt, setup=setup_code, repeat=5, number=1)
            
            results[case_name] = {
                "min_time": min(times),
                "max_time": max(times),
                "mean_time": sum(times) / len(times),
                "std_time": np.std(times)
            }
            
        self.benchmarks[algorithm_name] = results
        return results
        
    def profile_algorithm(self, algorithm: Callable,
                         test_data: Any,
                         algorithm_name: str = "algorithm") -> Dict[str, Any]:
        """æ€§èƒ½åˆ†æç®—æ³•"""
        self.logger.info(f"å¼€å§‹æ€§èƒ½åˆ†æ: {algorithm_name}")
        
        # åˆ›å»ºæ€§èƒ½åˆ†æå™¨
        profiler = cProfile.Profile()
        profiler.enable()
        
        # æ‰§è¡Œç®—æ³•
        result = algorithm(test_data)
        
        profiler.disable()
        
        # è·å–ç»Ÿè®¡ä¿¡æ¯
        stats = pstats.Stats(profiler)
        stats.sort_stats('cumulative')
        
        # æå–å…³é”®æŒ‡æ ‡
        profile_data = {
            "total_calls": stats.total_calls,
            "total_time": stats.total_tt,
            "function_calls": []
        }
        
        # è·å–å‰10ä¸ªæœ€è€—æ—¶çš„å‡½æ•°
        for func, (cc, nc, tt, ct, callers) in stats.stats.items():
            if len(profile_data["function_calls"]) < 10:
                profile_data["function_calls"].append({
                    "function": func,
                    "calls": cc,
                    "total_time": tt,
                    "cumulative_time": ct
                })
                
        return profile_data
        
    def compare_implementations(self, implementations: Dict[str, Callable],
                              test_data: Any) -> Dict[str, Any]:
        """æ¯”è¾ƒä¸åŒå®ç°"""
        results = {}
        
        for name, implementation in implementations.items():
            # åŸºå‡†æµ‹è¯•
            benchmark_result = self.benchmark_algorithm(
                implementation, {"test": test_data}, name
            )
            
            # æ€§èƒ½åˆ†æ
            profile_result = self.profile_algorithm(
                implementation, test_data, name
            )
            
            results[name] = {
                "benchmark": benchmark_result,
                "profile": profile_result
            }
            
        return results
        
    def generate_report(self, algorithm_name: str) -> str:
        """ç”ŸæˆåŸºå‡†æµ‹è¯•æŠ¥å‘Š"""
        if algorithm_name not in self.benchmarks:
            return f"ç®—æ³• {algorithm_name} çš„åŸºå‡†æµ‹è¯•ç»“æœä¸å­˜åœ¨"
            
        benchmark = self.benchmarks[algorithm_name]
        
        report = []
        report.append(f"# æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š: {algorithm_name}")
        report.append(f"## æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        for case_name, metrics in benchmark.items():
            report.append(f"\n### æµ‹è¯•ç”¨ä¾‹: {case_name}")
            report.append(f"- æœ€å°æ‰§è¡Œæ—¶é—´: {metrics['min_time']:.6f} ç§’")
            report.append(f"- æœ€å¤§æ‰§è¡Œæ—¶é—´: {metrics['max_time']:.6f} ç§’")
            report.append(f"- å¹³å‡æ‰§è¡Œæ—¶é—´: {metrics['mean_time']:.6f} ç§’")
            report.append(f"- æ ‡å‡†å·®: {metrics['std_time']:.6f} ç§’")
            
        return "\n".join(report)
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

### å¸¸è§ç®—æ³•å¤æ‚åº¦

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ç¨³å®šæ€§ |
|------|------------|------------|--------|
| å†’æ³¡æ’åº | O(nÂ²) | O(1) | ç¨³å®š |
| é€‰æ‹©æ’åº | O(nÂ²) | O(1) | ä¸ç¨³å®š |
| æ’å…¥æ’åº | O(nÂ²) | O(1) | ç¨³å®š |
| å¿«é€Ÿæ’åº | O(n log n) | O(log n) | ä¸ç¨³å®š |
| å½’å¹¶æ’åº | O(n log n) | O(n) | ç¨³å®š |
| å †æ’åº | O(n log n) | O(1) | ä¸ç¨³å®š |

### æœç´¢ç®—æ³•å¤æ‚åº¦

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------------|------------|----------|
| çº¿æ€§æœç´¢ | O(n) | O(1) | æ— åºæ•°ç»„ |
| äºŒåˆ†æœç´¢ | O(log n) | O(1) | æœ‰åºæ•°ç»„ |
| æ·±åº¦ä¼˜å…ˆæœç´¢ | O(V + E) | O(V) | å›¾éå† |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ | O(V + E) | O(V) | å›¾éå† |

## ğŸ›¡ï¸ æœ€ä½³å®è·µ

### 1. å¤æ‚åº¦åˆ†æåŸåˆ™

- **æœ€åæƒ…å†µåˆ†æ**ï¼šåˆ†æç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹çš„æ€§èƒ½
- **å¹³å‡æƒ…å†µåˆ†æ**ï¼šåˆ†æç®—æ³•åœ¨å¹³å‡æƒ…å†µä¸‹çš„æ€§èƒ½
- **æ¸è¿›åˆ†æ**ï¼šå…³æ³¨è¾“å…¥è§„æ¨¡å¾ˆå¤§æ—¶çš„æ€§èƒ½è¶‹åŠ¿
- **å¸¸æ•°å› å­**ï¼šåœ¨æ¸è¿›åˆ†æä¸­å¿½ç•¥å¸¸æ•°å› å­

### 2. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```python
class PerformanceOptimizer:
    """æ€§èƒ½ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.optimization_strategies = []
        
    def add_strategy(self, strategy: Callable) -> None:
        """æ·»åŠ ä¼˜åŒ–ç­–ç•¥"""
        self.optimization_strategies.append(strategy)
        
    def optimize_algorithm(self, algorithm: Callable, 
                          input_data: Any) -> Callable:
        """ä¼˜åŒ–ç®—æ³•"""
        optimized_algorithm = algorithm
        
        for strategy in self.optimization_strategies:
            optimized_algorithm = strategy(optimized_algorithm)
            
        return optimized_algorithm
        
    def memoization_decorator(self, func: Callable) -> Callable:
        """è®°å¿†åŒ–è£…é¥°å™¨"""
        cache = {}
        
        @functools.wraps(func)
        def wrapper(*args):
            if args not in cache:
                cache[args] = func(*args)
            return cache[args]
            
        return wrapper
        
    def early_termination_decorator(self, func: Callable) -> Callable:
        """æ—©æœŸç»ˆæ­¢è£…é¥°å™¨"""
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # æ£€æŸ¥æ˜¯å¦æœ‰æ—©æœŸç»ˆæ­¢æ¡ä»¶
            if hasattr(func, 'early_termination_condition'):
                if func.early_termination_condition(*args, **kwargs):
                    return func.early_termination_value
            return func(*args, **kwargs)
            
        return wrapper
```

### 3. å¤æ‚åº¦åˆ†æå·¥å…·

```python
class ComplexityTools:
    """å¤æ‚åº¦åˆ†æå·¥å…·"""
    
    @staticmethod
    def is_polynomial_time(complexity: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¤šé¡¹å¼æ—¶é—´"""
        polynomial_patterns = ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)', 
                              'O(nÂ²)', 'O(nÂ³)', 'O(n^k)']
        return any(pattern in complexity for pattern in polynomial_patterns)
        
    @staticmethod
    def is_exponential_time(complexity: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæŒ‡æ•°æ—¶é—´"""
        exponential_patterns = ['O(2â¿)', 'O(3â¿)', 'O(n!)']
        return any(pattern in complexity for pattern in exponential_patterns)
        
    @staticmethod
    def compare_complexities(complexity1: str, complexity2: str) -> str:
        """æ¯”è¾ƒä¸¤ä¸ªå¤æ‚åº¦"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ›´å¤æ‚
        if complexity1 == complexity2:
            return "ç›¸ç­‰"
        elif "O(1)" in complexity1:
            return "complexity1 æ›´ä¼˜"
        elif "O(1)" in complexity2:
            return "complexity2 æ›´ä¼˜"
        else:
            return "éœ€è¦å…·ä½“åˆ†æ"
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md](./02-01-01-ç®—æ³•åŸºç¡€.md) - ç®—æ³•ç†è®ºåŸºç¡€
- [02-ç†è®ºåŸºç¡€/02-02-æ•°æ®ç»“æ„ç†è®º/02-02-01-æ•°æ®ç»“æ„åŸºç¡€.md](../02-02-æ•°æ®ç»“æ„ç†è®º/02-02-01-æ•°æ®ç»“æ„åŸºç¡€.md) - æ•°æ®ç»“æ„ç†è®º
- [06-ç»„ä»¶ç®—æ³•/06-01-åŸºç¡€ç®—æ³•/06-01-01-æ’åºç®—æ³•.md](../../06-ç»„ä»¶ç®—æ³•/06-01-åŸºç¡€ç®—æ³•/06-01-01-æ’åºç®—æ³•.md) - æ’åºç®—æ³•å®ç°

---

*æœ¬æ–‡æ¡£æä¾›äº†ç®—æ³•å¤æ‚åº¦åˆ†æçš„å®Œæ•´ç†è®ºåŸºç¡€å’ŒPythonå®ç°ï¼ŒåŒ…æ‹¬å¤æ‚åº¦åˆ†æå·¥å…·ã€æ€§èƒ½æµ‹è¯•ã€è¯æ˜æ–¹æ³•ç­‰æ ¸å¿ƒç»„ä»¶ã€‚*
