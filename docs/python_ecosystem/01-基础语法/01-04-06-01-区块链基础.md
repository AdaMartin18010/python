# åŒºå—é“¾åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

åŒºå—é“¾æ˜¯ä¸€ç§åˆ†å¸ƒå¼è´¦æœ¬æŠ€æœ¯ï¼Œé€šè¿‡å¯†ç å­¦ã€å…±è¯†æœºåˆ¶å’Œåˆ†å¸ƒå¼ç½‘ç»œå®ç°å»ä¸­å¿ƒåŒ–çš„æ•°æ®å­˜å‚¨å’Œäº¤æ˜“éªŒè¯ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰å‡ºå‘ï¼Œæ„å»ºå®Œæ•´çš„åŒºå—é“¾ç†è®ºä½“ç³»ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 åŒºå—é“¾ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1** (åŒºå—é“¾ç³»ç»Ÿ)
åŒºå—é“¾ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\text{Blockchain} = (B, N, C, P, V)$$

å…¶ä¸­ï¼š

- $B = \{b_1, b_2, \ldots, b_n\}$ æ˜¯åŒºå—é›†åˆ
- $N = \{n_1, n_2, \ldots, n_m\}$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $C$ æ˜¯å…±è¯†ç®—æ³•
- $P$ æ˜¯å¯†ç å­¦åè®®
- $V$ æ˜¯éªŒè¯æœºåˆ¶

### 1.2 åŒºå—ç»“æ„å®šä¹‰

**å®šä¹‰ 1.2** (åŒºå—)
åŒºå—æ˜¯ä¸€ä¸ªå…­å…ƒç»„ï¼š
$$b_i = (\text{header}, \text{transactions}, \text{timestamp}, \text{nonce}, \text{hash}, \text{prev\_hash})$$

å…¶ä¸­ï¼š

- $\text{header}$ æ˜¯åŒºå—å¤´ä¿¡æ¯
- $\text{transactions}$ æ˜¯äº¤æ˜“é›†åˆ
- $\text{timestamp}$ æ˜¯æ—¶é—´æˆ³
- $\text{nonce}$ æ˜¯éšæœºæ•°
- $\text{hash}$ æ˜¯å½“å‰åŒºå—å“ˆå¸Œ
- $\text{prev\_hash}$ æ˜¯å‰ä¸€ä¸ªåŒºå—å“ˆå¸Œ

### 1.3 äº¤æ˜“å®šä¹‰

**å®šä¹‰ 1.3** (äº¤æ˜“)
äº¤æ˜“æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$t = (\text{from}, \text{to}, \text{amount}, \text{signature}, \text{timestamp})$$

å…¶ä¸­ï¼š

- $\text{from}$ æ˜¯å‘é€æ–¹åœ°å€
- $\text{to}$ æ˜¯æ¥æ”¶æ–¹åœ°å€
- $\text{amount}$ æ˜¯äº¤æ˜“é‡‘é¢
- $\text{signature}$ æ˜¯æ•°å­—ç­¾å
- $\text{timestamp}$ æ˜¯äº¤æ˜“æ—¶é—´æˆ³

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 å¯†ç å­¦åŸºç¡€

#### 2.1.1 å“ˆå¸Œå‡½æ•°

**å®šä¹‰ 2.1** (å“ˆå¸Œå‡½æ•°)
å“ˆå¸Œå‡½æ•° $H: \{0,1\}^* \rightarrow \{0,1\}^n$ æ»¡è¶³ï¼š

1. **ç¡®å®šæ€§**: $H(x) = H(x)$
2. **å¿«é€Ÿè®¡ç®—**: è®¡ç®— $H(x)$ æ˜¯é«˜æ•ˆçš„
3. **æŠ—ç¢°æ’æ€§**: éš¾ä»¥æ‰¾åˆ° $x \neq y$ ä½¿å¾— $H(x) = H(y)$
4. **é›ªå´©æ•ˆåº”**: è¾“å…¥çš„å¾®å°å˜åŒ–å¯¼è‡´è¾“å‡ºçš„å·¨å¤§å˜åŒ–

#### 2.1.2 æ•°å­—ç­¾å

**å®šä¹‰ 2.2** (æ•°å­—ç­¾å)
æ•°å­—ç­¾åç®—æ³•æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(\text{Gen}, \text{Sign}, \text{Verify})$ï¼š

- $\text{Gen}() \rightarrow (\text{pk}, \text{sk})$: ç”Ÿæˆå…¬ç§é’¥å¯¹
- $\text{Sign}(\text{sk}, m) \rightarrow \sigma$: ä½¿ç”¨ç§é’¥ç­¾åæ¶ˆæ¯
- $\text{Verify}(\text{pk}, m, \sigma) \rightarrow \{\text{True}, \text{False}\}$: éªŒè¯ç­¾å

### 2.2 å…±è¯†æœºåˆ¶

#### 2.2.1 å·¥ä½œé‡è¯æ˜ (PoW)

**å®šä¹‰ 2.3** (å·¥ä½œé‡è¯æ˜)
å·¥ä½œé‡è¯æ˜è¦æ±‚èŠ‚ç‚¹æ‰¾åˆ°ä¸€ä¸ªéšæœºæ•° $\text{nonce}$ï¼Œä½¿å¾—ï¼š
$$H(\text{block\_data} \parallel \text{nonce}) < \text{target}$$

å…¶ä¸­ $\text{target}$ æ˜¯ç›®æ ‡éš¾åº¦å€¼ã€‚

#### 2.2.2 æƒç›Šè¯æ˜ (PoS)

**å®šä¹‰ 2.4** (æƒç›Šè¯æ˜)
æƒç›Šè¯æ˜ä¸­ï¼ŒèŠ‚ç‚¹è¢«é€‰ä¸ºéªŒè¯è€…çš„æ¦‚ç‡ä¸å…¶æŒæœ‰çš„ä»£å¸æ•°é‡æˆæ­£æ¯”ï¼š
$$P(\text{selected}) = \frac{\text{stake}}{\sum_{i} \text{stake}_i}$$

## 3. Pythonå®ç°

### 3.1 åŸºç¡€æ•°æ®ç»“æ„

```python
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
import hashlib
import json
import time
from abc import ABC, abstractmethod
import threading
from collections import defaultdict

@dataclass
class Transaction:
    """äº¤æ˜“ç±»"""
    from_address: str
    to_address: str
    amount: float
    timestamp: float = field(default_factory=time.time)
    signature: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'from_address': self.from_address,
            'to_address': self.to_address,
            'amount': self.amount,
            'timestamp': self.timestamp,
            'signature': self.signature
        }
    
    def calculate_hash(self) -> str:
        """è®¡ç®—äº¤æ˜“å“ˆå¸Œ"""
        transaction_string = json.dumps(self.to_dict(), sort_keys=True)
        return hashlib.sha256(transaction_string.encode()).hexdigest()

@dataclass
class BlockHeader:
    """åŒºå—å¤´"""
    version: str = "1.0"
    prev_hash: str = ""
    merkle_root: str = ""
    timestamp: float = field(default_factory=time.time)
    difficulty: int = 4
    nonce: int = 0
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'version': self.version,
            'prev_hash': self.prev_hash,
            'merkle_root': self.merkle_root,
            'timestamp': self.timestamp,
            'difficulty': self.difficulty,
            'nonce': self.nonce
        }

class Block:
    """åŒºå—ç±»"""
    
    def __init__(self, index: int, transactions: List[Transaction], 
                 prev_hash: str = "", difficulty: int = 4):
        self.index = index
        self.transactions = transactions
        self.header = BlockHeader(prev_hash=prev_hash, difficulty=difficulty)
        self.hash = ""
        self._calculate_hash()
    
    def _calculate_hash(self) -> None:
        """è®¡ç®—åŒºå—å“ˆå¸Œ"""
        block_data = {
            'index': self.index,
            'header': self.header.to_dict(),
            'transactions': [tx.to_dict() for tx in self.transactions]
        }
        block_string = json.dumps(block_data, sort_keys=True)
        self.hash = hashlib.sha256(block_string.encode()).hexdigest()
    
    def mine_block(self) -> None:
        """æŒ–çŸ¿"""
        target = "0" * self.header.difficulty
        
        while self.hash[:self.header.difficulty] != target:
            self.header.nonce += 1
            self._calculate_hash()
    
    def is_valid(self) -> bool:
        """éªŒè¯åŒºå—æœ‰æ•ˆæ€§"""
        # éªŒè¯å“ˆå¸Œ
        original_hash = self.hash
        self._calculate_hash()
        if self.hash != original_hash:
            return False
        
        # éªŒè¯äº¤æ˜“
        for transaction in self.transactions:
            if not self._verify_transaction(transaction):
                return False
        
        return True
    
    def _verify_transaction(self, transaction: Transaction) -> bool:
        """éªŒè¯äº¤æ˜“"""
        # è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„ç­¾åéªŒè¯
        return True

class Blockchain:
    """åŒºå—é“¾ç±»"""
    
    def __init__(self):
        self.chain: List[Block] = []
        self.pending_transactions: List[Transaction] = []
        self.nodes: set = set()
        self.difficulty = 4
        
        # åˆ›å»ºåˆ›ä¸–åŒºå—
        self._create_genesis_block()
    
    def _create_genesis_block(self) -> None:
        """åˆ›å»ºåˆ›ä¸–åŒºå—"""
        genesis_block = Block(0, [], "0", self.difficulty)
        genesis_block.mine_block()
        self.chain.append(genesis_block)
    
    def get_latest_block(self) -> Block:
        """è·å–æœ€æ–°åŒºå—"""
        return self.chain[-1]
    
    def add_transaction(self, from_address: str, to_address: str, 
                       amount: float) -> int:
        """æ·»åŠ äº¤æ˜“"""
        transaction = Transaction(from_address, to_address, amount)
        self.pending_transactions.append(transaction)
        return len(self.chain) + 1
    
    def mine_pending_transactions(self, miner_address: str) -> Block:
        """æŒ–æ˜å¾…å¤„ç†äº¤æ˜“"""
        block = Block(len(self.chain), self.pending_transactions, 
                     self.get_latest_block().hash, self.difficulty)
        
        # æ·»åŠ æŒ–çŸ¿å¥–åŠ±
        reward_transaction = Transaction("", miner_address, 10.0)
        block.transactions.append(reward_transaction)
        
        block.mine_block()
        
        # é‡ç½®å¾…å¤„ç†äº¤æ˜“
        self.pending_transactions = []
        
        # æ·»åŠ åŒºå—åˆ°é“¾
        self.chain.append(block)
        
        return block
    
    def is_chain_valid(self) -> bool:
        """éªŒè¯åŒºå—é“¾æœ‰æ•ˆæ€§"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]
            
            # éªŒè¯å½“å‰åŒºå—å“ˆå¸Œ
            if not current_block.is_valid():
                return False
            
            # éªŒè¯åŒºå—é“¾æ¥
            if current_block.header.prev_hash != previous_block.hash:
                return False
        
        return True
    
    def get_balance(self, address: str) -> float:
        """è·å–åœ°å€ä½™é¢"""
        balance = 0.0
        
        for block in self.chain:
            for transaction in block.transactions:
                if transaction.from_address == address:
                    balance -= transaction.amount
                if transaction.to_address == address:
                    balance += transaction.amount
        
        return balance

class ConsensusAlgorithm(ABC):
    """å…±è¯†ç®—æ³•æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def select_validator(self, nodes: List[str], stakes: Dict[str, float]) -> str:
        """é€‰æ‹©éªŒè¯è€…"""
        pass
    
    @abstractmethod
    def validate_block(self, block: Block, validators: List[str]) -> bool:
        """éªŒè¯åŒºå—"""
        pass

class ProofOfWork(ConsensusAlgorithm):
    """å·¥ä½œé‡è¯æ˜å…±è¯†ç®—æ³•"""
    
    def select_validator(self, nodes: List[str], stakes: Dict[str, float]) -> str:
        """é€‰æ‹©éªŒè¯è€…ï¼ˆPoWä¸­ç¬¬ä¸€ä¸ªæ‰¾åˆ°nonceçš„èŠ‚ç‚¹ï¼‰"""
        # PoWä¸­ä¸éœ€è¦é¢„å…ˆé€‰æ‹©éªŒè¯è€…
        return ""
    
    def validate_block(self, block: Block, validators: List[str]) -> bool:
        """éªŒè¯åŒºå—"""
        target = "0" * block.header.difficulty
        return block.hash[:block.header.difficulty] == target

class ProofOfStake(ConsensusAlgorithm):
    """æƒç›Šè¯æ˜å…±è¯†ç®—æ³•"""
    
    def select_validator(self, nodes: List[str], stakes: Dict[str, float]) -> str:
        """æ ¹æ®æƒç›Šé€‰æ‹©éªŒè¯è€…"""
        total_stake = sum(stakes.values())
        if total_stake == 0:
            return nodes[0] if nodes else ""
        
        # ç®€å•çš„éšæœºé€‰æ‹©ï¼ˆå®é™…åº”è¯¥ä½¿ç”¨æ›´å¤æ‚çš„ç®—æ³•ï¼‰
        import random
        random.seed(time.time())
        rand_val = random.uniform(0, total_stake)
        
        current_sum = 0
        for node, stake in stakes.items():
            current_sum += stake
            if rand_val <= current_sum:
                return node
        
        return nodes[-1] if nodes else ""
    
    def validate_block(self, block: Block, validators: List[str]) -> bool:
        """éªŒè¯åŒºå—"""
        # PoSä¸­éœ€è¦å¤šä¸ªéªŒè¯è€…ç¡®è®¤
        return len(validators) >= len(validators) // 2 + 1

class SmartContract:
    """æ™ºèƒ½åˆçº¦åŸºç±»"""
    
    def __init__(self, contract_address: str):
        self.contract_address = contract_address
        self.state: Dict[str, Any] = {}
        self.code: str = ""
    
    def execute(self, function_name: str, *args, **kwargs) -> Any:
        """æ‰§è¡Œåˆçº¦å‡½æ•°"""
        if hasattr(self, function_name):
            return getattr(self, function_name)(*args, **kwargs)
        raise ValueError(f"Function {function_name} not found")
    
    def get_state(self) -> Dict[str, Any]:
        """è·å–åˆçº¦çŠ¶æ€"""
        return self.state.copy()

class TokenContract(SmartContract):
    """ä»£å¸åˆçº¦"""
    
    def __init__(self, contract_address: str, initial_supply: float = 1000000):
        super().__init__(contract_address)
        self.state['total_supply'] = initial_supply
        self.state['balances'] = defaultdict(float)
        self.state['balances'][contract_address] = initial_supply
    
    def transfer(self, from_address: str, to_address: str, amount: float) -> bool:
        """è½¬è´¦"""
        if self.state['balances'][from_address] >= amount:
            self.state['balances'][from_address] -= amount
            self.state['balances'][to_address] += amount
            return True
        return False
    
    def balance_of(self, address: str) -> float:
        """æŸ¥è¯¢ä½™é¢"""
        return self.state['balances'][address]
    
    def total_supply(self) -> float:
        """æŸ¥è¯¢æ€»ä¾›åº”é‡"""
        return self.state['total_supply']

class BlockchainNode:
    """åŒºå—é“¾èŠ‚ç‚¹"""
    
    def __init__(self, node_id: str, consensus_algorithm: ConsensusAlgorithm):
        self.node_id = node_id
        self.blockchain = Blockchain()
        self.consensus_algorithm = consensus_algorithm
        self.peers: set = set()
        self.stake = 0.0
    
    def add_peer(self, peer_id: str) -> None:
        """æ·»åŠ å¯¹ç­‰èŠ‚ç‚¹"""
        self.peers.add(peer_id)
    
    def broadcast_transaction(self, transaction: Transaction) -> None:
        """å¹¿æ’­äº¤æ˜“"""
        # åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šé€šè¿‡ç½‘ç»œå‘é€äº¤æ˜“
        pass
    
    def receive_block(self, block: Block) -> bool:
        """æ¥æ”¶æ–°åŒºå—"""
        if self.blockchain.is_chain_valid():
            self.blockchain.chain.append(block)
            return True
        return False
    
    def mine_block(self) -> Optional[Block]:
        """æŒ–æ˜æ–°åŒºå—"""
        if self.pending_transactions:
            return self.blockchain.mine_pending_transactions(self.node_id)
        return None
```

### 3.2 å…±è¯†ç®—æ³•å®ç°

```python
class ConsensusManager:
    """å…±è¯†ç®¡ç†å™¨"""
    
    def __init__(self, algorithm: ConsensusAlgorithm):
        self.algorithm = algorithm
        self.validators: List[str] = []
        self.stakes: Dict[str, float] = {}
    
    def add_validator(self, node_id: str, stake: float = 0.0) -> None:
        """æ·»åŠ éªŒè¯è€…"""
        self.validators.append(node_id)
        self.stakes[node_id] = stake
    
    def select_validator(self) -> str:
        """é€‰æ‹©éªŒè¯è€…"""
        return self.algorithm.select_validator(self.validators, self.stakes)
    
    def validate_block(self, block: Block) -> bool:
        """éªŒè¯åŒºå—"""
        return self.algorithm.validate_block(block, self.validators)

class NetworkSimulator:
    """ç½‘ç»œæ¨¡æ‹Ÿå™¨"""
    
    def __init__(self):
        self.nodes: Dict[str, BlockchainNode] = {}
        self.consensus_manager = ConsensusManager(ProofOfWork())
    
    def add_node(self, node_id: str, consensus_algorithm: ConsensusAlgorithm) -> None:
        """æ·»åŠ èŠ‚ç‚¹"""
        node = BlockchainNode(node_id, consensus_algorithm)
        self.nodes[node_id] = node
        self.consensus_manager.add_validator(node_id)
        
        # è¿æ¥æ‰€æœ‰èŠ‚ç‚¹
        for existing_node_id in self.nodes:
            if existing_node_id != node_id:
                node.add_peer(existing_node_id)
                self.nodes[existing_node_id].add_peer(node_id)
    
    def broadcast_transaction(self, from_node: str, to_address: str, 
                            amount: float) -> None:
        """å¹¿æ’­äº¤æ˜“"""
        if from_node in self.nodes:
            node = self.nodes[from_node]
            tx_index = node.blockchain.add_transaction(from_node, to_address, amount)
            
            # å¹¿æ’­åˆ°å…¶ä»–èŠ‚ç‚¹
            for peer_id in node.peers:
                if peer_id in self.nodes:
                    self.nodes[peer_id].blockchain.add_transaction(from_node, to_address, amount)
    
    def mine_block(self, node_id: str) -> Optional[Block]:
        """æŒ–æ˜åŒºå—"""
        if node_id in self.nodes:
            return self.nodes[node_id].mine_block()
        return None
    
    def get_network_state(self) -> Dict[str, Any]:
        """è·å–ç½‘ç»œçŠ¶æ€"""
        return {
            'node_count': len(self.nodes),
            'chain_lengths': {node_id: len(node.blockchain.chain) 
                            for node_id, node in self.nodes.items()},
            'balances': {node_id: node.blockchain.get_balance(node_id) 
                        for node_id, node in self.nodes.items()}
        }
```

## 4. ç†è®ºè¯æ˜

### 4.1 åŒºå—é“¾å®‰å…¨æ€§

**å®šç† 4.1** (åŒºå—é“¾å®‰å…¨æ€§)
å¦‚æœæ”»å‡»è€…æ§åˆ¶çš„è®¡ç®—èƒ½åŠ›å°äºç½‘ç»œæ€»è®¡ç®—èƒ½åŠ›çš„50%ï¼Œåˆ™åŒºå—é“¾æ˜¯å®‰å…¨çš„ã€‚

**è¯æ˜**:
è®¾æ”»å‡»è€…æ§åˆ¶çš„è®¡ç®—èƒ½åŠ›ä¸º $p$ï¼Œç½‘ç»œæ€»è®¡ç®—èƒ½åŠ›ä¸º $1$ã€‚
æ”»å‡»è€…éœ€è¦åˆ›å»ºæ¯”è¯šå®èŠ‚ç‚¹æ›´é•¿çš„é“¾ï¼Œè¿™éœ€è¦ï¼š
$$p > 1 - p \Rightarrow p > 0.5$$

å› æ­¤ï¼Œå½“ $p < 0.5$ æ—¶ï¼ŒåŒºå—é“¾æ˜¯å®‰å…¨çš„ã€‚

### 4.2 å…±è¯†ç®—æ³•æ­£ç¡®æ€§

**å®šç† 4.2** (PoWå…±è¯†æ­£ç¡®æ€§)
å·¥ä½œé‡è¯æ˜ç®—æ³•èƒ½å¤Ÿä¿è¯ç½‘ç»œä¸­çš„èŠ‚ç‚¹å°±åŒºå—é¡ºåºè¾¾æˆä¸€è‡´ã€‚

**è¯æ˜**:

1. **å”¯ä¸€æ€§**: æ¯ä¸ªåŒºå—éƒ½æœ‰å”¯ä¸€çš„å“ˆå¸Œå€¼
2. **ä¸å¯å˜æ€§**: ä¿®æ”¹åŒºå—éœ€è¦é‡æ–°è®¡ç®—æ‰€æœ‰åç»­åŒºå—
3. **ä¸€è‡´æ€§**: æ‰€æœ‰èŠ‚ç‚¹éƒ½æ¥å—æœ€é•¿æœ‰æ•ˆé“¾

### 4.3 æ™ºèƒ½åˆçº¦å®‰å…¨æ€§

**å®šç† 4.3** (æ™ºèƒ½åˆçº¦ç¡®å®šæ€§)
å¦‚æœæ™ºèƒ½åˆçº¦å‡½æ•°æ˜¯ç¡®å®šæ€§çš„ï¼Œåˆ™æ‰€æœ‰èŠ‚ç‚¹æ‰§è¡Œç›¸åŒè¾“å…¥ä¼šäº§ç”Ÿç›¸åŒè¾“å‡ºã€‚

**è¯æ˜**:
è®¾åˆçº¦å‡½æ•°ä¸º $f(x)$ï¼Œå¯¹äºä»»æ„è¾“å…¥ $x$ï¼š
$$f(x) = f(x) \text{ (ç¡®å®šæ€§)}$$

å› æ­¤ï¼Œæ‰€æœ‰èŠ‚ç‚¹æ‰§è¡Œ $f(x)$ éƒ½ä¼šå¾—åˆ°ç›¸åŒç»“æœã€‚

## 5. æ€§èƒ½åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦

- **åŒºå—åˆ›å»º**: $O(2^d)$ å…¶ä¸­ $d$ æ˜¯éš¾åº¦
- **äº¤æ˜“éªŒè¯**: $O(n)$ å…¶ä¸­ $n$ æ˜¯äº¤æ˜“æ•°é‡
- **é“¾éªŒè¯**: $O(m \cdot n)$ å…¶ä¸­ $m$ æ˜¯åŒºå—æ•°é‡

### 5.2 ç©ºé—´å¤æ‚åº¦

- **åŒºå—å­˜å‚¨**: $O(m \cdot n)$
- **äº¤æ˜“æ± **: $O(p)$ å…¶ä¸­ $p$ æ˜¯å¾…å¤„ç†äº¤æ˜“æ•°é‡
- **èŠ‚ç‚¹çŠ¶æ€**: $O(1)$

### 5.3 ç½‘ç»œå¤æ‚åº¦

- **æ¶ˆæ¯ä¼ æ’­**: $O(\log n)$ å…¶ä¸­ $n$ æ˜¯èŠ‚ç‚¹æ•°é‡
- **å…±è¯†è¾¾æˆ**: $O(n)$
- **çŠ¶æ€åŒæ­¥**: $O(m)$

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 åŠ å¯†è´§å¸ç³»ç»Ÿ

```python
def create_cryptocurrency_system():
    """åˆ›å»ºåŠ å¯†è´§å¸ç³»ç»Ÿ"""
    # åˆ›å»ºç½‘ç»œ
    network = NetworkSimulator()
    
    # æ·»åŠ èŠ‚ç‚¹
    network.add_node("node1", ProofOfWork())
    network.add_node("node2", ProofOfWork())
    network.add_node("node3", ProofOfWork())
    
    # åˆ›å»ºäº¤æ˜“
    network.broadcast_transaction("node1", "node2", 50.0)
    network.broadcast_transaction("node2", "node3", 25.0)
    
    # æŒ–æ˜åŒºå—
    block1 = network.mine_block("node1")
    block2 = network.mine_block("node2")
    
    # æ£€æŸ¥ç½‘ç»œçŠ¶æ€
    state = network.get_network_state()
    print(f"ç½‘ç»œçŠ¶æ€: {state}")
    
    return network

def create_smart_contract_system():
    """åˆ›å»ºæ™ºèƒ½åˆçº¦ç³»ç»Ÿ"""
    # åˆ›å»ºä»£å¸åˆçº¦
    token_contract = TokenContract("contract1", 1000000)
    
    # æ‰§è¡Œåˆçº¦æ“ä½œ
    token_contract.transfer("contract1", "user1", 1000)
    token_contract.transfer("user1", "user2", 500)
    
    # æŸ¥è¯¢çŠ¶æ€
    print(f"ç”¨æˆ·1ä½™é¢: {token_contract.balance_of('user1')}")
    print(f"ç”¨æˆ·2ä½™é¢: {token_contract.balance_of('user2')}")
    print(f"æ€»ä¾›åº”é‡: {token_contract.total_supply()}")
    
    return token_contract
```

### 6.2 æ€§èƒ½æµ‹è¯•

```python
def performance_test():
    """æ€§èƒ½æµ‹è¯•"""
    import time
    
    # åˆ›å»ºåŒºå—é“¾
    blockchain = Blockchain()
    
    # æµ‹è¯•äº¤æ˜“æ·»åŠ æ€§èƒ½
    start_time = time.time()
    for i in range(1000):
        blockchain.add_transaction(f"user{i}", f"user{i+1}", 1.0)
    add_time = time.time() - start_time
    
    # æµ‹è¯•æŒ–çŸ¿æ€§èƒ½
    start_time = time.time()
    block = blockchain.mine_pending_transactions("miner")
    mine_time = time.time() - start_time
    
    print(f"æ·»åŠ 1000ä¸ªäº¤æ˜“è€—æ—¶: {add_time:.4f}ç§’")
    print(f"æŒ–æ˜åŒºå—è€—æ—¶: {mine_time:.4f}ç§’")
    print(f"åŒºå—é“¾é•¿åº¦: {len(blockchain.chain)}")
    print(f"åŒºå—é“¾æœ‰æ•ˆ: {blockchain.is_chain_valid()}")

if __name__ == "__main__":
    # è¿è¡Œç¤ºä¾‹
    print("=== åŒºå—é“¾åŸºç¡€ç¤ºä¾‹ ===")
    
    # åˆ›å»ºåŠ å¯†è´§å¸ç³»ç»Ÿ
    print("\n1. åˆ›å»ºåŠ å¯†è´§å¸ç³»ç»Ÿ")
    network = create_cryptocurrency_system()
    
    # åˆ›å»ºæ™ºèƒ½åˆçº¦ç³»ç»Ÿ
    print("\n2. åˆ›å»ºæ™ºèƒ½åˆçº¦ç³»ç»Ÿ")
    contract = create_smart_contract_system()
    
    # æ€§èƒ½æµ‹è¯•
    print("\n3. æ€§èƒ½æµ‹è¯•")
    performance_test()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£æ„å»ºäº†å®Œæ•´çš„åŒºå—é“¾ç†è®ºåŸºç¡€ï¼ŒåŒ…æ‹¬ï¼š

1. **å½¢å¼åŒ–å®šä¹‰**: åŒºå—é“¾ç³»ç»Ÿã€åŒºå—ã€äº¤æ˜“çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **æ ¸å¿ƒæ¦‚å¿µ**: å¯†ç å­¦åŸºç¡€ã€å…±è¯†æœºåˆ¶ã€æ™ºèƒ½åˆçº¦
3. **Pythonå®ç°**: å®Œæ•´çš„åŒºå—é“¾ç³»ç»Ÿå®ç°
4. **ç†è®ºè¯æ˜**: å®‰å…¨æ€§ã€æ­£ç¡®æ€§ã€ç¡®å®šæ€§çš„æ•°å­¦è¯æ˜
5. **æ€§èƒ½åˆ†æ**: æ—¶é—´ã€ç©ºé—´ã€ç½‘ç»œå¤æ‚åº¦åˆ†æ
6. **åº”ç”¨ç¤ºä¾‹**: åŠ å¯†è´§å¸ç³»ç»Ÿå’Œæ™ºèƒ½åˆçº¦ç³»ç»Ÿ

åŒºå—é“¾æŠ€æœ¯é€šè¿‡å»ä¸­å¿ƒåŒ–ã€å¯†ç å­¦å’Œå…±è¯†æœºåˆ¶ï¼Œå®ç°äº†å®‰å…¨ã€é€æ˜ã€ä¸å¯ç¯¡æ”¹çš„æ•°æ®å­˜å‚¨å’Œäº¤æ˜“ç³»ç»Ÿï¼Œä¸ºæ•°å­—ç»æµçš„å‘å±•æä¾›äº†é‡è¦åŸºç¡€è®¾æ–½ã€‚

---

*æœ€åæ›´æ–°: 2024-12-19*
*ä¸‹æ¬¡æ›´æ–°: å®Œæˆæ¸¸æˆå¼€å‘é¢†åŸŸæ–‡æ¡£*
