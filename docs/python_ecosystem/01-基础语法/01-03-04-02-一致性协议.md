# ä¸€è‡´æ€§åè®®

## ğŸ“‹ æ¦‚è¿°

ä¸€è‡´æ€§åè®®æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œç¡®ä¿åœ¨å¤šä¸ªèŠ‚ç‚¹ä¹‹é—´ç»´æŠ¤æ•°æ®çš„ä¸€è‡´æ€§ã€‚æœ¬æ–‡æ¡£æä¾›ä¸€è‡´æ€§åè®®çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰ã€Pythonå®ç°å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. ä¸€è‡´æ€§åè®®å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**ä¸€è‡´æ€§åè®®äº”å…ƒç»„**:
$$\mathcal{CP} = (N, S, T, C, V)$$

å…¶ä¸­ï¼š

- $N = \{n_1, n_2, ..., n_k\}$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $S = \{s_1, s_2, ..., s_m\}$ æ˜¯çŠ¶æ€é›†åˆ
- $T = \{t_1, t_2, ..., t_p\}$ æ˜¯äº‹åŠ¡é›†åˆ
- $C: T \times N \rightarrow S$ æ˜¯ä¸€è‡´æ€§å‡½æ•°
- $V: S \times S \rightarrow \{true, false\}$ æ˜¯éªŒè¯å‡½æ•°

#### 1.2 ä¸€è‡´æ€§çº§åˆ«

**å¼ºä¸€è‡´æ€§**:
$$\forall t \in T, \forall n_i, n_j \in N: C(t, n_i) = C(t, n_j)$$

**æœ€ç»ˆä¸€è‡´æ€§**:
$$\lim_{t \to \infty} \forall n_i, n_j \in N: C(t, n_i) = C(t, n_j)$$

**å¼±ä¸€è‡´æ€§**:
$$\exists t \in T, \exists n_i, n_j \in N: C(t, n_i) \neq C(t, n_j)$$

## ğŸ”§ Pythonå®ç°

### 2. åŸºç¡€æ¡†æ¶

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Set, Optional, Any, Tuple
from collections import defaultdict
import time
import uuid
import asyncio
from concurrent.futures import ThreadPoolExecutor
import threading
import logging

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ConsistencyLevel(Enum):
    """ä¸€è‡´æ€§çº§åˆ«æšä¸¾"""
    STRONG = "strong"
    EVENTUAL = "eventual"
    WEAK = "weak"

class NodeState(Enum):
    """èŠ‚ç‚¹çŠ¶æ€æšä¸¾"""
    LEADER = "leader"
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    OFFLINE = "offline"

@dataclass
class Transaction:
    """äº‹åŠ¡å®šä¹‰"""
    id: str
    operation: str
    data: Any
    timestamp: float
    node_id: str
    sequence_number: int = 0
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = time.time()

@dataclass
class ConsensusMessage:
    """å…±è¯†æ¶ˆæ¯"""
    message_id: str
    message_type: str
    sender_id: str
    receiver_id: str
    data: Any
    timestamp: float
    sequence_number: int = 0
    
    def __post_init__(self):
        if not self.message_id:
            self.message_id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = time.time()

class ConsistencyProtocol(ABC):
    """ä¸€è‡´æ€§åè®®æŠ½è±¡åŸºç±»"""
    
    def __init__(self, node_id: str, nodes: List[str]):
        self.node_id = node_id
        self.nodes = nodes
        self.state = NodeState.FOLLOWER
        self.current_term = 0
        self.voted_for: Optional[str] = None
        self.log: List[Transaction] = []
        self.commit_index = 0
        self.last_applied = 0
        self.next_index: Dict[str, int] = defaultdict(int)
        self.match_index: Dict[str, int] = defaultdict(int)
        self.election_timeout = 5.0
        self.heartbeat_interval = 1.0
        self.last_heartbeat = time.time()
        
    @abstractmethod
    async def propose_transaction(self, transaction: Transaction) -> bool:
        """æè®®äº‹åŠ¡"""
        pass
    
    @abstractmethod
    async def commit_transaction(self, transaction_id: str) -> bool:
        """æäº¤äº‹åŠ¡"""
        pass
    
    @abstractmethod
    def verify_consistency(self) -> bool:
        """éªŒè¯ä¸€è‡´æ€§"""
        pass

class RaftProtocol(ConsistencyProtocol):
    """Raftä¸€è‡´æ€§åè®®å®ç°"""
    
    def __init__(self, node_id: str, nodes: List[str]):
        super().__init__(node_id, nodes)
        self.votes_received: Set[str] = set()
        self.election_timer = None
        self.heartbeat_timer = None
        self.lock = threading.Lock()
        
    async def start_election(self):
        """å¼€å§‹é€‰ä¸¾"""
        with self.lock:
            self.state = NodeState.CANDIDATE
            self.current_term += 1
            self.voted_for = self.node_id
            self.votes_received = {self.node_id}
            
        logger.info(f"Node {self.node_id} starting election for term {self.current_term}")
        
        # å‘å…¶ä»–èŠ‚ç‚¹è¯·æ±‚æŠ•ç¥¨
        for node in self.nodes:
            if node != self.node_id:
                await self._request_vote(node)
    
    async def _request_vote(self, target_node: str):
        """è¯·æ±‚æŠ•ç¥¨"""
        message = ConsensusMessage(
            message_type="RequestVote",
            sender_id=self.node_id,
            receiver_id=target_node,
            data={
                "term": self.current_term,
                "candidate_id": self.node_id,
                "last_log_index": len(self.log) - 1,
                "last_log_term": self.log[-1].timestamp if self.log else 0
            }
        )
        
        # æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
        await self._send_message(message)
    
    async def _send_message(self, message: ConsensusMessage):
        """å‘é€æ¶ˆæ¯"""
        logger.info(f"Node {self.node_id} sending {message.message_type} to {message.receiver_id}")
        # è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„ç½‘ç»œé€šä¿¡
        # ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡æ‹Ÿå®ç°
        
    async def propose_transaction(self, transaction: Transaction) -> bool:
        """æè®®äº‹åŠ¡"""
        if self.state != NodeState.LEADER:
            logger.warning(f"Node {self.node_id} is not leader, cannot propose transaction")
            return False
            
        with self.lock:
            transaction.sequence_number = len(self.log)
            self.log.append(transaction)
            
        logger.info(f"Node {self.node_id} proposed transaction {transaction.id}")
        
        # å¤åˆ¶åˆ°å…¶ä»–èŠ‚ç‚¹
        success_count = 1  # åŒ…æ‹¬è‡ªå·±
        for node in self.nodes:
            if node != self.node_id:
                if await self._replicate_log(node, transaction):
                    success_count += 1
        
        # å¦‚æœå¤§å¤šæ•°èŠ‚ç‚¹ç¡®è®¤ï¼Œåˆ™æäº¤
        if success_count > len(self.nodes) / 2:
            await self.commit_transaction(transaction.id)
            return True
            
        return False
    
    async def _replicate_log(self, target_node: str, transaction: Transaction) -> bool:
        """å¤åˆ¶æ—¥å¿—åˆ°ç›®æ ‡èŠ‚ç‚¹"""
        message = ConsensusMessage(
            message_type="AppendEntries",
            sender_id=self.node_id,
            receiver_id=target_node,
            data={
                "term": self.current_term,
                "leader_id": self.node_id,
                "prev_log_index": len(self.log) - 2,
                "prev_log_term": self.log[-2].timestamp if len(self.log) > 1 else 0,
                "entries": [transaction],
                "leader_commit": self.commit_index
            }
        )
        
        await self._send_message(message)
        return True  # æ¨¡æ‹ŸæˆåŠŸ
    
    async def commit_transaction(self, transaction_id: str) -> bool:
        """æäº¤äº‹åŠ¡"""
        with self.lock:
            # æ‰¾åˆ°äº‹åŠ¡åœ¨æ—¥å¿—ä¸­çš„ä½ç½®
            for i, transaction in enumerate(self.log):
                if transaction.id == transaction_id:
                    self.commit_index = max(self.commit_index, i)
                    logger.info(f"Node {self.node_id} committed transaction {transaction_id}")
                    return True
        return False
    
    def verify_consistency(self) -> bool:
        """éªŒè¯ä¸€è‡´æ€§"""
        # æ£€æŸ¥æ—¥å¿—å®Œæ•´æ€§
        for i in range(len(self.log) - 1):
            if self.log[i].sequence_number + 1 != self.log[i + 1].sequence_number:
                return False
        return True

class PaxosProtocol(ConsistencyProtocol):
    """Paxosä¸€è‡´æ€§åè®®å®ç°"""
    
    def __init__(self, node_id: str, nodes: List[str]):
        super().__init__(node_id, nodes)
        self.proposal_number = 0
        self.accepted_proposals: Dict[int, Any] = {}
        self.promises: Dict[str, Dict] = {}
        
    async def propose_transaction(self, transaction: Transaction) -> bool:
        """æè®®äº‹åŠ¡"""
        self.proposal_number += 1
        
        # Phase 1: Prepare
        promises = await self._prepare_phase()
        
        if len(promises) <= len(self.nodes) / 2:
            logger.warning(f"Node {self.node_id} did not receive enough promises")
            return False
        
        # Phase 2: Accept
        accepted = await self._accept_phase(transaction, promises)
        
        if len(accepted) > len(self.nodes) / 2:
            await self.commit_transaction(transaction.id)
            return True
            
        return False
    
    async def _prepare_phase(self) -> List[Dict]:
        """å‡†å¤‡é˜¶æ®µ"""
        promises = []
        for node in self.nodes:
            if node != self.node_id:
                message = ConsensusMessage(
                    message_type="Prepare",
                    sender_id=self.node_id,
                    receiver_id=node,
                    data={
                        "proposal_number": self.proposal_number
                    }
                )
                await self._send_message(message)
                # æ¨¡æ‹Ÿå“åº”
                promises.append({"node": node, "promised": True})
        return promises
    
    async def _accept_phase(self, transaction: Transaction, promises: List[Dict]) -> List[Dict]:
        """æ¥å—é˜¶æ®µ"""
        accepted = []
        for node in self.nodes:
            if node != self.node_id:
                message = ConsensusMessage(
                    message_type="Accept",
                    sender_id=self.node_id,
                    receiver_id=node,
                    data={
                        "proposal_number": self.proposal_number,
                        "transaction": transaction
                    }
                )
                await self._send_message(message)
                # æ¨¡æ‹Ÿå“åº”
                accepted.append({"node": node, "accepted": True})
        return accepted
    
    async def commit_transaction(self, transaction_id: str) -> bool:
        """æäº¤äº‹åŠ¡"""
        self.log.append(Transaction(
            id=transaction_id,
            operation="commit",
            data=None,
            timestamp=time.time(),
            node_id=self.node_id
        ))
        logger.info(f"Node {self.node_id} committed transaction {transaction_id}")
        return True
    
    def verify_consistency(self) -> bool:
        """éªŒè¯ä¸€è‡´æ€§"""
        # æ£€æŸ¥ææ¡ˆç¼–å·çš„å•è°ƒæ€§
        proposal_numbers = [p for p in self.accepted_proposals.keys()]
        return proposal_numbers == sorted(proposal_numbers)

class TwoPhaseCommitProtocol(ConsistencyProtocol):
    """ä¸¤é˜¶æ®µæäº¤åè®®å®ç°"""
    
    def __init__(self, node_id: str, nodes: List[str]):
        super().__init__(node_id, nodes)
        self.coordinator = node_id == nodes[0]  # ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºåè°ƒè€…
        self.prepared_transactions: Set[str] = set()
        self.committed_transactions: Set[str] = set()
        
    async def propose_transaction(self, transaction: Transaction) -> bool:
        """æè®®äº‹åŠ¡"""
        if not self.coordinator:
            logger.warning(f"Node {self.node_id} is not coordinator")
            return False
        
        # Phase 1: Prepare
        prepared_count = 0
        for node in self.nodes:
            if node != self.node_id:
                message = ConsensusMessage(
                    message_type="Prepare",
                    sender_id=self.node_id,
                    receiver_id=node,
                    data={"transaction": transaction}
                )
                await self._send_message(message)
                # æ¨¡æ‹Ÿå“åº”
                prepared_count += 1
        
        if prepared_count == len(self.nodes) - 1:
            self.prepared_transactions.add(transaction.id)
            
            # Phase 2: Commit
            committed_count = 0
            for node in self.nodes:
                if node != self.node_id:
                    message = ConsensusMessage(
                        message_type="Commit",
                        sender_id=self.node_id,
                        receiver_id=node,
                        data={"transaction_id": transaction.id}
                    )
                    await self._send_message(message)
                    # æ¨¡æ‹Ÿå“åº”
                    committed_count += 1
            
            if committed_count == len(self.nodes) - 1:
                self.committed_transactions.add(transaction.id)
                await self.commit_transaction(transaction.id)
                return True
        
        return False
    
    async def commit_transaction(self, transaction_id: str) -> bool:
        """æäº¤äº‹åŠ¡"""
        self.log.append(Transaction(
            id=transaction_id,
            operation="commit",
            data=None,
            timestamp=time.time(),
            node_id=self.node_id
        ))
        logger.info(f"Node {self.node_id} committed transaction {transaction_id}")
        return True
    
    def verify_consistency(self) -> bool:
        """éªŒè¯ä¸€è‡´æ€§"""
        # æ£€æŸ¥å·²æäº¤çš„äº‹åŠ¡æ˜¯å¦éƒ½å·²å‡†å¤‡
        return self.committed_transactions.issubset(self.prepared_transactions)

class ConsistencyManager:
    """ä¸€è‡´æ€§ç®¡ç†å™¨"""
    
    def __init__(self, protocol_type: str, node_id: str, nodes: List[str]):
        self.node_id = node_id
        self.nodes = nodes
        self.protocol_type = protocol_type
        
        if protocol_type == "raft":
            self.protocol = RaftProtocol(node_id, nodes)
        elif protocol_type == "paxos":
            self.protocol = PaxosProtocol(node_id, nodes)
        elif protocol_type == "2pc":
            self.protocol = TwoPhaseCommitProtocol(node_id, nodes)
        else:
            raise ValueError(f"Unsupported protocol type: {protocol_type}")
    
    async def execute_transaction(self, operation: str, data: Any) -> bool:
        """æ‰§è¡Œäº‹åŠ¡"""
        transaction = Transaction(
            operation=operation,
            data=data,
            timestamp=time.time(),
            node_id=self.node_id
        )
        
        return await self.protocol.propose_transaction(transaction)
    
    def get_consistency_status(self) -> Dict[str, Any]:
        """è·å–ä¸€è‡´æ€§çŠ¶æ€"""
        return {
            "node_id": self.node_id,
            "protocol_type": self.protocol_type,
            "state": self.protocol.state.value if hasattr(self.protocol, 'state') else "unknown",
            "log_length": len(self.protocol.log),
            "consistency_verified": self.protocol.verify_consistency(),
            "current_term": getattr(self.protocol, 'current_term', 0)
        }
```

### 3. å®é™…åº”ç”¨ç¤ºä¾‹

```python
async def demonstrate_consistency_protocols():
    """æ¼”ç¤ºä¸€è‡´æ€§åè®®"""
    nodes = ["node1", "node2", "node3", "node4", "node5"]
    
    # åˆ›å»ºä¸åŒåè®®çš„èŠ‚ç‚¹
    raft_nodes = []
    paxos_nodes = []
    tpc_nodes = []
    
    for i, node_id in enumerate(nodes):
        raft_nodes.append(ConsistencyManager("raft", node_id, nodes))
        paxos_nodes.append(ConsistencyManager("paxos", node_id, nodes))
        tpc_nodes.append(ConsistencyManager("2pc", node_id, nodes))
    
    # æ¼”ç¤ºRaftåè®®
    print("=== Raft Protocol Demo ===")
    await raft_nodes[0].execute_transaction("SET", {"key": "value1", "value": "data1"})
    await raft_nodes[1].execute_transaction("SET", {"key": "value2", "value": "data2"})
    
    for node in raft_nodes:
        status = node.get_consistency_status()
        print(f"Raft {status['node_id']}: {status}")
    
    # æ¼”ç¤ºPaxosåè®®
    print("\n=== Paxos Protocol Demo ===")
    await paxos_nodes[0].execute_transaction("SET", {"key": "value3", "value": "data3"})
    
    for node in paxos_nodes:
        status = node.get_consistency_status()
        print(f"Paxos {status['node_id']}: {status}")
    
    # æ¼”ç¤ºä¸¤é˜¶æ®µæäº¤
    print("\n=== Two-Phase Commit Demo ===")
    await tpc_nodes[0].execute_transaction("SET", {"key": "value4", "value": "data4"})
    
    for node in tpc_nodes:
        status = node.get_consistency_status()
        print(f"2PC {status['node_id']}: {status}")

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    asyncio.run(demonstrate_consistency_protocols())
```

## ğŸ“Š æ€§èƒ½åˆ†æ

### 4. å¤æ‚åº¦åˆ†æ

#### 4.1 æ—¶é—´å¤æ‚åº¦

**Raftåè®®**:

- é€‰ä¸¾é˜¶æ®µ: $O(n)$
- æ—¥å¿—å¤åˆ¶: $O(n)$
- æ€»å¤æ‚åº¦: $O(n)$

**Paxosåè®®**:

- å‡†å¤‡é˜¶æ®µ: $O(n)$
- æ¥å—é˜¶æ®µ: $O(n)$
- æ€»å¤æ‚åº¦: $O(n)$

**ä¸¤é˜¶æ®µæäº¤**:

- å‡†å¤‡é˜¶æ®µ: $O(n)$
- æäº¤é˜¶æ®µ: $O(n)$
- æ€»å¤æ‚åº¦: $O(n)$

#### 4.2 ç©ºé—´å¤æ‚åº¦

**æ—¥å¿—å­˜å‚¨**: $O(t)$ å…¶ä¸­ $t$ æ˜¯äº‹åŠ¡æ•°é‡
**çŠ¶æ€å­˜å‚¨**: $O(n)$ å…¶ä¸­ $n$ æ˜¯èŠ‚ç‚¹æ•°é‡
**æ¶ˆæ¯å­˜å‚¨**: $O(m)$ å…¶ä¸­ $m$ æ˜¯æ¶ˆæ¯æ•°é‡

### 5. ä¸€è‡´æ€§ä¿è¯

#### 5.1 å®‰å…¨æ€§

**çº¿æ€§åŒ–**: æ‰€æœ‰æ“ä½œçœ‹èµ·æ¥éƒ½æ˜¯åŸå­çš„
**é¡ºåºæ€§**: æ“ä½œæŒ‰ç…§å…¨å±€é¡ºåºæ‰§è¡Œ
**æŒä¹…æ€§**: å·²æäº¤çš„æ“ä½œä¸ä¼šä¸¢å¤±

#### 5.2 æ´»æ€§

**è¿›å±•æ€§**: ç³»ç»Ÿæœ€ç»ˆä¼šå–å¾—è¿›å±•
**å¯ç”¨æ€§**: åœ¨å¤§å¤šæ•°èŠ‚ç‚¹æ­£å¸¸æ—¶ç³»ç»Ÿå¯ç”¨
**å®¹é”™æ€§**: èƒ½å¤Ÿå®¹å¿èŠ‚ç‚¹æ•…éšœ

## ğŸ”— ç›¸å…³é“¾æ¥

- [åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](../03-04-01-åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€.md)
- [å¾®æœåŠ¡æ¶æ„](../../05-æ¶æ„é¢†åŸŸ/05-01-å¾®æœåŠ¡æ¶æ„/05-01-01-å¾®æœåŠ¡åŸºç¡€.md)
- [äº‹ä»¶é©±åŠ¨æ¶æ„](../03-02-è½¯ä»¶æ¶æ„/03-02-04-äº‹ä»¶é©±åŠ¨æ¶æ„.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Lamport, L. (1998). "The part-time parliament". ACM Transactions on Computer Systems.
2. Ongaro, D., & Ousterhout, J. (2014). "In search of an understandable consensus algorithm".
3. Gray, J., & Lamport, L. (2006). "Consensus on transaction commit". ACM Transactions on Database Systems.

---

**æ–‡æ¡£çŠ¶æ€**: å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2024-12-19
**ç»´æŠ¤è€…**: AI Assistant
