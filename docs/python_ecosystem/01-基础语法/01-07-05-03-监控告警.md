# ç›‘æ§å‘Šè­¦

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£ä»‹ç»è½¯ä»¶ç³»ç»Ÿç›‘æ§å‘Šè­¦çš„ç†è®ºåŸºç¡€ã€å®ç°æ–¹æ³•å’Œæœ€ä½³å®è·µï¼Œä¸ºæ„å»ºå¯é çš„ç›‘æ§ä½“ç³»æä¾›ç³»ç»ŸåŒ–çš„è§£å†³æ–¹æ¡ˆã€‚

## 1. ç†è®ºåŸºç¡€

### 1.1 ç›‘æ§ç³»ç»Ÿå®šä¹‰

**ç›‘æ§ç³»ç»Ÿ** æ˜¯ä¸€ä¸ªæŒç»­è§‚å¯Ÿã€æ”¶é›†ã€åˆ†æå’ŒæŠ¥å‘Šç³»ç»Ÿè¿è¡ŒçŠ¶æ€çš„è‡ªåŠ¨åŒ–ç³»ç»Ÿã€‚

#### 1.1.1 å½¢å¼åŒ–å®šä¹‰

è®¾ $\mathcal{M}$ ä¸ºç›‘æ§ç³»ç»Ÿï¼Œåˆ™ï¼š

$$\mathcal{M} = (S, C, A, N, R)$$

å…¶ä¸­ï¼š

- $S$: æ•°æ®æºé›†åˆ (Sources)
- $C$: æ”¶é›†å™¨é›†åˆ (Collectors)
- $A$: åˆ†æå™¨é›†åˆ (Analyzers)
- $N$: é€šçŸ¥å™¨é›†åˆ (Notifiers)
- $R$: è§„åˆ™é›†åˆ (Rules)

#### 1.1.2 ç›‘æ§æŒ‡æ ‡æ¨¡å‹

è®¾ $I$ ä¸ºæŒ‡æ ‡é›†åˆï¼Œæ¯ä¸ªæŒ‡æ ‡ $i \in I$ å®šä¹‰ä¸ºï¼š

$$i = (n, v, t, u)$$

å…¶ä¸­ï¼š

- $n$: æŒ‡æ ‡åç§°
- $v$: æŒ‡æ ‡å€¼
- $t$: æ—¶é—´æˆ³
- $u$: å•ä½

### 1.2 å‘Šè­¦ç†è®º

#### 1.2.1 å‘Šè­¦å®šä¹‰

å‘Šè­¦æ˜¯ç›‘æ§ç³»ç»Ÿæ£€æµ‹åˆ°å¼‚å¸¸æƒ…å†µæ—¶å‘å‡ºçš„é€šçŸ¥ã€‚

è®¾ $\mathcal{A}$ ä¸ºå‘Šè­¦ç³»ç»Ÿï¼Œåˆ™ï¼š

$$\mathcal{A} = (T, C, S, P)$$

å…¶ä¸­ï¼š

- $T$: é˜ˆå€¼é›†åˆ (Thresholds)
- $C$: æ¡ä»¶é›†åˆ (Conditions)
- $S$: ä¸¥é‡ç¨‹åº¦é›†åˆ (Severity)
- $P$: ç­–ç•¥é›†åˆ (Policies)

#### 1.2.2 å‘Šè­¦æ¡ä»¶

å‘Šè­¦æ¡ä»¶å¯ä»¥è¡¨ç¤ºä¸ºé€»è¾‘è¡¨è¾¾å¼ï¼š

$$C = \bigvee_{i=1}^{n} \left( \bigwedge_{j=1}^{m} (v_{ij} \circ \theta_{ij}) \right)$$

å…¶ä¸­ï¼š

- $v_{ij}$: æŒ‡æ ‡å€¼
- $\theta_{ij}$: é˜ˆå€¼
- $\circ$: æ¯”è¾ƒæ“ä½œç¬¦ ($>, <, \geq, \leq, =, \neq$)

### 1.3 æ—¶é—´åºåˆ—åˆ†æ

#### 1.3.1 æ—¶é—´åºåˆ—å®šä¹‰

æ—¶é—´åºåˆ—æ˜¯éšæ—¶é—´å˜åŒ–çš„æ•°å€¼åºåˆ—ï¼š

$$X = \{x_t : t \in T\}$$

å…¶ä¸­ $T$ æ˜¯æ—¶é—´ç´¢å¼•é›†åˆã€‚

#### 1.3.2 å¼‚å¸¸æ£€æµ‹ç†è®º

å¼‚å¸¸æ£€æµ‹åŸºäºç»Ÿè®¡æ¨¡å‹ï¼š

$$P(x_t | x_{t-1}, x_{t-2}, ..., x_{t-n}) < \alpha$$

å…¶ä¸­ $\alpha$ æ˜¯æ˜¾è‘—æ€§æ°´å¹³ã€‚

## 2. æ ¸å¿ƒç»„ä»¶å®ç°

### 2.1 ç›‘æ§ç³»ç»Ÿæ¶æ„

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Callable, Any, Union
import asyncio
import logging
from datetime import datetime, timedelta
import json
import statistics
from collections import deque
import threading
import time

class MetricType(Enum):
    """æŒ‡æ ‡ç±»å‹æšä¸¾"""
    COUNTER = "counter"
    GAUGE = "gauge"
    HISTOGRAM = "histogram"
    SUMMARY = "summary"

class Severity(Enum):
    """å‘Šè­¦ä¸¥é‡ç¨‹åº¦æšä¸¾"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

@dataclass
class Metric:
    """ç›‘æ§æŒ‡æ ‡å®šä¹‰"""
    name: str
    value: float
    timestamp: datetime
    unit: str
    type: MetricType
    labels: Dict[str, str] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            "name": self.name,
            "value": self.value,
            "timestamp": self.timestamp.isoformat(),
            "unit": self.unit,
            "type": self.type.value,
            "labels": self.labels
        }

@dataclass
class Alert:
    """å‘Šè­¦å®šä¹‰"""
    id: str
    name: str
    description: str
    severity: Severity
    timestamp: datetime
    metric_name: str
    metric_value: float
    threshold: float
    condition: str
    status: str = "active"
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "severity": self.severity.value,
            "timestamp": self.timestamp.isoformat(),
            "metric_name": self.metric_name,
            "metric_value": self.metric_value,
            "threshold": self.threshold,
            "condition": self.condition,
            "status": self.status
        }

class DataSource(ABC):
    """æ•°æ®æºæŠ½è±¡åŸºç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.is_running = False
    
    @abstractmethod
    async def collect(self) -> List[Metric]:
        """æ”¶é›†æ•°æ®"""
        pass
    
    @abstractmethod
    async def start(self):
        """å¯åŠ¨æ•°æ®æº"""
        pass
    
    @abstractmethod
    async def stop(self):
        """åœæ­¢æ•°æ®æº"""
        pass

class SystemMetricsSource(DataSource):
    """ç³»ç»ŸæŒ‡æ ‡æ•°æ®æº"""
    
    def __init__(self, name: str = "system"):
        super().__init__(name)
        self.collection_interval = 60  # ç§’
    
    async def collect(self) -> List[Metric]:
        """æ”¶é›†ç³»ç»ŸæŒ‡æ ‡"""
        import psutil
        
        metrics = []
        now = datetime.now()
        
        # CPUä½¿ç”¨ç‡
        cpu_percent = psutil.cpu_percent(interval=1)
        metrics.append(Metric(
            name="cpu_usage",
            value=cpu_percent,
            timestamp=now,
            unit="%",
            type=MetricType.GAUGE,
            labels={"source": "system"}
        ))
        
        # å†…å­˜ä½¿ç”¨ç‡
        memory = psutil.virtual_memory()
        metrics.append(Metric(
            name="memory_usage",
            value=memory.percent,
            timestamp=now,
            unit="%",
            type=MetricType.GAUGE,
            labels={"source": "system"}
        ))
        
        # ç£ç›˜ä½¿ç”¨ç‡
        disk = psutil.disk_usage('/')
        disk_percent = (disk.used / disk.total) * 100
        metrics.append(Metric(
            name="disk_usage",
            value=disk_percent,
            timestamp=now,
            unit="%",
            type=MetricType.GAUGE,
            labels={"source": "system"}
        ))
        
        return metrics
    
    async def start(self):
        """å¯åŠ¨ç³»ç»ŸæŒ‡æ ‡æ”¶é›†"""
        self.is_running = True
        logging.info(f"Started system metrics collection: {self.name}")
    
    async def stop(self):
        """åœæ­¢ç³»ç»ŸæŒ‡æ ‡æ”¶é›†"""
        self.is_running = False
        logging.info(f"Stopped system metrics collection: {self.name}")

class ApplicationMetricsSource(DataSource):
    """åº”ç”¨æŒ‡æ ‡æ•°æ®æº"""
    
    def __init__(self, name: str, metrics_callback: Callable):
        super().__init__(name)
        self.metrics_callback = metrics_callback
        self.collection_interval = 30  # ç§’
    
    async def collect(self) -> List[Metric]:
        """æ”¶é›†åº”ç”¨æŒ‡æ ‡"""
        try:
            metrics = await self.metrics_callback()
            return metrics
        except Exception as e:
            logging.error(f"Error collecting application metrics: {e}")
            return []
    
    async def start(self):
        """å¯åŠ¨åº”ç”¨æŒ‡æ ‡æ”¶é›†"""
        self.is_running = True
        logging.info(f"Started application metrics collection: {self.name}")
    
    async def stop(self):
        """åœæ­¢åº”ç”¨æŒ‡æ ‡æ”¶é›†"""
        self.is_running = False
        logging.info(f"Stopped application metrics collection: {self.name}")

class MetricsCollector:
    """æŒ‡æ ‡æ”¶é›†å™¨"""
    
    def __init__(self):
        self.sources: List[DataSource] = []
        self.metrics_buffer: deque = deque(maxlen=10000)
        self.is_running = False
    
    def add_source(self, source: DataSource):
        """æ·»åŠ æ•°æ®æº"""
        self.sources.append(source)
    
    async def collect_all(self) -> List[Metric]:
        """æ”¶é›†æ‰€æœ‰æ•°æ®æºçš„æŒ‡æ ‡"""
        all_metrics = []
        
        for source in self.sources:
            if source.is_running:
                try:
                    metrics = await source.collect()
                    all_metrics.extend(metrics)
                    
                    # æ·»åŠ åˆ°ç¼“å†²åŒº
                    for metric in metrics:
                        self.metrics_buffer.append(metric)
                        
                except Exception as e:
                    logging.error(f"Error collecting from source {source.name}: {e}")
        
        return all_metrics
    
    async def start(self):
        """å¯åŠ¨æ”¶é›†å™¨"""
        self.is_running = True
        
        # å¯åŠ¨æ‰€æœ‰æ•°æ®æº
        for source in self.sources:
            await source.start()
        
        logging.info("Metrics collector started")
    
    async def stop(self):
        """åœæ­¢æ”¶é›†å™¨"""
        self.is_running = False
        
        # åœæ­¢æ‰€æœ‰æ•°æ®æº
        for source in self.sources:
            await source.stop()
        
        logging.info("Metrics collector stopped")
    
    def get_recent_metrics(self, minutes: int = 60) -> List[Metric]:
        """è·å–æœ€è¿‘çš„æŒ‡æ ‡"""
        cutoff_time = datetime.now() - timedelta(minutes=minutes)
        return [m for m in self.metrics_buffer if m.timestamp >= cutoff_time]

class AlertRule:
    """å‘Šè­¦è§„åˆ™"""
    
    def __init__(self, name: str, condition: Callable, severity: Severity, 
                 description: str = "", cooldown: int = 300):
        self.name = name
        self.condition = condition
        self.severity = severity
        self.description = description
        self.cooldown = cooldown  # å†·å´æ—¶é—´ï¼ˆç§’ï¼‰
        self.last_triggered = None
    
    def evaluate(self, metrics: List[Metric]) -> Optional[Alert]:
        """è¯„ä¼°å‘Šè­¦è§„åˆ™"""
        try:
            # æ£€æŸ¥å†·å´æ—¶é—´
            if (self.last_triggered and 
                (datetime.now() - self.last_triggered).total_seconds() < self.cooldown):
                return None
            
            # æ‰§è¡Œæ¡ä»¶æ£€æŸ¥
            result = self.condition(metrics)
            
            if result and isinstance(result, dict):
                # åˆ›å»ºå‘Šè­¦
                alert = Alert(
                    id=f"{self.name}_{int(time.time())}",
                    name=self.name,
                    description=self.description,
                    severity=self.severity,
                    timestamp=datetime.now(),
                    metric_name=result.get('metric_name', ''),
                    metric_value=result.get('metric_value', 0),
                    threshold=result.get('threshold', 0),
                    condition=result.get('condition', '')
                )
                
                self.last_triggered = datetime.now()
                return alert
            
            return None
            
        except Exception as e:
            logging.error(f"Error evaluating alert rule {self.name}: {e}")
            return None

class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨"""
    
    def __init__(self):
        self.rules: List[AlertRule] = []
        self.active_alerts: Dict[str, Alert] = {}
        self.alert_handlers: List[Callable] = []
    
    def add_rule(self, rule: AlertRule):
        """æ·»åŠ å‘Šè­¦è§„åˆ™"""
        self.rules.append(rule)
    
    def add_handler(self, handler: Callable):
        """æ·»åŠ å‘Šè­¦å¤„ç†å™¨"""
        self.alert_handlers.append(handler)
    
    async def evaluate_rules(self, metrics: List[Metric]):
        """è¯„ä¼°æ‰€æœ‰å‘Šè­¦è§„åˆ™"""
        for rule in self.rules:
            alert = rule.evaluate(metrics)
            
            if alert:
                # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå‘Šè­¦
                if alert.id not in self.active_alerts:
                    self.active_alerts[alert.id] = alert
                    
                    # è§¦å‘å‘Šè­¦å¤„ç†å™¨
                    for handler in self.alert_handlers:
                        try:
                            await handler(alert)
                        except Exception as e:
                            logging.error(f"Error in alert handler: {e}")
    
    def resolve_alert(self, alert_id: str):
        """è§£å†³å‘Šè­¦"""
        if alert_id in self.active_alerts:
            self.active_alerts[alert_id].status = "resolved"
            del self.active_alerts[alert_id]
    
    def get_active_alerts(self) -> List[Alert]:
        """è·å–æ´»è·ƒå‘Šè­¦"""
        return list(self.active_alerts.values())

class NotificationHandler:
    """é€šçŸ¥å¤„ç†å™¨"""
    
    def __init__(self, name: str):
        self.name = name
    
    async def handle(self, alert: Alert):
        """å¤„ç†å‘Šè­¦é€šçŸ¥"""
        logging.info(f"[{self.name}] Alert: {alert.name} - {alert.description}")
        logging.info(f"Severity: {alert.severity.value}")
        logging.info(f"Metric: {alert.metric_name} = {alert.metric_value} {alert.condition} {alert.threshold}")

class EmailNotificationHandler(NotificationHandler):
    """é‚®ä»¶é€šçŸ¥å¤„ç†å™¨"""
    
    def __init__(self, smtp_server: str, username: str, password: str, 
                 recipients: List[str]):
        super().__init__("Email")
        self.smtp_server = smtp_server
        self.username = username
        self.password = password
        self.recipients = recipients
    
    async def handle(self, alert: Alert):
        """å‘é€é‚®ä»¶é€šçŸ¥"""
        # è¿™é‡Œå®ç°é‚®ä»¶å‘é€é€»è¾‘
        logging.info(f"Sending email alert to {self.recipients}")
        await super().handle(alert)

class SlackNotificationHandler(NotificationHandler):
    """Slacké€šçŸ¥å¤„ç†å™¨"""
    
    def __init__(self, webhook_url: str, channel: str = "#alerts"):
        super().__init__("Slack")
        self.webhook_url = webhook_url
        self.channel = channel
    
    async def handle(self, alert: Alert):
        """å‘é€Slacké€šçŸ¥"""
        # è¿™é‡Œå®ç°Slacké€šçŸ¥é€»è¾‘
        logging.info(f"Sending Slack alert to {self.channel}")
        await super().handle(alert)

class MonitoringSystem:
    """ç›‘æ§ç³»ç»Ÿä¸»ç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.collector = MetricsCollector()
        self.alert_manager = AlertManager()
        self.is_running = False
        self.collection_interval = 60  # ç§’
    
    def add_data_source(self, source: DataSource):
        """æ·»åŠ æ•°æ®æº"""
        self.collector.add_source(source)
    
    def add_alert_rule(self, rule: AlertRule):
        """æ·»åŠ å‘Šè­¦è§„åˆ™"""
        self.alert_manager.add_rule(rule)
    
    def add_notification_handler(self, handler: Callable):
        """æ·»åŠ é€šçŸ¥å¤„ç†å™¨"""
        self.alert_manager.add_handler(handler)
    
    async def start(self):
        """å¯åŠ¨ç›‘æ§ç³»ç»Ÿ"""
        self.is_running = True
        
        # å¯åŠ¨æ”¶é›†å™¨
        await self.collector.start()
        
        # å¯åŠ¨ç›‘æ§å¾ªç¯
        asyncio.create_task(self._monitoring_loop())
        
        logging.info(f"Monitoring system {self.name} started")
    
    async def stop(self):
        """åœæ­¢ç›‘æ§ç³»ç»Ÿ"""
        self.is_running = False
        
        # åœæ­¢æ”¶é›†å™¨
        await self.collector.stop()
        
        logging.info(f"Monitoring system {self.name} stopped")
    
    async def _monitoring_loop(self):
        """ç›‘æ§å¾ªç¯"""
        while self.is_running:
            try:
                # æ”¶é›†æŒ‡æ ‡
                metrics = await self.collector.collect_all()
                
                # è¯„ä¼°å‘Šè­¦è§„åˆ™
                await self.alert_manager.evaluate_rules(metrics)
                
                # ç­‰å¾…ä¸‹æ¬¡æ”¶é›†
                await asyncio.sleep(self.collection_interval)
                
            except Exception as e:
                logging.error(f"Error in monitoring loop: {e}")
                await asyncio.sleep(10)
    
    def get_system_status(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        return {
            "name": self.name,
            "is_running": self.is_running,
            "data_sources": len(self.collector.sources),
            "alert_rules": len(self.alert_manager.rules),
            "active_alerts": len(self.alert_manager.active_alerts),
            "recent_metrics": len(self.collector.get_recent_metrics())
        }
```

### 2.2 å‘Šè­¦è§„åˆ™å®ç°

```python
# é¢„å®šä¹‰çš„å‘Šè­¦è§„åˆ™
def create_cpu_alert_rule(threshold: float = 80.0) -> AlertRule:
    """åˆ›å»ºCPUä½¿ç”¨ç‡å‘Šè­¦è§„åˆ™"""
    def condition(metrics: List[Metric]) -> Optional[Dict[str, Any]]:
        for metric in metrics:
            if metric.name == "cpu_usage" and metric.value > threshold:
                return {
                    "metric_name": metric.name,
                    "metric_value": metric.value,
                    "threshold": threshold,
                    "condition": ">"
                }
        return None
    
    return AlertRule(
        name="High CPU Usage",
        condition=condition,
        severity=Severity.WARNING,
        description=f"CPU usage is above {threshold}%",
        cooldown=300
    )

def create_memory_alert_rule(threshold: float = 85.0) -> AlertRule:
    """åˆ›å»ºå†…å­˜ä½¿ç”¨ç‡å‘Šè­¦è§„åˆ™"""
    def condition(metrics: List[Metric]) -> Optional[Dict[str, Any]]:
        for metric in metrics:
            if metric.name == "memory_usage" and metric.value > threshold:
                return {
                    "metric_name": metric.name,
                    "metric_value": metric.value,
                    "threshold": threshold,
                    "condition": ">"
                }
        return None
    
    return AlertRule(
        name="High Memory Usage",
        condition=condition,
        severity=Severity.ERROR,
        description=f"Memory usage is above {threshold}%",
        cooldown=300
    )

def create_disk_alert_rule(threshold: float = 90.0) -> AlertRule:
    """åˆ›å»ºç£ç›˜ä½¿ç”¨ç‡å‘Šè­¦è§„åˆ™"""
    def condition(metrics: List[Metric]) -> Optional[Dict[str, Any]]:
        for metric in metrics:
            if metric.name == "disk_usage" and metric.value > threshold:
                return {
                    "metric_name": metric.name,
                    "metric_value": metric.value,
                    "threshold": threshold,
                    "condition": ">"
                }
        return None
    
    return AlertRule(
        name="High Disk Usage",
        condition=condition,
        severity=Severity.CRITICAL,
        description=f"Disk usage is above {threshold}%",
        cooldown=600
    )

def create_response_time_alert_rule(threshold: float = 1000.0) -> AlertRule:
    """åˆ›å»ºå“åº”æ—¶é—´å‘Šè­¦è§„åˆ™"""
    def condition(metrics: List[Metric]) -> Optional[Dict[str, Any]]:
        for metric in metrics:
            if metric.name == "response_time" and metric.value > threshold:
                return {
                    "metric_name": metric.name,
                    "metric_value": metric.value,
                    "threshold": threshold,
                    "condition": ">"
                }
        return None
    
    return AlertRule(
        name="High Response Time",
        condition=condition,
        severity=Severity.WARNING,
        description=f"Response time is above {threshold}ms",
        cooldown=300
    )

def create_error_rate_alert_rule(threshold: float = 5.0) -> AlertRule:
    """åˆ›å»ºé”™è¯¯ç‡å‘Šè­¦è§„åˆ™"""
    def condition(metrics: List[Metric]) -> Optional[Dict[str, Any]]:
        for metric in metrics:
            if metric.name == "error_rate" and metric.value > threshold:
                return {
                    "metric_name": metric.name,
                    "metric_value": metric.value,
                    "threshold": threshold,
                    "condition": ">"
                }
        return None
    
    return AlertRule(
        name="High Error Rate",
        condition=condition,
        severity=Severity.ERROR,
        description=f"Error rate is above {threshold}%",
        cooldown=300
    )
```

### 2.3 å¼‚å¸¸æ£€æµ‹ç®—æ³•

```python
class AnomalyDetector:
    """å¼‚å¸¸æ£€æµ‹å™¨"""
    
    def __init__(self, window_size: int = 100):
        self.window_size = window_size
        self.history: deque = deque(maxlen=window_size)
    
    def add_data_point(self, value: float):
        """æ·»åŠ æ•°æ®ç‚¹"""
        self.history.append(value)
    
    def detect_anomaly(self, current_value: float, threshold: float = 2.0) -> bool:
        """æ£€æµ‹å¼‚å¸¸"""
        if len(self.history) < self.window_size:
            return False
        
        # è®¡ç®—ç»Ÿè®¡é‡
        mean = statistics.mean(self.history)
        std = statistics.stdev(self.history) if len(self.history) > 1 else 0
        
        if std == 0:
            return False
        
        # è®¡ç®—Zåˆ†æ•°
        z_score = abs(current_value - mean) / std
        
        return z_score > threshold
    
    def get_statistics(self) -> Dict[str, float]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        if not self.history:
            return {}
        
        return {
            "mean": statistics.mean(self.history),
            "std": statistics.stdev(self.history) if len(self.history) > 1 else 0,
            "min": min(self.history),
            "max": max(self.history),
            "count": len(self.history)
        }

class TrendDetector:
    """è¶‹åŠ¿æ£€æµ‹å™¨"""
    
    def __init__(self, window_size: int = 50):
        self.window_size = window_size
        self.history: deque = deque(maxlen=window_size)
    
    def add_data_point(self, value: float, timestamp: datetime):
        """æ·»åŠ æ•°æ®ç‚¹"""
        self.history.append((timestamp, value))
    
    def detect_trend(self) -> str:
        """æ£€æµ‹è¶‹åŠ¿"""
        if len(self.history) < 3:
            return "insufficient_data"
        
        # è®¡ç®—çº¿æ€§å›å½’
        x_values = [(point[0] - self.history[0][0]).total_seconds() for point in self.history]
        y_values = [point[1] for point in self.history]
        
        # ç®€å•çš„çº¿æ€§å›å½’
        n = len(x_values)
        sum_x = sum(x_values)
        sum_y = sum(y_values)
        sum_xy = sum(x * y for x, y in zip(x_values, y_values))
        sum_x2 = sum(x * x for x in x_values)
        
        if n * sum_x2 - sum_x * sum_x == 0:
            return "no_trend"
        
        slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
        
        if abs(slope) < 0.001:
            return "stable"
        elif slope > 0:
            return "increasing"
        else:
            return "decreasing"
```

## 3. å®é™…åº”ç”¨ç¤ºä¾‹

### 3.1 Webåº”ç”¨ç›‘æ§ç³»ç»Ÿ

```python
async def web_app_monitoring_example():
    """Webåº”ç”¨ç›‘æ§ç³»ç»Ÿç¤ºä¾‹"""
    
    # åˆ›å»ºç›‘æ§ç³»ç»Ÿ
    monitoring_system = MonitoringSystem("WebApp-Monitoring")
    
    # æ·»åŠ ç³»ç»ŸæŒ‡æ ‡æ•°æ®æº
    system_source = SystemMetricsSource()
    monitoring_system.add_data_source(system_source)
    
    # æ·»åŠ åº”ç”¨æŒ‡æ ‡æ•°æ®æº
    async def collect_app_metrics():
        """æ”¶é›†åº”ç”¨æŒ‡æ ‡"""
        metrics = []
        now = datetime.now()
        
        # æ¨¡æ‹Ÿåº”ç”¨æŒ‡æ ‡
        import random
        
        # å“åº”æ—¶é—´
        response_time = random.uniform(50, 500)
        metrics.append(Metric(
            name="response_time",
            value=response_time,
            timestamp=now,
            unit="ms",
            type=MetricType.GAUGE,
            labels={"endpoint": "/api/users"}
        ))
        
        # è¯·æ±‚ç‡
        request_rate = random.uniform(100, 1000)
        metrics.append(Metric(
            name="request_rate",
            value=request_rate,
            timestamp=now,
            unit="req/s",
            type=MetricType.GAUGE,
            labels={"endpoint": "/api/users"}
        ))
        
        # é”™è¯¯ç‡
        error_rate = random.uniform(0, 10)
        metrics.append(Metric(
            name="error_rate",
            value=error_rate,
            timestamp=now,
            unit="%",
            type=MetricType.GAUGE,
            labels={"endpoint": "/api/users"}
        ))
        
        return metrics
    
    app_source = ApplicationMetricsSource("webapp", collect_app_metrics)
    monitoring_system.add_data_source(app_source)
    
    # æ·»åŠ å‘Šè­¦è§„åˆ™
    monitoring_system.add_alert_rule(create_cpu_alert_rule(70.0))
    monitoring_system.add_alert_rule(create_memory_alert_rule(80.0))
    monitoring_system.add_alert_rule(create_disk_alert_rule(85.0))
    monitoring_system.add_alert_rule(create_response_time_alert_rule(800.0))
    monitoring_system.add_alert_rule(create_error_rate_alert_rule(3.0))
    
    # æ·»åŠ é€šçŸ¥å¤„ç†å™¨
    email_handler = EmailNotificationHandler(
        smtp_server="smtp.gmail.com",
        username="admin@example.com",
        password="password",
        recipients=["admin@example.com", "ops@example.com"]
    )
    monitoring_system.add_notification_handler(email_handler.handle)
    
    slack_handler = SlackNotificationHandler(
        webhook_url="https://hooks.slack.com/services/...",
        channel="#alerts"
    )
    monitoring_system.add_notification_handler(slack_handler.handle)
    
    # å¯åŠ¨ç›‘æ§ç³»ç»Ÿ
    await monitoring_system.start()
    
    # è¿è¡Œä¸€æ®µæ—¶é—´
    await asyncio.sleep(300)  # 5åˆ†é’Ÿ
    
    # è·å–ç³»ç»ŸçŠ¶æ€
    status = monitoring_system.get_system_status()
    print(json.dumps(status, indent=2, default=str))
    
    # è·å–æ´»è·ƒå‘Šè­¦
    active_alerts = monitoring_system.alert_manager.get_active_alerts()
    print(f"Active alerts: {len(active_alerts)}")
    for alert in active_alerts:
        print(f"- {alert.name}: {alert.description}")
    
    # åœæ­¢ç›‘æ§ç³»ç»Ÿ
    await monitoring_system.stop()

# è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(web_app_monitoring_example())
```

### 3.2 å¾®æœåŠ¡ç›‘æ§ç³»ç»Ÿ

```python
async def microservice_monitoring_example():
    """å¾®æœåŠ¡ç›‘æ§ç³»ç»Ÿç¤ºä¾‹"""
    
    # åˆ›å»ºå¤šä¸ªæœåŠ¡çš„ç›‘æ§ç³»ç»Ÿ
    services = ["user-service", "order-service", "payment-service"]
    monitoring_systems = {}
    
    for service in services:
        # åˆ›å»ºç›‘æ§ç³»ç»Ÿ
        monitoring_system = MonitoringSystem(f"{service}-Monitoring")
        
        # æ·»åŠ ç³»ç»ŸæŒ‡æ ‡
        system_source = SystemMetricsSource()
        monitoring_system.add_data_source(system_source)
        
        # æ·»åŠ æœåŠ¡ç‰¹å®šæŒ‡æ ‡
        async def create_service_metrics(service_name: str):
            async def collect_service_metrics():
                metrics = []
                now = datetime.now()
                
                import random
                
                # æœåŠ¡å¥åº·çŠ¶æ€
                health_score = random.uniform(80, 100)
                metrics.append(Metric(
                    name="health_score",
                    value=health_score,
                    timestamp=now,
                    unit="%",
                    type=MetricType.GAUGE,
                    labels={"service": service_name}
                ))
                
                # æœåŠ¡å“åº”æ—¶é—´
                response_time = random.uniform(20, 200)
                metrics.append(Metric(
                    name="service_response_time",
                    value=response_time,
                    timestamp=now,
                    unit="ms",
                    type=MetricType.GAUGE,
                    labels={"service": service_name}
                ))
                
                return metrics
            
            return collect_service_metrics
        
        service_source = ApplicationMetricsSource(
            service, 
            await create_service_metrics(service)
        )
        monitoring_system.add_data_source(service_source)
        
        # æ·»åŠ å‘Šè­¦è§„åˆ™
        monitoring_system.add_alert_rule(create_cpu_alert_rule(75.0))
        monitoring_system.add_alert_rule(create_memory_alert_rule(85.0))
        
        # æœåŠ¡ç‰¹å®šå‘Šè­¦è§„åˆ™
        def create_health_alert_rule(service_name: str, threshold: float = 90.0):
            def condition(metrics: List[Metric]) -> Optional[Dict[str, Any]]:
                for metric in metrics:
                    if (metric.name == "health_score" and 
                        metric.labels.get("service") == service_name and
                        metric.value < threshold):
                        return {
                            "metric_name": metric.name,
                            "metric_value": metric.value,
                            "threshold": threshold,
                            "condition": "<"
                        }
                return None
            
            return AlertRule(
                name=f"{service_name} Health Alert",
                condition=condition,
                severity=Severity.CRITICAL,
                description=f"{service_name} health score is below {threshold}%",
                cooldown=300
            )
        
        monitoring_system.add_alert_rule(create_health_alert_rule(service))
        
        # æ·»åŠ é€šçŸ¥å¤„ç†å™¨
        notification_handler = NotificationHandler(f"{service}-Handler")
        monitoring_system.add_notification_handler(notification_handler.handle)
        
        monitoring_systems[service] = monitoring_system
    
    # å¯åŠ¨æ‰€æœ‰ç›‘æ§ç³»ç»Ÿ
    start_tasks = [system.start() for system in monitoring_systems.values()]
    await asyncio.gather(*start_tasks)
    
    # è¿è¡Œä¸€æ®µæ—¶é—´
    await asyncio.sleep(180)  # 3åˆ†é’Ÿ
    
    # è·å–æ‰€æœ‰ç³»ç»ŸçŠ¶æ€
    for service, system in monitoring_systems.items():
        status = system.get_system_status()
        print(f"{service} status: {status}")
    
    # åœæ­¢æ‰€æœ‰ç›‘æ§ç³»ç»Ÿ
    stop_tasks = [system.stop() for system in monitoring_systems.values()]
    await asyncio.gather(*stop_tasks)
```

## 4. æœ€ä½³å®è·µ

### 4.1 ç›‘æ§ç­–ç•¥

1. **åˆ†å±‚ç›‘æ§**: åŸºç¡€è®¾æ–½å±‚ã€åº”ç”¨å±‚ã€ä¸šåŠ¡å±‚
2. **å…³é”®æŒ‡æ ‡**: é€‰æ‹©æœ€é‡è¦çš„æŒ‡æ ‡è¿›è¡Œç›‘æ§
3. **åˆç†é˜ˆå€¼**: è®¾ç½®åˆç†çš„å‘Šè­¦é˜ˆå€¼
4. **è¶‹åŠ¿åˆ†æ**: å…³æ³¨æŒ‡æ ‡çš„å˜åŒ–è¶‹åŠ¿

### 4.2 å‘Šè­¦è®¾è®¡

1. **é¿å…å‘Šè­¦ç–²åŠ³**: åˆç†è®¾ç½®å†·å´æ—¶é—´å’Œé˜ˆå€¼
2. **åˆ†çº§å‘Šè­¦**: æ ¹æ®ä¸¥é‡ç¨‹åº¦åˆ†çº§å¤„ç†
3. **è‡ªåŠ¨æ¢å¤**: å®ç°è‡ªåŠ¨æ¢å¤æœºåˆ¶
4. **å‘Šè­¦èšåˆ**: é¿å…é‡å¤å‘Šè­¦

### 4.3 æ•°æ®ç®¡ç†

1. **æ•°æ®ä¿ç•™**: åˆç†è®¾ç½®æ•°æ®ä¿ç•™æœŸé™
2. **æ•°æ®å‹ç¼©**: å¯¹å†å²æ•°æ®è¿›è¡Œå‹ç¼©
3. **æ•°æ®å¤‡ä»½**: é‡è¦ç›‘æ§æ•°æ®çš„å¤‡ä»½
4. **æ•°æ®å®‰å…¨**: ä¿æŠ¤ç›‘æ§æ•°æ®çš„å®‰å…¨

## 5. æ€§èƒ½ä¼˜åŒ–

### 5.1 æ•°æ®æ”¶é›†ä¼˜åŒ–

```python
class OptimizedMetricsCollector(MetricsCollector):
    """ä¼˜åŒ–çš„æŒ‡æ ‡æ”¶é›†å™¨"""
    
    def __init__(self, batch_size: int = 100):
        super().__init__()
        self.batch_size = batch_size
        self.batch_buffer: List[Metric] = []
    
    async def collect_all(self) -> List[Metric]:
        """æ‰¹é‡æ”¶é›†æŒ‡æ ‡"""
        all_metrics = []
        
        # å¹¶è¡Œæ”¶é›†æ‰€æœ‰æ•°æ®æº
        tasks = []
        for source in self.sources:
            if source.is_running:
                tasks.append(source.collect())
        
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, list):
                    all_metrics.extend(result)
                elif isinstance(result, Exception):
                    logging.error(f"Collection error: {result}")
        
        # æ‰¹é‡å¤„ç†
        self.batch_buffer.extend(all_metrics)
        
        if len(self.batch_buffer) >= self.batch_size:
            # æ‰¹é‡æ·»åŠ åˆ°ç¼“å†²åŒº
            for metric in self.batch_buffer:
                self.metrics_buffer.append(metric)
            
            self.batch_buffer.clear()
        
        return all_metrics
```

### 5.2 å‘Šè­¦ä¼˜åŒ–

```python
class OptimizedAlertManager(AlertManager):
    """ä¼˜åŒ–çš„å‘Šè­¦ç®¡ç†å™¨"""
    
    def __init__(self, evaluation_interval: int = 60):
        super().__init__()
        self.evaluation_interval = evaluation_interval
        self.last_evaluation = {}
    
    async def evaluate_rules(self, metrics: List[Metric]):
        """ä¼˜åŒ–çš„è§„åˆ™è¯„ä¼°"""
        current_time = datetime.now()
        
        for rule in self.rules:
            # æ£€æŸ¥è¯„ä¼°é—´éš”
            if (rule.name in self.last_evaluation and
                (current_time - self.last_evaluation[rule.name]).total_seconds() < self.evaluation_interval):
                continue
            
            alert = rule.evaluate(metrics)
            
            if alert:
                if alert.id not in self.active_alerts:
                    self.active_alerts[alert.id] = alert
                    
                    # å¼‚æ­¥å¤„ç†å‘Šè­¦
                    asyncio.create_task(self._handle_alert_async(alert))
            
            self.last_evaluation[rule.name] = current_time
    
    async def _handle_alert_async(self, alert: Alert):
        """å¼‚æ­¥å¤„ç†å‘Šè­¦"""
        for handler in self.alert_handlers:
            try:
                await handler(alert)
            except Exception as e:
                logging.error(f"Error in alert handler: {e}")
```

## 6. æ€»ç»“

ç›‘æ§å‘Šè­¦ç³»ç»Ÿæ˜¯ç°ä»£è½¯ä»¶å·¥ç¨‹çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œé€šè¿‡å®æ—¶ç›‘æ§ç³»ç»ŸçŠ¶æ€ã€åŠæ—¶å‘ç°é—®é¢˜å¹¶å¿«é€Ÿå“åº”ï¼Œæ˜¾è‘—æé«˜äº†ç³»ç»Ÿçš„å¯é æ€§å’Œå¯ç”¨æ€§ã€‚æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ç†è®ºåŸºç¡€ã€å®ç°æ–¹æ³•å’Œæœ€ä½³å®è·µï¼Œä¸ºæ„å»ºé«˜è´¨é‡çš„ç›‘æ§å‘Šè­¦ç³»ç»Ÿæä¾›äº†ç³»ç»ŸåŒ–çš„è§£å†³æ–¹æ¡ˆã€‚

### å…³é”®è¦ç‚¹

1. **ç†è®ºåŸºç¡€**: ä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰å’Œæ•°å­¦æ¨¡å‹
2. **å®ç°æ–¹æ³•**: å®Œæ•´çš„Pythonå®ç°å’Œä»£ç ç¤ºä¾‹
3. **æœ€ä½³å®è·µ**: ç»è¿‡éªŒè¯çš„è®¾è®¡åŸåˆ™å’Œç­–ç•¥
4. **æ€§èƒ½ä¼˜åŒ–**: é«˜æ•ˆçš„æ”¶é›†å’Œå¤„ç†æœºåˆ¶
5. **å¯æ‰©å±•æ€§**: æ”¯æŒå¤šç§æ•°æ®æºå’Œå‘Šè­¦è§„åˆ™

### åº”ç”¨ä»·å€¼

1. **æé«˜å¯é æ€§**: åŠæ—¶å‘ç°å’Œå¤„ç†é—®é¢˜
2. **é™ä½é£é™©**: é¢„é˜²æ€§ç›‘æ§å’Œå‘Šè­¦
3. **æå‡æ•ˆç‡**: è‡ªåŠ¨åŒ–ç›‘æ§å’Œå“åº”
4. **å¢å¼ºå¯è§‚æµ‹æ€§**: å®Œæ•´çš„ç³»ç»ŸçŠ¶æ€è§†å›¾

---

**ç›¸å…³æ–‡æ¡£**:

- [æ€§èƒ½æµ‹è¯•ç­–ç•¥](../07-04-æµ‹è¯•ç­–ç•¥/07-04-03-æ€§èƒ½æµ‹è¯•ç­–ç•¥.md)
- [å®‰å…¨æµ‹è¯•ç­–ç•¥](../07-04-æµ‹è¯•ç­–ç•¥/07-04-04-å®‰å…¨æµ‹è¯•ç­–ç•¥.md)
- [CI/CDæµæ°´çº¿](./07-05-02-CI-CDæµæ°´çº¿.md)
