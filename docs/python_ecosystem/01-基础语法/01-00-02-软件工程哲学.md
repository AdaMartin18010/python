# 00-02 è½¯ä»¶å·¥ç¨‹å“²å­¦

## ğŸ“‹ ç›®å½•

- [00-02 è½¯ä»¶å·¥ç¨‹å“²å­¦](#00-02-è½¯ä»¶å·¥ç¨‹å“²å­¦)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [1. è½¯ä»¶å·¥ç¨‹çš„æœ¬è´¨](#1-è½¯ä»¶å·¥ç¨‹çš„æœ¬è´¨)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 è½¯ä»¶å·¥ç¨‹çš„å“²å­¦åŸºç¡€](#12-è½¯ä»¶å·¥ç¨‹çš„å“²å­¦åŸºç¡€)
      - [1.2.1 ç³»ç»ŸåŒ–æ€ç»´](#121-ç³»ç»ŸåŒ–æ€ç»´)
      - [1.2.2 å·¥ç¨‹åŒ–æ€ç»´](#122-å·¥ç¨‹åŒ–æ€ç»´)
  - [2. è½¯ä»¶å·¥ç¨‹çš„ä»·å€¼å“²å­¦](#2-è½¯ä»¶å·¥ç¨‹çš„ä»·å€¼å“²å­¦)
    - [2.1 è´¨é‡ä»·å€¼](#21-è´¨é‡ä»·å€¼)
    - [2.2 æ•ˆç‡ä»·å€¼](#22-æ•ˆç‡ä»·å€¼)
  - [3. è½¯ä»¶å·¥ç¨‹ä¼¦ç†å“²å­¦](#3-è½¯ä»¶å·¥ç¨‹ä¼¦ç†å“²å­¦)
    - [3.1 è´£ä»»ä¼¦ç†](#31-è´£ä»»ä¼¦ç†)
    - [3.2 å…¬å¹³ä¼¦ç†](#32-å…¬å¹³ä¼¦ç†)
  - [4. Pythonå®ç°ç¤ºä¾‹](#4-pythonå®ç°ç¤ºä¾‹)
    - [4.1 ç³»ç»ŸåŒ–æ€ç»´å®ç°](#41-ç³»ç»ŸåŒ–æ€ç»´å®ç°)
    - [4.2 å·¥ç¨‹åŒ–æ€ç»´å®ç°](#42-å·¥ç¨‹åŒ–æ€ç»´å®ç°)
    - [4.3 ä¼¦ç†å“²å­¦å®ç°](#43-ä¼¦ç†å“²å­¦å®ç°)
  - [5. è½¯ä»¶å·¥ç¨‹å“²å­¦çš„åº”ç”¨](#5-è½¯ä»¶å·¥ç¨‹å“²å­¦çš„åº”ç”¨)
    - [5.1 é¡¹ç›®è¯„ä¼°æ¡†æ¶](#51-é¡¹ç›®è¯„ä¼°æ¡†æ¶)
  - [6. æ€»ç»“](#6-æ€»ç»“)
  - [7. ç›¸å…³é“¾æ¥](#7-ç›¸å…³é“¾æ¥)

## æ¦‚è¿°

è½¯ä»¶å·¥ç¨‹å“²å­¦æ¢è®¨è½¯ä»¶å¼€å‘çš„æœ¬è´¨è§„å¾‹ã€ä»·å€¼å–å‘å’Œä¼¦ç†å‡†åˆ™ï¼Œä¸ºè½¯ä»¶å·¥ç¨‹å®è·µæä¾›å“²å­¦æŒ‡å¯¼ã€‚

## 1. è½¯ä»¶å·¥ç¨‹çš„æœ¬è´¨

### 1.1 æ¦‚å¿µå®šä¹‰

**è½¯ä»¶å·¥ç¨‹**ï¼ˆSoftware Engineeringï¼‰æ˜¯åº”ç”¨ç³»ç»ŸåŒ–ã€è§„èŒƒåŒ–ã€å¯é‡åŒ–çš„æ–¹æ³•æ¥å¼€å‘ã€è¿è¡Œå’Œç»´æŠ¤è½¯ä»¶çš„å­¦ç§‘ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾ $SE$ ä¸ºè½¯ä»¶å·¥ç¨‹è¿‡ç¨‹ï¼Œ$R$ ä¸ºéœ€æ±‚ç©ºé—´ï¼Œ$D$ ä¸ºè®¾è®¡ç©ºé—´ï¼Œ$I$ ä¸ºå®ç°ç©ºé—´ï¼Œ$T$ ä¸ºæµ‹è¯•ç©ºé—´ï¼Œåˆ™ï¼š

$$SE: R \times D \times I \times T \rightarrow S$$

å…¶ä¸­ $S$ ä¸ºè½¯ä»¶äº§å“ç©ºé—´ã€‚

### 1.2 è½¯ä»¶å·¥ç¨‹çš„å“²å­¦åŸºç¡€

#### 1.2.1 ç³»ç»ŸåŒ–æ€ç»´

**ç³»ç»ŸåŒ–æ€ç»´**æ˜¯è½¯ä»¶å·¥ç¨‹çš„æ ¸å¿ƒå“²å­¦ï¼Œå¼ºè°ƒæ•´ä½“æ€§ã€å±‚æ¬¡æ€§å’Œå…³è”æ€§ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
è®¾ $S$ ä¸ºè½¯ä»¶ç³»ç»Ÿï¼Œ$C_i$ ä¸ºç»„ä»¶ï¼Œ$R_{ij}$ ä¸ºç»„ä»¶é—´å…³ç³»ï¼Œåˆ™ï¼š

$$S = \langle \{C_i\}, \{R_{ij}\} \rangle$$

æ»¡è¶³ï¼š

- $\forall i: C_i \in S$ ï¼ˆç»„ä»¶å±äºç³»ç»Ÿï¼‰
- $\forall i,j: R_{ij} \subseteq C_i \times C_j$ ï¼ˆå…³ç³»å®šä¹‰ï¼‰

#### 1.2.2 å·¥ç¨‹åŒ–æ€ç»´

**å·¥ç¨‹åŒ–æ€ç»´**å¼ºè°ƒå¯é¢„æµ‹æ€§ã€å¯é‡å¤æ€§å’Œå¯æ§åˆ¶æ€§ã€‚

**æ•°å­¦å®šä¹‰**ï¼š
è®¾ $P$ ä¸ºé¡¹ç›®ï¼Œ$M$ ä¸ºæ–¹æ³•ï¼Œ$T$ ä¸ºæ—¶é—´ï¼Œ$Q$ ä¸ºè´¨é‡ï¼Œåˆ™ï¼š

$$Q(P) = f(M, T, R)$$

å…¶ä¸­ $R$ ä¸ºèµ„æºï¼Œ$f$ ä¸ºè´¨é‡å‡½æ•°ã€‚

## 2. è½¯ä»¶å·¥ç¨‹çš„ä»·å€¼å“²å­¦

### 2.1 è´¨é‡ä»·å€¼

**è½¯ä»¶è´¨é‡**æ˜¯è½¯ä»¶å·¥ç¨‹çš„æ ¸å¿ƒä»·å€¼ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$Q = \sum_{i=1}^{n} w_i \cdot q_i$$

å…¶ä¸­ï¼š

- $q_i$ ä¸ºç¬¬ $i$ ä¸ªè´¨é‡å±æ€§
- $w_i$ ä¸ºæƒé‡
- $Q$ ä¸ºæ€»ä½“è´¨é‡

### 2.2 æ•ˆç‡ä»·å€¼

**å¼€å‘æ•ˆç‡**æ˜¯è½¯ä»¶å·¥ç¨‹çš„é‡è¦ä»·å€¼ã€‚

**æ•°å­¦å®šä¹‰**ï¼š
$$E = \frac{F}{T \cdot R}$$

å…¶ä¸­ï¼š

- $F$ ä¸ºåŠŸèƒ½ç‚¹æ•°
- $T$ ä¸ºå¼€å‘æ—¶é—´
- $R$ ä¸ºèµ„æºæŠ•å…¥
- $E$ ä¸ºæ•ˆç‡

## 3. è½¯ä»¶å·¥ç¨‹ä¼¦ç†å“²å­¦

### 3.1 è´£ä»»ä¼¦ç†

è½¯ä»¶å·¥ç¨‹å¸ˆå¯¹å…¶äº§å“è´Ÿæœ‰é“å¾·è´£ä»»ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾ $A$ ä¸ºè¡Œä¸ºï¼Œ$C$ ä¸ºåæœï¼Œ$R$ ä¸ºè´£ä»»ï¼Œåˆ™ï¼š

$$R(A) = \sum_{i=1}^{n} p_i \cdot C_i(A)$$

å…¶ä¸­ $p_i$ ä¸ºæ¦‚ç‡ï¼Œ$C_i$ ä¸ºç¬¬ $i$ ä¸ªåæœã€‚

### 3.2 å…¬å¹³ä¼¦ç†

è½¯ä»¶åº”è¯¥å…¬å¹³åœ°æœåŠ¡æ‰€æœ‰ç”¨æˆ·ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$F = \min_{i,j} \frac{U_i}{U_j}$$

å…¶ä¸­ $U_i$ ä¸ºç¬¬ $i$ ä¸ªç”¨æˆ·çš„æ•ˆç”¨ã€‚

## 4. Pythonå®ç°ç¤ºä¾‹

### 4.1 ç³»ç»ŸåŒ–æ€ç»´å®ç°

```python
from typing import Dict, List, Any, Set
from dataclasses import dataclass
from abc import ABC, abstractmethod
import networkx as nx

@dataclass
class Component:
    """ç³»ç»Ÿç»„ä»¶"""
    name: str
    functionality: str
    dependencies: Set[str]
    complexity: float
    
    def __post_init__(self):
        if not self.name:
            raise ValueError("Component must have a name")

class Relationship:
    """ç»„ä»¶é—´å…³ç³»"""
    
    def __init__(self, source: str, target: str, relationship_type: str):
        self.source = source
        self.target = target
        self.relationship_type = relationship_type
    
    def __str__(self) -> str:
        return f"{self.source} --{self.relationship_type}--> {self.target}"

class SoftwareSystem:
    """è½¯ä»¶ç³»ç»Ÿ"""
    
    def __init__(self, name: str):
        self.name = name
        self.components: Dict[str, Component] = {}
        self.relationships: List[Relationship] = []
        self.graph = nx.DiGraph()
    
    def add_component(self, component: Component):
        """æ·»åŠ ç»„ä»¶"""
        self.components[component.name] = component
        self.graph.add_node(component.name, **component.__dict__)
    
    def add_relationship(self, relationship: Relationship):
        """æ·»åŠ å…³ç³»"""
        self.relationships.append(relationship)
        self.graph.add_edge(
            relationship.source, 
            relationship.target, 
            type=relationship.relationship_type
        )
    
    def get_system_complexity(self) -> float:
        """è®¡ç®—ç³»ç»Ÿå¤æ‚åº¦"""
        return sum(comp.complexity for comp in self.components.values())
    
    def get_dependency_cycles(self) -> List[List[str]]:
        """æ£€æµ‹ä¾èµ–å¾ªç¯"""
        try:
            return list(nx.simple_cycles(self.graph))
        except nx.NetworkXNoCycle:
            return []
    
    def get_component_metrics(self) -> Dict[str, Dict[str, Any]]:
        """è·å–ç»„ä»¶æŒ‡æ ‡"""
        metrics = {}
        for name, component in self.components.items():
            in_degree = self.graph.in_degree(name)
            out_degree = self.graph.out_degree(name)
            metrics[name] = {
                'complexity': component.complexity,
                'in_degree': in_degree,
                'out_degree': out_degree,
                'total_degree': in_degree + out_degree
            }
        return metrics

# å…·ä½“ç»„ä»¶å®ç°
class DatabaseComponent(Component):
    """æ•°æ®åº“ç»„ä»¶"""
    def __init__(self):
        super().__init__(
            name="database",
            functionality="Data storage and retrieval",
            dependencies=set(),
            complexity=0.8
        )

class BusinessLogicComponent(Component):
    """ä¸šåŠ¡é€»è¾‘ç»„ä»¶"""
    def __init__(self):
        super().__init__(
            name="business_logic",
            functionality="Business rules and processing",
            dependencies={"database"},
            complexity=0.6
        )

class UserInterfaceComponent(Component):
    """ç”¨æˆ·ç•Œé¢ç»„ä»¶"""
    def __init__(self):
        super().__init__(
            name="ui",
            functionality="User interaction",
            dependencies={"business_logic"},
            complexity=0.4
        )

def demonstrate_systematic_thinking():
    """æ¼”ç¤ºç³»ç»ŸåŒ–æ€ç»´"""
    system = SoftwareSystem("E-commerce System")
    
    # æ·»åŠ ç»„ä»¶
    system.add_component(DatabaseComponent())
    system.add_component(BusinessLogicComponent())
    system.add_component(UserInterfaceComponent())
    
    # æ·»åŠ å…³ç³»
    system.add_relationship(Relationship("business_logic", "database", "uses"))
    system.add_relationship(Relationship("ui", "business_logic", "calls"))
    
    # åˆ†æç³»ç»Ÿ
    print(f"System complexity: {system.get_system_complexity()}")
    print(f"Dependency cycles: {system.get_dependency_cycles()}")
    print(f"Component metrics: {system.get_component_metrics()}")
    
    return system

if __name__ == "__main__":
    demonstrate_systematic_thinking()
```

### 4.2 å·¥ç¨‹åŒ–æ€ç»´å®ç°

```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import math

@dataclass
class ProjectMetrics:
    """é¡¹ç›®æŒ‡æ ‡"""
    function_points: int
    development_time: timedelta
    team_size: int
    defects: int
    cost: float

class EngineeringMethod:
    """å·¥ç¨‹åŒ–æ–¹æ³•"""
    
    def __init__(self, name: str, efficiency_factor: float):
        self.name = name
        self.efficiency_factor = efficiency_factor
    
    def calculate_quality(self, metrics: ProjectMetrics) -> float:
        """è®¡ç®—è´¨é‡"""
        defect_rate = metrics.defects / metrics.function_points
        return max(0, 1 - defect_rate)
    
    def calculate_efficiency(self, metrics: ProjectMetrics) -> float:
        """è®¡ç®—æ•ˆç‡"""
        return (metrics.function_points / 
                (metrics.development_time.days * metrics.team_size) * 
                self.efficiency_factor)

class SoftwareProject:
    """è½¯ä»¶é¡¹ç›®"""
    
    def __init__(self, name: str):
        self.name = name
        self.metrics: Optional[ProjectMetrics] = None
        self.methods: List[EngineeringMethod] = []
        self.start_date: Optional[datetime] = None
        self.end_date: Optional[datetime] = None
    
    def add_method(self, method: EngineeringMethod):
        """æ·»åŠ å·¥ç¨‹æ–¹æ³•"""
        self.methods.append(method)
    
    def set_metrics(self, metrics: ProjectMetrics):
        """è®¾ç½®é¡¹ç›®æŒ‡æ ‡"""
        self.metrics = metrics
    
    def calculate_project_quality(self) -> Dict[str, float]:
        """è®¡ç®—é¡¹ç›®è´¨é‡"""
        if not self.metrics or not self.methods:
            return {}
        
        results = {}
        for method in self.methods:
            quality = method.calculate_quality(self.metrics)
            efficiency = method.calculate_efficiency(self.metrics)
            results[method.name] = {
                'quality': quality,
                'efficiency': efficiency,
                'overall_score': (quality + efficiency) / 2
            }
        
        return results
    
    def predict_completion_time(self, remaining_functions: int) -> timedelta:
        """é¢„æµ‹å®Œæˆæ—¶é—´"""
        if not self.metrics or not self.methods:
            return timedelta(days=0)
        
        avg_efficiency = sum(
            method.calculate_efficiency(self.metrics) 
            for method in self.methods
        ) / len(self.methods)
        
        if avg_efficiency <= 0:
            return timedelta(days=0)
        
        days_needed = remaining_functions / (avg_efficiency * self.metrics.team_size)
        return timedelta(days=math.ceil(days_needed))

# å…·ä½“æ–¹æ³•å®ç°
class AgileMethod(EngineeringMethod):
    """æ•æ·æ–¹æ³•"""
    def __init__(self):
        super().__init__("Agile", 1.2)

class WaterfallMethod(EngineeringMethod):
    """ç€‘å¸ƒæ–¹æ³•"""
    def __init__(self):
        super().__init__("Waterfall", 0.8)

class DevOpsMethod(EngineeringMethod):
    """DevOpsæ–¹æ³•"""
    def __init__(self):
        super().__init__("DevOps", 1.5)

def demonstrate_engineering_thinking():
    """æ¼”ç¤ºå·¥ç¨‹åŒ–æ€ç»´"""
    project = SoftwareProject("E-commerce Platform")
    
    # æ·»åŠ å·¥ç¨‹æ–¹æ³•
    project.add_method(AgileMethod())
    project.add_method(WaterfallMethod())
    project.add_method(DevOpsMethod())
    
    # è®¾ç½®é¡¹ç›®æŒ‡æ ‡
    metrics = ProjectMetrics(
        function_points=1000,
        development_time=timedelta(days=180),
        team_size=8,
        defects=50,
        cost=500000.0
    )
    project.set_metrics(metrics)
    
    # åˆ†æé¡¹ç›®
    results = project.calculate_project_quality()
    print("Project Quality Analysis:")
    for method_name, scores in results.items():
        print(f"{method_name}:")
        print(f"  Quality: {scores['quality']:.3f}")
        print(f"  Efficiency: {scores['efficiency']:.3f}")
        print(f"  Overall Score: {scores['overall_score']:.3f}")
    
    # é¢„æµ‹å®Œæˆæ—¶é—´
    remaining_functions = 200
    completion_time = project.predict_completion_time(remaining_functions)
    print(f"Predicted completion time for {remaining_functions} functions: {completion_time.days} days")
    
    return project

if __name__ == "__main__":
    demonstrate_engineering_thinking()
```

### 4.3 ä¼¦ç†å“²å­¦å®ç°

```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import json

class EthicalPrinciple(Enum):
    """ä¼¦ç†åŸåˆ™"""
    RESPONSIBILITY = "responsibility"
    FAIRNESS = "fairness"
    TRANSPARENCY = "transparency"
    PRIVACY = "privacy"
    SECURITY = "security"

@dataclass
class EthicalImpact:
    """ä¼¦ç†å½±å“"""
    principle: EthicalPrinciple
    impact_score: float  # 0-1, 1ä¸ºæœ€ç§¯æ
    description: str
    affected_stakeholders: List[str]

class EthicalAnalyzer:
    """ä¼¦ç†åˆ†æå™¨"""
    
    def __init__(self):
        self.impact_history: List[EthicalImpact] = []
    
    def analyze_feature(self, feature_name: str, feature_description: str) -> Dict[str, float]:
        """åˆ†æåŠŸèƒ½ç‰¹æ€§çš„ä¼¦ç†å½±å“"""
        impacts = []
        
        # è´£ä»»ä¼¦ç†åˆ†æ
        if "user data" in feature_description.lower():
            impacts.append(EthicalImpact(
                principle=EthicalPrinciple.RESPONSIBILITY,
                impact_score=0.8,
                description="Handles user data responsibly",
                affected_stakeholders=["users", "developers"]
            ))
        
        # å…¬å¹³æ€§åˆ†æ
        if "algorithm" in feature_description.lower():
            impacts.append(EthicalImpact(
                principle=EthicalPrinciple.FAIRNESS,
                impact_score=0.6,
                description="Algorithmic decision making",
                affected_stakeholders=["users", "society"]
            ))
        
        # é€æ˜åº¦åˆ†æ
        if "black box" in feature_description.lower():
            impacts.append(EthicalImpact(
                principle=EthicalPrinciple.TRANSPARENCY,
                impact_score=0.3,
                description="Lacks transparency",
                affected_stakeholders=["users", "regulators"]
            ))
        
        # éšç§åˆ†æ
        if "personal" in feature_description.lower():
            impacts.append(EthicalImpact(
                principle=EthicalPrinciple.PRIVACY,
                impact_score=0.7,
                description="Involves personal information",
                affected_stakeholders=["users"]
            ))
        
        # å®‰å…¨æ€§åˆ†æ
        if "security" in feature_description.lower():
            impacts.append(EthicalImpact(
                principle=EthicalPrinciple.SECURITY,
                impact_score=0.9,
                description="Security-focused feature",
                affected_stakeholders=["users", "organization"]
            ))
        
        self.impact_history.extend(impacts)
        
        # è®¡ç®—å„åŸåˆ™çš„ç»¼åˆå¾—åˆ†
        principle_scores = {}
        for principle in EthicalPrinciple:
            principle_impacts = [imp for imp in impacts if imp.principle == principle]
            if principle_impacts:
                principle_scores[principle.value] = sum(
                    imp.impact_score for imp in principle_impacts
                ) / len(principle_impacts)
            else:
                principle_scores[principle.value] = 0.5  # ä¸­æ€§å½±å“
        
        return principle_scores
    
    def get_overall_ethical_score(self) -> float:
        """è·å–æ•´ä½“ä¼¦ç†å¾—åˆ†"""
        if not self.impact_history:
            return 0.5
        
        return sum(imp.impact_score for imp in self.impact_history) / len(self.impact_history)
    
    def generate_ethical_report(self) -> Dict[str, Any]:
        """ç”Ÿæˆä¼¦ç†æŠ¥å‘Š"""
        report = {
            'overall_score': self.get_overall_ethical_score(),
            'principle_breakdown': {},
            'recommendations': []
        }
        
        # æŒ‰åŸåˆ™åˆ†ç»„åˆ†æ
        for principle in EthicalPrinciple:
            principle_impacts = [imp for imp in self.impact_history if imp.principle == principle]
            if principle_impacts:
                avg_score = sum(imp.impact_score for imp in principle_impacts) / len(principle_impacts)
                report['principle_breakdown'][principle.value] = {
                    'score': avg_score,
                    'count': len(principle_impacts),
                    'descriptions': [imp.description for imp in principle_impacts]
                }
        
        # ç”Ÿæˆå»ºè®®
        for principle, data in report['principle_breakdown'].items():
            if data['score'] < 0.5:
                report['recommendations'].append(
                    f"Improve {principle} considerations in feature design"
                )
        
        return report

class EthicalSoftwareSystem:
    """ä¼¦ç†è½¯ä»¶ç³»ç»Ÿ"""
    
    def __init__(self, name: str):
        self.name = name
        self.features: Dict[str, str] = {}
        self.analyzer = EthicalAnalyzer()
    
    def add_feature(self, feature_name: str, description: str):
        """æ·»åŠ åŠŸèƒ½ç‰¹æ€§"""
        self.features[feature_name] = description
    
    def analyze_ethical_implications(self) -> Dict[str, Any]:
        """åˆ†æä¼¦ç†å½±å“"""
        for feature_name, description in self.features.items():
            self.analyzer.analyze_feature(feature_name, description)
        
        return self.analyzer.generate_ethical_report()

def demonstrate_ethical_philosophy():
    """æ¼”ç¤ºä¼¦ç†å“²å­¦"""
    system = EthicalSoftwareSystem("AI Recommendation System")
    
    # æ·»åŠ åŠŸèƒ½ç‰¹æ€§
    system.add_feature(
        "User Profiling",
        "Collects and analyzes user behavior data to create personal profiles"
    )
    system.add_feature(
        "Recommendation Algorithm",
        "Uses machine learning algorithms to provide personalized recommendations"
    )
    system.add_feature(
        "Data Encryption",
        "Implements security measures to protect user data"
    )
    system.add_feature(
        "Transparent Decision Making",
        "Provides explanations for algorithmic decisions"
    )
    
    # åˆ†æä¼¦ç†å½±å“
    report = system.analyze_ethical_implications()
    
    print("Ethical Analysis Report:")
    print(f"Overall Ethical Score: {report['overall_score']:.3f}")
    print("\nPrinciple Breakdown:")
    for principle, data in report['principle_breakdown'].items():
        print(f"  {principle}: {data['score']:.3f} ({data['count']} impacts)")
        for desc in data['descriptions']:
            print(f"    - {desc}")
    
    print("\nRecommendations:")
    for rec in report['recommendations']:
        print(f"  - {rec}")
    
    return system

if __name__ == "__main__":
    demonstrate_ethical_philosophy()
```

## 5. è½¯ä»¶å·¥ç¨‹å“²å­¦çš„åº”ç”¨

### 5.1 é¡¹ç›®è¯„ä¼°æ¡†æ¶

åŸºäºè½¯ä»¶å·¥ç¨‹å“²å­¦ï¼Œå»ºç«‹é¡¹ç›®è¯„ä¼°æ¡†æ¶ï¼š

```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import math

@dataclass
class ProjectCriteria:
    """é¡¹ç›®è¯„ä¼°æ ‡å‡†"""
    name: str
    weight: float
    min_score: float
    max_score: float

class ProjectEvaluator:
    """é¡¹ç›®è¯„ä¼°å™¨"""
    
    def __init__(self):
        self.criteria: List[ProjectCriteria] = [
            ProjectCriteria("Quality", 0.3, 0.0, 1.0),
            ProjectCriteria("Efficiency", 0.25, 0.0, 1.0),
            ProjectCriteria("Ethics", 0.2, 0.0, 1.0),
            ProjectCriteria("Innovation", 0.15, 0.0, 1.0),
            ProjectCriteria("Sustainability", 0.1, 0.0, 1.0)
        ]
    
    def evaluate_project(self, scores: Dict[str, float]) -> Dict[str, Any]:
        """è¯„ä¼°é¡¹ç›®"""
        total_score = 0
        weighted_scores = {}
        
        for criterion in self.criteria:
            score = scores.get(criterion.name, 0.5)
            # å½’ä¸€åŒ–å¾—åˆ†
            normalized_score = (score - criterion.min_score) / (criterion.max_score - criterion.min_score)
            weighted_score = normalized_score * criterion.weight
            weighted_scores[criterion.name] = {
                'raw_score': score,
                'normalized_score': normalized_score,
                'weighted_score': weighted_score
            }
            total_score += weighted_score
        
        return {
            'total_score': total_score,
            'grade': self._get_grade(total_score),
            'weighted_scores': weighted_scores,
            'recommendations': self._generate_recommendations(weighted_scores)
        }
    
    def _get_grade(self, score: float) -> str:
        """è·å–ç­‰çº§"""
        if score >= 0.9:
            return "A+"
        elif score >= 0.8:
            return "A"
        elif score >= 0.7:
            return "B+"
        elif score >= 0.6:
            return "B"
        elif score >= 0.5:
            return "C"
        else:
            return "D"
    
    def _generate_recommendations(self, weighted_scores: Dict[str, Dict[str, float]]) -> List[str]:
        """ç”Ÿæˆå»ºè®®"""
        recommendations = []
        
        for criterion_name, scores in weighted_scores.items():
            if scores['normalized_score'] < 0.6:
                recommendations.append(f"Improve {criterion_name} performance")
        
        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
def evaluate_software_project():
    """è¯„ä¼°è½¯ä»¶é¡¹ç›®"""
    evaluator = ProjectEvaluator()
    
    # æ¨¡æ‹Ÿé¡¹ç›®å¾—åˆ†
    project_scores = {
        "Quality": 0.85,
        "Efficiency": 0.78,
        "Ethics": 0.92,
        "Innovation": 0.65,
        "Sustainability": 0.70
    }
    
    result = evaluator.evaluate_project(project_scores)
    
    print("Project Evaluation Results:")
    print(f"Total Score: {result['total_score']:.3f}")
    print(f"Grade: {result['grade']}")
    
    print("\nDetailed Scores:")
    for criterion, scores in result['weighted_scores'].items():
        print(f"  {criterion}: {scores['raw_score']:.3f} (weighted: {scores['weighted_score']:.3f})")
    
    print("\nRecommendations:")
    for rec in result['recommendations']:
        print(f"  - {rec}")
    
    return result

if __name__ == "__main__":
    evaluate_software_project()
```

## 6. æ€»ç»“

è½¯ä»¶å·¥ç¨‹å“²å­¦ä¸ºè½¯ä»¶å¼€å‘æä¾›äº†æ·±å±‚çš„ç†è®ºæŒ‡å¯¼ï¼Œé€šè¿‡ç³»ç»ŸåŒ–æ€ç»´ã€å·¥ç¨‹åŒ–æ–¹æ³•å’Œä¼¦ç†å‡†åˆ™ï¼ŒæŒ‡å¯¼æˆ‘ä»¬æ„å»ºé«˜è´¨é‡ã€è´Ÿè´£ä»»ã€å¯æŒç»­çš„è½¯ä»¶ç³»ç»Ÿã€‚Pythonä½œä¸ºç°ä»£è½¯ä»¶å·¥ç¨‹çš„é‡è¦å·¥å…·ï¼Œä¸ºå®è·µè¿™äº›å“²å­¦æ€æƒ³æä¾›äº†å¼ºå¤§çš„æ”¯æŒã€‚

## 7. ç›¸å…³é“¾æ¥

- [00-01-ç¼–ç¨‹å“²å­¦](./00-01-ç¼–ç¨‹å“²å­¦.md)
- [00-03-è®¡ç®—æ€ç»´](./00-03-è®¡ç®—æ€ç»´.md)
- [01-01-é›†åˆè®ºåŸºç¡€](../01-å½¢å¼ç§‘å­¦/01-01-é›†åˆè®ºåŸºç¡€.md)
- [02-01-ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ19æ—¥  
**ç»´æŠ¤è€…**: AI Assistant
