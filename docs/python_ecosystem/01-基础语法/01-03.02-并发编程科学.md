# 03.02 å¹¶å‘ç¼–ç¨‹ç§‘å­¦

## ğŸ“– æ¦‚è¿°

å¹¶å‘ç¼–ç¨‹ç§‘å­¦æ˜¯ç ”ç©¶å¤šçº¿ç¨‹ã€å¤šè¿›ç¨‹å’Œå¼‚æ­¥ç¼–ç¨‹çš„ç†è®ºä¸å®è·µã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦é˜è¿°å¹¶å‘ç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µã€åŒæ­¥æœºåˆ¶å’Œè®¾è®¡æ¨¡å¼ï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å¹¶å‘ç¼–ç¨‹çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰**ï¼šå¹¶å‘ç¼–ç¨‹æ˜¯å¤šä¸ªæ‰§è¡Œå•å…ƒåŒæ—¶æ‰§è¡Œçš„è®¡ç®—æ¨¡å‹ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**ï¼š
$$\text{Concurrency} = \langle \text{Threads}, \text{Processes}, \text{Synchronization}, \text{Communication} \rangle$$

å…¶ä¸­ï¼š

- $\text{Threads}$ æ˜¯çº¿ç¨‹é›†åˆ
- $\text{Processes}$ æ˜¯è¿›ç¨‹é›†åˆ
- $\text{Synchronization}$ æ˜¯åŒæ­¥æœºåˆ¶
- $\text{Communication}$ æ˜¯é€šä¿¡æœºåˆ¶

**Pythonå®ç°**ï¼š

```python
from typing import TypeVar, Generic, Dict, List, Any, Callable, Optional
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import threading
import multiprocessing
import asyncio
import time
import queue

T = TypeVar('T')

class ConcurrencyType(Enum):
    """å¹¶å‘ç±»å‹æšä¸¾"""
    THREADING = "threading"
    MULTIPROCESSING = "multiprocessing"
    ASYNCIO = "asyncio"
    COROUTINE = "coroutine"

class SynchronizationType(Enum):
    """åŒæ­¥ç±»å‹æšä¸¾"""
    LOCK = "lock"
    SEMAPHORE = "semaphore"
    EVENT = "event"
    CONDITION = "condition"
    BARRIER = "barrier"
    QUEUE = "queue"

@dataclass
class Thread:
    """çº¿ç¨‹ç±»"""
    name: str
    target: Callable
    args: tuple
    kwargs: dict
    daemon: bool = False
    
    def __post_init__(self):
        self.thread = threading.Thread(
            target=self.target,
            args=self.args,
            kwargs=self.kwargs,
            daemon=self.daemon,
            name=self.name
        )
    
    def start(self):
        """å¯åŠ¨çº¿ç¨‹"""
        self.thread.start()
    
    def join(self, timeout: Optional[float] = None):
        """ç­‰å¾…çº¿ç¨‹ç»“æŸ"""
        self.thread.join(timeout=timeout)
    
    def is_alive(self) -> bool:
        """æ£€æŸ¥çº¿ç¨‹æ˜¯å¦å­˜æ´»"""
        return self.thread.is_alive()

@dataclass
class Process:
    """è¿›ç¨‹ç±»"""
    name: str
    target: Callable
    args: tuple
    kwargs: dict
    
    def __post_init__(self):
        self.process = multiprocessing.Process(
            target=self.target,
            args=self.args,
            kwargs=self.kwargs,
            name=self.name
        )
    
    def start(self):
        """å¯åŠ¨è¿›ç¨‹"""
        self.process.start()
    
    def join(self, timeout: Optional[float] = None):
        """ç­‰å¾…è¿›ç¨‹ç»“æŸ"""
        self.process.join(timeout=timeout)
    
    def is_alive(self) -> bool:
        """æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜æ´»"""
        return self.process.is_alive()
    
    def terminate(self):
        """ç»ˆæ­¢è¿›ç¨‹"""
        self.process.terminate()

class ConcurrencyModel:
    """å¹¶å‘æ¨¡å‹"""
    
    def __init__(self, concurrency_type: ConcurrencyType):
        self.concurrency_type = concurrency_type
        self.execution_units = []
        self.synchronization_mechanisms = {}
    
    def add_execution_unit(self, name: str, target: Callable, *args, **kwargs):
        """æ·»åŠ æ‰§è¡Œå•å…ƒ"""
        if self.concurrency_type == ConcurrencyType.THREADING:
            execution_unit = Thread(name, target, args, kwargs)
        elif self.concurrency_type == ConcurrencyType.MULTIPROCESSING:
            execution_unit = Process(name, target, args, kwargs)
        else:
            raise ValueError(f"Unsupported concurrency type: {self.concurrency_type}")
        
        self.execution_units.append(execution_unit)
    
    def add_synchronization(self, name: str, sync_type: SynchronizationType, **kwargs):
        """æ·»åŠ åŒæ­¥æœºåˆ¶"""
        if sync_type == SynchronizationType.LOCK:
            self.synchronization_mechanisms[name] = threading.Lock()
        elif sync_type == SynchronizationType.SEMAPHORE:
            value = kwargs.get('value', 1)
            self.synchronization_mechanisms[name] = threading.Semaphore(value)
        elif sync_type == SynchronizationType.EVENT:
            self.synchronization_mechanisms[name] = threading.Event()
        elif sync_type == SynchronizationType.CONDITION:
            lock = kwargs.get('lock', threading.Lock())
            self.synchronization_mechanisms[name] = threading.Condition(lock)
        elif sync_type == SynchronizationType.BARRIER:
            parties = kwargs.get('parties', 2)
            self.synchronization_mechanisms[name] = threading.Barrier(parties)
        elif sync_type == SynchronizationType.QUEUE:
            maxsize = kwargs.get('maxsize', 0)
            self.synchronization_mechanisms[name] = queue.Queue(maxsize)
    
    def execute(self):
        """æ‰§è¡Œå¹¶å‘æ¨¡å‹"""
        # å¯åŠ¨æ‰€æœ‰æ‰§è¡Œå•å…ƒ
        for unit in self.execution_units:
            unit.start()
        
        # ç­‰å¾…æ‰€æœ‰æ‰§è¡Œå•å…ƒå®Œæˆ
        for unit in self.execution_units:
            unit.join()
    
    def get_synchronization(self, name: str):
        """è·å–åŒæ­¥æœºåˆ¶"""
        return self.synchronization_mechanisms.get(name)
```

### 2. çº¿ç¨‹æ¨¡å‹

#### 2.1 çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ

**çº¿ç¨‹çŠ¶æ€**ï¼š

- **æ–°å»º (New)**ï¼šçº¿ç¨‹è¢«åˆ›å»ºä½†æœªå¯åŠ¨
- **å°±ç»ª (Ready)**ï¼šçº¿ç¨‹ç­‰å¾…CPUæ‰§è¡Œ
- **è¿è¡Œ (Running)**ï¼šçº¿ç¨‹æ­£åœ¨æ‰§è¡Œ
- **é˜»å¡ (Blocked)**ï¼šçº¿ç¨‹ç­‰å¾…I/Oæˆ–åŒæ­¥
- **ç»ˆæ­¢ (Terminated)**ï¼šçº¿ç¨‹æ‰§è¡Œå®Œæˆ

**Pythonå®ç°**ï¼š

```python
from enum import Enum
from threading import Thread, Event
import time

class ThreadState(Enum):
    """çº¿ç¨‹çŠ¶æ€æšä¸¾"""
    NEW = "new"
    READY = "ready"
    RUNNING = "running"
    BLOCKED = "blocked"
    TERMINATED = "terminated"

class ThreadModel:
    """çº¿ç¨‹æ¨¡å‹"""
    
    def __init__(self):
        self.threads = {}
        self.state_transitions = {
            ThreadState.NEW: [ThreadState.READY],
            ThreadState.READY: [ThreadState.RUNNING, ThreadState.BLOCKED],
            ThreadState.RUNNING: [ThreadState.READY, ThreadState.BLOCKED, ThreadState.TERMINATED],
            ThreadState.BLOCKED: [ThreadState.READY],
            ThreadState.TERMINATED: []
        }
    
    def create_thread(self, name: str, target: Callable, *args, **kwargs) -> str:
        """åˆ›å»ºçº¿ç¨‹"""
        thread_id = f"thread_{len(self.threads)}"
        
        thread_info = {
            'name': name,
            'target': target,
            'args': args,
            'kwargs': kwargs,
            'state': ThreadState.NEW,
            'thread': None,
            'start_time': None,
            'end_time': None
        }
        
        self.threads[thread_id] = thread_info
        return thread_id
    
    def start_thread(self, thread_id: str):
        """å¯åŠ¨çº¿ç¨‹"""
        if thread_id not in self.threads:
            raise ValueError(f"Thread {thread_id} not found")
        
        thread_info = self.threads[thread_id]
        
        if thread_info['state'] != ThreadState.NEW:
            raise ValueError(f"Thread {thread_id} is not in NEW state")
        
        # åˆ›å»ºå®é™…çº¿ç¨‹
        thread = Thread(
            target=self._thread_wrapper,
            args=(thread_id,),
            name=thread_info['name']
        )
        
        thread_info['thread'] = thread
        thread_info['state'] = ThreadState.READY
        thread_info['start_time'] = time.time()
        
        # å¯åŠ¨çº¿ç¨‹
        thread.start()
        thread_info['state'] = ThreadState.RUNNING
    
    def _thread_wrapper(self, thread_id: str):
        """çº¿ç¨‹åŒ…è£…å™¨"""
        thread_info = self.threads[thread_id]
        
        try:
            # æ‰§è¡Œç›®æ ‡å‡½æ•°
            result = thread_info['target'](*thread_info['args'], **thread_info['kwargs'])
            thread_info['result'] = result
        except Exception as e:
            thread_info['error'] = e
        finally:
            thread_info['state'] = ThreadState.TERMINATED
            thread_info['end_time'] = time.time()
    
    def get_thread_state(self, thread_id: str) -> ThreadState:
        """è·å–çº¿ç¨‹çŠ¶æ€"""
        if thread_id not in self.threads:
            raise ValueError(f"Thread {thread_id} not found")
        
        return self.threads[thread_id]['state']
    
    def get_thread_info(self, thread_id: str) -> Dict[str, Any]:
        """è·å–çº¿ç¨‹ä¿¡æ¯"""
        if thread_id not in self.threads:
            raise ValueError(f"Thread {thread_id} not found")
        
        return self.threads[thread_id].copy()
    
    def wait_for_thread(self, thread_id: str, timeout: Optional[float] = None):
        """ç­‰å¾…çº¿ç¨‹å®Œæˆ"""
        if thread_id not in self.threads:
            raise ValueError(f"Thread {thread_id} not found")
        
        thread_info = self.threads[thread_id]
        if thread_info['thread']:
            thread_info['thread'].join(timeout=timeout)
    
    def get_all_threads(self) -> Dict[str, ThreadState]:
        """è·å–æ‰€æœ‰çº¿ç¨‹çŠ¶æ€"""
        return {thread_id: info['state'] for thread_id, info in self.threads.items()}
```

#### 2.2 çº¿ç¨‹æ± 

**å®šä¹‰**ï¼šçº¿ç¨‹æ± æ˜¯é¢„å…ˆåˆ›å»ºçš„ä¸€ç»„çº¿ç¨‹ï¼Œç”¨äºæ‰§è¡Œä»»åŠ¡ã€‚

**Pythonå®ç°**ï¼š

```python
from concurrent.futures import ThreadPoolExecutor, Future
from typing import List, Callable, Any
import threading

class ThreadPool:
    """çº¿ç¨‹æ± """
    
    def __init__(self, max_workers: int = None):
        self.max_workers = max_workers or (threading.cpu_count() * 2)
        self.executor = ThreadPoolExecutor(max_workers=self.max_workers)
        self.futures = []
        self.completed_tasks = []
        self.failed_tasks = []
    
    def submit(self, func: Callable, *args, **kwargs) -> Future:
        """æäº¤ä»»åŠ¡"""
        future = self.executor.submit(func, *args, **kwargs)
        self.futures.append(future)
        return future
    
    def submit_batch(self, tasks: List[tuple]) -> List[Future]:
        """æ‰¹é‡æäº¤ä»»åŠ¡"""
        futures = []
        for task in tasks:
            if isinstance(task, tuple):
                func, args, kwargs = task[0], task[1] if len(task) > 1 else (), task[2] if len(task) > 2 else {}
            else:
                func, args, kwargs = task, (), {}
            
            future = self.submit(func, *args, **kwargs)
            futures.append(future)
        
        return futures
    
    def wait_for_completion(self, timeout: Optional[float] = None):
        """ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ"""
        for future in self.futures:
            try:
                result = future.result(timeout=timeout)
                self.completed_tasks.append({
                    'future': future,
                    'result': result,
                    'status': 'completed'
                })
            except Exception as e:
                self.failed_tasks.append({
                    'future': future,
                    'error': e,
                    'status': 'failed'
                })
    
    def get_results(self) -> List[Any]:
        """è·å–æ‰€æœ‰ç»“æœ"""
        results = []
        for task in self.completed_tasks:
            results.append(task['result'])
        return results
    
    def get_errors(self) -> List[Exception]:
        """è·å–æ‰€æœ‰é”™è¯¯"""
        errors = []
        for task in self.failed_tasks:
            errors.append(task['error'])
        return errors
    
    def shutdown(self, wait: bool = True):
        """å…³é—­çº¿ç¨‹æ± """
        self.executor.shutdown(wait=wait)
    
    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'max_workers': self.max_workers,
            'total_tasks': len(self.futures),
            'completed_tasks': len(self.completed_tasks),
            'failed_tasks': len(self.failed_tasks),
            'success_rate': len(self.completed_tasks) / len(self.futures) if self.futures else 0
        }
```

### 3. åŒæ­¥æœºåˆ¶

#### 3.1 é”æœºåˆ¶

**å®šä¹‰**ï¼šé”æ˜¯ç”¨äºä¿æŠ¤å…±äº«èµ„æºçš„åŒæ­¥æœºåˆ¶ã€‚

**é”ç±»å‹**ï¼š

- **äº’æ–¥é” (Mutex)**ï¼šç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®èµ„æº
- **è¯»å†™é” (Read-Write Lock)**ï¼šå…è®¸å¤šä¸ªè¯»æ“ä½œæˆ–ä¸€ä¸ªå†™æ“ä½œ
- **è‡ªæ—‹é” (Spin Lock)**ï¼šå¿™ç­‰å¾…çš„é”æœºåˆ¶

**Pythonå®ç°**ï¼š

```python
import threading
import time
from typing import Optional

class MutexLock:
    """äº’æ–¥é”"""
    
    def __init__(self):
        self.lock = threading.Lock()
        self.owner = None
        self.acquire_count = 0
    
    def acquire(self, blocking: bool = True, timeout: Optional[float] = None) -> bool:
        """è·å–é”"""
        if self.lock.acquire(blocking=blocking, timeout=timeout):
            self.owner = threading.current_thread()
            self.acquire_count += 1
            return True
        return False
    
    def release(self):
        """é‡Šæ”¾é”"""
        if self.owner == threading.current_thread():
            self.acquire_count -= 1
            if self.acquire_count == 0:
                self.owner = None
            self.lock.release()
        else:
            raise RuntimeError("Cannot release lock not owned by current thread")
    
    def __enter__(self):
        self.acquire()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.release()

class ReadWriteLock:
    """è¯»å†™é”"""
    
    def __init__(self):
        self.read_lock = threading.Lock()
        self.write_lock = threading.Lock()
        self.readers = 0
        self.writers = 0
        self.writer_waiting = 0
    
    def acquire_read(self, blocking: bool = True, timeout: Optional[float] = None) -> bool:
        """è·å–è¯»é”"""
        if not self.read_lock.acquire(blocking=blocking, timeout=timeout):
            return False
        
        try:
            # ç­‰å¾…å†™æ“ä½œå®Œæˆ
            while self.writers > 0 or self.writer_waiting > 0:
                if not blocking:
                    self.read_lock.release()
                    return False
                time.sleep(0.001)  # çŸ­æš‚ç­‰å¾…
            
            self.readers += 1
            return True
        finally:
            self.read_lock.release()
    
    def release_read(self):
        """é‡Šæ”¾è¯»é”"""
        with self.read_lock:
            self.readers -= 1
    
    def acquire_write(self, blocking: bool = True, timeout: Optional[float] = None) -> bool:
        """è·å–å†™é”"""
        if not self.write_lock.acquire(blocking=blocking, timeout=timeout):
            return False
        
        try:
            self.writer_waiting += 1
            
            # ç­‰å¾…æ‰€æœ‰è¯»æ“ä½œå’Œå†™æ“ä½œå®Œæˆ
            while self.readers > 0 or self.writers > 0:
                if not blocking:
                    self.writer_waiting -= 1
                    self.write_lock.release()
                    return False
                time.sleep(0.001)  # çŸ­æš‚ç­‰å¾…
            
            self.writer_waiting -= 1
            self.writers += 1
            return True
        finally:
            self.write_lock.release()
    
    def release_write(self):
        """é‡Šæ”¾å†™é”"""
        with self.write_lock:
            self.writers -= 1

class SpinLock:
    """è‡ªæ—‹é”"""
    
    def __init__(self):
        self.locked = False
        self.owner = None
    
    def acquire(self, blocking: bool = True, timeout: Optional[float] = None) -> bool:
        """è·å–é”"""
        start_time = time.time()
        
        while self.locked:
            if not blocking:
                return False
            
            if timeout is not None and time.time() - start_time > timeout:
                return False
            
            # è‡ªæ—‹ç­‰å¾…
            time.sleep(0.001)  # çŸ­æš‚ä¼‘çœ é¿å…è¿‡åº¦å ç”¨CPU
        
        self.locked = True
        self.owner = threading.current_thread()
        return True
    
    def release(self):
        """é‡Šæ”¾é”"""
        if self.owner == threading.current_thread():
            self.locked = False
            self.owner = None
        else:
            raise RuntimeError("Cannot release lock not owned by current thread")
    
    def __enter__(self):
        self.acquire()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.release()
```

#### 3.2 ä¿¡å·é‡å’Œäº‹ä»¶

**Pythonå®ç°**ï¼š

```python
class Semaphore:
    """ä¿¡å·é‡"""
    
    def __init__(self, value: int = 1):
        self.semaphore = threading.Semaphore(value)
        self.max_value = value
        self.current_value = value
    
    def acquire(self, blocking: bool = True, timeout: Optional[float] = None) -> bool:
        """è·å–ä¿¡å·é‡"""
        if self.semaphore.acquire(blocking=blocking, timeout=timeout):
            self.current_value -= 1
            return True
        return False
    
    def release(self, n: int = 1):
        """é‡Šæ”¾ä¿¡å·é‡"""
        for _ in range(n):
            self.semaphore.release()
            self.current_value += 1
    
    def __enter__(self):
        self.acquire()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.release()

class Event:
    """äº‹ä»¶"""
    
    def __init__(self):
        self.event = threading.Event()
        self.set_count = 0
        self.clear_count = 0
    
    def set(self):
        """è®¾ç½®äº‹ä»¶"""
        self.event.set()
        self.set_count += 1
    
    def clear(self):
        """æ¸…é™¤äº‹ä»¶"""
        self.event.clear()
        self.clear_count += 1
    
    def wait(self, timeout: Optional[float] = None) -> bool:
        """ç­‰å¾…äº‹ä»¶"""
        return self.event.wait(timeout=timeout)
    
    def is_set(self) -> bool:
        """æ£€æŸ¥äº‹ä»¶æ˜¯å¦å·²è®¾ç½®"""
        return self.event.is_set()
    
    def get_stats(self) -> Dict[str, int]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'set_count': self.set_count,
            'clear_count': self.clear_count,
            'is_set': self.is_set()
        }
```

### 4. å¹¶å‘æ¨¡å¼

#### 4.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

**å®šä¹‰**ï¼šç”Ÿäº§è€…ç”Ÿæˆæ•°æ®ï¼Œæ¶ˆè´¹è€…å¤„ç†æ•°æ®ï¼Œé€šè¿‡ç¼“å†²åŒºè¿›è¡Œè§£è€¦ã€‚

**Pythonå®ç°**ï¼š

```python
import queue
import threading
import time
from typing import Callable, Any

class Producer:
    """ç”Ÿäº§è€…"""
    
    def __init__(self, name: str, buffer: queue.Queue, producer_func: Callable[[], Any]):
        self.name = name
        self.buffer = buffer
        self.producer_func = producer_func
        self.running = False
        self.produced_count = 0
    
    def start(self):
        """å¯åŠ¨ç”Ÿäº§è€…"""
        self.running = True
        self.thread = threading.Thread(target=self._produce, name=f"Producer-{self.name}")
        self.thread.start()
    
    def stop(self):
        """åœæ­¢ç”Ÿäº§è€…"""
        self.running = False
        if hasattr(self, 'thread'):
            self.thread.join()
    
    def _produce(self):
        """ç”Ÿäº§æ•°æ®"""
        while self.running:
            try:
                item = self.producer_func()
                self.buffer.put(item, timeout=1)
                self.produced_count += 1
                print(f"{self.name} produced: {item}")
                time.sleep(0.1)  # ç”Ÿäº§é—´éš”
            except queue.Full:
                print(f"{self.name} buffer is full, waiting...")
            except Exception as e:
                print(f"{self.name} error: {e}")
                break

class Consumer:
    """æ¶ˆè´¹è€…"""
    
    def __init__(self, name: str, buffer: queue.Queue, consumer_func: Callable[[Any], None]):
        self.name = name
        self.buffer = buffer
        self.consumer_func = consumer_func
        self.running = False
        self.consumed_count = 0
    
    def start(self):
        """å¯åŠ¨æ¶ˆè´¹è€…"""
        self.running = True
        self.thread = threading.Thread(target=self._consume, name=f"Consumer-{self.name}")
        self.thread.start()
    
    def stop(self):
        """åœæ­¢æ¶ˆè´¹è€…"""
        self.running = False
        if hasattr(self, 'thread'):
            self.thread.join()
    
    def _consume(self):
        """æ¶ˆè´¹æ•°æ®"""
        while self.running:
            try:
                item = self.buffer.get(timeout=1)
                self.consumer_func(item)
                self.consumed_count += 1
                print(f"{self.name} consumed: {item}")
                self.buffer.task_done()
                time.sleep(0.2)  # æ¶ˆè´¹é—´éš”
            except queue.Empty:
                print(f"{self.name} buffer is empty, waiting...")
            except Exception as e:
                print(f"{self.name} error: {e}")
                break

class ProducerConsumerSystem:
    """ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿ"""
    
    def __init__(self, buffer_size: int = 10):
        self.buffer = queue.Queue(maxsize=buffer_size)
        self.producers = []
        self.consumers = []
        self.running = False
    
    def add_producer(self, name: str, producer_func: Callable[[], Any]):
        """æ·»åŠ ç”Ÿäº§è€…"""
        producer = Producer(name, self.buffer, producer_func)
        self.producers.append(producer)
    
    def add_consumer(self, name: str, consumer_func: Callable[[Any], None]):
        """æ·»åŠ æ¶ˆè´¹è€…"""
        consumer = Consumer(name, self.buffer, consumer_func)
        self.consumers.append(consumer)
    
    def start(self):
        """å¯åŠ¨ç³»ç»Ÿ"""
        self.running = True
        
        # å¯åŠ¨æ‰€æœ‰ç”Ÿäº§è€…
        for producer in self.producers:
            producer.start()
        
        # å¯åŠ¨æ‰€æœ‰æ¶ˆè´¹è€…
        for consumer in self.consumers:
            consumer.start()
    
    def stop(self):
        """åœæ­¢ç³»ç»Ÿ"""
        self.running = False
        
        # åœæ­¢æ‰€æœ‰ç”Ÿäº§è€…
        for producer in self.producers:
            producer.stop()
        
        # åœæ­¢æ‰€æœ‰æ¶ˆè´¹è€…
        for consumer in self.consumers:
            consumer.stop()
    
    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        total_produced = sum(p.produced_count for p in self.producers)
        total_consumed = sum(c.consumed_count for c in self.consumers)
        
        return {
            'buffer_size': self.buffer.qsize(),
            'total_produced': total_produced,
            'total_consumed': total_consumed,
            'producer_count': len(self.producers),
            'consumer_count': len(self.consumers)
        }
```

#### 4.2 è¯»è€…-å†™è€…æ¨¡å¼

**å®šä¹‰**ï¼šå…è®¸å¤šä¸ªè¯»è€…åŒæ—¶è®¿é—®èµ„æºï¼Œä½†å†™è€…å¿…é¡»ç‹¬å è®¿é—®ã€‚

**Pythonå®ç°**ï¼š

```python
class ReaderWriterLock:
    """è¯»è€…-å†™è€…é”"""
    
    def __init__(self):
        self.read_lock = threading.Lock()
        self.write_lock = threading.Lock()
        self.readers = 0
        self.writers = 0
        self.writer_waiting = 0
    
    def acquire_read(self, blocking: bool = True, timeout: Optional[float] = None) -> bool:
        """è·å–è¯»é”"""
        if not self.read_lock.acquire(blocking=blocking, timeout=timeout):
            return False
        
        try:
            # ç­‰å¾…å†™æ“ä½œå®Œæˆ
            while self.writers > 0 or self.writer_waiting > 0:
                if not blocking:
                    self.read_lock.release()
                    return False
                time.sleep(0.001)
            
            self.readers += 1
            return True
        finally:
            self.read_lock.release()
    
    def release_read(self):
        """é‡Šæ”¾è¯»é”"""
        with self.read_lock:
            self.readers -= 1
    
    def acquire_write(self, blocking: bool = True, timeout: Optional[float] = None) -> bool:
        """è·å–å†™é”"""
        if not self.write_lock.acquire(blocking=blocking, timeout=timeout):
            return False
        
        try:
            self.writer_waiting += 1
            
            # ç­‰å¾…æ‰€æœ‰è¯»æ“ä½œå’Œå†™æ“ä½œå®Œæˆ
            while self.readers > 0 or self.writers > 0:
                if not blocking:
                    self.writer_waiting -= 1
                    self.write_lock.release()
                    return False
                time.sleep(0.001)
            
            self.writer_waiting -= 1
            self.writers += 1
            return True
        finally:
            self.write_lock.release()
    
    def release_write(self):
        """é‡Šæ”¾å†™é”"""
        with self.write_lock:
            self.writers -= 1

class Reader:
    """è¯»è€…"""
    
    def __init__(self, name: str, rw_lock: ReaderWriterLock, read_func: Callable[[], Any]):
        self.name = name
        self.rw_lock = rw_lock
        self.read_func = read_func
        self.running = False
        self.read_count = 0
    
    def start(self):
        """å¯åŠ¨è¯»è€…"""
        self.running = True
        self.thread = threading.Thread(target=self._read, name=f"Reader-{self.name}")
        self.thread.start()
    
    def stop(self):
        """åœæ­¢è¯»è€…"""
        self.running = False
        if hasattr(self, 'thread'):
            self.thread.join()
    
    def _read(self):
        """è¯»å–æ•°æ®"""
        while self.running:
            try:
                if self.rw_lock.acquire_read(timeout=1):
                    try:
                        data = self.read_func()
                        self.read_count += 1
                        print(f"{self.name} read: {data}")
                        time.sleep(0.1)  # è¯»å–æ—¶é—´
                    finally:
                        self.rw_lock.release_read()
                else:
                    print(f"{self.name} waiting for read lock...")
            except Exception as e:
                print(f"{self.name} error: {e}")
                break

class Writer:
    """å†™è€…"""
    
    def __init__(self, name: str, rw_lock: ReaderWriterLock, write_func: Callable[[Any], None]):
        self.name = name
        self.rw_lock = rw_lock
        self.write_func = write_func
        self.running = False
        self.write_count = 0
    
    def start(self):
        """å¯åŠ¨å†™è€…"""
        self.running = True
        self.thread = threading.Thread(target=self._write, name=f"Writer-{self.name}")
        self.thread.start()
    
    def stop(self):
        """åœæ­¢å†™è€…"""
        self.running = False
        if hasattr(self, 'thread'):
            self.thread.join()
    
    def _write(self):
        """å†™å…¥æ•°æ®"""
        while self.running:
            try:
                if self.rw_lock.acquire_write(timeout=1):
                    try:
                        data = f"data_{self.write_count}"
                        self.write_func(data)
                        self.write_count += 1
                        print(f"{self.name} wrote: {data}")
                        time.sleep(0.2)  # å†™å…¥æ—¶é—´
                    finally:
                        self.rw_lock.release_write()
                else:
                    print(f"{self.name} waiting for write lock...")
            except Exception as e:
                print(f"{self.name} error: {e}")
                break

class ReaderWriterSystem:
    """è¯»è€…-å†™è€…ç³»ç»Ÿ"""
    
    def __init__(self):
        self.rw_lock = ReaderWriterLock()
        self.readers = []
        self.writers = []
        self.shared_data = []
        self.running = False
    
    def add_reader(self, name: str):
        """æ·»åŠ è¯»è€…"""
        def read_func():
            return self.shared_data.copy()
        
        reader = Reader(name, self.rw_lock, read_func)
        self.readers.append(reader)
    
    def add_writer(self, name: str):
        """æ·»åŠ å†™è€…"""
        def write_func(data):
            self.shared_data.append(data)
        
        writer = Writer(name, self.rw_lock, write_func)
        self.writers.append(writer)
    
    def start(self):
        """å¯åŠ¨ç³»ç»Ÿ"""
        self.running = True
        
        # å¯åŠ¨æ‰€æœ‰è¯»è€…
        for reader in self.readers:
            reader.start()
        
        # å¯åŠ¨æ‰€æœ‰å†™è€…
        for writer in self.writers:
            writer.start()
    
    def stop(self):
        """åœæ­¢ç³»ç»Ÿ"""
        self.running = False
        
        # åœæ­¢æ‰€æœ‰è¯»è€…
        for reader in self.readers:
            reader.stop()
        
        # åœæ­¢æ‰€æœ‰å†™è€…
        for writer in self.writers:
            writer.stop()
    
    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        total_reads = sum(r.read_count for r in self.readers)
        total_writes = sum(w.write_count for w in self.writers)
        
        return {
            'shared_data_size': len(self.shared_data),
            'total_reads': total_reads,
            'total_writes': total_writes,
            'reader_count': len(self.readers),
            'writer_count': len(self.writers)
        }
```

### 5. å¼‚æ­¥ç¼–ç¨‹

#### 5.1 åç¨‹å’Œå¼‚æ­¥å‡½æ•°

**Pythonå®ç°**ï¼š

```python
import asyncio
from typing import Any, Coroutine, List

class AsyncTask:
    """å¼‚æ­¥ä»»åŠ¡"""
    
    def __init__(self, name: str, coro: Coroutine):
        self.name = name
        self.coro = coro
        self.task = None
        self.result = None
        self.error = None
        self.completed = False
    
    async def execute(self):
        """æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡"""
        try:
            self.result = await self.coro
            self.completed = True
        except Exception as e:
            self.error = e
            self.completed = True

class AsyncScheduler:
    """å¼‚æ­¥è°ƒåº¦å™¨"""
    
    def __init__(self):
        self.tasks = []
        self.loop = None
    
    def add_task(self, name: str, coro: Coroutine):
        """æ·»åŠ å¼‚æ­¥ä»»åŠ¡"""
        task = AsyncTask(name, coro)
        self.tasks.append(task)
        return task
    
    async def run_all(self):
        """è¿è¡Œæ‰€æœ‰ä»»åŠ¡"""
        self.loop = asyncio.get_event_loop()
        
        # åˆ›å»ºæ‰€æœ‰ä»»åŠ¡
        task_objects = []
        for task in self.tasks:
            task.task = asyncio.create_task(task.execute(), name=task.name)
            task_objects.append(task.task)
        
        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        await asyncio.gather(*task_objects, return_exceptions=True)
    
    def run(self):
        """è¿è¡Œè°ƒåº¦å™¨"""
        asyncio.run(self.run_all())
    
    def get_results(self) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰ç»“æœ"""
        results = {}
        for task in self.tasks:
            if task.completed:
                if task.error:
                    results[task.name] = {'error': str(task.error)}
                else:
                    results[task.name] = {'result': task.result}
            else:
                results[task.name] = {'status': 'running'}
        return results

# ç¤ºä¾‹å¼‚æ­¥å‡½æ•°
async def async_producer(name: str, delay: float):
    """å¼‚æ­¥ç”Ÿäº§è€…"""
    for i in range(5):
        print(f"{name} producing item {i}")
        await asyncio.sleep(delay)
    return f"{name} completed"

async def async_consumer(name: str, delay: float):
    """å¼‚æ­¥æ¶ˆè´¹è€…"""
    for i in range(5):
        print(f"{name} consuming item {i}")
        await asyncio.sleep(delay)
    return f"{name} completed"

async def async_worker(name: str, work_items: List[str]):
    """å¼‚æ­¥å·¥ä½œè€…"""
    results = []
    for item in work_items:
        print(f"{name} processing {item}")
        await asyncio.sleep(0.1)
        results.append(f"{name} processed {item}")
    return results
```

## ğŸ”¬ å¹¶å‘ç¼–ç¨‹åº”ç”¨æ¡ˆä¾‹

### 1. ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿç¤ºä¾‹

```python
# åˆ›å»ºç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿ
def producer_function():
    """ç”Ÿäº§è€…å‡½æ•°"""
    import random
    return random.randint(1, 100)

def consumer_function(item):
    """æ¶ˆè´¹è€…å‡½æ•°"""
    print(f"Processing item: {item}")

# åˆ›å»ºç³»ç»Ÿ
system = ProducerConsumerSystem(buffer_size=5)

# æ·»åŠ ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…
system.add_producer("Producer1", producer_function)
system.add_producer("Producer2", producer_function)
system.add_consumer("Consumer1", consumer_function)
system.add_consumer("Consumer2", consumer_function)

# å¯åŠ¨ç³»ç»Ÿ
system.start()

# è¿è¡Œä¸€æ®µæ—¶é—´
time.sleep(5)

# åœæ­¢ç³»ç»Ÿ
system.stop()

# è·å–ç»Ÿè®¡ä¿¡æ¯
stats = system.get_stats()
print("System Statistics:", stats)
```

### 2. è¯»è€…-å†™è€…ç³»ç»Ÿç¤ºä¾‹

```python
# åˆ›å»ºè¯»è€…-å†™è€…ç³»ç»Ÿ
rw_system = ReaderWriterSystem()

# æ·»åŠ è¯»è€…å’Œå†™è€…
rw_system.add_reader("Reader1")
rw_system.add_reader("Reader2")
rw_system.add_writer("Writer1")
rw_system.add_writer("Writer2")

# å¯åŠ¨ç³»ç»Ÿ
rw_system.start()

# è¿è¡Œä¸€æ®µæ—¶é—´
time.sleep(5)

# åœæ­¢ç³»ç»Ÿ
rw_system.stop()

# è·å–ç»Ÿè®¡ä¿¡æ¯
stats = rw_system.get_stats()
print("Reader-Writer System Statistics:", stats)
```

### 3. å¼‚æ­¥ç¼–ç¨‹ç¤ºä¾‹

```python
# åˆ›å»ºå¼‚æ­¥è°ƒåº¦å™¨
scheduler = AsyncScheduler()

# æ·»åŠ å¼‚æ­¥ä»»åŠ¡
scheduler.add_task("Producer1", async_producer("Producer1", 0.5))
scheduler.add_task("Producer2", async_producer("Producer2", 0.3))
scheduler.add_task("Consumer1", async_consumer("Consumer1", 0.4))
scheduler.add_task("Worker1", async_worker("Worker1", ["task1", "task2", "task3"]))

# è¿è¡Œè°ƒåº¦å™¨
scheduler.run()

# è·å–ç»“æœ
results = scheduler.get_results()
print("Async Task Results:", results)
```

## ğŸ“Š æ€»ç»“

å¹¶å‘ç¼–ç¨‹ç§‘å­¦ä¸ºç°ä»£è½¯ä»¶å¼€å‘æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ï¼š

1. **çº¿ç¨‹æ¨¡å‹**ï¼šç†è§£çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸå’ŒçŠ¶æ€è½¬æ¢
2. **åŒæ­¥æœºåˆ¶**ï¼šæŒæ¡é”ã€ä¿¡å·é‡ã€äº‹ä»¶ç­‰åŒæ­¥å·¥å…·
3. **å¹¶å‘æ¨¡å¼**ï¼šåº”ç”¨ç”Ÿäº§è€…-æ¶ˆè´¹è€…ã€è¯»è€…-å†™è€…ç­‰æ¨¡å¼
4. **å¼‚æ­¥ç¼–ç¨‹**ï¼šä½¿ç”¨åç¨‹å’Œå¼‚æ­¥å‡½æ•°æé«˜æ€§èƒ½

é€šè¿‡æ·±å…¥ç†è§£å¹¶å‘ç¼–ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

- è®¾è®¡é«˜æ€§èƒ½çš„å¤šçº¿ç¨‹åº”ç”¨
- é¿å…ç«æ€æ¡ä»¶å’Œæ­»é”
- å®ç°é«˜æ•ˆçš„èµ„æºç®¡ç†
- æ„å»ºå¯æ‰©å±•çš„å¹¶å‘ç³»ç»Ÿ
- åˆ©ç”¨å¤šæ ¸å¤„ç†å™¨æé«˜æ€§èƒ½
