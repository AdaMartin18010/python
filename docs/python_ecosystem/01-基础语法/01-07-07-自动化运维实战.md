# è‡ªåŠ¨åŒ–è¿ç»´å®æˆ˜

## 7.7 è‡ªåŠ¨åŒ–è¿ç»´å®æˆ˜

### æ¦‚å¿µä¸æµç¨‹

è‡ªåŠ¨åŒ–è¿ç»´ï¼ˆDevOpsï¼‰æ˜¯é€šè¿‡è‡ªåŠ¨åŒ–å·¥å…·å’Œæµç¨‹ï¼Œå®ç°è½¯ä»¶éƒ¨ç½²ã€é…ç½®ç®¡ç†ã€ç›‘æ§å‘Šè­¦ç­‰è¿ç»´ä»»åŠ¡çš„è‡ªåŠ¨åŒ–å¤„ç†ã€‚

#### å…¸å‹è‡ªåŠ¨åŒ–è¿ç»´æµç¨‹

1. ä»£ç æäº¤ä¸æ„å»º
2. è‡ªåŠ¨åŒ–æµ‹è¯•
3. éƒ¨ç½²ä¸å‘å¸ƒ
4. ç›‘æ§ä¸å‘Šè­¦
5. æ•…éšœè‡ªæ„ˆ

### åŸºç¡€è‡ªåŠ¨åŒ–å·¥å…·

#### 1. è¿œç¨‹æ‰§è¡Œæ¡†æ¶

```python
import paramiko
import subprocess
import threading
from concurrent.futures import ThreadPoolExecutor
import json
import logging

class RemoteExecutor:
    def __init__(self, host, username, password=None, key_filename=None):
        self.host = host
        self.username = username
        self.password = password
        self.key_filename = key_filename
        self.ssh = None
    
    def connect(self):
        """å»ºç«‹SSHè¿æ¥"""
        try:
            self.ssh = paramiko.SSHClient()
            self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            if self.key_filename:
                self.ssh.connect(self.host, username=self.username, key_filename=self.key_filename)
            else:
                self.ssh.connect(self.host, username=self.username, password=self.password)
            
            return True
        except Exception as e:
            logging.error(f"è¿æ¥å¤±è´¥ {self.host}: {str(e)}")
            return False
    
    def execute_command(self, command, timeout=30):
        """æ‰§è¡Œè¿œç¨‹å‘½ä»¤"""
        if not self.ssh:
            if not self.connect():
                return None, None, None
        
        try:
            stdin, stdout, stderr = self.ssh.exec_command(command, timeout=timeout)
            
            # è·å–è¾“å‡º
            output = stdout.read().decode('utf-8')
            error = stderr.read().decode('utf-8')
            exit_code = stdout.channel.recv_exit_status()
            
            return output, error, exit_code
        except Exception as e:
            logging.error(f"æ‰§è¡Œå‘½ä»¤å¤±è´¥: {str(e)}")
            return None, None, -1
    
    def upload_file(self, local_path, remote_path):
        """ä¸Šä¼ æ–‡ä»¶"""
        if not self.ssh:
            if not self.connect():
                return False
        
        try:
            sftp = self.ssh.open_sftp()
            sftp.put(local_path, remote_path)
            sftp.close()
            return True
        except Exception as e:
            logging.error(f"æ–‡ä»¶ä¸Šä¼ å¤±è´¥: {str(e)}")
            return False
    
    def download_file(self, remote_path, local_path):
        """ä¸‹è½½æ–‡ä»¶"""
        if not self.ssh:
            if not self.connect():
                return False
        
        try:
            sftp = self.ssh.open_sftp()
            sftp.get(remote_path, local_path)
            sftp.close()
            return True
        except Exception as e:
            logging.error(f"æ–‡ä»¶ä¸‹è½½å¤±è´¥: {str(e)}")
            return False
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.ssh:
            self.ssh.close()

class BatchExecutor:
    def __init__(self, hosts_config):
        self.hosts = []
        for host_info in hosts_config:
            executor = RemoteExecutor(**host_info)
            self.hosts.append(executor)
    
    def execute_on_all(self, command, max_workers=10):
        """åœ¨æ‰€æœ‰ä¸»æœºä¸Šæ‰§è¡Œå‘½ä»¤"""
        results = {}
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_host = {
                executor.submit(host.execute_command, command): host.host 
                for host in self.hosts
            }
            
            for future in future_to_host:
                host = future_to_host[future]
                try:
                    output, error, exit_code = future.result()
                    results[host] = {
                        'output': output,
                        'error': error,
                        'exit_code': exit_code,
                        'success': exit_code == 0
                    }
                except Exception as e:
                    results[host] = {
                        'output': None,
                        'error': str(e),
                        'exit_code': -1,
                        'success': False
                    }
        
        return results
    
    def upload_to_all(self, local_path, remote_path):
        """ä¸Šä¼ æ–‡ä»¶åˆ°æ‰€æœ‰ä¸»æœº"""
        results = {}
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_host = {
                executor.submit(host.upload_file, local_path, remote_path): host.host 
                for host in self.hosts
            }
            
            for future in future_to_host:
                host = future_to_host[future]
                try:
                    success = future.result()
                    results[host] = success
                except Exception as e:
                    results[host] = False
        
        return results
```

#### 2. é…ç½®ç®¡ç†

```python
import yaml
import json
import os
from jinja2 import Template

class ConfigManager:
    def __init__(self, config_dir="./configs"):
        self.config_dir = config_dir
        self.configs = {}
        self.load_configs()
    
    def load_configs(self):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        if not os.path.exists(self.config_dir):
            os.makedirs(self.config_dir)
            return
        
        for filename in os.listdir(self.config_dir):
            if filename.endswith(('.yaml', '.yml', '.json')):
                config_path = os.path.join(self.config_dir, filename)
                self.load_config(config_path)
    
    def load_config(self, config_path):
        """åŠ è½½å•ä¸ªé…ç½®æ–‡ä»¶"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                if config_path.endswith(('.yaml', '.yml')):
                    config = yaml.safe_load(f)
                else:
                    config = json.load(f)
                
                config_name = os.path.splitext(os.path.basename(config_path))[0]
                self.configs[config_name] = config
                
        except Exception as e:
            logging.error(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥ {config_path}: {str(e)}")
    
    def get_config(self, config_name, key=None):
        """è·å–é…ç½®"""
        if config_name not in self.configs:
            return None
        
        config = self.configs[config_name]
        if key:
            return config.get(key)
        return config
    
    def set_config(self, config_name, key, value):
        """è®¾ç½®é…ç½®"""
        if config_name not in self.configs:
            self.configs[config_name] = {}
        
        self.configs[config_name][key] = value
    
    def save_config(self, config_name, config_type='yaml'):
        """ä¿å­˜é…ç½®"""
        config = self.configs.get(config_name)
        if not config:
            return False
        
        filename = f"{config_name}.{config_type}"
        config_path = os.path.join(self.config_dir, filename)
        
        try:
            with open(config_path, 'w', encoding='utf-8') as f:
                if config_type == 'yaml':
                    yaml.dump(config, f, default_flow_style=False, allow_unicode=True)
                else:
                    json.dump(config, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            logging.error(f"ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {str(e)}")
            return False
    
    def render_template(self, template_content, variables):
        """æ¸²æŸ“æ¨¡æ¿"""
        template = Template(template_content)
        return template.render(**variables)

class ApplicationConfig:
    def __init__(self, app_name, config_manager):
        self.app_name = app_name
        self.config_manager = config_manager
    
    def get_deployment_config(self):
        """è·å–éƒ¨ç½²é…ç½®"""
        return self.config_manager.get_config(f"{self.app_name}_deployment")
    
    def get_monitoring_config(self):
        """è·å–ç›‘æ§é…ç½®"""
        return self.config_manager.get_config(f"{self.app_name}_monitoring")
    
    def update_deployment_config(self, updates):
        """æ›´æ–°éƒ¨ç½²é…ç½®"""
        current_config = self.get_deployment_config() or {}
        current_config.update(updates)
        self.config_manager.configs[f"{self.app_name}_deployment"] = current_config
        self.config_manager.save_config(f"{self.app_name}_deployment")
```

#### 3. æ—¥å¿—ç®¡ç†

```python
import logging
import logging.handlers
import datetime
import os

class LogManager:
    def __init__(self, log_dir="./logs", max_bytes=10*1024*1024, backup_count=5):
        self.log_dir = log_dir
        self.max_bytes = max_bytes
        self.backup_count = backup_count
        
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
    
    def setup_logger(self, name, level=logging.INFO):
        """è®¾ç½®æ—¥å¿—è®°å½•å™¨"""
        logger = logging.getLogger(name)
        logger.setLevel(level)
        
        # æ¸…é™¤ç°æœ‰å¤„ç†å™¨
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)
        
        # æ–‡ä»¶å¤„ç†å™¨
        log_file = os.path.join(self.log_dir, f"{name}.log")
        file_handler = logging.handlers.RotatingFileHandler(
            log_file, maxBytes=self.max_bytes, backupCount=self.backup_count
        )
        
        # æ§åˆ¶å°å¤„ç†å™¨
        console_handler = logging.StreamHandler()
        
        # æ ¼å¼åŒ–å™¨
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger
    
    def get_logger(self, name):
        """è·å–æ—¥å¿—è®°å½•å™¨"""
        return logging.getLogger(name)

class LogCollector:
    def __init__(self, remote_executor):
        self.remote_executor = remote_executor
    
    def collect_logs(self, log_paths, output_dir="./collected_logs"):
        """æ”¶é›†è¿œç¨‹æ—¥å¿—"""
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        collected_files = []
        
        for log_path in log_paths:
            if self.remote_executor.execute_command(f"test -f {log_path}")[2] == 0:
                local_path = os.path.join(output_dir, f"{self.remote_executor.host}_{os.path.basename(log_path)}")
                if self.remote_executor.download_file(log_path, local_path):
                    collected_files.append(local_path)
        
        return collected_files
    
    def tail_log(self, log_path, lines=100):
        """è·å–æ—¥å¿—å°¾éƒ¨"""
        command = f"tail -n {lines} {log_path}"
        output, error, exit_code = self.remote_executor.execute_command(command)
        
        if exit_code == 0:
            return output.split('\n')
        else:
            return []
    
    def search_log(self, log_path, pattern):
        """æœç´¢æ—¥å¿—"""
        command = f"grep '{pattern}' {log_path}"
        output, error, exit_code = self.remote_executor.execute_command(command)
        
        if exit_code == 0:
            return output.split('\n')
        else:
            return []
```

### è‡ªåŠ¨åŒ–éƒ¨ç½²

#### 1. åº”ç”¨éƒ¨ç½²å™¨

```python
class ApplicationDeployer:
    def __init__(self, remote_executor, config_manager):
        self.remote_executor = remote_executor
        self.config_manager = config_manager
        self.logger = logging.getLogger(__name__)
    
    def deploy_application(self, app_name, version, deployment_config):
        """éƒ¨ç½²åº”ç”¨"""
        self.logger.info(f"å¼€å§‹éƒ¨ç½²åº”ç”¨ {app_name} ç‰ˆæœ¬ {version}")
        
        # 1. å‡†å¤‡éƒ¨ç½²ç¯å¢ƒ
        if not self._prepare_environment(deployment_config):
            return False
        
        # 2. ä¸‹è½½åº”ç”¨åŒ…
        if not self._download_package(app_name, version, deployment_config):
            return False
        
        # 3. åœæ­¢æ—§ç‰ˆæœ¬
        if not self._stop_application(app_name):
            self.logger.warning("åœæ­¢æ—§ç‰ˆæœ¬å¤±è´¥ï¼Œç»§ç»­éƒ¨ç½²")
        
        # 4. éƒ¨ç½²æ–°ç‰ˆæœ¬
        if not self._deploy_package(app_name, version, deployment_config):
            return False
        
        # 5. å¯åŠ¨åº”ç”¨
        if not self._start_application(app_name, deployment_config):
            return False
        
        # 6. å¥åº·æ£€æŸ¥
        if not self._health_check(app_name, deployment_config):
            self.logger.error("å¥åº·æ£€æŸ¥å¤±è´¥")
            return False
        
        self.logger.info(f"åº”ç”¨ {app_name} ç‰ˆæœ¬ {version} éƒ¨ç½²æˆåŠŸ")
        return True
    
    def _prepare_environment(self, deployment_config):
        """å‡†å¤‡éƒ¨ç½²ç¯å¢ƒ"""
        install_dir = deployment_config.get('install_dir', '/opt/apps')
        
        # åˆ›å»ºå®‰è£…ç›®å½•
        commands = [
            f"mkdir -p {install_dir}",
            f"chmod 755 {install_dir}"
        ]
        
        for command in commands:
            output, error, exit_code = self.remote_executor.execute_command(command)
            if exit_code != 0:
                self.logger.error(f"å‡†å¤‡ç¯å¢ƒå¤±è´¥: {error}")
                return False
        
        return True
    
    def _download_package(self, app_name, version, deployment_config):
        """ä¸‹è½½åº”ç”¨åŒ…"""
        package_url = deployment_config.get('package_url')
        install_dir = deployment_config.get('install_dir', '/opt/apps')
        
        if not package_url:
            self.logger.error("æœªé…ç½®åŒ…ä¸‹è½½åœ°å€")
            return False
        
        download_command = f"wget -O {install_dir}/{app_name}-{version}.tar.gz {package_url}"
        output, error, exit_code = self.remote_executor.execute_command(download_command)
        
        if exit_code != 0:
            self.logger.error(f"ä¸‹è½½åŒ…å¤±è´¥: {error}")
            return False
        
        return True
    
    def _stop_application(self, app_name):
        """åœæ­¢åº”ç”¨"""
        stop_commands = [
            f"systemctl stop {app_name}",
            f"pkill -f {app_name}",
            f"killall {app_name}"
        ]
        
        for command in stop_commands:
            output, error, exit_code = self.remote_executor.execute_command(command)
            if exit_code == 0:
                self.logger.info(f"åº”ç”¨ {app_name} å·²åœæ­¢")
                return True
        
        return False
    
    def _deploy_package(self, app_name, version, deployment_config):
        """éƒ¨ç½²åŒ…"""
        install_dir = deployment_config.get('install_dir', '/opt/apps')
        app_dir = deployment_config.get('app_dir', f'/opt/apps/{app_name}')
        
        commands = [
            f"cd {install_dir}",
            f"tar -xzf {app_name}-{version}.tar.gz",
            f"rm -rf {app_dir}",
            f"mv {app_name}-{version} {app_dir}",
            f"chmod +x {app_dir}/bin/*"
        ]
        
        for command in commands:
            output, error, exit_code = self.remote_executor.execute_command(command)
            if exit_code != 0:
                self.logger.error(f"éƒ¨ç½²åŒ…å¤±è´¥: {error}")
                return False
        
        return True
    
    def _start_application(self, app_name, deployment_config):
        """å¯åŠ¨åº”ç”¨"""
        app_dir = deployment_config.get('app_dir', f'/opt/apps/{app_name}')
        start_script = deployment_config.get('start_script', 'start.sh')
        
        start_command = f"cd {app_dir} && ./{start_script}"
        output, error, exit_code = self.remote_executor.execute_command(start_command)
        
        if exit_code != 0:
            self.logger.error(f"å¯åŠ¨åº”ç”¨å¤±è´¥: {error}")
            return False
        
        return True
    
    def _health_check(self, app_name, deployment_config):
        """å¥åº·æ£€æŸ¥"""
        health_url = deployment_config.get('health_url')
        if not health_url:
            return True
        
        check_command = f"curl -f {health_url}"
        output, error, exit_code = self.remote_executor.execute_command(check_command)
        
        return exit_code == 0
```

#### 2. æ‰¹é‡éƒ¨ç½²ç®¡ç†å™¨

```python
class BatchDeploymentManager:
    def __init__(self, hosts_config, config_manager):
        self.batch_executor = BatchExecutor(hosts_config)
        self.config_manager = config_manager
        self.logger = logging.getLogger(__name__)
    
    def deploy_to_all(self, app_name, version, deployment_config):
        """æ‰¹é‡éƒ¨ç½²åˆ°æ‰€æœ‰ä¸»æœº"""
        self.logger.info(f"å¼€å§‹æ‰¹é‡éƒ¨ç½² {app_name} ç‰ˆæœ¬ {version}")
        
        results = {}
        
        # å¹¶è¡Œéƒ¨ç½²
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_host = {}
            
            for host in self.batch_executor.hosts:
                deployer = ApplicationDeployer(host, self.config_manager)
                future = executor.submit(deployer.deploy_application, app_name, version, deployment_config)
                future_to_host[future] = host.host
            
            for future in future_to_host:
                host = future_to_host[future]
                try:
                    success = future.result()
                    results[host] = success
                    status = "æˆåŠŸ" if success else "å¤±è´¥"
                    self.logger.info(f"ä¸»æœº {host} éƒ¨ç½²{status}")
                except Exception as e:
                    results[host] = False
                    self.logger.error(f"ä¸»æœº {host} éƒ¨ç½²å¼‚å¸¸: {str(e)}")
        
        # ç»Ÿè®¡ç»“æœ
        success_count = sum(1 for success in results.values() if success)
        total_count = len(results)
        
        self.logger.info(f"æ‰¹é‡éƒ¨ç½²å®Œæˆ: {success_count}/{total_count} æˆåŠŸ")
        return results
```

### ç›‘æ§ä¸å‘Šè­¦

#### 1. ç³»ç»Ÿç›‘æ§

```python
import psutil
import time
from datetime import datetime

class SystemMonitor:
    def __init__(self, remote_executor):
        self.remote_executor = remote_executor
        self.logger = logging.getLogger(__name__)
    
    def get_system_info(self):
        """è·å–ç³»ç»Ÿä¿¡æ¯"""
        commands = {
            'cpu_usage': "top -bn1 | grep 'Cpu(s)' | awk '{print $2}' | cut -d'%' -f1",
            'memory_usage': "free | grep Mem | awk '{printf \"%.2f\", $3/$2 * 100.0}'",
            'disk_usage': "df / | tail -1 | awk '{print $5}' | cut -d'%' -f1",
            'load_average': "uptime | awk -F'load average:' '{print $2}'",
            'process_count': "ps aux | wc -l"
        }
        
        system_info = {}
        
        for metric, command in commands.items():
            output, error, exit_code = self.remote_executor.execute_command(command)
            if exit_code == 0 and output.strip():
                try:
                    system_info[metric] = float(output.strip())
                except ValueError:
                    system_info[metric] = 0
            else:
                system_info[metric] = 0
        
        return system_info
    
    def check_system_health(self, thresholds):
        """æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€"""
        system_info = self.get_system_info()
        alerts = []
        
        # CPUä½¿ç”¨ç‡æ£€æŸ¥
        if system_info.get('cpu_usage', 0) > thresholds.get('cpu_threshold', 80):
            alerts.append(f"CPUä½¿ç”¨ç‡è¿‡é«˜: {system_info['cpu_usage']:.1f}%")
        
        # å†…å­˜ä½¿ç”¨ç‡æ£€æŸ¥
        if system_info.get('memory_usage', 0) > thresholds.get('memory_threshold', 80):
            alerts.append(f"å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: {system_info['memory_usage']:.1f}%")
        
        # ç£ç›˜ä½¿ç”¨ç‡æ£€æŸ¥
        if system_info.get('disk_usage', 0) > thresholds.get('disk_threshold', 85):
            alerts.append(f"ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜: {system_info['disk_usage']:.1f}%")
        
        return alerts, system_info

class ApplicationMonitor:
    def __init__(self, remote_executor):
        self.remote_executor = remote_executor
        self.logger = logging.getLogger(__name__)
    
    def check_application_status(self, app_name):
        """æ£€æŸ¥åº”ç”¨çŠ¶æ€"""
        commands = [
            f"systemctl is-active {app_name}",
            f"pgrep -f {app_name}",
            f"netstat -tlnp | grep {app_name}"
        ]
        
        status = {
            'service_active': False,
            'process_running': False,
            'port_listening': False
        }
        
        # æ£€æŸ¥æœåŠ¡çŠ¶æ€
        output, error, exit_code = self.remote_executor.execute_command(commands[0])
        status['service_active'] = output.strip() == 'active'
        
        # æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
        output, error, exit_code = self.remote_executor.execute_command(commands[1])
        status['process_running'] = exit_code == 0
        
        # æ£€æŸ¥ç«¯å£ç›‘å¬
        output, error, exit_code = self.remote_executor.execute_command(commands[2])
        status['port_listening'] = exit_code == 0
        
        return status
    
    def get_application_metrics(self, app_name):
        """è·å–åº”ç”¨æŒ‡æ ‡"""
        commands = {
            'process_count': f"pgrep -c {app_name}",
            'memory_usage': f"ps aux | grep {app_name} | grep -v grep | awk '{{sum+=$6}} END {{print sum}}'",
            'cpu_usage': f"ps aux | grep {app_name} | grep -v grep | awk '{{sum+=$3}} END {{print sum}}'"
        }
        
        metrics = {}
        
        for metric, command in commands.items():
            output, error, exit_code = self.remote_executor.execute_command(command)
            if exit_code == 0 and output.strip():
                try:
                    metrics[metric] = float(output.strip())
                except ValueError:
                    metrics[metric] = 0
            else:
                metrics[metric] = 0
        
        return metrics
```

#### 2. å‘Šè­¦ç³»ç»Ÿ

```python
class AlertManager:
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.logger = logging.getLogger(__name__)
        self.alert_history = []
    
    def send_alert(self, alert_type, message, severity='warning'):
        """å‘é€å‘Šè­¦"""
        alert = {
            'timestamp': datetime.now(),
            'type': alert_type,
            'message': message,
            'severity': severity
        }
        
        self.alert_history.append(alert)
        
        # æ ¹æ®ä¸¥é‡ç¨‹åº¦é€‰æ‹©å‘Šè­¦æ–¹å¼
        if severity == 'critical':
            self._send_critical_alert(alert)
        elif severity == 'warning':
            self._send_warning_alert(alert)
        else:
            self._send_info_alert(alert)
        
        self.logger.warning(f"å‘Šè­¦: {message}")
    
    def _send_critical_alert(self, alert):
        """å‘é€ä¸¥é‡å‘Šè­¦"""
        # å®ç°é‚®ä»¶ã€çŸ­ä¿¡ã€ç”µè¯ç­‰å‘Šè­¦æ–¹å¼
        print(f"ğŸš¨ ä¸¥é‡å‘Šè­¦: {alert['message']}")
    
    def _send_warning_alert(self, alert):
        """å‘é€è­¦å‘Šå‘Šè­¦"""
        # å®ç°é‚®ä»¶ã€é’‰é’‰ç­‰å‘Šè­¦æ–¹å¼
        print(f"âš ï¸ è­¦å‘Š: {alert['message']}")
    
    def _send_info_alert(self, alert):
        """å‘é€ä¿¡æ¯å‘Šè­¦"""
        # å®ç°æ—¥å¿—è®°å½•ç­‰å‘Šè­¦æ–¹å¼
        print(f"â„¹ï¸ ä¿¡æ¯: {alert['message']}")
    
    def get_alert_history(self, hours=24):
        """è·å–å‘Šè­¦å†å²"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        return [alert for alert in self.alert_history if alert['timestamp'] > cutoff_time]

class MonitoringScheduler:
    def __init__(self, system_monitor, app_monitor, alert_manager, config_manager):
        self.system_monitor = system_monitor
        self.app_monitor = app_monitor
        self.alert_manager = alert_manager
        self.config_manager = config_manager
        self.logger = logging.getLogger(__name__)
        self.running = False
    
    def start_monitoring(self, interval=60):
        """å¼€å§‹ç›‘æ§"""
        self.running = True
        self.logger.info("å¼€å§‹ç³»ç»Ÿç›‘æ§")
        
        while self.running:
            try:
                self._monitoring_cycle()
                time.sleep(interval)
            except KeyboardInterrupt:
                self.stop_monitoring()
            except Exception as e:
                self.logger.error(f"ç›‘æ§å¼‚å¸¸: {str(e)}")
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.running = False
        self.logger.info("åœæ­¢ç³»ç»Ÿç›‘æ§")
    
    def _monitoring_cycle(self):
        """ç›‘æ§å‘¨æœŸ"""
        # ç³»ç»Ÿå¥åº·æ£€æŸ¥
        thresholds = self.config_manager.get_config('monitoring', 'thresholds') or {}
        alerts, system_info = self.system_monitor.check_system_health(thresholds)
        
        for alert in alerts:
            self.alert_manager.send_alert('system', alert, 'warning')
        
        # åº”ç”¨çŠ¶æ€æ£€æŸ¥
        apps = self.config_manager.get_config('monitoring', 'applications') or []
        for app in apps:
            status = self.app_monitor.check_application_status(app)
            
            if not status['service_active']:
                self.alert_manager.send_alert('application', f"åº”ç”¨ {app} æœåŠ¡æœªè¿è¡Œ", 'critical')
            
            if not status['process_running']:
                self.alert_manager.send_alert('application', f"åº”ç”¨ {app} è¿›ç¨‹æœªè¿è¡Œ", 'critical')
```

### CI/CDæµæ°´çº¿

#### 1. æ„å»ºæµæ°´çº¿

```python
class BuildPipeline:
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.logger = logging.getLogger(__name__)
    
    def build_application(self, app_name, version, build_config):
        """æ„å»ºåº”ç”¨"""
        self.logger.info(f"å¼€å§‹æ„å»ºåº”ç”¨ {app_name} ç‰ˆæœ¬ {version}")
        
        # 1. ä»£ç æ£€å‡º
        if not self._checkout_code(app_name, build_config):
            return False
        
        # 2. ä¾èµ–å®‰è£…
        if not self._install_dependencies(app_name, build_config):
            return False
        
        # 3. ä»£ç æµ‹è¯•
        if not self._run_tests(app_name, build_config):
            return False
        
        # 4. æ„å»ºæ‰“åŒ…
        if not self._build_package(app_name, version, build_config):
            return False
        
        # 5. ä¸Šä¼ åˆ¶å“
        if not self._upload_artifact(app_name, version, build_config):
            return False
        
        self.logger.info(f"åº”ç”¨ {app_name} ç‰ˆæœ¬ {version} æ„å»ºæˆåŠŸ")
        return True
    
    def _checkout_code(self, app_name, build_config):
        """ä»£ç æ£€å‡º"""
        repo_url = build_config.get('repo_url')
        branch = build_config.get('branch', 'main')
        workspace = build_config.get('workspace', f'/tmp/builds/{app_name}')
        
        commands = [
            f"mkdir -p {workspace}",
            f"cd {workspace}",
            f"git clone {repo_url} .",
            f"git checkout {branch}",
            f"git pull origin {branch}"
        ]
        
        for command in commands:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            if result.returncode != 0:
                self.logger.error(f"ä»£ç æ£€å‡ºå¤±è´¥: {result.stderr}")
                return False
        
        return True
    
    def _install_dependencies(self, app_name, build_config):
        """å®‰è£…ä¾èµ–"""
        workspace = build_config.get('workspace', f'/tmp/builds/{app_name}')
        requirements_file = build_config.get('requirements_file', 'requirements.txt')
        
        if os.path.exists(os.path.join(workspace, requirements_file)):
            command = f"cd {workspace} && pip install -r {requirements_file}"
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            
            if result.returncode != 0:
                self.logger.error(f"ä¾èµ–å®‰è£…å¤±è´¥: {result.stderr}")
                return False
        
        return True
    
    def _run_tests(self, app_name, build_config):
        """è¿è¡Œæµ‹è¯•"""
        workspace = build_config.get('workspace', f'/tmp/builds/{app_name}')
        test_command = build_config.get('test_command', 'python -m pytest')
        
        command = f"cd {workspace} && {test_command}"
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        
        if result.returncode != 0:
            self.logger.error(f"æµ‹è¯•å¤±è´¥: {result.stderr}")
            return False
        
        return True
    
    def _build_package(self, app_name, version, build_config):
        """æ„å»ºåŒ…"""
        workspace = build_config.get('workspace', f'/tmp/builds/{app_name}')
        build_command = build_config.get('build_command', f'python setup.py sdist')
        
        command = f"cd {workspace} && {build_command}"
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        
        if result.returncode != 0:
            self.logger.error(f"æ„å»ºå¤±è´¥: {result.stderr}")
            return False
        
        return True
    
    def _upload_artifact(self, app_name, version, build_config):
        """ä¸Šä¼ åˆ¶å“"""
        # å®ç°åˆ¶å“ä¸Šä¼ é€»è¾‘
        return True
```

### å®æˆ˜æ¡ˆä¾‹ï¼šå®Œæ•´è‡ªåŠ¨åŒ–è¿ç»´ç³»ç»Ÿ

```python
class AutomatedOpsSystem:
    def __init__(self, config_file):
        self.config_manager = ConfigManager()
        self.log_manager = LogManager()
        self.logger = self.log_manager.setup_logger('automated_ops')
        
        # åŠ è½½é…ç½®
        self.load_config(config_file)
        
        # åˆå§‹åŒ–ç»„ä»¶
        self.batch_executor = BatchExecutor(self.hosts_config)
        self.alert_manager = AlertManager(self.config_manager)
        self.system_monitor = SystemMonitor(self.batch_executor.hosts[0])
        self.app_monitor = ApplicationMonitor(self.batch_executor.hosts[0])
        self.monitoring_scheduler = MonitoringScheduler(
            self.system_monitor, self.app_monitor, self.alert_manager, self.config_manager
        )
        self.build_pipeline = BuildPipeline(self.config_manager)
        self.deployment_manager = BatchDeploymentManager(self.hosts_config, self.config_manager)
    
    def load_config(self, config_file):
        """åŠ è½½ç³»ç»Ÿé…ç½®"""
        with open(config_file, 'r') as f:
            config = yaml.safe_load(f)
        
        self.hosts_config = config.get('hosts', [])
        self.apps_config = config.get('applications', {})
    
    def deploy_application(self, app_name, version):
        """éƒ¨ç½²åº”ç”¨"""
        self.logger.info(f"å¼€å§‹éƒ¨ç½²åº”ç”¨ {app_name} ç‰ˆæœ¬ {version}")
        
        # æ„å»ºåº”ç”¨
        build_config = self.apps_config.get(app_name, {}).get('build', {})
        if not self.build_pipeline.build_application(app_name, version, build_config):
            self.logger.error(f"åº”ç”¨ {app_name} æ„å»ºå¤±è´¥")
            return False
        
        # éƒ¨ç½²åº”ç”¨
        deployment_config = self.apps_config.get(app_name, {}).get('deployment', {})
        results = self.deployment_manager.deploy_to_all(app_name, version, deployment_config)
        
        success_count = sum(1 for success in results.values() if success)
        total_count = len(results)
        
        if success_count == total_count:
            self.logger.info(f"åº”ç”¨ {app_name} éƒ¨ç½²æˆåŠŸ")
            return True
        else:
            self.logger.error(f"åº”ç”¨ {app_name} éƒ¨åˆ†éƒ¨ç½²å¤±è´¥: {success_count}/{total_count}")
            return False
    
    def start_monitoring(self):
        """å¯åŠ¨ç›‘æ§"""
        self.logger.info("å¯åŠ¨ç³»ç»Ÿç›‘æ§")
        self.monitoring_scheduler.start_monitoring()
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.logger.info("åœæ­¢ç³»ç»Ÿç›‘æ§")
        self.monitoring_scheduler.stop_monitoring()
    
    def get_system_status(self):
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        status = {}
        
        # è·å–æ‰€æœ‰ä¸»æœºçš„ç³»ç»Ÿä¿¡æ¯
        for host in self.batch_executor.hosts:
            monitor = SystemMonitor(host)
            status[host.host] = monitor.get_system_info()
        
        return status

def main():
    """ä¸»å‡½æ•°"""
    # åˆ›å»ºè‡ªåŠ¨åŒ–è¿ç»´ç³»ç»Ÿ
    ops_system = AutomatedOpsSystem('ops_config.yaml')
    
    # éƒ¨ç½²åº”ç”¨ç¤ºä¾‹
    ops_system.deploy_application('webapp', 'v1.0.0')
    
    # å¯åŠ¨ç›‘æ§
    try:
        ops_system.start_monitoring()
    except KeyboardInterrupt:
        ops_system.stop_monitoring()

if __name__ == "__main__":
    main()
```

### ç†è®ºæ€»ç»“

è‡ªåŠ¨åŒ–è¿ç»´æ˜¯ç°ä»£ITåŸºç¡€è®¾æ–½ç®¡ç†çš„é‡è¦æ‰‹æ®µï¼Œé€šè¿‡è‡ªåŠ¨åŒ–å·¥å…·å’Œæµç¨‹ï¼Œèƒ½å¤Ÿæé«˜éƒ¨ç½²æ•ˆç‡ã€å‡å°‘äººä¸ºé”™è¯¯ã€å®ç°å¿«é€Ÿå“åº”å’Œæ•…éšœè‡ªæ„ˆï¼Œä¸ºä¸šåŠ¡è¿ç»­æ€§æä¾›ä¿éšœã€‚
