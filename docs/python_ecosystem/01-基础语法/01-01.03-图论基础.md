# 01.03 å›¾è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

å›¾è®ºæ˜¯ç ”ç©¶å›¾ç»“æ„çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨è®¡ç®—æœºç§‘å­¦ä¸­å¹¿æ³›åº”ç”¨äºç½‘ç»œã€ç®—æ³•å’Œæ•°æ®ç»“æ„ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰å›¾è®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å›¾çš„åŸºæœ¬å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼š
å›¾ $G = (V, E)$ ç”±é¡¶ç‚¹é›† $V$ å’Œè¾¹é›† $E$ ç»„æˆï¼Œå…¶ä¸­ $E \subseteq V \times V$

**Pythonå®ç°**ï¼š

```python
from typing import Set, List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from collections import defaultdict

class GraphType(Enum):
    UNDIRECTED = "undirected"
    DIRECTED = "directed"
    WEIGHTED = "weighted"

@dataclass
class Edge:
    """è¾¹"""
    source: Any
    target: Any
    weight: float = 1.0

class Graph:
    """å›¾çš„åŸºæœ¬å®ç°"""
    
    def __init__(self, graph_type: GraphType = GraphType.UNDIRECTED):
        self.vertices: Set[Any] = set()
        self.edges: Set[Edge] = set()
        self.graph_type = graph_type
        self.adjacency_list: Dict[Any, Set[Any]] = defaultdict(set)
    
    def add_vertex(self, vertex: Any) -> None:
        """æ·»åŠ é¡¶ç‚¹"""
        self.vertices.add(vertex)
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = set()
    
    def add_edge(self, source: Any, target: Any, weight: float = 1.0) -> None:
        """æ·»åŠ è¾¹"""
        self.add_vertex(source)
        self.add_vertex(target)
        
        edge = Edge(source, target, weight)
        self.edges.add(edge)
        
        self.adjacency_list[source].add(target)
        if self.graph_type == GraphType.UNDIRECTED:
            self.adjacency_list[target].add(source)
    
    def remove_vertex(self, vertex: Any) -> None:
        """ç§»é™¤é¡¶ç‚¹"""
        if vertex in self.vertices:
            self.vertices.remove(vertex)
            
            # ç§»é™¤ç›¸å…³è¾¹
            edges_to_remove = set()
            for edge in self.edges:
                if edge.source == vertex or edge.target == vertex:
                    edges_to_remove.add(edge)
            
            for edge in edges_to_remove:
                self.edges.remove(edge)
            
            # æ›´æ–°é‚»æ¥è¡¨
            if vertex in self.adjacency_list:
                del self.adjacency_list[vertex]
            
            for adj_list in self.adjacency_list.values():
                adj_list.discard(vertex)
    
    def remove_edge(self, source: Any, target: Any) -> None:
        """ç§»é™¤è¾¹"""
        edges_to_remove = set()
        for edge in self.edges:
            if edge.source == source and edge.target == target:
                edges_to_remove.add(edge)
        
        for edge in edges_to_remove:
            self.edges.remove(edge)
        
        self.adjacency_list[source].discard(target)
        if self.graph_type == GraphType.UNDIRECTED:
            self.adjacency_list[target].discard(source)
    
    def get_neighbors(self, vertex: Any) -> Set[Any]:
        """è·å–é‚»å±…"""
        return self.adjacency_list.get(vertex, set())
    
    def get_degree(self, vertex: Any) -> int:
        """è·å–åº¦æ•°"""
        return len(self.adjacency_list.get(vertex, set()))
    
    def is_connected(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¿é€š"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        visited = set()
        self._dfs(start_vertex, visited)
        
        return len(visited) == len(self.vertices)
    
    def _dfs(self, vertex: Any, visited: Set[Any]) -> None:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited.add(vertex)
        for neighbor in self.adjacency_list[vertex]:
            if neighbor not in visited:
                self._dfs(neighbor, visited)
    
    def get_components(self) -> List[Set[Any]]:
        """è·å–è¿é€šåˆ†é‡"""
        visited = set()
        components = []
        
        for vertex in self.vertices:
            if vertex not in visited:
                component = set()
                self._dfs(vertex, component)
                components.append(component)
                visited.update(component)
        
        return components
    
    def __repr__(self) -> str:
        return f"Graph(vertices={len(self.vertices)}, edges={len(self.edges)}, type={self.graph_type.value})"

# ç¤ºä¾‹ï¼šåŸºæœ¬å›¾æ“ä½œ
def demonstrate_basic_graph():
    """æ¼”ç¤ºåŸºæœ¬å›¾æ“ä½œ"""
    # åˆ›å»ºæ— å‘å›¾
    graph = Graph(GraphType.UNDIRECTED)
    
    # æ·»åŠ é¡¶ç‚¹å’Œè¾¹
    graph.add_edge(1, 2)
    graph.add_edge(2, 3)
    graph.add_edge(3, 4)
    graph.add_edge(4, 1)
    graph.add_edge(2, 4)
    
    print("åŸºæœ¬å›¾æ“ä½œç¤ºä¾‹:")
    print(f"å›¾: {graph}")
    print(f"é¡¶ç‚¹: {graph.vertices}")
    print(f"è¾¹æ•°: {len(graph.edges)}")
    print(f"è¿é€šæ€§: {graph.is_connected()}")
    print(f"é¡¶ç‚¹1çš„åº¦æ•°: {graph.get_degree(1)}")
    print(f"é¡¶ç‚¹1çš„é‚»å±…: {graph.get_neighbors(1)}")
    
    return graph

# è¿è¡Œç¤ºä¾‹
basic_graph = demonstrate_basic_graph()
```

### 2. å›¾çš„éå†ç®—æ³•

#### 2.1 æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)

**æ•°å­¦å®šä¹‰**ï¼š
DFSæ˜¯ä¸€ä¸ªé€’å½’ç®—æ³•ï¼Œè®¿é—®é¡ºåºæ»¡è¶³ï¼š$visit(v) \rightarrow visit(neighbor(v))$

**Pythonå®ç°**ï¼š

```python
class GraphTraversal:
    """å›¾éå†ç®—æ³•"""
    
    def __init__(self, graph: Graph):
        self.graph = graph
    
    def dfs(self, start_vertex: Any) -> List[Any]:
        """æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        result = []
        
        def dfs_recursive(vertex: Any):
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                
                for neighbor in self.graph.get_neighbors(vertex):
                    dfs_recursive(neighbor)
        
        dfs_recursive(start_vertex)
        return result
    
    def dfs_iterative(self, start_vertex: Any) -> List[Any]:
        """è¿­ä»£å¼æ·±åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        result = []
        stack = [start_vertex]
        
        while stack:
            vertex = stack.pop()
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                
                # å°†é‚»å±…æŒ‰ç›¸åé¡ºåºå‹å…¥æ ˆï¼ˆä¿æŒæ­£ç¡®é¡ºåºï¼‰
                neighbors = list(self.graph.get_neighbors(vertex))
                for neighbor in reversed(neighbors):
                    if neighbor not in visited:
                        stack.append(neighbor)
        
        return result
    
    def bfs(self, start_vertex: Any) -> List[Any]:
        """å¹¿åº¦ä¼˜å…ˆæœç´¢"""
        visited = set()
        result = []
        queue = [start_vertex]
        visited.add(start_vertex)
        
        while queue:
            vertex = queue.pop(0)
            result.append(vertex)
            
            for neighbor in self.graph.get_neighbors(vertex):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return result

# ç¤ºä¾‹ï¼šå›¾éå†
def demonstrate_graph_traversal():
    """æ¼”ç¤ºå›¾éå†"""
    # åˆ›å»ºå›¾
    graph = Graph()
    graph.add_edge(1, 2)
    graph.add_edge(1, 3)
    graph.add_edge(2, 4)
    graph.add_edge(2, 5)
    graph.add_edge(3, 6)
    graph.add_edge(3, 7)
    
    traversal = GraphTraversal(graph)
    
    print("å›¾éå†ç¤ºä¾‹:")
    print(f"DFS (é€’å½’): {traversal.dfs(1)}")
    print(f"DFS (è¿­ä»£): {traversal.dfs_iterative(1)}")
    print(f"BFS: {traversal.bfs(1)}")
    
    return traversal

# è¿è¡Œç¤ºä¾‹
traversal_demo = demonstrate_graph_traversal()
```

#### 2.2 æœ€çŸ­è·¯å¾„ç®—æ³•

**æ•°å­¦å®šä¹‰**ï¼š
æœ€çŸ­è·¯å¾„é—®é¢˜ï¼šæ‰¾åˆ°ä»é¡¶ç‚¹ $s$ åˆ°é¡¶ç‚¹ $t$ çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„æƒé‡å’Œæœ€å°ã€‚

**Pythonå®ç°**ï¼š

```python
from heapq import heappush, heappop
from typing import Dict, List, Tuple, Optional

class ShortestPath:
    """æœ€çŸ­è·¯å¾„ç®—æ³•"""
    
    def __init__(self, graph: Graph):
        self.graph = graph
    
    def dijkstra(self, start_vertex: Any) -> Tuple[Dict[Any, float], Dict[Any, Any]]:
        """Dijkstraç®—æ³•"""
        distances = {vertex: float('inf') for vertex in self.graph.vertices}
        distances[start_vertex] = 0
        previous = {}
        
        # ä¼˜å…ˆé˜Ÿåˆ—
        pq = [(0, start_vertex)]
        
        while pq:
            current_distance, current_vertex = heappop(pq)
            
            if current_distance > distances[current_vertex]:
                continue
            
            for neighbor in self.graph.get_neighbors(current_vertex):
                # æ‰¾åˆ°è¿æ¥å½“å‰é¡¶ç‚¹å’Œé‚»å±…çš„è¾¹
                edge_weight = 1.0  # ç®€åŒ–ï¼Œå‡è®¾æ‰€æœ‰è¾¹æƒé‡ä¸º1
                for edge in self.graph.edges:
                    if edge.source == current_vertex and edge.target == neighbor:
                        edge_weight = edge.weight
                        break
                
                distance = current_distance + edge_weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heappush(pq, (distance, neighbor))
        
        return distances, previous
    
    def bellman_ford(self, start_vertex: Any) -> Tuple[Dict[Any, float], Dict[Any, Any]]:
        """Bellman-Fordç®—æ³•"""
        distances = {vertex: float('inf') for vertex in self.graph.vertices}
        distances[start_vertex] = 0
        previous = {}
        
        # æ¾å¼›æ“ä½œ
        for _ in range(len(self.graph.vertices) - 1):
            for edge in self.graph.edges:
                if distances[edge.source] + edge.weight < distances[edge.target]:
                    distances[edge.target] = distances[edge.source] + edge.weight
                    previous[edge.target] = edge.source
        
        # æ£€æŸ¥è´Ÿç¯
        for edge in self.graph.edges:
            if distances[edge.source] + edge.weight < distances[edge.target]:
                raise ValueError("å›¾ä¸­å­˜åœ¨è´Ÿç¯")
        
        return distances, previous
    
    def get_path(self, previous: Dict[Any, Any], target: Any) -> List[Any]:
        """é‡å»ºè·¯å¾„"""
        path = []
        current = target
        
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        return list(reversed(path))

# ç¤ºä¾‹ï¼šæœ€çŸ­è·¯å¾„
def demonstrate_shortest_path():
    """æ¼”ç¤ºæœ€çŸ­è·¯å¾„ç®—æ³•"""
    # åˆ›å»ºå¸¦æƒå›¾
    graph = Graph(GraphType.WEIGHTED)
    graph.add_edge(1, 2, 4)
    graph.add_edge(1, 3, 2)
    graph.add_edge(2, 3, 1)
    graph.add_edge(2, 4, 5)
    graph.add_edge(3, 4, 8)
    graph.add_edge(3, 5, 10)
    graph.add_edge(4, 5, 2)
    
    sp = ShortestPath(graph)
    
    print("æœ€çŸ­è·¯å¾„ç¤ºä¾‹:")
    
    # Dijkstraç®—æ³•
    distances, previous = sp.dijkstra(1)
    print(f"Dijkstraè·ç¦»: {distances}")
    
    # é‡å»ºè·¯å¾„
    path_to_5 = sp.get_path(previous, 5)
    print(f"ä»1åˆ°5çš„è·¯å¾„: {path_to_5}")
    
    return sp

# è¿è¡Œç¤ºä¾‹
shortest_path_demo = demonstrate_shortest_path()
```

### 3. æœ€å°ç”Ÿæˆæ ‘

**æ•°å­¦å®šä¹‰**ï¼š
æœ€å°ç”Ÿæˆæ ‘æ˜¯è¿æ¥æ‰€æœ‰é¡¶ç‚¹çš„æœ€å°æƒé‡æ ‘ï¼š$T \subseteq E$ ä½¿å¾— $G' = (V, T)$ æ˜¯æ ‘ä¸” $\sum_{e \in T} w(e)$ æœ€å°ã€‚

**Pythonå®ç°**ï¼š

```python
class MinimumSpanningTree:
    """æœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    
    def __init__(self, graph: Graph):
        self.graph = graph
    
    def kruskal(self) -> Set[Edge]:
        """Kruskalç®—æ³•"""
        # æŒ‰æƒé‡æ’åºè¾¹
        sorted_edges = sorted(self.graph.edges, key=lambda e: e.weight)
        
        # å¹¶æŸ¥é›†
        parent = {vertex: vertex for vertex in self.graph.vertices}
        
        def find(vertex: Any) -> Any:
            if parent[vertex] != vertex:
                parent[vertex] = find(parent[vertex])
            return parent[vertex]
        
        def union(vertex1: Any, vertex2: Any) -> bool:
            root1, root2 = find(vertex1), find(vertex2)
            if root1 == root2:
                return False
            parent[root2] = root1
            return True
        
        mst_edges = set()
        
        for edge in sorted_edges:
            if union(edge.source, edge.target):
                mst_edges.add(edge)
                if len(mst_edges) == len(self.graph.vertices) - 1:
                    break
        
        return mst_edges
    
    def prim(self, start_vertex: Any) -> Set[Edge]:
        """Primç®—æ³•"""
        visited = {start_vertex}
        mst_edges = set()
        
        while len(visited) < len(self.graph.vertices):
            min_edge = None
            min_weight = float('inf')
            
            # æ‰¾åˆ°è¿æ¥å·²è®¿é—®å’Œæœªè®¿é—®é¡¶ç‚¹çš„æœ€å°æƒé‡è¾¹
            for edge in self.graph.edges:
                if ((edge.source in visited and edge.target not in visited) or
                    (edge.target in visited and edge.source not in visited)):
                    if edge.weight < min_weight:
                        min_weight = edge.weight
                        min_edge = edge
            
            if min_edge:
                mst_edges.add(min_edge)
                if min_edge.source in visited:
                    visited.add(min_edge.target)
                else:
                    visited.add(min_edge.source)
            else:
                break
        
        return mst_edges

# ç¤ºä¾‹ï¼šæœ€å°ç”Ÿæˆæ ‘
def demonstrate_mst():
    """æ¼”ç¤ºæœ€å°ç”Ÿæˆæ ‘"""
    # åˆ›å»ºå¸¦æƒå›¾
    graph = Graph(GraphType.WEIGHTED)
    graph.add_edge(1, 2, 4)
    graph.add_edge(1, 3, 2)
    graph.add_edge(2, 3, 1)
    graph.add_edge(2, 4, 5)
    graph.add_edge(3, 4, 8)
    graph.add_edge(3, 5, 10)
    graph.add_edge(4, 5, 2)
    
    mst = MinimumSpanningTree(graph)
    
    print("æœ€å°ç”Ÿæˆæ ‘ç¤ºä¾‹:")
    
    # Kruskalç®—æ³•
    kruskal_edges = mst.kruskal()
    kruskal_weight = sum(edge.weight for edge in kruskal_edges)
    print(f"Kruskal MST: {kruskal_edges}")
    print(f"Kruskalæ€»æƒé‡: {kruskal_weight}")
    
    # Primç®—æ³•
    prim_edges = mst.prim(1)
    prim_weight = sum(edge.weight for edge in prim_edges)
    print(f"Prim MST: {prim_edges}")
    print(f"Primæ€»æƒé‡: {prim_weight}")
    
    return mst

# è¿è¡Œç¤ºä¾‹
mst_demo = demonstrate_mst()
```

### 4. å›¾çš„ç‰¹æ®Šæ€§è´¨

#### 4.1 äºŒåˆ†å›¾

**æ•°å­¦å®šä¹‰**ï¼š
äºŒåˆ†å›¾ $G = (V_1 \cup V_2, E)$ å…¶ä¸­ $V_1 \cap V_2 = \emptyset$ ä¸” $E \subseteq V_1 \times V_2$

**Pythonå®ç°**ï¼š

```python
class BipartiteGraph:
    """äºŒåˆ†å›¾"""
    
    def __init__(self):
        self.left_vertices: Set[Any] = set()
        self.right_vertices: Set[Any] = set()
        self.edges: Set[Edge] = set()
    
    def add_left_vertex(self, vertex: Any) -> None:
        """æ·»åŠ å·¦ä¾§é¡¶ç‚¹"""
        self.left_vertices.add(vertex)
    
    def add_right_vertex(self, vertex: Any) -> None:
        """æ·»åŠ å³ä¾§é¡¶ç‚¹"""
        self.right_vertices.add(vertex)
    
    def add_edge(self, left_vertex: Any, right_vertex: Any, weight: float = 1.0) -> None:
        """æ·»åŠ è¾¹ï¼ˆä»å·¦åˆ°å³ï¼‰"""
        self.add_left_vertex(left_vertex)
        self.add_right_vertex(right_vertex)
        
        edge = Edge(left_vertex, right_vertex, weight)
        self.edges.add(edge)
    
    def is_bipartite(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºäºŒåˆ†å›¾"""
        # ä½¿ç”¨BFSç€è‰²
        colors = {}
        queue = []
        
        # ä»å·¦ä¾§é¡¶ç‚¹å¼€å§‹
        for vertex in self.left_vertices:
            if vertex not in colors:
                colors[vertex] = 0
                queue.append(vertex)
                
                while queue:
                    current = queue.pop(0)
                    current_color = colors[current]
                    
                    # æ£€æŸ¥é‚»å±…
                    for edge in self.edges:
                        neighbor = None
                        if edge.source == current:
                            neighbor = edge.target
                        elif edge.target == current:
                            neighbor = edge.source
                        
                        if neighbor is not None:
                            if neighbor not in colors:
                                colors[neighbor] = 1 - current_color
                                queue.append(neighbor)
                            elif colors[neighbor] == current_color:
                                return False
        
        return True

# ç¤ºä¾‹ï¼šäºŒåˆ†å›¾
def demonstrate_bipartite_graph():
    """æ¼”ç¤ºäºŒåˆ†å›¾"""
    bipartite = BipartiteGraph()
    
    # æ·»åŠ è¾¹
    bipartite.add_edge(1, 'A')
    bipartite.add_edge(1, 'B')
    bipartite.add_edge(2, 'A')
    bipartite.add_edge(2, 'C')
    bipartite.add_edge(3, 'B')
    bipartite.add_edge(3, 'C')
    
    print("äºŒåˆ†å›¾ç¤ºä¾‹:")
    print(f"å·¦ä¾§é¡¶ç‚¹: {bipartite.left_vertices}")
    print(f"å³ä¾§é¡¶ç‚¹: {bipartite.right_vertices}")
    print(f"è¾¹: {bipartite.edges}")
    print(f"æ˜¯äºŒåˆ†å›¾: {bipartite.is_bipartite()}")
    
    return bipartite

# è¿è¡Œç¤ºä¾‹
bipartite_demo = demonstrate_bipartite_graph()
```

#### 4.2 æ‹“æ‰‘æ’åº

**æ•°å­¦å®šä¹‰**ï¼š
æ‹“æ‰‘æ’åºæ˜¯DAGä¸­é¡¶ç‚¹çš„çº¿æ€§æ’åºï¼Œä½¿å¾—å¯¹äºæ¯æ¡è¾¹ $(u, v)$ï¼Œ$u$ åœ¨ $v$ ä¹‹å‰ã€‚

**Pythonå®ç°**ï¼š

```python
class TopologicalSort:
    """æ‹“æ‰‘æ’åº"""
    
    def __init__(self, graph: Graph):
        self.graph = graph
    
    def topological_sort(self) -> List[Any]:
        """æ‹“æ‰‘æ’åºï¼ˆKahnç®—æ³•ï¼‰"""
        # è®¡ç®—å…¥åº¦
        in_degree = {vertex: 0 for vertex in self.graph.vertices}
        
        for edge in self.graph.edges:
            in_degree[edge.target] += 1
        
        # æ‰¾åˆ°å…¥åº¦ä¸º0çš„é¡¶ç‚¹
        queue = [vertex for vertex, degree in in_degree.items() if degree == 0]
        result = []
        
        while queue:
            current = queue.pop(0)
            result.append(current)
            
            # å‡å°‘é‚»å±…çš„å…¥åº¦
            for neighbor in self.graph.get_neighbors(current):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰ç¯
        if len(result) != len(self.graph.vertices):
            raise ValueError("å›¾ä¸­å­˜åœ¨ç¯ï¼Œæ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº")
        
        return result
    
    def topological_sort_dfs(self) -> List[Any]:
        """æ‹“æ‰‘æ’åºï¼ˆDFSï¼‰"""
        visited = set()
        temp_visited = set()
        result = []
        
        def dfs(vertex: Any):
            if vertex in temp_visited:
                raise ValueError("å›¾ä¸­å­˜åœ¨ç¯")
            if vertex in visited:
                return
            
            temp_visited.add(vertex)
            
            for neighbor in self.graph.get_neighbors(vertex):
                dfs(neighbor)
            
            temp_visited.remove(vertex)
            visited.add(vertex)
            result.insert(0, vertex)
        
        for vertex in self.graph.vertices:
            if vertex not in visited:
                dfs(vertex)
        
        return result

# ç¤ºä¾‹ï¼šæ‹“æ‰‘æ’åº
def demonstrate_topological_sort():
    """æ¼”ç¤ºæ‹“æ‰‘æ’åº"""
    # åˆ›å»ºæœ‰å‘å›¾
    graph = Graph(GraphType.DIRECTED)
    graph.add_edge(1, 2)
    graph.add_edge(1, 3)
    graph.add_edge(2, 4)
    graph.add_edge(3, 4)
    graph.add_edge(4, 5)
    
    ts = TopologicalSort(graph)
    
    print("æ‹“æ‰‘æ’åºç¤ºä¾‹:")
    
    try:
        kahn_result = ts.topological_sort()
        print(f"Kahnç®—æ³•: {kahn_result}")
        
        dfs_result = ts.topological_sort_dfs()
        print(f"DFSç®—æ³•: {dfs_result}")
    except ValueError as e:
        print(f"é”™è¯¯: {e}")
    
    return ts

# è¿è¡Œç¤ºä¾‹
topo_sort_demo = demonstrate_topological_sort()
```

## ğŸ“Š å›¾è®ºæ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µ

1. **å›¾ç»“æ„**ï¼šé¡¶ç‚¹å’Œè¾¹çš„é›†åˆ
2. **éå†ç®—æ³•**ï¼šDFSã€BFS
3. **æœ€çŸ­è·¯å¾„**ï¼šDijkstraã€Bellman-Ford
4. **æœ€å°ç”Ÿæˆæ ‘**ï¼šKruskalã€Prim
5. **ç‰¹æ®Šå›¾**ï¼šäºŒåˆ†å›¾ã€DAG

### æ•°å­¦å½¢å¼åŒ–

å›¾è®ºå¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦ç»“æ„è¡¨ç¤ºï¼š

$$GraphTheory = (Graphs, Traversal, Paths, Trees, SpecialGraphs)$$

### Pythonå®ç°éªŒè¯

```python
class GraphTheoryValidator:
    """å›¾è®ºéªŒè¯å™¨"""
    
    def __init__(self):
        self.test_graph = Graph()
        self.test_graph.add_edge(1, 2)
        self.test_graph.add_edge(2, 3)
        self.test_graph.add_edge(3, 1)
    
    def validate_basic_operations(self) -> bool:
        """éªŒè¯åŸºæœ¬æ“ä½œ"""
        return (len(self.test_graph.vertices) == 3 and
                len(self.test_graph.edges) == 3)
    
    def validate_traversal(self) -> bool:
        """éªŒè¯éå†"""
        traversal = GraphTraversal(self.test_graph)
        dfs_result = traversal.dfs(1)
        return len(dfs_result) == 3
    
    def validate_shortest_path(self) -> bool:
        """éªŒè¯æœ€çŸ­è·¯å¾„"""
        sp = ShortestPath(self.test_graph)
        distances, _ = sp.dijkstra(1)
        return distances[2] == 1
    
    def validate_mst(self) -> bool:
        """éªŒè¯æœ€å°ç”Ÿæˆæ ‘"""
        mst = MinimumSpanningTree(self.test_graph)
        mst_edges = mst.kruskal()
        return len(mst_edges) == 2  # n-1æ¡è¾¹
    
    def run_all_tests(self) -> Dict[str, bool]:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        tests = {
            'basic_operations': self.validate_basic_operations(),
            'traversal': self.validate_traversal(),
            'shortest_path': self.validate_shortest_path(),
            'mst': self.validate_mst()
        }
        
        print("=== å›¾è®ºéªŒè¯ç»“æœ ===")
        for test_name, result in tests.items():
            print(f"{test_name}: {'PASS' if result else 'FAIL'}")
        
        return tests

# ä½¿ç”¨ç¤ºä¾‹
validator = GraphTheoryValidator()
test_results = validator.run_all_tests()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [01.01 é›†åˆè®ºåŸºç¡€](./01.01-é›†åˆè®ºåŸºç¡€.md)
- [01.02 é€»è¾‘å­¦åŸºç¡€](./01.02-é€»è¾‘å­¦åŸºç¡€.md)
- [02.01 ç®—æ³•ç†è®º](../02-ç†è®ºåŸºç¡€/02.01-ç®—æ³•ç†è®º.md)

---

*å›¾è®ºä¸ºç½‘ç»œåˆ†æã€ç®—æ³•è®¾è®¡å’Œæ•°æ®ç»“æ„æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ï¼Œé€šè¿‡å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥è§£å†³å„ç§å›¾ç›¸å…³çš„é—®é¢˜ã€‚*
