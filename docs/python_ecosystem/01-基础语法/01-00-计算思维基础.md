# 00. è®¡ç®—æ€ç»´åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

è®¡ç®—æ€ç»´æ˜¯è¿ç”¨è®¡ç®—æœºç§‘å­¦çš„åŸºç¡€æ¦‚å¿µè¿›è¡Œé—®é¢˜æ±‚è§£ã€ç³»ç»Ÿè®¾è®¡å’Œäººç±»è¡Œä¸ºç†è§£çš„æ€ç»´è¿‡ç¨‹ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰è®¡ç®—æ€ç»´ï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. è®¡ç®—æ€ç»´çš„å®šä¹‰

#### 1.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 1.1.1** (è®¡ç®—æ€ç»´)
è®¡ç®—æ€ç»´æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{CT} = (D, A, P, A', E)$ï¼Œå…¶ä¸­ï¼š

- $D$ æ˜¯é—®é¢˜åˆ†è§£ (Decomposition)
- $A$ æ˜¯æ¨¡å¼è¯†åˆ« (Pattern Recognition)
- $P$ æ˜¯æŠ½è±¡åŒ– (Abstraction)
- $A'$ æ˜¯ç®—æ³•è®¾è®¡ (Algorithm Design)
- $E$ æ˜¯è¯„ä¼° (Evaluation)

**å®šä¹‰ 1.1.2** (è®¡ç®—æ€ç»´è¿‡ç¨‹)
è®¡ç®—æ€ç»´è¿‡ç¨‹æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$\text{CT}: \text{Problem} \rightarrow \text{Solution}$$

#### 1.2 Pythonå®ç°

```python
from typing import TypeVar, Generic, Dict, Any, List, Callable, Set
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import time

T = TypeVar('T')

class CTComponent(Enum):
    """è®¡ç®—æ€ç»´ç»„ä»¶"""
    DECOMPOSITION = "decomposition"
    PATTERN_RECOGNITION = "pattern_recognition"
    ABSTRACTION = "abstraction"
    ALGORITHM_DESIGN = "algorithm_design"
    EVALUATION = "evaluation"

@dataclass
class Problem:
    """é—®é¢˜å®šä¹‰"""
    description: str
    constraints: List[str]
    goals: List[str]
    complexity: int

@dataclass
class Solution:
    """è§£å†³æ–¹æ¡ˆ"""
    algorithm: Callable
    complexity: str
    correctness: float
    efficiency: float

class ComputationalThinking:
    """è®¡ç®—æ€ç»´ç³»ç»Ÿ"""
    
    def __init__(self):
        self.decomposition_strategies: List[Callable] = []
        self.pattern_recognizers: List[Callable] = []
        self.abstraction_methods: List[Callable] = []
        self.algorithm_templates: List[Callable] = []
        self.evaluation_metrics: List[Callable] = []
    
    def add_decomposition_strategy(self, strategy: Callable) -> None:
        """æ·»åŠ åˆ†è§£ç­–ç•¥"""
        self.decomposition_strategies.append(strategy)
    
    def add_pattern_recognizer(self, recognizer: Callable) -> None:
        """æ·»åŠ æ¨¡å¼è¯†åˆ«å™¨"""
        self.pattern_recognizers.append(recognizer)
    
    def add_abstraction_method(self, method: Callable) -> None:
        """æ·»åŠ æŠ½è±¡åŒ–æ–¹æ³•"""
        self.abstraction_methods.append(method)
    
    def add_algorithm_template(self, template: Callable) -> None:
        """æ·»åŠ ç®—æ³•æ¨¡æ¿"""
        self.algorithm_templates.append(template)
    
    def add_evaluation_metric(self, metric: Callable) -> None:
        """æ·»åŠ è¯„ä¼°æŒ‡æ ‡"""
        self.evaluation_metrics.append(metric)
    
    def solve_problem(self, problem: Problem) -> Solution:
        """è§£å†³é—®é¢˜"""
        # 1. é—®é¢˜åˆ†è§£
        subproblems = self._decompose_problem(problem)
        
        # 2. æ¨¡å¼è¯†åˆ«
        patterns = self._recognize_patterns(subproblems)
        
        # 3. æŠ½è±¡åŒ–
        abstractions = self._abstract_problem(problem, patterns)
        
        # 4. ç®—æ³•è®¾è®¡
        algorithm = self._design_algorithm(abstractions)
        
        # 5. è¯„ä¼°
        solution = self._evaluate_solution(algorithm, problem)
        
        return solution
    
    def _decompose_problem(self, problem: Problem) -> List[Problem]:
        """é—®é¢˜åˆ†è§£"""
        subproblems = []
        
        for strategy in self.decomposition_strategies:
            try:
                subproblems.extend(strategy(problem))
            except Exception:
                continue
        
        return subproblems
    
    def _recognize_patterns(self, subproblems: List[Problem]) -> List[str]:
        """æ¨¡å¼è¯†åˆ«"""
        patterns = []
        
        for recognizer in self.pattern_recognizers:
            try:
                patterns.extend(recognizer(subproblems))
            except Exception:
                continue
        
        return patterns
    
    def _abstract_problem(self, problem: Problem, patterns: List[str]) -> Dict[str, Any]:
        """é—®é¢˜æŠ½è±¡åŒ–"""
        abstractions = {}
        
        for method in self.abstraction_methods:
            try:
                abstraction = method(problem, patterns)
                abstractions.update(abstraction)
            except Exception:
                continue
        
        return abstractions
    
    def _design_algorithm(self, abstractions: Dict[str, Any]) -> Callable:
        """ç®—æ³•è®¾è®¡"""
        for template in self.algorithm_templates:
            try:
                algorithm = template(abstractions)
                if algorithm:
                    return algorithm
            except Exception:
                continue
        
        # é»˜è®¤ç®—æ³•
        return lambda x: x
    
    def _evaluate_solution(self, algorithm: Callable, problem: Problem) -> Solution:
        """è§£å†³æ–¹æ¡ˆè¯„ä¼°"""
        correctness = 0.0
        efficiency = 0.0
        
        for metric in self.evaluation_metrics:
            try:
                score = metric(algorithm, problem)
                if 'correctness' in metric.__name__.lower():
                    correctness = score
                elif 'efficiency' in metric.__name__.lower():
                    efficiency = score
            except Exception:
                continue
        
        return Solution(
            algorithm=algorithm,
            complexity="O(n)",
            correctness=correctness,
            efficiency=efficiency
        )

# ç¤ºä¾‹ï¼šè®¡ç®—æ€ç»´ç³»ç»Ÿ
ct_system = ComputationalThinking()

# æ·»åŠ åˆ†è§£ç­–ç•¥
def divide_and_conquer_strategy(problem: Problem) -> List[Problem]:
    """åˆ†æ²»ç­–ç•¥"""
    if problem.complexity > 5:
        return [
            Problem(f"{problem.description} (Part 1)", problem.constraints, problem.goals, problem.complexity // 2),
            Problem(f"{problem.description} (Part 2)", problem.constraints, problem.goals, problem.complexity // 2)
        ]
    return [problem]

ct_system.add_decomposition_strategy(divide_and_conquer_strategy)

# æ·»åŠ æ¨¡å¼è¯†åˆ«å™¨
def sorting_pattern_recognizer(subproblems: List[Problem]) -> List[str]:
    """æ’åºæ¨¡å¼è¯†åˆ«"""
    patterns = []
    for subproblem in subproblems:
        if "sort" in subproblem.description.lower() or "order" in subproblem.description.lower():
            patterns.append("sorting")
    return patterns

ct_system.add_pattern_recognizer(sorting_pattern_recognizer)

# æ·»åŠ æŠ½è±¡åŒ–æ–¹æ³•
def data_structure_abstraction(problem: Problem, patterns: List[str]) -> Dict[str, Any]:
    """æ•°æ®ç»“æ„æŠ½è±¡åŒ–"""
    abstractions = {}
    
    if "sorting" in patterns:
        abstractions["data_structure"] = "array"
        abstractions["operation"] = "comparison"
    
    return abstractions

ct_system.add_abstraction_method(data_structure_abstraction)

# æ·»åŠ ç®—æ³•æ¨¡æ¿
def sorting_algorithm_template(abstractions: Dict[str, Any]) -> Callable:
    """æ’åºç®—æ³•æ¨¡æ¿"""
    if abstractions.get("data_structure") == "array":
        return lambda arr: sorted(arr)
    return None

ct_system.add_algorithm_template(sorting_algorithm_template)

# æ·»åŠ è¯„ä¼°æŒ‡æ ‡
def correctness_metric(algorithm: Callable, problem: Problem) -> float:
    """æ­£ç¡®æ€§è¯„ä¼°"""
    # ç®€åŒ–çš„æ­£ç¡®æ€§è¯„ä¼°
    return 0.9

def efficiency_metric(algorithm: Callable, problem: Problem) -> float:
    """æ•ˆç‡è¯„ä¼°"""
    # ç®€åŒ–çš„æ•ˆç‡è¯„ä¼°
    return 0.8

ct_system.add_evaluation_metric(correctness_metric)
ct_system.add_evaluation_metric(efficiency_metric)

# ä½¿ç”¨è®¡ç®—æ€ç»´è§£å†³é—®é¢˜
problem = Problem(
    description="Sort a list of numbers",
    constraints=["Must be in-place", "Must be stable"],
    goals=["Ascending order", "Efficient"],
    complexity=10
)

solution = ct_system.solve_problem(problem)
print(f"é—®é¢˜: {problem.description}")
print(f"ç®—æ³•å¤æ‚åº¦: {solution.complexity}")
print(f"æ­£ç¡®æ€§: {solution.correctness:.2f}")
print(f"æ•ˆç‡: {solution.efficiency:.2f}")
```

### 2. é—®é¢˜åˆ†è§£

#### 2.1 åˆ†è§£ç­–ç•¥

**å®šä¹‰ 2.1.1** (é—®é¢˜åˆ†è§£)
é—®é¢˜åˆ†è§£æ˜¯å°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºæ›´å°ã€æ›´æ˜“å¤„ç†çš„å­é—®é¢˜çš„è¿‡ç¨‹ï¼š
$$P = P_1 \oplus P_2 \oplus \ldots \oplus P_n$$

å…¶ä¸­ $\oplus$ è¡¨ç¤ºç»„åˆæ“ä½œã€‚

**Pythonå®ç°**ï¼š

```python
class ProblemDecomposition:
    """é—®é¢˜åˆ†è§£ç³»ç»Ÿ"""
    
    def __init__(self):
        self.decomposition_strategies: Dict[str, Callable] = {}
        self.combination_strategies: Dict[str, Callable] = {}
    
    def add_decomposition_strategy(self, name: str, strategy: Callable) -> None:
        """æ·»åŠ åˆ†è§£ç­–ç•¥"""
        self.decomposition_strategies[name] = strategy
    
    def add_combination_strategy(self, name: str, strategy: Callable) -> None:
        """æ·»åŠ ç»„åˆç­–ç•¥"""
        self.combination_strategies[name] = strategy
    
    def decompose(self, problem: Any, strategy_name: str = "default") -> List[Any]:
        """åˆ†è§£é—®é¢˜"""
        if strategy_name in self.decomposition_strategies:
            return self.decomposition_strategies[strategy_name](problem)
        else:
            return self._default_decomposition(problem)
    
    def combine(self, subproblems: List[Any], strategy_name: str = "default") -> Any:
        """ç»„åˆå­é—®é¢˜"""
        if strategy_name in self.combination_strategies:
            return self.combination_strategies[strategy_name](subproblems)
        else:
            return self._default_combination(subproblems)
    
    def _default_decomposition(self, problem: Any) -> List[Any]:
        """é»˜è®¤åˆ†è§£ç­–ç•¥"""
        if isinstance(problem, (list, tuple)):
            return list(problem)
        elif isinstance(problem, dict):
            return list(problem.values())
        else:
            return [problem]
    
    def _default_combination(self, subproblems: List[Any]) -> Any:
        """é»˜è®¤ç»„åˆç­–ç•¥"""
        if all(isinstance(x, (int, float)) for x in subproblems):
            return sum(subproblems)
        elif all(isinstance(x, str) for x in subproblems):
            return "".join(subproblems)
        else:
            return subproblems

# ç¤ºä¾‹ï¼šé—®é¢˜åˆ†è§£
decomposition = ProblemDecomposition()

# æ·»åŠ åˆ†æ²»åˆ†è§£ç­–ç•¥
def divide_and_conquer(problem: List[int]) -> List[List[int]]:
    """åˆ†æ²»åˆ†è§£"""
    if len(problem) <= 1:
        return [problem]
    
    mid = len(problem) // 2
    return [problem[:mid], problem[mid:]]

decomposition.add_decomposition_strategy("divide_and_conquer", divide_and_conquer)

# æ·»åŠ åˆ†æ²»ç»„åˆç­–ç•¥
def merge_combine(subproblems: List[List[int]]) -> List[int]:
    """å½’å¹¶ç»„åˆ"""
    if len(subproblems) == 1:
        return subproblems[0]
    
    result = []
    i, j = 0, 0
    
    while i < len(subproblems[0]) and j < len(subproblems[1]):
        if subproblems[0][i] <= subproblems[1][j]:
            result.append(subproblems[0][i])
            i += 1
        else:
            result.append(subproblems[1][j])
            j += 1
    
    result.extend(subproblems[0][i:])
    result.extend(subproblems[1][j:])
    
    return result

decomposition.add_combination_strategy("merge", merge_combine)

# ä½¿ç”¨åˆ†è§£ç­–ç•¥
problem = [64, 34, 25, 12, 22, 11, 90]
subproblems = decomposition.decompose(problem, "divide_and_conquer")
print(f"åŸå§‹é—®é¢˜: {problem}")
print(f"åˆ†è§£ç»“æœ: {subproblems}")

# ä½¿ç”¨ç»„åˆç­–ç•¥
solution = decomposition.combine(subproblems, "merge")
print(f"ç»„åˆç»“æœ: {solution}")
```

#### 2.2 é€’å½’åˆ†è§£

**å®šä¹‰ 2.2.1** (é€’å½’åˆ†è§£)
é€’å½’åˆ†è§£æ˜¯ä½¿ç”¨é€’å½’æ–¹æ³•è¿›è¡Œé—®é¢˜åˆ†è§£ï¼š
$$T(n) = aT(n/b) + f(n)$$

å…¶ä¸­ $a$ æ˜¯å­é—®é¢˜æ•°é‡ï¼Œ$b$ æ˜¯é—®é¢˜è§„æ¨¡å› å­ï¼Œ$f(n)$ æ˜¯ç»„åˆæˆæœ¬ã€‚

**Pythonå®ç°**ï¼š

```python
class RecursiveDecomposition:
    """é€’å½’åˆ†è§£ç³»ç»Ÿ"""
    
    def __init__(self):
        self.base_cases: Dict[str, Callable] = {}
        self.recursive_cases: Dict[str, Callable] = {}
    
    def add_base_case(self, problem_type: str, handler: Callable) -> None:
        """æ·»åŠ åŸºæœ¬æƒ…å†µ"""
        self.base_cases[problem_type] = handler
    
    def add_recursive_case(self, problem_type: str, handler: Callable) -> None:
        """æ·»åŠ é€’å½’æƒ…å†µ"""
        self.recursive_cases[problem_type] = handler
    
    def solve_recursively(self, problem: Any) -> Any:
        """é€’å½’æ±‚è§£"""
        problem_type = self._classify_problem(problem)
        
        # æ£€æŸ¥åŸºæœ¬æƒ…å†µ
        if problem_type in self.base_cases:
            return self.base_cases[problem_type](problem)
        
        # é€’å½’æƒ…å†µ
        if problem_type in self.recursive_cases:
            subproblems = self.recursive_cases[problem_type](problem)
            solutions = [self.solve_recursively(subproblem) for subproblem in subproblems]
            return self._combine_solutions(solutions)
        
        # é»˜è®¤æƒ…å†µ
        return problem
    
    def _classify_problem(self, problem: Any) -> str:
        """é—®é¢˜åˆ†ç±»"""
        if isinstance(problem, (list, tuple)):
            if len(problem) <= 1:
                return "base_case"
            else:
                return "recursive_case"
        else:
            return "simple_case"
    
    def _combine_solutions(self, solutions: List[Any]) -> Any:
        """ç»„åˆè§£å†³æ–¹æ¡ˆ"""
        if all(isinstance(x, (int, float)) for x in solutions):
            return sum(solutions)
        elif all(isinstance(x, list) for x in solutions):
            result = []
            for solution in solutions:
                result.extend(solution)
            return result
        else:
            return solutions

# ç¤ºä¾‹ï¼šé€’å½’åˆ†è§£
recursive = RecursiveDecomposition()

# æ·»åŠ åŸºæœ¬æƒ…å†µ
def base_case_handler(problem: List[int]) -> List[int]:
    """åŸºæœ¬æƒ…å†µå¤„ç†"""
    return problem

recursive.add_base_case("base_case", base_case_handler)

# æ·»åŠ é€’å½’æƒ…å†µ
def recursive_case_handler(problem: List[int]) -> List[List[int]]:
    """é€’å½’æƒ…å†µå¤„ç†"""
    if len(problem) <= 1:
        return [problem]
    
    mid = len(problem) // 2
    return [problem[:mid], problem[mid:]]

recursive.add_recursive_case("recursive_case", recursive_case_handler)

# ä½¿ç”¨é€’å½’åˆ†è§£
problem = [64, 34, 25, 12, 22, 11, 90]
solution = recursive.solve_recursively(problem)
print(f"é€’å½’åˆ†è§£ç»“æœ: {solution}")
```

### 3. æ¨¡å¼è¯†åˆ«

#### 3.1 æ¨¡å¼ç±»å‹

**å®šä¹‰ 3.1.1** (æ¨¡å¼)
æ¨¡å¼æ˜¯é—®é¢˜ä¸­é‡å¤å‡ºç°çš„ç»“æ„æˆ–å…³ç³»ï¼š
$$\text{Pattern} = \langle \text{Structure}, \text{Context}, \text{Solution} \rangle$$

**Pythonå®ç°**ï¼š

```python
from typing import Optional, List, Dict, Any, Callable
from enum import Enum

class PatternType(Enum):
    """æ¨¡å¼ç±»å‹"""
    STRUCTURAL = "structural"
    BEHAVIORAL = "behavioral"
    ALGORITHMIC = "algorithmic"
    DATA = "data"

@dataclass
class Pattern:
    """æ¨¡å¼å®šä¹‰"""
    name: str
    pattern_type: PatternType
    structure: str
    context: str
    solution: Callable
    confidence: float

class PatternRecognition:
    """æ¨¡å¼è¯†åˆ«ç³»ç»Ÿ"""
    
    def __init__(self):
        self.patterns: List[Pattern] = []
        self.recognizers: Dict[PatternType, List[Callable]] = {
            PatternType.STRUCTURAL: [],
            PatternType.BEHAVIORAL: [],
            PatternType.ALGORITHMIC: [],
            PatternType.DATA: []
        }
    
    def add_pattern(self, pattern: Pattern) -> None:
        """æ·»åŠ æ¨¡å¼"""
        self.patterns.append(pattern)
    
    def add_recognizer(self, pattern_type: PatternType, recognizer: Callable) -> None:
        """æ·»åŠ è¯†åˆ«å™¨"""
        self.recognizers[pattern_type].append(recognizer)
    
    def recognize_patterns(self, data: Any) -> List[Pattern]:
        """è¯†åˆ«æ¨¡å¼"""
        recognized_patterns = []
        
        for pattern_type, recognizers in self.recognizers.items():
            for recognizer in recognizers:
                try:
                    patterns = recognizer(data)
                    if patterns:
                        recognized_patterns.extend(patterns)
                except Exception:
                    continue
        
        return recognized_patterns
    
    def match_pattern(self, data: Any, pattern: Pattern) -> bool:
        """åŒ¹é…æ¨¡å¼"""
        try:
            # ç®€åŒ–çš„æ¨¡å¼åŒ¹é…
            if pattern.pattern_type == PatternType.STRUCTURAL:
                return self._match_structural_pattern(data, pattern)
            elif pattern.pattern_type == PatternType.ALGORITHMIC:
                return self._match_algorithmic_pattern(data, pattern)
            else:
                return False
        except Exception:
            return False
    
    def _match_structural_pattern(self, data: Any, pattern: Pattern) -> bool:
        """åŒ¹é…ç»“æ„æ¨¡å¼"""
        if isinstance(data, list) and "array" in pattern.structure.lower():
            return True
        elif isinstance(data, dict) and "hash" in pattern.structure.lower():
            return True
        return False
    
    def _match_algorithmic_pattern(self, data: Any, pattern: Pattern) -> bool:
        """åŒ¹é…ç®—æ³•æ¨¡å¼"""
        if isinstance(data, list) and len(data) > 1:
            if "sort" in pattern.name.lower():
                return data != sorted(data)
            elif "search" in pattern.name.lower():
                return True
        return False

# ç¤ºä¾‹ï¼šæ¨¡å¼è¯†åˆ«
pattern_recognition = PatternRecognition()

# æ·»åŠ æ¨¡å¼
sorting_pattern = Pattern(
    name="Sorting Pattern",
    pattern_type=PatternType.ALGORITHMIC,
    structure="array of comparable elements",
    context="need to arrange elements in order",
    solution=lambda x: sorted(x),
    confidence=0.9
)

pattern_recognition.add_pattern(sorting_pattern)

# æ·»åŠ è¯†åˆ«å™¨
def algorithmic_pattern_recognizer(data: Any) -> List[Pattern]:
    """ç®—æ³•æ¨¡å¼è¯†åˆ«å™¨"""
    patterns = []
    
    if isinstance(data, list) and len(data) > 1:
        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ’åº
        if data != sorted(data):
            patterns.append(sorting_pattern)
    
    return patterns

pattern_recognition.add_recognizer(PatternType.ALGORITHMIC, algorithmic_pattern_recognizer)

# ä½¿ç”¨æ¨¡å¼è¯†åˆ«
data = [64, 34, 25, 12, 22, 11, 90]
patterns = pattern_recognition.recognize_patterns(data)
print(f"æ•°æ®: {data}")
print(f"è¯†åˆ«åˆ°çš„æ¨¡å¼: {[p.name for p in patterns]}")
```

#### 3.2 æ¨¡å¼åº”ç”¨

**å®šä¹‰ 3.2.1** (æ¨¡å¼åº”ç”¨)
æ¨¡å¼åº”ç”¨æ˜¯å°†è¯†åˆ«åˆ°çš„æ¨¡å¼è½¬æ¢ä¸ºè§£å†³æ–¹æ¡ˆçš„è¿‡ç¨‹ï¼š
$$\text{Apply}(\text{Pattern}, \text{Problem}) = \text{Solution}$$

**Pythonå®ç°**ï¼š

```python
class PatternApplication:
    """æ¨¡å¼åº”ç”¨ç³»ç»Ÿ"""
    
    def __init__(self):
        self.pattern_solutions: Dict[str, Callable] = {}
        self.adaptation_rules: List[Callable] = []
    
    def add_pattern_solution(self, pattern_name: str, solution: Callable) -> None:
        """æ·»åŠ æ¨¡å¼è§£å†³æ–¹æ¡ˆ"""
        self.pattern_solutions[pattern_name] = solution
    
    def add_adaptation_rule(self, rule: Callable) -> None:
        """æ·»åŠ é€‚é…è§„åˆ™"""
        self.adaptation_rules.append(rule)
    
    def apply_pattern(self, pattern: Pattern, problem: Any) -> Any:
        """åº”ç”¨æ¨¡å¼"""
        # ç›´æ¥åº”ç”¨
        if pattern.name in self.pattern_solutions:
            try:
                return self.pattern_solutions[pattern.name](problem)
            except Exception:
                pass
        
        # é€‚é…åº”ç”¨
        for rule in self.adaptation_rules:
            try:
                adapted_solution = rule(pattern, problem)
                if adapted_solution:
                    return adapted_solution
            except Exception:
                continue
        
        # é»˜è®¤åº”ç”¨
        return pattern.solution(problem)
    
    def adapt_solution(self, pattern: Pattern, problem: Any) -> Callable:
        """é€‚é…è§£å†³æ–¹æ¡ˆ"""
        # ç®€åŒ–çš„é€‚é…é€»è¾‘
        def adapted_solution(data: Any) -> Any:
            try:
                return pattern.solution(data)
            except Exception:
                # é™çº§å¤„ç†
                if isinstance(data, list):
                    return list(data)
                else:
                    return data
        
        return adapted_solution

# ç¤ºä¾‹ï¼šæ¨¡å¼åº”ç”¨
pattern_application = PatternApplication()

# æ·»åŠ æ¨¡å¼è§£å†³æ–¹æ¡ˆ
def sorting_solution(data: List[int]) -> List[int]:
    """æ’åºè§£å†³æ–¹æ¡ˆ"""
    return sorted(data)

pattern_application.add_pattern_solution("Sorting Pattern", sorting_solution)

# æ·»åŠ é€‚é…è§„åˆ™
def sorting_adaptation_rule(pattern: Pattern, problem: Any) -> Callable:
    """æ’åºé€‚é…è§„åˆ™"""
    if "sort" in pattern.name.lower() and isinstance(problem, list):
        def adapted_sorting(data: List[Any]) -> List[Any]:
            try:
                return sorted(data)
            except TypeError:
                # å¤„ç†ä¸å¯æ¯”è¾ƒçš„å…ƒç´ 
                return data
        return adapted_sorting
    return None

pattern_application.add_adaptation_rule(sorting_adaptation_rule)

# åº”ç”¨æ¨¡å¼
problem = [64, 34, 25, 12, 22, 11, 90]
solution = pattern_application.apply_pattern(sorting_pattern, problem)
print(f"åº”ç”¨æ¨¡å¼åçš„è§£å†³æ–¹æ¡ˆ: {solution}")
```

### 4. ç®—æ³•è®¾è®¡

#### 4.1 ç®—æ³•æ¨¡æ¿

**å®šä¹‰ 4.1.1** (ç®—æ³•æ¨¡æ¿)
ç®—æ³•æ¨¡æ¿æ˜¯å¯é‡ç”¨çš„ç®—æ³•æ¡†æ¶ï¼š
$$\text{Template}(\text{Parameters}) = \text{Algorithm}$$

**Pythonå®ç°**ï¼š

```python
class AlgorithmTemplate:
    """ç®—æ³•æ¨¡æ¿ç³»ç»Ÿ"""
    
    def __init__(self):
        self.templates: Dict[str, Callable] = {}
        self.parameters: Dict[str, List[str]] = {}
    
    def add_template(self, name: str, template: Callable, parameters: List[str]) -> None:
        """æ·»åŠ ç®—æ³•æ¨¡æ¿"""
        self.templates[name] = template
        self.parameters[name] = parameters
    
    def instantiate_template(self, template_name: str, **kwargs) -> Callable:
        """å®ä¾‹åŒ–æ¨¡æ¿"""
        if template_name not in self.templates:
            raise ValueError(f"Template {template_name} not found")
        
        template = self.templates[template_name]
        required_params = self.parameters[template_name]
        
        # æ£€æŸ¥å‚æ•°
        missing_params = [param for param in required_params if param not in kwargs]
        if missing_params:
            raise ValueError(f"Missing parameters: {missing_params}")
        
        # åˆ›å»ºå®ä¾‹åŒ–å‡½æ•°
        def instantiated_algorithm(*args, **kwargs2):
            return template(*args, **kwargs, **kwargs2)
        
        return instantiated_algorithm
    
    def list_templates(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æ¨¡æ¿"""
        return list(self.templates.keys())
    
    def get_template_info(self, template_name: str) -> Dict[str, Any]:
        """è·å–æ¨¡æ¿ä¿¡æ¯"""
        if template_name not in self.templates:
            return {}
        
        return {
            "name": template_name,
            "parameters": self.parameters[template_name],
            "template": self.templates[template_name]
        }

# ç¤ºä¾‹ï¼šç®—æ³•æ¨¡æ¿
algorithm_templates = AlgorithmTemplate()

# æ·»åŠ åˆ†æ²»æ¨¡æ¿
def divide_and_conquer_template(divide_func, conquer_func, combine_func):
    """åˆ†æ²»ç®—æ³•æ¨¡æ¿"""
    def algorithm(data):
        if len(data) <= 1:
            return conquer_func(data)
        
        subproblems = divide_func(data)
        solutions = [algorithm(subproblem) for subproblem in subproblems]
        return combine_func(solutions)
    
    return algorithm

algorithm_templates.add_template(
    "divide_and_conquer",
    divide_and_conquer_template,
    ["divide_func", "conquer_func", "combine_func"]
)

# æ·»åŠ åŠ¨æ€è§„åˆ’æ¨¡æ¿
def dynamic_programming_template(transition_func, base_cases):
    """åŠ¨æ€è§„åˆ’æ¨¡æ¿"""
    def algorithm(n):
        if n in base_cases:
            return base_cases[n]
        
        return transition_func(n, algorithm)
    
    return algorithm

algorithm_templates.add_template(
    "dynamic_programming",
    dynamic_programming_template,
    ["transition_func", "base_cases"]
)

# å®ä¾‹åŒ–åˆ†æ²»æ¨¡æ¿
def divide_list(data):
    """åˆ†å‰²åˆ—è¡¨"""
    mid = len(data) // 2
    return [data[:mid], data[mid:]]

def conquer_single(data):
    """å¤„ç†å•ä¸ªå…ƒç´ """
    return data

def combine_sorted(lists):
    """åˆå¹¶æ’åºåˆ—è¡¨"""
    result = []
    i, j = 0, 0
    
    while i < len(lists[0]) and j < len(lists[1]):
        if lists[0][i] <= lists[1][j]:
            result.append(lists[0][i])
            i += 1
        else:
            result.append(lists[1][j])
            j += 1
    
    result.extend(lists[0][i:])
    result.extend(lists[1][j:])
    
    return result

merge_sort = algorithm_templates.instantiate_template(
    "divide_and_conquer",
    divide_func=divide_list,
    conquer_func=conquer_single,
    combine_func=combine_sorted
)

# ä½¿ç”¨å®ä¾‹åŒ–çš„ç®—æ³•
data = [64, 34, 25, 12, 22, 11, 90]
result = merge_sort(data)
print(f"ä½¿ç”¨åˆ†æ²»æ¨¡æ¿çš„ç»“æœ: {result}")

# å®ä¾‹åŒ–åŠ¨æ€è§„åˆ’æ¨¡æ¿
def fibonacci_transition(n, fib_func):
    """æ–æ³¢é‚£å¥‘è½¬ç§»å‡½æ•°"""
    return fib_func(n-1) + fib_func(n-2)

fibonacci_base_cases = {0: 0, 1: 1}

fibonacci = algorithm_templates.instantiate_template(
    "dynamic_programming",
    transition_func=fibonacci_transition,
    base_cases=fibonacci_base_cases
)

# ä½¿ç”¨åŠ¨æ€è§„åˆ’ç®—æ³•
fib_10 = fibonacci(10)
print(f"æ–æ³¢é‚£å¥‘(10) = {fib_10}")
```

#### 4.2 ç®—æ³•åˆ†æ

**å®šä¹‰ 4.2.1** (ç®—æ³•å¤æ‚åº¦)
ç®—æ³•å¤æ‚åº¦æ˜¯ç®—æ³•æ€§èƒ½çš„åº¦é‡ï¼š
$$T(n) = O(f(n))$$

å…¶ä¸­ $f(n)$ æ˜¯å¢é•¿å‡½æ•°ã€‚

**Pythonå®ç°**ï¼š

```python
import time
import random
from typing import Callable, List, Tuple, Dict, Any

class AlgorithmAnalysis:
    """ç®—æ³•åˆ†æç³»ç»Ÿ"""
    
    def __init__(self):
        self.analysis_results: Dict[str, Dict[str, Any]] = {}
    
    def analyze_algorithm(self, algorithm: Callable, test_cases: List[Any]) -> Dict[str, Any]:
        """åˆ†æç®—æ³•"""
        results = {
            "time_complexity": {},
            "space_complexity": {},
            "correctness": 0.0,
            "performance": {}
        }
        
        # æ—¶é—´å¤æ‚åº¦åˆ†æ
        results["time_complexity"] = self._analyze_time_complexity(algorithm, test_cases)
        
        # ç©ºé—´å¤æ‚åº¦åˆ†æ
        results["space_complexity"] = self._analyze_space_complexity(algorithm, test_cases)
        
        # æ­£ç¡®æ€§åˆ†æ
        results["correctness"] = self._analyze_correctness(algorithm, test_cases)
        
        # æ€§èƒ½åˆ†æ
        results["performance"] = self._analyze_performance(algorithm, test_cases)
        
        return results
    
    def _analyze_time_complexity(self, algorithm: Callable, test_cases: List[Any]) -> Dict[str, Any]:
        """åˆ†ææ—¶é—´å¤æ‚åº¦"""
        times = []
        sizes = []
        
        for test_case in test_cases:
            size = len(test_case) if hasattr(test_case, '__len__') else 1
            start_time = time.time()
            
            try:
                algorithm(test_case)
                end_time = time.time()
                execution_time = end_time - start_time
                times.append(execution_time)
                sizes.append(size)
            except Exception:
                continue
        
        # ç®€åŒ–çš„å¤æ‚åº¦ä¼°è®¡
        if len(times) >= 2:
            # è®¡ç®—å¢é•¿ç‡
            growth_rates = []
            for i in range(1, len(times)):
                if times[i-1] > 0:
                    rate = times[i] / times[i-1]
                    growth_rates.append(rate)
            
            if growth_rates:
                avg_growth = sum(growth_rates) / len(growth_rates)
                if avg_growth < 1.5:
                    complexity = "O(1)"
                elif avg_growth < 2.5:
                    complexity = "O(log n)"
                elif avg_growth < 4:
                    complexity = "O(n)"
                elif avg_growth < 8:
                    complexity = "O(n log n)"
                else:
                    complexity = "O(nÂ²)"
            else:
                complexity = "Unknown"
        else:
            complexity = "Insufficient data"
        
        return {
            "complexity": complexity,
            "times": times,
            "sizes": sizes
        }
    
    def _analyze_space_complexity(self, algorithm: Callable, test_cases: List[Any]) -> Dict[str, Any]:
        """åˆ†æç©ºé—´å¤æ‚åº¦"""
        # ç®€åŒ–çš„ç©ºé—´å¤æ‚åº¦åˆ†æ
        return {
            "complexity": "O(n)",  # é»˜è®¤ä¼°è®¡
            "note": "Space complexity analysis requires detailed implementation analysis"
        }
    
    def _analyze_correctness(self, algorithm: Callable, test_cases: List[Any]) -> float:
        """åˆ†ææ­£ç¡®æ€§"""
        correct_count = 0
        total_count = 0
        
        for test_case in test_cases:
            try:
                result = algorithm(test_case)
                # ç®€åŒ–çš„æ­£ç¡®æ€§æ£€æŸ¥
                if isinstance(result, list) and len(result) == len(test_case):
                    if result == sorted(test_case):
                        correct_count += 1
                total_count += 1
            except Exception:
                continue
        
        return correct_count / total_count if total_count > 0 else 0.0
    
    def _analyze_performance(self, algorithm: Callable, test_cases: List[Any]) -> Dict[str, Any]:
        """åˆ†ææ€§èƒ½"""
        execution_times = []
        
        for test_case in test_cases:
            start_time = time.time()
            try:
                algorithm(test_case)
                end_time = time.time()
                execution_times.append(end_time - start_time)
            except Exception:
                continue
        
        if execution_times:
            return {
                "average_time": sum(execution_times) / len(execution_times),
                "min_time": min(execution_times),
                "max_time": max(execution_times),
                "total_time": sum(execution_times)
            }
        else:
            return {
                "average_time": 0,
                "min_time": 0,
                "max_time": 0,
                "total_time": 0
            }

# ç¤ºä¾‹ï¼šç®—æ³•åˆ†æ
algorithm_analysis = AlgorithmAnalysis()

# æµ‹è¯•ç”¨ä¾‹
test_cases = [
    [1],
    [1, 2],
    [2, 1],
    [1, 2, 3],
    [3, 2, 1],
    [1, 3, 2],
    list(range(10)),
    list(range(10, 0, -1)),
    [random.randint(1, 100) for _ in range(20)]
]

# åˆ†ææ’åºç®—æ³•
analysis_result = algorithm_analysis.analyze_algorithm(sorted, test_cases)

print("ç®—æ³•åˆ†æç»“æœ:")
print(f"æ—¶é—´å¤æ‚åº¦: {analysis_result['time_complexity']['complexity']}")
print(f"ç©ºé—´å¤æ‚åº¦: {analysis_result['space_complexity']['complexity']}")
print(f"æ­£ç¡®æ€§: {analysis_result['correctness']:.2f}")
print(f"å¹³å‡æ‰§è¡Œæ—¶é—´: {analysis_result['performance']['average_time']:.6f}ç§’")
```

## ğŸ“š ç†è®ºè¯æ˜

### 1. è®¡ç®—æ€ç»´å®Œå¤‡æ€§å®šç†

**å®šç† 1.1** (è®¡ç®—æ€ç»´å®Œå¤‡æ€§)
å¦‚æœé—®é¢˜ $P$ æ˜¯å¯è®¡ç®—çš„ï¼Œåˆ™å­˜åœ¨è®¡ç®—æ€ç»´æ–¹æ³•å¯ä»¥è§£å†³ $P$ã€‚

**è¯æ˜**ï¼š

1. é—®é¢˜å¯è®¡ç®—æ„å‘³ç€å­˜åœ¨ç®—æ³• $A$ å¯ä»¥è§£å†³ $P$
2. è®¡ç®—æ€ç»´åŒ…å«ç®—æ³•è®¾è®¡ç»„ä»¶
3. å› æ­¤è®¡ç®—æ€ç»´å¯ä»¥è®¾è®¡å‡ºç®—æ³• $A$
4. æ‰€ä»¥è®¡ç®—æ€ç»´å¯ä»¥è§£å†³ $P$

### 2. æ¨¡å¼è¯†åˆ«æ­£ç¡®æ€§å®šç†

**å®šç† 2.1** (æ¨¡å¼è¯†åˆ«æ­£ç¡®æ€§)
å¦‚æœæ¨¡å¼ $M$ æ­£ç¡®è¯†åˆ«ï¼Œåˆ™åº”ç”¨ $M$ çš„è§£å†³æ–¹æ¡ˆæ˜¯æ­£ç¡®çš„ã€‚

**è¯æ˜**ï¼š

1. æ¨¡å¼ $M$ æ­£ç¡®è¯†åˆ«æ„å‘³ç€ $M$ ä¸é—®é¢˜åŒ¹é…
2. æ¨¡å¼ $M$ åŒ…å«ç»è¿‡éªŒè¯çš„è§£å†³æ–¹æ¡ˆ
3. å› æ­¤åº”ç”¨ $M$ çš„è§£å†³æ–¹æ¡ˆæ˜¯æ­£ç¡®çš„

## ğŸ”— ç›¸å…³æ¦‚å¿µ

- [ç¼–ç¨‹è¯­è¨€å“²å­¦](../00-ç¼–ç¨‹å“²å­¦/00-ç¼–ç¨‹è¯­è¨€å“²å­¦.md)
- [å½¢å¼åŒ–æ€ç»´åŸºç¡€](../01-å½¢å¼åŒ–æ€ç»´/00-å½¢å¼åŒ–æ€ç»´åŸºç¡€.md)
- [ç®—æ³•ç†è®º](../../02-ç†è®ºåŸºç¡€/01-ç®—æ³•ç†è®º/00-ç®—æ³•ç†è®ºåŸºç¡€.md)

## ğŸ“– å‚è€ƒæ–‡çŒ®

1. Wing, J. M. (2006). Computational Thinking
2. Denning, P. J. (2009). The Profession of IT: Beyond Computational Thinking
3. Aho, A. V. (2012). Computation and Computational Thinking
4. Selby, C. C. (2014). How can the teaching of programming be used to enhance computational thinking skills?

---

*è®¡ç®—æ€ç»´ä¸ºé—®é¢˜æ±‚è§£æä¾›äº†ç³»ç»Ÿæ€§çš„æ–¹æ³•ï¼Œæ˜¯è½¯ä»¶å·¥ç¨‹å’Œè®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒæ€ç»´æ–¹å¼ã€‚*
