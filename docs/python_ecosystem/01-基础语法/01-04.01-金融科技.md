# 04.01 é‡‘èç§‘æŠ€

## ğŸ“‹ æ¦‚è¿°

é‡‘èç§‘æŠ€ï¼ˆFinTechï¼‰æ˜¯é‡‘èä¸æŠ€æœ¯çš„èåˆï¼Œæ¶µç›–æ”¯ä»˜ã€é“¶è¡Œã€ä¿é™©ã€æŠ•èµ„ç­‰æ ¸å¿ƒé‡‘èä¸šåŠ¡ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰é‡‘èç§‘æŠ€çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶æä¾›Pythonå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é‡‘èç³»ç»Ÿçš„åŸºç¡€æ¨¡å‹

**æ•°å­¦å®šä¹‰**ï¼š
é‡‘èç³»ç»Ÿæ˜¯ä¸€ä¸ªå››å…ƒç»„ $F = (A, T, R, S)$ï¼Œå…¶ä¸­ï¼š

- $A$ æ˜¯è´¦æˆ·é›†åˆ
- $T$ æ˜¯äº¤æ˜“é›†åˆ
- $R$ æ˜¯è§„åˆ™é›†åˆ
- $S$ æ˜¯çŠ¶æ€é›†åˆ

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Set, Any, Optional, Decimal
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
from decimal import Decimal, getcontext
import uuid

# è®¾ç½®ç²¾åº¦
getcontext().prec = 28

class AccountType(Enum):
    CHECKING = "checking"
    SAVINGS = "savings"
    CREDIT = "credit"
    INVESTMENT = "investment"

class TransactionType(Enum):
    DEPOSIT = "deposit"
    WITHDRAWAL = "withdrawal"
    TRANSFER = "transfer"
    PAYMENT = "payment"
    INTEREST = "interest"

class AccountStatus(Enum):
    ACTIVE = "active"
    SUSPENDED = "suspended"
    CLOSED = "closed"

@dataclass
class Account:
    """è´¦æˆ·"""
    account_id: str
    account_type: AccountType
    balance: Decimal
    currency: str
    status: AccountStatus
    created_at: datetime
    owner_id: str
    transactions: List['Transaction'] = field(default_factory=list)
    
    def __post_init__(self):
        if not self.account_id:
            self.account_id = str(uuid.uuid4())
        if not self.created_at:
            self.created_at = datetime.now()

@dataclass
class Transaction:
    """äº¤æ˜“"""
    transaction_id: str
    from_account: str
    to_account: str
    amount: Decimal
    currency: str
    transaction_type: TransactionType
    timestamp: datetime
    description: str
    status: str = "pending"
    
    def __post_init__(self):
        if not self.transaction_id:
            self.transaction_id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = datetime.now()

@dataclass
class FinancialRule:
    """é‡‘èè§„åˆ™"""
    rule_id: str
    name: str
    condition: str
    action: str
    priority: int
    
    def __post_init__(self):
        if not self.rule_id:
            self.rule_id = str(uuid.uuid4())

class FinancialSystem:
    """é‡‘èç³»ç»Ÿ"""
    
    def __init__(self):
        self.accounts: Dict[str, Account] = {}
        self.transactions: Dict[str, Transaction] = {}
        self.rules: List[FinancialRule] = []
        self.system_state: Dict[str, Any] = {}
    
    def create_account(self, account_type: AccountType, owner_id: str, 
                      initial_balance: Decimal = Decimal('0'), 
                      currency: str = "USD") -> Account:
        """åˆ›å»ºè´¦æˆ·"""
        account = Account(
            account_id="",
            account_type=account_type,
            balance=initial_balance,
            currency=currency,
            status=AccountStatus.ACTIVE,
            created_at=datetime.now(),
            owner_id=owner_id
        )
        
        self.accounts[account.account_id] = account
        return account
    
    def execute_transaction(self, from_account_id: str, to_account_id: str,
                          amount: Decimal, transaction_type: TransactionType,
                          description: str = "") -> Transaction:
        """æ‰§è¡Œäº¤æ˜“"""
        # éªŒè¯è´¦æˆ·
        if from_account_id not in self.accounts:
            raise ValueError(f"From account {from_account_id} not found")
        if to_account_id not in self.accounts:
            raise ValueError(f"To account {to_account_id} not found")
        
        from_account = self.accounts[from_account_id]
        to_account = self.accounts[to_account_id]
        
        # éªŒè¯ä½™é¢
        if transaction_type in [TransactionType.WITHDRAWAL, TransactionType.TRANSFER]:
            if from_account.balance < amount:
                raise ValueError("Insufficient funds")
        
        # åˆ›å»ºäº¤æ˜“
        transaction = Transaction(
            transaction_id="",
            from_account=from_account_id,
            to_account=to_account_id,
            amount=amount,
            currency=from_account.currency,
            transaction_type=transaction_type,
            timestamp=datetime.now(),
            description=description
        )
        
        # æ›´æ–°ä½™é¢
        if transaction_type == TransactionType.DEPOSIT:
            to_account.balance += amount
        elif transaction_type == TransactionType.WITHDRAWAL:
            from_account.balance -= amount
        elif transaction_type == TransactionType.TRANSFER:
            from_account.balance -= amount
            to_account.balance += amount
        
        # è®°å½•äº¤æ˜“
        from_account.transactions.append(transaction)
        to_account.transactions.append(transaction)
        self.transactions[transaction.transaction_id] = transaction
        
        # åº”ç”¨è§„åˆ™
        self._apply_rules(transaction)
        
        return transaction
    
    def _apply_rules(self, transaction: Transaction):
        """åº”ç”¨é‡‘èè§„åˆ™"""
        for rule in sorted(self.rules, key=lambda r: r.priority):
            if self._evaluate_condition(rule.condition, transaction):
                self._execute_action(rule.action, transaction)
    
    def _evaluate_condition(self, condition: str, transaction: Transaction) -> bool:
        """è¯„ä¼°è§„åˆ™æ¡ä»¶"""
        # ç®€åŒ–çš„æ¡ä»¶è¯„ä¼°
        if condition == "large_transaction":
            return transaction.amount > Decimal('10000')
        elif condition == "suspicious_pattern":
            return len(transaction.from_account) > 0  # ç®€åŒ–
        return False
    
    def _execute_action(self, action: str, transaction: Transaction):
        """æ‰§è¡Œè§„åˆ™åŠ¨ä½œ"""
        if action == "flag_transaction":
            transaction.status = "flagged"
        elif action == "require_approval":
            transaction.status = "pending_approval"

# ç¤ºä¾‹ï¼šåŸºæœ¬é‡‘èç³»ç»Ÿ
def demonstrate_basic_financial_system():
    """æ¼”ç¤ºåŸºæœ¬é‡‘èç³»ç»Ÿ"""
    system = FinancialSystem()
    
    # åˆ›å»ºè´¦æˆ·
    account1 = system.create_account(AccountType.CHECKING, "user1", Decimal('1000'))
    account2 = system.create_account(AccountType.SAVINGS, "user2", Decimal('500'))
    
    print("åŸºæœ¬é‡‘èç³»ç»Ÿç¤ºä¾‹:")
    print(f"è´¦æˆ·1: {account1.account_id}, ä½™é¢: {account1.balance}")
    print(f"è´¦æˆ·2: {account2.account_id}, ä½™é¢: {account2.balance}")
    
    # æ‰§è¡Œäº¤æ˜“
    transaction = system.execute_transaction(
        account1.account_id, account2.account_id,
        Decimal('200'), TransactionType.TRANSFER,
        "è½¬è´¦"
    )
    
    print(f"äº¤æ˜“: {transaction.transaction_id}")
    print(f"è´¦æˆ·1ä½™é¢: {account1.balance}")
    print(f"è´¦æˆ·2ä½™é¢: {account2.balance}")
    
    return system

# è¿è¡Œç¤ºä¾‹
basic_system = demonstrate_basic_financial_system()
```

### 2. æ”¯ä»˜ç³»ç»Ÿ

#### 2.1 æ”¯ä»˜å¤„ç†æ¨¡å‹

**æ•°å­¦å®šä¹‰**ï¼š
æ”¯ä»˜å¤„ç†æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼š$P \xrightarrow{process} P'$ï¼Œå…¶ä¸­çŠ¶æ€åŒ…æ‹¬ï¼špending â†’ processing â†’ completed/failed

**Pythonå®ç°**ï¼š

```python
from typing import Optional, Callable
from enum import Enum
import hashlib
import hmac

class PaymentStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class PaymentMethod(Enum):
    CREDIT_CARD = "credit_card"
    DEBIT_CARD = "debit_card"
    BANK_TRANSFER = "bank_transfer"
    DIGITAL_WALLET = "digital_wallet"
    CRYPTOCURRENCY = "cryptocurrency"

@dataclass
class Payment:
    """æ”¯ä»˜"""
    payment_id: str
    amount: Decimal
    currency: str
    from_account: str
    to_account: str
    payment_method: PaymentMethod
    status: PaymentStatus
    created_at: datetime
    processed_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.payment_id:
            self.payment_id = str(uuid.uuid4())
        if not self.created_at:
            self.created_at = datetime.now()

class PaymentProcessor:
    """æ”¯ä»˜å¤„ç†å™¨"""
    
    def __init__(self):
        self.payments: Dict[str, Payment] = {}
        self.processors: Dict[PaymentMethod, Callable] = {}
        self.fraud_detectors: List[Callable] = []
    
    def register_processor(self, method: PaymentMethod, processor: Callable):
        """æ³¨å†Œæ”¯ä»˜å¤„ç†å™¨"""
        self.processors[method] = processor
    
    def register_fraud_detector(self, detector: Callable):
        """æ³¨å†Œæ¬ºè¯ˆæ£€æµ‹å™¨"""
        self.fraud_detectors.append(detector)
    
    def create_payment(self, amount: Decimal, currency: str, from_account: str,
                      to_account: str, payment_method: PaymentMethod,
                      metadata: Dict[str, Any] = None) -> Payment:
        """åˆ›å»ºæ”¯ä»˜"""
        payment = Payment(
            payment_id="",
            amount=amount,
            currency=currency,
            from_account=from_account,
            to_account=to_account,
            payment_method=payment_method,
            status=PaymentStatus.PENDING,
            created_at=datetime.now(),
            metadata=metadata or {}
        )
        
        self.payments[payment.payment_id] = payment
        return payment
    
    def process_payment(self, payment_id: str) -> bool:
        """å¤„ç†æ”¯ä»˜"""
        if payment_id not in self.payments:
            raise ValueError(f"Payment {payment_id} not found")
        
        payment = self.payments[payment_id]
        
        # æ¬ºè¯ˆæ£€æµ‹
        if self._detect_fraud(payment):
            payment.status = PaymentStatus.FAILED
            return False
        
        # æ›´æ–°çŠ¶æ€
        payment.status = PaymentStatus.PROCESSING
        
        # å¤„ç†æ”¯ä»˜
        if payment.payment_method in self.processors:
            processor = self.processors[payment.payment_method]
            success = processor(payment)
            
            if success:
                payment.status = PaymentStatus.COMPLETED
                payment.processed_at = datetime.now()
            else:
                payment.status = PaymentStatus.FAILED
        else:
            payment.status = PaymentStatus.FAILED
            return False
        
        return payment.status == PaymentStatus.COMPLETED
    
    def _detect_fraud(self, payment: Payment) -> bool:
        """æ¬ºè¯ˆæ£€æµ‹"""
        for detector in self.fraud_detectors:
            if detector(payment):
                return True
        return False

# ç¤ºä¾‹æ”¯ä»˜å¤„ç†å™¨
def credit_card_processor(payment: Payment) -> bool:
    """ä¿¡ç”¨å¡æ”¯ä»˜å¤„ç†å™¨"""
    # æ¨¡æ‹Ÿä¿¡ç”¨å¡å¤„ç†
    import random
    return random.random() > 0.1  # 90%æˆåŠŸç‡

def bank_transfer_processor(payment: Payment) -> bool:
    """é“¶è¡Œè½¬è´¦å¤„ç†å™¨"""
    # æ¨¡æ‹Ÿé“¶è¡Œè½¬è´¦
    import random
    return random.random() > 0.05  # 95%æˆåŠŸç‡

# ç¤ºä¾‹æ¬ºè¯ˆæ£€æµ‹å™¨
def large_amount_detector(payment: Payment) -> bool:
    """å¤§é¢äº¤æ˜“æ£€æµ‹å™¨"""
    return payment.amount > Decimal('10000')

def frequency_detector(payment: Payment) -> bool:
    """é¢‘ç‡æ£€æµ‹å™¨"""
    # ç®€åŒ–å®ç°
    return False

# ç¤ºä¾‹ï¼šæ”¯ä»˜ç³»ç»Ÿ
def demonstrate_payment_system():
    """æ¼”ç¤ºæ”¯ä»˜ç³»ç»Ÿ"""
    processor = PaymentProcessor()
    
    # æ³¨å†Œå¤„ç†å™¨
    processor.register_processor(PaymentMethod.CREDIT_CARD, credit_card_processor)
    processor.register_processor(PaymentMethod.BANK_TRANSFER, bank_transfer_processor)
    
    # æ³¨å†Œæ¬ºè¯ˆæ£€æµ‹å™¨
    processor.register_fraud_detector(large_amount_detector)
    processor.register_fraud_detector(frequency_detector)
    
    # åˆ›å»ºæ”¯ä»˜
    payment = processor.create_payment(
        amount=Decimal('100'),
        currency="USD",
        from_account="user1",
        to_account="merchant1",
        payment_method=PaymentMethod.CREDIT_CARD,
        metadata={"description": "è´­ä¹°å•†å“"}
    )
    
    print("æ”¯ä»˜ç³»ç»Ÿç¤ºä¾‹:")
    print(f"æ”¯ä»˜ID: {payment.payment_id}")
    print(f"é‡‘é¢: {payment.amount} {payment.currency}")
    print(f"çŠ¶æ€: {payment.status.value}")
    
    # å¤„ç†æ”¯ä»˜
    success = processor.process_payment(payment.payment_id)
    print(f"å¤„ç†ç»“æœ: {'æˆåŠŸ' if success else 'å¤±è´¥'}")
    print(f"æœ€ç»ˆçŠ¶æ€: {payment.status.value}")
    
    return processor

# è¿è¡Œç¤ºä¾‹
payment_system = demonstrate_payment_system()
```

#### 2.2 åŠ å¯†ä¸å®‰å…¨

**æ•°å­¦å®šä¹‰**ï¼š
åŠ å¯†å‡½æ•° $E: M \times K \rightarrow C$ï¼Œè§£å¯†å‡½æ•° $D: C \times K \rightarrow M$

**Pythonå®ç°**ï¼š

```python
import hashlib
import hmac
import secrets
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64

class CryptographyService:
    """åŠ å¯†æœåŠ¡"""
    
    def __init__(self):
        self.key = Fernet.generate_key()
        self.cipher_suite = Fernet(self.key)
    
    def encrypt_data(self, data: str) -> str:
        """åŠ å¯†æ•°æ®"""
        encrypted_data = self.cipher_suite.encrypt(data.encode())
        return base64.b64encode(encrypted_data).decode()
    
    def decrypt_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•°æ®"""
        encrypted_bytes = base64.b64decode(encrypted_data.encode())
        decrypted_data = self.cipher_suite.decrypt(encrypted_bytes)
        return decrypted_data.decode()
    
    def hash_password(self, password: str, salt: str = None) -> tuple[str, str]:
        """å“ˆå¸Œå¯†ç """
        if salt is None:
            salt = secrets.token_hex(16)
        
        # ä½¿ç”¨PBKDF2
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt.encode(),
            iterations=100000,
        )
        
        key = base64.b64encode(kdf.derive(password.encode()))
        return key.decode(), salt
    
    def verify_password(self, password: str, hashed_password: str, salt: str) -> bool:
        """éªŒè¯å¯†ç """
        try:
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt.encode(),
                iterations=100000,
            )
            key = base64.b64encode(kdf.derive(password.encode()))
            return key.decode() == hashed_password
        except:
            return False
    
    def generate_signature(self, data: str, secret_key: str) -> str:
        """ç”Ÿæˆæ•°å­—ç­¾å"""
        signature = hmac.new(
            secret_key.encode(),
            data.encode(),
            hashlib.sha256
        ).hexdigest()
        return signature
    
    def verify_signature(self, data: str, signature: str, secret_key: str) -> bool:
        """éªŒè¯æ•°å­—ç­¾å"""
        expected_signature = self.generate_signature(data, secret_key)
        return hmac.compare_digest(signature, expected_signature)

# ç¤ºä¾‹ï¼šåŠ å¯†æœåŠ¡
def demonstrate_cryptography():
    """æ¼”ç¤ºåŠ å¯†æœåŠ¡"""
    crypto_service = CryptographyService()
    
    # åŠ å¯†æ•°æ®
    original_data = "æ•æ„Ÿé‡‘èæ•°æ®"
    encrypted = crypto_service.encrypt_data(original_data)
    decrypted = crypto_service.decrypt_data(encrypted)
    
    print("åŠ å¯†æœåŠ¡ç¤ºä¾‹:")
    print(f"åŸå§‹æ•°æ®: {original_data}")
    print(f"åŠ å¯†å: {encrypted}")
    print(f"è§£å¯†å: {decrypted}")
    print(f"æ•°æ®å®Œæ•´æ€§: {original_data == decrypted}")
    
    # å¯†ç å“ˆå¸Œ
    password = "my_password"
    hashed, salt = crypto_service.hash_password(password)
    is_valid = crypto_service.verify_password(password, hashed, salt)
    
    print(f"å¯†ç éªŒè¯: {is_valid}")
    
    # æ•°å­—ç­¾å
    data = "äº¤æ˜“æ•°æ®"
    secret_key = "secret_key"
    signature = crypto_service.generate_signature(data, secret_key)
    is_valid_signature = crypto_service.verify_signature(data, signature, secret_key)
    
    print(f"ç­¾åéªŒè¯: {is_valid_signature}")
    
    return crypto_service

# è¿è¡Œç¤ºä¾‹
crypto_service = demonstrate_cryptography()
```

### 3. é£é™©ç®¡ç†

#### 3.1 é£é™©è¯„ä¼°æ¨¡å‹

**æ•°å­¦å®šä¹‰**ï¼š
é£é™©è¯„åˆ† $R = \sum_{i=1}^{n} w_i \cdot f_i(x)$ï¼Œå…¶ä¸­ $w_i$ æ˜¯æƒé‡ï¼Œ$f_i$ æ˜¯é£é™©å› å­

**Pythonå®ç°**ï¼š

```python
from typing import Dict, List, Tuple
import numpy as np
from dataclasses import dataclass

@dataclass
class RiskFactor:
    """é£é™©å› å­"""
    name: str
    weight: float
    value: float
    description: str

@dataclass
class RiskAssessment:
    """é£é™©è¯„ä¼°"""
    risk_score: float
    risk_level: str
    factors: List[RiskFactor]
    recommendations: List[str]

class RiskManager:
    """é£é™©ç®¡ç†å™¨"""
    
    def __init__(self):
        self.risk_factors: Dict[str, RiskFactor] = {}
        self.risk_thresholds = {
            'low': 0.3,
            'medium': 0.7,
            'high': 1.0
        }
    
    def add_risk_factor(self, factor: RiskFactor):
        """æ·»åŠ é£é™©å› å­"""
        self.risk_factors[factor.name] = factor
    
    def calculate_risk_score(self, account_id: str, 
                           transaction_history: List[Transaction]) -> RiskAssessment:
        """è®¡ç®—é£é™©è¯„åˆ†"""
        factors = []
        total_score = 0.0
        
        # äº¤æ˜“é¢‘ç‡é£é™©
        frequency_risk = self._calculate_frequency_risk(transaction_history)
        factors.append(RiskFactor("äº¤æ˜“é¢‘ç‡", 0.2, frequency_risk, "äº¤æ˜“é¢‘ç‡å¼‚å¸¸"))
        total_score += 0.2 * frequency_risk
        
        # äº¤æ˜“é‡‘é¢é£é™©
        amount_risk = self._calculate_amount_risk(transaction_history)
        factors.append(RiskFactor("äº¤æ˜“é‡‘é¢", 0.3, amount_risk, "å¤§é¢äº¤æ˜“é£é™©"))
        total_score += 0.3 * amount_risk
        
        # åœ°ç†ä½ç½®é£é™©
        location_risk = self._calculate_location_risk(transaction_history)
        factors.append(RiskFactor("åœ°ç†ä½ç½®", 0.2, location_risk, "å¼‚åœ°äº¤æ˜“é£é™©"))
        total_score += 0.2 * location_risk
        
        # æ—¶é—´æ¨¡å¼é£é™©
        time_risk = self._calculate_time_risk(transaction_history)
        factors.append(RiskFactor("æ—¶é—´æ¨¡å¼", 0.3, time_risk, "å¼‚å¸¸æ—¶é—´äº¤æ˜“"))
        total_score += 0.3 * time_risk
        
        # ç¡®å®šé£é™©ç­‰çº§
        risk_level = self._determine_risk_level(total_score)
        
        # ç”Ÿæˆå»ºè®®
        recommendations = self._generate_recommendations(total_score, factors)
        
        return RiskAssessment(
            risk_score=total_score,
            risk_level=risk_level,
            factors=factors,
            recommendations=recommendations
        )
    
    def _calculate_frequency_risk(self, transactions: List[Transaction]) -> float:
        """è®¡ç®—äº¤æ˜“é¢‘ç‡é£é™©"""
        if not transactions:
            return 0.0
        
        # è®¡ç®—æœ€è¿‘24å°æ—¶çš„äº¤æ˜“æ¬¡æ•°
        recent_transactions = [
            t for t in transactions 
            if (datetime.now() - t.timestamp).total_seconds() < 86400
        ]
        
        # é£é™©è¯„åˆ†ï¼šäº¤æ˜“æ¬¡æ•°è¶Šå¤šï¼Œé£é™©è¶Šé«˜
        risk = min(len(recent_transactions) / 10.0, 1.0)
        return risk
    
    def _calculate_amount_risk(self, transactions: List[Transaction]) -> float:
        """è®¡ç®—äº¤æ˜“é‡‘é¢é£é™©"""
        if not transactions:
            return 0.0
        
        # è®¡ç®—å¹³å‡äº¤æ˜“é‡‘é¢
        total_amount = sum(t.amount for t in transactions)
        avg_amount = total_amount / len(transactions)
        
        # é£é™©è¯„åˆ†ï¼šé‡‘é¢è¶Šå¤§ï¼Œé£é™©è¶Šé«˜
        risk = min(float(avg_amount) / 10000.0, 1.0)
        return risk
    
    def _calculate_location_risk(self, transactions: List[Transaction]) -> float:
        """è®¡ç®—åœ°ç†ä½ç½®é£é™©"""
        # ç®€åŒ–å®ç°ï¼šå‡è®¾æ‰€æœ‰äº¤æ˜“éƒ½æœ‰ç›¸åŒçš„åœ°ç†ä½ç½®é£é™©
        return 0.1
    
    def _calculate_time_risk(self, transactions: List[Transaction]) -> float:
        """è®¡ç®—æ—¶é—´æ¨¡å¼é£é™©"""
        if not transactions:
            return 0.0
        
        # è®¡ç®—å¤œé—´äº¤æ˜“æ¯”ä¾‹
        night_transactions = [
            t for t in transactions 
            if t.timestamp.hour < 6 or t.timestamp.hour > 22
        ]
        
        risk = len(night_transactions) / len(transactions)
        return risk
    
    def _determine_risk_level(self, risk_score: float) -> str:
        """ç¡®å®šé£é™©ç­‰çº§"""
        if risk_score < self.risk_thresholds['low']:
            return 'low'
        elif risk_score < self.risk_thresholds['medium']:
            return 'medium'
        else:
            return 'high'
    
    def _generate_recommendations(self, risk_score: float, 
                                factors: List[RiskFactor]) -> List[str]:
        """ç”Ÿæˆé£é™©å»ºè®®"""
        recommendations = []
        
        if risk_score > 0.7:
            recommendations.append("å»ºè®®è¿›è¡Œé¢å¤–èº«ä»½éªŒè¯")
            recommendations.append("è€ƒè™‘é™åˆ¶äº¤æ˜“é‡‘é¢")
        
        if risk_score > 0.5:
            recommendations.append("ç›‘æ§è´¦æˆ·æ´»åŠ¨")
        
        # åŸºäºå…·ä½“é£é™©å› å­çš„å»ºè®®
        for factor in factors:
            if factor.value > 0.5:
                recommendations.append(f"å…³æ³¨{factor.description}")
        
        return recommendations

# ç¤ºä¾‹ï¼šé£é™©ç®¡ç†
def demonstrate_risk_management():
    """æ¼”ç¤ºé£é™©ç®¡ç†"""
    risk_manager = RiskManager()
    
    # åˆ›å»ºæ¨¡æ‹Ÿäº¤æ˜“å†å²
    transactions = []
    for i in range(10):
        transaction = Transaction(
            transaction_id=str(i),
            from_account="user1",
            to_account="merchant1",
            amount=Decimal('100'),
            currency="USD",
            transaction_type=TransactionType.TRANSFER,
            timestamp=datetime.now(),
            description=f"äº¤æ˜“{i}"
        )
        transactions.append(transaction)
    
    # è®¡ç®—é£é™©è¯„åˆ†
    assessment = risk_manager.calculate_risk_score("user1", transactions)
    
    print("é£é™©ç®¡ç†ç¤ºä¾‹:")
    print(f"é£é™©è¯„åˆ†: {assessment.risk_score:.2f}")
    print(f"é£é™©ç­‰çº§: {assessment.risk_level}")
    print("é£é™©å› å­:")
    for factor in assessment.factors:
        print(f"  {factor.name}: {factor.value:.2f} ({factor.description})")
    print("å»ºè®®:")
    for recommendation in assessment.recommendations:
        print(f"  - {recommendation}")
    
    return risk_manager

# è¿è¡Œç¤ºä¾‹
risk_manager = demonstrate_risk_management()
```

### 4. æŠ•èµ„ç»„åˆç®¡ç†

#### 4.1 æŠ•èµ„ç»„åˆä¼˜åŒ–

**æ•°å­¦å®šä¹‰**ï¼š
æŠ•èµ„ç»„åˆä¼˜åŒ–é—®é¢˜ï¼š$\min_w \frac{1}{2}w^T\Sigma w$ subject to $w^T\mu = r_p$, $w^T1 = 1$

**Pythonå®ç°**ï¼š

```python
import numpy as np
import pandas as pd
from typing import List, Dict, Tuple
from dataclasses import dataclass

@dataclass
class Asset:
    """èµ„äº§"""
    symbol: str
    name: str
    price: float
    returns: List[float]
    volatility: float
    expected_return: float

@dataclass
class Portfolio:
    """æŠ•èµ„ç»„åˆ"""
    assets: List[Asset]
    weights: List[float]
    expected_return: float
    volatility: float
    sharpe_ratio: float

class PortfolioOptimizer:
    """æŠ•èµ„ç»„åˆä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.assets: List[Asset] = []
        self.returns_matrix: np.ndarray = None
        self.covariance_matrix: np.ndarray = None
    
    def add_asset(self, asset: Asset):
        """æ·»åŠ èµ„äº§"""
        self.assets.append(asset)
        self._update_matrices()
    
    def _update_matrices(self):
        """æ›´æ–°æ”¶ç›ŠçŸ©é˜µå’Œåæ–¹å·®çŸ©é˜µ"""
        if len(self.assets) < 2:
            return
        
        # æ„å»ºæ”¶ç›ŠçŸ©é˜µ
        returns_data = [asset.returns for asset in self.assets]
        self.returns_matrix = np.array(returns_data)
        
        # è®¡ç®—åæ–¹å·®çŸ©é˜µ
        self.covariance_matrix = np.cov(self.returns_matrix)
    
    def calculate_portfolio_metrics(self, weights: List[float]) -> Tuple[float, float, float]:
        """è®¡ç®—æŠ•èµ„ç»„åˆæŒ‡æ ‡"""
        if len(weights) != len(self.assets):
            raise ValueError("æƒé‡æ•°é‡ä¸èµ„äº§æ•°é‡ä¸åŒ¹é…")
        
        weights = np.array(weights)
        
        # é¢„æœŸæ”¶ç›Š
        expected_returns = np.array([asset.expected_return for asset in self.assets])
        portfolio_return = np.dot(weights, expected_returns)
        
        # æ³¢åŠ¨ç‡
        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.covariance_matrix, weights)))
        
        # å¤æ™®æ¯”ç‡ï¼ˆå‡è®¾æ— é£é™©åˆ©ç‡ä¸º0ï¼‰
        sharpe_ratio = portfolio_return / portfolio_volatility if portfolio_volatility > 0 else 0
        
        return portfolio_return, portfolio_volatility, sharpe_ratio
    
    def optimize_portfolio(self, target_return: float = None, 
                          risk_free_rate: float = 0.0) -> Portfolio:
        """ä¼˜åŒ–æŠ•èµ„ç»„åˆ"""
        if len(self.assets) < 2:
            raise ValueError("éœ€è¦è‡³å°‘2ä¸ªèµ„äº§è¿›è¡Œä¼˜åŒ–")
        
        n_assets = len(self.assets)
        
        # ç®€åŒ–çš„ä¼˜åŒ–ï¼šç­‰æƒé‡æŠ•èµ„ç»„åˆ
        weights = [1.0 / n_assets] * n_assets
        
        # è®¡ç®—æŒ‡æ ‡
        expected_return, volatility, sharpe_ratio = self.calculate_portfolio_metrics(weights)
        
        return Portfolio(
            assets=self.assets,
            weights=weights,
            expected_return=expected_return,
            volatility=volatility,
            sharpe_ratio=sharpe_ratio
        )
    
    def monte_carlo_optimization(self, n_simulations: int = 10000) -> Portfolio:
        """è’™ç‰¹å¡æ´›ä¼˜åŒ–"""
        best_sharpe = -np.inf
        best_weights = None
        best_portfolio = None
        
        for _ in range(n_simulations):
            # ç”Ÿæˆéšæœºæƒé‡
            weights = np.random.random(len(self.assets))
            weights = weights / np.sum(weights)
            
            # è®¡ç®—æŒ‡æ ‡
            expected_return, volatility, sharpe_ratio = self.calculate_portfolio_metrics(weights)
            
            if sharpe_ratio > best_sharpe:
                best_sharpe = sharpe_ratio
                best_weights = weights
                best_portfolio = Portfolio(
                    assets=self.assets,
                    weights=weights.tolist(),
                    expected_return=expected_return,
                    volatility=volatility,
                    sharpe_ratio=sharpe_ratio
                )
        
        return best_portfolio

# ç¤ºä¾‹ï¼šæŠ•èµ„ç»„åˆç®¡ç†
def demonstrate_portfolio_management():
    """æ¼”ç¤ºæŠ•èµ„ç»„åˆç®¡ç†"""
    optimizer = PortfolioOptimizer()
    
    # åˆ›å»ºæ¨¡æ‹Ÿèµ„äº§
    np.random.seed(42)
    
    # è‚¡ç¥¨èµ„äº§
    stock_returns = np.random.normal(0.08, 0.15, 252)  # å¹´åŒ–8%æ”¶ç›Šï¼Œ15%æ³¢åŠ¨ç‡
    stock = Asset("STOCK", "è‚¡ç¥¨", 100.0, stock_returns.tolist(), 0.15, 0.08)
    
    # å€ºåˆ¸èµ„äº§
    bond_returns = np.random.normal(0.04, 0.05, 252)  # å¹´åŒ–4%æ”¶ç›Šï¼Œ5%æ³¢åŠ¨ç‡
    bond = Asset("BOND", "å€ºåˆ¸", 100.0, bond_returns.tolist(), 0.05, 0.04)
    
    # å•†å“èµ„äº§
    commodity_returns = np.random.normal(0.06, 0.20, 252)  # å¹´åŒ–6%æ”¶ç›Šï¼Œ20%æ³¢åŠ¨ç‡
    commodity = Asset("COMMODITY", "å•†å“", 100.0, commodity_returns.tolist(), 0.20, 0.06)
    
    # æ·»åŠ èµ„äº§
    optimizer.add_asset(stock)
    optimizer.add_asset(bond)
    optimizer.add_asset(commodity)
    
    # ç­‰æƒé‡æŠ•èµ„ç»„åˆ
    equal_weight_portfolio = optimizer.optimize_portfolio()
    
    # è’™ç‰¹å¡æ´›ä¼˜åŒ–
    optimized_portfolio = optimizer.monte_carlo_optimization(1000)
    
    print("æŠ•èµ„ç»„åˆç®¡ç†ç¤ºä¾‹:")
    print("ç­‰æƒé‡æŠ•èµ„ç»„åˆ:")
    print(f"  é¢„æœŸæ”¶ç›Š: {equal_weight_portfolio.expected_return:.4f}")
    print(f"  æ³¢åŠ¨ç‡: {equal_weight_portfolio.volatility:.4f}")
    print(f"  å¤æ™®æ¯”ç‡: {equal_weight_portfolio.sharpe_ratio:.4f}")
    
    print("\nä¼˜åŒ–æŠ•èµ„ç»„åˆ:")
    print(f"  é¢„æœŸæ”¶ç›Š: {optimized_portfolio.expected_return:.4f}")
    print(f"  æ³¢åŠ¨ç‡: {optimized_portfolio.volatility:.4f}")
    print(f"  å¤æ™®æ¯”ç‡: {optimized_portfolio.sharpe_ratio:.4f}")
    print(f"  æƒé‡: {optimized_portfolio.weights}")
    
    return optimizer

# è¿è¡Œç¤ºä¾‹
portfolio_optimizer = demonstrate_portfolio_management()
```

## ğŸ“Š é‡‘èç§‘æŠ€æ€»ç»“

### æ ¸å¿ƒç‰¹å¾

1. **å®‰å…¨æ€§**ï¼šåŠ å¯†ã€èº«ä»½éªŒè¯ã€æ¬ºè¯ˆæ£€æµ‹
2. **å®æ—¶æ€§**ï¼šå¿«é€Ÿäº¤æ˜“å¤„ç†ã€å®æ—¶é£é™©ç›‘æ§
3. **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒå¤§è§„æ¨¡äº¤æ˜“å’Œç”¨æˆ·
4. **åˆè§„æ€§**ï¼šç¬¦åˆé‡‘èç›‘ç®¡è¦æ±‚

### æ•°å­¦å½¢å¼åŒ–

é‡‘èç§‘æŠ€å¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦ç»“æ„è¡¨ç¤ºï¼š

$$FinTech = (FinancialSystem, PaymentSystem, RiskManagement, PortfolioManagement)$$

### Pythonå®ç°éªŒè¯

```python
class FinTechValidator:
    """é‡‘èç§‘æŠ€éªŒè¯å™¨"""
    
    def __init__(self):
        self.test_system = FinancialSystem()
    
    def validate_financial_system(self) -> bool:
        """éªŒè¯é‡‘èç³»ç»Ÿ"""
        # åˆ›å»ºæµ‹è¯•è´¦æˆ·
        account = self.test_system.create_account(
            AccountType.CHECKING, "test_user", Decimal('1000')
        )
        
        return (account.balance == Decimal('1000') and 
                account.status == AccountStatus.ACTIVE)
    
    def validate_payment_system(self) -> bool:
        """éªŒè¯æ”¯ä»˜ç³»ç»Ÿ"""
        processor = PaymentProcessor()
        processor.register_processor(PaymentMethod.CREDIT_CARD, lambda p: True)
        
        payment = processor.create_payment(
            Decimal('100'), "USD", "user1", "user2", PaymentMethod.CREDIT_CARD
        )
        
        return payment.status == PaymentStatus.PENDING
    
    def validate_cryptography(self) -> bool:
        """éªŒè¯åŠ å¯†æœåŠ¡"""
        crypto = CryptographyService()
        original = "test_data"
        encrypted = crypto.encrypt_data(original)
        decrypted = crypto.decrypt_data(encrypted)
        
        return original == decrypted
    
    def validate_risk_management(self) -> bool:
        """éªŒè¯é£é™©ç®¡ç†"""
        risk_manager = RiskManager()
        assessment = risk_manager.calculate_risk_score("test", [])
        
        return assessment.risk_score >= 0 and assessment.risk_score <= 1
    
    def run_all_tests(self) -> Dict[str, bool]:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        tests = {
            'financial_system': self.validate_financial_system(),
            'payment_system': self.validate_payment_system(),
            'cryptography': self.validate_cryptography(),
            'risk_management': self.validate_risk_management()
        }
        
        print("=== é‡‘èç§‘æŠ€éªŒè¯ç»“æœ ===")
        for test_name, result in tests.items():
            print(f"{test_name}: {'PASS' if result else 'FAIL'}")
        
        return tests

# ä½¿ç”¨ç¤ºä¾‹
validator = FinTechValidator()
test_results = validator.run_all_tests()
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [03.01 è®¾è®¡æ¨¡å¼ç§‘å­¦](../03-å…·ä½“ç§‘å­¦/03.01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md)
- [04.02 äººå·¥æ™ºèƒ½](../04-è¡Œä¸šé¢†åŸŸ/04.02-äººå·¥æ™ºèƒ½.md)
- [05.01 å¾®æœåŠ¡æ¶æ„](../05-æ¶æ„é¢†åŸŸ/05.01-å¾®æœåŠ¡æ¶æ„.md)

---

*é‡‘èç§‘æŠ€ä¸ºç°ä»£é‡‘èæœåŠ¡æä¾›äº†æŠ€æœ¯åŸºç¡€ï¼Œé€šè¿‡å½¢å¼åŒ–å®šä¹‰å’ŒPythonå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå®‰å…¨ã€é«˜æ•ˆã€å¯æ‰©å±•çš„é‡‘èç³»ç»Ÿã€‚*
