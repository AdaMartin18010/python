# 04-01-03 åç«¯æŠ€æœ¯æ ˆ

## ğŸ“‹ ç›®å½•

- [04-01-03 åç«¯æŠ€æœ¯æ ˆ](#04-01-03-åç«¯æŠ€æœ¯æ ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ”¬ æ¦‚å¿µå®šä¹‰](#-æ¦‚å¿µå®šä¹‰)
    - [å®šä¹‰ 3.1 (åç«¯æŠ€æœ¯æ ˆ)](#å®šä¹‰-31-åç«¯æŠ€æœ¯æ ˆ)
    - [å®šä¹‰ 3.2 (å¾®æœåŠ¡æ¶æ„)](#å®šä¹‰-32-å¾®æœåŠ¡æ¶æ„)
    - [å®šä¹‰ 3.3 (APIè®¾è®¡)](#å®šä¹‰-33-apiè®¾è®¡)
  - [ğŸ“ æ•°å­¦å½¢å¼åŒ–](#-æ•°å­¦å½¢å¼åŒ–)
    - [å®šç† 3.1 (CAPå®šç†)](#å®šç†-31-capå®šç†)
    - [å®šç† 3.2 (è´Ÿè½½å‡è¡¡ç®—æ³•)](#å®šç†-32-è´Ÿè½½å‡è¡¡ç®—æ³•)
  - [ğŸ Pythonå®ç°](#-pythonå®ç°)
    - [1. Webæ¡†æ¶å®ç°](#1-webæ¡†æ¶å®ç°)
    - [2. æ•°æ®åº“æ“ä½œ](#2-æ•°æ®åº“æ“ä½œ)
    - [3. APIè®¾è®¡](#3-apiè®¾è®¡)
    - [4. å¾®æœåŠ¡æ¶æ„](#4-å¾®æœåŠ¡æ¶æ„)
    - [5. æ¶ˆæ¯é˜Ÿåˆ—](#5-æ¶ˆæ¯é˜Ÿåˆ—)
  - [ğŸ“Š æŠ€æœ¯æ ˆå¯¹æ¯”](#-æŠ€æœ¯æ ˆå¯¹æ¯”)
  - [ğŸ”„ å·¥ä½œæµç¨‹](#-å·¥ä½œæµç¨‹)
    - [åç«¯å¼€å‘æµç¨‹](#åç«¯å¼€å‘æµç¨‹)
  - [ğŸ“ˆ åº”ç”¨æ¡ˆä¾‹](#-åº”ç”¨æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šç”¨æˆ·ç®¡ç†ç³»ç»Ÿ](#æ¡ˆä¾‹1ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ)
    - [æ¡ˆä¾‹2ï¼šå¾®æœåŠ¡æ¶æ„](#æ¡ˆä¾‹2å¾®æœåŠ¡æ¶æ„)
  - [ğŸ”— ç›¸å…³é“¾æ¥](#-ç›¸å…³é“¾æ¥)

## ğŸ¯ æ¦‚è¿°

åç«¯æŠ€æœ¯æ ˆæ˜¯Webåº”ç”¨çš„æœåŠ¡å™¨ç«¯æŠ€æœ¯é›†åˆï¼Œè´Ÿè´£ä¸šåŠ¡é€»è¾‘å¤„ç†ã€æ•°æ®å­˜å‚¨ã€APIæä¾›ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–å®šä¹‰ã€æ•°å­¦åŸºç¡€ã€Pythonå®ç°ç­‰å¤šä¸ªç»´åº¦å…¨é¢é˜è¿°åç«¯æŠ€æœ¯æ ˆã€‚

## ğŸ”¬ æ¦‚å¿µå®šä¹‰

### å®šä¹‰ 3.1 (åç«¯æŠ€æœ¯æ ˆ)

åç«¯æŠ€æœ¯æ ˆæ˜¯æœåŠ¡å™¨ç«¯æŠ€æœ¯çš„é›†åˆï¼Œå½¢å¼åŒ–å®šä¹‰ä¸ºï¼š

$$BTS = (Server, Database, API, Cache, Queue)$$

å…¶ä¸­ï¼š

- $Server$ æ˜¯æœåŠ¡å™¨ç³»ç»Ÿ
- $Database$ æ˜¯æ•°æ®åº“ç³»ç»Ÿ
- $API$ æ˜¯æ¥å£ç³»ç»Ÿ
- $Cache$ æ˜¯ç¼“å­˜ç³»ç»Ÿ
- $Queue$ æ˜¯æ¶ˆæ¯é˜Ÿåˆ—

### å®šä¹‰ 3.2 (å¾®æœåŠ¡æ¶æ„)

å¾®æœåŠ¡æ¶æ„æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„è®¾è®¡æ¨¡å¼ï¼š

$$MSA = (Services, Communication, Discovery, LoadBalancer)$$

å…¶ä¸­ï¼š

- $Services$ æ˜¯æœåŠ¡é›†åˆ
- $Communication$ æ˜¯é€šä¿¡æœºåˆ¶
- $Discovery$ æ˜¯æœåŠ¡å‘ç°
- $LoadBalancer$ æ˜¯è´Ÿè½½å‡è¡¡

### å®šä¹‰ 3.3 (APIè®¾è®¡)

APIè®¾è®¡éµå¾ªRESTfulåŸåˆ™ï¼š

$$API = (Resources, Methods, Status, Headers)$$

å…¶ä¸­ï¼š

- $Resources$ æ˜¯èµ„æºé›†åˆ
- $Methods$ æ˜¯HTTPæ–¹æ³•
- $Status$ æ˜¯çŠ¶æ€ç 
- $Headers$ æ˜¯è¯·æ±‚å¤´

## ğŸ“ æ•°å­¦å½¢å¼åŒ–

### å®šç† 3.1 (CAPå®šç†)

åˆ†å¸ƒå¼ç³»ç»Ÿæœ€å¤šåªèƒ½åŒæ—¶æ»¡è¶³ä¸‰ä¸ªç‰¹æ€§ä¸­çš„ä¸¤ä¸ªï¼š

$$CAP = \{Consistency, Availability, Partition\}$$

å¯¹äºä»»æ„åˆ†å¸ƒå¼ç³»ç»Ÿ $S$ï¼Œæœ€å¤šåªèƒ½æ»¡è¶³ $|S \cap CAP| = 2$ã€‚

### å®šç† 3.2 (è´Ÿè½½å‡è¡¡ç®—æ³•)

è´Ÿè½½å‡è¡¡ç®—æ³•çš„å¤æ‚åº¦åˆ†æï¼š

$$O(LB_{round\_robin}) = O(1)$$
$$O(LB_{least\_connections}) = O(n)$$

å…¶ä¸­ $n$ æ˜¯æœåŠ¡å™¨æ•°é‡ã€‚

## ğŸ Pythonå®ç°

### 1. Webæ¡†æ¶å®ç°

```python
from flask import Flask, request, jsonify
from fastapi import FastAPI, HTTPException
import uvicorn
from typing import Dict, Any, List
import asyncio
import aiohttp

class FlaskApp:
    """Flaskåº”ç”¨"""
    
    def __init__(self, name: str = "FlaskApp"):
        self.app = Flask(name)
        self.routes = {}
        self.middleware = []
    
    def route(self, path: str, methods: List[str] = None):
        """è·¯ç”±è£…é¥°å™¨"""
        if methods is None:
            methods = ['GET']
        
        def decorator(func):
            for method in methods:
                route_key = f"{method}:{path}"
                self.routes[route_key] = func
                
                # æ³¨å†ŒFlaskè·¯ç”±
                if method == 'GET':
                    self.app.route(path, methods=[method])(func)
                else:
                    self.app.route(path, methods=[method])(func)
            return func
        return decorator
    
    def add_middleware(self, middleware_func):
        """æ·»åŠ ä¸­é—´ä»¶"""
        self.middleware.append(middleware_func)
    
    def run(self, host: str = 'localhost', port: int = 5000):
        """è¿è¡Œåº”ç”¨"""
        self.app.run(host=host, port=port)

class FastAPIApp:
    """FastAPIåº”ç”¨"""
    
    def __init__(self, title: str = "FastAPI App"):
        self.app = FastAPI(title=title)
        self.routes = {}
    
    def route(self, path: str, methods: List[str] = None):
        """è·¯ç”±è£…é¥°å™¨"""
        if methods is None:
            methods = ['GET']
        
        def decorator(func):
            for method in methods:
                route_key = f"{method}:{path}"
                self.routes[route_key] = func
                
                # æ³¨å†ŒFastAPIè·¯ç”±
                if method == 'GET':
                    self.app.get(path)(func)
                elif method == 'POST':
                    self.app.post(path)(func)
                elif method == 'PUT':
                    self.app.put(path)(func)
                elif method == 'DELETE':
                    self.app.delete(path)(func)
            return func
        return decorator
    
    def run(self, host: str = 'localhost', port: int = 8000):
        """è¿è¡Œåº”ç”¨"""
        uvicorn.run(self.app, host=host, port=port)
```

### 2. æ•°æ®åº“æ“ä½œ

```python
import sqlite3
import psycopg2
import redis
from typing import Dict, Any, List, Optional
import json

class DatabaseManager:
    """æ•°æ®åº“ç®¡ç†å™¨"""
    
    def __init__(self, db_type: str = 'sqlite', **kwargs):
        self.db_type = db_type
        self.connection = None
        self.config = kwargs
    
    def connect(self):
        """è¿æ¥æ•°æ®åº“"""
        if self.db_type == 'sqlite':
            self.connection = sqlite3.connect(self.config.get('database', ':memory:'))
        elif self.db_type == 'postgresql':
            self.connection = psycopg2.connect(**self.config)
        else:
            raise ValueError(f"Unsupported database type: {self.db_type}")
    
    def execute(self, query: str, params: tuple = None):
        """æ‰§è¡ŒSQLæŸ¥è¯¢"""
        if not self.connection:
            self.connect()
        
        cursor = self.connection.cursor()
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        self.connection.commit()
        return cursor
    
    def fetch_all(self, query: str, params: tuple = None) -> List[tuple]:
        """è·å–æ‰€æœ‰ç»“æœ"""
        cursor = self.execute(query, params)
        return cursor.fetchall()
    
    def fetch_one(self, query: str, params: tuple = None) -> Optional[tuple]:
        """è·å–å•ä¸ªç»“æœ"""
        cursor = self.execute(query, params)
        return cursor.fetchone()
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.connection:
            self.connection.close()

class RedisCache:
    """Redisç¼“å­˜"""
    
    def __init__(self, host: str = 'localhost', port: int = 6379, db: int = 0):
        self.redis_client = redis.Redis(host=host, port=port, db=db)
    
    def set(self, key: str, value: Any, expire: int = None):
        """è®¾ç½®ç¼“å­˜"""
        if isinstance(value, (dict, list)):
            value = json.dumps(value)
        self.redis_client.set(key, value, ex=expire)
    
    def get(self, key: str) -> Any:
        """è·å–ç¼“å­˜"""
        value = self.redis_client.get(key)
        if value:
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                return value.decode('utf-8')
        return None
    
    def delete(self, key: str):
        """åˆ é™¤ç¼“å­˜"""
        self.redis_client.delete(key)
    
    def exists(self, key: str) -> bool:
        """æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨"""
        return bool(self.redis_client.exists(key))

class ORM:
    """ç®€å•ORM"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db = db_manager
        self.models = {}
    
    def model(self, table_name: str):
        """æ¨¡å‹è£…é¥°å™¨"""
        def decorator(cls):
            self.models[table_name] = cls
            cls.table_name = table_name
            return cls
        return decorator
    
    def create_table(self, model_class):
        """åˆ›å»ºè¡¨"""
        fields = []
        for field_name, field_type in model_class.__annotations__.items():
            if field_type == str:
                fields.append(f"{field_name} TEXT")
            elif field_type == int:
                fields.append(f"{field_name} INTEGER")
            elif field_type == float:
                fields.append(f"{field_name} REAL")
        
        fields_str = ", ".join(fields)
        query = f"CREATE TABLE IF NOT EXISTS {model_class.table_name} ({fields_str})"
        self.db.execute(query)
    
    def insert(self, model_instance):
        """æ’å…¥æ•°æ®"""
        fields = list(model_instance.__annotations__.keys())
        values = [getattr(model_instance, field) for field in fields]
        placeholders = ", ".join(["?" for _ in fields])
        fields_str = ", ".join(fields)
        
        query = f"INSERT INTO {model_instance.table_name} ({fields_str}) VALUES ({placeholders})"
        self.db.execute(query, tuple(values))
    
    def select(self, model_class, conditions: Dict[str, Any] = None) -> List[Any]:
        """æŸ¥è¯¢æ•°æ®"""
        query = f"SELECT * FROM {model_class.table_name}"
        params = None
        
        if conditions:
            where_clause = " AND ".join([f"{k} = ?" for k in conditions.keys()])
            query += f" WHERE {where_clause}"
            params = tuple(conditions.values())
        
        results = self.db.fetch_all(query, params)
        return [model_class(*row) for row in results]
```

### 3. APIè®¾è®¡

```python
class RESTfulAPI:
    """RESTful APIè®¾è®¡"""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.endpoints = {}
        self.authentication = None
    
    def endpoint(self, path: str, methods: List[str] = None):
        """ç«¯ç‚¹è£…é¥°å™¨"""
        if methods is None:
            methods = ['GET']
        
        def decorator(func):
            for method in methods:
                endpoint_key = f"{method}:{path}"
                self.endpoints[endpoint_key] = func
            return func
        return decorator
    
    def set_authentication(self, auth_func):
        """è®¾ç½®è®¤è¯"""
        self.authentication = auth_func
    
    def handle_request(self, method: str, path: str, data: Dict[str, Any] = None):
        """å¤„ç†è¯·æ±‚"""
        endpoint_key = f"{method}:{path}"
        
        if endpoint_key not in self.endpoints:
            return {"error": "Endpoint not found"}, 404
        
        # è®¤è¯æ£€æŸ¥
        if self.authentication:
            auth_result = self.authentication(data)
            if not auth_result:
                return {"error": "Authentication failed"}, 401
        
        # æ‰§è¡Œç«¯ç‚¹å‡½æ•°
        try:
            result = self.endpoints[endpoint_key](data or {})
            return result, 200
        except Exception as e:
            return {"error": str(e)}, 500

class GraphQLAPI:
    """GraphQL APIè®¾è®¡"""
    
    def __init__(self):
        self.schema = {}
        self.resolvers = {}
    
    def type(self, type_name: str):
        """ç±»å‹è£…é¥°å™¨"""
        def decorator(cls):
            self.schema[type_name] = cls
            return cls
        return decorator
    
    def resolver(self, type_name: str, field_name: str):
        """è§£æå™¨è£…é¥°å™¨"""
        def decorator(func):
            if type_name not in self.resolvers:
                self.resolvers[type_name] = {}
            self.resolvers[type_name][field_name] = func
            return func
        return decorator
    
    def execute_query(self, query: str, variables: Dict[str, Any] = None):
        """æ‰§è¡ŒGraphQLæŸ¥è¯¢"""
        # ç®€åŒ–çš„GraphQLæŸ¥è¯¢æ‰§è¡Œ
        # å®é™…å®ç°éœ€è¦å®Œæ•´çš„GraphQLè§£æå™¨
        return {"data": {"message": "GraphQL query executed"}}
```

### 4. å¾®æœåŠ¡æ¶æ„

```python
class Microservice:
    """å¾®æœåŠ¡"""
    
    def __init__(self, name: str, port: int):
        self.name = name
        self.port = port
        self.services = {}
        self.health_check = None
    
    def register_service(self, service_name: str, service_url: str):
        """æ³¨å†ŒæœåŠ¡"""
        self.services[service_name] = service_url
    
    def set_health_check(self, health_func):
        """è®¾ç½®å¥åº·æ£€æŸ¥"""
        self.health_check = health_func
    
    def check_health(self) -> bool:
        """å¥åº·æ£€æŸ¥"""
        if self.health_check:
            return self.health_check()
        return True

class ServiceDiscovery:
    """æœåŠ¡å‘ç°"""
    
    def __init__(self):
        self.services = {}
    
    def register(self, service_name: str, service_url: str, metadata: Dict[str, Any] = None):
        """æ³¨å†ŒæœåŠ¡"""
        self.services[service_name] = {
            'url': service_url,
            'metadata': metadata or {},
            'status': 'healthy'
        }
    
    def discover(self, service_name: str) -> Optional[str]:
        """å‘ç°æœåŠ¡"""
        if service_name in self.services:
            return self.services[service_name]['url']
        return None
    
    def list_services(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æœåŠ¡"""
        return list(self.services.keys())

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self, algorithm: str = 'round_robin'):
        self.algorithm = algorithm
        self.servers = []
        self.current_index = 0
    
    def add_server(self, server_url: str, weight: int = 1):
        """æ·»åŠ æœåŠ¡å™¨"""
        self.servers.append({'url': server_url, 'weight': weight})
    
    def get_next_server(self) -> Optional[str]:
        """è·å–ä¸‹ä¸€ä¸ªæœåŠ¡å™¨"""
        if not self.servers:
            return None
        
        if self.algorithm == 'round_robin':
            server = self.servers[self.current_index]
            self.current_index = (self.current_index + 1) % len(self.servers)
            return server['url']
        elif self.algorithm == 'random':
            import random
            return random.choice(self.servers)['url']
        else:
            return self.servers[0]['url']
```

### 5. æ¶ˆæ¯é˜Ÿåˆ—

```python
import queue
import threading
import time
from typing import Callable, Any

class MessageQueue:
    """æ¶ˆæ¯é˜Ÿåˆ—"""
    
    def __init__(self, max_size: int = 1000):
        self.queue = queue.Queue(maxsize=max_size)
        self.consumers = []
        self.running = False
    
    def publish(self, message: Any):
        """å‘å¸ƒæ¶ˆæ¯"""
        try:
            self.queue.put(message, timeout=1)
            return True
        except queue.Full:
            return False
    
    def subscribe(self, consumer_func: Callable):
        """è®¢é˜…æ¶ˆæ¯"""
        self.consumers.append(consumer_func)
    
    def start_consuming(self):
        """å¼€å§‹æ¶ˆè´¹"""
        self.running = True
        for consumer in self.consumers:
            thread = threading.Thread(target=self._consumer_worker, args=(consumer,))
            thread.daemon = True
            thread.start()
    
    def stop_consuming(self):
        """åœæ­¢æ¶ˆè´¹"""
        self.running = False
    
    def _consumer_worker(self, consumer_func: Callable):
        """æ¶ˆè´¹è€…å·¥ä½œçº¿ç¨‹"""
        while self.running:
            try:
                message = self.queue.get(timeout=1)
                consumer_func(message)
                self.queue.task_done()
            except queue.Empty:
                continue

class EventBus:
    """äº‹ä»¶æ€»çº¿"""
    
    def __init__(self):
        self.subscribers = {}
    
    def subscribe(self, event_type: str, handler: Callable):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)
    
    def publish(self, event_type: str, data: Any = None):
        """å‘å¸ƒäº‹ä»¶"""
        if event_type in self.subscribers:
            for handler in self.subscribers[event_type]:
                try:
                    handler(data)
                except Exception as e:
                    print(f"Event handler error: {e}")
    
    def unsubscribe(self, event_type: str, handler: Callable):
        """å–æ¶ˆè®¢é˜…"""
        if event_type in self.subscribers:
            self.subscribers[event_type].remove(handler)
```

## ğŸ“Š æŠ€æœ¯æ ˆå¯¹æ¯”

| æŠ€æœ¯ | ç±»å‹ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|------|----------|
| Flask | è½»é‡çº§æ¡†æ¶ | ç®€å•ã€çµæ´» | åŠŸèƒ½æœ‰é™ | å°å‹åº”ç”¨ |
| FastAPI | ç°ä»£æ¡†æ¶ | é«˜æ€§èƒ½ã€è‡ªåŠ¨æ–‡æ¡£ | ç”Ÿæ€è¾ƒå° | APIæœåŠ¡ |
| Django | å…¨åŠŸèƒ½æ¡†æ¶ | åŠŸèƒ½å®Œæ•´ã€ç”Ÿæ€ä¸°å¯Œ | å¤æ‚ã€é‡é‡çº§ | ä¼ä¸šçº§åº”ç”¨ |
| PostgreSQL | å…³ç³»æ•°æ®åº“ | åŠŸèƒ½å¼ºå¤§ã€ACID | å¤æ‚ | å¤æ‚æ•°æ® |
| Redis | å†…å­˜æ•°æ®åº“ | é«˜æ€§èƒ½ã€ç®€å• | å®¹é‡é™åˆ¶ | ç¼“å­˜ã€ä¼šè¯ |
| RabbitMQ | æ¶ˆæ¯é˜Ÿåˆ— | åŠŸèƒ½å®Œæ•´ã€å¯é  | å¤æ‚ | å¼‚æ­¥å¤„ç† |

## ğŸ”„ å·¥ä½œæµç¨‹

### åç«¯å¼€å‘æµç¨‹

```python
def backend_development_workflow():
    """åç«¯å¼€å‘æµç¨‹"""
    
    # 1. åˆ›å»ºæ•°æ®åº“
    db_manager = DatabaseManager('sqlite', database='app.db')
    orm = ORM(db_manager)
    
    # 2. å®šä¹‰æ•°æ®æ¨¡å‹
    @orm.model('users')
    class User:
        def __init__(self, id: int, name: str, email: str):
            self.id = id
            self.name = name
            self.email = email
    
    # 3. åˆ›å»ºè¡¨
    orm.create_table(User)
    
    # 4. åˆ›å»ºç¼“å­˜
    cache = RedisCache()
    
    # 5. åˆ›å»ºAPI
    api = RESTfulAPI()
    
    @api.endpoint('/users', methods=['GET'])
    def get_users(data):
        # æ£€æŸ¥ç¼“å­˜
        cached_users = cache.get('users')
        if cached_users:
            return cached_users
        
        # ä»æ•°æ®åº“è·å–
        users = orm.select(User)
        user_list = [{'id': u.id, 'name': u.name, 'email': u.email} for u in users]
        
        # è®¾ç½®ç¼“å­˜
        cache.set('users', user_list, expire=300)
        return user_list
    
    @api.endpoint('/users', methods=['POST'])
    def create_user(data):
        user = User(
            id=data.get('id'),
            name=data.get('name'),
            email=data.get('email')
        )
        orm.insert(user)
        
        # æ¸…é™¤ç¼“å­˜
        cache.delete('users')
        return {'message': 'User created successfully'}
    
    # 6. åˆ›å»ºå¾®æœåŠ¡
    user_service = Microservice('user-service', 8001)
    user_service.register_service('database', 'sqlite://app.db')
    
    # 7. åˆ›å»ºæœåŠ¡å‘ç°
    discovery = ServiceDiscovery()
    discovery.register('user-service', 'http://localhost:8001')
    
    # 8. åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
    lb = LoadBalancer('round_robin')
    lb.add_server('http://localhost:8001')
    lb.add_server('http://localhost:8002')
    
    # 9. åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—
    mq = MessageQueue()
    
    def user_created_handler(message):
        print(f"User created: {message}")
    
    mq.subscribe(user_created_handler)
    
    print("=== åç«¯å¼€å‘æµç¨‹å®Œæˆ ===")
    print(f"æ•°æ®åº“: {db_manager.db_type}")
    print(f"APIç«¯ç‚¹: {list(api.endpoints.keys())}")
    print(f"å¾®æœåŠ¡: {user_service.name}")
    print(f"æœåŠ¡å‘ç°: {discovery.list_services()}")
    
    return api, db_manager, cache, user_service, discovery, lb, mq
```

## ğŸ“ˆ åº”ç”¨æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šç”¨æˆ·ç®¡ç†ç³»ç»Ÿ

```python
def user_management_system():
    """ç”¨æˆ·ç®¡ç†ç³»ç»Ÿç¤ºä¾‹"""
    
    # åˆ›å»ºæ•°æ®åº“
    db = DatabaseManager('sqlite', database='users.db')
    orm = ORM(db)
    
    # ç”¨æˆ·æ¨¡å‹
    @orm.model('users')
    class User:
        def __init__(self, id: int, username: str, email: str, password: str):
            self.id = id
            self.username = username
            self.email = email
            self.password = password
    
    # åˆ›å»ºè¡¨
    orm.create_table(User)
    
    # åˆ›å»ºAPI
    api = RESTfulAPI()
    
    @api.endpoint('/users', methods=['GET'])
    def get_users(data):
        users = orm.select(User)
        return [{'id': u.id, 'username': u.username, 'email': u.email} for u in users]
    
    @api.endpoint('/users', methods=['POST'])
    def create_user(data):
        user = User(
            id=data.get('id'),
            username=data.get('username'),
            email=data.get('email'),
            password=data.get('password')
        )
        orm.insert(user)
        return {'message': 'User created'}
    
    @api.endpoint('/users/{user_id}', methods=['GET'])
    def get_user(data):
        user_id = data.get('user_id')
        users = orm.select(User, {'id': user_id})
        if users:
            user = users[0]
            return {'id': user.id, 'username': user.username, 'email': user.email}
        return {'error': 'User not found'}, 404
    
    return api, orm
```

### æ¡ˆä¾‹2ï¼šå¾®æœåŠ¡æ¶æ„

```python
def microservices_architecture():
    """å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹"""
    
    # ç”¨æˆ·æœåŠ¡
    user_service = Microservice('user-service', 8001)
    user_service.register_service('database', 'postgresql://user:pass@localhost/users')
    
    # è®¢å•æœåŠ¡
    order_service = Microservice('order-service', 8002)
    order_service.register_service('database', 'postgresql://user:pass@localhost/orders')
    
    # æ”¯ä»˜æœåŠ¡
    payment_service = Microservice('payment-service', 8003)
    payment_service.register_service('database', 'postgresql://user:pass@localhost/payments')
    
    # æœåŠ¡å‘ç°
    discovery = ServiceDiscovery()
    discovery.register('user-service', 'http://localhost:8001')
    discovery.register('order-service', 'http://localhost:8002')
    discovery.register('payment-service', 'http://localhost:8003')
    
    # è´Ÿè½½å‡è¡¡å™¨
    lb = LoadBalancer('round_robin')
    lb.add_server('http://localhost:8001')
    lb.add_server('http://localhost:8002')
    lb.add_server('http://localhost:8003')
    
    # æ¶ˆæ¯é˜Ÿåˆ—
    mq = MessageQueue()
    
    def order_created_handler(message):
        print(f"Order created: {message}")
        # è§¦å‘æ”¯ä»˜æµç¨‹
        payment_service_url = discovery.discover('payment-service')
        print(f"Triggering payment at: {payment_service_url}")
    
    mq.subscribe(order_created_handler)
    
    return {
        'services': [user_service, order_service, payment_service],
        'discovery': discovery,
        'load_balancer': lb,
        'message_queue': mq
    }
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [04-01-01-Webæ¶æ„åŸºç¡€](./04-01-01-Webæ¶æ„åŸºç¡€.md)
- [04-01-02-å‰ç«¯æŠ€æœ¯æ ˆ](./04-01-02-å‰ç«¯æŠ€æœ¯æ ˆ.md)
- [05-æ¶æ„é¢†åŸŸ/05-02-å¾®æœåŠ¡æ¶æ„/05-02-01-å¾®æœåŠ¡åŸºç¡€](../05-æ¶æ„é¢†åŸŸ/05-02-å¾®æœåŠ¡æ¶æ„/05-02-01-å¾®æœåŠ¡åŸºç¡€.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0  
**æœ€åæ›´æ–°**ï¼š2024å¹´  
**ç»´æŠ¤è€…**ï¼šAIåŠ©æ‰‹
