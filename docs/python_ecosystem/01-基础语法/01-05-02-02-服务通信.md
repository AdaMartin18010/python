# å¾®æœåŠ¡é€šä¿¡

## ğŸ“‹ æ¦‚è¿°

å¾®æœåŠ¡é€šä¿¡æ˜¯å¾®æœåŠ¡æ¶æ„ä¸­çš„æ ¸å¿ƒç»„ä»¶ï¼Œå®šä¹‰äº†æœåŠ¡é—´å¦‚ä½•äº¤æ¢ä¿¡æ¯å’Œåè°ƒå·¥ä½œã€‚é€šä¿¡æ¨¡å¼çš„é€‰æ‹©ç›´æ¥å½±å“ç³»ç»Ÿçš„æ€§èƒ½ã€å¯é æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

## ğŸ¯ é€šä¿¡æ¨¡å¼åˆ†ç±»

### åŒæ­¥é€šä¿¡

**å®šä¹‰**ï¼šè°ƒç”¨æ–¹ç­‰å¾…è¢«è°ƒç”¨æ–¹è¿”å›ç»“æœåæ‰ç»§ç»­æ‰§è¡Œã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$SyncComm(s_i, s_j) = \{req, resp\} \text{ where } s_i \xrightarrow{req} s_j \xrightarrow{resp} s_i$$

**ç‰¹å¾**ï¼š

- å¼ºä¸€è‡´æ€§
- å®æ—¶å“åº”
- ç´§è€¦åˆ
- æ•…éšœä¼ æ’­é£é™©

### å¼‚æ­¥é€šä¿¡

**å®šä¹‰**ï¼šè°ƒç”¨æ–¹å‘é€æ¶ˆæ¯åä¸ç­‰å¾…ç«‹å³å“åº”ï¼Œè¢«è°ƒç”¨æ–¹å¼‚æ­¥å¤„ç†ã€‚

**æ•°å­¦è¡¨ç¤º**ï¼š
$$AsyncComm(s_i, s_j) = \{msg\} \text{ where } s_i \xrightarrow{msg} s_j \text{ and } s_i \nrightarrow s_j$$

**ç‰¹å¾**ï¼š

- æ¾è€¦åˆ
- é«˜ååé‡
- æ•…éšœéš”ç¦»
- æœ€ç»ˆä¸€è‡´æ€§

## ğŸ”§ Pythonå®ç°

### åŒæ­¥é€šä¿¡å®ç°

```python
import aiohttp
import asyncio
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
from datetime import datetime
import json
import logging

# HTTPå®¢æˆ·ç«¯é…ç½®
@dataclass
class HttpClientConfig:
    base_url: str
    timeout: int = 30
    max_retries: int = 3
    retry_delay: float = 1.0
    headers: Optional[Dict[str, str]] = None

# HTTPå®¢æˆ·ç«¯
class HttpClient:
    """HTTPåŒæ­¥é€šä¿¡å®¢æˆ·ç«¯"""
    
    def __init__(self, config: HttpClientConfig):
        self.config = config
        self.session: Optional[aiohttp.ClientSession] = None
        self.logger = logging.getLogger("http_client")
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(
            base_url=self.config.base_url,
            headers=self.config.headers or {}
        )
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
            
    async def get(self, path: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """GETè¯·æ±‚"""
        return await self._request("GET", path, params=params)
        
    async def post(self, path: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """POSTè¯·æ±‚"""
        return await self._request("POST", path, json=data)
        
    async def put(self, path: str, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """PUTè¯·æ±‚"""
        return await self._request("PUT", path, json=data)
        
    async def delete(self, path: str) -> Dict[str, Any]:
        """DELETEè¯·æ±‚"""
        return await self._request("DELETE", path)
        
    async def _request(
        self, 
        method: str, 
        path: str, 
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """æ‰§è¡ŒHTTPè¯·æ±‚"""
        if not self.session:
            raise Exception("Client session not initialized")
            
        for attempt in range(self.config.max_retries):
            try:
                timeout = aiohttp.ClientTimeout(total=self.config.timeout)
                
                async with self.session.request(
                    method, path, params=params, json=json, timeout=timeout
                ) as response:
                    if response.status >= 400:
                        raise Exception(f"HTTP {response.status}: {await response.text()}")
                    return await response.json()
                    
            except Exception as e:
                self.logger.warning(f"Request failed (attempt {attempt + 1}): {e}")
                if attempt == self.config.max_retries - 1:
                    raise e
                await asyncio.sleep(self.config.retry_delay * (2 ** attempt))

# gRPCå®¢æˆ·ç«¯
import grpc
from typing import Any, Iterator

class GrpcClient:
    """gRPCåŒæ­¥é€šä¿¡å®¢æˆ·ç«¯"""
    
    def __init__(self, server_address: str):
        self.server_address = server_address
        self.channel: Optional[grpc.aio.Channel] = None
        
    async def __aenter__(self):
        self.channel = grpc.aio.insecure_channel(self.server_address)
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.channel:
            await self.channel.close()
            
    async def unary_call(self, stub_method, request) -> Any:
        """ä¸€å…ƒè°ƒç”¨"""
        if not self.channel:
            raise Exception("gRPC channel not initialized")
        return await stub_method(request)
        
    async def streaming_call(self, stub_method, request) -> Iterator[Any]:
        """æµå¼è°ƒç”¨"""
        if not self.channel:
            raise Exception("gRPC channel not initialized")
        async for response in stub_method(request):
            yield response
```

### å¼‚æ­¥é€šä¿¡å®ç°

```python
import asyncio
from typing import Dict, Any, Callable, Optional, List
from dataclasses import dataclass
from datetime import datetime
import json
import logging
from enum import Enum

# æ¶ˆæ¯ç±»å‹
class MessageType(Enum):
    COMMAND = "command"
    EVENT = "event"
    QUERY = "query"
    RESPONSE = "response"

# æ¶ˆæ¯ç»“æ„
@dataclass
class Message:
    id: str
    type: MessageType
    source: str
    destination: str
    payload: Dict[str, Any]
    timestamp: datetime
    correlation_id: Optional[str] = None
    reply_to: Optional[str] = None

# æ¶ˆæ¯æ€»çº¿
class MessageBus:
    """æ¶ˆæ¯æ€»çº¿ - å¼‚æ­¥é€šä¿¡æ ¸å¿ƒ"""
    
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.message_queue = asyncio.Queue()
        self.running = False
        self.logger = logging.getLogger("message_bus")
        
    async def start(self) -> None:
        """å¯åŠ¨æ¶ˆæ¯æ€»çº¿"""
        self.running = True
        asyncio.create_task(self._process_messages())
        self.logger.info("Message bus started")
        
    async def stop(self) -> None:
        """åœæ­¢æ¶ˆæ¯æ€»çº¿"""
        self.running = False
        self.logger.info("Message bus stopped")
        
    async def publish(self, message: Message) -> None:
        """å‘å¸ƒæ¶ˆæ¯"""
        await self.message_queue.put(message)
        self.logger.debug(f"Message published: {message.id}")
        
    def subscribe(self, message_type: str, handler: Callable) -> None:
        """è®¢é˜…æ¶ˆæ¯"""
        if message_type not in self.subscribers:
            self.subscribers[message_type] = []
        self.subscribers[message_type].append(handler)
        self.logger.info(f"Handler subscribed to {message_type}")
        
    async def _process_messages(self) -> None:
        """å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—"""
        while self.running:
            try:
                message = await asyncio.wait_for(self.message_queue.get(), timeout=1.0)
                await self._handle_message(message)
                self.message_queue.task_done()
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                self.logger.error(f"Error processing message: {e}")
                
    async def _handle_message(self, message: Message) -> None:
        """å¤„ç†å•ä¸ªæ¶ˆæ¯"""
        message_type = message.type.value
        
        if message_type in self.subscribers:
            for handler in self.subscribers[message_type]:
                try:
                    await handler(message)
                except Exception as e:
                    self.logger.error(f"Error in message handler: {e}")

# äº‹ä»¶å‘å¸ƒè€…
class EventPublisher:
    """äº‹ä»¶å‘å¸ƒè€…"""
    
    def __init__(self, message_bus: MessageBus, service_name: str):
        self.message_bus = message_bus
        self.service_name = service_name
        self.logger = logging.getLogger(f"event_publisher.{service_name}")
        
    async def publish_event(
        self, 
        event_type: str, 
        event_data: Dict[str, Any],
        correlation_id: Optional[str] = None
    ) -> None:
        """å‘å¸ƒäº‹ä»¶"""
        message = Message(
            id=f"event_{datetime.now().timestamp()}",
            type=MessageType.EVENT,
            source=self.service_name,
            destination="*",  # å¹¿æ’­ç»™æ‰€æœ‰è®¢é˜…è€…
            payload=event_data,
            timestamp=datetime.now(),
            correlation_id=correlation_id
        )
        
        await self.message_bus.publish(message)
        self.logger.info(f"Event published: {event_type}")

# äº‹ä»¶è®¢é˜…è€…
class EventSubscriber:
    """äº‹ä»¶è®¢é˜…è€…"""
    
    def __init__(self, message_bus: MessageBus, service_name: str):
        self.message_bus = message_bus
        self.service_name = service_name
        self.handlers: Dict[str, Callable] = {}
        self.logger = logging.getLogger(f"event_subscriber.{service_name}")
        
    def subscribe(self, event_type: str, handler: Callable) -> None:
        """è®¢é˜…äº‹ä»¶"""
        self.handlers[event_type] = handler
        self.message_bus.subscribe(MessageType.EVENT.value, self._handle_event)
        self.logger.info(f"Subscribed to event: {event_type}")
        
    async def _handle_event(self, message: Message) -> None:
        """å¤„ç†äº‹ä»¶æ¶ˆæ¯"""
        if message.source == self.service_name:
            return  # å¿½ç•¥è‡ªå·±å‘å¸ƒçš„äº‹ä»¶
            
        event_type = message.payload.get("event_type")
        if event_type in self.handlers:
            try:
                await self.handlers[event_type](message.payload)
                self.logger.debug(f"Event handled: {event_type}")
            except Exception as e:
                self.logger.error(f"Error handling event {event_type}: {e}")

# å‘½ä»¤å‘é€è€…
class CommandSender:
    """å‘½ä»¤å‘é€è€…"""
    
    def __init__(self, message_bus: MessageBus, service_name: str):
        self.message_bus = message_bus
        self.service_name = service_name
        self.pending_commands: Dict[str, asyncio.Future] = {}
        self.logger = logging.getLogger(f"command_sender.{service_name}")
        
    async def send_command(
        self, 
        destination: str, 
        command_type: str, 
        command_data: Dict[str, Any],
        timeout: float = 30.0
    ) -> Dict[str, Any]:
        """å‘é€å‘½ä»¤å¹¶ç­‰å¾…å“åº”"""
        command_id = f"cmd_{datetime.now().timestamp()}"
        future = asyncio.Future()
        self.pending_commands[command_id] = future
        
        message = Message(
            id=command_id,
            type=MessageType.COMMAND,
            source=self.service_name,
            destination=destination,
            payload={
                "command_type": command_type,
                "data": command_data
            },
            timestamp=datetime.now(),
            reply_to=self.service_name
        )
        
        await self.message_bus.publish(message)
        
        try:
            response = await asyncio.wait_for(future, timeout=timeout)
            return response
        except asyncio.TimeoutError:
            del self.pending_commands[command_id]
            raise Exception(f"Command timeout: {command_type}")
        finally:
            if command_id in self.pending_commands:
                del self.pending_commands[command_id]
                
    def handle_response(self, message: Message) -> None:
        """å¤„ç†å‘½ä»¤å“åº”"""
        if message.correlation_id in self.pending_commands:
            future = self.pending_commands[message.correlation_id]
            if not future.done():
                future.set_result(message.payload)

# å‘½ä»¤å¤„ç†å™¨
class CommandHandler:
    """å‘½ä»¤å¤„ç†å™¨"""
    
    def __init__(self, message_bus: MessageBus, service_name: str):
        self.message_bus = message_bus
        self.service_name = service_name
        self.handlers: Dict[str, Callable] = {}
        self.logger = logging.getLogger(f"command_handler.{service_name}")
        
    def register_handler(self, command_type: str, handler: Callable) -> None:
        """æ³¨å†Œå‘½ä»¤å¤„ç†å™¨"""
        self.handlers[command_type] = handler
        self.message_bus.subscribe(MessageType.COMMAND.value, self._handle_command)
        self.logger.info(f"Command handler registered: {command_type}")
        
    async def _handle_command(self, message: Message) -> None:
        """å¤„ç†å‘½ä»¤æ¶ˆæ¯"""
        if message.destination != self.service_name and message.destination != "*":
            return  # ä¸æ˜¯å‘ç»™æˆ‘ä»¬çš„å‘½ä»¤
            
        command_type = message.payload.get("command_type")
        if command_type in self.handlers:
            try:
                result = await self.handlers[command_type](message.payload.get("data", {}))
                
                # å‘é€å“åº”
                if message.reply_to:
                    response = Message(
                        id=f"resp_{message.id}",
                        type=MessageType.RESPONSE,
                        source=self.service_name,
                        destination=message.reply_to,
                        payload={"result": result},
                        timestamp=datetime.now(),
                        correlation_id=message.id
                    )
                    await self.message_bus.publish(response)
                    
                self.logger.debug(f"Command handled: {command_type}")
            except Exception as e:
                self.logger.error(f"Error handling command {command_type}: {e}")
```

### æ¶ˆæ¯é˜Ÿåˆ—å®ç°

```python
import asyncio
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
from datetime import datetime
import json
import logging
from enum import Enum

# æ¶ˆæ¯çŠ¶æ€
class MessageStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    RETRY = "retry"

# æ¶ˆæ¯é˜Ÿåˆ—
class MessageQueue:
    """æ¶ˆæ¯é˜Ÿåˆ—å®ç°"""
    
    def __init__(self, name: str, max_size: int = 1000):
        self.name = name
        self.max_size = max_size
        self.queue = asyncio.Queue(maxsize=max_size)
        self.dead_letter_queue = asyncio.Queue()
        self.consumers: List[Callable] = []
        self.running = False
        self.logger = logging.getLogger(f"message_queue.{name}")
        
    async def start(self) -> None:
        """å¯åŠ¨æ¶ˆæ¯é˜Ÿåˆ—"""
        self.running = True
        asyncio.create_task(self._process_queue())
        self.logger.info(f"Message queue {self.name} started")
        
    async def stop(self) -> None:
        """åœæ­¢æ¶ˆæ¯é˜Ÿåˆ—"""
        self.running = False
        self.logger.info(f"Message queue {self.name} stopped")
        
    async def enqueue(self, message: Message) -> bool:
        """å…¥é˜Ÿæ¶ˆæ¯"""
        try:
            await self.queue.put(message)
            self.logger.debug(f"Message enqueued: {message.id}")
            return True
        except asyncio.QueueFull:
            self.logger.warning(f"Queue {self.name} is full")
            return False
            
    async def dequeue(self) -> Optional[Message]:
        """å‡ºé˜Ÿæ¶ˆæ¯"""
        try:
            return await asyncio.wait_for(self.queue.get(), timeout=1.0)
        except asyncio.TimeoutError:
            return None
            
    def add_consumer(self, consumer: Callable) -> None:
        """æ·»åŠ æ¶ˆè´¹è€…"""
        self.consumers.append(consumer)
        self.logger.info(f"Consumer added to queue {self.name}")
        
    async def _process_queue(self) -> None:
        """å¤„ç†é˜Ÿåˆ—æ¶ˆæ¯"""
        while self.running:
            message = await self.dequeue()
            if message:
                await self._process_message(message)
                
    async def _process_message(self, message: Message) -> None:
        """å¤„ç†å•ä¸ªæ¶ˆæ¯"""
        for consumer in self.consumers:
            try:
                await consumer(message)
                self.queue.task_done()
                break
            except Exception as e:
                self.logger.error(f"Error processing message {message.id}: {e}")
                # å°†å¤±è´¥çš„æ¶ˆæ¯ç§»åˆ°æ­»ä¿¡é˜Ÿåˆ—
                await self.dead_letter_queue.put(message)
                break

# æ¶ˆæ¯ä»£ç†
class MessageBroker:
    """æ¶ˆæ¯ä»£ç† - ç®¡ç†å¤šä¸ªæ¶ˆæ¯é˜Ÿåˆ—"""
    
    def __init__(self):
        self.queues: Dict[str, MessageQueue] = {}
        self.running = False
        self.logger = logging.getLogger("message_broker")
        
    async def start(self) -> None:
        """å¯åŠ¨æ¶ˆæ¯ä»£ç†"""
        self.running = True
        for queue in self.queues.values():
            await queue.start()
        self.logger.info("Message broker started")
        
    async def stop(self) -> None:
        """åœæ­¢æ¶ˆæ¯ä»£ç†"""
        self.running = False
        for queue in self.queues.values():
            await queue.stop()
        self.logger.info("Message broker stopped")
        
    def create_queue(self, name: str, max_size: int = 1000) -> MessageQueue:
        """åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—"""
        if name in self.queues:
            raise ValueError(f"Queue {name} already exists")
            
        queue = MessageQueue(name, max_size)
        self.queues[name] = queue
        self.logger.info(f"Queue created: {name}")
        return queue
        
    def get_queue(self, name: str) -> Optional[MessageQueue]:
        """è·å–æ¶ˆæ¯é˜Ÿåˆ—"""
        return self.queues.get(name)
        
    async def publish(self, queue_name: str, message: Message) -> bool:
        """å‘å¸ƒæ¶ˆæ¯åˆ°æŒ‡å®šé˜Ÿåˆ—"""
        queue = self.get_queue(queue_name)
        if not queue:
            self.logger.error(f"Queue {queue_name} not found")
            return False
        return await queue.enqueue(message)
        
    def subscribe(self, queue_name: str, consumer: Callable) -> None:
        """è®¢é˜…é˜Ÿåˆ—"""
        queue = self.get_queue(queue_name)
        if queue:
            queue.add_consumer(consumer)
        else:
            self.logger.error(f"Queue {queue_name} not found")
```

### APIç½‘å…³å®ç°

```python
import aiohttp
from aiohttp import web
from typing import Dict, Any, Optional, List, Callable
from dataclasses import dataclass
import json
import logging
from datetime import datetime

# è·¯ç”±é…ç½®
@dataclass
class RouteConfig:
    path: str
    method: str
    service_name: str
    service_path: str
    timeout: int = 30
    auth_required: bool = False
    rate_limit: Optional[int] = None

# APIç½‘å…³
class ApiGateway:
    """APIç½‘å…³ - ç»Ÿä¸€å…¥å£ç‚¹"""
    
    def __init__(self, service_discovery: 'ServiceDiscovery'):
        self.service_discovery = service_discovery
        self.routes: List[RouteConfig] = []
        self.middleware: List[Callable] = []
        self.logger = logging.getLogger("api_gateway")
        
    def add_route(self, route: RouteConfig) -> None:
        """æ·»åŠ è·¯ç”±"""
        self.routes.append(route)
        self.logger.info(f"Route added: {route.method} {route.path} -> {route.service_name}")
        
    def add_middleware(self, middleware: Callable) -> None:
        """æ·»åŠ ä¸­é—´ä»¶"""
        self.middleware.append(middleware)
        self.logger.info("Middleware added")
        
    async def handle_request(self, request: web.Request) -> web.Response:
        """å¤„ç†è¯·æ±‚"""
        # åº”ç”¨ä¸­é—´ä»¶
        for middleware in self.middleware:
            request = await middleware(request)
            
        # æŸ¥æ‰¾è·¯ç”±
        route = self._find_route(request.method, request.path)
        if not route:
            return web.Response(status=404, text="Route not found")
            
        # è·å–æœåŠ¡ç«¯ç‚¹
        service_endpoint = self.service_discovery.get_service_endpoint(route.service_name)
        if not service_endpoint:
            return web.Response(status=503, text="Service unavailable")
            
        # è½¬å‘è¯·æ±‚
        return await self._forward_request(request, route, service_endpoint)
        
    def _find_route(self, method: str, path: str) -> Optional[RouteConfig]:
        """æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±"""
        for route in self.routes:
            if route.method == method and route.path == path:
                return route
        return None
        
    async def _forward_request(
        self, 
        request: web.Request, 
        route: RouteConfig, 
        service_endpoint: str
    ) -> web.Response:
        """è½¬å‘è¯·æ±‚åˆ°åç«¯æœåŠ¡"""
        try:
            # æ„å»ºç›®æ ‡URL
            target_url = f"{service_endpoint}{route.service_path}"
            
            # è¯»å–è¯·æ±‚ä½“
            body = await request.read() if request.body_exists else None
            
            # æ„å»ºè¯·æ±‚å¤´
            headers = dict(request.headers)
            headers.pop('Host', None)  # ç§»é™¤Hostå¤´
            
            # å‘é€è¯·æ±‚
            async with aiohttp.ClientSession() as session:
                async with session.request(
                    request.method,
                    target_url,
                    headers=headers,
                    data=body,
                    timeout=aiohttp.ClientTimeout(total=route.timeout)
                ) as response:
                    # è¯»å–å“åº”
                    response_body = await response.read()
                    
                    # æ„å»ºå“åº”
                    return web.Response(
                        body=response_body,
                        status=response.status,
                        headers=dict(response.headers)
                    )
                    
        except Exception as e:
            self.logger.error(f"Error forwarding request: {e}")
            return web.Response(status=500, text="Internal server error")

# è®¤è¯ä¸­é—´ä»¶
class AuthMiddleware:
    """è®¤è¯ä¸­é—´ä»¶"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        
    async def __call__(self, request: web.Request) -> web.Request:
        """å¤„ç†è®¤è¯"""
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            raise web.HTTPUnauthorized(text="Missing authorization header")
            
        try:
            # éªŒè¯JWTä»¤ç‰Œ
            token = auth_header.replace('Bearer ', '')
            import jwt
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            request['user'] = payload
        except Exception as e:
            raise web.HTTPUnauthorized(text="Invalid token")
            
        return request

# é™æµä¸­é—´ä»¶
class RateLimitMiddleware:
    """é™æµä¸­é—´ä»¶"""
    
    def __init__(self, requests_per_minute: int = 60):
        self.requests_per_minute = requests_per_minute
        self.request_counts: Dict[str, List[float]] = {}
        
    async def __call__(self, request: web.Request) -> web.Request:
        """å¤„ç†é™æµ"""
        client_ip = request.remote
        
        # æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
        current_time = datetime.now().timestamp()
        if client_ip in self.request_counts:
            self.request_counts[client_ip] = [
                t for t in self.request_counts[client_ip]
                if current_time - t < 60
            ]
        else:
            self.request_counts[client_ip] = []
            
        # æ£€æŸ¥é™æµ
        if len(self.request_counts[client_ip]) >= self.requests_per_minute:
            raise web.HTTPTooManyRequests(text="Rate limit exceeded")
            
        # è®°å½•è¯·æ±‚
        self.request_counts[client_ip].append(current_time)
        
        return request

# æ—¥å¿—ä¸­é—´ä»¶
class LoggingMiddleware:
    """æ—¥å¿—ä¸­é—´ä»¶"""
    
    def __init__(self):
        self.logger = logging.getLogger("api_gateway")
        
    async def __call__(self, request: web.Request) -> web.Request:
        """è®°å½•è¯·æ±‚æ—¥å¿—"""
        start_time = datetime.now()
        request['start_time'] = start_time
        
        self.logger.info(f"Request: {request.method} {request.path}")
        
        return request
```

## ğŸ“Š é€šä¿¡æ¨¡å¼æ¯”è¾ƒ

### æ€§èƒ½å¯¹æ¯”

| æ¨¡å¼ | å»¶è¿Ÿ | ååé‡ | å¯é æ€§ | å¤æ‚åº¦ |
|------|------|--------|--------|--------|
| åŒæ­¥HTTP | é«˜ | ä¸­ç­‰ | ä¸­ç­‰ | ä½ |
| åŒæ­¥gRPC | ä½ | é«˜ | é«˜ | ä¸­ç­‰ |
| å¼‚æ­¥æ¶ˆæ¯ | ä½ | é«˜ | é«˜ | é«˜ |
| äº‹ä»¶é©±åŠ¨ | ä½ | å¾ˆé«˜ | å¾ˆé«˜ | å¾ˆé«˜ |

### ä½¿ç”¨åœºæ™¯

**åŒæ­¥é€šä¿¡é€‚ç”¨åœºæ™¯**ï¼š

- éœ€è¦ç«‹å³å“åº”çš„æ“ä½œ
- ç®€å•çš„CRUDæ“ä½œ
- å®æ—¶æ€§è¦æ±‚é«˜çš„åœºæ™¯

**å¼‚æ­¥é€šä¿¡é€‚ç”¨åœºæ™¯**ï¼š

- é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
- æ‰¹é‡å¤„ç†æ“ä½œ
- äº‹ä»¶é©±åŠ¨çš„ä¸šåŠ¡æµç¨‹
- é«˜å¹¶å‘åœºæ™¯

## ğŸ” æ•…éšœå¤„ç†

### é‡è¯•æœºåˆ¶

```python
class RetryPolicy:
    """é‡è¯•ç­–ç•¥"""
    
    def __init__(self, max_attempts: int = 3, base_delay: float = 1.0):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        
    async def execute(self, operation: Callable, *args, **kwargs) -> Any:
        """æ‰§è¡Œå¸¦é‡è¯•çš„æ“ä½œ"""
        last_exception = None
        
        for attempt in range(self.max_attempts):
            try:
                return await operation(*args, **kwargs)
            except Exception as e:
                last_exception = e
                if attempt < self.max_attempts - 1:
                    delay = self.base_delay * (2 ** attempt)  # æŒ‡æ•°é€€é¿
                    await asyncio.sleep(delay)
                    
        raise last_exception
```

### ç†”æ–­å™¨æ¨¡å¼

```python
class CircuitBreaker:
    """ç†”æ–­å™¨"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        
    async def call(self, operation: Callable, *args, **kwargs) -> Any:
        """æ‰§è¡Œå¸¦ç†”æ–­å™¨çš„æ“ä½œ"""
        if self.state == "OPEN":
            if (self.last_failure_time and 
                datetime.now().timestamp() - self.last_failure_time > self.timeout):
                self.state = "HALF_OPEN"
            else:
                raise Exception("Circuit breaker is OPEN")
                
        try:
            result = await operation(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
            
    def _on_success(self):
        """æˆåŠŸå¤„ç†"""
        self.failure_count = 0
        if self.state == "HALF_OPEN":
            self.state = "CLOSED"
            
    def _on_failure(self):
        """å¤±è´¥å¤„ç†"""
        self.failure_count += 1
        self.last_failure_time = datetime.now().timestamp()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"
```

## ğŸ›¡ï¸ å®‰å…¨è€ƒè™‘

### æ¶ˆæ¯åŠ å¯†

```python
class MessageEncryption:
    """æ¶ˆæ¯åŠ å¯†"""
    
    def __init__(self, encryption_key: str):
        self.encryption_key = encryption_key
        
    def encrypt_message(self, message: Message) -> Message:
        """åŠ å¯†æ¶ˆæ¯"""
        from cryptography.fernet import Fernet
        f = Fernet(self.encryption_key.encode())
        
        encrypted_payload = f.encrypt(json.dumps(message.payload).encode())
        message.payload = {"encrypted_data": encrypted_payload.decode()}
        return message
        
    def decrypt_message(self, message: Message) -> Message:
        """è§£å¯†æ¶ˆæ¯"""
        from cryptography.fernet import Fernet
        f = Fernet(self.encryption_key.encode())
        
        if "encrypted_data" in message.payload:
            encrypted_data = message.payload["encrypted_data"].encode()
            decrypted_data = f.decrypt(encrypted_data)
            message.payload = json.loads(decrypted_data.decode())
        return message
```

## ğŸ“‹ æœ€ä½³å®è·µ

### 1. é€šä¿¡è®¾è®¡åŸåˆ™

- **å¹‚ç­‰æ€§**ï¼šç¡®ä¿é‡å¤è¯·æ±‚ä¸ä¼šäº§ç”Ÿå‰¯ä½œç”¨
- **å¯è§‚æµ‹æ€§**ï¼šæ·»åŠ é€‚å½“çš„æ—¥å¿—å’Œç›‘æ§
- **é”™è¯¯å¤„ç†**ï¼šå®ç°å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶
- **ç‰ˆæœ¬ç®¡ç†**ï¼šæ”¯æŒAPIç‰ˆæœ¬ç®¡ç†

### 2. æ€§èƒ½ä¼˜åŒ–

- **è¿æ¥æ± **ï¼šå¤ç”¨HTTPè¿æ¥
- **å‹ç¼©**ï¼šä½¿ç”¨gzipå‹ç¼©å‡å°‘ä¼ è¾“é‡
- **ç¼“å­˜**ï¼šç¼“å­˜é¢‘ç¹è®¿é—®çš„æ•°æ®
- **è´Ÿè½½å‡è¡¡**ï¼šä½¿ç”¨è´Ÿè½½å‡è¡¡å™¨åˆ†å‘è¯·æ±‚

### 3. ç›‘æ§æŒ‡æ ‡

```python
class CommunicationMetrics:
    """é€šä¿¡æŒ‡æ ‡ç›‘æ§"""
    
    def __init__(self):
        self.request_count = 0
        self.error_count = 0
        self.response_times: List[float] = []
        
    def record_request(self, response_time: float, success: bool) -> None:
        """è®°å½•è¯·æ±‚æŒ‡æ ‡"""
        self.request_count += 1
        if not success:
            self.error_count += 1
        self.response_times.append(response_time)
        
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡"""
        avg_response_time = (
            sum(self.response_times) / len(self.response_times)
            if self.response_times else 0
        )
        
        error_rate = (
            self.error_count / self.request_count
            if self.request_count > 0 else 0
        )
        
        return {
            "request_count": self.request_count,
            "error_count": self.error_count,
            "error_rate": error_rate,
            "avg_response_time": avg_response_time,
            "min_response_time": min(self.response_times) if self.response_times else 0,
            "max_response_time": max(self.response_times) if self.response_times else 0
        }
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [05-æ¶æ„é¢†åŸŸ/05-02-å¾®æœåŠ¡æ¶æ„/05-02-01-å¾®æœåŠ¡åŸºç¡€.md](./05-02-01-å¾®æœåŠ¡åŸºç¡€.md) - å¾®æœåŠ¡æ¶æ„åŸºç¡€
- [02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md](../../02-ç†è®ºåŸºç¡€/02-01-ç®—æ³•ç†è®º/02-01-01-ç®—æ³•åŸºç¡€.md) - ç®—æ³•ç†è®ºåŸºç¡€
- [03-å…·ä½“ç§‘å­¦/03-01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md](../../03-å…·ä½“ç§‘å­¦/03-01-è®¾è®¡æ¨¡å¼ç§‘å­¦.md) - è®¾è®¡æ¨¡å¼ç§‘å­¦

---

*æœ¬æ–‡æ¡£æä¾›äº†å¾®æœåŠ¡é€šä¿¡çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬åŒæ­¥å’Œå¼‚æ­¥é€šä¿¡æ¨¡å¼ã€æ¶ˆæ¯é˜Ÿåˆ—ã€APIç½‘å…³ç­‰æ ¸å¿ƒç»„ä»¶ã€‚*
