# 01-01-03 ä»£æ•°åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

ä»£æ•°å­¦æ˜¯ç ”ç©¶ä»£æ•°ç»“æ„çš„æ•°å­¦åˆ†æ”¯ï¼Œåœ¨è®¡ç®—æœºç§‘å­¦ä¸­æœ‰ç€é‡è¦åº”ç”¨ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦å®šä¹‰ä»£æ•°çš„åŸºæœ¬æ¦‚å¿µï¼Œå»ºç«‹ç¾¤è®ºã€ç¯è®ºã€åŸŸè®ºçš„ç†è®ºæ¡†æ¶ï¼Œå¹¶æä¾›å®Œæ•´çš„Pythonå®ç°ã€‚

## 1. å½¢å¼åŒ–å®šä¹‰

### 1.1 åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.1** (äºŒå…ƒè¿ç®—)
é›†åˆ $S$ ä¸Šçš„äºŒå…ƒè¿ç®—æ˜¯ä¸€ä¸ªå‡½æ•° $f: S \times S \rightarrow S$ã€‚

**å®šä¹‰ 1.2** (ä»£æ•°ç»“æ„)
ä»£æ•°ç»“æ„æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ $(S, \mathcal{O})$ï¼Œå…¶ä¸­ $S$ æ˜¯é›†åˆï¼Œ$\mathcal{O}$ æ˜¯è¿ç®—é›†åˆã€‚

**å®šä¹‰ 1.3** (åŒæ€)
ä»£æ•°ç»“æ„ $(A, \mathcal{O}_A)$ å’Œ $(B, \mathcal{O}_B)$ ä¹‹é—´çš„åŒæ€æ˜¯ä¸€ä¸ªå‡½æ•° $f: A \rightarrow B$ï¼Œä¿æŒè¿ç®—ç»“æ„ã€‚

### 1.2 ç¾¤è®º

**å®šä¹‰ 1.4** (ç¾¤)
ç¾¤æ˜¯ä¸€ä¸ªä»£æ•°ç»“æ„ $(G, \cdot)$ï¼Œæ»¡è¶³ï¼š

1. **å°é—­æ€§**: $\forall a, b \in G: a \cdot b \in G$
2. **ç»“åˆå¾‹**: $\forall a, b, c \in G: (a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. **å•ä½å…ƒ**: $\exists e \in G: \forall a \in G: e \cdot a = a \cdot e = a$
4. **é€†å…ƒ**: $\forall a \in G: \exists a^{-1} \in G: a \cdot a^{-1} = a^{-1} \cdot a = e$

**å®šä¹‰ 1.5** (å­ç¾¤)
ç¾¤ $(G, \cdot)$ çš„å­ç¾¤æ˜¯ $(H, \cdot)$ï¼Œå…¶ä¸­ $H \subseteq G$ ä¸” $(H, \cdot)$ æ˜¯ç¾¤ã€‚

**å®šä¹‰ 1.6** (å¾ªç¯ç¾¤)
ç¾¤ $G$ æ˜¯å¾ªç¯ç¾¤ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ $g \in G$ ä½¿å¾— $G = \langle g \rangle = \{g^n \mid n \in \mathbb{Z}\}$ã€‚

### 1.3 ç¯è®º

**å®šä¹‰ 1.7** (ç¯)
ç¯æ˜¯ä¸€ä¸ªä»£æ•°ç»“æ„ $(R, +, \cdot)$ï¼Œæ»¡è¶³ï¼š

1. $(R, +)$ æ˜¯é˜¿è´å°”ç¾¤
2. $(R, \cdot)$ æ˜¯åŠç¾¤
3. **åˆ†é…å¾‹**: $\forall a, b, c \in R: a \cdot (b + c) = a \cdot b + a \cdot c$ ä¸” $(a + b) \cdot c = a \cdot c + b \cdot c$

**å®šä¹‰ 1.8** (åŸŸ)
åŸŸæ˜¯ä¸€ä¸ªç¯ $(F, +, \cdot)$ï¼Œå…¶ä¸­ $(F \setminus \{0\}, \cdot)$ æ˜¯é˜¿è´å°”ç¾¤ã€‚

**å®šä¹‰ 1.9** (ç†æƒ³)
ç¯ $R$ çš„ç†æƒ³æ˜¯å­ç¯ $I$ï¼Œæ»¡è¶³ $\forall r \in R, i \in I: r \cdot i, i \cdot r \in I$ã€‚

### 1.4 çº¿æ€§ä»£æ•°

**å®šä¹‰ 1.10** (å‘é‡ç©ºé—´)
åŸŸ $F$ ä¸Šçš„å‘é‡ç©ºé—´æ˜¯ä¸€ä¸ªé˜¿è´å°”ç¾¤ $(V, +)$ å’Œæ ‡é‡ä¹˜æ³• $F \times V \rightarrow V$ï¼Œæ»¡è¶³ï¼š

1. $\forall a \in F, v, w \in V: a(v + w) = av + aw$
2. $\forall a, b \in F, v \in V: (a + b)v = av + bv$
3. $\forall a, b \in F, v \in V: (ab)v = a(bv)$
4. $\forall v \in V: 1v = v$

**å®šä¹‰ 1.11** (çº¿æ€§å˜æ¢)
å‘é‡ç©ºé—´ $V$ åˆ° $W$ çš„çº¿æ€§å˜æ¢æ˜¯å‡½æ•° $T: V \rightarrow W$ï¼Œæ»¡è¶³ï¼š

1. $\forall v, w \in V: T(v + w) = T(v) + T(w)$
2. $\forall a \in F, v \in V: T(av) = aT(v)$

## 2. é‡è¦å®šç†

### 2.1 ç¾¤è®ºå®šç†

**å®šç† 2.1** (æ‹‰æ ¼æœ—æ—¥å®šç†)
æœ‰é™ç¾¤ $G$ çš„å­ç¾¤ $H$ çš„é˜¶æ•´é™¤ $G$ çš„é˜¶ã€‚

**è¯æ˜**:
è€ƒè™‘é™ªé›†åˆ†è§£ $G = \bigcup_{g \in G} gH$ï¼Œæ¯ä¸ªé™ªé›†çš„å¤§å°ç­‰äº $|H|$ã€‚

**å®šç† 2.2** (è¥¿ç½—å®šç†)
è®¾ $G$ æ˜¯æœ‰é™ç¾¤ï¼Œ$p$ æ˜¯ç´ æ•°ï¼Œ$p^k$ æ•´é™¤ $|G|$ï¼Œåˆ™ $G$ æœ‰é˜¶ä¸º $p^k$ çš„å­ç¾¤ã€‚

**è¯æ˜**:
ä½¿ç”¨å½’çº³æ³•å’Œç¾¤ä½œç”¨ç†è®ºã€‚

### 2.2 ç¯è®ºå®šç†

**å®šç† 2.3** (ä¸­å›½å‰©ä½™å®šç† - ç¯è®ºç‰ˆæœ¬)
è®¾ $R$ æ˜¯ç¯ï¼Œ$I_1, I_2, \ldots, I_n$ æ˜¯ä¸¤ä¸¤äº’ç´ çš„ç†æƒ³ï¼Œåˆ™ï¼š
$$R / (I_1 \cap I_2 \cap \cdots \cap I_n) \cong R/I_1 \times R/I_2 \times \cdots \times R/I_n$$

**è¯æ˜**:
æ„é€ åŒæ€æ˜ å°„å¹¶è¯æ˜å…¶æ˜¯åŒå°„ã€‚

### 2.3 çº¿æ€§ä»£æ•°å®šç†

**å®šç† 2.4** (ç§©-é›¶åŒ–åº¦å®šç†)
è®¾ $T: V \rightarrow W$ æ˜¯çº¿æ€§å˜æ¢ï¼Œåˆ™ï¼š
$$\dim V = \dim \ker T + \dim \text{im } T$$

**è¯æ˜**:
ä½¿ç”¨åŸºçš„æ‰©å±•å’Œçº¿æ€§æ— å…³æ€§ã€‚

## 3. Pythonå®ç°

### 3.1 ç¾¤è®ºå®ç°

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Set, List, Dict, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import math
import random
from collections import defaultdict, deque

T = TypeVar('T')

class GroupElement:
    """ç¾¤å…ƒç´ åŸºç±»"""
    
    def __init__(self, value: Any):
        self.value = value
    
    def __str__(self):
        return str(self.value)
    
    def __repr__(self):
        return f"GroupElement({self.value})"
    
    def __eq__(self, other):
        return isinstance(other, GroupElement) and self.value == other.value
    
    def __hash__(self):
        return hash(self.value)

class Group(ABC):
    """ç¾¤æŠ½è±¡åŸºç±»"""
    
    def __init__(self, elements: Set[GroupElement]):
        self.elements = elements
        self.identity = self._find_identity()
    
    @abstractmethod
    def multiply(self, a: GroupElement, b: GroupElement) -> GroupElement:
        """ç¾¤ä¹˜æ³•"""
        pass
    
    @abstractmethod
    def inverse(self, a: GroupElement) -> GroupElement:
        """é€†å…ƒ"""
        pass
    
    def _find_identity(self) -> GroupElement:
        """æ‰¾åˆ°å•ä½å…ƒ"""
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if (self.multiply(e, a) != a or 
                    self.multiply(a, e) != a):
                    is_identity = False
                    break
            if is_identity:
                return e
        raise ValueError("ç¾¤ä¸­æ²¡æœ‰å•ä½å…ƒ")
    
    def is_group(self) -> bool:
        """éªŒè¯æ˜¯å¦ä¸ºç¾¤"""
        # æ£€æŸ¥å°é—­æ€§
        for a in self.elements:
            for b in self.elements:
                if self.multiply(a, b) not in self.elements:
                    return False
        
        # æ£€æŸ¥ç»“åˆå¾‹
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    if (self.multiply(self.multiply(a, b), c) != 
                        self.multiply(a, self.multiply(b, c))):
                        return False
        
        # æ£€æŸ¥å•ä½å…ƒ
        if self.identity not in self.elements:
            return False
        
        # æ£€æŸ¥é€†å…ƒ
        for a in self.elements:
            has_inverse = False
            for b in self.elements:
                if (self.multiply(a, b) == self.identity and 
                    self.multiply(b, a) == self.identity):
                    has_inverse = True
                    break
            if not has_inverse:
                return False
        
        return True
    
    def order(self) -> int:
        """ç¾¤çš„é˜¶"""
        return len(self.elements)
    
    def subgroup(self, elements: Set[GroupElement]) -> 'Group':
        """ç”Ÿæˆå­ç¾¤"""
        # éªŒè¯å­ç¾¤æ€§è´¨
        for a in elements:
            for b in elements:
                if self.multiply(a, b) not in elements:
                    raise ValueError("ä¸æ„æˆå­ç¾¤")
        
        return type(self)(elements)

class CyclicGroup(Group):
    """å¾ªç¯ç¾¤"""
    
    def __init__(self, generator: GroupElement, order: int):
        self.generator = generator
        self.order = order
        
        # ç”Ÿæˆç¾¤å…ƒç´ 
        elements = set()
        current = generator
        for _ in range(order):
            elements.add(current)
            current = self.multiply(current, generator)
        
        super().__init__(elements)
    
    def multiply(self, a: GroupElement, b: GroupElement) -> GroupElement:
        """å¾ªç¯ç¾¤ä¹˜æ³•"""
        # ç®€åŒ–å®ç°ï¼Œå‡è®¾å…ƒç´ æ˜¯æ•´æ•°
        result = (a.value + b.value) % self.order
        return GroupElement(result)
    
    def inverse(self, a: GroupElement) -> GroupElement:
        """å¾ªç¯ç¾¤é€†å…ƒ"""
        # ç®€åŒ–å®ç°
        inverse_value = (-a.value) % self.order
        return GroupElement(inverse_value)
    
    def is_cyclic(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¾ªç¯ç¾¤"""
        return True

class SymmetricGroup(Group):
    """å¯¹ç§°ç¾¤"""
    
    def __init__(self, n: int):
        self.n = n
        self.elements = self._generate_permutations(n)
        super().__init__(self.elements)
    
    def _generate_permutations(self, n: int) -> Set[GroupElement]:
        """ç”Ÿæˆæ‰€æœ‰ç½®æ¢"""
        if n == 1:
            return {GroupElement([0])}
        
        perms = set()
        for perm in self._generate_permutations(n - 1):
            for i in range(n):
                new_perm = list(perm.value)
                new_perm.insert(i, n - 1)
                perms.add(GroupElement(new_perm))
        
        return perms
    
    def multiply(self, a: GroupElement, b: GroupElement) -> GroupElement:
        """ç½®æ¢ä¹˜æ³•"""
        result = [0] * self.n
        for i in range(self.n):
            result[i] = a.value[b.value[i]]
        return GroupElement(result)
    
    def inverse(self, a: GroupElement) -> GroupElement:
        """ç½®æ¢é€†å…ƒ"""
        result = [0] * self.n
        for i in range(self.n):
            result[a.value[i]] = i
        return GroupElement(result)
```

### 3.2 ç¯è®ºå®ç°

```python
class RingElement:
    """ç¯å…ƒç´ """
    
    def __init__(self, value: Any):
        self.value = value
    
    def __str__(self):
        return str(self.value)
    
    def __repr__(self):
        return f"RingElement({self.value})"
    
    def __eq__(self, other):
        return isinstance(other, RingElement) and self.value == other.value
    
    def __hash__(self):
        return hash(self.value)

class Ring:
    """ç¯"""
    
    def __init__(self, elements: Set[RingElement]):
        self.elements = elements
        self.zero = self._find_zero()
        self.one = self._find_one()
    
    def add(self, a: RingElement, b: RingElement) -> RingElement:
        """ç¯åŠ æ³•"""
        # ç®€åŒ–å®ç°
        return RingElement(a.value + b.value)
    
    def multiply(self, a: RingElement, b: RingElement) -> RingElement:
        """ç¯ä¹˜æ³•"""
        # ç®€åŒ–å®ç°
        return RingElement(a.value * b.value)
    
    def _find_zero(self) -> RingElement:
        """æ‰¾åˆ°é›¶å…ƒ"""
        for e in self.elements:
            is_zero = True
            for a in self.elements:
                if (self.add(e, a) != a or 
                    self.add(a, e) != a):
                    is_zero = False
                    break
            if is_zero:
                return e
        raise ValueError("ç¯ä¸­æ²¡æœ‰é›¶å…ƒ")
    
    def _find_one(self) -> Optional[RingElement]:
        """æ‰¾åˆ°å•ä½å…ƒ"""
        for e in self.elements:
            if e == self.zero:
                continue
            is_one = True
            for a in self.elements:
                if a == self.zero:
                    continue
                if (self.multiply(e, a) != a or 
                    self.multiply(a, e) != a):
                    is_one = False
                    break
            if is_one:
                return e
        return None
    
    def is_ring(self) -> bool:
        """éªŒè¯æ˜¯å¦ä¸ºç¯"""
        # æ£€æŸ¥åŠ æ³•ç¾¤æ€§è´¨
        for a in self.elements:
            for b in self.elements:
                if self.add(a, b) not in self.elements:
                    return False
        
        # æ£€æŸ¥ä¹˜æ³•åŠç¾¤æ€§è´¨
        for a in self.elements:
            for b in self.elements:
                if self.multiply(a, b) not in self.elements:
                    return False
        
        # æ£€æŸ¥åˆ†é…å¾‹
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    if (self.multiply(a, self.add(b, c)) != 
                        self.add(self.multiply(a, b), self.multiply(a, c))):
                        return False
                    if (self.multiply(self.add(a, b), c) != 
                        self.add(self.multiply(a, c), self.multiply(b, c))):
                        return False
        
        return True

class Field(Ring):
    """åŸŸ"""
    
    def __init__(self, elements: Set[RingElement]):
        super().__init__(elements)
        if not self._is_field():
            raise ValueError("ä¸æ„æˆåŸŸ")
    
    def _is_field(self) -> bool:
        """éªŒè¯æ˜¯å¦ä¸ºåŸŸ"""
        if not self.is_ring():
            return False
        
        # æ£€æŸ¥éé›¶å…ƒç´ æ„æˆä¹˜æ³•ç¾¤
        nonzero_elements = {e for e in self.elements if e != self.zero}
        
        for a in nonzero_elements:
            for b in nonzero_elements:
                if self.multiply(a, b) not in nonzero_elements:
                    return False
        
        # æ£€æŸ¥æ¯ä¸ªéé›¶å…ƒç´ éƒ½æœ‰é€†å…ƒ
        for a in nonzero_elements:
            has_inverse = False
            for b in nonzero_elements:
                if self.multiply(a, b) == self.one:
                    has_inverse = True
                    break
            if not has_inverse:
                return False
        
        return True
    
    def divide(self, a: RingElement, b: RingElement) -> RingElement:
        """åŸŸé™¤æ³•"""
        if b == self.zero:
            raise ValueError("é™¤é›¶é”™è¯¯")
        
        # æ‰¾åˆ°bçš„é€†å…ƒ
        for c in self.elements:
            if c != self.zero and self.multiply(b, c) == self.one:
                return self.multiply(a, c)
        
        raise ValueError("æ— æ³•æ‰¾åˆ°é€†å…ƒ")

class FiniteField(Field):
    """æœ‰é™åŸŸ"""
    
    def __init__(self, p: int, n: int = 1):
        """
        æ„é€ æœ‰é™åŸŸ GF(p^n)
        
        p: ç´ æ•°
        n: æ¬¡æ•°
        """
        self.p = p
        self.n = n
        self.order = p ** n
        
        # ç”ŸæˆåŸŸå…ƒç´ 
        if n == 1:
            elements = {RingElement(i) for i in range(p)}
        else:
            # ç®€åŒ–å®ç°ï¼Œä»…æ”¯æŒn=1çš„æƒ…å†µ
            raise NotImplementedError("ä»…æ”¯æŒn=1çš„æœ‰é™åŸŸ")
        
        super().__init__(elements)
    
    def add(self, a: RingElement, b: RingElement) -> RingElement:
        """æœ‰é™åŸŸåŠ æ³•"""
        return RingElement((a.value + b.value) % self.p)
    
    def multiply(self, a: RingElement, b: RingElement) -> RingElement:
        """æœ‰é™åŸŸä¹˜æ³•"""
        return RingElement((a.value * b.value) % self.p)
```

### 3.3 çº¿æ€§ä»£æ•°å®ç°

```python
class Vector:
    """å‘é‡"""
    
    def __init__(self, components: List[float]):
        self.components = components
        self.dimension = len(components)
    
    def __str__(self):
        return f"Vector({self.components})"
    
    def __repr__(self):
        return self.__str__()
    
    def __add__(self, other: 'Vector') -> 'Vector':
        """å‘é‡åŠ æ³•"""
        if self.dimension != other.dimension:
            raise ValueError("å‘é‡ç»´åº¦ä¸åŒ¹é…")
        
        result = [a + b for a, b in zip(self.components, other.components)]
        return Vector(result)
    
    def __sub__(self, other: 'Vector') -> 'Vector':
        """å‘é‡å‡æ³•"""
        if self.dimension != other.dimension:
            raise ValueError("å‘é‡ç»´åº¦ä¸åŒ¹é…")
        
        result = [a - b for a, b in zip(self.components, other.components)]
        return Vector(result)
    
    def __mul__(self, scalar: float) -> 'Vector':
        """æ ‡é‡ä¹˜æ³•"""
        result = [a * scalar for a in self.components]
        return Vector(result)
    
    def __rmul__(self, scalar: float) -> 'Vector':
        """å³æ ‡é‡ä¹˜æ³•"""
        return self * scalar
    
    def dot(self, other: 'Vector') -> float:
        """ç‚¹ç§¯"""
        if self.dimension != other.dimension:
            raise ValueError("å‘é‡ç»´åº¦ä¸åŒ¹é…")
        
        return sum(a * b for a, b in zip(self.components, other.components))
    
    def norm(self) -> float:
        """èŒƒæ•°"""
        return math.sqrt(self.dot(self))
    
    def normalize(self) -> 'Vector':
        """å•ä½åŒ–"""
        norm = self.norm()
        if norm == 0:
            raise ValueError("é›¶å‘é‡æ— æ³•å•ä½åŒ–")
        return self * (1 / norm)

class Matrix:
    """çŸ©é˜µ"""
    
    def __init__(self, rows: List[List[float]]):
        self.rows = rows
        self.m = len(rows)
        self.n = len(rows[0]) if rows else 0
        
        # éªŒè¯çŸ©é˜µå½¢çŠ¶
        for row in rows:
            if len(row) != self.n:
                raise ValueError("çŸ©é˜µè¡Œé•¿åº¦ä¸ä¸€è‡´")
    
    def __str__(self):
        return f"Matrix({self.rows})"
    
    def __repr__(self):
        return self.__str__()
    
    def __add__(self, other: 'Matrix') -> 'Matrix':
        """çŸ©é˜µåŠ æ³•"""
        if self.m != other.m or self.n != other.n:
            raise ValueError("çŸ©é˜µç»´åº¦ä¸åŒ¹é…")
        
        result = []
        for i in range(self.m):
            row = [self.rows[i][j] + other.rows[i][j] for j in range(self.n)]
            result.append(row)
        
        return Matrix(result)
    
    def __sub__(self, other: 'Matrix') -> 'Matrix':
        """çŸ©é˜µå‡æ³•"""
        if self.m != other.m or self.n != other.n:
            raise ValueError("çŸ©é˜µç»´åº¦ä¸åŒ¹é…")
        
        result = []
        for i in range(self.m):
            row = [self.rows[i][j] - other.rows[i][j] for j in range(self.n)]
            result.append(row)
        
        return Matrix(result)
    
    def __mul__(self, other: 'Matrix') -> 'Matrix':
        """çŸ©é˜µä¹˜æ³•"""
        if self.n != other.m:
            raise ValueError("çŸ©é˜µç»´åº¦ä¸åŒ¹é…")
        
        result = []
        for i in range(self.m):
            row = []
            for j in range(other.n):
                element = sum(self.rows[i][k] * other.rows[k][j] 
                            for k in range(self.n))
                row.append(element)
            result.append(row)
        
        return Matrix(result)
    
    def __rmul__(self, scalar: float) -> 'Matrix':
        """æ ‡é‡ä¹˜æ³•"""
        result = []
        for i in range(self.m):
            row = [scalar * self.rows[i][j] for j in range(self.n)]
            result.append(row)
        
        return Matrix(result)
    
    def transpose(self) -> 'Matrix':
        """è½¬ç½®"""
        result = []
        for j in range(self.n):
            row = [self.rows[i][j] for i in range(self.m)]
            result.append(row)
        
        return Matrix(result)
    
    def determinant(self) -> float:
        """è¡Œåˆ—å¼"""
        if self.m != self.n:
            raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰è¡Œåˆ—å¼")
        
        if self.m == 1:
            return self.rows[0][0]
        
        if self.m == 2:
            return (self.rows[0][0] * self.rows[1][1] - 
                   self.rows[0][1] * self.rows[1][0])
        
        # ä½¿ç”¨æ‹‰æ™®æ‹‰æ–¯å±•å¼€
        det = 0
        for j in range(self.n):
            minor = self._minor(0, j)
            det += (-1) ** j * self.rows[0][j] * minor.determinant()
        
        return det
    
    def _minor(self, i: int, j: int) -> 'Matrix':
        """ä½™å­å¼"""
        result = []
        for row_idx in range(self.m):
            if row_idx == i:
                continue
            row = []
            for col_idx in range(self.n):
                if col_idx == j:
                    continue
                row.append(self.rows[row_idx][col_idx])
            result.append(row)
        
        return Matrix(result)
    
    def inverse(self) -> 'Matrix':
        """é€†çŸ©é˜µ"""
        if self.m != self.n:
            raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰é€†çŸ©é˜µ")
        
        det = self.determinant()
        if det == 0:
            raise ValueError("çŸ©é˜µä¸å¯é€†")
        
        # ä½¿ç”¨ä¼´éšçŸ©é˜µ
        adj = self._adjugate()
        return adj * (1 / det)
    
    def _adjugate(self) -> 'Matrix':
        """ä¼´éšçŸ©é˜µ"""
        result = []
        for i in range(self.m):
            row = []
            for j in range(self.n):
                minor = self._minor(i, j)
                cofactor = (-1) ** (i + j) * minor.determinant()
                row.append(cofactor)
            result.append(row)
        
        return Matrix(result).transpose()
    
    @classmethod
    def identity(cls, n: int) -> 'Matrix':
        """å•ä½çŸ©é˜µ"""
        rows = []
        for i in range(n):
            row = [1 if i == j else 0 for j in range(n)]
            rows.append(row)
        
        return cls(rows)
    
    @classmethod
    def zero(cls, m: int, n: int) -> 'Matrix':
        """é›¶çŸ©é˜µ"""
        rows = [[0 for _ in range(n)] for _ in range(m)]
        return cls(rows)
```

### 3.4 çº¿æ€§å˜æ¢å®ç°

```python
class LinearTransformation:
    """çº¿æ€§å˜æ¢"""
    
    def __init__(self, matrix: Matrix):
        self.matrix = matrix
    
    def __call__(self, vector: Vector) -> Vector:
        """åº”ç”¨çº¿æ€§å˜æ¢"""
        if vector.dimension != self.matrix.n:
            raise ValueError("å‘é‡ç»´åº¦ä¸çŸ©é˜µä¸åŒ¹é…")
        
        result = []
        for i in range(self.matrix.m):
            element = sum(self.matrix.rows[i][j] * vector.components[j] 
                         for j in range(self.matrix.n))
            result.append(element)
        
        return Vector(result)
    
    def kernel(self) -> List[Vector]:
        """æ ¸ç©ºé—´"""
        # ç®€åŒ–å®ç°ï¼Œæ±‚è§£é½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„
        # è¿™é‡Œè¿”å›é›¶å‘é‡
        return [Vector([0] * self.matrix.n)]
    
    def image(self) -> List[Vector]:
        """åƒç©ºé—´"""
        # ç®€åŒ–å®ç°ï¼Œè¿”å›çŸ©é˜µçš„åˆ—ç©ºé—´
        result = []
        for j in range(self.matrix.n):
            column = [self.matrix.rows[i][j] for i in range(self.matrix.m)]
            result.append(Vector(column))
        return result
    
    def rank(self) -> int:
        """ç§©"""
        # ç®€åŒ–å®ç°
        return min(self.matrix.m, self.matrix.n)
    
    def nullity(self) -> int:
        """é›¶åŒ–åº¦"""
        return self.matrix.n - self.rank()
    
    def compose(self, other: 'LinearTransformation') -> 'LinearTransformation':
        """å¤åˆå˜æ¢"""
        result_matrix = self.matrix * other.matrix
        return LinearTransformation(result_matrix)
```

## 4. åº”ç”¨ç¤ºä¾‹

### 4.1 ç¾¤è®ºåº”ç”¨

```python
# å¾ªç¯ç¾¤ç¤ºä¾‹
def test_cyclic_group():
    # åˆ›å»ºé˜¶ä¸º5çš„å¾ªç¯ç¾¤
    generator = GroupElement(1)
    group = CyclicGroup(generator, 5)
    
    print(f"å¾ªç¯ç¾¤é˜¶æ•°: {group.order()}")
    print(f"ç¾¤å…ƒç´ : {[str(e) for e in group.elements]}")
    print(f"å•ä½å…ƒ: {group.identity}")
    print(f"æ˜¯å¦ä¸ºç¾¤: {group.is_group()}")

# å¯¹ç§°ç¾¤ç¤ºä¾‹
def test_symmetric_group():
    # åˆ›å»ºS3å¯¹ç§°ç¾¤
    group = SymmetricGroup(3)
    
    print(f"å¯¹ç§°ç¾¤S3é˜¶æ•°: {group.order()}")
    print(f"ç¾¤å…ƒç´ : {[str(e) for e in list(group.elements)[:5]]}...")
    print(f"æ˜¯å¦ä¸ºç¾¤: {group.is_group()}")

# è¿è¡Œæµ‹è¯•
test_cyclic_group()
test_symmetric_group()
```

### 4.2 ç¯è®ºåº”ç”¨

```python
# æœ‰é™åŸŸç¤ºä¾‹
def test_finite_field():
    # åˆ›å»ºGF(5)
    field = FiniteField(5)
    
    print(f"æœ‰é™åŸŸGF(5)é˜¶æ•°: {field.order}")
    print(f"åŸŸå…ƒç´ : {[str(e) for e in field.elements]}")
    print(f"é›¶å…ƒ: {field.zero}")
    print(f"å•ä½å…ƒ: {field.one}")
    print(f"æ˜¯å¦ä¸ºåŸŸ: {field._is_field()}")
    
    # æµ‹è¯•è¿ç®—
    a = RingElement(2)
    b = RingElement(3)
    print(f"{a} + {b} = {field.add(a, b)}")
    print(f"{a} * {b} = {field.multiply(a, b)}")
    print(f"{a} / {b} = {field.divide(a, b)}")

# è¿è¡Œæµ‹è¯•
test_finite_field()
```

### 4.3 çº¿æ€§ä»£æ•°åº”ç”¨

```python
# å‘é‡è¿ç®—ç¤ºä¾‹
def test_vector_operations():
    v1 = Vector([1, 2, 3])
    v2 = Vector([4, 5, 6])
    
    print(f"v1 = {v1}")
    print(f"v2 = {v2}")
    print(f"v1 + v2 = {v1 + v2}")
    print(f"v1 - v2 = {v1 - v2}")
    print(f"2 * v1 = {2 * v1}")
    print(f"v1 Â· v2 = {v1.dot(v2)}")
    print(f"||v1|| = {v1.norm()}")

# çŸ©é˜µè¿ç®—ç¤ºä¾‹
def test_matrix_operations():
    A = Matrix([[1, 2], [3, 4]])
    B = Matrix([[5, 6], [7, 8]])
    
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"A + B = {A + B}")
    print(f"A * B = {A * B}")
    print(f"det(A) = {A.determinant()}")
    print(f"A^(-1) = {A.inverse()}")

# çº¿æ€§å˜æ¢ç¤ºä¾‹
def test_linear_transformation():
    # æ—‹è½¬çŸ©é˜µ
    theta = math.pi / 4  # 45åº¦
    rotation_matrix = Matrix([
        [math.cos(theta), -math.sin(theta)],
        [math.sin(theta), math.cos(theta)]
    ])
    
    T = LinearTransformation(rotation_matrix)
    v = Vector([1, 0])
    
    print(f"æ—‹è½¬çŸ©é˜µ: {rotation_matrix}")
    print(f"å‘é‡ v = {v}")
    print(f"æ—‹è½¬å T(v) = {T(v)}")
    print(f"å˜æ¢ç§©: {T.rank()}")

# è¿è¡Œæµ‹è¯•
test_vector_operations()
test_matrix_operations()
test_linear_transformation()
```

## 5. ç†è®ºè¯æ˜

### 5.1 ç¾¤è®ºè¯æ˜

**å®šç† 5.1** (ç¾¤å…ƒç´ çš„é˜¶)
ç¾¤ $G$ ä¸­å…ƒç´  $g$ çš„é˜¶æ˜¯ä½¿å¾— $g^n = e$ çš„æœ€å°æ­£æ•´æ•° $n$ã€‚

**è¯æ˜**:
ä½¿ç”¨é¸½å·¢åŸç†è¯æ˜é˜¶çš„å­˜åœ¨æ€§ã€‚

**å®šç† 5.2** (å¾ªç¯ç¾¤ç»“æ„)
é˜¶ä¸º $n$ çš„å¾ªç¯ç¾¤åŒæ„äº $(\mathbb{Z}_n, +)$ã€‚

**è¯æ˜**:
æ„é€ åŒæ„æ˜ å°„ $f: \langle g \rangle \rightarrow \mathbb{Z}_n$ã€‚

### 5.2 ç¯è®ºè¯æ˜

**å®šç† 5.3** (ç†æƒ³çš„æ€§è´¨)
ç¯ $R$ çš„ç†æƒ³ $I$ æ˜¯ $R$ çš„å­ç¯ï¼Œä¸”æ»¡è¶³å¸æ”¶æ€§è´¨ã€‚

**è¯æ˜**:
ç›´æ¥éªŒè¯å®šä¹‰ã€‚

### 5.3 çº¿æ€§ä»£æ•°è¯æ˜

**å®šç† 5.4** (çŸ©é˜µç§©çš„æ€§è´¨)
çŸ©é˜µçš„ç§©ç­‰äºå…¶è¡Œç©ºé—´çš„ç»´æ•°ï¼Œä¹Ÿç­‰äºå…¶åˆ—ç©ºé—´çš„ç»´æ•°ã€‚

**è¯æ˜**:
ä½¿ç”¨è¡Œå˜æ¢å’Œåˆ—å˜æ¢ä¿æŒç§©çš„æ€§è´¨ã€‚

## 6. æ€§èƒ½åˆ†æ

### 6.1 å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------------|------------|----------|
| ç¾¤ä¹˜æ³• | O(1) | O(1) | ç¾¤è¿ç®— |
| çŸ©é˜µä¹˜æ³• | O(nÂ³) | O(nÂ²) | çº¿æ€§ä»£æ•°è®¡ç®— |
| è¡Œåˆ—å¼è®¡ç®— | O(n!) | O(nÂ²) | å°çŸ©é˜µ |
| çŸ©é˜µæ±‚é€† | O(nÂ³) | O(nÂ²) | çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£ |

### 6.2 ä¼˜åŒ–ç­–ç•¥

1. **å¹¶è¡Œè®¡ç®—**: åˆ©ç”¨å¤šæ ¸å¤„ç†å™¨å¹¶è¡Œè®¡ç®—
2. **ç¼“å­˜æœºåˆ¶**: ç¼“å­˜ä¸­é—´ç»“æœé¿å…é‡å¤è®¡ç®—
3. **æ•°å€¼ç¨³å®šæ€§**: ä½¿ç”¨æ•°å€¼ç¨³å®šçš„ç®—æ³•
4. **ç¨€ç–çŸ©é˜µ**: åˆ©ç”¨ç¨€ç–æ€§ä¼˜åŒ–å­˜å‚¨å’Œè®¡ç®—

## 7. æ€»ç»“

ä»£æ•°å­¦ä¸ºè®¡ç®—æœºç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ï¼Œç‰¹åˆ«æ˜¯åœ¨å¯†ç å­¦ã€ç¼–ç ç†è®ºã€ç®—æ³•è®¾è®¡ç­‰é¢†åŸŸæœ‰ç€å¹¿æ³›åº”ç”¨ã€‚

### ä¸»è¦æˆæœ

1. **å®Œæ•´çš„ç†è®ºæ¡†æ¶**: ä»åŸºæœ¬æ¦‚å¿µåˆ°é«˜çº§å®šç†
2. **å®ç”¨çš„å®ç°**: æ‰€æœ‰ä»£æ•°ç»“æ„éƒ½æœ‰å¯¹åº”çš„Pythonå®ç°
3. **ä¸¥æ ¼çš„å½¢å¼åŒ–**: æ•°å­¦å®šä¹‰å’Œè¯æ˜
4. **å®é™…åº”ç”¨**: å¯†ç å­¦ã€ç¼–ç ç†è®ºã€ç®—æ³•è®¾è®¡ç­‰

### æŠ€æœ¯ç‰¹è‰²

1. **å¤šè¡¨å¾æ–¹æ³•**: æ¦‚å¿µã€æ•°å­¦ã€ä»£ç ã€å›¾è¡¨
2. **å±‚æ¬¡åŒ–ç»„ç»‡**: ä»åŸºç¡€åˆ°åº”ç”¨
3. **ä¸¥æ ¼çš„å½¢å¼åŒ–**: æ•°å­¦å®šä¹‰å’Œè¯æ˜
4. **å®Œæ•´çš„å®ç°**: å¯è¿è¡Œçš„Pythonä»£ç 

---

*æœ¬æ–‡æ¡£å»ºç«‹äº†ä»£æ•°åŸºç¡€çš„å®Œæ•´æ¡†æ¶ï¼Œä¸ºåç»­çš„å¯†ç å­¦ã€ç¼–ç ç†è®ºç­‰å¥ å®šäº†åŸºç¡€ã€‚*
