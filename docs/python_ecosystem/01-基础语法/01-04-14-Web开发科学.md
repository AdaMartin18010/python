# 04-14 Webå¼€å‘ç§‘å­¦ (Web Development Science)

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [å½¢å¼åŒ–å®šä¹‰](#å½¢å¼åŒ–å®šä¹‰)
- [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
- [Webåº”ç”¨æ¨¡å‹](#webåº”ç”¨æ¨¡å‹)
- [HTTPåè®®æ ˆ](#httpåè®®æ ˆ)
- [å‰ç«¯å¼€å‘ç§‘å­¦](#å‰ç«¯å¼€å‘ç§‘å­¦)
- [åç«¯å¼€å‘ç§‘å­¦](#åç«¯å¼€å‘ç§‘å­¦)
- [å®‰å…¨æ¨¡å‹](#å®‰å…¨æ¨¡å‹)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [Pythonå®ç°](#pythonå®ç°)
- [åº”ç”¨ç¤ºä¾‹](#åº”ç”¨ç¤ºä¾‹)
- [æ€»ç»“](#æ€»ç»“)

## æ¦‚è¿°

Webå¼€å‘ç§‘å­¦æ˜¯ç ”ç©¶ä¸‡ç»´ç½‘åº”ç”¨ç³»ç»Ÿè®¾è®¡ã€å®ç°å’Œä¼˜åŒ–çš„ç»¼åˆæ€§å­¦ç§‘ï¼Œæ¶µç›–å‰ç«¯æŠ€æœ¯ã€åç«¯æ¶æ„ã€ç½‘ç»œåè®®ã€å®‰å…¨æœºåˆ¶ç­‰å¤šä¸ªç»´åº¦ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

```python
from typing import Dict, List, Optional, Union, Protocol
from dataclasses import dataclass
from enum import Enum
import asyncio
import json
import hashlib
import ssl
from datetime import datetime

@dataclass
class WebRequest:
    """Webè¯·æ±‚çš„å½¢å¼åŒ–å®šä¹‰"""
    method: str
    url: str
    headers: Dict[str, str]
    body: Optional[bytes]
    timestamp: datetime
    
@dataclass
class WebResponse:
    """Webå“åº”çš„å½¢å¼åŒ–å®šä¹‰"""
    status_code: int
    headers: Dict[str, str]
    body: bytes
    timestamp: datetime

class HTTPMethod(Enum):
    """HTTPæ–¹æ³•æšä¸¾"""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"
    HEAD = "HEAD"
    OPTIONS = "OPTIONS"
```

## å½¢å¼åŒ–å®šä¹‰

### Webåº”ç”¨ç³»ç»Ÿ

**å®šä¹‰ 4.14.1** (Webåº”ç”¨ç³»ç»Ÿ)
Webåº”ç”¨ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $W = (F, B, P, S, C)$ï¼Œå…¶ä¸­ï¼š

- $F$ æ˜¯å‰ç«¯ç»„ä»¶é›†åˆ
- $B$ æ˜¯åç«¯ç»„ä»¶é›†åˆ  
- $P$ æ˜¯åè®®æ ˆé›†åˆ
- $S$ æ˜¯å®‰å…¨æœºåˆ¶é›†åˆ
- $C$ æ˜¯é…ç½®å‚æ•°é›†åˆ

**å®šä¹‰ 4.14.2** (HTTPäº‹åŠ¡)
HTTPäº‹åŠ¡æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $T = (R, P, S)$ï¼Œå…¶ä¸­ï¼š

- $R$ æ˜¯è¯·æ±‚å¯¹è±¡
- $P$ æ˜¯å¤„ç†è¿‡ç¨‹
- $S$ æ˜¯å“åº”å¯¹è±¡

### çŠ¶æ€è½¬æ¢æ¨¡å‹

```python
class WebApplicationState(Enum):
    """Webåº”ç”¨çŠ¶æ€æšä¸¾"""
    INITIALIZED = "initialized"
    RUNNING = "running"
    MAINTENANCE = "maintenance"
    ERROR = "error"
    SHUTDOWN = "shutdown"

class StateTransition:
    """çŠ¶æ€è½¬æ¢æ¨¡å‹"""
    
    def __init__(self):
        self.transitions = {
            WebApplicationState.INITIALIZED: [WebApplicationState.RUNNING, WebApplicationState.ERROR],
            WebApplicationState.RUNNING: [WebApplicationState.MAINTENANCE, WebApplicationState.ERROR, WebApplicationState.SHUTDOWN],
            WebApplicationState.MAINTENANCE: [WebApplicationState.RUNNING, WebApplicationState.ERROR],
            WebApplicationState.ERROR: [WebApplicationState.RUNNING, WebApplicationState.SHUTDOWN],
            WebApplicationState.SHUTDOWN: []
        }
    
    def can_transition(self, from_state: WebApplicationState, to_state: WebApplicationState) -> bool:
        """æ£€æŸ¥çŠ¶æ€è½¬æ¢æ˜¯å¦æœ‰æ•ˆ"""
        return to_state in self.transitions.get(from_state, [])
    
    def get_valid_transitions(self, current_state: WebApplicationState) -> List[WebApplicationState]:
        """è·å–æœ‰æ•ˆçŠ¶æ€è½¬æ¢"""
        return self.transitions.get(current_state, [])
```

## ç†è®ºåŸºç¡€

### RESTæ¶æ„é£æ ¼

**å®šç† 4.14.1** (RESTçº¦æŸæ¡ä»¶)
RESTæ¶æ„å¿…é¡»æ»¡è¶³ä»¥ä¸‹çº¦æŸï¼š

1. **å®¢æˆ·ç«¯-æœåŠ¡å™¨åˆ†ç¦»**: $C \cap S = \emptyset$
2. **æ— çŠ¶æ€**: $\forall r \in R, \text{state}(r) = \emptyset$
3. **ç¼“å­˜**: $\exists c \in C, \text{cacheable}(c) = \text{true}$
4. **ç»Ÿä¸€æ¥å£**: $\forall i \in I, \text{uniform}(i) = \text{true}$
5. **åˆ†å±‚ç³»ç»Ÿ**: $\exists L_1, L_2, \ldots, L_n, \text{layered}(L_1, L_2, \ldots, L_n)$

```python
class RESTConstraint:
    """RESTçº¦æŸæ£€æŸ¥å™¨"""
    
    @staticmethod
    def check_client_server_separation(client: object, server: object) -> bool:
        """æ£€æŸ¥å®¢æˆ·ç«¯-æœåŠ¡å™¨åˆ†ç¦»"""
        return not hasattr(client, 'server_state') and not hasattr(server, 'client_state')
    
    @staticmethod
    def check_stateless(request: WebRequest) -> bool:
        """æ£€æŸ¥æ— çŠ¶æ€æ€§"""
        return 'session' not in request.headers and 'state' not in request.headers
    
    @staticmethod
    def check_cacheable(response: WebResponse) -> bool:
        """æ£€æŸ¥å¯ç¼“å­˜æ€§"""
        cache_headers = ['Cache-Control', 'ETag', 'Last-Modified']
        return any(header in response.headers for header in cache_headers)
    
    @staticmethod
    def check_uniform_interface(method: str, resource: str) -> bool:
        """æ£€æŸ¥ç»Ÿä¸€æ¥å£"""
        valid_methods = ['GET', 'POST', 'PUT', 'DELETE']
        return method in valid_methods and resource.startswith('/')
```

### HTTPåè®®ç†è®º

**å®šä¹‰ 4.14.3** (HTTPæ¶ˆæ¯)
HTTPæ¶ˆæ¯æ˜¯ä¸€ä¸ªå››å…ƒç»„ $M = (S, H, B, V)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯èµ·å§‹è¡Œ
- $H$ æ˜¯å¤´éƒ¨å­—æ®µé›†åˆ
- $B$ æ˜¯æ¶ˆæ¯ä½“
- $V$ æ˜¯åè®®ç‰ˆæœ¬

**å®šç† 4.14.2** (HTTPå¹‚ç­‰æ€§)
å¯¹äºå¹‚ç­‰HTTPæ–¹æ³• $m$ï¼Œæ»¡è¶³ï¼š
$\forall r_1, r_2 \in R, \text{method}(r_1) = \text{method}(r_2) = m \Rightarrow \text{result}(r_1) = \text{result}(r_2)$

```python
class HTTPMessage:
    """HTTPæ¶ˆæ¯æ¨¡å‹"""
    
    def __init__(self, start_line: str, headers: Dict[str, str], body: bytes, version: str):
        self.start_line = start_line
        self.headers = headers
        self.body = body
        self.version = version
    
    def is_idempotent(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå¹‚ç­‰æ–¹æ³•"""
        idempotent_methods = ['GET', 'PUT', 'DELETE', 'HEAD', 'OPTIONS']
        method = self.start_line.split()[0]
        return method in idempotent_methods
    
    def is_safe(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå®‰å…¨æ–¹æ³•"""
        safe_methods = ['GET', 'HEAD', 'OPTIONS']
        method = self.start_line.split()[0]
        return method in safe_methods
    
    def get_content_length(self) -> int:
        """è·å–å†…å®¹é•¿åº¦"""
        return len(self.body)
    
    def to_bytes(self) -> bytes:
        """è½¬æ¢ä¸ºå­—èŠ‚æµ"""
        lines = [self.start_line]
        for key, value in self.headers.items():
            lines.append(f"{key}: {value}")
        lines.append("")
        lines.append("")
        
        header_bytes = "\r\n".join(lines).encode('utf-8')
        return header_bytes + self.body
```

## Webåº”ç”¨æ¨¡å‹

### MVCæ¶æ„æ¨¡å¼

**å®šä¹‰ 4.14.4** (MVCæ¨¡å¼)
MVCæ¨¡å¼æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $MVC = (M, V, C)$ï¼Œå…¶ä¸­ï¼š

- $M$ æ˜¯æ¨¡å‹ç»„ä»¶ï¼Œè´Ÿè´£æ•°æ®å’Œä¸šåŠ¡é€»è¾‘
- $V$ æ˜¯è§†å›¾ç»„ä»¶ï¼Œè´Ÿè´£ç”¨æˆ·ç•Œé¢
- $C$ æ˜¯æ§åˆ¶å™¨ç»„ä»¶ï¼Œè´Ÿè´£åè°ƒæ¨¡å‹å’Œè§†å›¾

```python
from abc import ABC, abstractmethod

class Model(ABC):
    """æ¨¡å‹æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def get_data(self) -> Dict:
        """è·å–æ•°æ®"""
        pass
    
    @abstractmethod
    def update_data(self, data: Dict) -> bool:
        """æ›´æ–°æ•°æ®"""
        pass

class View(ABC):
    """è§†å›¾æŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def render(self, data: Dict) -> str:
        """æ¸²æŸ“è§†å›¾"""
        pass
    
    @abstractmethod
    def update(self, data: Dict) -> None:
        """æ›´æ–°è§†å›¾"""
        pass

class Controller:
    """æ§åˆ¶å™¨å®ç°"""
    
    def __init__(self, model: Model, view: View):
        self.model = model
        self.view = view
    
    def handle_request(self, request: WebRequest) -> WebResponse:
        """å¤„ç†è¯·æ±‚"""
        # è§£æè¯·æ±‚
        method = request.method
        path = request.url
        
        # è·¯ç”±åˆ†å‘
        if method == 'GET':
            return self.handle_get(path)
        elif method == 'POST':
            return self.handle_post(path, request.body)
        else:
            return WebResponse(405, {}, b"Method Not Allowed", datetime.now())
    
    def handle_get(self, path: str) -> WebResponse:
        """å¤„ç†GETè¯·æ±‚"""
        data = self.model.get_data()
        content = self.view.render(data)
        return WebResponse(200, {'Content-Type': 'text/html'}, content.encode(), datetime.now())
    
    def handle_post(self, path: str, body: bytes) -> WebResponse:
        """å¤„ç†POSTè¯·æ±‚"""
        # è§£æè¯·æ±‚ä½“
        form_data = self.parse_form_data(body)
        
        # æ›´æ–°æ¨¡å‹
        success = self.model.update_data(form_data)
        
        if success:
            return WebResponse(200, {}, b"Success", datetime.now())
        else:
            return WebResponse(400, {}, b"Bad Request", datetime.now())
    
    def parse_form_data(self, body: bytes) -> Dict:
        """è§£æè¡¨å•æ•°æ®"""
        data = {}
        if body:
            form_str = body.decode('utf-8')
            for pair in form_str.split('&'):
                if '=' in pair:
                    key, value = pair.split('=', 1)
                    data[key] = value
        return data
```

## HTTPåè®®æ ˆ

### åè®®å±‚æ¬¡æ¨¡å‹

```python
class HTTPProtocolStack:
    """HTTPåè®®æ ˆå®ç°"""
    
    def __init__(self):
        self.layers = {
            'application': self.application_layer,
            'presentation': self.presentation_layer,
            'session': self.session_layer,
            'transport': self.transport_layer,
            'network': self.network_layer,
            'data_link': self.data_link_layer,
            'physical': self.physical_layer
        }
    
    def send_request(self, request: WebRequest) -> WebResponse:
        """å‘é€è¯·æ±‚ï¼ˆè‡ªä¸Šè€Œä¸‹ï¼‰"""
        data = request
        for layer_name in ['application', 'presentation', 'session', 'transport', 'network', 'data_link', 'physical']:
            data = self.layers[layer_name].encode(data)
        
        # æ¨¡æ‹Ÿç½‘ç»œä¼ è¾“
        response_data = self.transmit(data)
        
        # æ¥æ”¶å“åº”ï¼ˆè‡ªä¸‹è€Œä¸Šï¼‰
        for layer_name in reversed(['application', 'presentation', 'session', 'transport', 'network', 'data_link', 'physical']):
            response_data = self.layers[layer_name].decode(response_data)
        
        return response_data
    
    def application_layer(self, data: WebRequest) -> bytes:
        """åº”ç”¨å±‚å¤„ç†"""
        return data.to_bytes()
    
    def presentation_layer(self, data: bytes) -> bytes:
        """è¡¨ç¤ºå±‚å¤„ç†ï¼ˆç¼–ç è½¬æ¢ï¼‰"""
        return data
    
    def session_layer(self, data: bytes) -> bytes:
        """ä¼šè¯å±‚å¤„ç†"""
        return data
    
    def transport_layer(self, data: bytes) -> bytes:
        """ä¼ è¾“å±‚å¤„ç†ï¼ˆTCPå°è£…ï¼‰"""
        # æ¨¡æ‹ŸTCPå¤´éƒ¨
        tcp_header = b"TCP_HEADER"
        return tcp_header + data
    
    def network_layer(self, data: bytes) -> bytes:
        """ç½‘ç»œå±‚å¤„ç†ï¼ˆIPå°è£…ï¼‰"""
        # æ¨¡æ‹ŸIPå¤´éƒ¨
        ip_header = b"IP_HEADER"
        return ip_header + data
    
    def data_link_layer(self, data: bytes) -> bytes:
        """æ•°æ®é“¾è·¯å±‚å¤„ç†"""
        return data
    
    def physical_layer(self, data: bytes) -> bytes:
        """ç‰©ç†å±‚å¤„ç†"""
        return data
    
    def transmit(self, data: bytes) -> bytes:
        """æ¨¡æ‹Ÿç½‘ç»œä¼ è¾“"""
        # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿå’Œé”™è¯¯
        import random
        if random.random() < 0.1:  # 10%é”™è¯¯ç‡
            raise ConnectionError("Network error")
        
        # æ¨¡æ‹Ÿå“åº”
        response = WebResponse(200, {'Content-Type': 'text/html'}, b"<html><body>Hello World</body></html>", datetime.now())
        return response.to_bytes()
```

## å‰ç«¯å¼€å‘ç§‘å­¦

### DOMæ¨¡å‹

**å®šä¹‰ 4.14.5** (DOMæ ‘)
DOMæ ‘æ˜¯ä¸€ä¸ªæœ‰å‘æ ‘ $T = (V, E)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $E$ æ˜¯è¾¹é›†åˆï¼Œè¡¨ç¤ºçˆ¶å­å…³ç³»

```python
class DOMNode:
    """DOMèŠ‚ç‚¹æ¨¡å‹"""
    
    def __init__(self, tag_name: str, attributes: Dict[str, str] = None, text_content: str = ""):
        self.tag_name = tag_name
        self.attributes = attributes or {}
        self.text_content = text_content
        self.children = []
        self.parent = None
    
    def add_child(self, child: 'DOMNode') -> None:
        """æ·»åŠ å­èŠ‚ç‚¹"""
        child.parent = self
        self.children.append(child)
    
    def remove_child(self, child: 'DOMNode') -> bool:
        """ç§»é™¤å­èŠ‚ç‚¹"""
        if child in self.children:
            self.children.remove(child)
            child.parent = None
            return True
        return False
    
    def get_element_by_id(self, element_id: str) -> Optional['DOMNode']:
        """æ ¹æ®IDæŸ¥æ‰¾å…ƒç´ """
        if self.attributes.get('id') == element_id:
            return self
        
        for child in self.children:
            result = child.get_element_by_id(element_id)
            if result:
                return result
        
        return None
    
    def get_elements_by_class(self, class_name: str) -> List['DOMNode']:
        """æ ¹æ®ç±»åæŸ¥æ‰¾å…ƒç´ """
        elements = []
        
        if class_name in self.attributes.get('class', '').split():
            elements.append(self)
        
        for child in self.children:
            elements.extend(child.get_elements_by_class(class_name))
        
        return elements
    
    def to_html(self) -> str:
        """è½¬æ¢ä¸ºHTMLå­—ç¬¦ä¸²"""
        if self.tag_name == 'text':
            return self.text_content
        
        html = f"<{self.tag_name}"
        
        for key, value in self.attributes.items():
            html += f' {key}="{value}"'
        
        if not self.children and not self.text_content:
            html += " />"
        else:
            html += ">"
            html += self.text_content
            
            for child in self.children:
                html += child.to_html()
            
            html += f"</{self.tag_name}>"
        
        return html

class DOMDocument:
    """DOMæ–‡æ¡£æ¨¡å‹"""
    
    def __init__(self):
        self.root = DOMNode('html')
        self.head = DOMNode('head')
        self.body = DOMNode('body')
        
        self.root.add_child(self.head)
        self.root.add_child(self.body)
    
    def create_element(self, tag_name: str, attributes: Dict[str, str] = None) -> DOMNode:
        """åˆ›å»ºå…ƒç´ """
        return DOMNode(tag_name, attributes)
    
    def get_element_by_id(self, element_id: str) -> Optional[DOMNode]:
        """æ ¹æ®IDæŸ¥æ‰¾å…ƒç´ """
        return self.root.get_element_by_id(element_id)
    
    def get_elements_by_class(self, class_name: str) -> List[DOMNode]:
        """æ ¹æ®ç±»åæŸ¥æ‰¾å…ƒç´ """
        return self.root.get_elements_by_class(class_name)
    
    def to_html(self) -> str:
        """è½¬æ¢ä¸ºHTMLæ–‡æ¡£"""
        return f"<!DOCTYPE html>\n{self.root.to_html()}"
```

### äº‹ä»¶ç³»ç»Ÿ

```python
from typing import Callable, Any

class Event:
    """äº‹ä»¶æ¨¡å‹"""
    
    def __init__(self, event_type: str, target: DOMNode, data: Any = None):
        self.type = event_type
        self.target = target
        self.data = data
        self.timestamp = datetime.now()
        self.propagation_stopped = False
    
    def stop_propagation(self) -> None:
        """åœæ­¢äº‹ä»¶ä¼ æ’­"""
        self.propagation_stopped = True

class EventSystem:
    """äº‹ä»¶ç³»ç»Ÿ"""
    
    def __init__(self):
        self.event_listeners = {}
    
    def add_event_listener(self, element: DOMNode, event_type: str, handler: Callable[[Event], None]) -> None:
        """æ·»åŠ äº‹ä»¶ç›‘å¬å™¨"""
        key = (id(element), event_type)
        if key not in self.event_listeners:
            self.event_listeners[key] = []
        self.event_listeners[key].append(handler)
    
    def remove_event_listener(self, element: DOMNode, event_type: str, handler: Callable[[Event], None]) -> bool:
        """ç§»é™¤äº‹ä»¶ç›‘å¬å™¨"""
        key = (id(element), event_type)
        if key in self.event_listeners:
            try:
                self.event_listeners[key].remove(handler)
                return True
            except ValueError:
                pass
        return False
    
    def dispatch_event(self, event: Event) -> None:
        """åˆ†å‘äº‹ä»¶"""
        # äº‹ä»¶æ•è·é˜¶æ®µï¼ˆè‡ªä¸Šè€Œä¸‹ï¼‰
        self._capture_phase(event)
        
        # ç›®æ ‡é˜¶æ®µ
        self._target_phase(event)
        
        # äº‹ä»¶å†’æ³¡é˜¶æ®µï¼ˆè‡ªä¸‹è€Œä¸Šï¼‰
        if not event.propagation_stopped:
            self._bubble_phase(event)
    
    def _capture_phase(self, event: Event) -> None:
        """äº‹ä»¶æ•è·é˜¶æ®µ"""
        # ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
        path = self._get_event_path(event.target)
        
        # è‡ªä¸Šè€Œä¸‹è§¦å‘æ•è·äº‹ä»¶
        for node in reversed(path[:-1]):  # ä¸åŒ…æ‹¬ç›®æ ‡èŠ‚ç‚¹
            key = (id(node), f"{event.type}_capture")
            if key in self.event_listeners:
                for handler in self.event_listeners[key]:
                    handler(event)
                    if event.propagation_stopped:
                        return
    
    def _target_phase(self, event: Event) -> None:
        """ç›®æ ‡é˜¶æ®µ"""
        key = (id(event.target), event.type)
        if key in self.event_listeners:
            for handler in self.event_listeners[key]:
                handler(event)
                if event.propagation_stopped:
                    return
    
    def _bubble_phase(self, event: Event) -> None:
        """äº‹ä»¶å†’æ³¡é˜¶æ®µ"""
        # ä»ç›®æ ‡èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„
        path = self._get_event_path(event.target)
        
        # è‡ªä¸‹è€Œä¸Šè§¦å‘å†’æ³¡äº‹ä»¶
        for node in path[:-1]:  # ä¸åŒ…æ‹¬ç›®æ ‡èŠ‚ç‚¹
            key = (id(node), event.type)
            if key in self.event_listeners:
                for handler in self.event_listeners[key]:
                    handler(event)
                    if event.propagation_stopped:
                        return
    
    def _get_event_path(self, target: DOMNode) -> List[DOMNode]:
        """è·å–äº‹ä»¶è·¯å¾„"""
        path = [target]
        current = target
        
        while current.parent:
            current = current.parent
            path.append(current)
        
        return path
```

## åç«¯å¼€å‘ç§‘å­¦

### RESTful APIè®¾è®¡

```python
class RESTfulAPI:
    """RESTful APIè®¾è®¡æ¨¡å¼"""
    
    def __init__(self):
        self.resources = {}
        self.routes = {}
    
    def register_resource(self, resource_name: str, resource_class: type) -> None:
        """æ³¨å†Œèµ„æº"""
        self.resources[resource_name] = resource_class
    
    def add_route(self, method: str, path: str, handler: Callable) -> None:
        """æ·»åŠ è·¯ç”±"""
        key = (method, path)
        self.routes[key] = handler
    
    def handle_request(self, request: WebRequest) -> WebResponse:
        """å¤„ç†è¯·æ±‚"""
        method = request.method
        path = request.url
        
        # æŸ¥æ‰¾è·¯ç”±
        route_key = (method, path)
        if route_key in self.routes:
            handler = self.routes[route_key]
            return handler(request)
        
        # å°è¯•åŒ¹é…èµ„æºè·¯ç”±
        resource_response = self._handle_resource_request(request)
        if resource_response:
            return resource_response
        
        return WebResponse(404, {}, b"Not Found", datetime.now())
    
    def _handle_resource_request(self, request: WebRequest) -> Optional[WebResponse]:
        """å¤„ç†èµ„æºè¯·æ±‚"""
        method = request.method
        path = request.url
        
        # è§£æè·¯å¾„ /api/{resource}/{id}
        parts = path.split('/')
        if len(parts) >= 3 and parts[1] == 'api':
            resource_name = parts[2]
            resource_id = parts[3] if len(parts) > 3 else None
            
            if resource_name in self.resources:
                resource_class = self.resources[resource_name]
                
                if method == 'GET':
                    if resource_id:
                        return self._get_resource(resource_class, resource_id)
                    else:
                        return self._list_resources(resource_class)
                elif method == 'POST':
                    return self._create_resource(resource_class, request.body)
                elif method == 'PUT':
                    return self._update_resource(resource_class, resource_id, request.body)
                elif method == 'DELETE':
                    return self._delete_resource(resource_class, resource_id)
        
        return None
    
    def _get_resource(self, resource_class: type, resource_id: str) -> WebResponse:
        """è·å–å•ä¸ªèµ„æº"""
        # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        data = {"id": resource_id, "name": f"Resource {resource_id}"}
        return WebResponse(200, {'Content-Type': 'application/json'}, json.dumps(data).encode(), datetime.now())
    
    def _list_resources(self, resource_class: type) -> WebResponse:
        """è·å–èµ„æºåˆ—è¡¨"""
        # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        data = [{"id": "1", "name": "Resource 1"}, {"id": "2", "name": "Resource 2"}]
        return WebResponse(200, {'Content-Type': 'application/json'}, json.dumps(data).encode(), datetime.now())
    
    def _create_resource(self, resource_class: type, body: bytes) -> WebResponse:
        """åˆ›å»ºèµ„æº"""
        data = json.loads(body.decode())
        # æ¨¡æ‹Ÿæ•°æ®åº“æ’å…¥
        new_id = "3"
        return WebResponse(201, {'Content-Type': 'application/json'}, json.dumps({"id": new_id, **data}).encode(), datetime.now())
    
    def _update_resource(self, resource_class: type, resource_id: str, body: bytes) -> WebResponse:
        """æ›´æ–°èµ„æº"""
        data = json.loads(body.decode())
        # æ¨¡æ‹Ÿæ•°æ®åº“æ›´æ–°
        return WebResponse(200, {'Content-Type': 'application/json'}, json.dumps({"id": resource_id, **data}).encode(), datetime.now())
    
    def _delete_resource(self, resource_class: type, resource_id: str) -> WebResponse:
        """åˆ é™¤èµ„æº"""
        # æ¨¡æ‹Ÿæ•°æ®åº“åˆ é™¤
        return WebResponse(204, {}, b"", datetime.now())
```

## å®‰å…¨æ¨¡å‹

### è®¤è¯ä¸æˆæƒ

```python
class SecurityModel:
    """å®‰å…¨æ¨¡å‹"""
    
    def __init__(self):
        self.users = {}
        self.sessions = {}
        self.permissions = {}
    
    def authenticate(self, username: str, password: str) -> Optional[str]:
        """ç”¨æˆ·è®¤è¯"""
        if username in self.users:
            stored_password = self.users[username]['password']
            if self._verify_password(password, stored_password):
                # ç”Ÿæˆä¼šè¯ä»¤ç‰Œ
                session_token = self._generate_session_token()
                self.sessions[session_token] = {
                    'username': username,
                    'created_at': datetime.now(),
                    'expires_at': datetime.now().replace(hour=datetime.now().hour + 1)
                }
                return session_token
        return None
    
    def authorize(self, session_token: str, resource: str, action: str) -> bool:
        """æƒé™éªŒè¯"""
        if session_token not in self.sessions:
            return False
        
        session = self.sessions[session_token]
        if datetime.now() > session['expires_at']:
            del self.sessions[session_token]
            return False
        
        username = session['username']
        user_permissions = self.permissions.get(username, [])
        
        required_permission = f"{resource}:{action}"
        return required_permission in user_permissions
    
    def _verify_password(self, password: str, stored_password: str) -> bool:
        """éªŒè¯å¯†ç """
        # ä½¿ç”¨å“ˆå¸ŒéªŒè¯
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        return password_hash == stored_password
    
    def _generate_session_token(self) -> str:
        """ç”Ÿæˆä¼šè¯ä»¤ç‰Œ"""
        import secrets
        return secrets.token_urlsafe(32)
    
    def add_user(self, username: str, password: str, permissions: List[str]) -> None:
        """æ·»åŠ ç”¨æˆ·"""
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        self.users[username] = {'password': password_hash}
        self.permissions[username] = permissions
```

## æ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥

```python
class CacheStrategy:
    """ç¼“å­˜ç­–ç•¥"""
    
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.cache = {}
        self.access_times = {}
    
    def get(self, key: str) -> Optional[bytes]:
        """è·å–ç¼“å­˜"""
        if key in self.cache:
            # æ›´æ–°è®¿é—®æ—¶é—´
            self.access_times[key] = datetime.now()
            return self.cache[key]
        return None
    
    def set(self, key: str, value: bytes, ttl: int = 3600) -> None:
        """è®¾ç½®ç¼“å­˜"""
        if len(self.cache) >= self.max_size:
            self._evict_lru()
        
        self.cache[key] = value
        self.access_times[key] = datetime.now()
    
    def _evict_lru(self) -> None:
        """æ·˜æ±°æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„é¡¹"""
        if not self.access_times:
            return
        
        # æ‰¾åˆ°æœ€ä¹…æœªè®¿é—®çš„é¡¹
        lru_key = min(self.access_times.keys(), key=lambda k: self.access_times[k])
        del self.cache[lru_key]
        del self.access_times[lru_key]
    
    def invalidate(self, key: str) -> bool:
        """å¤±æ•ˆç¼“å­˜"""
        if key in self.cache:
            del self.cache[key]
            del self.access_times[key]
            return True
        return False
```

## Pythonå®ç°

### WebæœåŠ¡å™¨å®ç°

```python
class SimpleWebServer:
    """ç®€å•WebæœåŠ¡å™¨å®ç°"""
    
    def __init__(self, host: str = 'localhost', port: int = 8000):
        self.host = host
        self.port = port
        self.routes = {}
        self.middleware = []
        self.security_model = SecurityModel()
        self.cache = CacheStrategy()
    
    def route(self, path: str, methods: List[str] = None):
        """è·¯ç”±è£…é¥°å™¨"""
        if methods is None:
            methods = ['GET']
        
        def decorator(handler):
            for method in methods:
                self.routes[(method, path)] = handler
            return handler
        return decorator
    
    def add_middleware(self, middleware_func: Callable):
        """æ·»åŠ ä¸­é—´ä»¶"""
        self.middleware.append(middleware_func)
    
    def handle_request(self, request: WebRequest) -> WebResponse:
        """å¤„ç†è¯·æ±‚"""
        # åº”ç”¨ä¸­é—´ä»¶
        for middleware in self.middleware:
            request = middleware(request)
        
        # æ£€æŸ¥ç¼“å­˜
        cache_key = f"{request.method}:{request.url}"
        cached_response = self.cache.get(cache_key)
        if cached_response:
            return WebResponse(200, {'X-Cache': 'HIT'}, cached_response, datetime.now())
        
        # æŸ¥æ‰¾è·¯ç”±
        route_key = (request.method, request.url)
        if route_key in self.routes:
            handler = self.routes[route_key]
            response = handler(request)
            
            # ç¼“å­˜å“åº”
            if response.status_code == 200:
                self.cache.set(cache_key, response.body)
            
            return response
        
        return WebResponse(404, {}, b"Not Found", datetime.now())
    
    def run(self):
        """è¿è¡ŒæœåŠ¡å™¨"""
        print(f"Server running on http://{self.host}:{self.port}")
        
        # ç¤ºä¾‹è·¯ç”±
        @self.route('/')
        def home(request):
            return WebResponse(200, {'Content-Type': 'text/html'}, b"<h1>Welcome to Web Server</h1>", datetime.now())
        
        @self.route('/api/users', methods=['GET'])
        def get_users(request):
            users = [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]
            return WebResponse(200, {'Content-Type': 'application/json'}, json.dumps(users).encode(), datetime.now())
```

## åº”ç”¨ç¤ºä¾‹

### å®Œæ•´Webåº”ç”¨ç¤ºä¾‹

```python
def create_web_application():
    """åˆ›å»ºå®Œæ•´Webåº”ç”¨ç¤ºä¾‹"""
    
    # åˆ›å»ºæœåŠ¡å™¨
    server = SimpleWebServer()
    
    # æ·»åŠ ä¸­é—´ä»¶
    def logging_middleware(request: WebRequest) -> WebRequest:
        print(f"[{datetime.now()}] {request.method} {request.url}")
        return request
    
    def auth_middleware(request: WebRequest) -> WebRequest:
        auth_header = request.headers.get('Authorization')
        if auth_header and auth_header.startswith('Bearer '):
            token = auth_header[7:]
            if server.security_model.authorize(token, 'api', 'read'):
                request.headers['X-Authenticated'] = 'true'
        return request
    
    server.add_middleware(logging_middleware)
    server.add_middleware(auth_middleware)
    
    # æ·»åŠ ç”¨æˆ·
    server.security_model.add_user('admin', 'password123', ['api:read', 'api:write'])
    
    # å®šä¹‰è·¯ç”±
    @server.route('/')
    def home(request):
        html = """
        <!DOCTYPE html>
        <html>
        <head><title>Web Application</title></head>
        <body>
            <h1>Welcome to Web Application</h1>
            <p>This is a complete web application example.</p>
            <ul>
                <li><a href="/api/users">Users API</a></li>
                <li><a href="/api/products">Products API</a></li>
            </ul>
        </body>
        </html>
        """
        return WebResponse(200, {'Content-Type': 'text/html'}, html.encode(), datetime.now())
    
    @server.route('/api/users', methods=['GET'])
    def get_users(request):
        users = [
            {"id": 1, "name": "Alice", "email": "alice@example.com"},
            {"id": 2, "name": "Bob", "email": "bob@example.com"},
            {"id": 3, "name": "Charlie", "email": "charlie@example.com"}
        ]
        return WebResponse(200, {'Content-Type': 'application/json'}, json.dumps(users).encode(), datetime.now())
    
    @server.route('/api/products', methods=['GET'])
    def get_products(request):
        products = [
            {"id": 1, "name": "Product A", "price": 99.99},
            {"id": 2, "name": "Product B", "price": 149.99},
            {"id": 3, "name": "Product C", "price": 199.99}
        ]
        return WebResponse(200, {'Content-Type': 'application/json'}, json.dumps(products).encode(), datetime.now())
    
    return server

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    app = create_web_application()
    
    # æ¨¡æ‹Ÿè¯·æ±‚
    request1 = WebRequest('GET', '/', {}, None, datetime.now())
    response1 = app.handle_request(request1)
    print(f"Response 1: {response1.status_code}")
    
    request2 = WebRequest('GET', '/api/users', {}, None, datetime.now())
    response2 = app.handle_request(request2)
    print(f"Response 2: {response2.status_code}")
    print(f"Response 2 body: {response2.body.decode()}")
```

## æ€»ç»“

Webå¼€å‘ç§‘å­¦æ˜¯ä¸€ä¸ªç»¼åˆæ€§çš„å­¦ç§‘ï¼Œæ¶µç›–äº†ä»åº•å±‚åè®®åˆ°é«˜å±‚åº”ç”¨çš„å„ä¸ªæ–¹é¢ã€‚é€šè¿‡å½¢å¼åŒ–çš„å®šä¹‰å’Œä¸¥æ ¼çš„æ•°å­¦å»ºæ¨¡ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å¥½åœ°ç†è§£å’Œè®¾è®¡Webåº”ç”¨ç³»ç»Ÿã€‚

### å…³é”®è¦ç‚¹

1. **å½¢å¼åŒ–å»ºæ¨¡**: ä½¿ç”¨æ•°å­¦è¯­è¨€ç²¾ç¡®æè¿°Webç³»ç»Ÿçš„å„ä¸ªç»„ä»¶
2. **åè®®æ ˆç†è§£**: æ·±å…¥ç†è§£HTTPåè®®æ ˆçš„å±‚æ¬¡ç»“æ„
3. **æ¶æ„æ¨¡å¼**: æŒæ¡MVCã€RESTç­‰é‡è¦çš„æ¶æ„æ¨¡å¼
4. **å®‰å…¨æœºåˆ¶**: å®ç°å®Œå–„çš„è®¤è¯ã€æˆæƒå’Œå®‰å…¨é˜²æŠ¤
5. **æ€§èƒ½ä¼˜åŒ–**: è¿ç”¨ç¼“å­˜ã€å‹ç¼©ç­‰æŠ€æœ¯æå‡æ€§èƒ½

### æœªæ¥å‘å±•æ–¹å‘

1. **WebAssembly**: é«˜æ€§èƒ½çš„Webåº”ç”¨å¼€å‘
2. **PWAæŠ€æœ¯**: æ¸è¿›å¼Webåº”ç”¨
3. **å¾®å‰ç«¯æ¶æ„**: å¤§å‹Webåº”ç”¨çš„æ¨¡å—åŒ–å¼€å‘
4. **GraphQL**: æ›´çµæ´»çš„æ•°æ®æŸ¥è¯¢æ¥å£
5. **Web3æŠ€æœ¯**: å»ä¸­å¿ƒåŒ–Webåº”ç”¨

é€šè¿‡ç³»ç»Ÿæ€§çš„å­¦ä¹ å’Œå®è·µï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºé«˜è´¨é‡ã€é«˜æ€§èƒ½ã€å®‰å…¨å¯é çš„Webåº”ç”¨ç³»ç»Ÿã€‚ 