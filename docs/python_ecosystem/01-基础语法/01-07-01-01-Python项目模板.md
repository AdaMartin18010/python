# Pythoné¡¹ç›®æ¨¡æ¿

## ğŸ“š æ¦‚è¿°

Pythoné¡¹ç›®æ¨¡æ¿æ˜¯è½¯ä»¶å·¥ç¨‹å®è·µçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œæä¾›äº†æ ‡å‡†åŒ–çš„é¡¹ç›®ç»“æ„å’Œæœ€ä½³å®è·µã€‚æœ¬æ–‡æ¡£ä»å®è·µåº”ç”¨çš„è§’åº¦ï¼Œç³»ç»Ÿåœ°ä»‹ç»Pythoné¡¹ç›®æ¨¡æ¿çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦å½¢å¼åŒ–å’Œå®é™…å®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. é¡¹ç›®ç»“æ„çš„å½¢å¼åŒ–å®šä¹‰

#### 1.1 é¡¹ç›®ç»“æ„çš„æ•°å­¦å®šä¹‰

é¡¹ç›®ç»“æ„å¯ä»¥å½¢å¼åŒ–å®šä¹‰ä¸ºæœ‰å‘å›¾ $G = (V, E)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯èŠ‚ç‚¹é›†åˆï¼Œè¡¨ç¤ºé¡¹ç›®ä¸­çš„æ–‡ä»¶å’Œç›®å½•
- $E$ æ˜¯è¾¹é›†åˆï¼Œè¡¨ç¤ºæ–‡ä»¶é—´çš„ä¾èµ–å…³ç³»

æ¯ä¸ªèŠ‚ç‚¹ $v \in V$ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$v = (path, type, metadata)$$

å…¶ä¸­ $path$ æ˜¯æ–‡ä»¶è·¯å¾„ï¼Œ$type$ æ˜¯æ–‡ä»¶ç±»å‹ï¼Œ$metadata$ æ˜¯å…ƒæ•°æ®ã€‚

#### 1.2 é¡¹ç›®ç»“æ„çš„Pythonå®ç°

```python
from typing import Dict, List, Set, Any, Optional, Union
from pathlib import Path
from dataclasses import dataclass, field
from enum import Enum
import json
import yaml
import os

class FileType(Enum):
    """æ–‡ä»¶ç±»å‹æšä¸¾"""
    PYTHON = "python"
    CONFIG = "config"
    DOCUMENTATION = "documentation"
    TEST = "test"
    RESOURCE = "resource"
    BUILD = "build"

class DependencyType(Enum):
    """ä¾èµ–ç±»å‹æšä¸¾"""
    IMPORT = "import"
    INHERITANCE = "inheritance"
    COMPOSITION = "composition"
    CONFIGURATION = "configuration"

@dataclass
class FileMetadata:
    """æ–‡ä»¶å…ƒæ•°æ®"""
    name: str
    type: FileType
    size: int
    created_time: float
    modified_time: float
    dependencies: List[str] = field(default_factory=list)
    properties: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ProjectNode:
    """é¡¹ç›®èŠ‚ç‚¹"""
    path: str
    type: FileType
    metadata: FileMetadata
    children: List['ProjectNode'] = field(default_factory=list)
    parent: Optional['ProjectNode'] = None

class ProjectStructure:
    """é¡¹ç›®ç»“æ„ç®¡ç†å™¨"""
    
    def __init__(self, root_path: str):
        self.root_path = Path(root_path)
        self.nodes: Dict[str, ProjectNode] = {}
        self.dependencies: Dict[str, Set[str]] = {}
    
    def scan_project(self) -> None:
        """æ‰«æé¡¹ç›®ç»“æ„"""
        self._scan_directory(self.root_path, None)
        self._analyze_dependencies()
    
    def _scan_directory(self, path: Path, parent: Optional[ProjectNode]) -> None:
        """é€’å½’æ‰«æç›®å½•"""
        for item in path.iterdir():
            if item.is_file():
                node = self._create_file_node(item, parent)
                self.nodes[str(item)] = node
            elif item.is_dir() and not item.name.startswith('.'):
                # åˆ›å»ºç›®å½•èŠ‚ç‚¹
                dir_node = ProjectNode(
                    path=str(item),
                    type=FileType.RESOURCE,
                    metadata=FileMetadata(
                        name=item.name,
                        type=FileType.RESOURCE,
                        size=0,
                        created_time=item.stat().st_ctime,
                        modified_time=item.stat().st_mtime
                    ),
                    parent=parent
                )
                self.nodes[str(item)] = dir_node
                self._scan_directory(item, dir_node)
    
    def _create_file_node(self, file_path: Path, parent: Optional[ProjectNode]) -> ProjectNode:
        """åˆ›å»ºæ–‡ä»¶èŠ‚ç‚¹"""
        file_type = self._determine_file_type(file_path)
        stat = file_path.stat()
        
        metadata = FileMetadata(
            name=file_path.name,
            type=file_type,
            size=stat.st_size,
            created_time=stat.st_ctime,
            modified_time=stat.st_mtime
        )
        
        return ProjectNode(
            path=str(file_path),
            type=file_type,
            metadata=metadata,
            parent=parent
        )
    
    def _determine_file_type(self, file_path: Path) -> FileType:
        """ç¡®å®šæ–‡ä»¶ç±»å‹"""
        suffix = file_path.suffix.lower()
        
        if suffix == '.py':
            return FileType.PYTHON
        elif suffix in ['.yml', '.yaml', '.json', '.toml', '.ini']:
            return FileType.CONFIG
        elif suffix in ['.md', '.rst', '.txt']:
            return FileType.DOCUMENTATION
        elif 'test' in file_path.name.lower():
            return FileType.TEST
        elif suffix in ['.pyx', '.pxd', '.c', '.cpp']:
            return FileType.BUILD
        else:
            return FileType.RESOURCE
    
    def _analyze_dependencies(self) -> None:
        """åˆ†ææ–‡ä»¶ä¾èµ–å…³ç³»"""
        for node in self.nodes.values():
            if node.type == FileType.PYTHON:
                self._analyze_python_dependencies(node)
    
    def _analyze_python_dependencies(self, node: ProjectNode) -> None:
        """åˆ†æPythonæ–‡ä»¶ä¾èµ–"""
        try:
            with open(node.path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # ç®€å•çš„importåˆ†æ
            import_lines = [line.strip() for line in content.split('\n') 
                           if line.strip().startswith(('import ', 'from '))]
            
            dependencies = []
            for line in import_lines:
                if line.startswith('import '):
                    module = line.split()[1].split('.')[0]
                    dependencies.append(module)
                elif line.startswith('from '):
                    parts = line.split()
                    if len(parts) >= 3:
                        module = parts[1].split('.')[0]
                        dependencies.append(module)
            
            node.metadata.dependencies = dependencies
            self.dependencies[node.path] = set(dependencies)
            
        except Exception as e:
            print(f"Error analyzing dependencies for {node.path}: {e}")
    
    def get_dependency_graph(self) -> Dict[str, Set[str]]:
        """è·å–ä¾èµ–å›¾"""
        return self.dependencies
    
    def find_circular_dependencies(self) -> List[List[str]]:
        """æŸ¥æ‰¾å¾ªç¯ä¾èµ–"""
        def dfs(node: str, visited: Set[str], rec_stack: Set[str], path: List[str]) -> List[List[str]]:
            visited.add(node)
            rec_stack.add(node)
            path.append(node)
            
            cycles = []
            for neighbor in self.dependencies.get(node, set()):
                if neighbor not in visited:
                    cycles.extend(dfs(neighbor, visited, rec_stack, path))
                elif neighbor in rec_stack:
                    # æ‰¾åˆ°å¾ªç¯
                    cycle_start = path.index(neighbor)
                    cycles.append(path[cycle_start:] + [neighbor])
            
            rec_stack.remove(node)
            path.pop()
            return cycles
        
        visited = set()
        all_cycles = []
        
        for node in self.dependencies:
            if node not in visited:
                all_cycles.extend(dfs(node, visited, set(), []))
        
        return all_cycles
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'root_path': str(self.root_path),
            'nodes': {
                path: {
                    'path': node.path,
                    'type': node.type.value,
                    'metadata': {
                        'name': node.metadata.name,
                        'size': node.metadata.size,
                        'dependencies': node.metadata.dependencies,
                        'properties': node.metadata.properties
                    }
                }
                for path, node in self.nodes.items()
            },
            'dependencies': {
                path: list(deps) for path, deps in self.dependencies.items()
            }
        }

# ä½¿ç”¨ç¤ºä¾‹
project_structure = ProjectStructure(".")
project_structure.scan_project()

# è·å–é¡¹ç›®ç»“æ„ä¿¡æ¯
project_info = project_structure.to_dict()
print(f"é¡¹ç›®åŒ…å« {len(project_info['nodes'])} ä¸ªæ–‡ä»¶/ç›®å½•")

# æŸ¥æ‰¾å¾ªç¯ä¾èµ–
cycles = project_structure.find_circular_dependencies()
if cycles:
    print(f"å‘ç° {len(cycles)} ä¸ªå¾ªç¯ä¾èµ–:")
    for cycle in cycles:
        print(f"  {' -> '.join(cycle)}")
else:
    print("æœªå‘ç°å¾ªç¯ä¾èµ–")
```

### 2. æ ‡å‡†é¡¹ç›®æ¨¡æ¿

#### 2.1 åŸºç¡€é¡¹ç›®æ¨¡æ¿

```python
class ProjectTemplate:
    """é¡¹ç›®æ¨¡æ¿åŸºç±»"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.structure: Dict[str, Any] = {}
        self.files: Dict[str, str] = {}
        self.config: Dict[str, Any] = {}
    
    def add_file(self, path: str, content: str):
        """æ·»åŠ æ–‡ä»¶"""
        self.files[path] = content
    
    def add_directory(self, path: str):
        """æ·»åŠ ç›®å½•"""
        self.structure[path] = {"type": "directory"}
    
    def set_config(self, key: str, value: Any):
        """è®¾ç½®é…ç½®"""
        self.config[key] = value
    
    def generate_project(self, target_path: str, project_name: str) -> None:
        """ç”Ÿæˆé¡¹ç›®"""
        target_dir = Path(target_path) / project_name
        target_dir.mkdir(parents=True, exist_ok=True)
        
        # åˆ›å»ºç›®å½•ç»“æ„
        for path, info in self.structure.items():
            if info["type"] == "directory":
                (target_dir / path).mkdir(parents=True, exist_ok=True)
        
        # åˆ›å»ºæ–‡ä»¶
        for file_path, content in self.files.items():
            full_path = target_dir / file_path
            full_path.parent.mkdir(parents=True, exist_ok=True)
            
            # æ›¿æ¢æ¨¡æ¿å˜é‡
            processed_content = self._process_template(content, project_name)
            
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(processed_content)
        
        # åˆ›å»ºé…ç½®æ–‡ä»¶
        self._create_config_files(target_dir, project_name)
    
    def _process_template(self, content: str, project_name: str) -> str:
        """å¤„ç†æ¨¡æ¿å˜é‡"""
        replacements = {
            "{{PROJECT_NAME}}": project_name,
            "{{PROJECT_NAME_UPPER}}": project_name.upper(),
            "{{PROJECT_NAME_LOWER}}": project_name.lower(),
            "{{DESCRIPTION}}": self.description,
            "{{AUTHOR}}": self.config.get("author", "Unknown"),
            "{{VERSION}}": self.config.get("version", "0.1.0"),
            "{{LICENSE}}": self.config.get("license", "MIT"),
        }
        
        for placeholder, value in replacements.items():
            content = content.replace(placeholder, str(value))
        
        return content
    
    def _create_config_files(self, target_dir: Path, project_name: str):
        """åˆ›å»ºé…ç½®æ–‡ä»¶"""
        # setup.py
        setup_py_content = f'''from setuptools import setup, find_packages

setup(
    name="{project_name.lower()}",
    version="{self.config.get('version', '0.1.0')}",
    description="{self.description}",
    author="{self.config.get('author', 'Unknown')}",
    packages=find_packages(),
    install_requires={self.config.get('dependencies', [])},
    python_requires=">=3.8",
)
'''
        with open(target_dir / "setup.py", 'w') as f:
            f.write(setup_py_content)
        
        # requirements.txt
        requirements = self.config.get('dependencies', [])
        with open(target_dir / "requirements.txt", 'w') as f:
            f.write('\n'.join(requirements))
        
        # README.md
        readme_content = f'''# {project_name}

{self.description}

## Installation

```bash
pip install -r requirements.txt
```

## Usage

```python
from {project_name.lower()} import main

main()
```

## License

{self.config.get('license', 'MIT')}
'''
        with open(target_dir / "README.md", 'w') as f:
            f.write(readme_content)

class BasicPythonTemplate(ProjectTemplate):
    """åŸºç¡€Pythoné¡¹ç›®æ¨¡æ¿"""

    def __init__(self):
        super().__init__(
            name="Basic Python Project",
            description="A basic Python project template with standard structure"
        )
        
        self._setup_structure()
        self._setup_files()
        self._setup_config()
    
    def _setup_structure(self):
        """è®¾ç½®ç›®å½•ç»“æ„"""
        directories = [
            "src",
            "tests",
            "docs",
            "scripts",
            "data",
            "config"
        ]
        
        for directory in directories:
            self.add_directory(directory)
    
    def _setup_files(self):
        """è®¾ç½®æ–‡ä»¶"""
        # ä¸»æ¨¡å—
        self.add_file("src/__init__.py", "")
        
        main_py_content = '''"""
{{PROJECT_NAME}}

{{DESCRIPTION}}
"""

def main():
    """Main function"""
    print("Hello from {{PROJECT_NAME}}!")

if __name__ == "__main__":
    main()
'''
        self.add_file("src/main.py", main_py_content)

        # æµ‹è¯•æ–‡ä»¶
        test_content = '''"""
Tests for {{PROJECT_NAME}}
"""

import unittest
from src.main import main

class TestMain(unittest.TestCase):
    def test_main(self):
        """Test main function"""
        # Add your tests here
        self.assertTrue(True)

if __name__ == "__main__":
    unittest.main()
'''
        self.add_file("tests/test_main.py", test_content)
        self.add_file("tests/__init__.py", "")

        # é…ç½®æ–‡ä»¶
        config_content = '''# {{PROJECT_NAME}} Configuration

[default]
debug = false
log_level = INFO
'''
        self.add_file("config/config.ini", config_content)

        # è„šæœ¬æ–‡ä»¶
        script_content = '''#!/usr/bin/env python3
"""
Utility script for {{PROJECT_NAME}}
"""

import sys
import os

def main():
    """Script main function"""
    print("Running {{PROJECT_NAME}} utility script")

if __name__ == "__main__":
    main()
'''
        self.add_file("scripts/run.py", script_content)

    def _setup_config(self):
        """è®¾ç½®é…ç½®"""
        self.set_config("author", "Your Name")
        self.set_config("version", "0.1.0")
        self.set_config("license", "MIT")
        self.set_config("dependencies", [
            "pytest>=6.0",
            "black>=21.0",
            "flake8>=3.8"
        ])

# ä½¿ç”¨ç¤ºä¾‹

template = BasicPythonTemplate()
template.generate_project(".", "my_project")
print("åŸºç¡€Pythoné¡¹ç›®æ¨¡æ¿å·²ç”Ÿæˆ")

```

#### 2.2 é«˜çº§é¡¹ç›®æ¨¡æ¿

```python
class WebAPITemplate(ProjectTemplate):
    """Web APIé¡¹ç›®æ¨¡æ¿"""
    
    def __init__(self):
        super().__init__(
            name="Web API Project",
            description="A FastAPI-based web API project template"
        )
        
        self._setup_structure()
        self._setup_files()
        self._setup_config()
    
    def _setup_structure(self):
        """è®¾ç½®ç›®å½•ç»“æ„"""
        directories = [
            "app",
            "app/api",
            "app/core",
            "app/models",
            "app/schemas",
            "app/services",
            "tests",
            "docs",
            "migrations",
            "scripts"
        ]
        
        for directory in directories:
            self.add_directory(directory)
    
    def _setup_files(self):
        """è®¾ç½®æ–‡ä»¶"""
        # ä¸»åº”ç”¨æ–‡ä»¶
        main_app_content = '''"""
{{PROJECT_NAME}} - FastAPI Application
"""

from fastapi import FastAPI
from app.api.routes import router
from app.core.config import settings

app = FastAPI(
    title="{{PROJECT_NAME}}",
    description="{{DESCRIPTION}}",
    version="{{VERSION}}"
)

app.include_router(router, prefix="/api/v1")

@app.get("/")
async def root():
    return {"message": "Welcome to {{PROJECT_NAME}}!"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
'''
        self.add_file("app/main.py", main_app_content)
        self.add_file("app/__init__.py", "")
        
        # é…ç½®æ–‡ä»¶
        config_content = '''"""
Configuration settings for {{PROJECT_NAME}}
"""

from pydantic import BaseSettings

class Settings(BaseSettings):
    app_name: str = "{{PROJECT_NAME}}"
    debug: bool = False
    database_url: str = "sqlite:///./app.db"
    secret_key: str = "your-secret-key"
    
    class Config:
        env_file = ".env"

settings = Settings()
'''
        self.add_file("app/core/config.py", config_content)
        self.add_file("app/core/__init__.py", "")
        
        # è·¯ç”±æ–‡ä»¶
        routes_content = '''"""
API routes for {{PROJECT_NAME}}
"""

from fastapi import APIRouter
from app.schemas.item import Item, ItemCreate
from app.services.item_service import ItemService

router = APIRouter()
item_service = ItemService()

@router.get("/items/", response_model=list[Item])
async def get_items():
    return item_service.get_all()

@router.post("/items/", response_model=Item)
async def create_item(item: ItemCreate):
    return item_service.create(item)

@router.get("/items/{item_id}", response_model=Item)
async def get_item(item_id: int):
    return item_service.get_by_id(item_id)
'''
        self.add_file("app/api/routes.py", routes_content)
        self.add_file("app/api/__init__.py", "")
        
        # æ•°æ®æ¨¡å‹
        models_content = '''"""
Database models for {{PROJECT_NAME}}
"""

from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class Item(Base):
    __tablename__ = "items"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
'''
        self.add_file("app/models/item.py", models_content)
        self.add_file("app/models/__init__.py", "")
        
        # Pydanticæ¨¡å¼
        schemas_content = '''"""
Pydantic schemas for {{PROJECT_NAME}}
"""

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class ItemBase(BaseModel):
    title: str
    description: Optional[str] = None

class ItemCreate(ItemBase):
    pass

class Item(ItemBase):
    id: int
    created_at: datetime
    
    class Config:
        orm_mode = True
'''
        self.add_file("app/schemas/item.py", schemas_content)
        self.add_file("app/schemas/__init__.py", "")
        
        # æœåŠ¡å±‚
        service_content = '''"""
Service layer for {{PROJECT_NAME}}
"""

from app.models.item import Item
from app.schemas.item import ItemCreate
from typing import List

class ItemService:
    def __init__(self):
        self.items = []
        self.counter = 1
    
    def get_all(self) -> List[Item]:
        return self.items
    
    def get_by_id(self, item_id: int) -> Item:
        for item in self.items:
            if item.id == item_id:
                return item
        raise ValueError(f"Item with id {item_id} not found")
    
    def create(self, item: ItemCreate) -> Item:
        new_item = Item(
            id=self.counter,
            title=item.title,
            description=item.description
        )
        self.items.append(new_item)
        self.counter += 1
        return new_item
'''
        self.add_file("app/services/item_service.py", service_content)
        self.add_file("app/services/__init__.py", "")
        
        # æµ‹è¯•æ–‡ä»¶
        test_content = '''"""
Tests for {{PROJECT_NAME}}
"""

import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()

def test_health_check():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json()["status"] == "healthy"
'''
        self.add_file("tests/test_api.py", test_content)
        
        # Dockeræ–‡ä»¶
        dockerfile_content = '''FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
        self.add_file("Dockerfile", dockerfile_content)
        
        # docker-composeæ–‡ä»¶
        compose_content = '''version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DEBUG=false
    volumes:
      - .:/app
'''
        self.add_file("docker-compose.yml", compose_content)
    
    def _setup_config(self):
        """è®¾ç½®é…ç½®"""
        self.set_config("author", "Your Name")
        self.set_config("version", "0.1.0")
        self.set_config("license", "MIT")
        self.set_config("dependencies", [
            "fastapi>=0.68.0",
            "uvicorn>=0.15.0",
            "sqlalchemy>=1.4.0",
            "pydantic>=1.8.0",
            "pytest>=6.0",
            "httpx>=0.19.0"
        ])

class DataScienceTemplate(ProjectTemplate):
    """æ•°æ®ç§‘å­¦é¡¹ç›®æ¨¡æ¿"""
    
    def __init__(self):
        super().__init__(
            name="Data Science Project",
            description="A comprehensive data science project template"
        )
        
        self._setup_structure()
        self._setup_files()
        self._setup_config()
    
    def _setup_structure(self):
        """è®¾ç½®ç›®å½•ç»“æ„"""
        directories = [
            "data",
            "data/raw",
            "data/processed",
            "data/external",
            "notebooks",
            "src",
            "src/data",
            "src/features",
            "src/models",
            "src/visualization",
            "models",
            "reports",
            "reports/figures",
            "tests"
        ]
        
        for directory in directories:
            self.add_directory(directory)
    
    def _setup_files(self):
        """è®¾ç½®æ–‡ä»¶"""
        # ä¸»é…ç½®æ–‡ä»¶
        config_content = '''"""
Configuration for {{PROJECT_NAME}}
"""

import os
from pathlib import Path

# Project paths
PROJECT_ROOT = Path(__file__).parent.parent
DATA_DIR = PROJECT_ROOT / "data"
RAW_DATA_DIR = DATA_DIR / "raw"
PROCESSED_DATA_DIR = DATA_DIR / "processed"
MODELS_DIR = PROJECT_ROOT / "models"
REPORTS_DIR = PROJECT_ROOT / "reports"

# Data parameters
RANDOM_SEED = 42
TEST_SIZE = 0.2
VALIDATION_SIZE = 0.2

# Model parameters
MODEL_PARAMS = {
    "random_forest": {
        "n_estimators": 100,
        "max_depth": 10,
        "random_state": RANDOM_SEED
    }
}
'''
        self.add_file("src/config.py", config_content)
        
        # æ•°æ®å¤„ç†æ¨¡å—
        data_processing_content = '''"""
Data processing utilities for {{PROJECT_NAME}}
"""

import pandas as pd
import numpy as np
from pathlib import Path
from typing import Tuple
from sklearn.model_selection import train_test_split

def load_data(file_path: Path) -> pd.DataFrame:
    """Load data from file"""
    if file_path.suffix == '.csv':
        return pd.read_csv(file_path)
    elif file_path.suffix == '.parquet':
        return pd.read_parquet(file_path)
    else:
        raise ValueError(f"Unsupported file format: {file_path.suffix}")

def split_data(data: pd.DataFrame, target_col: str, 
               test_size: float = 0.2, val_size: float = 0.2) -> Tuple:
    """Split data into train, validation, and test sets"""
    # First split: train+val and test
    train_val, test = train_test_split(
        data, test_size=test_size, random_state=42, stratify=data[target_col]
    )
    
    # Second split: train and validation
    train, val = train_test_split(
        train_val, test_size=val_size, random_state=42, stratify=train_val[target_col]
    )
    
    return train, val, test

def preprocess_data(data: pd.DataFrame) -> pd.DataFrame:
    """Preprocess the data"""
    # Add your preprocessing steps here
    processed_data = data.copy()
    
    # Handle missing values
    processed_data = processed_data.fillna(processed_data.mean())
    
    # Encode categorical variables
    categorical_cols = processed_data.select_dtypes(include=['object']).columns
    for col in categorical_cols:
        processed_data[col] = processed_data[col].astype('category').cat.codes
    
    return processed_data
'''
        self.add_file("src/data/data_processing.py", data_processing_content)
        
        # ç‰¹å¾å·¥ç¨‹æ¨¡å—
        feature_engineering_content = '''"""
Feature engineering for {{PROJECT_NAME}}
"""

import pandas as pd
import numpy as np
from sklearn.feature_selection import SelectKBest, f_classif
from sklearn.preprocessing import StandardScaler
from typing import List, Tuple

class FeatureEngineer:
    def __init__(self):
        self.scaler = StandardScaler()
        self.feature_selector = None
        self.selected_features = None
    
    def create_features(self, data: pd.DataFrame) -> pd.DataFrame:
        """Create new features"""
        df = data.copy()
        
        # Add your feature engineering logic here
        # Example: create interaction features
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        for i, col1 in enumerate(numeric_cols):
            for col2 in numeric_cols[i+1:]:
                df[f'{col1}_{col2}_interaction'] = df[col1] * df[col2]
        
        return df
    
    def select_features(self, X: pd.DataFrame, y: pd.Series, 
                       k: int = 10) -> pd.DataFrame:
        """Select top k features"""
        self.feature_selector = SelectKBest(score_func=f_classif, k=k)
        X_selected = self.feature_selector.fit_transform(X, y)
        self.selected_features = X.columns[self.feature_selector.get_support()]
        
        return pd.DataFrame(X_selected, columns=self.selected_features)
    
    def scale_features(self, X: pd.DataFrame) -> pd.DataFrame:
        """Scale features"""
        X_scaled = self.scaler.fit_transform(X)
        return pd.DataFrame(X_scaled, columns=X.columns)
'''
        self.add_file("src/features/feature_engineering.py", feature_engineering_content)
        
        # æ¨¡å‹è®­ç»ƒæ¨¡å—
        model_training_content = '''"""
Model training for {{PROJECT_NAME}}
"""

import joblib
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import GridSearchCV
from pathlib import Path
from typing import Dict, Any

class ModelTrainer:
    def __init__(self, model_params: Dict[str, Any]):
        self.model_params = model_params
        self.model = None
        self.best_params = None
    
    def train_model(self, X_train: pd.DataFrame, y_train: pd.Series,
                   X_val: pd.DataFrame, y_val: pd.Series) -> Dict[str, Any]:
        """Train the model"""
        # Initialize model
        self.model = RandomForestClassifier(**self.model_params)
        
        # Hyperparameter tuning
        param_grid = {
            'n_estimators': [50, 100, 200],
            'max_depth': [5, 10, 15, None],
            'min_samples_split': [2, 5, 10]
        }
        
        grid_search = GridSearchCV(
            self.model, param_grid, cv=5, scoring='accuracy', n_jobs=-1
        )
        grid_search.fit(X_train, y_train)
        
        self.model = grid_search.best_estimator_
        self.best_params = grid_search.best_params_
        
        # Evaluate on validation set
        y_val_pred = self.model.predict(X_val)
        val_report = classification_report(y_val, y_val_pred, output_dict=True)
        
        return {
            'best_params': self.best_params,
            'validation_accuracy': val_report['accuracy'],
            'validation_report': val_report
        }
    
    def save_model(self, model_path: Path):
        """Save the trained model"""
        joblib.dump(self.model, model_path)
    
    def load_model(self, model_path: Path):
        """Load a trained model"""
        self.model = joblib.load(model_path)
'''
        self.add_file("src/models/model_training.py", model_training_content)
        
        # å¯è§†åŒ–æ¨¡å—
        visualization_content = '''"""
Visualization utilities for {{PROJECT_NAME}}
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from pathlib import Path
from typing import List

class Visualizer:
    def __init__(self, style: str = 'seaborn'):
        plt.style.use(style)
        self.colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']
    
    def plot_feature_importance(self, feature_importance: pd.Series, 
                               top_n: int = 10, save_path: Path = None):
        """Plot feature importance"""
        plt.figure(figsize=(10, 6))
        top_features = feature_importance.head(top_n)
        
        plt.barh(range(len(top_features)), top_features.values)
        plt.yticks(range(len(top_features)), top_features.index)
        plt.xlabel('Feature Importance')
        plt.title(f'Top {top_n} Feature Importance')
        plt.gca().invert_yaxis()
        
        if save_path:
            plt.savefig(save_path, bbox_inches='tight', dpi=300)
        plt.show()
    
    def plot_confusion_matrix(self, y_true: np.ndarray, y_pred: np.ndarray,
                             save_path: Path = None):
        """Plot confusion matrix"""
        plt.figure(figsize=(8, 6))
        cm = confusion_matrix(y_true, y_pred)
        
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
        plt.title('Confusion Matrix')
        plt.ylabel('True Label')
        plt.xlabel('Predicted Label')
        
        if save_path:
            plt.savefig(save_path, bbox_inches='tight', dpi=300)
        plt.show()
    
    def plot_training_history(self, history: Dict[str, List[float]],
                             save_path: Path = None):
        """Plot training history"""
        plt.figure(figsize=(12, 4))
        
        plt.subplot(1, 2, 1)
        plt.plot(history['train_loss'], label='Train Loss')
        plt.plot(history['val_loss'], label='Validation Loss')
        plt.title('Loss History')
        plt.xlabel('Epoch')
        plt.ylabel('Loss')
        plt.legend()
        
        plt.subplot(1, 2, 2)
        plt.plot(history['train_acc'], label='Train Accuracy')
        plt.plot(history['val_acc'], label='Validation Accuracy')
        plt.title('Accuracy History')
        plt.xlabel('Epoch')
        plt.ylabel('Accuracy')
        plt.legend()
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, bbox_inches='tight', dpi=300)
        plt.show()
'''
        self.add_file("src/visualization/visualizer.py", visualization_content)
        
        # Jupyter notebookæ¨¡æ¿
        notebook_content = '''{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# {{PROJECT_NAME}}\\n",
    "\\n",
    "{{DESCRIPTION}}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\\n",
    "import numpy as np\\n",
    "import matplotlib.pyplot as plt\\n",
    "import seaborn as sns\\n",
    "\\n",
    "# Set up paths\\n",
    "import sys\\n",
    "sys.path.append('../src')\\n",
    "\\n",
    "from config import *\\n",
    "from data.data_processing import load_data, preprocess_data\\n",
    "from features.feature_engineering import FeatureEngineer\\n",
    "from models.model_training import ModelTrainer\\n",
    "from visualization.visualizer import Visualizer"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Data Loading and Exploration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load data\\n",
    "# data = load_data(RAW_DATA_DIR / 'your_data.csv')\\n",
    "# print(f'Data shape: {data.shape}')\\n",
    "# data.head()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}'''
        self.add_file("notebooks/01_data_exploration.ipynb", notebook_content)
    
    def _setup_config(self):
        """è®¾ç½®é…ç½®"""
        self.set_config("author", "Your Name")
        self.set_config("version", "0.1.0")
        self.set_config("license", "MIT")
        self.set_config("dependencies", [
            "pandas>=1.3.0",
            "numpy>=1.21.0",
            "scikit-learn>=1.0.0",
            "matplotlib>=3.4.0",
            "seaborn>=0.11.0",
            "jupyter>=1.0.0",
            "notebook>=6.4.0",
            "joblib>=1.1.0"
        ])

# ä½¿ç”¨ç¤ºä¾‹
web_api_template = WebAPITemplate()
web_api_template.generate_project(".", "my_web_api")

data_science_template = DataScienceTemplate()
data_science_template.generate_project(".", "my_data_science_project")

print("é«˜çº§é¡¹ç›®æ¨¡æ¿å·²ç”Ÿæˆ")
```

### 3. é¡¹ç›®ç”Ÿæˆå™¨

```python
class ProjectGenerator:
    """é¡¹ç›®ç”Ÿæˆå™¨"""
    
    def __init__(self):
        self.templates = {
            "basic": BasicPythonTemplate,
            "web-api": WebAPITemplate,
            "data-science": DataScienceTemplate
        }
    
    def list_templates(self) -> List[str]:
        """åˆ—å‡ºå¯ç”¨æ¨¡æ¿"""
        return list(self.templates.keys())
    
    def create_project(self, template_name: str, project_name: str, 
                      target_path: str = ".") -> None:
        """åˆ›å»ºé¡¹ç›®"""
        if template_name not in self.templates:
            raise ValueError(f"Unknown template: {template_name}")
        
        template_class = self.templates[template_name]
        template = template_class()
        template.generate_project(target_path, project_name)
        
        print(f"é¡¹ç›® '{project_name}' å·²ä½¿ç”¨æ¨¡æ¿ '{template_name}' åˆ›å»ºåœ¨ '{target_path}'")
    
    def create_custom_project(self, project_name: str, target_path: str = ".",
                             template_config: Dict[str, Any] = None) -> None:
        """åˆ›å»ºè‡ªå®šä¹‰é¡¹ç›®"""
        template = ProjectTemplate(
            name=project_name,
            description=template_config.get("description", "Custom Python project")
        )
        
        # åº”ç”¨è‡ªå®šä¹‰é…ç½®
        if template_config:
            for key, value in template_config.items():
                if key == "files":
                    for file_path, content in value.items():
                        template.add_file(file_path, content)
                elif key == "directories":
                    for directory in value:
                        template.add_directory(directory)
                else:
                    template.set_config(key, value)
        
        template.generate_project(target_path, project_name)
        print(f"è‡ªå®šä¹‰é¡¹ç›® '{project_name}' å·²åˆ›å»ºåœ¨ '{target_path}'")

# ä½¿ç”¨ç¤ºä¾‹
generator = ProjectGenerator()

# åˆ—å‡ºå¯ç”¨æ¨¡æ¿
print("å¯ç”¨æ¨¡æ¿:")
for template in generator.list_templates():
    print(f"  - {template}")

# åˆ›å»ºWeb APIé¡¹ç›®
generator.create_project("web-api", "my_fastapi_app")

# åˆ›å»ºè‡ªå®šä¹‰é¡¹ç›®
custom_config = {
    "description": "A custom machine learning project",
    "directories": ["ml_models", "data", "scripts"],
    "files": {
        "src/ml_utils.py": '''
"""
Machine learning utilities
"""

import numpy as np
import pandas as pd

def preprocess_data(data):
    """Preprocess data"""
    return data
''',
        "requirements.txt": "numpy\npandas\nscikit-learn\nmatplotlib"
    },
    "author": "ML Engineer",
    "version": "1.0.0"
}

generator.create_custom_project("ml_project", template_config=custom_config)
```

## ğŸ”¬ æ•°å­¦è¯æ˜

### 1. é¡¹ç›®ç»“æ„å¤æ‚åº¦å®šç†

__å®šç†__: å¯¹äºåŒ…å« $n$ ä¸ªæ–‡ä»¶çš„é¡¹ç›®ï¼Œæœ€å¤§ä¾èµ–å…³ç³»æ•°ä¸º $O(n^2)$ã€‚

__è¯æ˜__: æ¯ä¸ªæ–‡ä»¶æœ€å¤šå¯ä»¥ä¾èµ– $n-1$ ä¸ªå…¶ä»–æ–‡ä»¶ï¼Œå› æ­¤æ€»ä¾èµ–å…³ç³»æ•°æœ€å¤šä¸º $n(n-1)/2 = O(n^2)$ã€‚

### 2. æ¨¡æ¿ç”Ÿæˆæ•ˆç‡å®šç†

__å®šç†__: ä½¿ç”¨æ¨¡æ¿ç”Ÿæˆé¡¹ç›®çš„å¤æ‚åº¦ä¸º $O(f + d)$ï¼Œå…¶ä¸­ $f$ æ˜¯æ–‡ä»¶æ•°ï¼Œ$d$ æ˜¯ç›®å½•æ•°ã€‚

__è¯æ˜__: æ¯ä¸ªæ–‡ä»¶å’Œç›®å½•åªéœ€è¦ä¸€æ¬¡æ“ä½œå³å¯åˆ›å»ºï¼Œå› æ­¤æ€»å¤æ‚åº¦ä¸º $O(f + d)$ã€‚

## ğŸ“Š åº”ç”¨å®ä¾‹

### 1. æ‰¹é‡é¡¹ç›®ç”Ÿæˆ

```python
class BatchProjectGenerator:
    """æ‰¹é‡é¡¹ç›®ç”Ÿæˆå™¨"""
    
    def __init__(self, generator: ProjectGenerator):
        self.generator = generator
    
    def generate_multiple_projects(self, projects_config: List[Dict[str, Any]]) -> None:
        """æ‰¹é‡ç”Ÿæˆå¤šä¸ªé¡¹ç›®"""
        for config in projects_config:
            template_name = config.get("template", "basic")
            project_name = config["name"]
            target_path = config.get("path", ".")
            
            try:
                self.generator.create_project(template_name, project_name, target_path)
                print(f"âœ“ æˆåŠŸåˆ›å»ºé¡¹ç›®: {project_name}")
            except Exception as e:
                print(f"âœ— åˆ›å»ºé¡¹ç›®å¤±è´¥ {project_name}: {e}")
    
    def generate_project_suite(self, suite_name: str, 
                              projects: List[str]) -> None:
        """ç”Ÿæˆé¡¹ç›®å¥—ä»¶"""
        suite_path = Path(suite_name)
        suite_path.mkdir(exist_ok=True)
        
        for project_name in projects:
            project_path = suite_path / project_name
            self.generator.create_project("basic", project_name, str(suite_path))
        
        # åˆ›å»ºå¥—ä»¶é…ç½®æ–‡ä»¶
        suite_config = {
            "suite_name": suite_name,
            "projects": projects,
            "created_at": str(datetime.now())
        }
        
        with open(suite_path / "suite_config.json", 'w') as f:
            json.dump(suite_config, f, indent=2)
        
        print(f"é¡¹ç›®å¥—ä»¶ '{suite_name}' å·²åˆ›å»ºï¼ŒåŒ…å« {len(projects)} ä¸ªé¡¹ç›®")

# ä½¿ç”¨ç¤ºä¾‹
batch_generator = BatchProjectGenerator(generator)

# æ‰¹é‡ç”Ÿæˆé¡¹ç›®
projects_config = [
    {"name": "user_service", "template": "web-api"},
    {"name": "data_processor", "template": "data-science"},
    {"name": "utils_library", "template": "basic"}
]

batch_generator.generate_multiple_projects(projects_config)

# ç”Ÿæˆé¡¹ç›®å¥—ä»¶
project_suite = ["auth_service", "payment_service", "notification_service"]
batch_generator.generate_project_suite("microservices_suite", project_suite)
```

### 2. é¡¹ç›®æ¨¡æ¿éªŒè¯

```python
class TemplateValidator:
    """æ¨¡æ¿éªŒè¯å™¨"""
    
    def __init__(self):
        self.validation_rules = {
            "required_files": ["README.md", "requirements.txt"],
            "required_directories": ["src", "tests"],
            "forbidden_patterns": [r"\.pyc$", r"__pycache__", r"\.DS_Store"],
            "naming_conventions": {
                "python_files": r"^[a-z_][a-z0-9_]*\.py$",
                "directories": r"^[a-z_][a-z0-9_]*$"
            }
        }
    
    def validate_template(self, template: ProjectTemplate) -> Dict[str, List[str]]:
        """éªŒè¯æ¨¡æ¿"""
        errors = []
        warnings = []
        
        # æ£€æŸ¥å¿…éœ€æ–‡ä»¶
        template_files = set(template.files.keys())
        for required_file in self.validation_rules["required_files"]:
            if not any(required_file in f for f in template_files):
                errors.append(f"ç¼ºå°‘å¿…éœ€æ–‡ä»¶: {required_file}")
        
        # æ£€æŸ¥å¿…éœ€ç›®å½•
        template_dirs = set(template.structure.keys())
        for required_dir in self.validation_rules["required_directories"]:
            if required_dir not in template_dirs:
                warnings.append(f"å»ºè®®æ·»åŠ ç›®å½•: {required_dir}")
        
        # æ£€æŸ¥å‘½åè§„èŒƒ
        import re
        for file_path in template_files:
            if file_path.endswith('.py'):
                filename = Path(file_path).name
                if not re.match(self.validation_rules["naming_conventions"]["python_files"], filename):
                    warnings.append(f"Pythonæ–‡ä»¶å‘½åä¸è§„èŒƒ: {filename}")
        
        return {"errors": errors, "warnings": warnings}
    
    def validate_generated_project(self, project_path: str) -> Dict[str, List[str]]:
        """éªŒè¯ç”Ÿæˆçš„é¡¹ç›®"""
        project_path = Path(project_path)
        errors = []
        warnings = []
        
        if not project_path.exists():
            errors.append(f"é¡¹ç›®è·¯å¾„ä¸å­˜åœ¨: {project_path}")
            return {"errors": errors, "warnings": warnings}
        
        # æ£€æŸ¥é¡¹ç›®ç»“æ„
        for item in project_path.rglob("*"):
            if item.is_file():
                # æ£€æŸ¥æ–‡ä»¶å¤§å°
                if item.stat().st_size == 0:
                    warnings.append(f"ç©ºæ–‡ä»¶: {item}")
                
                # æ£€æŸ¥æ–‡ä»¶æƒé™
                if not os.access(item, os.R_OK):
                    errors.append(f"æ–‡ä»¶ä¸å¯è¯»: {item}")
        
        return {"errors": errors, "warnings": warnings}

# ä½¿ç”¨ç¤ºä¾‹
validator = TemplateValidator()

# éªŒè¯æ¨¡æ¿
basic_template = BasicPythonTemplate()
validation_result = validator.validate_template(basic_template)

print("æ¨¡æ¿éªŒè¯ç»“æœ:")
if validation_result["errors"]:
    print("é”™è¯¯:")
    for error in validation_result["errors"]:
        print(f"  - {error}")

if validation_result["warnings"]:
    print("è­¦å‘Š:")
    for warning in validation_result["warnings"]:
        print(f"  - {warning}")

# éªŒè¯ç”Ÿæˆçš„é¡¹ç›®
project_validation = validator.validate_generated_project("my_project")
print(f"é¡¹ç›®éªŒè¯ç»“æœ: {project_validation}")
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [å®è·µåº”ç”¨æ¦‚è¿°](../README.md)
- [æœ€ä½³å®è·µ](07-02-æœ€ä½³å®è·µ/README.md)
- [æ€§èƒ½ä¼˜åŒ–](07-03-æ€§èƒ½ä¼˜åŒ–/README.md)
- [ç»„ä»¶ç®—æ³•](../06-ç»„ä»¶ç®—æ³•/README.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Python Packaging Authority. (2021). Python Packaging User Guide. <https://packaging.python.org/>
2. FastAPI. (2021). FastAPI Documentation. <https://fastapi.tiangolo.com/>
3. Jupyter Project. (2021). Jupyter Documentation. <https://jupyter.org/documentation>

---

*æœ¬æ–‡æ¡£æ˜¯Pythonç¼–ç¨‹è¯­è¨€çŸ¥è¯†ä½“ç³»é‡æ„é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œéµå¾ªä¸¥æ ¼çš„æ•°å­¦å½¢å¼åŒ–å’ŒPythonå®ç°æ ‡å‡†ã€‚*
