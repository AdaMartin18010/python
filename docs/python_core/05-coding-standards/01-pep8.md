# PEP 8 - Python 代码风格指南

**Python 代码风格的官方规范 | 2025 更新版**-

---

## 📖 简介

PEP 8 是 Python 的官方代码风格指南，定义了编写可读、一致的 Python 代码的规范。

### 核心理念

> "代码被阅读的次数远多于被编写的次数。"  
> —— Guido van Rossum

**一致性原则**：

- 项目内保持一致最重要
- 模块内保持一致次之
- 函数内保持一致也很重要

---

## 🎨 代码布局

### 1. 缩进

```python
# ✅ 使用 4 个空格缩进
def long_function_name(
    var_one: str,
    var_two: int,
    var_three: list[str],
) -> None:
    print(var_one)

# ❌ 不要使用 tab
def bad_function():
 print("wrong")  # tab 缩进
```

### 2. 行长度

```python
# ✅ 每行最多 79 字符（代码）
# ✅ 每行最多 72 字符（文档字符串/注释）

# 推荐：使用括号进行隐式续行
result = some_function_that_takes_arguments(
    "argument1",
    "argument2",
    "argument3",
)

# 可选：使用反斜杠（不推荐）
result = some_function_that_takes_arguments \
    ("argument1", "argument2")
```

### 3. 空行

```python
# ✅ 顶级定义之间空 2 行
class MyClass:
    pass


def my_function() -> None:
    pass


# ✅ 类方法定义之间空 1 行
class MyClass:
    def first_method(self) -> None:
        pass

    def second_method(self) -> None:
        pass


# ✅ 函数内逻辑块之间空 1 行
def complex_function() -> None:
    # 初始化
    x = 1
    y = 2
    
    # 处理
    result = x + y
    
    # 返回
    return result
```

### 4. 导入

```python
# ✅ 分组导入，按顺序：标准库、第三方库、本地库
import os
import sys

import numpy as np
import pandas as pd

from mypackage import mymodule
from mypackage.subpackage import another


# ✅ 每行一个导入
from typing import (
    Any,
    Dict,
    List,
    Optional,
)

# ❌ 避免星号导入
from module import *  # 不推荐

# ✅ 使用显式导入
from module import specific_function, specific_class
```

---

## 📝 命名约定

### 1. 基本规则

```python
# ✅ 模块名：lowercase_with_underscores
# my_module.py

# ✅ 类名：CapWords (PascalCase)
class UserAccount:
    pass

class HTTPServer:
    pass

# ✅ 函数名：lowercase_with_underscores
def calculate_total() -> int:
    return 100

# ✅ 变量名：lowercase_with_underscores
user_count = 10
max_retries = 3

# ✅ 常量：UPPERCASE_WITH_UNDERSCORES
MAX_BUFFER_SIZE = 1024
DEFAULT_TIMEOUT = 30

# ✅ 私有成员：_leading_underscore
class MyClass:
    def __init__(self) -> None:
        self._private_var = 1
    
    def _private_method(self) -> None:
        pass

# ✅ 魔术方法：__double_leading_and_trailing__
def __init__(self) -> None:
    pass
```

### 2. 命名案例

```python
# ✅ 好的命名
def calculate_user_age(birth_year: int) -> int:
    from datetime import datetime
    return datetime.now().year - birth_year

class DatabaseConnection:
    def __init__(self, host: str, port: int) -> None:
        self.host = host
        self.port = port
    
    def connect(self) -> None:
        pass

# ❌ 避免的命名
def calc(y: int) -> int:  # 太简短
    pass

class db:  # 类名应该用 PascalCase
    pass

l = 1  # 单字母变量（容易与数字混淆）
O = 0
I = 1
```

---

## 💬 注释

### 1. 块注释

```python
# ✅ 块注释应该与代码对齐，使用 # 开头
def complex_function() -> None:
    # 这是一个块注释
    # 用于解释下面的代码逻辑
    # 每行都以 # 和一个空格开头
    x = calculate_something()
    
    # 另一个块注释
    # 解释另一段逻辑
    y = process(x)
```

### 2. 行内注释

```python
# ✅ 行内注释与代码至少间隔 2 个空格
x = x + 1  # 补偿边界

# ❌ 避免无意义的行内注释
x = x + 1  # x 加 1（显而易见）
```

### 3. 文档字符串

```python
# ✅ 使用三引号文档字符串
def function_with_docstring(param1: str, param2: int) -> str:
    """一行摘要，以句号结尾。
    
    详细描述函数的功能、参数、返回值等。
    可以包含多行。
    
    Args:
        param1: 参数1的描述
        param2: 参数2的描述
    
    Returns:
        返回值的描述
    
    Raises:
        ValueError: 当 param2 为负数时
    
    Examples:
        >>> function_with_docstring("test", 5)
        'test5'
    """
    if param2 < 0:
        raise ValueError("param2 must be non-negative")
    return param1 * param2


class MyClass:
    """类的文档字符串。
    
    类的详细描述。
    
    Attributes:
        attr1: 属性1的描述
        attr2: 属性2的描述
    """
    
    def __init__(self, attr1: str, attr2: int) -> None:
        """初始化方法的文档字符串。
        
        Args:
            attr1: 参数描述
            attr2: 参数描述
        """
        self.attr1 = attr1
        self.attr2 = attr2
```

---

## 🔧 表达式和语句

### 1. 空格使用

```python
# ✅ 正确的空格使用
spam(ham[1], {eggs: 2})
x = 1
y = 2
long_variable = 3

# 函数调用
func(arg1, arg2)
dict[key]
list[index]

# 运算符周围
i = i + 1
submitted += 1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)

# ❌ 错误的空格使用
spam( ham[ 1 ], { eggs: 2 } )  # 括号内多余空格
x             = 1              # 对齐用的额外空格
y             = 2
long_variable = 3

func (arg1, arg2)  # 函数名和括号之间不要空格
dict [key]         # 同上
list [index]       # 同上

# 运算符前后不一致
i=i+1
submitted +=1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

### 2. 尾随逗号

```python
# ✅ 推荐：多行时使用尾随逗号
FILES = [
    "setup.cfg",
    "tox.ini",
    "README.md",  # 尾随逗号
]

def func(
    arg1: str,
    arg2: int,
    arg3: float,  # 尾随逗号
) -> None:
    pass

# ✅ 单行时不使用尾随逗号
FILES = ["setup.cfg", "tox.ini"]
```

### 3. 比较

```python
# ✅ 使用 is 检查 None
if value is None:
    pass

if value is not None:
    pass

# ❌ 不要使用 ==
if value == None:  # 错误
    pass

# ✅ 布尔值比较
if greeting:  # 推荐
    pass

if not greeting:  # 推荐
    pass

# ❌ 显式比较布尔值
if greeting == True:  # 不推荐
    pass

if greeting is True:  # 不推荐
    pass
```

---

## 🎯 Python 3.12+ 特定规范

### 1. 类型注解

```python
# ✅ 使用新式类型注解
def process_items(items: list[str]) -> dict[str, int]:
    return {item: len(item) for item in items}

# ✅ 使用 | 表示联合类型
def parse_value(value: str | int) -> float:
    return float(value)

# ✅ 使用 type 语句（Python 3.12+）
type Point = tuple[float, float]
type Matrix = list[list[float]]

# ❌ 避免旧式导入
from typing import List, Dict  # 不推荐（Python 3.9+）
def process_items(items: List[str]) -> Dict[str, int]:
    pass
```

### 2. match 语句格式

```python
# ✅ match 语句格式
def handle_command(command: str) -> None:
    match command.split():
        case ["quit"]:
            print("Goodbye!")
        case ["load", filename]:
            print(f"Loading {filename}")
        case ["save", filename]:
            print(f"Saving {filename}")
        case _:
            print("Unknown command")
```

---

## 🛠️ 工具支持

### 1. 自动格式化

```bash
# black - 固执的代码格式化器
pip install black
black your_file.py

# ruff format - 更快的替代品
pip install ruff
ruff format your_file.py
```

### 2. 代码检查

```bash
# ruff - 快速 Python linter
ruff check your_file.py

# flake8 - 传统 linter
flake8 your_file.py

# pylint - 全面的代码分析
pylint your_file.py
```

### 3. 配置示例

```toml
# pyproject.toml
[tool.black]
line-length = 88
target-version = ["py312"]

[tool.ruff]
line-length = 88
target-version = "py312"

[tool.ruff.lint]
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # pyflakes
    "I",   # isort
    "N",   # pep8-naming
    "UP",  # pyupgrade
    "B",   # flake8-bugbear
]

[tool.isort]
profile = "black"
line_length = 88
```

---

## 📋 完整示例

```python
"""模块文档字符串。

这个模块展示了符合 PEP 8 的代码风格。
"""

import os
import sys
from typing import Any

import numpy as np
import pandas as pd

from mypackage import mymodule


# 模块级常量
MAX_RETRIES = 3
DEFAULT_TIMEOUT = 30


class UserManager:
    """用户管理器类。
    
    管理用户的创建、更新和删除操作。
    
    Attributes:
        users: 用户字典
        max_users: 最大用户数
    """
    
    def __init__(self, max_users: int = 100) -> None:
        """初始化用户管理器。
        
        Args:
            max_users: 最大用户数，默认 100
        """
        self.users: dict[str, dict[str, Any]] = {}
        self.max_users = max_users
        self._user_count = 0
    
    def add_user(
        self,
        username: str,
        email: str,
        age: int | None = None,
    ) -> bool:
        """添加新用户。
        
        Args:
            username: 用户名
            email: 电子邮件地址
            age: 年龄（可选）
        
        Returns:
            添加成功返回 True，否则返回 False
        
        Raises:
            ValueError: 当用户已存在时
        """
        if username in self.users:
            raise ValueError(f"User {username} already exists")
        
        if self._user_count >= self.max_users:
            return False
        
        self.users[username] = {
            "email": email,
            "age": age,
            "active": True,
        }
        self._user_count += 1
        return True
    
    def get_user(self, username: str) -> dict[str, Any] | None:
        """获取用户信息。
        
        Args:
            username: 用户名
        
        Returns:
            用户信息字典，如果用户不存在则返回 None
        """
        return self.users.get(username)
    
    def _validate_user(self, user: dict[str, Any]) -> bool:
        """验证用户数据（私有方法）。
        
        Args:
            user: 用户数据字典
        
        Returns:
            验证通过返回 True，否则返回 False
        """
        required_fields = ["email", "active"]
        return all(field in user for field in required_fields)


def process_users(
    users: list[str],
    callback: callable[[str], None] | None = None,
) -> list[str]:
    """处理用户列表。
    
    对用户列表进行处理，并可选地执行回调函数。
    
    Args:
        users: 用户名列表
        callback: 可选的回调函数
    
    Returns:
        处理后的用户列表
    
    Examples:
        >>> process_users(["alice", "bob"])
        ['ALICE', 'BOB']
    """
    result = []
    
    for user in users:
        # 转换为大写
        processed = user.upper()
        result.append(processed)
        
        # 执行回调
        if callback is not None:
            callback(processed)
    
    return result


def main() -> None:
    """主函数。"""
    manager = UserManager(max_users=1000)
    
    # 添加用户
    manager.add_user(
        username="alice",
        email="alice@example.com",
        age=30,
    )
    
    # 获取用户
    user = manager.get_user("alice")
    if user is not None:
        print(f"Found user: {user}")


if __name__ == "__main__":
    main()
```

---

## 🔗 相关资源

- [PEP 8 官方文档](https://peps.python.org/pep-0008/)
- [PEP 257 - 文档字符串规范](https://peps.python.org/pep-0257/)
- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)
- [Black 文档](https://black.readthedocs.io/)
- [Ruff 文档](https://docs.astral.sh/ruff/)

---

**编写优雅的 Python 代码，从遵循 PEP 8 开始！** 📝✨
